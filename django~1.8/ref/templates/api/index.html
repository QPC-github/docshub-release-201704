
<!DOCTYPE HTML>

<html lang="en">

<head>
  <meta charset="utf-8">
  <title>The Django Template Language&#58; for Python Programmers - Django 1.8 - W3cubDocs</title>
  
  <meta name="description" content="This document explains the Django template system from a technical perspective – how it works and how to extend it. If you’re just looking for &hellip;">
  <meta name="keywords" content="django, template, language, for, python, programmers, -, django~1.8">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="http://docs.w3cub.com/django~1.8/ref/templates/api/">
  <link href="/favicon.png" rel="icon">
  <link type="text/css" rel="stylesheet" href="/assets/application-50364fff564ce3b6327021805f3f00e2957b441cf27f576a7dd4ff63bbc47047.css">
  <script type="text/javascript" src="/assets/application-db64bfd54ceb42be11af7995804cf4902548419ceb79d509b0b7d62c22d98e6f.js"></script>
  <script src="/json/django~1.8.js"></script>
  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-71174418-1']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>


</head>

<body>
	<div class="_app">
	<header class="_header">
  
  <form class="_search">
    <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
    <a class="_search-clear"></a>
    <div class="_search-tag"></div>
  </form>
  
  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/django~1.8/" class="_nav-link" title="" style="margin-left:0;">Django 1.8</a></span>
  
  <nav class="_nav">
    <a href="/app/" class="_nav-link ">App</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		<div class="_list">
			
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<div class="_page _sphinx">
				
<h1 id="the-django-template-language-for-python-programmers">The Django template language: for Python programmers</h1> <p>This document explains the Django template system from a technical perspective – how it works and how to extend it. If you’re just looking for reference on the language syntax, see <a class="reference internal" href="../language/"><span class="doc">The Django template language</span></a>.</p> <p>It assumes an understanding of templates, contexts, variables, tags, and rendering. Start with the <a class="reference internal" href="../../../topics/templates/#template-language-intro"><span class="std std-ref">introduction to the Django template language</span></a> if you aren’t familiar with these concepts.</p>  <h2 id="overview">Overview</h2> <p>Using the template system in Python is a three-step process:</p> <ol class="arabic simple"> <li>You configure an <a class="reference internal" href="#django.template.Engine" title="django.template.Engine"><code>Engine</code></a>.</li> <li>You compile template code into a <a class="reference internal" href="#django.template.Template" title="django.template.Template"><code>Template</code></a>.</li> <li>You render the template with a <a class="reference internal" href="#django.template.Context" title="django.template.Context"><code>Context</code></a>.</li> </ol> <p>Django projects generally rely on the <a class="reference internal" href="../../../topics/templates/#template-engines"><span class="std std-ref">high level, backend agnostic APIs</span></a> for each of these steps instead of the template system’s lower level APIs:</p> <ol class="arabic simple"> <li>For each <a class="reference internal" href="../../../topics/templates/#django.template.backends.django.DjangoTemplates" title="django.template.backends.django.DjangoTemplates"><code>DjangoTemplates</code></a> backend in the <a class="reference internal" href="../../settings/#std:setting-TEMPLATES"><code>TEMPLATES</code></a> setting, Django instantiates an <a class="reference internal" href="#django.template.Engine" title="django.template.Engine"><code>Engine</code></a>. <a class="reference internal" href="../../../topics/templates/#django.template.backends.django.DjangoTemplates" title="django.template.backends.django.DjangoTemplates"><code>DjangoTemplates</code></a> wraps <a class="reference internal" href="#django.template.Engine" title="django.template.Engine"><code>Engine</code></a> and adapts it to the common template backend API.</li> <li>The <a class="reference internal" href="../../../topics/templates/#module-django.template.loader" title="django.template.loader"><code>django.template.loader</code></a> module provides functions such as <a class="reference internal" href="../../../topics/templates/#django.template.loader.get_template" title="django.template.loader.get_template"><code>get_template()</code></a> for loading templates. They return a <code>django.template.backends.django.Template</code> which wraps the actual <a class="reference internal" href="#django.template.Template" title="django.template.Template"><code>django.template.Template</code></a>.</li> <li>The <code>Template</code> obtained in the previous step has a <a class="reference internal" href="../../../topics/templates/#django.template.backends.base.Template.render" title="django.template.backends.base.Template.render"><code>render()</code></a> method which marshals a context and possibly a request into a <a class="reference internal" href="#django.template.Context" title="django.template.Context"><code>Context</code></a> and delegates the rendering to the underlying <a class="reference internal" href="#django.template.Template" title="django.template.Template"><code>Template</code></a>.</li> </ol>   <h2 id="configuring-an-engine">Configuring an engine</h2> <p>If you are simply using the <a class="reference internal" href="../../../topics/templates/#django.template.backends.django.DjangoTemplates" title="django.template.backends.django.DjangoTemplates"><code>DjangoTemplates</code></a> backend, this probably isn’t the documentation you’re looking for. An instance of the <code>Engine</code> class described below is accessible using the <code>engine</code> attribute of that backend and any attribute defaults mentioned below are overridden by what’s passed by <a class="reference internal" href="../../../topics/templates/#django.template.backends.django.DjangoTemplates" title="django.template.backends.django.DjangoTemplates"><code>DjangoTemplates</code></a>.</p> <dl class="class"> <dt id="django.template.Engine">
<code>class Engine(dirs=None, app_dirs=False, allowed_include_roots=None, context_processors=None, debug=False, loaders=None, string_if_invalid='', file_charset='utf-8')</code> <a class="reference internal" href="https://docs.djangoproject.com/en/1.8/_modules/django/template/engine/#Engine" target="_blank"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
 <p>When instantiating an <code>Engine</code> all arguments must be passed as keyword arguments:</p> <ul> <li>
<p class="first"><code>dirs</code> is a list of directories where the engine should look for template source files. It is used to configure <a class="reference internal" href="#django.template.loaders.filesystem.Loader" title="django.template.loaders.filesystem.Loader"><code>filesystem.Loader</code></a>.</p> <p>It defaults to an empty list.</p> </li> <li>
<p class="first"><code>app_dirs</code> only affects the default value of <code>loaders</code>. See below.</p> <p>It defaults to <code>False</code>.</p> </li> <li>
<p class="first"><code>allowed_include_roots</code> is a list of strings representing allowed prefixes for the <code>{% ssi %}</code> template tag. This is a security measure, so that template authors can’t access files that they shouldn’t be accessing.</p> <p>For example, if <code>'allowed_include_roots'</code> is <code>['/home/html',
'/var/www']</code>, then <code>{% ssi /home/html/foo.txt %}</code> would work, but <code>{%
ssi /etc/passwd %}</code> wouldn’t.</p> <p>It defaults to an empty list.</p> <div class="deprecated"> <p><span class="versionmodified">Deprecated since version 1.8: </span><code>allowed_include_roots</code> is deprecated.</p> </div> </li> <li>
<p class="first"><code>context_processors</code> is a list of dotted Python paths to callables that are used to populate the context when a template is rendered with a request. These callables take a request object as their argument and return a <a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#dict" title="(in Python v3.6)" target="_blank"><code>dict</code></a> of items to be merged into the context.</p> <p>It defaults to an empty list.</p> <p>See <a class="reference internal" href="#django.template.RequestContext" title="django.template.RequestContext"><code>RequestContext</code></a> for more information.</p> </li> <li>
<p class="first"><code>debug</code> is a boolean that turns on/off template debug mode. If it is <code>True</code>, the template engine will store additional debug information which can be used to display a detailed report for any exception raised during template rendering.</p> <p>It defaults to <code>False</code>.</p> </li> <li>
<p class="first"><code>loaders</code> is a list of template loader classes, specified as strings. Each <code>Loader</code> class knows how to import templates from a particular source. Optionally, a tuple can be used instead of a string. The first item in the tuple should be the <code>Loader</code> class name, subsequent items are passed to the <code>Loader</code> during initialization.</p> <p>It defaults to a list containing:</p> <ul class="simple"> <li><code>'django.template.loaders.filesystem.Loader'</code></li> <li>
<code>'django.template.loaders.app_directories.Loader'</code> if and only if <code>app_dirs</code> is <code>True</code>.</li> </ul> <p>See <a class="reference internal" href="#template-loaders"><span class="std std-ref">Loader types</span></a> for details.</p> </li> <li>
<p class="first"><code>string_if_invalid</code> is the output, as a string, that the template system should use for invalid (e.g. misspelled) variables.</p> <p>It defaults to the empty string.</p> <p>See <a class="reference internal" href="#invalid-template-variables"><span class="std std-ref">How invalid variables are handled</span></a> for details.</p> </li> <li>
<p class="first"><code>file_charset</code> is the charset used to read template files on disk.</p> <p>It defaults to <code>'utf-8'</code>.</p> </li> </ul> </dd>
</dl> <dl class="staticmethod"> <dt id="django.template.Engine.get_default">
<code>static Engine.get_default()</code> <a class="reference internal" href="https://docs.djangoproject.com/en/1.8/_modules/django/template/engine/#Engine.get_default" target="_blank"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>When a Django project configures one and only one <a class="reference internal" href="../../../topics/templates/#django.template.backends.django.DjangoTemplates" title="django.template.backends.django.DjangoTemplates"><code>DjangoTemplates</code></a> engine, this method returns the underlying <a class="reference internal" href="#django.template.Engine" title="django.template.Engine"><code>Engine</code></a>. In other circumstances it will raise <a class="reference internal" href="../../exceptions/#django.core.exceptions.ImproperlyConfigured" title="django.core.exceptions.ImproperlyConfigured"><code>ImproperlyConfigured</code></a>.</p> <p>It’s required for preserving APIs that rely on a globally available, implicitly configured engine. Any other use is strongly discouraged.</p> </dd>
</dl> <dl class="method"> <dt id="django.template.Engine.from_string">
<code>Engine.from_string(template_code)</code> <a class="reference internal" href="https://docs.djangoproject.com/en/1.8/_modules/django/template/engine/#Engine.from_string" target="_blank"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Compiles the given template code and returns a <a class="reference internal" href="#django.template.Template" title="django.template.Template"><code>Template</code></a> object.</p> </dd>
</dl> <dl class="method"> <dt id="django.template.Engine.get_template">
<code>Engine.get_template(template_name)</code> <a class="reference internal" href="https://docs.djangoproject.com/en/1.8/_modules/django/template/engine/#Engine.get_template" target="_blank"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Loads a template with the given name, compiles it and returns a <a class="reference internal" href="#django.template.Template" title="django.template.Template"><code>Template</code></a> object.</p> </dd>
</dl> <dl class="method"> <dt id="django.template.Engine.select_template">
<code>Engine.select_template(self, template_name_list)</code> <a class="reference internal" href="https://docs.djangoproject.com/en/1.8/_modules/django/template/engine/#Engine.select_template" target="_blank"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Like <a class="reference internal" href="#django.template.Engine.get_template" title="django.template.Engine.get_template"><code>get_template()</code></a>, except it takes a list of names and returns the first template that was found.</p> </dd>
</dl>   <h2 id="loading-a-template">Loading a template</h2> <p>The recommended way to create a <a class="reference internal" href="#django.template.Template" title="django.template.Template"><code>Template</code></a> is by calling the factory methods of the <a class="reference internal" href="#django.template.Engine" title="django.template.Engine"><code>Engine</code></a>: <a class="reference internal" href="#django.template.Engine.get_template" title="django.template.Engine.get_template"><code>get_template()</code></a>, <a class="reference internal" href="#django.template.Engine.select_template" title="django.template.Engine.select_template"><code>select_template()</code></a> and <a class="reference internal" href="#django.template.Engine.from_string" title="django.template.Engine.from_string"><code>from_string()</code></a>.</p> <p>In a Django project where the <a class="reference internal" href="../../settings/#std:setting-TEMPLATES"><code>TEMPLATES</code></a> setting defines exactly one <a class="reference internal" href="../../../topics/templates/#django.template.backends.django.DjangoTemplates" title="django.template.backends.django.DjangoTemplates"><code>DjangoTemplates</code></a> engine, it’s possible to instantiate a <a class="reference internal" href="#django.template.Template" title="django.template.Template"><code>Template</code></a> directly.</p> <dl class="class"> <dt id="django.template.Template">
<code>class Template</code> <a class="reference internal" href="https://docs.djangoproject.com/en/1.8/_modules/django/template/base/#Template" target="_blank"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>This class lives at <code>django.template.Template</code>. The constructor takes one argument — the raw template code:</p> <pre data-language="python">from django.template import Template

template = Template("My name is {{ my_name }}.")
</pre> </dd>
</dl> <div class="admonition-behind-the-scenes admonition"> <p class="first admonition-title">Behind the scenes</p> <p>The system only parses your raw template code once – when you create the <code>Template</code> object. From then on, it’s stored internally as a tree structure for performance.</p> <p class="last">Even the parsing itself is quite fast. Most of the parsing happens via a single call to a single, short, regular expression.</p> </div>   <h2 id="rendering-a-context">Rendering a context</h2> <p>Once you have a compiled <a class="reference internal" href="#django.template.Template" title="django.template.Template"><code>Template</code></a> object, you can render a context with it. You can reuse the same template to render it several times with different contexts.</p> <dl class="class"> <dt id="django.template.Context">
<code>class Context(dict_=None, current_app=_current_app_undefined)</code> <a class="reference internal" href="https://docs.djangoproject.com/en/1.8/_modules/django/template/context/#Context" target="_blank"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>This class lives at <code>django.template.Context</code>. The constructor takes two optional arguments:</p> <ul> <li>A dictionary mapping variable names to variable values. </li> <li>
<p class="first">The name of the current application. This application name is used to help <a class="reference internal" href="../../../topics/http/urls/#topics-http-reversing-url-namespaces"><span class="std std-ref">resolve namespaced URLs</span></a>. If you’re not using namespaced URLs, you can ignore this argument.</p> <div class="deprecated"> <p><span class="versionmodified">Deprecated since version 1.8: </span>The <code>current_app</code> argument is deprecated. If you need it, you must now use a <a class="reference internal" href="#django.template.RequestContext" title="django.template.RequestContext"><code>RequestContext</code></a> instead of a <a class="reference internal" href="#django.template.Context" title="django.template.Context"><code>Context</code></a>.</p> </div> </li> </ul> <p>For details, see <a class="reference internal" href="#playing-with-context"><span class="std std-ref">Playing with Context objects</span></a> below.</p> </dd>
</dl> <dl class="method"> <dt id="django.template.Template.render">
<code>Template.render(context)</code> <a class="reference internal" href="https://docs.djangoproject.com/en/1.8/_modules/django/template/base/#Template.render" target="_blank"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Call the <a class="reference internal" href="#django.template.Template" title="django.template.Template"><code>Template</code></a> object’s <code>render()</code> method with a <a class="reference internal" href="#django.template.Context" title="django.template.Context"><code>Context</code></a> to “fill” the template:</p> <pre data-language="python">&gt;&gt;&gt; from django.template import Context, Template
&gt;&gt;&gt; template = Template("My name is {{ my_name }}.")

&gt;&gt;&gt; context = Context({"my_name": "Adrian"})
&gt;&gt;&gt; template.render(context)
"My name is Adrian."

&gt;&gt;&gt; context = Context({"my_name": "Dolores"})
&gt;&gt;&gt; template.render(context)
"My name is Dolores."
</pre> </dd>
</dl>  <h3 id="variables-and-lookups">Variables and lookups</h3> <p>Variable names must consist of any letter (A-Z), any digit (0-9), an underscore (but they must not start with an underscore) or a dot.</p> <p>Dots have a special meaning in template rendering. A dot in a variable name signifies a <strong>lookup</strong>. Specifically, when the template system encounters a dot in a variable name, it tries the following lookups, in this order:</p> <ul class="simple"> <li>Dictionary lookup. Example: <code>foo["bar"]</code>
</li> <li>Attribute lookup. Example: <code>foo.bar</code>
</li> <li>List-index lookup. Example: <code>foo[bar]</code>
</li> </ul> <p>Note that “bar” in a template expression like <code>{{ foo.bar }}</code> will be interpreted as a literal string and not using the value of the variable “bar”, if one exists in the template context.</p> <p>The template system uses the first lookup type that works. It’s short-circuit logic. Here are a few examples:</p> <pre data-language="python">&gt;&gt;&gt; from django.template import Context, Template
&gt;&gt;&gt; t = Template("My name is {{ person.first_name }}.")
&gt;&gt;&gt; d = {"person": {"first_name": "Joe", "last_name": "Johnson"}}
&gt;&gt;&gt; t.render(Context(d))
"My name is Joe."

&gt;&gt;&gt; class PersonClass: pass
&gt;&gt;&gt; p = PersonClass()
&gt;&gt;&gt; p.first_name = "Ron"
&gt;&gt;&gt; p.last_name = "Nasty"
&gt;&gt;&gt; t.render(Context({"person": p}))
"My name is Ron."

&gt;&gt;&gt; t = Template("The first stooge in the list is {{ stooges.0 }}.")
&gt;&gt;&gt; c = Context({"stooges": ["Larry", "Curly", "Moe"]})
&gt;&gt;&gt; t.render(c)
"The first stooge in the list is Larry."
</pre> <p>If any part of the variable is callable, the template system will try calling it. Example:</p> <pre data-language="python">&gt;&gt;&gt; class PersonClass2:
...     def name(self):
...         return "Samantha"
&gt;&gt;&gt; t = Template("My name is {{ person.name }}.")
&gt;&gt;&gt; t.render(Context({"person": PersonClass2}))
"My name is Samantha."
</pre> <p>Callable variables are slightly more complex than variables which only require straight lookups. Here are some things to keep in mind:</p> <ul> <li>
<p class="first">If the variable raises an exception when called, the exception will be propagated, unless the exception has an attribute <code>silent_variable_failure</code> whose value is <code>True</code>. If the exception <em>does</em> have a <code>silent_variable_failure</code> attribute whose value is <code>True</code>, the variable will render as the value of the engine’s <code>string_if_invalid</code> configuration option (an empty string, by default). Example:</p> <pre data-language="python">&gt;&gt;&gt; t = Template("My name is {{ person.first_name }}.")
&gt;&gt;&gt; class PersonClass3:
...     def first_name(self):
...         raise AssertionError("foo")
&gt;&gt;&gt; p = PersonClass3()
&gt;&gt;&gt; t.render(Context({"person": p}))
Traceback (most recent call last):
...
AssertionError: foo

&gt;&gt;&gt; class SilentAssertionError(Exception):
...     silent_variable_failure = True
&gt;&gt;&gt; class PersonClass4:
...     def first_name(self):
...         raise SilentAssertionError
&gt;&gt;&gt; p = PersonClass4()
&gt;&gt;&gt; t.render(Context({"person": p}))
"My name is ."
</pre> <p>Note that <a class="reference internal" href="../../exceptions/#django.core.exceptions.ObjectDoesNotExist" title="django.core.exceptions.ObjectDoesNotExist"><code>django.core.exceptions.ObjectDoesNotExist</code></a>, which is the base class for all Django database API <code>DoesNotExist</code> exceptions, has <code>silent_variable_failure = True</code>. So if you’re using Django templates with Django model objects, any <code>DoesNotExist</code> exception will fail silently.</p> </li> <li>A variable can only be called if it has no required arguments. Otherwise, the system will return the value of the engine’s <code>string_if_invalid</code> option. </li> </ul> <ul id="alters-data-description"> <li>
<p class="first">Obviously, there can be side effects when calling some variables, and it’d be either foolish or a security hole to allow the template system to access them.</p> <p>A good example is the <a class="reference internal" href="../../models/instances/#django.db.models.Model.delete" title="django.db.models.Model.delete"><code>delete()</code></a> method on each Django model object. The template system shouldn’t be allowed to do something like this:</p> <pre data-language="python">I will now delete this valuable data. {{ data.delete }}
</pre> <p>To prevent this, set an <code>alters_data</code> attribute on the callable variable. The template system won’t call a variable if it has <code>alters_data=True</code> set, and will instead replace the variable with <code>string_if_invalid</code>, unconditionally. The dynamically-generated <a class="reference internal" href="../../models/instances/#django.db.models.Model.delete" title="django.db.models.Model.delete"><code>delete()</code></a> and <a class="reference internal" href="../../models/instances/#django.db.models.Model.save" title="django.db.models.Model.save"><code>save()</code></a> methods on Django model objects get <code>alters_data=True</code> automatically. Example:</p> <pre data-language="python">def sensitive_function(self):
    self.database_record.delete()
sensitive_function.alters_data = True
</pre> </li> <li>Occasionally you may want to turn off this feature for other reasons, and tell the template system to leave a variable uncalled no matter what. To do so, set a <code>do_not_call_in_templates</code> attribute on the callable with the value <code>True</code>. The template system then will act as if your variable is not callable (allowing you to access attributes of the callable, for example). </li> </ul>   <h3 id="invalid-template-variables">How invalid variables are handled</h3> <p id="how-invalid-variables-are-handled">Generally, if a variable doesn’t exist, the template system inserts the value of the engine’s <code>string_if_invalid</code> configuration option, which is set to <code>''</code> (the empty string) by default.</p> <p>Filters that are applied to an invalid variable will only be applied if <code>string_if_invalid</code> is set to <code>''</code> (the empty string). If <code>string_if_invalid</code> is set to any other value, variable filters will be ignored.</p> <p>This behavior is slightly different for the <code>if</code>, <code>for</code> and <code>regroup</code> template tags. If an invalid variable is provided to one of these template tags, the variable will be interpreted as <code>None</code>. Filters are always applied to invalid variables within these template tags.</p> <p>If <code>string_if_invalid</code> contains a <code>'%s'</code>, the format marker will be replaced with the name of the invalid variable.</p> <div class="admonition-for-debug-purposes-only admonition"> <p class="first admonition-title">For debug purposes only!</p> <p>While <code>string_if_invalid</code> can be a useful debugging tool, it is a bad idea to turn it on as a ‘development default’.</p> <p>Many templates, including those in the Admin site, rely upon the silence of the template system when a non-existent variable is encountered. If you assign a value other than <code>''</code> to <code>string_if_invalid</code>, you will experience rendering problems with these templates and sites.</p> <p class="last">Generally, <code>string_if_invalid</code> should only be enabled in order to debug a specific template problem, then cleared once debugging is complete.</p> </div>   <h3 id="built-in-variables">Built-in variables</h3> <p>Every context contains <code>True</code>, <code>False</code> and <code>None</code>. As you would expect, these variables resolve to the corresponding Python objects.</p>   <h3 id="limitations-with-string-literals">Limitations with string literals</h3> <p>Django’s template language has no way to escape the characters used for its own syntax. For example, the <a class="reference internal" href="../builtins/#std:templatetag-templatetag"><code>templatetag</code></a> tag is required if you need to output character sequences like <code>{%</code> and <code>%}</code>.</p> <p>A similar issue exists if you want to include these sequences in template filter or tag arguments. For example, when parsing a block tag, Django’s template parser looks for the first occurrence of <code>%}</code> after a <code>{%</code>. This prevents the use of <code>"%}"</code> as a string literal. For example, a <code>TemplateSyntaxError</code> will be raised for the following expressions:</p> <pre data-language="python">{% include "template.html" tvar="Some string literal with %} in it." %}

{% with tvar="Some string literal with %} in it." %}{% endwith %}
</pre> <p>The same issue can be triggered by using a reserved sequence in filter arguments:</p> <pre data-language="python">{{ some.variable|default:"}}" }}
</pre> <p>If you need to use strings with these sequences, store them in template variables or use a custom template tag or filter to workaround the limitation.</p>    <h2 id="playing-with-context">Playing with Context objects</h2> <p id="playing-with-context-objects">Most of the time, you’ll instantiate <a class="reference internal" href="#django.template.Context" title="django.template.Context"><code>Context</code></a> objects by passing in a fully-populated dictionary to <code>Context()</code>. But you can add and delete items from a <code>Context</code> object once it’s been instantiated, too, using standard dictionary syntax:</p> <pre data-language="python">&gt;&gt;&gt; from django.template import Context
&gt;&gt;&gt; c = Context({"foo": "bar"})
&gt;&gt;&gt; c['foo']
'bar'
&gt;&gt;&gt; del c['foo']
&gt;&gt;&gt; c['foo']
Traceback (most recent call last):
...
KeyError: 'foo'
&gt;&gt;&gt; c['newvariable'] = 'hello'
&gt;&gt;&gt; c['newvariable']
'hello'
</pre> <dl class="method"> <dt id="django.template.Context.get">
<code>Context.get(key, otherwise=None)</code> </dt> <dd>
<p>Returns the value for <code>key</code> if <code>key</code> is in the context, else returns <code>otherwise</code>.</p> </dd>
</dl> <dl class="method"> <dt id="django.template.Context.pop">
<code>Context.pop()</code> </dt> 
</dl> <dl class="method"> <dt id="django.template.Context.push">
<code>Context.push()</code> </dt> 
</dl> <dl class="exception"> <dt id="django.template.ContextPopException">
<code>exception ContextPopException</code> <a class="reference internal" href="https://docs.djangoproject.com/en/1.8/_modules/django/template/context/#ContextPopException" target="_blank"><span class="viewcode-link">[source]</span></a>
</dt> 
</dl> <p>A <code>Context</code> object is a stack. That is, you can <code>push()</code> and <code>pop()</code> it. If you <code>pop()</code> too much, it’ll raise <code>django.template.ContextPopException</code>:</p> <pre data-language="python">&gt;&gt;&gt; c = Context()
&gt;&gt;&gt; c['foo'] = 'first level'
&gt;&gt;&gt; c.push()
{}
&gt;&gt;&gt; c['foo'] = 'second level'
&gt;&gt;&gt; c['foo']
'second level'
&gt;&gt;&gt; c.pop()
{'foo': 'second level'}
&gt;&gt;&gt; c['foo']
'first level'
&gt;&gt;&gt; c['foo'] = 'overwritten'
&gt;&gt;&gt; c['foo']
'overwritten'
&gt;&gt;&gt; c.pop()
Traceback (most recent call last):
...
ContextPopException
</pre>  <p>You can also use <code>push()</code> as a context manager to ensure a matching <code>pop()</code> is called.</p> <pre data-language="python">&gt;&gt;&gt; c = Context()
&gt;&gt;&gt; c['foo'] = 'first level'
&gt;&gt;&gt; with c.push():
...     c['foo'] = 'second level'
...     c['foo']
'second level'
&gt;&gt;&gt; c['foo']
'first level'
</pre> <p>All arguments passed to <code>push()</code> will be passed to the <code>dict</code> constructor used to build the new context level.</p> <pre data-language="python">&gt;&gt;&gt; c = Context()
&gt;&gt;&gt; c['foo'] = 'first level'
&gt;&gt;&gt; with c.push(foo='second level'):
...     c['foo']
'second level'
&gt;&gt;&gt; c['foo']
'first level'
</pre> <dl class="method"> <dt id="django.template.Context.update">
<code>Context.update(other_dict)</code> <a class="reference internal" href="https://docs.djangoproject.com/en/1.8/_modules/django/template/context/#Context.update" target="_blank"><span class="viewcode-link">[source]</span></a>
</dt> 
</dl> <p>In addition to <code>push()</code> and <code>pop()</code>, the <code>Context</code> object also defines an <code>update()</code> method. This works like <code>push()</code> but takes a dictionary as an argument and pushes that dictionary onto the stack instead of an empty one.</p> <pre data-language="python">&gt;&gt;&gt; c = Context()
&gt;&gt;&gt; c['foo'] = 'first level'
&gt;&gt;&gt; c.update({'foo': 'updated'})
{'foo': 'updated'}
&gt;&gt;&gt; c['foo']
'updated'
&gt;&gt;&gt; c.pop()
{'foo': 'updated'}
&gt;&gt;&gt; c['foo']
'first level'
</pre> <p>Using a <code>Context</code> as a stack comes in handy in <a class="reference internal" href="../../../howto/custom-template-tags/#howto-writing-custom-template-tags"><span class="std std-ref">some custom template tags</span></a>.</p> <dl class="method"> <dt id="django.template.Context.flatten">
<code>Context.flatten()</code> </dt> 
</dl>  <p>Using <code>flatten()</code> method you can get whole <code>Context</code> stack as one dictionary including builtin variables.</p> <pre data-language="python">&gt;&gt;&gt; c = Context()
&gt;&gt;&gt; c['foo'] = 'first level'
&gt;&gt;&gt; c.update({'bar': 'second level'})
{'bar': 'second level'}
&gt;&gt;&gt; c.flatten()
{'True': True, 'None': None, 'foo': 'first level', 'False': False, 'bar': 'second level'}
</pre> <p>A <code>flatten()</code> method is also internally used to make <code>Context</code> objects comparable.</p> <pre data-language="python">&gt;&gt;&gt; c1 = Context()
&gt;&gt;&gt; c1['foo'] = 'first level'
&gt;&gt;&gt; c1['bar'] = 'second level'
&gt;&gt;&gt; c2 = Context()
&gt;&gt;&gt; c2.update({'bar': 'second level', 'foo': 'first level'})
{'foo': 'first level', 'bar': 'second level'}
&gt;&gt;&gt; c1 == c2
True
</pre> <p>Result from <code>flatten()</code> can be useful in unit tests to compare <code>Context</code> against <code>dict</code>:</p> <pre data-language="python">class ContextTest(unittest.TestCase):
    def test_against_dictionary(self):
        c1 = Context()
        c1['update'] = 'value'
        self.assertEqual(c1.flatten(), {
            'True': True,
            'None': None,
            'False': False,
            'update': 'value',
        })
</pre>  <h3 id="id1">Subclassing Context: RequestContext</h3> <dl class="class" id="subclassing-context-requestcontext"> <dt id="django.template.RequestContext">
<code>class RequestContext(request, dict_=None, processors=None)</code> <a class="reference internal" href="https://docs.djangoproject.com/en/1.8/_modules/django/template/context/#RequestContext" target="_blank"><span class="viewcode-link">[source]</span></a>
</dt> 
</dl> <p>Django comes with a special <code>Context</code> class, <code>django.template.RequestContext</code>, that acts slightly differently from the normal <code>django.template.Context</code>. The first difference is that it takes an <a class="reference internal" href="../../request-response/#django.http.HttpRequest" title="django.http.HttpRequest"><code>HttpRequest</code></a> as its first argument. For example:</p> <pre data-language="python">c = RequestContext(request, {
    'foo': 'bar',
})
</pre> <p>The second difference is that it automatically populates the context with a few variables, according to the engine’s <code>context_processors</code> configuration option.</p> <p>The <code>context_processors</code> option is a list of callables – called <strong>context processors</strong> – that take a request object as their argument and return a dictionary of items to be merged into the context. In the default generated settings file, the default template engine contains the following context processors:</p> <pre data-language="python">[
    'django.template.context_processors.debug',
    'django.template.context_processors.request',
    'django.contrib.auth.context_processors.auth',
    'django.contrib.messages.context_processors.messages',
]
</pre> <div class="versionchanged"> <p>Built-in template context processors were moved from <code>django.core.context_processors</code> to <code>django.template.context_processors</code> in Django 1.8.</p> </div> <p>In addition to these, <a class="reference internal" href="#django.template.RequestContext" title="django.template.RequestContext"><code>RequestContext</code></a> always enables <code>'django.template.context_processors.csrf'</code>. This is a security related context processor required by the admin and other contrib apps, and, in case of accidental misconfiguration, it is deliberately hardcoded in and cannot be turned off in the <code>context_processors</code> option.</p> <p>Each processor is applied in order. That means, if one processor adds a variable to the context and a second processor adds a variable with the same name, the second will override the first. The default processors are explained below.</p> <div class="admonition-when-context-processors-are-applied admonition"> <p class="first admonition-title">When context processors are applied</p> <p>Context processors are applied on top of context data. This means that a context processor may overwrite variables you’ve supplied to your <a class="reference internal" href="#django.template.Context" title="django.template.Context"><code>Context</code></a> or <a class="reference internal" href="#django.template.RequestContext" title="django.template.RequestContext"><code>RequestContext</code></a>, so take care to avoid variable names that overlap with those supplied by your context processors.</p> <p>If you want context data to take priority over context processors, use the following pattern:</p> <pre data-language="python">from django.template import RequestContext

request_context = RequestContext(request)
request_context.push({"my_name": "Adrian"})
</pre> <p class="last">Django does this to allow context data to override context processors in APIs such as <a class="reference internal" href="../../../topics/http/shortcuts/#django.shortcuts.render" title="django.shortcuts.render"><code>render()</code></a> and <a class="reference internal" href="../../template-response/#django.template.response.TemplateResponse" title="django.template.response.TemplateResponse"><code>TemplateResponse</code></a>.</p> </div> <p>Also, you can give <a class="reference internal" href="#django.template.RequestContext" title="django.template.RequestContext"><code>RequestContext</code></a> a list of additional processors, using the optional, third positional argument, <code>processors</code>. In this example, the <a class="reference internal" href="#django.template.RequestContext" title="django.template.RequestContext"><code>RequestContext</code></a> instance gets a <code>ip_address</code> variable:</p> <pre data-language="python">from django.http import HttpResponse
from django.template import RequestContext

def ip_address_processor(request):
    return {'ip_address': request.META['REMOTE_ADDR']}

def some_view(request):
    # ...
    c = RequestContext(request, {
        'foo': 'bar',
    }, [ip_address_processor])
    return HttpResponse(t.render(c))
</pre>   <h3 id="context-processors">Built-in template context processors</h3> <p id="built-in-template-context-processors">Here’s what each of the built-in processors does:</p>  <h4 id="django-contrib-auth-context-processors-auth">django.contrib.auth.context_processors.auth</h4> <dl class="function"> <dt id="django.contrib.auth.context_processors.auth">
<code>auth()</code> <a class="reference internal" href="https://docs.djangoproject.com/en/1.8/_modules/django/contrib/auth/context_processors/#auth" target="_blank"><span class="viewcode-link">[source]</span></a>
</dt> 
</dl> <p>If this processor is enabled, every <code>RequestContext</code> will contain these variables:</p> <ul class="simple"> <li>
<code>user</code> – An <code>auth.User</code> instance representing the currently logged-in user (or an <code>AnonymousUser</code> instance, if the client isn’t logged in).</li> <li>
<code>perms</code> – An instance of <code>django.contrib.auth.context_processors.PermWrapper</code>, representing the permissions that the currently logged-in user has.</li> </ul>   <h4 id="django-template-context-processors-debug">django.template.context_processors.debug</h4> <dl class="function"> <dt id="django.template.context_processors.debug">
<code>debug()</code> <a class="reference internal" href="https://docs.djangoproject.com/en/1.8/_modules/django/template/context_processors/#debug" target="_blank"><span class="viewcode-link">[source]</span></a>
</dt> 
</dl> <p>If this processor is enabled, every <code>RequestContext</code> will contain these two variables – but only if your <a class="reference internal" href="../../settings/#std:setting-DEBUG"><code>DEBUG</code></a> setting is set to <code>True</code> and the request’s IP address (<code>request.META['REMOTE_ADDR']</code>) is in the <a class="reference internal" href="../../settings/#std:setting-INTERNAL_IPS"><code>INTERNAL_IPS</code></a> setting:</p> <ul class="simple"> <li>
<code>debug</code> – <code>True</code>. You can use this in templates to test whether you’re in <a class="reference internal" href="../../settings/#std:setting-DEBUG"><code>DEBUG</code></a> mode.</li> <li>
<code>sql_queries</code> – A list of <code>{'sql': ..., 'time': ...}</code> dictionaries, representing every SQL query that has happened so far during the request and how long it took. The list is in order by query and lazily generated on access.</li> </ul>   <h4 id="django-template-context-processors-i18n">django.template.context_processors.i18n</h4> <p>If this processor is enabled, every <code>RequestContext</code> will contain these two variables:</p> <ul class="simple"> <li>
<code>LANGUAGES</code> – The value of the <a class="reference internal" href="../../settings/#std:setting-LANGUAGES"><code>LANGUAGES</code></a> setting.</li> <li>
<code>LANGUAGE_CODE</code> – <code>request.LANGUAGE_CODE</code>, if it exists. Otherwise, the value of the <a class="reference internal" href="../../settings/#std:setting-LANGUAGE_CODE"><code>LANGUAGE_CODE</code></a> setting.</li> </ul> <p>See <a class="reference internal" href="../../../topics/i18n/"><span class="doc">Internationalization and localization</span></a> for more.</p>   <h4 id="django-template-context-processors-media">django.template.context_processors.media</h4> <p>If this processor is enabled, every <code>RequestContext</code> will contain a variable <code>MEDIA_URL</code>, providing the value of the <a class="reference internal" href="../../settings/#std:setting-MEDIA_URL"><code>MEDIA_URL</code></a> setting.</p>   <h4 id="django-template-context-processors-static">django.template.context_processors.static</h4> <dl class="function"> <dt id="django.template.context_processors.static">
<code>static()</code> <a class="reference internal" href="https://docs.djangoproject.com/en/1.8/_modules/django/template/context_processors/#static" target="_blank"><span class="viewcode-link">[source]</span></a>
</dt> 
</dl> <p>If this processor is enabled, every <code>RequestContext</code> will contain a variable <code>STATIC_URL</code>, providing the value of the <a class="reference internal" href="../../settings/#std:setting-STATIC_URL"><code>STATIC_URL</code></a> setting.</p>   <h4 id="django-template-context-processors-csrf">django.template.context_processors.csrf</h4> <p>This processor adds a token that is needed by the <a class="reference internal" href="../builtins/#std:templatetag-csrf_token"><code>csrf_token</code></a> template tag for protection against <a class="reference internal" href="../../csrf/"><span class="doc">Cross Site Request Forgeries</span></a>.</p>   <h4 id="django-template-context-processors-request">django.template.context_processors.request</h4> <p>If this processor is enabled, every <code>RequestContext</code> will contain a variable <code>request</code>, which is the current <a class="reference internal" href="../../request-response/#django.http.HttpRequest" title="django.http.HttpRequest"><code>HttpRequest</code></a>.</p>   <h4 id="django-contrib-messages-context-processors-messages">django.contrib.messages.context_processors.messages</h4> <p>If this processor is enabled, every <code>RequestContext</code> will contain these two variables:</p> <ul class="simple"> <li>
<code>messages</code> – A list of messages (as strings) that have been set via the <a class="reference internal" href="../../contrib/messages/"><span class="doc">messages framework</span></a>.</li> <li>
<code>DEFAULT_MESSAGE_LEVELS</code> – A mapping of the message level names to <a class="reference internal" href="../../contrib/messages/#message-level-constants"><span class="std std-ref">their numeric value</span></a>.</li> </ul> <div class="versionchanged"> <p>The <code>DEFAULT_MESSAGE_LEVELS</code> variable was added.</p> </div>    <h3 id="writing-your-own-context-processors">Writing your own context processors</h3> <p>A context processor has a very simple interface: It’s just a Python function that takes one argument, an <a class="reference internal" href="../../request-response/#django.http.HttpRequest" title="django.http.HttpRequest"><code>HttpRequest</code></a> object, and returns a dictionary that gets added to the template context. Each context processor <em>must</em> return a dictionary.</p> <p>Custom context processors can live anywhere in your code base. All Django cares about is that your custom context processors are pointed to by the <code>'context_processors'</code> option in your <a class="reference internal" href="../../settings/#std:setting-TEMPLATES"><code>TEMPLATES</code></a> setting — or the <code>context_processors</code> argument of <a class="reference internal" href="#django.template.Engine" title="django.template.Engine"><code>Engine</code></a> if you’re using it directly.</p>    <h2 id="loading-templates">Loading templates</h2> <p>Generally, you’ll store templates in files on your filesystem rather than using the low-level <a class="reference internal" href="#django.template.Template" title="django.template.Template"><code>Template</code></a> API yourself. Save templates in a directory specified as a <strong>template directory</strong>.</p> <p>Django searches for template directories in a number of places, depending on your template loading settings (see “Loader types” below), but the most basic way of specifying template directories is by using the <a class="reference internal" href="../../settings/#std:setting-TEMPLATES-DIRS"><code>DIRS</code></a> option.</p>  <h3 id="the-dirs-option">The <a class="reference internal" href="../../settings/#std:setting-TEMPLATES-DIRS"><code>DIRS</code></a> option</h3> <div class="versionchanged"> <p>This value used to be defined by the <code>TEMPLATE_DIRS</code> setting.</p> </div> <p>Tell Django what your template directories are by using the <a class="reference internal" href="../../settings/#std:setting-TEMPLATES-DIRS"><code>DIRS</code></a> option in the <a class="reference internal" href="../../settings/#std:setting-TEMPLATES"><code>TEMPLATES</code></a> setting in your settings file — or the <code>dirs</code> argument of <a class="reference internal" href="#django.template.Engine" title="django.template.Engine"><code>Engine</code></a>. This should be set to a list of strings that contain full paths to your template directories:</p> <pre data-language="python">TEMPLATES = [
    {
        'BACKEND': 'django.template.backends.django.DjangoTemplates',
        'DIRS': [
            '/home/html/templates/lawrence.com',
            '/home/html/templates/default',
        ],
    },
]
</pre> <p>Your templates can go anywhere you want, as long as the directories and templates are readable by the Web server. They can have any extension you want, such as <code>.html</code> or <code>.txt</code>, or they can have no extension at all.</p> <p>Note that these paths should use Unix-style forward slashes, even on Windows.</p>   <h3 id="template-loaders">Loader types</h3> <p id="loader-types">By default, Django uses a filesystem-based template loader, but Django comes with a few other template loaders, which know how to load templates from other sources.</p> <p>Some of these other loaders are disabled by default, but you can activate them by adding a <code>'loaders'</code> option to your <code>DjangoTemplates</code> backend in the <a class="reference internal" href="../../settings/#std:setting-TEMPLATES"><code>TEMPLATES</code></a> setting or passing a <code>loaders</code> argument to <a class="reference internal" href="#django.template.Engine" title="django.template.Engine"><code>Engine</code></a>. <code>loaders</code> should be a list of strings or tuples, where each represents a template loader class. Here are the template loaders that come with Django:</p> <p><code>django.template.loaders.filesystem.Loader</code></p> <dl class="class"> <dt id="django.template.loaders.filesystem.Loader">
<code>class filesystem.Loader</code> </dt> <dd>
<p>Loads templates from the filesystem, according to <a class="reference internal" href="../../settings/#std:setting-TEMPLATES-DIRS"><code>DIRS</code></a>.</p> <p>This loader is enabled by default. However it won’t find any templates until you set <a class="reference internal" href="../../settings/#std:setting-TEMPLATES-DIRS"><code>DIRS</code></a> to a non-empty list:</p> <pre data-language="python">TEMPLATES = [{
    'BACKEND': 'django.template.backends.django.DjangoTemplates',
    'DIRS': [os.path.join(BASE_DIR, 'templates')],
}]
</pre> </dd>
</dl> <p><code>django.template.loaders.app_directories.Loader</code></p> <dl class="class"> <dt id="django.template.loaders.app_directories.Loader">
<code>class app_directories.Loader</code> </dt> <dd>
<p>Loads templates from Django apps on the filesystem. For each app in <a class="reference internal" href="../../settings/#std:setting-INSTALLED_APPS"><code>INSTALLED_APPS</code></a>, the loader looks for a <code>templates</code> subdirectory. If the directory exists, Django looks for templates in there.</p> <p>This means you can store templates with your individual apps. This also makes it easy to distribute Django apps with default templates.</p> <p>For example, for this setting:</p> <pre data-language="python">INSTALLED_APPS = ('myproject.polls', 'myproject.music')
</pre> <p>...then <code>get_template('foo.html')</code> will look for <code>foo.html</code> in these directories, in this order:</p> <ul class="simple"> <li><code>/path/to/myproject/polls/templates/</code></li> <li><code>/path/to/myproject/music/templates/</code></li> </ul> <p>... and will use the one it finds first.</p> <p>The order of <a class="reference internal" href="../../settings/#std:setting-INSTALLED_APPS"><code>INSTALLED_APPS</code></a> is significant! For example, if you want to customize the Django admin, you might choose to override the standard <code>admin/base_site.html</code> template, from <code>django.contrib.admin</code>, with your own <code>admin/base_site.html</code> in <code>myproject.polls</code>. You must then make sure that your <code>myproject.polls</code> comes <em>before</em> <code>django.contrib.admin</code> in <a class="reference internal" href="../../settings/#std:setting-INSTALLED_APPS"><code>INSTALLED_APPS</code></a>, otherwise <code>django.contrib.admin</code>’s will be loaded first and yours will be ignored.</p> <p>Note that the loader performs an optimization when it first runs: it caches a list of which <a class="reference internal" href="../../settings/#std:setting-INSTALLED_APPS"><code>INSTALLED_APPS</code></a> packages have a <code>templates</code> subdirectory.</p> <p>You can enable this loader simply by setting <a class="reference internal" href="../../settings/#std:setting-TEMPLATES-APP_DIRS"><code>APP_DIRS</code></a> to <code>True</code>:</p> <pre data-language="python">TEMPLATES = [{
    'BACKEND': 'django.template.backends.django.DjangoTemplates',
    'APP_DIRS': True,
}]
</pre> </dd>
</dl> <p><code>django.template.loaders.eggs.Loader</code></p> <dl class="class"> <dt id="django.template.loaders.eggs.Loader">
<code>class eggs.Loader</code> </dt> <dd>
<p>Just like <code>app_directories</code> above, but it loads templates from Python eggs rather than from the filesystem.</p> <p>This loader is disabled by default.</p> </dd>
</dl> <p><code>django.template.loaders.cached.Loader</code></p> <dl class="class"> <dt id="django.template.loaders.cached.Loader">
<code>class cached.Loader</code> </dt> <dd>
<p>By default, the templating system will read and compile your templates every time they need to be rendered. While the Django templating system is quite fast, the overhead from reading and compiling templates can add up.</p> <p>The cached template loader is a class-based loader that you configure with a list of other loaders that it should wrap. The wrapped loaders are used to locate unknown templates when they are first encountered. The cached loader then stores the compiled <code>Template</code> in memory. The cached <code>Template</code> instance is returned for subsequent requests to load the same template.</p> <p>For example, to enable template caching with the <code>filesystem</code> and <code>app_directories</code> template loaders you might use the following settings:</p> <pre data-language="python">TEMPLATES = [{
    'BACKEND': 'django.template.backends.django.DjangoTemplates',
    'DIRS': [os.path.join(BASE_DIR, 'templates')],
    'OPTIONS': {
        'loaders': [
            ('django.template.loaders.cached.Loader', [
                'django.template.loaders.filesystem.Loader',
                'django.template.loaders.app_directories.Loader',
            ]),
        ],
    },
}]
</pre> <div class="admonition note"> <p class="first admonition-title">Note</p> <p class="last">All of the built-in Django template tags are safe to use with the cached loader, but if you’re using custom template tags that come from third party packages, or that you wrote yourself, you should ensure that the <code>Node</code> implementation for each tag is thread-safe. For more information, see <a class="reference internal" href="../../../howto/custom-template-tags/#template-tag-thread-safety"><span class="std std-ref">template tag thread safety considerations</span></a>.</p> </div> <p>This loader is disabled by default.</p> </dd>
</dl> <p><code>django.template.loaders.locmem.Loader</code></p>  <dl class="class"> <dt id="django.template.loaders.locmem.Loader">
<code>class locmem.Loader</code> </dt> <dd>
<p>Loads templates from a Python dictionary. This is useful for testing.</p> <p>This loader takes a dictionary of templates as its first argument:</p> <pre data-language="python">TEMPLATES = [{
    'BACKEND': 'django.template.backends.django.DjangoTemplates',
    'OPTIONS': {
        'loaders': [
            ('django.template.loaders.locmem.Loader', {
                'index.html': 'content here',
            }),
        ],
    },
}]
</pre> <p>This loader is disabled by default.</p> </dd>
</dl> <p>Django uses the template loaders in order according to the <code>'loaders'</code> option. It uses each loader until a loader finds a match.</p>   <h3 id="custom-template-loaders">Custom loaders</h3> <p id="custom-loaders">Custom <code>Loader</code> classes should inherit from <code>django.template.loaders.base.Loader</code> and override the <code>load_template_source()</code> method, which takes a <code>template_name</code> argument, loads the template from disk (or elsewhere), and returns a tuple: <code>(template_string, template_origin)</code>.</p> <div class="versionchanged"> <p><code>django.template.loaders.base.Loader</code> used to be defined at <code>django.template.loader.BaseLoader</code>.</p> </div> <p>The <code>load_template()</code> method of the <code>Loader</code> class retrieves the template string by calling <code>load_template_source()</code>, instantiates a <code>Template</code> from the template source, and returns a tuple: <code>(template, template_origin)</code>.</p>    <h2 id="template-origin">Template origin</h2>  <p>When an <a class="reference internal" href="#django.template.Engine" title="django.template.Engine"><code>Engine</code></a> is initialized with <code>debug=True</code>, its templates have an <code>origin</code> attribute depending on the source they are loaded from. For engines initialized by Django, <code>debug</code> defaults to the value of <a class="reference internal" href="../../settings/#std:setting-DEBUG"><code>DEBUG</code></a>.</p> <dl class="class"> <dt id="django.template.loader.LoaderOrigin">
<code>class loader.LoaderOrigin</code> </dt> <dd>
<p>Templates created from a template loader will use the <code>django.template.loader.LoaderOrigin</code> class.</p> <dl class="attribute"> <dt id="django.template.loader.LoaderOrigin.name">
<code>name</code> </dt> <dd>
<p>The path to the template as returned by the template loader. For loaders that read from the file system, this is the full path to the template.</p> </dd>
</dl> <dl class="attribute"> <dt id="django.template.loader.LoaderOrigin.loadname">
<code>loadname</code> </dt> <dd>
<p>The relative path to the template as passed into the template loader.</p> </dd>
</dl> </dd>
</dl> <dl class="class"> <dt id="django.template.StringOrigin">
<code>class StringOrigin</code> <a class="reference internal" href="https://docs.djangoproject.com/en/1.8/_modules/django/template/base/#StringOrigin" target="_blank"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Templates created from a <code>Template</code> class will use the <code>django.template.StringOrigin</code> class.</p> <dl class="attribute"> <dt id="django.template.StringOrigin.source">
<code>source</code> </dt> <dd>
<p>The string used to create the template.</p> </dd>
</dl> </dd>
</dl>
<div class="_attribution">
  <p class="_attribution-p">
    © Django Software Foundation and individual contributors<br>Licensed under the BSD License.<br>
    <a href="https://docs.djangoproject.com/en/1.8/ref/templates/api/" class="_attribution-link" target="_blank">https://docs.djangoproject.com/en/1.8/ref/templates/api/</a>
  </p>
</div>

			</div>
		</div>
	</section>

	</div>
</body>
</html>
