
<!DOCTYPE HTML>

<html lang="en">

<head>
  <meta charset="utf-8">
  <title>pandas.merge_asof() - Pandas 0.19 - W3cubDocs</title>
  
  <meta name="description" content=" Perform an asof merge. This is similar to a left-join except that we match on nearest key rather than equal keys. ">
  <meta name="keywords" content="pandas, merge, asof, -, pandas~0.19">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="http://docs.w3cub.com/pandas~0.19/generated/pandas.merge_asof/">
  <link href="/favicon.png" rel="icon">
  <link type="text/css" rel="stylesheet" href="/assets/application-50364fff564ce3b6327021805f3f00e2957b441cf27f576a7dd4ff63bbc47047.css">
  <script type="text/javascript" src="/assets/application-db64bfd54ceb42be11af7995804cf4902548419ceb79d509b0b7d62c22d98e6f.js"></script>
  <script src="/json/pandas~0.19.js"></script>
  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-71174418-1']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>


</head>

<body>
	<div class="_app">
	<header class="_header">
  
  <form class="_search">
    <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
    <a class="_search-clear"></a>
    <div class="_search-tag"></div>
  </form>
  
  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/pandas~0.19/" class="_nav-link" title="" style="margin-left:0;">pandas 0.19</a></span>
  
  <nav class="_nav">
    <a href="/app/" class="_nav-link ">App</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		<div class="_list">
			
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<div class="_page _sphinx">
				
<h1 id="pandas-merge-asof">pandas.merge_asof</h1> <dl class="function"> <dt id="pandas.merge_asof">
<code>pandas.merge_asof(left, right, on=None, left_on=None, right_on=None, left_index=False, right_index=False, by=None, left_by=None, right_by=None, suffixes=('_x', '_y'), tolerance=None, allow_exact_matches=True)</code> <a class="reference external" href="http://github.com/pandas-dev/pandas/blob/v0.19.2/pandas/tools/merge.py#L263-L471" target="_blank"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Perform an asof merge. This is similar to a left-join except that we match on nearest key rather than equal keys.</p> <p>For each row in the left DataFrame, we select the last row in the right DataFrame whose ‘on’ key is less than or equal to the left’s key. Both DataFrames must be sorted by the key.</p> <p>Optionally match on equivalent keys with ‘by’ before searching for nearest match with ‘on’.</p> <div class="versionadded"> <p><span class="versionmodified">New in version 0.19.0.</span></p> </div> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr class="field-odd field">
<th class="field-name">Parameters:</th>
<td class="field-body">
<p class="first"><strong>left</strong> : DataFrame</p> <p><strong>right</strong> : DataFrame</p> <p><strong>on</strong> : label</p>  <p>Field name to join on. Must be found in both DataFrames. The data MUST be ordered. Furthermore this must be a numeric column, such as datetimelike, integer, or float. On or left_on/right_on must be given.</p>  <p><strong>left_on</strong> : label</p>  <p>Field name to join on in left DataFrame.</p>  <p><strong>right_on</strong> : label</p>  <p>Field name to join on in right DataFrame.</p>  <p><strong>left_index</strong> : boolean</p>  <p>Use the index of the left DataFrame as the join key.</p> <div class="versionadded"> <p><span class="versionmodified">New in version 0.19.2.</span></p> </div>  <p><strong>right_index</strong> : boolean</p>  <p>Use the index of the right DataFrame as the join key.</p> <div class="versionadded"> <p><span class="versionmodified">New in version 0.19.2.</span></p> </div>  <p><strong>by</strong> : column name or list of column names</p>  <p>Match on these columns before performing merge operation.</p>  <p><strong>left_by</strong> : column name</p>  <p>Field names to match on in the left DataFrame.</p> <div class="versionadded"> <p><span class="versionmodified">New in version 0.19.2.</span></p> </div>  <p><strong>right_by</strong> : column name</p>  <p>Field names to match on in the right DataFrame.</p> <div class="versionadded"> <p><span class="versionmodified">New in version 0.19.2.</span></p> </div>  <p><strong>suffixes</strong> : 2-length sequence (tuple, list, ...)</p>  <p>Suffix to apply to overlapping column names in the left and right side, respectively</p>  <p><strong>tolerance</strong> : integer or Timedelta, optional, default None</p>  <p>select asof tolerance within this range; must be compatible to the merge index.</p>  <p><strong>allow_exact_matches</strong> : boolean, default True</p>  <ul class="simple"> <li>If True, allow matching the same ‘on’ value (i.e. less-than-or-equal-to)</li> <li>If False, don’t match the same ‘on’ value (i.e., stricly less-than)</li> </ul>  </td> </tr> <tr class="field-even field">
<th class="field-name">Returns:</th>
<td class="field-body">
<p class="first last"><strong>merged</strong> : DataFrame</p> </td> </tr>  </table> <div class="admonition seealso"> <p class="first admonition-title">See also</p> <p class="last"><a class="reference internal" href="../pandas.merge/#pandas.merge" title="pandas.merge"><code>merge</code></a>, <a class="reference internal" href="../pandas.merge_ordered/#pandas.merge_ordered" title="pandas.merge_ordered"><code>merge_ordered</code></a></p> </div> <h4 class="rubric">Examples</h4> <pre data-language="python">&gt;&gt;&gt; left
    a left_val
0   1        a
1   5        b
2  10        c
</pre> <pre data-language="python">&gt;&gt;&gt; right
   a  right_val
0  1          1
1  2          2
2  3          3
3  6          6
4  7          7
</pre> <pre data-language="python">&gt;&gt;&gt; pd.merge_asof(left, right, on='a')
    a left_val  right_val
0   1        a          1
1   5        b          3
2  10        c          7
</pre> <pre data-language="python">&gt;&gt;&gt; pd.merge_asof(left, right, on='a', allow_exact_matches=False)
    a left_val  right_val
0   1        a        NaN
1   5        b        3.0
2  10        c        7.0
</pre> <p>For this example, we can achieve a similar result thru <code>pd.merge_ordered()</code>, though its not nearly as performant.</p> <pre data-language="python">&gt;&gt;&gt; (pd.merge_ordered(left, right, on='a')
...    .ffill()
...    .drop_duplicates(['left_val'])
... )
    a left_val  right_val
0   1        a        1.0
3   5        b        3.0
6  10        c        7.0
</pre> <p>We can use indexed DataFrames as well.</p> <pre data-language="python">&gt;&gt;&gt; left
   left_val
1         a
5         b
10        c
</pre> <pre data-language="python">&gt;&gt;&gt; right
   right_val
1          1
2          2
3          3
6          6
7          7
</pre> <pre data-language="python">&gt;&gt;&gt; pd.merge_asof(left, right, left_index=True, right_index=True)
   left_val  right_val
1         a          1
5         b          3
10        c          7
</pre> <p>Here is a real-world times-series example</p> <pre data-language="python">&gt;&gt;&gt; quotes
                     time ticker     bid     ask
0 2016-05-25 13:30:00.023   GOOG  720.50  720.93
1 2016-05-25 13:30:00.023   MSFT   51.95   51.96
2 2016-05-25 13:30:00.030   MSFT   51.97   51.98
3 2016-05-25 13:30:00.041   MSFT   51.99   52.00
4 2016-05-25 13:30:00.048   GOOG  720.50  720.93
5 2016-05-25 13:30:00.049   AAPL   97.99   98.01
6 2016-05-25 13:30:00.072   GOOG  720.50  720.88
7 2016-05-25 13:30:00.075   MSFT   52.01   52.03
</pre> <pre data-language="python">&gt;&gt;&gt; trades
                     time ticker   price  quantity
0 2016-05-25 13:30:00.023   MSFT   51.95        75
1 2016-05-25 13:30:00.038   MSFT   51.95       155
2 2016-05-25 13:30:00.048   GOOG  720.77       100
3 2016-05-25 13:30:00.048   GOOG  720.92       100
4 2016-05-25 13:30:00.048   AAPL   98.00       100
</pre> <p>By default we are taking the asof of the quotes</p> <pre data-language="python">&gt;&gt;&gt; pd.merge_asof(trades, quotes,
...                       on='time',
...                       by='ticker')
                     time ticker   price  quantity     bid     ask
0 2016-05-25 13:30:00.023   MSFT   51.95        75   51.95   51.96
1 2016-05-25 13:30:00.038   MSFT   51.95       155   51.97   51.98
2 2016-05-25 13:30:00.048   GOOG  720.77       100  720.50  720.93
3 2016-05-25 13:30:00.048   GOOG  720.92       100  720.50  720.93
4 2016-05-25 13:30:00.048   AAPL   98.00       100     NaN     NaN
</pre> <p>We only asof within 2ms betwen the quote time and the trade time</p> <pre data-language="python">&gt;&gt;&gt; pd.merge_asof(trades, quotes,
...                       on='time',
...                       by='ticker',
...                       tolerance=pd.Timedelta('2ms'))
                     time ticker   price  quantity     bid     ask
0 2016-05-25 13:30:00.023   MSFT   51.95        75   51.95   51.96
1 2016-05-25 13:30:00.038   MSFT   51.95       155     NaN     NaN
2 2016-05-25 13:30:00.048   GOOG  720.77       100  720.50  720.93
3 2016-05-25 13:30:00.048   GOOG  720.92       100  720.50  720.93
4 2016-05-25 13:30:00.048   AAPL   98.00       100     NaN     NaN
</pre> <p>We only asof within 10ms betwen the quote time and the trade time and we exclude exact matches on time. However <em>prior</em> data will propogate forward</p> <pre data-language="python">&gt;&gt;&gt; pd.merge_asof(trades, quotes,
...                       on='time',
...                       by='ticker',
...                       tolerance=pd.Timedelta('10ms'),
...                       allow_exact_matches=False)
                     time ticker   price  quantity     bid     ask
0 2016-05-25 13:30:00.023   MSFT   51.95        75     NaN     NaN
1 2016-05-25 13:30:00.038   MSFT   51.95       155   51.97   51.98
2 2016-05-25 13:30:00.048   GOOG  720.77       100  720.50  720.93
3 2016-05-25 13:30:00.048   GOOG  720.92       100  720.50  720.93
4 2016-05-25 13:30:00.048   AAPL   98.00       100     NaN     NaN
</pre> </dd>
</dl>
<div class="_attribution">
  <p class="_attribution-p">
    © 2011–2012 Lambda Foundry, Inc. and PyData Development Team<br>© 2008–2011 AQR Capital Management, LLC<br>© 2008–2014 the pandas development team<br>Licensed under the 3-clause BSD License.<br>
    <a href="http://pandas.pydata.org/pandas-docs/version/0.19.2/generated/pandas.merge_asof.html" class="_attribution-link" target="_blank">http://pandas.pydata.org/pandas-docs/version/0.19.2/generated/pandas.merge_asof.html</a>
  </p>
</div>

			</div>
		</div>
	</section>

	</div>
</body>
</html>
