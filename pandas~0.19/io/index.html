
<!DOCTYPE HTML>

<html lang="en">

<head>
  <meta charset="utf-8">
  <title>23. IO Tools (Text, CSV, HDF5, ...) - Pandas 0.19 - W3cubDocs</title>
  
  <meta name="description" content=" The pandas I&#47;O API is a set of top level reader functions accessed like pd.read_csv() that generally return a pandas object. ">
  <meta name="keywords" content="io, tools, text, csv, hdf, -, pandas, pandas~0.19">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="http://docs.w3cub.com/pandas~0.19/io/">
  <link href="/favicon.png" rel="icon">
  <link type="text/css" rel="stylesheet" href="/assets/application-50364fff564ce3b6327021805f3f00e2957b441cf27f576a7dd4ff63bbc47047.css">
  <script type="text/javascript" src="/assets/application-db64bfd54ceb42be11af7995804cf4902548419ceb79d509b0b7d62c22d98e6f.js"></script>
  <script src="/json/pandas~0.19.js"></script>
  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-71174418-1']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>


</head>

<body>
	<div class="_app">
	<header class="_header">
  
  <form class="_search">
    <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
    <a class="_search-clear"></a>
    <div class="_search-tag"></div>
  </form>
  
  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/pandas~0.19/" class="_nav-link" title="" style="margin-left:0;">pandas 0.19</a></span>
  
  <nav class="_nav">
    <a href="/app/" class="_nav-link ">App</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		<div class="_list">
			
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<div class="_page _sphinx">
				
<h1 id="io">IO Tools (Text, CSV, HDF5, ...)</h1> <p id="io-tools-text-csv-hdf5">The pandas I/O API is a set of top level <code>reader</code> functions accessed like <code>pd.read_csv()</code> that generally return a <code>pandas</code> object.</p>  <ul class="simple"> <li><a class="reference internal" href="#io-read-csv-table"><span class="std std-ref">read_csv</span></a></li> <li><a class="reference internal" href="#io-excel-reader"><span class="std std-ref">read_excel</span></a></li> <li><a class="reference internal" href="#io-hdf5"><span class="std std-ref">read_hdf</span></a></li> <li><a class="reference internal" href="#io-sql"><span class="std std-ref">read_sql</span></a></li> <li><a class="reference internal" href="#io-json-reader"><span class="std std-ref">read_json</span></a></li> <li>
<a class="reference internal" href="#io-msgpack"><span class="std std-ref">read_msgpack</span></a> (experimental)</li> <li><a class="reference internal" href="#io-read-html"><span class="std std-ref">read_html</span></a></li> <li>
<a class="reference internal" href="#io-bigquery-reader"><span class="std std-ref">read_gbq</span></a> (experimental)</li> <li><a class="reference internal" href="#io-stata-reader"><span class="std std-ref">read_stata</span></a></li> <li><a class="reference internal" href="#io-sas-reader"><span class="std std-ref">read_sas</span></a></li> <li><a class="reference internal" href="#io-clipboard"><span class="std std-ref">read_clipboard</span></a></li> <li><a class="reference internal" href="#io-pickle"><span class="std std-ref">read_pickle</span></a></li> </ul>  <p>The corresponding <code>writer</code> functions are object methods that are accessed like <code>df.to_csv()</code></p>  <ul class="simple"> <li><a class="reference internal" href="#io-store-in-csv"><span class="std std-ref">to_csv</span></a></li> <li><a class="reference internal" href="#io-excel-writer"><span class="std std-ref">to_excel</span></a></li> <li><a class="reference internal" href="#io-hdf5"><span class="std std-ref">to_hdf</span></a></li> <li><a class="reference internal" href="#io-sql"><span class="std std-ref">to_sql</span></a></li> <li><a class="reference internal" href="#io-json-writer"><span class="std std-ref">to_json</span></a></li> <li>
<a class="reference internal" href="#io-msgpack"><span class="std std-ref">to_msgpack</span></a> (experimental)</li> <li><a class="reference internal" href="#io-html"><span class="std std-ref">to_html</span></a></li> <li>
<a class="reference internal" href="#io-bigquery-writer"><span class="std std-ref">to_gbq</span></a> (experimental)</li> <li><a class="reference internal" href="#io-stata-writer"><span class="std std-ref">to_stata</span></a></li> <li><a class="reference internal" href="#io-clipboard"><span class="std std-ref">to_clipboard</span></a></li> <li><a class="reference internal" href="#io-pickle"><span class="std std-ref">to_pickle</span></a></li> </ul>  <p><a class="reference internal" href="#io-perf"><span class="std std-ref">Here</span></a> is an informal performance comparison for some of these IO methods.</p> <div class="admonition note"> <p class="first admonition-title">Note</p> <p class="last">For examples that use the <code>StringIO</code> class, make sure you import it according to your Python version, i.e. <code>from StringIO import StringIO</code> for Python 2 and <code>from io import StringIO</code> for Python 3.</p> </div>  <h2 id="io-read-csv-table">CSV &amp; Text files</h2> <p id="csv-text-files">The two workhorse functions for reading text files (a.k.a. flat files) are <a class="reference internal" href="../generated/pandas.read_csv/#pandas.read_csv" title="pandas.read_csv"><code>read_csv()</code></a> and <a class="reference internal" href="../generated/pandas.read_table/#pandas.read_table" title="pandas.read_table"><code>read_table()</code></a>. They both use the same parsing code to intelligently convert tabular data into a DataFrame object. See the <a class="reference internal" href="../cookbook/#cookbook-csv"><span class="std std-ref">cookbook</span></a> for some advanced strategies.</p>  <h3 id="parsing-options">Parsing options</h3> <p><a class="reference internal" href="../generated/pandas.read_csv/#pandas.read_csv" title="pandas.read_csv"><code>read_csv()</code></a> and <a class="reference internal" href="../generated/pandas.read_table/#pandas.read_table" title="pandas.read_table"><code>read_table()</code></a> accept the following arguments:</p>  <h4 id="basic">Basic</h4> <dl class="docutils"> <dt>filepath_or_buffer</dt> <span class="classifier-delimiter">:</span> <span class="classifier">various</span><dd>Either a path to a file (a <a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.6)" target="_blank"><code>str</code></a>, <a class="reference external" href="https://docs.python.org/3/library/pathlib.html#pathlib.Path" title="(in Python v3.6)" target="_blank"><code>pathlib.Path</code></a>, or <code>py._path.local.LocalPath</code>), URL (including http, ftp, and S3 locations), or any object with a <code>read()</code> method (such as an open file or <a class="reference external" href="https://docs.python.org/3/library/io.html#io.StringIO" title="(in Python v3.6)" target="_blank"><code>StringIO</code></a>).</dd> <dt>sep</dt> <span class="classifier-delimiter">:</span> <span class="classifier">str, defaults to <code>','</code> for <a class="reference internal" href="../generated/pandas.read_csv/#pandas.read_csv" title="pandas.read_csv"><code>read_csv()</code></a>, <code>\t</code> for <a class="reference internal" href="../generated/pandas.read_table/#pandas.read_table" title="pandas.read_table"><code>read_table()</code></a></span><dd>Delimiter to use. If sep is <code>None</code>, will try to automatically determine this. Separators longer than 1 character and different from <code>'\s+'</code> will be interpreted as regular expressions, will force use of the python parsing engine and will ignore quotes in the data. Regex example: <code>'\\r\\t'</code>.</dd> <dt>delimiter</dt> <span class="classifier-delimiter">:</span> <span class="classifier">str, default <code>None</code></span><dd>Alternative argument name for sep.</dd> <dt>delim_whitespace</dt> <span class="classifier-delimiter">:</span> <span class="classifier">boolean, default False</span><dd>
<p class="first">Specifies whether or not whitespace (e.g. <code>' '</code> or <code>'\t'</code>) will be used as the delimiter. Equivalent to setting <code>sep='\s+'</code>. If this option is set to True, nothing should be passed in for the <code>delimiter</code> parameter.</p> <div class="last versionadded"> <p><span class="versionmodified">New in version 0.18.1: </span>support for the Python parser.</p> </div> </dd> </dl>   <h4 id="column-and-index-locations-and-names">Column and Index Locations and Names</h4> <dl class="docutils"> <dt>header</dt> <span class="classifier-delimiter">:</span> <span class="classifier">int or list of ints, default <code>'infer'</code></span><dd>Row number(s) to use as the column names, and the start of the data. Default behavior is as if <code>header=0</code> if no <code>names</code> passed, otherwise as if <code>header=None</code>. Explicitly pass <code>header=0</code> to be able to replace existing names. The header can be a list of ints that specify row locations for a multi-index on the columns e.g. <code>[0,1,3]</code>. Intervening rows that are not specified will be skipped (e.g. 2 in this example is skipped). Note that this parameter ignores commented lines and empty lines if <code>skip_blank_lines=True</code>, so header=0 denotes the first line of data rather than the first line of the file.</dd> <dt>names</dt> <span class="classifier-delimiter">:</span> <span class="classifier">array-like, default <code>None</code></span><dd>List of column names to use. If file contains no header row, then you should explicitly pass <code>header=None</code>. Duplicates in this list are not allowed unless <code>mangle_dupe_cols=True</code>, which is the default.</dd> <dt>index_col</dt> <span class="classifier-delimiter">:</span> <span class="classifier">int or sequence or <code>False</code>, default <code>None</code></span><dd>Column to use as the row labels of the DataFrame. If a sequence is given, a MultiIndex is used. If you have a malformed file with delimiters at the end of each line, you might consider <code>index_col=False</code> to force pandas to <em>not</em> use the first column as the index (row names).</dd> <dt>usecols</dt> <span class="classifier-delimiter">:</span> <span class="classifier">array-like, default <code>None</code></span><dd>Return a subset of the columns. All elements in this array must either be positional (i.e. integer indices into the document columns) or strings that correspond to column names provided either by the user in <code>names</code> or inferred from the document header row(s). For example, a valid <code>usecols</code> parameter would be [0, 1, 2] or [‘foo’, ‘bar’, ‘baz’]. Using this parameter results in much faster parsing time and lower memory usage.</dd> <dt>as_recarray</dt> <span class="classifier-delimiter">:</span> <span class="classifier">boolean, default <code>False</code></span><dd>
<p class="first">DEPRECATED: this argument will be removed in a future version. Please call <code>pd.read_csv(...).to_records()</code> instead.</p> <p class="last">Return a NumPy recarray instead of a DataFrame after parsing the data. If set to <code>True</code>, this option takes precedence over the <code>squeeze</code> parameter. In addition, as row indices are not available in such a format, the <code>index_col</code> parameter will be ignored.</p> </dd> <dt>squeeze</dt> <span class="classifier-delimiter">:</span> <span class="classifier">boolean, default <code>False</code></span><dd>If the parsed data only contains one column then return a Series.</dd> <dt>prefix</dt> <span class="classifier-delimiter">:</span> <span class="classifier">str, default <code>None</code></span><dd>Prefix to add to column numbers when no header, e.g. ‘X’ for X0, X1, ...</dd> <dt>mangle_dupe_cols</dt> <span class="classifier-delimiter">:</span> <span class="classifier">boolean, default <code>True</code></span><dd>Duplicate columns will be specified as ‘X.0’...’X.N’, rather than ‘X’...’X’. Passing in False will cause data to be overwritten if there are duplicate names in the columns.</dd> </dl>   <h4 id="general-parsing-configuration">General Parsing Configuration</h4> <dl class="docutils"> <dt>dtype</dt> <span class="classifier-delimiter">:</span> <span class="classifier">Type name or dict of column -&gt; type, default <code>None</code></span><dd>Data type for data or columns. E.g. <code>{'a': np.float64, 'b': np.int32}</code> (unsupported with <code>engine='python'</code>). Use <code>str</code> or <code>object</code> to preserve and not interpret dtype.</dd> <dt>engine</dt> <span class="classifier-delimiter">:</span> <span class="classifier">{<code>'c'</code>, <code>'python'</code>}</span><dd>Parser engine to use. The C engine is faster while the python engine is currently more feature-complete.</dd> <dt>converters</dt> <span class="classifier-delimiter">:</span> <span class="classifier">dict, default <code>None</code></span><dd>Dict of functions for converting values in certain columns. Keys can either be integers or column labels.</dd> <dt>true_values</dt> <span class="classifier-delimiter">:</span> <span class="classifier">list, default <code>None</code></span><dd>Values to consider as <code>True</code>.</dd> <dt>false_values</dt> <span class="classifier-delimiter">:</span> <span class="classifier">list, default <code>None</code></span><dd>Values to consider as <code>False</code>.</dd> <dt>skipinitialspace</dt> <span class="classifier-delimiter">:</span> <span class="classifier">boolean, default <code>False</code></span><dd>Skip spaces after delimiter.</dd> <dt>skiprows</dt> <span class="classifier-delimiter">:</span> <span class="classifier">list-like or integer, default <code>None</code></span><dd>Line numbers to skip (0-indexed) or number of lines to skip (int) at the start of the file.</dd> <dt>skipfooter</dt> <span class="classifier-delimiter">:</span> <span class="classifier">int, default <code>0</code></span><dd>Number of lines at bottom of file to skip (unsupported with engine=’c’).</dd> <dt>skip_footer</dt> <span class="classifier-delimiter">:</span> <span class="classifier">int, default <code>0</code></span><dd>DEPRECATED: use the <code>skipfooter</code> parameter instead, as they are identical</dd> <dt>nrows</dt> <span class="classifier-delimiter">:</span> <span class="classifier">int, default <code>None</code></span><dd>Number of rows of file to read. Useful for reading pieces of large files.</dd> <dt>low_memory</dt> <span class="classifier-delimiter">:</span> <span class="classifier">boolean, default <code>True</code></span><dd>Internally process the file in chunks, resulting in lower memory use while parsing, but possibly mixed type inference. To ensure no mixed types either set <code>False</code>, or specify the type with the <code>dtype</code> parameter. Note that the entire file is read into a single DataFrame regardless, use the <code>chunksize</code> or <code>iterator</code> parameter to return the data in chunks. (Only valid with C parser)</dd> <dt>buffer_lines</dt> <span class="classifier-delimiter">:</span> <span class="classifier">int, default None</span><dd>DEPRECATED: this argument will be removed in a future version because its value is not respected by the parser</dd> <dt>compact_ints</dt> <span class="classifier-delimiter">:</span> <span class="classifier">boolean, default False</span><dd>
<p class="first">DEPRECATED: this argument will be removed in a future version</p> <p class="last">If <code>compact_ints</code> is <code>True</code>, then for any column that is of integer dtype, the parser will attempt to cast it as the smallest integer <code>dtype</code> possible, either signed or unsigned depending on the specification from the <code>use_unsigned</code> parameter.</p> </dd> <dt>use_unsigned</dt> <span class="classifier-delimiter">:</span> <span class="classifier">boolean, default False</span><dd>
<p class="first">DEPRECATED: this argument will be removed in a future version</p> <p class="last">If integer columns are being compacted (i.e. <code>compact_ints=True</code>), specify whether the column should be compacted to the smallest signed or unsigned integer dtype.</p> </dd> <dt>memory_map</dt> <span class="classifier-delimiter">:</span> <span class="classifier">boolean, default False</span><dd>If a filepath is provided for <code>filepath_or_buffer</code>, map the file object directly onto memory and access the data directly from there. Using this option can improve performance because there is no longer any I/O overhead.</dd> </dl>   <h4 id="na-and-missing-data-handling">NA and Missing Data Handling</h4> <dl class="docutils"> <dt>na_values</dt> <span class="classifier-delimiter">:</span> <span class="classifier">scalar, str, list-like, or dict, default <code>None</code></span><dd>Additional strings to recognize as NA/NaN. If dict passed, specific per-column NA values. By default the following values are interpreted as NaN: <code>'-1.#IND', '1.#QNAN', '1.#IND', '-1.#QNAN', '#N/A N/A', '#N/A', 'N/A', 'NA',
'#NA', 'NULL', 'NaN', '-NaN', 'nan', '-nan', ''</code>.</dd> <dt>keep_default_na</dt> <span class="classifier-delimiter">:</span> <span class="classifier">boolean, default <code>True</code></span><dd>If na_values are specified and keep_default_na is <code>False</code> the default NaN values are overridden, otherwise they’re appended to.</dd> <dt>na_filter</dt> <span class="classifier-delimiter">:</span> <span class="classifier">boolean, default <code>True</code></span><dd>Detect missing value markers (empty strings and the value of na_values). In data without any NAs, passing <code>na_filter=False</code> can improve the performance of reading a large file.</dd> <dt>verbose</dt> <span class="classifier-delimiter">:</span> <span class="classifier">boolean, default <code>False</code></span><dd>Indicate number of NA values placed in non-numeric columns.</dd> <dt>skip_blank_lines</dt> <span class="classifier-delimiter">:</span> <span class="classifier">boolean, default <code>True</code></span><dd>If <code>True</code>, skip over blank lines rather than interpreting as NaN values.</dd> </dl>   <h4 id="datetime-handling">Datetime Handling</h4> <dl class="docutils"> <dt>parse_dates</dt> <span class="classifier-delimiter">:</span> <span class="classifier">boolean or list of ints or names or list of lists or dict, default <code>False</code>.</span><dd>
<ul class="first last simple"> <li>If <code>True</code> -&gt; try parsing the index.</li> <li>If <code>[1, 2, 3]</code> -&gt; try parsing columns 1, 2, 3 each as a separate date column.</li> <li>If <code>[[1, 3]]</code> -&gt; combine columns 1 and 3 and parse as a single date column.</li> <li>If <code>{'foo' : [1, 3]}</code> -&gt; parse columns 1, 3 as date and call result ‘foo’. A fast-path exists for iso8601-formatted dates.</li> </ul> </dd> <dt>infer_datetime_format</dt> <span class="classifier-delimiter">:</span> <span class="classifier">boolean, default <code>False</code></span><dd>If <code>True</code> and parse_dates is enabled for a column, attempt to infer the datetime format to speed up the processing.</dd> <dt>keep_date_col</dt> <span class="classifier-delimiter">:</span> <span class="classifier">boolean, default <code>False</code></span><dd>If <code>True</code> and parse_dates specifies combining multiple columns then keep the original columns.</dd> <dt>date_parser</dt> <span class="classifier-delimiter">:</span> <span class="classifier">function, default <code>None</code></span><dd>Function to use for converting a sequence of string columns to an array of datetime instances. The default uses <code>dateutil.parser.parser</code> to do the conversion. Pandas will try to call date_parser in three different ways, advancing to the next if an exception occurs: 1) Pass one or more arrays (as defined by parse_dates) as arguments; 2) concatenate (row-wise) the string values from the columns defined by parse_dates into a single array and pass that; and 3) call date_parser once for each row using one or more strings (corresponding to the columns defined by parse_dates) as arguments.</dd> <dt>dayfirst</dt> <span class="classifier-delimiter">:</span> <span class="classifier">boolean, default <code>False</code></span><dd>DD/MM format dates, international and European format.</dd> </dl>   <h4 id="iteration">Iteration</h4> <dl class="docutils"> <dt>iterator</dt> <span class="classifier-delimiter">:</span> <span class="classifier">boolean, default <code>False</code></span><dd>Return <code>TextFileReader</code> object for iteration or getting chunks with <code>get_chunk()</code>.</dd> <dt>chunksize</dt> <span class="classifier-delimiter">:</span> <span class="classifier">int, default <code>None</code></span><dd>Return <code>TextFileReader</code> object for iteration. See <a class="reference internal" href="#io-chunking"><span class="std std-ref">iterating and chunking</span></a> below.</dd> </dl>   <h4 id="quoting-compression-and-file-format">Quoting, Compression, and File Format</h4> <dl class="docutils"> <dt>compression</dt> <span class="classifier-delimiter">:</span> <span class="classifier">{<code>'infer'</code>, <code>'gzip'</code>, <code>'bz2'</code>, <code>'zip'</code>, <code>'xz'</code>, <code>None</code>}, default <code>'infer'</code></span><dd>
<p class="first">For on-the-fly decompression of on-disk data. If ‘infer’, then use gzip, bz2, zip, or xz if filepath_or_buffer is a string ending in ‘.gz’, ‘.bz2’, ‘.zip’, or ‘.xz’, respectively, and no decompression otherwise. If using ‘zip’, the ZIP file must contain only one data file to be read in. Set to <code>None</code> for no decompression.</p> <div class="last versionadded"> <p><span class="versionmodified">New in version 0.18.1: </span>support for ‘zip’ and ‘xz’ compression.</p> </div> </dd> <dt>thousands</dt> <span class="classifier-delimiter">:</span> <span class="classifier">str, default <code>None</code></span><dd>Thousands separator.</dd> <dt>decimal</dt> <span class="classifier-delimiter">:</span> <span class="classifier">str, default <code>'.'</code></span><dd>Character to recognize as decimal point. E.g. use <code>','</code> for European data.</dd> <dt>float_precision</dt> <span class="classifier-delimiter">:</span> <span class="classifier">string, default None</span><dd>Specifies which converter the C engine should use for floating-point values. The options are <code>None</code> for the ordinary converter, <code>high</code> for the high-precision converter, and <code>round_trip</code> for the round-trip converter.</dd> <dt>lineterminator</dt> <span class="classifier-delimiter">:</span> <span class="classifier">str (length 1), default <code>None</code></span><dd>Character to break file into lines. Only valid with C parser.</dd> <dt>quotechar</dt> <span class="classifier-delimiter">:</span> <span class="classifier">str (length 1)</span><dd>The character used to denote the start and end of a quoted item. Quoted items can include the delimiter and it will be ignored.</dd> <dt>quoting</dt> <span class="classifier-delimiter">:</span> <span class="classifier">int or <code>csv.QUOTE_*</code> instance, default <code>0</code></span><dd>Control field quoting behavior per <code>csv.QUOTE_*</code> constants. Use one of <code>QUOTE_MINIMAL</code> (0), <code>QUOTE_ALL</code> (1), <code>QUOTE_NONNUMERIC</code> (2) or <code>QUOTE_NONE</code> (3).</dd> <dt>doublequote</dt> <span class="classifier-delimiter">:</span> <span class="classifier">boolean, default <code>True</code></span><dd>When <code>quotechar</code> is specified and <code>quoting</code> is not <code>QUOTE_NONE</code>, indicate whether or not to interpret two consecutive <code>quotechar</code> elements <strong>inside</strong> a field as a single <code>quotechar</code> element.</dd> <dt>escapechar</dt> <span class="classifier-delimiter">:</span> <span class="classifier">str (length 1), default <code>None</code></span><dd>One-character string used to escape delimiter when quoting is <code>QUOTE_NONE</code>.</dd> <dt>comment</dt> <span class="classifier-delimiter">:</span> <span class="classifier">str, default <code>None</code></span><dd>Indicates remainder of line should not be parsed. If found at the beginning of a line, the line will be ignored altogether. This parameter must be a single character. Like empty lines (as long as <code>skip_blank_lines=True</code>), fully commented lines are ignored by the parameter <code>header</code> but not by <code>skiprows</code>. For example, if <code>comment='#'</code>, parsing ‘#empty\na,b,c\n1,2,3’ with <code>header=0</code> will result in ‘a,b,c’ being treated as the header.</dd> <dt>encoding</dt> <span class="classifier-delimiter">:</span> <span class="classifier">str, default <code>None</code></span><dd>Encoding to use for UTF when reading/writing (e.g. <code>'utf-8'</code>). <a class="reference external" href="https://docs.python.org/3/library/codecs.html#standard-encodings" target="_blank">List of Python standard encodings</a>.</dd> <dt>dialect</dt> <span class="classifier-delimiter">:</span> <span class="classifier">str or <a class="reference external" href="https://docs.python.org/3/library/csv.html#csv.Dialect" title="(in Python v3.6)" target="_blank"><code>csv.Dialect</code></a> instance, default <code>None</code></span><dd>If <code>None</code> defaults to Excel dialect. Ignored if sep longer than 1 char. See <a class="reference external" href="https://docs.python.org/3/library/csv.html#csv.Dialect" title="(in Python v3.6)" target="_blank"><code>csv.Dialect</code></a> documentation for more details.</dd> <dt>tupleize_cols</dt> <span class="classifier-delimiter">:</span> <span class="classifier">boolean, default <code>False</code></span><dd>Leave a list of tuples on columns as is (default is to convert to a MultiIndex on the columns).</dd> </dl>   <h4 id="error-handling">Error Handling</h4> <dl class="docutils"> <dt>error_bad_lines</dt> <span class="classifier-delimiter">:</span> <span class="classifier">boolean, default <code>True</code></span><dd>Lines with too many fields (e.g. a csv line with too many commas) will by default cause an exception to be raised, and no DataFrame will be returned. If <code>False</code>, then these “bad lines” will dropped from the DataFrame that is returned (only valid with C parser). See <a class="reference internal" href="#io-bad-lines"><span class="std std-ref">bad lines</span></a> below.</dd> <dt>warn_bad_lines</dt> <span class="classifier-delimiter">:</span> <span class="classifier">boolean, default <code>True</code></span><dd>If error_bad_lines is <code>False</code>, and warn_bad_lines is <code>True</code>, a warning for each “bad line” will be output (only valid with C parser).</dd> </dl> <p>Consider a typical CSV file containing, in this case, some time series data:</p> <pre data-language="python">In [1]: print(open('foo.csv').read())
date,A,B,C
20090101,a,1,2
20090102,b,3,4
20090103,c,4,5
</pre> <p>The default for <code>read_csv</code> is to create a DataFrame with simple numbered rows:</p> <pre data-language="python">In [2]: pd.read_csv('foo.csv')
Out[2]: 
       date  A  B  C
0  20090101  a  1  2
1  20090102  b  3  4
2  20090103  c  4  5
</pre> <p>In the case of indexed data, you can pass the column number or column name you wish to use as the index:</p> <pre data-language="python">In [3]: pd.read_csv('foo.csv', index_col=0)
Out[3]: 
          A  B  C
date             
20090101  a  1  2
20090102  b  3  4
20090103  c  4  5
</pre> <pre data-language="python">In [4]: pd.read_csv('foo.csv', index_col='date')
Out[4]: 
          A  B  C
date             
20090101  a  1  2
20090102  b  3  4
20090103  c  4  5
</pre> <p>You can also use a list of columns to create a hierarchical index:</p> <pre data-language="python">In [5]: pd.read_csv('foo.csv', index_col=[0, 'A'])
Out[5]: 
            B  C
date     A      
20090101 a  1  2
20090102 b  3  4
20090103 c  4  5
</pre> <p id="io-dialect">The <code>dialect</code> keyword gives greater flexibility in specifying the file format. By default it uses the Excel dialect but you can specify either the dialect name or a <a class="reference external" href="https://docs.python.org/3/library/csv.html#csv.Dialect" title="(in Python v3.6)" target="_blank"><code>csv.Dialect</code></a> instance.</p> <p>Suppose you had data with unenclosed quotes:</p> <pre data-language="python">In [6]: print(data)
label1,label2,label3
index1,"a,c,e
index2,b,d,f
</pre> <p>By default, <code>read_csv</code> uses the Excel dialect and treats the double quote as the quote character, which causes it to fail when it finds a newline before it finds the closing double quote.</p> <p>We can get around this using <code>dialect</code></p> <pre data-language="python">In [7]: dia = csv.excel()

In [8]: dia.quoting = csv.QUOTE_NONE

In [9]: pd.read_csv(StringIO(data), dialect=dia)
Out[9]: 
       label1 label2 label3
index1     "a      c      e
index2      b      d      f
</pre> <p>All of the dialect options can be specified separately by keyword arguments:</p> <pre data-language="python">In [10]: data = 'a,b,c~1,2,3~4,5,6'

In [11]: pd.read_csv(StringIO(data), lineterminator='~')
Out[11]: 
   a  b  c
0  1  2  3
1  4  5  6
</pre> <p>Another common dialect option is <code>skipinitialspace</code>, to skip any whitespace after a delimiter:</p> <pre data-language="python">In [12]: data = 'a, b, c\n1, 2, 3\n4, 5, 6'

In [13]: print(data)
a, b, c
1, 2, 3
4, 5, 6

In [14]: pd.read_csv(StringIO(data), skipinitialspace=True)
Out[14]: 
   a  b  c
0  1  2  3
1  4  5  6
</pre> <p>The parsers make every attempt to “do the right thing” and not be very fragile. Type inference is a pretty big deal. So if a column can be coerced to integer dtype without altering the contents, it will do so. Any non-numeric columns will come through as object dtype as with the rest of pandas objects.</p>    <h3 id="io-dtypes">Specifying column data types</h3> <p id="specifying-column-data-types">Starting with v0.10, you can indicate the data type for the whole DataFrame or individual columns:</p> <pre data-language="python">In [15]: data = 'a,b,c\n1,2,3\n4,5,6\n7,8,9'

In [16]: print(data)
a,b,c
1,2,3
4,5,6
7,8,9

In [17]: df = pd.read_csv(StringIO(data), dtype=object)

In [18]: df
Out[18]: 
   a  b  c
0  1  2  3
1  4  5  6
2  7  8  9

In [19]: df['a'][0]
Out[19]: '1'

In [20]: df = pd.read_csv(StringIO(data), dtype={'b': object, 'c': np.float64})

In [21]: df.dtypes
Out[21]: 
a      int64
b     object
c    float64
dtype: object
</pre> <p>Fortunately, <code>pandas</code> offers more than one way to ensure that your column(s) contain only one <code>dtype</code>. If you’re unfamiliar with these concepts, you can see <a class="reference internal" href="../basics/#basics-dtypes"><span class="std std-ref">here</span></a> to learn more about dtypes, and <a class="reference internal" href="../basics/#basics-object-conversion"><span class="std std-ref">here</span></a> to learn more about <code>object</code> conversion in <code>pandas</code>.</p> <p>For instance, you can use the <code>converters</code> argument of <a class="reference internal" href="../generated/pandas.read_csv/#pandas.read_csv" title="pandas.read_csv"><code>read_csv()</code></a>:</p> <pre data-language="python">In [22]: data = "col_1\n1\n2\n'A'\n4.22"

In [23]: df = pd.read_csv(StringIO(data), converters={'col_1':str})

In [24]: df
Out[24]: 
  col_1
0     1
1     2
2   'A'
3  4.22

In [25]: df['col_1'].apply(type).value_counts()
Out[25]: 
&lt;type 'str'&gt;    4
Name: col_1, dtype: int64
</pre> <p>Or you can use the <a class="reference internal" href="../generated/pandas.to_numeric/#pandas.to_numeric" title="pandas.to_numeric"><code>to_numeric()</code></a> function to coerce the dtypes after reading in the data,</p> <pre data-language="python">In [26]: df2 = pd.read_csv(StringIO(data))

In [27]: df2['col_1'] = pd.to_numeric(df2['col_1'], errors='coerce')

In [28]: df2
Out[28]: 
   col_1
0   1.00
1   2.00
2    NaN
3   4.22

In [29]: df2['col_1'].apply(type).value_counts()
Out[29]: 
&lt;type 'float'&gt;    4
Name: col_1, dtype: int64
</pre> <p>which would convert all valid parsing to floats, leaving the invalid parsing as <code>NaN</code>.</p> <p>Ultimately, how you deal with reading in columns containing mixed dtypes depends on your specific needs. In the case above, if you wanted to <code>NaN</code> out the data anomalies, then <a class="reference internal" href="../generated/pandas.to_numeric/#pandas.to_numeric" title="pandas.to_numeric"><code>to_numeric()</code></a> is probably your best option. However, if you wanted for all the data to be coerced, no matter the type, then using the <code>converters</code> argument of <a class="reference internal" href="../generated/pandas.read_csv/#pandas.read_csv" title="pandas.read_csv"><code>read_csv()</code></a> would certainly be worth trying.</p> <div class="admonition note"> <p class="first admonition-title">Note</p> <p class="last">The <code>dtype</code> option is currently only supported by the C engine. Specifying <code>dtype</code> with <code>engine</code> other than ‘c’ raises a <code>ValueError</code>.</p> </div> <div class="admonition note"> <p class="first admonition-title">Note</p> <p>In some cases, reading in abnormal data with columns containing mixed dtypes will result in an inconsistent dataset. If you rely on pandas to infer the dtypes of your columns, the parsing engine will go and infer the dtypes for different chunks of the data, rather than the whole dataset at once. Consequently, you can end up with column(s) with mixed dtypes. For example,</p> <pre data-language="python">In [30]: df = pd.DataFrame({'col_1':range(500000) + ['a', 'b'] + range(500000)})

In [31]: df.to_csv('foo')

In [32]: mixed_df = pd.read_csv('foo')

In [33]: mixed_df['col_1'].apply(type).value_counts()
Out[33]: 
&lt;type 'int'&gt;    737858
&lt;type 'str'&gt;    262144
Name: col_1, dtype: int64

In [34]: mixed_df['col_1'].dtype
Out[34]: dtype('O')
</pre> <p class="last">will result with <code>mixed_df</code> containing an <code>int</code> dtype for certain chunks of the column, and <code>str</code> for others due to the mixed dtypes from the data that was read in. It is important to note that the overall column will be marked with a <code>dtype</code> of <code>object</code>, which is used for columns with mixed dtypes.</p> </div>   <h3 id="io-categorical">Specifying Categorical dtype</h3> <div class="versionadded" id="specifying-categorical-dtype"> <p><span class="versionmodified">New in version 0.19.0.</span></p> </div> <p><code>Categorical</code> columns can be parsed directly by specifying <code>dtype='category'</code></p> <pre data-language="python">In [35]: data = 'col1,col2,col3\na,b,1\na,b,2\nc,d,3'

In [36]: pd.read_csv(StringIO(data))
Out[36]: 
  col1 col2  col3
0    a    b     1
1    a    b     2
2    c    d     3

In [37]: pd.read_csv(StringIO(data)).dtypes
Out[37]: 
col1    object
col2    object
col3     int64
dtype: object

In [38]: pd.read_csv(StringIO(data), dtype='category').dtypes
Out[38]: 
col1    category
col2    category
col3    category
dtype: object
</pre> <p>Individual columns can be parsed as a <code>Categorical</code> using a dict specification</p> <pre data-language="python">In [39]: pd.read_csv(StringIO(data), dtype={'col1': 'category'}).dtypes
Out[39]: 
col1    category
col2      object
col3       int64
dtype: object
</pre> <div class="admonition note"> <p class="first admonition-title">Note</p> <p>The resulting categories will always be parsed as strings (object dtype). If the categories are numeric they can be converted using the <a class="reference internal" href="../generated/pandas.to_numeric/#pandas.to_numeric" title="pandas.to_numeric"><code>to_numeric()</code></a> function, or as appropriate, another converter such as <a class="reference internal" href="../generated/pandas.to_datetime/#pandas.to_datetime" title="pandas.to_datetime"><code>to_datetime()</code></a>.</p> <pre data-language="python">In [40]: df = pd.read_csv(StringIO(data), dtype='category')

In [41]: df.dtypes
Out[41]: 
col1    category
col2    category
col3    category
dtype: object

In [42]: df['col3']
Out[42]: 
0    1
1    2
2    3
Name: col3, dtype: category
Categories (3, object): [1, 2, 3]

In [43]: df['col3'].cat.categories = pd.to_numeric(df['col3'].cat.categories)

In [44]: df['col3']
Out[44]: 
0    1
1    2
2    3
Name: col3, dtype: category
Categories (3, int64): [1, 2, 3]
</pre> </div>   <h3 id="naming-and-using-columns">Naming and Using Columns</h3>  <h4 id="io-headers">Handling column names</h4> <p id="handling-column-names">A file may or may not have a header row. pandas assumes the first row should be used as the column names:</p> <pre data-language="python">In [45]: data = 'a,b,c\n1,2,3\n4,5,6\n7,8,9'

In [46]: print(data)
a,b,c
1,2,3
4,5,6
7,8,9

In [47]: pd.read_csv(StringIO(data))
Out[47]: 
   a  b  c
0  1  2  3
1  4  5  6
2  7  8  9
</pre> <p>By specifying the <code>names</code> argument in conjunction with <code>header</code> you can indicate other names to use and whether or not to throw away the header row (if any):</p> <pre data-language="python">In [48]: print(data)
a,b,c
1,2,3
4,5,6
7,8,9

In [49]: pd.read_csv(StringIO(data), names=['foo', 'bar', 'baz'], header=0)
Out[49]: 
   foo  bar  baz
0    1    2    3
1    4    5    6
2    7    8    9

In [50]: pd.read_csv(StringIO(data), names=['foo', 'bar', 'baz'], header=None)
Out[50]: 
  foo bar baz
0   a   b   c
1   1   2   3
2   4   5   6
3   7   8   9
</pre> <p>If the header is in a row other than the first, pass the row number to <code>header</code>. This will skip the preceding rows:</p> <pre data-language="python">In [51]: data = 'skip this skip it\na,b,c\n1,2,3\n4,5,6\n7,8,9'

In [52]: pd.read_csv(StringIO(data), header=1)
Out[52]: 
   a  b  c
0  1  2  3
1  4  5  6
2  7  8  9
</pre>    <h3 id="io-dupe-names">Duplicate names parsing</h3> <p id="duplicate-names-parsing">If the file or header contains duplicate names, pandas by default will deduplicate these names so as to prevent data overwrite:</p> <pre data-language="python">In [53]: data = 'a,b,a\n0,1,2\n3,4,5'

In [54]: pd.read_csv(StringIO(data))
Out[54]: 
   a  b  a.1
0  0  1    2
1  3  4    5
</pre> <p>There is no more duplicate data because <code>mangle_dupe_cols=True</code> by default, which modifies a series of duplicate columns ‘X’...’X’ to become ‘X.0’...’X.N’. If <code>mangle_dupe_cols
=False</code>, duplicate data can arise:</p> <pre data-language="python">In [2]: data = 'a,b,a\n0,1,2\n3,4,5'
In [3]: pd.read_csv(StringIO(data), mangle_dupe_cols=False)
Out[3]:
   a  b  a
0  2  1  2
1  5  4  5
</pre> <p>To prevent users from encountering this problem with duplicate data, a <code>ValueError</code> exception is raised if <code>mangle_dupe_cols != True</code>:</p> <pre data-language="python">In [2]: data = 'a,b,a\n0,1,2\n3,4,5'
In [3]: pd.read_csv(StringIO(data), mangle_dupe_cols=False)
...
ValueError: Setting mangle_dupe_cols=False is not supported yet
</pre>  <h4 id="io-usecols">Filtering columns (<code>usecols</code>)</h4> <p id="filtering-columns-usecols">The <code>usecols</code> argument allows you to select any subset of the columns in a file, either using the column names or position numbers:</p> <pre data-language="python">In [55]: data = 'a,b,c,d\n1,2,3,foo\n4,5,6,bar\n7,8,9,baz'

In [56]: pd.read_csv(StringIO(data))
Out[56]: 
   a  b  c    d
0  1  2  3  foo
1  4  5  6  bar
2  7  8  9  baz

In [57]: pd.read_csv(StringIO(data), usecols=['b', 'd'])
Out[57]: 
   b    d
0  2  foo
1  5  bar
2  8  baz

In [58]: pd.read_csv(StringIO(data), usecols=[0, 2, 3])
Out[58]: 
   a  c    d
0  1  3  foo
1  4  6  bar
2  7  9  baz
</pre>    <h3 id="comments-and-empty-lines">Comments and Empty Lines</h3>  <h4 id="io-skiplines">Ignoring line comments and empty lines</h4> <p id="ignoring-line-comments-and-empty-lines">If the <code>comment</code> parameter is specified, then completely commented lines will be ignored. By default, completely blank lines will be ignored as well. Both of these are API changes introduced in version 0.15.</p> <pre data-language="python">In [59]: data = '\na,b,c\n  \n# commented line\n1,2,3\n\n4,5,6'

In [60]: print(data)

a,b,c
  
1,2,3

4,5,6

# commented line
In [61]: pd.read_csv(StringIO(data), comment='#')
Out[61]: 
   a  b  c
0  1  2  3
1  4  5  6
</pre> <p>If <code>skip_blank_lines=False</code>, then <code>read_csv</code> will not ignore blank lines:</p> <pre data-language="python">In [62]: data = 'a,b,c\n\n1,2,3\n\n\n4,5,6'

In [63]: pd.read_csv(StringIO(data), skip_blank_lines=False)
Out[63]: 
     a    b    c
0  NaN  NaN  NaN
1  1.0  2.0  3.0
2  NaN  NaN  NaN
3  NaN  NaN  NaN
4  4.0  5.0  6.0
</pre> <div class="admonition warning"> <p class="first admonition-title">Warning</p> <p>The presence of ignored lines might create ambiguities involving line numbers; the parameter <code>header</code> uses row numbers (ignoring commented/empty lines), while <code>skiprows</code> uses line numbers (including commented/empty lines):</p> <pre data-language="python">In [64]: data = '#comment\na,b,c\nA,B,C\n1,2,3'

In [65]: pd.read_csv(StringIO(data), comment='#', header=1)
Out[65]: 
   A  B  C
0  1  2  3

In [66]: data = 'A,B,C\n#comment\na,b,c\n1,2,3'

In [67]: pd.read_csv(StringIO(data), comment='#', skiprows=2)
Out[67]: 
   a  b  c
0  1  2  3
</pre> <p>If both <code>header</code> and <code>skiprows</code> are specified, <code>header</code> will be relative to the end of <code>skiprows</code>. For example:</p> <pre data-language="python">In [68]: data = '# empty\n# second empty line\n# third empty' \

In [68]: 'line\nX,Y,Z\n1,2,3\nA,B,C\n1,2.,4.\n5.,NaN,10.0'

In [69]: print(data)
# empty
# second empty line
# third emptyline
X,Y,Z
1,2,3
A,B,C
1,2.,4.
5.,NaN,10.0

In [70]: pd.read_csv(StringIO(data), comment='#', skiprows=4, header=1)
Out[70]: 
     A    B     C
0  1.0  2.0   4.0
1  5.0  NaN  10.0
</pre> </div>   <h4 id="io-comments">Comments</h4> <p id="comments">Sometimes comments or meta data may be included in a file:</p> <pre data-language="python">In [71]: print(open('tmp.csv').read())
ID,level,category
Patient1,123000,x # really unpleasant
Patient2,23000,y # wouldn't take his medicine
Patient3,1234018,z # awesome
</pre> <p>By default, the parser includes the comments in the output:</p> <pre data-language="python">In [72]: df = pd.read_csv('tmp.csv')

In [73]: df
Out[73]: 
         ID    level                        category
0  Patient1   123000           x # really unpleasant
1  Patient2    23000  y # wouldn't take his medicine
2  Patient3  1234018                     z # awesome
</pre> <p>We can suppress the comments using the <code>comment</code> keyword:</p> <pre data-language="python">In [74]: df = pd.read_csv('tmp.csv', comment='#')

In [75]: df
Out[75]: 
         ID    level category
0  Patient1   123000       x 
1  Patient2    23000       y 
2  Patient3  1234018       z 
</pre>    <h3 id="io-unicode">Dealing with Unicode Data</h3> <p id="dealing-with-unicode-data">The <code>encoding</code> argument should be used for encoded unicode data, which will result in byte strings being decoded to unicode in the result:</p> <pre data-language="python">In [76]: data = b'word,length\nTr\xc3\xa4umen,7\nGr\xc3\xbc\xc3\x9fe,5'.decode('utf8').encode('latin-1')

In [77]: df = pd.read_csv(BytesIO(data), encoding='latin-1')

In [78]: df
Out[78]: 
      word  length
0  Träumen       7
1    Grüße       5

In [79]: df['word'][1]
Out[79]: u'Gr\xfc\xdfe'
</pre> <p>Some formats which encode all characters as multiple bytes, like UTF-16, won’t parse correctly at all without specifying the encoding. <a class="reference external" href="https://docs.python.org/3/library/codecs.html#standard-encodings" target="_blank">Full list of Python standard encodings</a></p>   <h3 id="io-index-col">Index columns and trailing delimiters</h3> <p id="index-columns-and-trailing-delimiters">If a file has one more column of data than the number of column names, the first column will be used as the DataFrame’s row names:</p> <pre data-language="python">In [80]: data = 'a,b,c\n4,apple,bat,5.7\n8,orange,cow,10'

In [81]: pd.read_csv(StringIO(data))
Out[81]: 
        a    b     c
4   apple  bat   5.7
8  orange  cow  10.0
</pre> <pre data-language="python">In [82]: data = 'index,a,b,c\n4,apple,bat,5.7\n8,orange,cow,10'

In [83]: pd.read_csv(StringIO(data), index_col=0)
Out[83]: 
            a    b     c
index                   
4       apple  bat   5.7
8      orange  cow  10.0
</pre> <p>Ordinarily, you can achieve this behavior using the <code>index_col</code> option.</p> <p>There are some exception cases when a file has been prepared with delimiters at the end of each data line, confusing the parser. To explicitly disable the index column inference and discard the last column, pass <code>index_col=False</code>:</p> <pre data-language="python">In [84]: data = 'a,b,c\n4,apple,bat,\n8,orange,cow,'

In [85]: print(data)
a,b,c
4,apple,bat,
8,orange,cow,

In [86]: pd.read_csv(StringIO(data))
Out[86]: 
        a    b   c
4   apple  bat NaN
8  orange  cow NaN

In [87]: pd.read_csv(StringIO(data), index_col=False)
Out[87]: 
   a       b    c
0  4   apple  bat
1  8  orange  cow
</pre>   <h3 id="io-parse-dates">Date Handling</h3>  <h4 id="date-handling">Specifying Date Columns</h4> <p>To better facilitate working with datetime data, <a class="reference internal" href="../generated/pandas.read_csv/#pandas.read_csv" title="pandas.read_csv"><code>read_csv()</code></a> and <a class="reference internal" href="../generated/pandas.read_table/#pandas.read_table" title="pandas.read_table"><code>read_table()</code></a> use the keyword arguments <code>parse_dates</code> and <code>date_parser</code> to allow users to specify a variety of columns and date/time formats to turn the input text data into <code>datetime</code> objects.</p> <p>The simplest case is to just pass in <code>parse_dates=True</code>:</p> <pre data-language="python"># Use a column as an index, and parse it as dates.
In [88]: df = pd.read_csv('foo.csv', index_col=0, parse_dates=True)

In [89]: df
Out[89]: 
            A  B  C
date               
2009-01-01  a  1  2
2009-01-02  b  3  4
2009-01-03  c  4  5

# These are python datetime objects
In [90]: df.index
Out[90]: DatetimeIndex(['2009-01-01', '2009-01-02', '2009-01-03'], dtype='datetime64[ns]', name=u'date', freq=None)
</pre> <p>It is often the case that we may want to store date and time data separately, or store various date fields separately. the <code>parse_dates</code> keyword can be used to specify a combination of columns to parse the dates and/or times from.</p> <p>You can specify a list of column lists to <code>parse_dates</code>, the resulting date columns will be prepended to the output (so as to not affect the existing column order) and the new column names will be the concatenation of the component column names:</p> <pre data-language="python">In [91]: print(open('tmp.csv').read())
KORD,19990127, 19:00:00, 18:56:00, 0.8100
KORD,19990127, 20:00:00, 19:56:00, 0.0100
KORD,19990127, 21:00:00, 20:56:00, -0.5900
KORD,19990127, 21:00:00, 21:18:00, -0.9900
KORD,19990127, 22:00:00, 21:56:00, -0.5900
KORD,19990127, 23:00:00, 22:56:00, -0.5900

In [92]: df = pd.read_csv('tmp.csv', header=None, parse_dates=[[1, 2], [1, 3]])

In [93]: df
Out[93]: 
                  1_2                 1_3     0     4
0 1999-01-27 19:00:00 1999-01-27 18:56:00  KORD  0.81
1 1999-01-27 20:00:00 1999-01-27 19:56:00  KORD  0.01
2 1999-01-27 21:00:00 1999-01-27 20:56:00  KORD -0.59
3 1999-01-27 21:00:00 1999-01-27 21:18:00  KORD -0.99
4 1999-01-27 22:00:00 1999-01-27 21:56:00  KORD -0.59
5 1999-01-27 23:00:00 1999-01-27 22:56:00  KORD -0.59
</pre> <p>By default the parser removes the component date columns, but you can choose to retain them via the <code>keep_date_col</code> keyword:</p> <pre data-language="python">In [94]: df = pd.read_csv('tmp.csv', header=None, parse_dates=[[1, 2], [1, 3]],
   ....:                  keep_date_col=True)
   ....: 

In [95]: df
Out[95]: 
                  1_2                 1_3     0         1          2  \
0 1999-01-27 19:00:00 1999-01-27 18:56:00  KORD  19990127   19:00:00   
1 1999-01-27 20:00:00 1999-01-27 19:56:00  KORD  19990127   20:00:00   
2 1999-01-27 21:00:00 1999-01-27 20:56:00  KORD  19990127   21:00:00   
3 1999-01-27 21:00:00 1999-01-27 21:18:00  KORD  19990127   21:00:00   
4 1999-01-27 22:00:00 1999-01-27 21:56:00  KORD  19990127   22:00:00   
5 1999-01-27 23:00:00 1999-01-27 22:56:00  KORD  19990127   23:00:00   

           3     4  
0   18:56:00  0.81  
1   19:56:00  0.01  
2   20:56:00 -0.59  
3   21:18:00 -0.99  
4   21:56:00 -0.59  
5   22:56:00 -0.59  
</pre> <p>Note that if you wish to combine multiple columns into a single date column, a nested list must be used. In other words, <code>parse_dates=[1, 2]</code> indicates that the second and third columns should each be parsed as separate date columns while <code>parse_dates=[[1, 2]]</code> means the two columns should be parsed into a single column.</p> <p>You can also use a dict to specify custom name columns:</p> <pre data-language="python">In [96]: date_spec = {'nominal': [1, 2], 'actual': [1, 3]}

In [97]: df = pd.read_csv('tmp.csv', header=None, parse_dates=date_spec)

In [98]: df
Out[98]: 
              nominal              actual     0     4
0 1999-01-27 19:00:00 1999-01-27 18:56:00  KORD  0.81
1 1999-01-27 20:00:00 1999-01-27 19:56:00  KORD  0.01
2 1999-01-27 21:00:00 1999-01-27 20:56:00  KORD -0.59
3 1999-01-27 21:00:00 1999-01-27 21:18:00  KORD -0.99
4 1999-01-27 22:00:00 1999-01-27 21:56:00  KORD -0.59
5 1999-01-27 23:00:00 1999-01-27 22:56:00  KORD -0.59
</pre> <p>It is important to remember that if multiple text columns are to be parsed into a single date column, then a new column is prepended to the data. The <code>index_col</code> specification is based off of this new set of columns rather than the original data columns:</p> <pre data-language="python">In [99]: date_spec = {'nominal': [1, 2], 'actual': [1, 3]}

In [100]: df = pd.read_csv('tmp.csv', header=None, parse_dates=date_spec,
   .....:                  index_col=0) #index is the nominal column
   .....: 

In [101]: df
Out[101]: 
                                 actual     0     4
nominal                                            
1999-01-27 19:00:00 1999-01-27 18:56:00  KORD  0.81
1999-01-27 20:00:00 1999-01-27 19:56:00  KORD  0.01
1999-01-27 21:00:00 1999-01-27 20:56:00  KORD -0.59
1999-01-27 21:00:00 1999-01-27 21:18:00  KORD -0.99
1999-01-27 22:00:00 1999-01-27 21:56:00  KORD -0.59
1999-01-27 23:00:00 1999-01-27 22:56:00  KORD -0.59
</pre> <div class="admonition note"> <p class="first admonition-title">Note</p> <p class="last">read_csv has a fast_path for parsing datetime strings in iso8601 format, e.g “2000-01-01T00:01:02+00:00” and similar variations. If you can arrange for your data to store datetimes in this format, load times will be significantly faster, ~20x has been observed.</p> </div> <div class="admonition note"> <p class="first admonition-title">Note</p> <p class="last">When passing a dict as the <code>parse_dates</code> argument, the order of the columns prepended is not guaranteed, because <code>dict</code> objects do not impose an ordering on their keys. On Python 2.7+ you may use <code>collections.OrderedDict</code> instead of a regular <code>dict</code> if this matters to you. Because of this, when using a dict for ‘parse_dates’ in conjunction with the <code>index_col</code> argument, it’s best to specify <code>index_col</code> as a column label rather then as an index on the resulting frame.</p> </div>   <h4 id="date-parsing-functions">Date Parsing Functions</h4> <p>Finally, the parser allows you to specify a custom <code>date_parser</code> function to take full advantage of the flexibility of the date parsing API:</p> <pre data-language="python">In [102]: import pandas.io.date_converters as conv

In [103]: df = pd.read_csv('tmp.csv', header=None, parse_dates=date_spec,
   .....:                  date_parser=conv.parse_date_time)
   .....: 

In [104]: df
Out[104]: 
              nominal              actual     0     4
0 1999-01-27 19:00:00 1999-01-27 18:56:00  KORD  0.81
1 1999-01-27 20:00:00 1999-01-27 19:56:00  KORD  0.01
2 1999-01-27 21:00:00 1999-01-27 20:56:00  KORD -0.59
3 1999-01-27 21:00:00 1999-01-27 21:18:00  KORD -0.99
4 1999-01-27 22:00:00 1999-01-27 21:56:00  KORD -0.59
5 1999-01-27 23:00:00 1999-01-27 22:56:00  KORD -0.59
</pre> <p>Pandas will try to call the <code>date_parser</code> function in three different ways. If an exception is raised, the next one is tried:</p> <ol class="arabic simple"> <li>
<code>date_parser</code> is first called with one or more arrays as arguments, as defined using <code>parse_dates</code> (e.g., <code>date_parser(['2013', '2013'], ['1', '2'])</code>)</li> <li>If #1 fails, <code>date_parser</code> is called with all the columns concatenated row-wise into a single array (e.g., <code>date_parser(['2013 1', '2013 2'])</code>)</li> <li>If #2 fails, <code>date_parser</code> is called once for every row with one or more string arguments from the columns indicated with <code>parse_dates</code> (e.g., <code>date_parser('2013', '1')</code> for the first row, <code>date_parser('2013', '2')</code> for the second, etc.)</li> </ol> <p>Note that performance-wise, you should try these methods of parsing dates in order:</p> <ol class="arabic simple"> <li>Try to infer the format using <code>infer_datetime_format=True</code> (see section below)</li> <li>If you know the format, use <code>pd.to_datetime()</code>: <code>date_parser=lambda x: pd.to_datetime(x, format=...)</code>
</li> <li>If you have a really non-standard format, use a custom <code>date_parser</code> function. For optimal performance, this should be vectorized, i.e., it should accept arrays as arguments.</li> </ol> <p>You can explore the date parsing functionality in <code>date_converters.py</code> and add your own. We would love to turn this module into a community supported set of date/time parsers. To get you started, <code>date_converters.py</code> contains functions to parse dual date and time columns, year/month/day columns, and year/month/day/hour/minute/second columns. It also contains a <code>generic_parser</code> function so you can curry it with a function that deals with a single date rather than the entire array.</p>   <h4 id="io-dayfirst">Inferring Datetime Format</h4> <p id="inferring-datetime-format">If you have <code>parse_dates</code> enabled for some or all of your columns, and your datetime strings are all formatted the same way, you may get a large speed up by setting <code>infer_datetime_format=True</code>. If set, pandas will attempt to guess the format of your datetime strings, and then use a faster means of parsing the strings. 5-10x parsing speeds have been observed. pandas will fallback to the usual parsing if either the format cannot be guessed or the format that was guessed cannot properly parse the entire column of strings. So in general, <code>infer_datetime_format</code> should not have any negative consequences if enabled.</p> <p>Here are some examples of datetime strings that can be guessed (All representing December 30th, 2011 at 00:00:00)</p> <ul class="simple"> <li>“20111230”</li> <li>“2011/12/30”</li> <li>“20111230 00:00:00”</li> <li>“12/30/2011 00:00:00”</li> <li>“30/Dec/2011 00:00:00”</li> <li>“30/December/2011 00:00:00”</li> </ul> <p><code>infer_datetime_format</code> is sensitive to <code>dayfirst</code>. With <code>dayfirst=True</code>, it will guess “01/12/2011” to be December 1st. With <code>dayfirst=False</code> (default) it will guess “01/12/2011” to be January 12th.</p> <pre data-language="python"># Try to infer the format for the index column
In [105]: df = pd.read_csv('foo.csv', index_col=0, parse_dates=True,
   .....:                  infer_datetime_format=True)
   .....: 

In [106]: df
Out[106]: 
            A  B  C
date               
2009-01-01  a  1  2
2009-01-02  b  3  4
2009-01-03  c  4  5
</pre>   <h4 id="international-date-formats">International Date Formats</h4> <p>While US date formats tend to be MM/DD/YYYY, many international formats use DD/MM/YYYY instead. For convenience, a <code>dayfirst</code> keyword is provided:</p> <pre data-language="python">In [107]: print(open('tmp.csv').read())
date,value,cat
1/6/2000,5,a
2/6/2000,10,b
3/6/2000,15,c

In [108]: pd.read_csv('tmp.csv', parse_dates=[0])
Out[108]: 
        date  value cat
0 2000-01-06      5   a
1 2000-02-06     10   b
2 2000-03-06     15   c

In [109]: pd.read_csv('tmp.csv', dayfirst=True, parse_dates=[0])
Out[109]: 
        date  value cat
0 2000-06-01      5   a
1 2000-06-02     10   b
2 2000-06-03     15   c
</pre>    <h3 id="io-float-precision">Specifying method for floating-point conversion</h3> <p id="specifying-method-for-floating-point-conversion">The parameter <code>float_precision</code> can be specified in order to use a specific floating-point converter during parsing with the C engine. The options are the ordinary converter, the high-precision converter, and the round-trip converter (which is guaranteed to round-trip values after writing to a file). For example:</p> <pre data-language="python">In [110]: val = '0.3066101993807095471566981359501369297504425048828125'

In [111]: data = 'a,b,c\n1,2,{0}'.format(val)

In [112]: abs(pd.read_csv(StringIO(data), engine='c', float_precision=None)['c'][0] - float(val))
Out[112]: 1.1102230246251565e-16

In [113]: abs(pd.read_csv(StringIO(data), engine='c', float_precision='high')['c'][0] - float(val))
Out[113]: 5.5511151231257827e-17

In [114]: abs(pd.read_csv(StringIO(data), engine='c', float_precision='round_trip')['c'][0] - float(val))
Out[114]: 0.0
</pre>   <h3 id="io-thousands">Thousand Separators</h3> <p id="thousand-separators">For large numbers that have been written with a thousands separator, you can set the <code>thousands</code> keyword to a string of length 1 so that integers will be parsed correctly:</p> <p>By default, numbers with a thousands separator will be parsed as strings</p> <pre data-language="python">In [115]: print(open('tmp.csv').read())
ID|level|category
Patient1|123,000|x
Patient2|23,000|y
Patient3|1,234,018|z

In [116]: df = pd.read_csv('tmp.csv', sep='|')

In [117]: df
Out[117]: 
         ID      level category
0  Patient1    123,000        x
1  Patient2     23,000        y
2  Patient3  1,234,018        z

In [118]: df.level.dtype
Out[118]: dtype('O')
</pre> <p>The <code>thousands</code> keyword allows integers to be parsed correctly</p> <pre data-language="python">In [119]: print(open('tmp.csv').read())
ID|level|category
Patient1|123,000|x
Patient2|23,000|y
Patient3|1,234,018|z

In [120]: df = pd.read_csv('tmp.csv', sep='|', thousands=',')

In [121]: df
Out[121]: 
         ID    level category
0  Patient1   123000        x
1  Patient2    23000        y
2  Patient3  1234018        z

In [122]: df.level.dtype
Out[122]: dtype('int64')
</pre>   <h3 id="io-na-values">NA Values</h3> <p id="na-values">To control which values are parsed as missing values (which are signified by <code>NaN</code>), specifiy a string in <code>na_values</code>. If you specify a list of strings, then all values in it are considered to be missing values. If you specify a number (a <code>float</code>, like <code>5.0</code> or an <code>integer</code> like <code>5</code>), the corresponding equivalent values will also imply a missing value (in this case effectively <code>[5.0,5]</code> are recognized as <code>NaN</code>.</p> <p>To completely override the default values that are recognized as missing, specify <code>keep_default_na=False</code>. The default <code>NaN</code> recognized values are <code>['-1.#IND', '1.#QNAN', '1.#IND', '-1.#QNAN', '#N/A','N/A', 'NA',
'#NA', 'NULL', 'NaN', '-NaN', 'nan', '-nan']</code>. Although a 0-length string <code>''</code> is not included in the default <code>NaN</code> values list, it is still treated as a missing value.</p> <pre data-language="python">read_csv(path, na_values=[5])
</pre> <p>the default values, in addition to <code>5</code> , <code>5.0</code> when interpreted as numbers are recognized as <code>NaN</code></p> <pre data-language="python">read_csv(path, keep_default_na=False, na_values=[""])
</pre> <p>only an empty field will be <code>NaN</code></p> <pre data-language="python">read_csv(path, keep_default_na=False, na_values=["NA", "0"])
</pre> <p>only <code>NA</code> and <code>0</code> as strings are <code>NaN</code></p> <pre data-language="python">read_csv(path, na_values=["Nope"])
</pre> <p>the default values, in addition to the string <code>"Nope"</code> are recognized as <code>NaN</code></p>   <h3 id="io-infinity">Infinity</h3> <p id="infinity"><code>inf</code> like values will be parsed as <code>np.inf</code> (positive infinity), and <code>-inf</code> as <code>-np.inf</code> (negative infinity). These will ignore the case of the value, meaning <code>Inf</code>, will also be parsed as <code>np.inf</code>.</p>   <h3 id="returning-series">Returning Series</h3> <p>Using the <code>squeeze</code> keyword, the parser will return output with a single column as a <code>Series</code>:</p> <pre data-language="python">In [123]: print(open('tmp.csv').read())
level
Patient1,123000
Patient2,23000
Patient3,1234018

In [124]: output =  pd.read_csv('tmp.csv', squeeze=True)

In [125]: output
Out[125]: 
Patient1     123000
Patient2      23000
Patient3    1234018
Name: level, dtype: int64

In [126]: type(output)
Out[126]: pandas.core.series.Series
</pre>   <h3 id="io-boolean">Boolean values</h3> <p id="boolean-values">The common values <code>True</code>, <code>False</code>, <code>TRUE</code>, and <code>FALSE</code> are all recognized as boolean. Sometime you would want to recognize some other values as being boolean. To do this use the <code>true_values</code> and <code>false_values</code> options:</p> <pre data-language="python">In [127]: data= 'a,b,c\n1,Yes,2\n3,No,4'

In [128]: print(data)
a,b,c
1,Yes,2
3,No,4

In [129]: pd.read_csv(StringIO(data))
Out[129]: 
   a    b  c
0  1  Yes  2
1  3   No  4

In [130]: pd.read_csv(StringIO(data), true_values=['Yes'], false_values=['No'])
Out[130]: 
   a      b  c
0  1   True  2
1  3  False  4
</pre>   <h3 id="io-bad-lines">Handling “bad” lines</h3> <p id="handling-bad-lines">Some files may have malformed lines with too few fields or too many. Lines with too few fields will have NA values filled in the trailing fields. Lines with too many will cause an error by default:</p> <pre data-language="python">In [27]: data = 'a,b,c\n1,2,3\n4,5,6,7\n8,9,10'

In [28]: pd.read_csv(StringIO(data))
---------------------------------------------------------------------------
CParserError                              Traceback (most recent call last)
CParserError: Error tokenizing data. C error: Expected 3 fields in line 3, saw 4
</pre> <p>You can elect to skip bad lines:</p> <pre data-language="python">In [29]: pd.read_csv(StringIO(data), error_bad_lines=False)
Skipping line 3: expected 3 fields, saw 4

Out[29]:
   a  b   c
0  1  2   3
1  8  9  10
</pre>   <h3 id="io-quoting">Quoting and Escape Characters</h3> <p id="quoting-and-escape-characters">Quotes (and other escape characters) in embedded fields can be handled in any number of ways. One way is to use backslashes; to properly parse this data, you should pass the <code>escapechar</code> option:</p> <pre data-language="python">In [131]: data = 'a,b\n"hello, \\"Bob\\", nice to see you",5'

In [132]: print(data)
a,b
"hello, \"Bob\", nice to see you",5

In [133]: pd.read_csv(StringIO(data), escapechar='\\')
Out[133]: 
                               a  b
0  hello, "Bob", nice to see you  5
</pre>   <h3 id="io-fwf">Files with Fixed Width Columns</h3> <p id="files-with-fixed-width-columns">While <code>read_csv</code> reads delimited data, the <a class="reference internal" href="../generated/pandas.read_fwf/#pandas.read_fwf" title="pandas.read_fwf"><code>read_fwf()</code></a> function works with data files that have known and fixed column widths. The function parameters to <code>read_fwf</code> are largely the same as <code>read_csv</code> with two extra parameters:</p>  <ul class="simple"> <li>
<code>colspecs</code>: A list of pairs (tuples) giving the extents of the fixed-width fields of each line as half-open intervals (i.e., [from, to[ ). String value ‘infer’ can be used to instruct the parser to try detecting the column specifications from the first 100 rows of the data. Default behaviour, if not specified, is to infer.</li> <li>
<code>widths</code>: A list of field widths which can be used instead of ‘colspecs’ if the intervals are contiguous.</li> </ul>  <p>Consider a typical fixed-width data file:</p> <pre data-language="python">In [134]: print(open('bar.csv').read())
id8141    360.242940   149.910199   11950.7
id1594    444.953632   166.985655   11788.4
id1849    364.136849   183.628767   11806.2
id1230    413.836124   184.375703   11916.8
id1948    502.953953   173.237159   12468.3
</pre> <p>In order to parse this file into a DataFrame, we simply need to supply the column specifications to the <code>read_fwf</code> function along with the file name:</p> <pre data-language="python">#Column specifications are a list of half-intervals
In [135]: colspecs = [(0, 6), (8, 20), (21, 33), (34, 43)]

In [136]: df = pd.read_fwf('bar.csv', colspecs=colspecs, header=None, index_col=0)

In [137]: df
Out[137]: 
                 1           2        3
0                                      
id8141  360.242940  149.910199  11950.7
id1594  444.953632  166.985655  11788.4
id1849  364.136849  183.628767  11806.2
id1230  413.836124  184.375703  11916.8
id1948  502.953953  173.237159  12468.3
</pre> <p>Note how the parser automatically picks column names X.&lt;column number&gt; when <code>header=None</code> argument is specified. Alternatively, you can supply just the column widths for contiguous columns:</p> <pre data-language="python">#Widths are a list of integers
In [138]: widths = [6, 14, 13, 10]

In [139]: df = pd.read_fwf('bar.csv', widths=widths, header=None)

In [140]: df
Out[140]: 
        0           1           2        3
0  id8141  360.242940  149.910199  11950.7
1  id1594  444.953632  166.985655  11788.4
2  id1849  364.136849  183.628767  11806.2
3  id1230  413.836124  184.375703  11916.8
4  id1948  502.953953  173.237159  12468.3
</pre> <p>The parser will take care of extra white spaces around the columns so it’s ok to have extra separation between the columns in the file.</p> <div class="versionadded"> <p><span class="versionmodified">New in version 0.13.0.</span></p> </div> <p>By default, <code>read_fwf</code> will try to infer the file’s <code>colspecs</code> by using the first 100 rows of the file. It can do it only in cases when the columns are aligned and correctly separated by the provided <code>delimiter</code> (default delimiter is whitespace).</p> <pre data-language="python">In [141]: df = pd.read_fwf('bar.csv', header=None, index_col=0)

In [142]: df
Out[142]: 
                 1           2        3
0                                      
id8141  360.242940  149.910199  11950.7
id1594  444.953632  166.985655  11788.4
id1849  364.136849  183.628767  11806.2
id1230  413.836124  184.375703  11916.8
id1948  502.953953  173.237159  12468.3
</pre>   <h3 id="indexes">Indexes</h3>  <h4 id="files-with-an-implicit-index-column">Files with an “implicit” index column</h4> <p>Consider a file with one less entry in the header than the number of data column:</p> <pre data-language="python">In [143]: print(open('foo.csv').read())
A,B,C
20090101,a,1,2
20090102,b,3,4
20090103,c,4,5
</pre> <p>In this special case, <code>read_csv</code> assumes that the first column is to be used as the index of the DataFrame:</p> <pre data-language="python">In [144]: pd.read_csv('foo.csv')
Out[144]: 
          A  B  C
20090101  a  1  2
20090102  b  3  4
20090103  c  4  5
</pre> <p>Note that the dates weren’t automatically parsed. In that case you would need to do as before:</p> <pre data-language="python">In [145]: df = pd.read_csv('foo.csv', parse_dates=True)

In [146]: df.index
Out[146]: DatetimeIndex(['2009-01-01', '2009-01-02', '2009-01-03'], dtype='datetime64[ns]', freq=None)
</pre>   <h4 id="reading-an-index-with-a-multiindex">Reading an index with a <code>MultiIndex</code>
</h4> <p id="io-csv-multiindex">Suppose you have data indexed by two columns:</p> <pre data-language="python">In [147]: print(open('data/mindex_ex.csv').read())
year,indiv,zit,xit
1977,"A",1.2,.6
1977,"B",1.5,.5
1977,"C",1.7,.8
1978,"A",.2,.06
1978,"B",.7,.2
1978,"C",.8,.3
1978,"D",.9,.5
1978,"E",1.4,.9
1979,"C",.2,.15
1979,"D",.14,.05
1979,"E",.5,.15
1979,"F",1.2,.5
1979,"G",3.4,1.9
1979,"H",5.4,2.7
1979,"I",6.4,1.2
</pre> <p>The <code>index_col</code> argument to <code>read_csv</code> and <code>read_table</code> can take a list of column numbers to turn multiple columns into a <code>MultiIndex</code> for the index of the returned object:</p> <pre data-language="python">In [148]: df = pd.read_csv("data/mindex_ex.csv", index_col=[0,1])

In [149]: df
Out[149]: 
             zit   xit
year indiv            
1977 A      1.20  0.60
     B      1.50  0.50
     C      1.70  0.80
1978 A      0.20  0.06
     B      0.70  0.20
     C      0.80  0.30
     D      0.90  0.50
     E      1.40  0.90
1979 C      0.20  0.15
     D      0.14  0.05
     E      0.50  0.15
     F      1.20  0.50
     G      3.40  1.90
     H      5.40  2.70
     I      6.40  1.20

In [150]: df.ix[1978]
Out[150]: 
       zit   xit
indiv           
A      0.2  0.06
B      0.7  0.20
C      0.8  0.30
D      0.9  0.50
E      1.4  0.90
</pre>   <h4 id="io-multi-index-columns">Reading columns with a <code>MultiIndex</code>
</h4> <p id="reading-columns-with-a-multiindex">By specifying list of row locations for the <code>header</code> argument, you can read in a <code>MultiIndex</code> for the columns. Specifying non-consecutive rows will skip the intervening rows. In order to have the pre-0.13 behavior of tupleizing columns, specify <code>tupleize_cols=True</code>.</p> <pre data-language="python">In [151]: from pandas.util.testing import makeCustomDataframe as mkdf

In [152]: df = mkdf(5,3,r_idx_nlevels=2,c_idx_nlevels=4)

In [153]: df.to_csv('mi.csv')

In [154]: print(open('mi.csv').read())
C0,,C_l0_g0,C_l0_g1,C_l0_g2
C1,,C_l1_g0,C_l1_g1,C_l1_g2
C2,,C_l2_g0,C_l2_g1,C_l2_g2
C3,,C_l3_g0,C_l3_g1,C_l3_g2
R0,R1,,,
R_l0_g0,R_l1_g0,R0C0,R0C1,R0C2
R_l0_g1,R_l1_g1,R1C0,R1C1,R1C2
R_l0_g2,R_l1_g2,R2C0,R2C1,R2C2
R_l0_g3,R_l1_g3,R3C0,R3C1,R3C2
R_l0_g4,R_l1_g4,R4C0,R4C1,R4C2


In [155]: pd.read_csv('mi.csv',header=[0,1,2,3],index_col=[0,1])
Out[155]: 
C0              C_l0_g0 C_l0_g1 C_l0_g2
C1              C_l1_g0 C_l1_g1 C_l1_g2
C2              C_l2_g0 C_l2_g1 C_l2_g2
C3              C_l3_g0 C_l3_g1 C_l3_g2
R0      R1                             
R_l0_g0 R_l1_g0    R0C0    R0C1    R0C2
R_l0_g1 R_l1_g1    R1C0    R1C1    R1C2
R_l0_g2 R_l1_g2    R2C0    R2C1    R2C2
R_l0_g3 R_l1_g3    R3C0    R3C1    R3C2
R_l0_g4 R_l1_g4    R4C0    R4C1    R4C2
</pre> <p>Starting in 0.13.0, <code>read_csv</code> will be able to interpret a more common format of multi-columns indices.</p> <pre data-language="python">In [156]: print(open('mi2.csv').read())
,a,a,a,b,c,c
,q,r,s,t,u,v
one,1,2,3,4,5,6
two,7,8,9,10,11,12

In [157]: pd.read_csv('mi2.csv',header=[0,1],index_col=0)
Out[157]: 
     a         b   c    
     q  r  s   t   u   v
one  1  2  3   4   5   6
two  7  8  9  10  11  12
</pre> <p>Note: If an <code>index_col</code> is not specified (e.g. you don’t have an index, or wrote it with <code>df.to_csv(..., index=False</code>), then any <code>names</code> on the columns index will be <em>lost</em>.</p>    <h3 id="io-sniff">Automatically “sniffing” the delimiter</h3> <p id="automatically-sniffing-the-delimiter"><code>read_csv</code> is capable of inferring delimited (not necessarily comma-separated) files, as pandas uses the <a class="reference external" href="https://docs.python.org/3/library/csv.html#csv.Sniffer" title="(in Python v3.6)" target="_blank"><code>csv.Sniffer</code></a> class of the csv module. For this, you have to specify <code>sep=None</code>.</p> <pre data-language="python">In [158]: print(open('tmp2.sv').read())
:0:1:2:3
0:0.469112299907:-0.282863344329:-1.50905850317:-1.13563237102
1:1.21211202502:-0.173214649053:0.119208711297:-1.04423596628
2:-0.861848963348:-2.10456921889:-0.494929274069:1.07180380704
3:0.721555162244:-0.70677113363:-1.03957498511:0.271859885543
4:-0.424972329789:0.567020349794:0.276232019278:-1.08740069129
5:-0.673689708088:0.113648409689:-1.47842655244:0.524987667115
6:0.40470521868:0.57704598592:-1.71500201611:-1.03926848351
7:-0.370646858236:-1.15789225064:-1.34431181273:0.844885141425
8:1.07576978372:-0.10904997528:1.64356307036:-1.46938795954
9:0.357020564133:-0.67460010373:-1.77690371697:-0.968913812447


In [159]: pd.read_csv('tmp2.sv', sep=None, engine='python')
Out[159]: 
   Unnamed: 0         0         1         2         3
0           0  0.469112 -0.282863 -1.509059 -1.135632
1           1  1.212112 -0.173215  0.119209 -1.044236
2           2 -0.861849 -2.104569 -0.494929  1.071804
3           3  0.721555 -0.706771 -1.039575  0.271860
4           4 -0.424972  0.567020  0.276232 -1.087401
5           5 -0.673690  0.113648 -1.478427  0.524988
6           6  0.404705  0.577046 -1.715002 -1.039268
7           7 -0.370647 -1.157892 -1.344312  0.844885
8           8  1.075770 -0.109050  1.643563 -1.469388
9           9  0.357021 -0.674600 -1.776904 -0.968914
</pre>   <h3 id="io-chunking">Iterating through files chunk by chunk</h3> <p id="iterating-through-files-chunk-by-chunk">Suppose you wish to iterate through a (potentially very large) file lazily rather than reading the entire file into memory, such as the following:</p> <pre data-language="python">In [160]: print(open('tmp.sv').read())
|0|1|2|3
0|0.469112299907|-0.282863344329|-1.50905850317|-1.13563237102
1|1.21211202502|-0.173214649053|0.119208711297|-1.04423596628
2|-0.861848963348|-2.10456921889|-0.494929274069|1.07180380704
3|0.721555162244|-0.70677113363|-1.03957498511|0.271859885543
4|-0.424972329789|0.567020349794|0.276232019278|-1.08740069129
5|-0.673689708088|0.113648409689|-1.47842655244|0.524987667115
6|0.40470521868|0.57704598592|-1.71500201611|-1.03926848351
7|-0.370646858236|-1.15789225064|-1.34431181273|0.844885141425
8|1.07576978372|-0.10904997528|1.64356307036|-1.46938795954
9|0.357020564133|-0.67460010373|-1.77690371697|-0.968913812447


In [161]: table = pd.read_table('tmp.sv', sep='|')

In [162]: table
Out[162]: 
   Unnamed: 0         0         1         2         3
0           0  0.469112 -0.282863 -1.509059 -1.135632
1           1  1.212112 -0.173215  0.119209 -1.044236
2           2 -0.861849 -2.104569 -0.494929  1.071804
3           3  0.721555 -0.706771 -1.039575  0.271860
4           4 -0.424972  0.567020  0.276232 -1.087401
5           5 -0.673690  0.113648 -1.478427  0.524988
6           6  0.404705  0.577046 -1.715002 -1.039268
7           7 -0.370647 -1.157892 -1.344312  0.844885
8           8  1.075770 -0.109050  1.643563 -1.469388
9           9  0.357021 -0.674600 -1.776904 -0.968914
</pre> <p>By specifying a <code>chunksize</code> to <code>read_csv</code> or <code>read_table</code>, the return value will be an iterable object of type <code>TextFileReader</code>:</p> <pre data-language="python">In [163]: reader = pd.read_table('tmp.sv', sep='|', chunksize=4)

In [164]: reader
Out[164]: &lt;pandas.io.parsers.TextFileReader at 0x7ff27e15a450&gt;

In [165]: for chunk in reader:
   .....:     print(chunk)
   .....: 
   Unnamed: 0         0         1         2         3
0           0  0.469112 -0.282863 -1.509059 -1.135632
1           1  1.212112 -0.173215  0.119209 -1.044236
2           2 -0.861849 -2.104569 -0.494929  1.071804
3           3  0.721555 -0.706771 -1.039575  0.271860
   Unnamed: 0         0         1         2         3
4           4 -0.424972  0.567020  0.276232 -1.087401
5           5 -0.673690  0.113648 -1.478427  0.524988
6           6  0.404705  0.577046 -1.715002 -1.039268
7           7 -0.370647 -1.157892 -1.344312  0.844885
   Unnamed: 0         0        1         2         3
8           8  1.075770 -0.10905  1.643563 -1.469388
9           9  0.357021 -0.67460 -1.776904 -0.968914
</pre> <p>Specifying <code>iterator=True</code> will also return the <code>TextFileReader</code> object:</p> <pre data-language="python">In [166]: reader = pd.read_table('tmp.sv', sep='|', iterator=True)

In [167]: reader.get_chunk(5)
Out[167]: 
   Unnamed: 0         0         1         2         3
0           0  0.469112 -0.282863 -1.509059 -1.135632
1           1  1.212112 -0.173215  0.119209 -1.044236
2           2 -0.861849 -2.104569 -0.494929  1.071804
3           3  0.721555 -0.706771 -1.039575  0.271860
4           4 -0.424972  0.567020  0.276232 -1.087401
</pre>   <h3 id="specifying-the-parser-engine">Specifying the parser engine</h3> <p>Under the hood pandas uses a fast and efficient parser implemented in C as well as a python implementation which is currently more feature-complete. Where possible pandas uses the C parser (specified as <code>engine='c'</code>), but may fall back to python if C-unsupported options are specified. Currently, C-unsupported options include:</p> <ul class="simple"> <li>
<code>sep</code> other than a single character (e.g. regex separators)</li> <li><code>skipfooter</code></li> <li>
<code>sep=None</code> with <code>delim_whitespace=False</code>
</li> </ul> <p>Specifying any of the above options will produce a <code>ParserWarning</code> unless the python engine is selected explicitly using <code>engine='python'</code>.</p>   <h3 id="writing-out-data">Writing out Data</h3>  <h4 id="io-store-in-csv">Writing to CSV format</h4> <p id="writing-to-csv-format">The Series and DataFrame objects have an instance method <code>to_csv</code> which allows storing the contents of the object as a comma-separated-values file. The function takes a number of arguments. Only the first is required.</p>  <ul class="simple"> <li>
<code>path_or_buf</code>: A string path to the file to write or a StringIO</li> <li>
<code>sep</code> : Field delimiter for the output file (default ”,”)</li> <li>
<code>na_rep</code>: A string representation of a missing value (default ‘’)</li> <li>
<code>float_format</code>: Format string for floating point numbers</li> <li>
<code>cols</code>: Columns to write (default None)</li> <li>
<code>header</code>: Whether to write out the column names (default True)</li> <li>
<code>index</code>: whether to write row (index) names (default True)</li> <li>
<code>index_label</code>: Column label(s) for index column(s) if desired. If None (default), and <code>header</code> and <code>index</code> are True, then the index names are used. (A sequence should be given if the DataFrame uses MultiIndex).</li> <li>
<code>mode</code> : Python write mode, default ‘w’</li> <li>
<code>encoding</code>: a string representing the encoding to use if the contents are non-ASCII, for python versions prior to 3</li> <li>
<code>line_terminator</code>: Character sequence denoting line end (default ‘\n’)</li> <li>
<code>quoting</code>: Set quoting rules as in csv module (default csv.QUOTE_MINIMAL). Note that if you have set a <code>float_format</code> then floats are converted to strings and csv.QUOTE_NONNUMERIC will treat them as non-numeric</li> <li>
<code>quotechar</code>: Character used to quote fields (default ‘”’)</li> <li>
<code>doublequote</code>: Control quoting of <code>quotechar</code> in fields (default True)</li> <li>
<code>escapechar</code>: Character used to escape <code>sep</code> and <code>quotechar</code> when appropriate (default None)</li> <li>
<code>chunksize</code>: Number of rows to write at a time</li> <li>
<code>tupleize_cols</code>: If False (default), write as a list of tuples, otherwise write in an expanded line format suitable for <code>read_csv</code>
</li> <li>
<code>date_format</code>: Format string for datetime objects</li> </ul>    <h4 id="writing-a-formatted-string">Writing a formatted string</h4> <p id="io-formatting">The DataFrame object has an instance method <code>to_string</code> which allows control over the string representation of the object. All arguments are optional:</p>  <ul class="simple"> <li>
<code>buf</code> default None, for example a StringIO object</li> <li>
<code>columns</code> default None, which columns to write</li> <li>
<code>col_space</code> default None, minimum width of each column.</li> <li>
<code>na_rep</code> default <code>NaN</code>, representation of NA value</li> <li>
<code>formatters</code> default None, a dictionary (by column) of functions each of which takes a single argument and returns a formatted string</li> <li>
<code>float_format</code> default None, a function which takes a single (float) argument and returns a formatted string; to be applied to floats in the DataFrame.</li> <li>
<code>sparsify</code> default True, set to False for a DataFrame with a hierarchical index to print every multiindex key at each row.</li> <li>
<code>index_names</code> default True, will print the names of the indices</li> <li>
<code>index</code> default True, will print the index (ie, row labels)</li> <li>
<code>header</code> default True, will print the column labels</li> <li>
<code>justify</code> default <code>left</code>, will print column headers left- or right-justified</li> </ul>  <p>The Series object also has a <code>to_string</code> method, but with only the <code>buf</code>, <code>na_rep</code>, <code>float_format</code> arguments. There is also a <code>length</code> argument which, if set to <code>True</code>, will additionally output the length of the Series.</p>     <h2 id="io-json">JSON</h2> <p id="json">Read and write <code>JSON</code> format files and strings.</p>  <h3 id="io-json-writer">Writing JSON</h3> <p id="writing-json">A <code>Series</code> or <code>DataFrame</code> can be converted to a valid JSON string. Use <code>to_json</code> with optional parameters:</p> <ul> <li>
<code>path_or_buf</code> : the pathname or buffer to write the output This can be <code>None</code> in which case a JSON string is returned </li> <li>
<p class="first"><code>orient</code> :</p> <dl class="docutils"> <dt>Series :</dt> <dd>
<ul class="first last simple"> <li>default is <code>index</code>
</li> <li>allowed values are {<code>split</code>, <code>records</code>, <code>index</code>}</li> </ul> </dd> <dt>DataFrame</dt> <dd>
<ul class="first last simple"> <li>default is <code>columns</code>
</li> <li>allowed values are {<code>split</code>, <code>records</code>, <code>index</code>, <code>columns</code>, <code>values</code>}</li> </ul> </dd> </dl> <p>The format of the JSON string</p> <table class="docutils">   <tr class="row-odd">
<td><code>split</code></td> <td>dict like {index -&gt; [index], columns -&gt; [columns], data -&gt; [values]}</td> </tr> <tr class="row-even">
<td><code>records</code></td> <td>list like [{column -&gt; value}, ... , {column -&gt; value}]</td> </tr> <tr class="row-odd">
<td><code>index</code></td> <td>dict like {index -&gt; {column -&gt; value}}</td> </tr> <tr class="row-even">
<td><code>columns</code></td> <td>dict like {column -&gt; {index -&gt; value}}</td> </tr> <tr class="row-odd">
<td><code>values</code></td> <td>just the values array</td> </tr>  </table> </li> <li>
<code>date_format</code> : string, type of date conversion, ‘epoch’ for timestamp, ‘iso’ for ISO8601. </li> <li>
<code>double_precision</code> : The number of decimal places to use when encoding floating point values, default 10. </li> <li>
<code>force_ascii</code> : force encoded string to be ASCII, default True. </li> <li>
<code>date_unit</code> : The time unit to encode to, governs timestamp and ISO8601 precision. One of ‘s’, ‘ms’, ‘us’ or ‘ns’ for seconds, milliseconds, microseconds and nanoseconds respectively. Default ‘ms’. </li> <li>
<code>default_handler</code> : The handler to call if an object cannot otherwise be converted to a suitable format for JSON. Takes a single argument, which is the object to convert, and returns a serializable object. </li> <li>
<code>lines</code> : If <code>records</code> orient, then will write each record per line as json. </li> </ul> <p>Note <code>NaN</code>‘s, <code>NaT</code>‘s and <code>None</code> will be converted to <code>null</code> and <code>datetime</code> objects will be converted based on the <code>date_format</code> and <code>date_unit</code> parameters.</p> <pre data-language="python">In [168]: dfj = pd.DataFrame(randn(5, 2), columns=list('AB'))

In [169]: json = dfj.to_json()

In [170]: json
Out[170]: '{"A":{"0":-1.2945235903,"1":0.2766617129,"2":-0.0139597524,"3":-0.0061535699,"4":0.8957173022},"B":{"0":0.4137381054,"1":-0.472034511,"2":-0.3625429925,"3":-0.923060654,"4":0.8052440254}}'
</pre>  <h4 id="orient-options">Orient Options</h4> <p>There are a number of different options for the format of the resulting JSON file / string. Consider the following DataFrame and Series:</p> <pre data-language="python">In [171]: dfjo = pd.DataFrame(dict(A=range(1, 4), B=range(4, 7), C=range(7, 10)),
   .....:                     columns=list('ABC'), index=list('xyz'))
   .....: 

In [172]: dfjo
Out[172]: 
   A  B  C
x  1  4  7
y  2  5  8
z  3  6  9

In [173]: sjo = pd.Series(dict(x=15, y=16, z=17), name='D')

In [174]: sjo
Out[174]: 
x    15
y    16
z    17
Name: D, dtype: int64
</pre> <p><strong>Column oriented</strong> (the default for <code>DataFrame</code>) serializes the data as nested JSON objects with column labels acting as the primary index:</p> <pre data-language="python">In [175]: dfjo.to_json(orient="columns")
Out[175]: '{"A":{"x":1,"y":2,"z":3},"B":{"x":4,"y":5,"z":6},"C":{"x":7,"y":8,"z":9}}'

</pre> <p><strong>Index oriented</strong> (the default for <code>Series</code>) similar to column oriented but the index labels are now primary:</p> <pre data-language="python">In [176]: dfjo.to_json(orient="index")
Out[176]: '{"x":{"A":1,"B":4,"C":7},"y":{"A":2,"B":5,"C":8},"z":{"A":3,"B":6,"C":9}}'

In [177]: sjo.to_json(orient="index")
Out[177]: '{"x":15,"y":16,"z":17}'
</pre> <p><strong>Record oriented</strong> serializes the data to a JSON array of column -&gt; value records, index labels are not included. This is useful for passing DataFrame data to plotting libraries, for example the JavaScript library d3.js:</p> <pre data-language="python">In [178]: dfjo.to_json(orient="records")
Out[178]: '[{"A":1,"B":4,"C":7},{"A":2,"B":5,"C":8},{"A":3,"B":6,"C":9}]'

In [179]: sjo.to_json(orient="records")
Out[179]: '[15,16,17]'
</pre> <p><strong>Value oriented</strong> is a bare-bones option which serializes to nested JSON arrays of values only, column and index labels are not included:</p> <pre data-language="python">In [180]: dfjo.to_json(orient="values")
Out[180]: '[[1,4,7],[2,5,8],[3,6,9]]'

</pre> <p><strong>Split oriented</strong> serializes to a JSON object containing separate entries for values, index and columns. Name is also included for <code>Series</code>:</p> <pre data-language="python">In [181]: dfjo.to_json(orient="split")
Out[181]: '{"columns":["A","B","C"],"index":["x","y","z"],"data":[[1,4,7],[2,5,8],[3,6,9]]}'

In [182]: sjo.to_json(orient="split")
Out[182]: '{"name":"D","index":["x","y","z"],"data":[15,16,17]}'
</pre> <div class="admonition note"> <p class="first admonition-title">Note</p> <p class="last">Any orient option that encodes to a JSON object will not preserve the ordering of index and column labels during round-trip serialization. If you wish to preserve label ordering use the <code>split</code> option as it uses ordered containers.</p> </div>   <h4 id="id1">Date Handling</h4> <p>Writing in ISO date format</p> <pre data-language="python">In [183]: dfd = pd.DataFrame(randn(5, 2), columns=list('AB'))

In [184]: dfd['date'] = pd.Timestamp('20130101')

In [185]: dfd = dfd.sort_index(1, ascending=False)

In [186]: json = dfd.to_json(date_format='iso')

In [187]: json
Out[187]: '{"date":{"0":"2013-01-01T00:00:00.000Z","1":"2013-01-01T00:00:00.000Z","2":"2013-01-01T00:00:00.000Z","3":"2013-01-01T00:00:00.000Z","4":"2013-01-01T00:00:00.000Z"},"B":{"0":2.5656459463,"1":1.3403088498,"2":-0.2261692849,"3":0.8138502857,"4":-0.8273169356},"A":{"0":-1.2064117817,"1":1.4312559863,"2":-1.1702987971,"3":0.4108345112,"4":0.1320031703}}'
</pre> <p>Writing in ISO date format, with microseconds</p> <pre data-language="python">In [188]: json = dfd.to_json(date_format='iso', date_unit='us')

In [189]: json
Out[189]: '{"date":{"0":"2013-01-01T00:00:00.000000Z","1":"2013-01-01T00:00:00.000000Z","2":"2013-01-01T00:00:00.000000Z","3":"2013-01-01T00:00:00.000000Z","4":"2013-01-01T00:00:00.000000Z"},"B":{"0":2.5656459463,"1":1.3403088498,"2":-0.2261692849,"3":0.8138502857,"4":-0.8273169356},"A":{"0":-1.2064117817,"1":1.4312559863,"2":-1.1702987971,"3":0.4108345112,"4":0.1320031703}}'
</pre> <p>Epoch timestamps, in seconds</p> <pre data-language="python">In [190]: json = dfd.to_json(date_format='epoch', date_unit='s')

In [191]: json
Out[191]: '{"date":{"0":1356998400,"1":1356998400,"2":1356998400,"3":1356998400,"4":1356998400},"B":{"0":2.5656459463,"1":1.3403088498,"2":-0.2261692849,"3":0.8138502857,"4":-0.8273169356},"A":{"0":-1.2064117817,"1":1.4312559863,"2":-1.1702987971,"3":0.4108345112,"4":0.1320031703}}'
</pre> <p>Writing to a file, with a date index and a date column</p> <pre data-language="python">In [192]: dfj2 = dfj.copy()

In [193]: dfj2['date'] = pd.Timestamp('20130101')

In [194]: dfj2['ints'] = list(range(5))

In [195]: dfj2['bools'] = True

In [196]: dfj2.index = pd.date_range('20130101', periods=5)

In [197]: dfj2.to_json('test.json')

In [198]: open('test.json').read()
Out[198]: '{"A":{"1356998400000":-1.2945235903,"1357084800000":0.2766617129,"1357171200000":-0.0139597524,"1357257600000":-0.0061535699,"1357344000000":0.8957173022},"B":{"1356998400000":0.4137381054,"1357084800000":-0.472034511,"1357171200000":-0.3625429925,"1357257600000":-0.923060654,"1357344000000":0.8052440254},"date":{"1356998400000":1356998400000,"1357084800000":1356998400000,"1357171200000":1356998400000,"1357257600000":1356998400000,"1357344000000":1356998400000},"ints":{"1356998400000":0,"1357084800000":1,"1357171200000":2,"1357257600000":3,"1357344000000":4},"bools":{"1356998400000":true,"1357084800000":true,"1357171200000":true,"1357257600000":true,"1357344000000":true}}'
</pre>   <h4 id="fallback-behavior">Fallback Behavior</h4> <p>If the JSON serializer cannot handle the container contents directly it will fallback in the following manner:</p> <ul class="simple"> <li>if the dtype is unsupported (e.g. <code>np.complex</code>) then the <code>default_handler</code>, if provided, will be called for each value, otherwise an exception is raised.</li> <li>if an object is unsupported it will attempt the following:<ul> <li>check if the object has defined a <code>toDict</code> method and call it. A <code>toDict</code> method should return a <code>dict</code> which will then be JSON serialized.</li> <li>invoke the <code>default_handler</code> if one was provided.</li> <li>convert the object to a <code>dict</code> by traversing its contents. However this will often fail with an <code>OverflowError</code> or give unexpected results.</li> </ul> </li> </ul> <p>In general the best approach for unsupported objects or dtypes is to provide a <code>default_handler</code>. For example:</p> <pre data-language="python">DataFrame([1.0, 2.0, complex(1.0, 2.0)]).to_json()  # raises

RuntimeError: Unhandled numpy dtype 15
</pre> <p>can be dealt with by specifying a simple <code>default_handler</code>:</p> <pre data-language="python">In [199]: pd.DataFrame([1.0, 2.0, complex(1.0, 2.0)]).to_json(default_handler=str)
Out[199]: '{"0":{"0":"(1+0j)","1":"(2+0j)","2":"(1+2j)"}}'
</pre>    <h3 id="io-json-reader">Reading JSON</h3> <p id="reading-json">Reading a JSON string to pandas object can take a number of parameters. The parser will try to parse a <code>DataFrame</code> if <code>typ</code> is not supplied or is <code>None</code>. To explicitly force <code>Series</code> parsing, pass <code>typ=series</code></p> <ul> <li>
<code>filepath_or_buffer</code> : a <strong>VALID</strong> JSON string or file handle / StringIO. The string could be a URL. Valid URL schemes include http, ftp, S3, and file. For file URLs, a host is expected. For instance, a local file could be file ://localhost/path/to/table.json </li> <li>
<code>typ</code> : type of object to recover (series or frame), default ‘frame’ </li> <li>
<p class="first"><code>orient</code> :</p> <dl class="docutils"> <dt>Series :</dt> <dd>
<ul class="first last simple"> <li>default is <code>index</code>
</li> <li>allowed values are {<code>split</code>, <code>records</code>, <code>index</code>}</li> </ul> </dd> <dt>DataFrame</dt> <dd>
<ul class="first last simple"> <li>default is <code>columns</code>
</li> <li>allowed values are {<code>split</code>, <code>records</code>, <code>index</code>, <code>columns</code>, <code>values</code>}</li> </ul> </dd> </dl> <p>The format of the JSON string</p> <table class="docutils">   <tr class="row-odd">
<td><code>split</code></td> <td>dict like {index -&gt; [index], columns -&gt; [columns], data -&gt; [values]}</td> </tr> <tr class="row-even">
<td><code>records</code></td> <td>list like [{column -&gt; value}, ... , {column -&gt; value}]</td> </tr> <tr class="row-odd">
<td><code>index</code></td> <td>dict like {index -&gt; {column -&gt; value}}</td> </tr> <tr class="row-even">
<td><code>columns</code></td> <td>dict like {column -&gt; {index -&gt; value}}</td> </tr> <tr class="row-odd">
<td><code>values</code></td> <td>just the values array</td> </tr>  </table> </li> <li>
<code>dtype</code> : if True, infer dtypes, if a dict of column to dtype, then use those, if False, then don’t infer dtypes at all, default is True, apply only to the data </li> <li>
<code>convert_axes</code> : boolean, try to convert the axes to the proper dtypes, default is True </li> <li>
<code>convert_dates</code> : a list of columns to parse for dates; If True, then try to parse date-like columns, default is True </li> <li>
<code>keep_default_dates</code> : boolean, default True. If parsing dates, then parse the default date-like columns </li> <li>
<code>numpy</code> : direct decoding to numpy arrays. default is False; Supports numeric data only, although labels may be non-numeric. Also note that the JSON ordering <strong>MUST</strong> be the same for each term if <code>numpy=True</code> </li> <li>
<code>precise_float</code> : boolean, default <code>False</code>. Set to enable usage of higher precision (strtod) function when decoding string to double values. Default (<code>False</code>) is to use fast but less precise builtin functionality </li> <li>
<code>date_unit</code> : string, the timestamp unit to detect if converting dates. Default None. By default the timestamp precision will be detected, if this is not desired then pass one of ‘s’, ‘ms’, ‘us’ or ‘ns’ to force timestamp precision to seconds, milliseconds, microseconds or nanoseconds respectively. </li> <li>
<code>lines</code> : reads file as one json object per line. </li> <li>
<code>encoding</code> : The encoding to use to decode py3 bytes. </li> </ul> <p>The parser will raise one of <code>ValueError/TypeError/AssertionError</code> if the JSON is not parseable.</p> <p>If a non-default <code>orient</code> was used when encoding to JSON be sure to pass the same option here so that decoding produces sensible results, see <a class="reference internal" href="#orient-options">Orient Options</a> for an overview.</p>  <h4 id="data-conversion">Data Conversion</h4> <p>The default of <code>convert_axes=True</code>, <code>dtype=True</code>, and <code>convert_dates=True</code> will try to parse the axes, and all of the data into appropriate types, including dates. If you need to override specific dtypes, pass a dict to <code>dtype</code>. <code>convert_axes</code> should only be set to <code>False</code> if you need to preserve string-like numbers (e.g. ‘1’, ‘2’) in an axes.</p> <div class="admonition note"> <p class="first admonition-title">Note</p> <p>Large integer values may be converted to dates if <code>convert_dates=True</code> and the data and / or column labels appear ‘date-like’. The exact threshold depends on the <code>date_unit</code> specified. ‘date-like’ means that the column label meets one of the following criteria:</p>  <ul class="simple"> <li>it ends with <code>'_at'</code>
</li> <li>it ends with <code>'_time'</code>
</li> <li>it begins with <code>'timestamp'</code>
</li> <li>it is <code>'modified'</code>
</li> <li>it is <code>'date'</code>
</li> </ul>  </div> <div class="admonition warning"> <p class="first admonition-title">Warning</p> <p>When reading JSON data, automatic coercing into dtypes has some quirks:</p>  <ul class="simple"> <li>an index can be reconstructed in a different order from serialization, that is, the returned order is not guaranteed to be the same as before serialization</li> <li>a column that was <code>float</code> data will be converted to <code>integer</code> if it can be done safely, e.g. a column of <code>1.</code>
</li> <li>bool columns will be converted to <code>integer</code> on reconstruction</li> </ul>  <p class="last">Thus there are times where you may want to specify specific dtypes via the <code>dtype</code> keyword argument.</p> </div> <p>Reading from a JSON string:</p> <pre data-language="python">In [200]: pd.read_json(json)
Out[200]: 
          A         B       date
0 -1.206412  2.565646 2013-01-01
1  1.431256  1.340309 2013-01-01
2 -1.170299 -0.226169 2013-01-01
3  0.410835  0.813850 2013-01-01
4  0.132003 -0.827317 2013-01-01
</pre> <p>Reading from a file:</p> <pre data-language="python">In [201]: pd.read_json('test.json')
Out[201]: 
                   A         B bools       date  ints
2013-01-01 -1.294524  0.413738  True 2013-01-01     0
2013-01-02  0.276662 -0.472035  True 2013-01-01     1
2013-01-03 -0.013960 -0.362543  True 2013-01-01     2
2013-01-04 -0.006154 -0.923061  True 2013-01-01     3
2013-01-05  0.895717  0.805244  True 2013-01-01     4
</pre> <p>Don’t convert any data (but still convert axes and dates):</p> <pre data-language="python">In [202]: pd.read_json('test.json', dtype=object).dtypes
Out[202]: 
A        object
B        object
bools    object
date     object
ints     object
dtype: object
</pre> <p>Specify dtypes for conversion:</p> <pre data-language="python">In [203]: pd.read_json('test.json', dtype={'A' : 'float32', 'bools' : 'int8'}).dtypes
Out[203]: 
A               float32
B               float64
bools              int8
date     datetime64[ns]
ints              int64
dtype: object
</pre> <p>Preserve string indices:</p> <pre data-language="python">In [204]: si = pd.DataFrame(np.zeros((4, 4)),
   .....:          columns=list(range(4)),
   .....:          index=[str(i) for i in range(4)])
   .....: 

In [205]: si
Out[205]: 
     0    1    2    3
0  0.0  0.0  0.0  0.0
1  0.0  0.0  0.0  0.0
2  0.0  0.0  0.0  0.0
3  0.0  0.0  0.0  0.0

In [206]: si.index
Out[206]: Index([u'0', u'1', u'2', u'3'], dtype='object')

In [207]: si.columns
Out[207]: Int64Index([0, 1, 2, 3], dtype='int64')

In [208]: json = si.to_json()

In [209]: sij = pd.read_json(json, convert_axes=False)

In [210]: sij
Out[210]: 
   0  1  2  3
0  0  0  0  0
1  0  0  0  0
2  0  0  0  0
3  0  0  0  0

In [211]: sij.index
Out[211]: Index([u'0', u'1', u'2', u'3'], dtype='object')

In [212]: sij.columns
Out[212]: Index([u'0', u'1', u'2', u'3'], dtype='object')
</pre> <p>Dates written in nanoseconds need to be read back in nanoseconds:</p> <pre data-language="python">In [213]: json = dfj2.to_json(date_unit='ns')

# Try to parse timestamps as millseconds -&gt; Won't Work
In [214]: dfju = pd.read_json(json, date_unit='ms')

In [215]: dfju
Out[215]: 
                            A         B bools                 date  ints
1356998400000000000 -1.294524  0.413738  True  1356998400000000000     0
1357084800000000000  0.276662 -0.472035  True  1356998400000000000     1
1357171200000000000 -0.013960 -0.362543  True  1356998400000000000     2
1357257600000000000 -0.006154 -0.923061  True  1356998400000000000     3
1357344000000000000  0.895717  0.805244  True  1356998400000000000     4

# Let pandas detect the correct precision
In [216]: dfju = pd.read_json(json)

In [217]: dfju
Out[217]: 
                   A         B bools       date  ints
2013-01-01 -1.294524  0.413738  True 2013-01-01     0
2013-01-02  0.276662 -0.472035  True 2013-01-01     1
2013-01-03 -0.013960 -0.362543  True 2013-01-01     2
2013-01-04 -0.006154 -0.923061  True 2013-01-01     3
2013-01-05  0.895717  0.805244  True 2013-01-01     4

# Or specify that all timestamps are in nanoseconds
In [218]: dfju = pd.read_json(json, date_unit='ns')

In [219]: dfju
Out[219]: 
                   A         B bools       date  ints
2013-01-01 -1.294524  0.413738  True 2013-01-01     0
2013-01-02  0.276662 -0.472035  True 2013-01-01     1
2013-01-03 -0.013960 -0.362543  True 2013-01-01     2
2013-01-04 -0.006154 -0.923061  True 2013-01-01     3
2013-01-05  0.895717  0.805244  True 2013-01-01     4
</pre>   <h4 id="the-numpy-parameter">The Numpy Parameter</h4> <div class="admonition note"> <p class="first admonition-title">Note</p> <p class="last">This supports numeric data only. Index and columns labels may be non-numeric, e.g. strings, dates etc.</p> </div> <p>If <code>numpy=True</code> is passed to <code>read_json</code> an attempt will be made to sniff an appropriate dtype during deserialization and to subsequently decode directly to numpy arrays, bypassing the need for intermediate Python objects.</p> <p>This can provide speedups if you are deserialising a large amount of numeric data:</p> <pre data-language="python">In [220]: randfloats = np.random.uniform(-100, 1000, 10000)

In [221]: randfloats.shape = (1000, 10)

In [222]: dffloats = pd.DataFrame(randfloats, columns=list('ABCDEFGHIJ'))

In [223]: jsonfloats = dffloats.to_json()
</pre> <pre data-language="python">In [224]: timeit pd.read_json(jsonfloats)
100 loops, best of 3: 12.2 ms per loop
</pre> <pre data-language="python">In [225]: timeit pd.read_json(jsonfloats, numpy=True)
100 loops, best of 3: 7.35 ms per loop
</pre> <p>The speedup is less noticeable for smaller datasets:</p> <pre data-language="python">In [226]: jsonfloats = dffloats.head(100).to_json()
</pre> <pre data-language="python">In [227]: timeit pd.read_json(jsonfloats)
100 loops, best of 3: 5.72 ms per loop
</pre> <pre data-language="python">In [228]: timeit pd.read_json(jsonfloats, numpy=True)
100 loops, best of 3: 4.94 ms per loop
</pre> <div class="admonition warning"> <p class="first admonition-title">Warning</p> <p>Direct numpy decoding makes a number of assumptions and may fail or produce unexpected output if these assumptions are not satisfied:</p>  <ul class="simple"> <li>data is numeric.</li> <li>data is uniform. The dtype is sniffed from the first value decoded. A <code>ValueError</code> may be raised, or incorrect output may be produced if this condition is not satisfied.</li> <li>labels are ordered. Labels are only read from the first container, it is assumed that each subsequent row / column has been encoded in the same order. This should be satisfied if the data was encoded using <code>to_json</code> but may not be the case if the JSON is from another source.</li> </ul>  </div>    <h3 id="io-json-normalize">Normalization</h3> <div class="versionadded" id="normalization"> <p><span class="versionmodified">New in version 0.13.0.</span></p> </div> <p>pandas provides a utility function to take a dict or list of dicts and <em>normalize</em> this semi-structured data into a flat table.</p> <pre data-language="python">In [229]: from pandas.io.json import json_normalize

In [230]: data = [{'state': 'Florida',
   .....:           'shortname': 'FL',
   .....:           'info': {
   .....:                'governor': 'Rick Scott'
   .....:           },
   .....:           'counties': [{'name': 'Dade', 'population': 12345},
   .....:                       {'name': 'Broward', 'population': 40000},
   .....:                       {'name': 'Palm Beach', 'population': 60000}]},
   .....:          {'state': 'Ohio',
   .....:           'shortname': 'OH',
   .....:           'info': {
   .....:                'governor': 'John Kasich'
   .....:           },
   .....:           'counties': [{'name': 'Summit', 'population': 1234},
   .....:                        {'name': 'Cuyahoga', 'population': 1337}]}]
   .....: 

In [231]: json_normalize(data, 'counties', ['state', 'shortname', ['info', 'governor']])
Out[231]: 
         name  population info.governor    state shortname
0        Dade       12345    Rick Scott  Florida        FL
1     Broward       40000    Rick Scott  Florida        FL
2  Palm Beach       60000    Rick Scott  Florida        FL
3      Summit        1234   John Kasich     Ohio        OH
4    Cuyahoga        1337   John Kasich     Ohio        OH
</pre>   <h3 id="io-jsonl">Line delimited json</h3> <div class="versionadded" id="line-delimited-json"> <p><span class="versionmodified">New in version 0.19.0.</span></p> </div> <p>pandas is able to read and write line-delimited json files that are common in data processing pipelines using Hadoop or Spark.</p> <pre data-language="python">In [232]: jsonl = '''
   .....:     {"a":1,"b":2}
   .....:     {"a":3,"b":4}
   .....: '''
   .....: 

In [233]: df = pd.read_json(jsonl, lines=True)

In [234]: df
Out[234]: 
   a  b
0  1  2
1  3  4

In [235]: df.to_json(orient='records', lines=True)
Out[235]: u'{"a":1,"b":2}\n{"a":3,"b":4}'
</pre>    <h2 id="html">HTML</h2>  <h3 id="io-read-html">Reading HTML Content</h3> <div class="admonition warning" id="reading-html-content"> <p class="first admonition-title">Warning</p> <p class="last">We <strong>highly encourage</strong> you to read the <a class="reference internal" href="../gotchas/#html-gotchas"><span class="std std-ref">HTML parsing gotchas</span></a> regarding the issues surrounding the BeautifulSoup4/html5lib/lxml parsers.</p> </div> <div class="versionadded"> <p><span class="versionmodified">New in version 0.12.0.</span></p> </div> <p>The top-level <code>read_html()</code> function can accept an HTML string/file/URL and will parse HTML tables into list of pandas DataFrames. Let’s look at a few examples.</p> <div class="admonition note"> <p class="first admonition-title">Note</p> <p class="last"><code>read_html</code> returns a <code>list</code> of <code>DataFrame</code> objects, even if there is only a single table contained in the HTML content</p> </div> <p>Read a URL with no options</p> <pre data-language="python">In [236]: url = 'http://www.fdic.gov/bank/individual/failed/banklist.html'

In [237]: dfs = pd.read_html(url)

In [238]: dfs
Out[238]: 
[                             Bank Name             City  ST   CERT  \
 0                          Allied Bank         Mulberry  AR     91   
 1         The Woodbury Banking Company         Woodbury  GA  11297   
 2               First CornerStone Bank  King of Prussia  PA  35312   
 3                   Trust Company Bank          Memphis  TN   9956   
 4           North Milwaukee State Bank        Milwaukee  WI  20364   
 5               Hometown National Bank         Longview  WA  35156   
 6                  The Bank of Georgia   Peachtree City  GA  35259   
 ..                                 ...              ...  ..    ...   
 540      Hamilton Bank, NA  En Espanol            Miami  FL  24382   
 541             Sinclair National Bank         Gravette  AR  34248   
 542                 Superior Bank, FSB         Hinsdale  IL  32646   
 543                Malta National Bank            Malta  OH   6629   
 544    First Alliance Bank &amp; Trust Co.       Manchester  NH  34264   
 545  National State Bank of Metropolis       Metropolis  IL   3815   
 546                   Bank of Honolulu         Honolulu  HI  21029   
 
                    Acquiring Institution        Closing Date  \
 0                           Today's Bank  September 23, 2016   
 1                            United Bank     August 19, 2016   
 2    First-Citizens Bank &amp; Trust Company         May 6, 2016   
 3             The Bank of Fayette County      April 29, 2016   
 4    First-Citizens Bank &amp; Trust Company      March 11, 2016   
 5                         Twin City Bank     October 2, 2015   
 6                          Fidelity Bank     October 2, 2015   
 ..                                   ...                 ...   
 540     Israel Discount Bank of New York    January 11, 2002   
 541                   Delta Trust &amp; Bank   September 7, 2001   
 542                Superior Federal, FSB       July 27, 2001   
 543                    North Valley Bank         May 3, 2001   
 544  Southern New Hampshire Bank &amp; Trust    February 2, 2001   
 545              Banterra Bank of Marion   December 14, 2000   
 546                   Bank of the Orient    October 13, 2000   
 
            Updated Date  
 0     November 17, 2016  
 1     November 17, 2016  
 2     September 6, 2016  
 3     September 6, 2016  
 4         June 16, 2016  
 5        April 13, 2016  
 6      October 24, 2016  
 ..                  ...  
 540  September 21, 2015  
 541   February 10, 2004  
 542     August 19, 2014  
 543   November 18, 2002  
 544   February 18, 2003  
 545      March 17, 2005  
 546      March 17, 2005  
 
 [547 rows x 7 columns]]
</pre> <div class="admonition note"> <p class="first admonition-title">Note</p> <p class="last">The data from the above URL changes every Monday so the resulting data above and the data below may be slightly different.</p> </div> <p>Read in the content of the file from the above URL and pass it to <code>read_html</code> as a string</p> <pre data-language="python">In [239]: with open(file_path, 'r') as f:
   .....:     dfs = pd.read_html(f.read())
   .....: 

In [240]: dfs
Out[240]: 
[                                    Bank Name          City  ST   CERT  \
 0    Banks of Wisconsin d/b/a Bank of Kenosha       Kenosha  WI  35386   
 1                        Central Arizona Bank    Scottsdale  AZ  34527   
 2                                Sunrise Bank      Valdosta  GA  58185   
 3                       Pisgah Community Bank     Asheville  NC  58701   
 4                         Douglas County Bank  Douglasville  GA  21649   
 5                                Parkway Bank        Lenoir  NC  57158   
 6                      Chipola Community Bank      Marianna  FL  58034   
 ..                                        ...           ...  ..    ...   
 499               Hamilton Bank, NAEn Espanol         Miami  FL  24382   
 500                    Sinclair National Bank      Gravette  AR  34248   
 501                        Superior Bank, FSB      Hinsdale  IL  32646   
 502                       Malta National Bank         Malta  OH   6629   
 503           First Alliance Bank &amp; Trust Co.    Manchester  NH  34264   
 504         National State Bank of Metropolis    Metropolis  IL   3815   
 505                          Bank of Honolulu      Honolulu  HI  21029   
 
                    Acquiring Institution       Closing Date       Updated Date  
 0                  North Shore Bank, FSB       May 31, 2013       May 31, 2013  
 1                     Western State Bank       May 14, 2013       May 20, 2013  
 2                           Synovus Bank       May 10, 2013       May 21, 2013  
 3                     Capital Bank, N.A.       May 10, 2013       May 14, 2013  
 4                    Hamilton State Bank     April 26, 2013       May 16, 2013  
 5       CertusBank, National Association     April 26, 2013       May 17, 2013  
 6          First Federal Bank of Florida     April 19, 2013       May 16, 2013  
 ..                                   ...                ...                ...  
 499     Israel Discount Bank of New York   January 11, 2002       June 5, 2012  
 500                   Delta Trust &amp; Bank  September 7, 2001  February 10, 2004  
 501                Superior Federal, FSB      July 27, 2001       June 5, 2012  
 502                    North Valley Bank        May 3, 2001  November 18, 2002  
 503  Southern New Hampshire Bank &amp; Trust   February 2, 2001  February 18, 2003  
 504              Banterra Bank of Marion  December 14, 2000     March 17, 2005  
 505                   Bank of the Orient   October 13, 2000     March 17, 2005  
 
 [506 rows x 7 columns]]
</pre> <p>You can even pass in an instance of <code>StringIO</code> if you so desire</p> <pre data-language="python">In [241]: with open(file_path, 'r') as f:
   .....:     sio = StringIO(f.read())
   .....: 

In [242]: dfs = pd.read_html(sio)

In [243]: dfs
Out[243]: 
[                                    Bank Name          City  ST   CERT  \
 0    Banks of Wisconsin d/b/a Bank of Kenosha       Kenosha  WI  35386   
 1                        Central Arizona Bank    Scottsdale  AZ  34527   
 2                                Sunrise Bank      Valdosta  GA  58185   
 3                       Pisgah Community Bank     Asheville  NC  58701   
 4                         Douglas County Bank  Douglasville  GA  21649   
 5                                Parkway Bank        Lenoir  NC  57158   
 6                      Chipola Community Bank      Marianna  FL  58034   
 ..                                        ...           ...  ..    ...   
 499               Hamilton Bank, NAEn Espanol         Miami  FL  24382   
 500                    Sinclair National Bank      Gravette  AR  34248   
 501                        Superior Bank, FSB      Hinsdale  IL  32646   
 502                       Malta National Bank         Malta  OH   6629   
 503           First Alliance Bank &amp; Trust Co.    Manchester  NH  34264   
 504         National State Bank of Metropolis    Metropolis  IL   3815   
 505                          Bank of Honolulu      Honolulu  HI  21029   
 
                    Acquiring Institution       Closing Date       Updated Date  
 0                  North Shore Bank, FSB       May 31, 2013       May 31, 2013  
 1                     Western State Bank       May 14, 2013       May 20, 2013  
 2                           Synovus Bank       May 10, 2013       May 21, 2013  
 3                     Capital Bank, N.A.       May 10, 2013       May 14, 2013  
 4                    Hamilton State Bank     April 26, 2013       May 16, 2013  
 5       CertusBank, National Association     April 26, 2013       May 17, 2013  
 6          First Federal Bank of Florida     April 19, 2013       May 16, 2013  
 ..                                   ...                ...                ...  
 499     Israel Discount Bank of New York   January 11, 2002       June 5, 2012  
 500                   Delta Trust &amp; Bank  September 7, 2001  February 10, 2004  
 501                Superior Federal, FSB      July 27, 2001       June 5, 2012  
 502                    North Valley Bank        May 3, 2001  November 18, 2002  
 503  Southern New Hampshire Bank &amp; Trust   February 2, 2001  February 18, 2003  
 504              Banterra Bank of Marion  December 14, 2000     March 17, 2005  
 505                   Bank of the Orient   October 13, 2000     March 17, 2005  
 
 [506 rows x 7 columns]]
</pre> <div class="admonition note"> <p class="first admonition-title">Note</p> <p class="last">The following examples are not run by the IPython evaluator due to the fact that having so many network-accessing functions slows down the documentation build. If you spot an error or an example that doesn’t run, please do not hesitate to report it over on <a class="reference external" href="http://www.github.com/pandas-dev/pandas/issues" target="_blank">pandas GitHub issues page</a>.</p> </div> <p>Read a URL and match a table that contains specific text</p> <pre data-language="python">match = 'Metcalf Bank'
df_list = pd.read_html(url, match=match)
</pre> <p>Specify a header row (by default <code>&lt;th&gt;</code> elements are used to form the column index); if specified, the header row is taken from the data minus the parsed header elements (<code>&lt;th&gt;</code> elements).</p> <pre data-language="python">dfs = pd.read_html(url, header=0)
</pre> <p>Specify an index column</p> <pre data-language="python">dfs = pd.read_html(url, index_col=0)
</pre> <p>Specify a number of rows to skip</p> <pre data-language="python">dfs = pd.read_html(url, skiprows=0)
</pre> <p>Specify a number of rows to skip using a list (<code>xrange</code> (Python 2 only) works as well)</p> <pre data-language="python">dfs = pd.read_html(url, skiprows=range(2))
</pre> <p>Specify an HTML attribute</p> <pre data-language="python">dfs1 = pd.read_html(url, attrs={'id': 'table'})
dfs2 = pd.read_html(url, attrs={'class': 'sortable'})
print(np.array_equal(dfs1[0], dfs2[0]))  # Should be True
</pre> <p>Specify values that should be converted to NaN</p> <pre data-language="python">dfs = pd.read_html(url, na_values=['No Acquirer'])
</pre> <div class="versionadded"> <p><span class="versionmodified">New in version 0.19.</span></p> </div> <p>Specify whether to keep the default set of NaN values</p> <pre data-language="python">dfs = pd.read_html(url, keep_default_na=False)
</pre> <div class="versionadded"> <p><span class="versionmodified">New in version 0.19.</span></p> </div> <p>Specify converters for columns. This is useful for numerical text data that has leading zeros. By default columns that are numerical are cast to numeric types and the leading zeros are lost. To avoid this, we can convert these columns to strings.</p> <pre data-language="python">url_mcc = 'https://en.wikipedia.org/wiki/Mobile_country_code'
dfs = pd.read_html(url_mcc, match='Telekom Albania', header=0, converters={'MNC':
str})
</pre> <div class="versionadded"> <p><span class="versionmodified">New in version 0.19.</span></p> </div> <p>Use some combination of the above</p> <pre data-language="python">dfs = pd.read_html(url, match='Metcalf Bank', index_col=0)
</pre> <p>Read in pandas <code>to_html</code> output (with some loss of floating point precision)</p> <pre data-language="python">df = pd.DataFrame(randn(2, 2))
s = df.to_html(float_format='{0:.40g}'.format)
dfin = pd.read_html(s, index_col=0)
</pre> <p>The <code>lxml</code> backend will raise an error on a failed parse if that is the only parser you provide (if you only have a single parser you can provide just a string, but it is considered good practice to pass a list with one string if, for example, the function expects a sequence of strings)</p> <pre data-language="python">dfs = pd.read_html(url, 'Metcalf Bank', index_col=0, flavor=['lxml'])
</pre> <p>or</p> <pre data-language="python">dfs = pd.read_html(url, 'Metcalf Bank', index_col=0, flavor='lxml')
</pre> <p>However, if you have bs4 and html5lib installed and pass <code>None</code> or <code>['lxml',
'bs4']</code> then the parse will most likely succeed. Note that <em>as soon as a parse succeeds, the function will return</em>.</p> <pre data-language="python">dfs = pd.read_html(url, 'Metcalf Bank', index_col=0, flavor=['lxml', 'bs4'])
</pre>   <h3 id="io-html">Writing to HTML files</h3> <p id="writing-to-html-files"><code>DataFrame</code> objects have an instance method <code>to_html</code> which renders the contents of the <code>DataFrame</code> as an HTML table. The function arguments are as in the method <code>to_string</code> described above.</p> <div class="admonition note"> <p class="first admonition-title">Note</p> <p class="last">Not all of the possible options for <code>DataFrame.to_html</code> are shown here for brevity’s sake. See <code>to_html()</code> for the full set of options.</p> </div> <pre data-language="python">In [244]: df = pd.DataFrame(randn(2, 2))

In [245]: df
Out[245]: 
          0         1
0 -0.184744  0.496971
1 -0.856240  1.857977

In [246]: print(df.to_html())  # raw html
&lt;table border="1" class="dataframe"&gt;
  &lt;thead&gt;
    &lt;tr style="text-align: right;"&gt;
      &lt;th&gt;&lt;/th&gt;
      &lt;th&gt;0&lt;/th&gt;
      &lt;th&gt;1&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;th&gt;0&lt;/th&gt;
      &lt;td&gt;-0.184744&lt;/td&gt;
      &lt;td&gt;0.496971&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th&gt;1&lt;/th&gt;
      &lt;td&gt;-0.856240&lt;/td&gt;
      &lt;td&gt;1.857977&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
</pre> <p>HTML:</p> <table class="dataframe"> <thead> <tr style="text-align: right;"> <th></th> <th>0</th> <th>1</th> </tr> </thead>  <tr> <th>0</th> <td>-0.184744</td> <td>0.496971</td> </tr> <tr> <th>1</th> <td>-0.856240</td> <td>1.857977</td> </tr>  </table>
<p>The <code>columns</code> argument will limit the columns shown</p> <pre data-language="python">In [247]: print(df.to_html(columns=[0]))
&lt;table border="1" class="dataframe"&gt;
  &lt;thead&gt;
    &lt;tr style="text-align: right;"&gt;
      &lt;th&gt;&lt;/th&gt;
      &lt;th&gt;0&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;th&gt;0&lt;/th&gt;
      &lt;td&gt;-0.184744&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th&gt;1&lt;/th&gt;
      &lt;td&gt;-0.856240&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
</pre> <p>HTML:</p> <table class="dataframe"> <thead> <tr style="text-align: right;"> <th></th> <th>0</th> </tr> </thead>  <tr> <th>0</th> <td>-0.184744</td> </tr> <tr> <th>1</th> <td>-0.856240</td> </tr>  </table>
<p><code>float_format</code> takes a Python callable to control the precision of floating point values</p> <pre data-language="python">In [248]: print(df.to_html(float_format='{0:.10f}'.format))
&lt;table border="1" class="dataframe"&gt;
  &lt;thead&gt;
    &lt;tr style="text-align: right;"&gt;
      &lt;th&gt;&lt;/th&gt;
      &lt;th&gt;0&lt;/th&gt;
      &lt;th&gt;1&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;th&gt;0&lt;/th&gt;
      &lt;td&gt;-0.1847438576&lt;/td&gt;
      &lt;td&gt;0.4969711327&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th&gt;1&lt;/th&gt;
      &lt;td&gt;-0.8562396763&lt;/td&gt;
      &lt;td&gt;1.8579766508&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
</pre> <p>HTML:</p> <table class="dataframe"> <thead> <tr style="text-align: right;"> <th></th> <th>0</th> <th>1</th> </tr> </thead>  <tr> <th>0</th> <td>-0.1847438576</td> <td>0.4969711327</td> </tr> <tr> <th>1</th> <td>-0.8562396763</td> <td>1.8579766508</td> </tr>  </table>
<p><code>bold_rows</code> will make the row labels bold by default, but you can turn that off</p> <pre data-language="python">In [249]: print(df.to_html(bold_rows=False))
&lt;table border="1" class="dataframe"&gt;
  &lt;thead&gt;
    &lt;tr style="text-align: right;"&gt;
      &lt;th&gt;&lt;/th&gt;
      &lt;th&gt;0&lt;/th&gt;
      &lt;th&gt;1&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;-0.184744&lt;/td&gt;
      &lt;td&gt;0.496971&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;-0.856240&lt;/td&gt;
      &lt;td&gt;1.857977&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
</pre> <table class="dataframe"> <thead> <tr style="text-align: right;"> <th></th> <th>0</th> <th>1</th> </tr> </thead>  <tr> <td>0</td> <td>-0.184744</td> <td>0.496971</td> </tr> <tr> <td>1</td> <td>-0.856240</td> <td>1.857977</td> </tr>  </table>
<p>The <code>classes</code> argument provides the ability to give the resulting HTML table CSS classes. Note that these classes are <em>appended</em> to the existing <code>'dataframe'</code> class.</p> <pre data-language="python">In [250]: print(df.to_html(classes=['awesome_table_class', 'even_more_awesome_class']))
&lt;table border="1" class="dataframe awesome_table_class even_more_awesome_class"&gt;
  &lt;thead&gt;
    &lt;tr style="text-align: right;"&gt;
      &lt;th&gt;&lt;/th&gt;
      &lt;th&gt;0&lt;/th&gt;
      &lt;th&gt;1&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;th&gt;0&lt;/th&gt;
      &lt;td&gt;-0.184744&lt;/td&gt;
      &lt;td&gt;0.496971&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th&gt;1&lt;/th&gt;
      &lt;td&gt;-0.856240&lt;/td&gt;
      &lt;td&gt;1.857977&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
</pre> <p>Finally, the <code>escape</code> argument allows you to control whether the “&lt;”, “&gt;” and “&amp;” characters escaped in the resulting HTML (by default it is <code>True</code>). So to get the HTML without escaped characters pass <code>escape=False</code></p> <pre data-language="python">In [251]: df = pd.DataFrame({'a': list('&amp;&lt;&gt;'), 'b': randn(3)})
</pre> <p>Escaped:</p> <pre data-language="python">In [252]: print(df.to_html())
&lt;table border="1" class="dataframe"&gt;
  &lt;thead&gt;
    &lt;tr style="text-align: right;"&gt;
      &lt;th&gt;&lt;/th&gt;
      &lt;th&gt;a&lt;/th&gt;
      &lt;th&gt;b&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;th&gt;0&lt;/th&gt;
      &lt;td&gt;&amp;amp;&lt;/td&gt;
      &lt;td&gt;-0.474063&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th&gt;1&lt;/th&gt;
      &lt;td&gt;&amp;lt;&lt;/td&gt;
      &lt;td&gt;-0.230305&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th&gt;2&lt;/th&gt;
      &lt;td&gt;&amp;gt;&lt;/td&gt;
      &lt;td&gt;-0.400654&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
</pre> <table class="dataframe"> <thead> <tr style="text-align: right;"> <th></th> <th>a</th> <th>b</th> </tr> </thead>  <tr> <th>0</th> <td>&amp;</td> <td>-0.474063</td> </tr> <tr> <th>1</th> <td>&lt;</td> <td>-0.230305</td> </tr> <tr> <th>2</th> <td>&gt;</td> <td>-0.400654</td> </tr>  </table>
<p>Not escaped:</p> <pre data-language="python">In [253]: print(df.to_html(escape=False))
&lt;table border="1" class="dataframe"&gt;
  &lt;thead&gt;
    &lt;tr style="text-align: right;"&gt;
      &lt;th&gt;&lt;/th&gt;
      &lt;th&gt;a&lt;/th&gt;
      &lt;th&gt;b&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;th&gt;0&lt;/th&gt;
      &lt;td&gt;&amp;&lt;/td&gt;
      &lt;td&gt;-0.474063&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th&gt;1&lt;/th&gt;
      &lt;td&gt;&lt;&lt;/td&gt;
      &lt;td&gt;-0.230305&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th&gt;2&lt;/th&gt;
      &lt;td&gt;&gt;&lt;/td&gt;
      &lt;td&gt;-0.400654&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
</pre> <table class="dataframe"> <thead> <tr style="text-align: right;"> <th></th> <th>a</th> <th>b</th> </tr> </thead>  <tr> <th>0</th> <td>&amp;</td> <td>-0.474063</td> </tr> <tr> <th>1</th> <td>&lt;</td> <td>-0.230305</td> </tr> <tr> <th>2</th> <td>&gt;</td> <td>-0.400654</td> </tr>  </table>
<div class="admonition note"> <p class="first admonition-title">Note</p> <p class="last">Some browsers may not show a difference in the rendering of the previous two HTML tables.</p> </div>    <h2 id="io-excel">Excel files</h2> <p id="excel-files">The <a class="reference internal" href="../generated/pandas.read_excel/#pandas.read_excel" title="pandas.read_excel"><code>read_excel()</code></a> method can read Excel 2003 (<code>.xls</code>) and Excel 2007+ (<code>.xlsx</code>) files using the <code>xlrd</code> Python module. The <a class="reference internal" href="../generated/pandas.dataframe.to_excel/#pandas.DataFrame.to_excel" title="pandas.DataFrame.to_excel"><code>to_excel()</code></a> instance method is used for saving a <code>DataFrame</code> to Excel. Generally the semantics are similar to working with <a class="reference internal" href="#io-read-csv-table"><span class="std std-ref">csv</span></a> data. See the <a class="reference internal" href="../cookbook/#cookbook-excel"><span class="std std-ref">cookbook</span></a> for some advanced strategies</p>  <h3 id="io-excel-reader">Reading Excel Files</h3> <p id="reading-excel-files">In the most basic use-case, <code>read_excel</code> takes a path to an Excel file, and the <code>sheetname</code> indicating which sheet to parse.</p> <pre data-language="python"># Returns a DataFrame
read_excel('path_to_file.xls', sheetname='Sheet1')
</pre>  <h4 id="io-excel-excelfile-class">
<code>ExcelFile</code> class</h4> <p id="excelfile-class">To facilitate working with multiple sheets from the same file, the <code>ExcelFile</code> class can be used to wrap the file and can be be passed into <code>read_excel</code> There will be a performance benefit for reading multiple sheets as the file is read into memory only once.</p> <pre data-language="python">xlsx = pd.ExcelFile('path_to_file.xls)
df = pd.read_excel(xlsx, 'Sheet1')
</pre> <p>The <code>ExcelFile</code> class can also be used as a context manager.</p> <pre data-language="python">with pd.ExcelFile('path_to_file.xls') as xls:
    df1 = pd.read_excel(xls, 'Sheet1')
    df2 = pd.read_excel(xls, 'Sheet2')
</pre> <p>The <code>sheet_names</code> property will generate a list of the sheet names in the file.</p> <p>The primary use-case for an <code>ExcelFile</code> is parsing multiple sheets with different parameters</p> <pre data-language="python">data = {}
# For when Sheet1's format differs from Sheet2
with pd.ExcelFile('path_to_file.xls') as xls:
    data['Sheet1'] = pd.read_excel(xls, 'Sheet1', index_col=None, na_values=['NA'])
    data['Sheet2'] = pd.read_excel(xls, 'Sheet2', index_col=1)
</pre> <p>Note that if the same parsing parameters are used for all sheets, a list of sheet names can simply be passed to <code>read_excel</code> with no loss in performance.</p> <pre data-language="python"># using the ExcelFile class
data = {}
with pd.ExcelFile('path_to_file.xls') as xls:
    data['Sheet1'] = read_excel(xls, 'Sheet1', index_col=None, na_values=['NA'])
    data['Sheet2'] = read_excel(xls, 'Sheet2', index_col=None, na_values=['NA'])

# equivalent using the read_excel function
data = read_excel('path_to_file.xls', ['Sheet1', 'Sheet2'], index_col=None, na_values=['NA'])
</pre> <div class="versionadded"> <p><span class="versionmodified">New in version 0.12.</span></p> </div> <p><code>ExcelFile</code> has been moved to the top level namespace.</p> <div class="versionadded"> <p><span class="versionmodified">New in version 0.17.</span></p> </div> <p><code>read_excel</code> can take an <code>ExcelFile</code> object as input</p>   <h4 id="io-excel-specifying-sheets">Specifying Sheets</h4> <div class="admonition note" id="specifying-sheets"> <p class="first admonition-title">Note</p> <p class="last">The second argument is <code>sheetname</code>, not to be confused with <code>ExcelFile.sheet_names</code></p> </div> <div class="admonition note"> <p class="first admonition-title">Note</p> <p class="last">An ExcelFile’s attribute <code>sheet_names</code> provides access to a list of sheets.</p> </div> <ul class="simple"> <li>The arguments <code>sheetname</code> allows specifying the sheet or sheets to read.</li> <li>The default value for <code>sheetname</code> is 0, indicating to read the first sheet</li> <li>Pass a string to refer to the name of a particular sheet in the workbook.</li> <li>Pass an integer to refer to the index of a sheet. Indices follow Python convention, beginning at 0.</li> <li>Pass a list of either strings or integers, to return a dictionary of specified sheets.</li> <li>Pass a <code>None</code> to return a dictionary of all available sheets.</li> </ul> <pre data-language="python"># Returns a DataFrame
read_excel('path_to_file.xls', 'Sheet1', index_col=None, na_values=['NA'])
</pre> <p>Using the sheet index:</p> <pre data-language="python"># Returns a DataFrame
read_excel('path_to_file.xls', 0, index_col=None, na_values=['NA'])
</pre> <p>Using all default values:</p> <pre data-language="python"># Returns a DataFrame
read_excel('path_to_file.xls')
</pre> <p>Using None to get all sheets:</p> <pre data-language="python"># Returns a dictionary of DataFrames
read_excel('path_to_file.xls',sheetname=None)
</pre> <p>Using a list to get multiple sheets:</p> <pre data-language="python"># Returns the 1st and 4th sheet, as a dictionary of DataFrames.
read_excel('path_to_file.xls',sheetname=['Sheet1',3])
</pre> <div class="versionadded"> <p><span class="versionmodified">New in version 0.16.</span></p> </div> <p><code>read_excel</code> can read more than one sheet, by setting <code>sheetname</code> to either a list of sheet names, a list of sheet positions, or <code>None</code> to read all sheets.</p> <div class="versionadded"> <p><span class="versionmodified">New in version 0.13.</span></p> </div> <p>Sheets can be specified by sheet index or sheet name, using an integer or string, respectively.</p>   <h4 id="io-excel-reading-multiindex">Reading a <code>MultiIndex</code>
</h4> <div class="versionadded" id="reading-a-multiindex"> <p><span class="versionmodified">New in version 0.17.</span></p> </div> <p><code>read_excel</code> can read a <code>MultiIndex</code> index, by passing a list of columns to <code>index_col</code> and a <code>MultiIndex</code> column by passing a list of rows to <code>header</code>. If either the <code>index</code> or <code>columns</code> have serialized level names those will be read in as well by specifying the rows/columns that make up the levels.</p> <p>For example, to read in a <code>MultiIndex</code> index without names:</p> <pre data-language="python">In [254]: df = pd.DataFrame({'a':[1,2,3,4], 'b':[5,6,7,8]},
   .....:                   index=pd.MultiIndex.from_product([['a','b'],['c','d']]))
   .....: 

In [255]: df.to_excel('path_to_file.xlsx')

In [256]: df = pd.read_excel('path_to_file.xlsx', index_col=[0,1])

In [257]: df
Out[257]: 
     a  b
a c  1  5
  d  2  6
b c  3  7
  d  4  8
</pre> <p>If the index has level names, they will parsed as well, using the same parameters.</p> <pre data-language="python">In [258]: df.index = df.index.set_names(['lvl1', 'lvl2'])

In [259]: df.to_excel('path_to_file.xlsx')

In [260]: df = pd.read_excel('path_to_file.xlsx', index_col=[0,1])

In [261]: df
Out[261]: 
           a  b
lvl1 lvl2      
a    c     1  5
     d     2  6
b    c     3  7
     d     4  8
</pre> <p>If the source file has both <code>MultiIndex</code> index and columns, lists specifying each should be passed to <code>index_col</code> and <code>header</code></p> <pre data-language="python">In [262]: df.columns = pd.MultiIndex.from_product([['a'],['b', 'd']], names=['c1', 'c2'])

In [263]: df.to_excel('path_to_file.xlsx')

In [264]: df = pd.read_excel('path_to_file.xlsx',
   .....:                     index_col=[0,1], header=[0,1])
   .....: 

In [265]: df
Out[265]: 
c1         a   
c2         b  d
lvl1 lvl2      
a    c     1  5
     d     2  6
b    c     3  7
     d     4  8
</pre> <div class="admonition warning"> <p class="first admonition-title">Warning</p> <p class="last">Excel files saved in version 0.16.2 or prior that had index names will still able to be read in, but the <code>has_index_names</code> argument must specified to <code>True</code>.</p> </div>   <h4 id="parsing-specific-columns">Parsing Specific Columns</h4> <p>It is often the case that users will insert columns to do temporary computations in Excel and you may not want to read in those columns. <code>read_excel</code> takes a <code>parse_cols</code> keyword to allow you to specify a subset of columns to parse.</p> <p>If <code>parse_cols</code> is an integer, then it is assumed to indicate the last column to be parsed.</p> <pre data-language="python">read_excel('path_to_file.xls', 'Sheet1', parse_cols=2)
</pre> <p>If <code>parse_cols</code> is a list of integers, then it is assumed to be the file column indices to be parsed.</p> <pre data-language="python">read_excel('path_to_file.xls', 'Sheet1', parse_cols=[0, 2, 3])
</pre>   <h4 id="cell-converters">Cell Converters</h4> <p>It is possible to transform the contents of Excel cells via the <code>converters</code> option. For instance, to convert a column to boolean:</p> <pre data-language="python">read_excel('path_to_file.xls', 'Sheet1', converters={'MyBools': bool})
</pre> <p>This options handles missing values and treats exceptions in the converters as missing data. Transformations are applied cell by cell rather than to the column as a whole, so the array dtype is not guaranteed. For instance, a column of integers with missing values cannot be transformed to an array with integer dtype, because NaN is strictly a float. You can manually mask missing data to recover integer dtype:</p> <pre data-language="python">cfun = lambda x: int(x) if x else -1
read_excel('path_to_file.xls', 'Sheet1', converters={'MyInts': cfun})
</pre>    <h3 id="io-excel-writer">Writing Excel Files</h3>  <h4 id="writing-excel-files">Writing Excel Files to Disk</h4> <p>To write a DataFrame object to a sheet of an Excel file, you can use the <code>to_excel</code> instance method. The arguments are largely the same as <code>to_csv</code> described above, the first argument being the name of the excel file, and the optional second argument the name of the sheet to which the DataFrame should be written. For example:</p> <pre data-language="python">df.to_excel('path_to_file.xlsx', sheet_name='Sheet1')
</pre> <p>Files with a <code>.xls</code> extension will be written using <code>xlwt</code> and those with a <code>.xlsx</code> extension will be written using <code>xlsxwriter</code> (if available) or <code>openpyxl</code>.</p> <p>The DataFrame will be written in a way that tries to mimic the REPL output. One difference from 0.12.0 is that the <code>index_label</code> will be placed in the second row instead of the first. You can get the previous behaviour by setting the <code>merge_cells</code> option in <code>to_excel()</code> to <code>False</code>:</p> <pre data-language="python">df.to_excel('path_to_file.xlsx', index_label='label', merge_cells=False)
</pre> <p>The Panel class also has a <code>to_excel</code> instance method, which writes each DataFrame in the Panel to a separate sheet.</p> <p>In order to write separate DataFrames to separate sheets in a single Excel file, one can pass an <code>ExcelWriter</code>.</p> <pre data-language="python">with ExcelWriter('path_to_file.xlsx') as writer:
    df1.to_excel(writer, sheet_name='Sheet1')
    df2.to_excel(writer, sheet_name='Sheet2')
</pre> <div class="admonition note"> <p class="first admonition-title">Note</p> <p class="last">Wringing a little more performance out of <code>read_excel</code> Internally, Excel stores all numeric data as floats. Because this can produce unexpected behavior when reading in data, pandas defaults to trying to convert integers to floats if it doesn’t lose information (<code>1.0 --&gt;
1</code>). You can pass <code>convert_float=False</code> to disable this behavior, which may give a slight performance improvement.</p> </div>   <h4 id="io-excel-writing-buffer">Writing Excel Files to Memory</h4> <div class="versionadded" id="writing-excel-files-to-memory"> <p><span class="versionmodified">New in version 0.17.</span></p> </div> <p>Pandas supports writing Excel files to buffer-like objects such as <code>StringIO</code> or <code>BytesIO</code> using <code>ExcelWriter</code>.</p> <div class="versionadded"> <p><span class="versionmodified">New in version 0.17.</span></p> </div> <p>Added support for Openpyxl &gt;= 2.2</p> <pre data-language="python"># Safe import for either Python 2.x or 3.x
try:
    from io import BytesIO
except ImportError:
    from cStringIO import StringIO as BytesIO

bio = BytesIO()

# By setting the 'engine' in the ExcelWriter constructor.
writer = ExcelWriter(bio, engine='xlsxwriter')
df.to_excel(writer, sheet_name='Sheet1')

# Save the workbook
writer.save()

# Seek to the beginning and read to copy the workbook to a variable in memory
bio.seek(0)
workbook = bio.read()
</pre> <div class="admonition note"> <p class="first admonition-title">Note</p> <p class="last"><code>engine</code> is optional but recommended. Setting the engine determines the version of workbook produced. Setting <code>engine='xlrd'</code> will produce an Excel 2003-format workbook (xls). Using either <code>'openpyxl'</code> or <code>'xlsxwriter'</code> will produce an Excel 2007-format workbook (xlsx). If omitted, an Excel 2007-formatted workbook is produced.</p> </div>    <h3 id="io-excel-writers">Excel writer engines</h3> <div class="versionadded" id="excel-writer-engines"> <p><span class="versionmodified">New in version 0.13.</span></p> </div> <p><code>pandas</code> chooses an Excel writer via two methods:</p> <ol class="arabic simple"> <li>the <code>engine</code> keyword argument</li> <li>the filename extension (via the default specified in config options)</li> </ol> <p>By default, <code>pandas</code> uses the <a class="reference external" href="https://xlsxwriter.readthedocs.io" target="_blank">XlsxWriter</a> for <code>.xlsx</code> and <a class="reference external" href="https://openpyxl.readthedocs.io/" target="_blank">openpyxl</a> for <code>.xlsm</code> files and <a class="reference external" href="http://www.python-excel.org" target="_blank">xlwt</a> for <code>.xls</code> files. If you have multiple engines installed, you can set the default engine through <a class="reference internal" href="../options/#options"><span class="std std-ref">setting the config options</span></a> <code>io.excel.xlsx.writer</code> and <code>io.excel.xls.writer</code>. pandas will fall back on <a class="reference external" href="https://openpyxl.readthedocs.io/" target="_blank">openpyxl</a> for <code>.xlsx</code> files if <a class="reference external" href="https://xlsxwriter.readthedocs.io" target="_blank">Xlsxwriter</a> is not available.</p> <p>To specify which writer you want to use, you can pass an engine keyword argument to <code>to_excel</code> and to <code>ExcelWriter</code>. The built-in engines are:</p> <ul class="simple"> <li>
<code>openpyxl</code>: This includes stable support for Openpyxl from 1.6.1. However, it is advised to use version 2.2 and higher, especially when working with styles.</li> <li><code>xlsxwriter</code></li> <li><code>xlwt</code></li> </ul> <pre data-language="python"># By setting the 'engine' in the DataFrame and Panel 'to_excel()' methods.
df.to_excel('path_to_file.xlsx', sheet_name='Sheet1', engine='xlsxwriter')

# By setting the 'engine' in the ExcelWriter constructor.
writer = ExcelWriter('path_to_file.xlsx', engine='xlsxwriter')

# Or via pandas configuration.
from pandas import options
options.io.excel.xlsx.writer = 'xlsxwriter'

df.to_excel('path_to_file.xlsx', sheet_name='Sheet1')
</pre>    <h2 id="io-clipboard">Clipboard</h2> <p id="clipboard">A handy way to grab data is to use the <code>read_clipboard</code> method, which takes the contents of the clipboard buffer and passes them to the <code>read_table</code> method. For instance, you can copy the following text to the clipboard (CTRL-C on many operating systems):</p> <pre data-language="python">  A B C
x 1 4 p
y 2 5 q
z 3 6 r
</pre> <p>And then import the data directly to a DataFrame by calling:</p> <pre data-language="python">clipdf = pd.read_clipboard()
</pre> <pre data-language="python">In [266]: clipdf
Out[266]: 
   A  B  C
x  1  4  p
y  2  5  q
z  3  6  r
</pre> <p>The <code>to_clipboard</code> method can be used to write the contents of a DataFrame to the clipboard. Following which you can paste the clipboard contents into other applications (CTRL-V on many operating systems). Here we illustrate writing a DataFrame into clipboard and reading it back.</p> <pre data-language="python">In [267]: df = pd.DataFrame(randn(5,3))

In [268]: df
Out[268]: 
          0         1         2
0 -0.288267 -0.084905  0.004772
1  1.382989  0.343635 -1.253994
2 -0.124925  0.212244  0.496654
3  0.525417  1.238640 -1.210543
4 -1.175743 -0.172372 -0.734129

In [269]: df.to_clipboard()

In [270]: pd.read_clipboard()
Out[270]: 
          0         1         2
0 -0.288267 -0.084905  0.004772
1  1.382989  0.343635 -1.253994
2 -0.124925  0.212244  0.496654
3  0.525417  1.238640 -1.210543
4 -1.175743 -0.172372 -0.734129
</pre> <p>We can see that we got the same content back, which we had earlier written to the clipboard.</p> <div class="admonition note"> <p class="first admonition-title">Note</p> <p class="last">You may need to install xclip or xsel (with gtk or PyQt4 modules) on Linux to use these methods.</p> </div>   <h2 id="io-pickle">Pickling</h2> <p id="pickling">All pandas objects are equipped with <code>to_pickle</code> methods which use Python’s <code>cPickle</code> module to save data structures to disk using the pickle format.</p> <pre data-language="python">In [271]: df
Out[271]: 
          0         1         2
0 -0.288267 -0.084905  0.004772
1  1.382989  0.343635 -1.253994
2 -0.124925  0.212244  0.496654
3  0.525417  1.238640 -1.210543
4 -1.175743 -0.172372 -0.734129

In [272]: df.to_pickle('foo.pkl')
</pre> <p>The <code>read_pickle</code> function in the <code>pandas</code> namespace can be used to load any pickled pandas object (or any other pickled object) from file:</p> <pre data-language="python">In [273]: pd.read_pickle('foo.pkl')
Out[273]: 
          0         1         2
0 -0.288267 -0.084905  0.004772
1  1.382989  0.343635 -1.253994
2 -0.124925  0.212244  0.496654
3  0.525417  1.238640 -1.210543
4 -1.175743 -0.172372 -0.734129
</pre> <div class="admonition warning"> <p class="first admonition-title">Warning</p> <p>Loading pickled data received from untrusted sources can be unsafe.</p> <p class="last">See: <a class="reference external" href="http://docs.python.org/2.7/library/pickle.html" target="_blank">http://docs.python.org/2.7/library/pickle.html</a></p> </div> <div class="admonition warning"> <p class="first admonition-title">Warning</p> <p class="last">Several internal refactorings, 0.13 (<a class="reference internal" href="http://pandas.pydata.org/pandas-docs/version/0.19.2/whatsnew.html#whatsnew-0130-refactoring" target="_blank"><span class="std std-ref">Series Refactoring</span></a>), and 0.15 (<a class="reference internal" href="http://pandas.pydata.org/pandas-docs/version/0.19.2/whatsnew.html#whatsnew-0150-refactoring" target="_blank"><span class="std std-ref">Index Refactoring</span></a>), preserve compatibility with pickles created prior to these versions. However, these must be read with <code>pd.read_pickle</code>, rather than the default python <code>pickle.load</code>. See <a class="reference external" href="http://stackoverflow.com/questions/20444593/pandas-compiled-from-source-default-pickle-behavior-changed" target="_blank">this question</a> for a detailed explanation.</p> </div> <div class="admonition note"> <p class="first admonition-title">Note</p> <p class="last">These methods were previously <code>pd.save</code> and <code>pd.load</code>, prior to 0.12.0, and are now deprecated.</p> </div>   <h2 id="io-msgpack">msgpack (experimental)</h2> <div class="versionadded" id="msgpack-experimental"> <p><span class="versionmodified">New in version 0.13.0.</span></p> </div> <p>Starting in 0.13.0, pandas is supporting the <code>msgpack</code> format for object serialization. This is a lightweight portable binary format, similar to binary JSON, that is highly space efficient, and provides good performance both on the writing (serialization), and reading (deserialization).</p> <div class="admonition warning"> <p class="first admonition-title">Warning</p> <p>This is a very new feature of pandas. We intend to provide certain optimizations in the io of the <code>msgpack</code> data. Since this is marked as an EXPERIMENTAL LIBRARY, the storage format may not be stable until a future release.</p> <p>As a result of writing format changes and other issues:</p> <table class="docutils">  <thead valign="bottom"> <tr class="row-odd">
<th class="head">Packed with</th> <th class="head">Can be unpacked with</th> </tr> </thead>  <tr class="row-even">
<td>pre-0.17 / Python 2</td> <td>any</td> </tr> <tr class="row-odd">
<td>pre-0.17 / Python 3</td> <td>any</td> </tr> <tr class="row-even">
<td>0.17 / Python 2</td> <td>
<ul class="first last simple"> <li>0.17 / Python 2</li> <li>&gt;=0.18 / any Python</li> </ul> </td> </tr> <tr class="row-odd">
<td>0.17 / Python 3</td> <td>&gt;=0.18 / any Python</td> </tr> <tr class="row-even">
<td>0.18</td> <td>&gt;= 0.18</td> </tr>  </table> <p class="last">Reading (files packed by older versions) is backward-compatibile, except for files packed with 0.17 in Python 2, in which case only they can only be unpacked in Python 2.</p> </div> <pre data-language="python">In [274]: df = pd.DataFrame(np.random.rand(5,2),columns=list('AB'))

In [275]: df.to_msgpack('foo.msg')

In [276]: pd.read_msgpack('foo.msg')
Out[276]: 
          A         B
0  0.154336  0.710999
1  0.398096  0.765220
2  0.586749  0.293052
3  0.290293  0.710783
4  0.988593  0.062106

In [277]: s = pd.Series(np.random.rand(5),index=pd.date_range('20130101',periods=5))
</pre> <p>You can pass a list of objects and you will receive them back on deserialization.</p> <pre data-language="python">In [278]: pd.to_msgpack('foo.msg', df, 'foo', np.array([1,2,3]), s)

In [279]: pd.read_msgpack('foo.msg')
Out[279]: 
[          A         B
 0  0.154336  0.710999
 1  0.398096  0.765220
 2  0.586749  0.293052
 3  0.290293  0.710783
 4  0.988593  0.062106, 'foo', array([1, 2, 3]), 2013-01-01    0.690810
 2013-01-02    0.235907
 2013-01-03    0.712756
 2013-01-04    0.119599
 2013-01-05    0.023493
 Freq: D, dtype: float64]
</pre> <p>You can pass <code>iterator=True</code> to iterate over the unpacked results</p> <pre data-language="python">In [280]: for o in pd.read_msgpack('foo.msg',iterator=True):
   .....:     print o
   .....: 
          A         B
0  0.154336  0.710999
1  0.398096  0.765220
2  0.586749  0.293052
3  0.290293  0.710783
4  0.988593  0.062106
foo
[1 2 3]
2013-01-01    0.690810
2013-01-02    0.235907
2013-01-03    0.712756
2013-01-04    0.119599
2013-01-05    0.023493
Freq: D, dtype: float64
</pre> <p>You can pass <code>append=True</code> to the writer to append to an existing pack</p> <pre data-language="python">In [281]: df.to_msgpack('foo.msg',append=True)

In [282]: pd.read_msgpack('foo.msg')
Out[282]: 
[          A         B
 0  0.154336  0.710999
 1  0.398096  0.765220
 2  0.586749  0.293052
 3  0.290293  0.710783
 4  0.988593  0.062106, 'foo', array([1, 2, 3]), 2013-01-01    0.690810
 2013-01-02    0.235907
 2013-01-03    0.712756
 2013-01-04    0.119599
 2013-01-05    0.023493
 Freq: D, dtype: float64,           A         B
 0  0.154336  0.710999
 1  0.398096  0.765220
 2  0.586749  0.293052
 3  0.290293  0.710783
 4  0.988593  0.062106]
</pre> <p>Unlike other io methods, <code>to_msgpack</code> is available on both a per-object basis, <code>df.to_msgpack()</code> and using the top-level <code>pd.to_msgpack(...)</code> where you can pack arbitrary collections of python lists, dicts, scalars, while intermixing pandas objects.</p> <pre data-language="python">In [283]: pd.to_msgpack('foo2.msg', { 'dict' : [ { 'df' : df }, { 'string' : 'foo' }, { 'scalar' : 1. }, { 's' : s } ] })

In [284]: pd.read_msgpack('foo2.msg')
Out[284]: 
{'dict': ({'df':           A         B
   0  0.154336  0.710999
   1  0.398096  0.765220
   2  0.586749  0.293052
   3  0.290293  0.710783
   4  0.988593  0.062106},
  {'string': 'foo'},
  {'scalar': 1.0},
  {'s': 2013-01-01    0.690810
   2013-01-02    0.235907
   2013-01-03    0.712756
   2013-01-04    0.119599
   2013-01-05    0.023493
   Freq: D, dtype: float64})}
</pre>  <h3 id="read-write-api">Read/Write API</h3> <p>Msgpacks can also be read from and written to strings.</p> <pre data-language="python">In [285]: df.to_msgpack()
Out[285]: '\x84\xa6blocks\x91\x86\xa5dtype\xa7float64\xa8compress\xc0\xa4locs\x86\xa4ndim\x01\xa5dtype\xa5int64\xa8compress\xc0\xa4data\xd8\x00\x00\x00\x00\x00\x00\x00\x00\x00\x01\x00\x00\x00\x00\x00\x00\x00\xa5shape\x91\x02\xa3typ\xa7ndarray\xa5shape\x92\x02\x05\xa6values\xc7P\x00\xa0\xab\xfb6H\xc1\xc3?\x98(oMgz\xd9?\x17\xaed\\\xa5\xc6\xe2?\xdc\xd0\x1bd(\x94\xd2?\xb5\xe8\xf5\x0e\x8d\xa2\xef?\x02D\xebO\x80\xc0\xe6?\x16\xbddQ\xae|\xe8?\x10?Ya[\xc1\xd2?\xa8\xfd\xcf\xa0\xbc\xbe\xe6? Z\xe1\ti\xcc\xaf?\xa5klass\xaaFloatBlock\xa4axes\x92\x86\xa4name\xc0\xa5dtype\xa6object\xa8compress\xc0\xa4data\x92\xc4\x01A\xc4\x01B\xa5klass\xa5Index\xa3typ\xa5index\x86\xa4name\xc0\xa4stop\x05\xa5start\x00\xa4step\x01\xa5klass\xaaRangeIndex\xa3typ\xabrange_index\xa3typ\xadblock_manager\xa5klass\xa9DataFrame'
</pre> <p>Furthermore you can concatenate the strings to produce a list of the original objects.</p> <pre data-language="python">In [286]: pd.read_msgpack(df.to_msgpack() + s.to_msgpack())
Out[286]: 
[          A         B
 0  0.154336  0.710999
 1  0.398096  0.765220
 2  0.586749  0.293052
 3  0.290293  0.710783
 4  0.988593  0.062106, 2013-01-01    0.690810
 2013-01-02    0.235907
 2013-01-03    0.712756
 2013-01-04    0.119599
 2013-01-05    0.023493
 Freq: D, dtype: float64]
</pre>    <h2 id="io-hdf5">HDF5 (PyTables)</h2> <p id="hdf5-pytables"><code>HDFStore</code> is a dict-like object which reads and writes pandas using the high performance HDF5 format using the excellent <a class="reference external" href="http://www.pytables.org/" target="_blank">PyTables</a> library. See the <a class="reference internal" href="../cookbook/#cookbook-hdf"><span class="std std-ref">cookbook</span></a> for some advanced strategies</p> <div class="admonition warning"> <p class="first admonition-title">Warning</p> <p class="last">As of version 0.15.0, pandas requires <code>PyTables</code> &gt;= 3.0.0. Stores written with prior versions of pandas / <code>PyTables</code> &gt;= 2.3 are fully compatible (this was the previous minimum <code>PyTables</code> required version).</p> </div> <div class="admonition warning"> <p class="first admonition-title">Warning</p> <p class="last">There is a <code>PyTables</code> indexing bug which may appear when querying stores using an index. If you see a subset of results being returned, upgrade to <code>PyTables</code> &gt;= 3.2. Stores created previously will need to be rewritten using the updated version.</p> </div> <div class="admonition warning"> <p class="first admonition-title">Warning</p> <p class="last">As of version 0.17.0, <code>HDFStore</code> will not drop rows that have all missing values by default. Previously, if all values (except the index) were missing, <code>HDFStore</code> would not write those rows to disk.</p> </div> <pre data-language="python">In [287]: store = pd.HDFStore('store.h5')

In [288]: print(store)
&lt;class 'pandas.io.pytables.HDFStore'&gt;
File path: store.h5
Empty
</pre> <p>Objects can be written to the file just like adding key-value pairs to a dict:</p> <pre data-language="python">In [289]: np.random.seed(1234)

In [290]: index = pd.date_range('1/1/2000', periods=8)

In [291]: s = pd.Series(randn(5), index=['a', 'b', 'c', 'd', 'e'])

In [292]: df = pd.DataFrame(randn(8, 3), index=index,
   .....:                   columns=['A', 'B', 'C'])
   .....: 

In [293]: wp = pd.Panel(randn(2, 5, 4), items=['Item1', 'Item2'],
   .....:               major_axis=pd.date_range('1/1/2000', periods=5),
   .....:               minor_axis=['A', 'B', 'C', 'D'])
   .....: 

# store.put('s', s) is an equivalent method
In [294]: store['s'] = s

In [295]: store['df'] = df

In [296]: store['wp'] = wp

# the type of stored data
In [297]: store.root.wp._v_attrs.pandas_type
Out[297]: 'wide'

In [298]: store
Out[298]: 
&lt;class 'pandas.io.pytables.HDFStore'&gt;
File path: store.h5
/df            frame        (shape-&gt;[8,3])  
/s             series       (shape-&gt;[5])    
/wp            wide         (shape-&gt;[2,5,4])
</pre> <p>In a current or later Python session, you can retrieve stored objects:</p> <pre data-language="python"># store.get('df') is an equivalent method
In [299]: store['df']
Out[299]: 
                   A         B         C
2000-01-01  0.887163  0.859588 -0.636524
2000-01-02  0.015696 -2.242685  1.150036
2000-01-03  0.991946  0.953324 -2.021255
2000-01-04 -0.334077  0.002118  0.405453
2000-01-05  0.289092  1.321158 -1.546906
2000-01-06 -0.202646 -0.655969  0.193421
2000-01-07  0.553439  1.318152 -0.469305
2000-01-08  0.675554 -1.817027 -0.183109

# dotted (attribute) access provides get as well
In [300]: store.df
Out[300]: 
                   A         B         C
2000-01-01  0.887163  0.859588 -0.636524
2000-01-02  0.015696 -2.242685  1.150036
2000-01-03  0.991946  0.953324 -2.021255
2000-01-04 -0.334077  0.002118  0.405453
2000-01-05  0.289092  1.321158 -1.546906
2000-01-06 -0.202646 -0.655969  0.193421
2000-01-07  0.553439  1.318152 -0.469305
2000-01-08  0.675554 -1.817027 -0.183109
</pre> <p>Deletion of the object specified by the key</p> <pre data-language="python"># store.remove('wp') is an equivalent method
In [301]: del store['wp']

In [302]: store
Out[302]: 
&lt;class 'pandas.io.pytables.HDFStore'&gt;
File path: store.h5
/df            frame        (shape-&gt;[8,3])
/s             series       (shape-&gt;[5])  
</pre> <p>Closing a Store, Context Manager</p> <pre data-language="python">In [303]: store.close()

In [304]: store
Out[304]: 
&lt;class 'pandas.io.pytables.HDFStore'&gt;
File path: store.h5
File is CLOSED

In [305]: store.is_open
Out[305]: False

# Working with, and automatically closing the store with the context
# manager
In [306]: with pd.HDFStore('store.h5') as store:
   .....:     store.keys()
   .....: 
</pre>  <h3 id="id2">Read/Write API</h3> <p><code>HDFStore</code> supports an top-level API using <code>read_hdf</code> for reading and <code>to_hdf</code> for writing, similar to how <code>read_csv</code> and <code>to_csv</code> work. (new in 0.11.0)</p> <pre data-language="python">In [307]: df_tl = pd.DataFrame(dict(A=list(range(5)), B=list(range(5))))

In [308]: df_tl.to_hdf('store_tl.h5','table',append=True)

In [309]: pd.read_hdf('store_tl.h5', 'table', where = ['index&gt;2'])
Out[309]: 
   A  B
3  3  3
4  4  4
</pre> <p>As of version 0.17.0, HDFStore will no longer drop rows that are all missing by default. This behavior can be enabled by setting <code>dropna=True</code>.</p> <pre data-language="python">In [310]: df_with_missing = pd.DataFrame({'col1':[0, np.nan, 2],
   .....:                                 'col2':[1, np.nan, np.nan]})
   .....: 

In [311]: df_with_missing
Out[311]: 
   col1  col2
0   0.0   1.0
1   NaN   NaN
2   2.0   NaN

In [312]: df_with_missing.to_hdf('file.h5', 'df_with_missing',
   .....:                         format = 'table', mode='w')
   .....: 

In [313]: pd.read_hdf('file.h5', 'df_with_missing')
Out[313]: 
   col1  col2
0   0.0   1.0
1   NaN   NaN
2   2.0   NaN

In [314]: df_with_missing.to_hdf('file.h5', 'df_with_missing',
   .....:                         format = 'table', mode='w', dropna=True)
   .....: 

In [315]: pd.read_hdf('file.h5', 'df_with_missing')
Out[315]: 
   col1  col2
0   0.0   1.0
2   2.0   NaN
</pre> <p>This is also true for the major axis of a <code>Panel</code>:</p> <pre data-language="python">In [316]: matrix = [[[np.nan, np.nan, np.nan],[1,np.nan,np.nan]],
   .....:        [[np.nan, np.nan, np.nan], [np.nan,5,6]],
   .....:        [[np.nan, np.nan, np.nan],[np.nan,3,np.nan]]]
   .....: 

In [317]: panel_with_major_axis_all_missing = pd.Panel(matrix,
   .....:         items=['Item1', 'Item2','Item3'],
   .....:         major_axis=[1,2],
   .....:         minor_axis=['A', 'B', 'C'])
   .....: 

In [318]: panel_with_major_axis_all_missing
Out[318]: 
&lt;class 'pandas.core.panel.Panel'&gt;
Dimensions: 3 (items) x 2 (major_axis) x 3 (minor_axis)
Items axis: Item1 to Item3
Major_axis axis: 1 to 2
Minor_axis axis: A to C

In [319]: panel_with_major_axis_all_missing.to_hdf('file.h5', 'panel',
   .....:                                         dropna = True,
   .....:                                         format='table',
   .....:                                         mode='w')
   .....: 

In [320]: reloaded = pd.read_hdf('file.h5', 'panel')

In [321]: reloaded
Out[321]: 
&lt;class 'pandas.core.panel.Panel'&gt;
Dimensions: 3 (items) x 1 (major_axis) x 3 (minor_axis)
Items axis: Item1 to Item3
Major_axis axis: 2 to 2
Minor_axis axis: A to C
</pre>   <h3 id="io-hdf5-fixed">Fixed Format</h3> <div class="admonition note" id="fixed-format"> <p class="first admonition-title">Note</p> <p class="last">This was prior to 0.13.0 the <code>Storer</code> format.</p> </div> <p>The examples above show storing using <code>put</code>, which write the HDF5 to <code>PyTables</code> in a fixed array format, called the <code>fixed</code> format. These types of stores are are <strong>not</strong> appendable once written (though you can simply remove them and rewrite). Nor are they <strong>queryable</strong>; they must be retrieved in their entirety. They also do not support dataframes with non-unique column names. The <code>fixed</code> format stores offer very fast writing and slightly faster reading than <code>table</code> stores. This format is specified by default when using <code>put</code> or <code>to_hdf</code> or by <code>format='fixed'</code> or <code>format='f'</code></p> <div class="admonition warning"> <p class="first admonition-title">Warning</p> <p>A <code>fixed</code> format will raise a <code>TypeError</code> if you try to retrieve using a <code>where</code> .</p> <pre data-language="python">pd.DataFrame(randn(10,2)).to_hdf('test_fixed.h5','df')

pd.read_hdf('test_fixed.h5','df',where='index&gt;5')
TypeError: cannot pass a where specification when reading a fixed format.
           this store must be selected in its entirety
</pre> </div>   <h3 id="io-hdf5-table">Table Format</h3> <p id="table-format"><code>HDFStore</code> supports another <code>PyTables</code> format on disk, the <code>table</code> format. Conceptually a <code>table</code> is shaped very much like a DataFrame, with rows and columns. A <code>table</code> may be appended to in the same or other sessions. In addition, delete &amp; query type operations are supported. This format is specified by <code>format='table'</code> or <code>format='t'</code> to <code>append</code> or <code>put</code> or <code>to_hdf</code></p> <div class="versionadded"> <p><span class="versionmodified">New in version 0.13.</span></p> </div> <p>This format can be set as an option as well <code>pd.set_option('io.hdf.default_format','table')</code> to enable <code>put/append/to_hdf</code> to by default store in the <code>table</code> format.</p> <pre data-language="python">In [322]: store = pd.HDFStore('store.h5')

In [323]: df1 = df[0:4]

In [324]: df2 = df[4:]

# append data (creates a table automatically)
In [325]: store.append('df', df1)

In [326]: store.append('df', df2)

In [327]: store
Out[327]: 
&lt;class 'pandas.io.pytables.HDFStore'&gt;
File path: store.h5
/df            frame_table  (typ-&gt;appendable,nrows-&gt;8,ncols-&gt;3,indexers-&gt;[index])

# select the entire object
In [328]: store.select('df')
Out[328]: 
                   A         B         C
2000-01-01  0.887163  0.859588 -0.636524
2000-01-02  0.015696 -2.242685  1.150036
2000-01-03  0.991946  0.953324 -2.021255
2000-01-04 -0.334077  0.002118  0.405453
2000-01-05  0.289092  1.321158 -1.546906
2000-01-06 -0.202646 -0.655969  0.193421
2000-01-07  0.553439  1.318152 -0.469305
2000-01-08  0.675554 -1.817027 -0.183109

# the type of stored data
In [329]: store.root.df._v_attrs.pandas_type
Out[329]: 'frame_table'
</pre> <div class="admonition note"> <p class="first admonition-title">Note</p> <p class="last">You can also create a <code>table</code> by passing <code>format='table'</code> or <code>format='t'</code> to a <code>put</code> operation.</p> </div>   <h3 id="io-hdf5-keys">Hierarchical Keys</h3> <p id="hierarchical-keys">Keys to a store can be specified as a string. These can be in a hierarchical path-name like format (e.g. <code>foo/bar/bah</code>), which will generate a hierarchy of sub-stores (or <code>Groups</code> in PyTables parlance). Keys can be specified with out the leading ‘/’ and are ALWAYS absolute (e.g. ‘foo’ refers to ‘/foo’). Removal operations can remove everything in the sub-store and BELOW, so be <em>careful</em>.</p> <pre data-language="python">In [330]: store.put('foo/bar/bah', df)

In [331]: store.append('food/orange', df)

In [332]: store.append('food/apple',  df)

In [333]: store
Out[333]: 
&lt;class 'pandas.io.pytables.HDFStore'&gt;
File path: store.h5
/df                     frame_table  (typ-&gt;appendable,nrows-&gt;8,ncols-&gt;3,indexers-&gt;[index])
/foo/bar/bah            frame        (shape-&gt;[8,3])                                       
/food/apple             frame_table  (typ-&gt;appendable,nrows-&gt;8,ncols-&gt;3,indexers-&gt;[index])
/food/orange            frame_table  (typ-&gt;appendable,nrows-&gt;8,ncols-&gt;3,indexers-&gt;[index])

# a list of keys are returned
In [334]: store.keys()
Out[334]: ['/df', '/food/apple', '/food/orange', '/foo/bar/bah']

# remove all nodes under this level
In [335]: store.remove('food')

In [336]: store
Out[336]: 
&lt;class 'pandas.io.pytables.HDFStore'&gt;
File path: store.h5
/df                     frame_table  (typ-&gt;appendable,nrows-&gt;8,ncols-&gt;3,indexers-&gt;[index])
/foo/bar/bah            frame        (shape-&gt;[8,3])                                       
</pre> <div class="admonition warning"> <p class="first admonition-title">Warning</p> <p>Hierarchical keys cannot be retrieved as dotted (attribute) access as described above for items stored under the root node.</p> <pre data-language="python">In [8]: store.foo.bar.bah
AttributeError: 'HDFStore' object has no attribute 'foo'

# you can directly access the actual PyTables node but using the root node
In [9]: store.root.foo.bar.bah
Out[9]:
/foo/bar/bah (Group) ''
  children := ['block0_items' (Array), 'block0_values' (Array), 'axis0' (Array), 'axis1' (Array)]
</pre> <p>Instead, use explicit string based keys</p> <pre data-language="python">In [337]: store['foo/bar/bah']
Out[337]: 
                   A         B         C
2000-01-01  0.887163  0.859588 -0.636524
2000-01-02  0.015696 -2.242685  1.150036
2000-01-03  0.991946  0.953324 -2.021255
2000-01-04 -0.334077  0.002118  0.405453
2000-01-05  0.289092  1.321158 -1.546906
2000-01-06 -0.202646 -0.655969  0.193421
2000-01-07  0.553439  1.318152 -0.469305
2000-01-08  0.675554 -1.817027 -0.183109
</pre> </div>   <h3 id="io-hdf5-types">Storing Types</h3>  <h4 id="storing-types">Storing Mixed Types in a Table</h4> <p>Storing mixed-dtype data is supported. Strings are stored as a fixed-width using the maximum size of the appended column. Subsequent attempts at appending longer strings will raise a <code>ValueError</code>.</p> <p>Passing <code>min_itemsize={`values`: size}</code> as a parameter to append will set a larger minimum for the string columns. Storing <code>floats,
strings, ints, bools, datetime64</code> are currently supported. For string columns, passing <code>nan_rep = 'nan'</code> to append will change the default nan representation on disk (which converts to/from <code>np.nan</code>), this defaults to <code>nan</code>.</p> <pre data-language="python">In [338]: df_mixed = pd.DataFrame({ 'A' : randn(8),
   .....:                           'B' : randn(8),
   .....:                           'C' : np.array(randn(8),dtype='float32'),
   .....:                           'string' :'string',
   .....:                           'int' : 1,
   .....:                           'bool' : True,
   .....:                           'datetime64' : pd.Timestamp('20010102')},
   .....:                         index=list(range(8)))
   .....: 

In [339]: df_mixed.ix[3:5,['A', 'B', 'string', 'datetime64']] = np.nan

In [340]: store.append('df_mixed', df_mixed, min_itemsize = {'values': 50})

In [341]: df_mixed1 = store.select('df_mixed')

In [342]: df_mixed1
Out[342]: 
          A         B         C  bool datetime64  int  string
0  0.704721 -1.152659 -0.430096  True 2001-01-02    1  string
1 -0.785435  0.631979  0.767369  True 2001-01-02    1  string
2  0.462060  0.039513  0.984920  True 2001-01-02    1  string
3       NaN       NaN  0.270836  True        NaT    1     NaN
4       NaN       NaN  1.391986  True        NaT    1     NaN
5       NaN       NaN  0.079842  True        NaT    1     NaN
6  2.007843  0.152631 -0.399965  True 2001-01-02    1  string
7  0.226963  0.164530 -1.027851  True 2001-01-02    1  string

In [343]: df_mixed1.get_dtype_counts()
Out[343]: 
bool              1
datetime64[ns]    1
float32           1
float64           2
int64             1
object            1
dtype: int64

# we have provided a minimum string column size
In [344]: store.root.df_mixed.table
Out[344]: 
/df_mixed/table (Table(8,)) ''
  description := {
  "index": Int64Col(shape=(), dflt=0, pos=0),
  "values_block_0": Float64Col(shape=(2,), dflt=0.0, pos=1),
  "values_block_1": Float32Col(shape=(1,), dflt=0.0, pos=2),
  "values_block_2": Int64Col(shape=(1,), dflt=0, pos=3),
  "values_block_3": Int64Col(shape=(1,), dflt=0, pos=4),
  "values_block_4": BoolCol(shape=(1,), dflt=False, pos=5),
  "values_block_5": StringCol(itemsize=50, shape=(1,), dflt='', pos=6)}
  byteorder := 'little'
  chunkshape := (689,)
  autoindex := True
  colindexes := {
    "index": Index(6, medium, shuffle, zlib(1)).is_csi=False}
</pre>   <h4 id="storing-multi-index-dataframes">Storing Multi-Index DataFrames</h4> <p>Storing multi-index dataframes as tables is very similar to storing/selecting from homogeneous index DataFrames.</p> <pre data-language="python">In [345]: index = pd.MultiIndex(levels=[['foo', 'bar', 'baz', 'qux'],
   .....:                               ['one', 'two', 'three']],
   .....:                       labels=[[0, 0, 0, 1, 1, 2, 2, 3, 3, 3],
   .....:                               [0, 1, 2, 0, 1, 1, 2, 0, 1, 2]],
   .....:                       names=['foo', 'bar'])
   .....: 

In [346]: df_mi = pd.DataFrame(np.random.randn(10, 3), index=index,
   .....:                      columns=['A', 'B', 'C'])
   .....: 

In [347]: df_mi
Out[347]: 
                  A         B         C
foo bar                                
foo one   -0.584718  0.816594 -0.081947
    two   -0.344766  0.528288 -1.068989
    three -0.511881  0.291205  0.566534
bar one    0.503592  0.285296  0.484288
    two    1.363482 -0.781105 -0.468018
baz two    1.224574 -1.281108  0.875476
    three -1.710715 -0.450765  0.749164
qux one   -0.203933 -0.182175  0.680656
    two   -1.818499  0.047072  0.394844
    three -0.248432 -0.617707 -0.682884

In [348]: store.append('df_mi',df_mi)

In [349]: store.select('df_mi')
Out[349]: 
                  A         B         C
foo bar                                
foo one   -0.584718  0.816594 -0.081947
    two   -0.344766  0.528288 -1.068989
    three -0.511881  0.291205  0.566534
bar one    0.503592  0.285296  0.484288
    two    1.363482 -0.781105 -0.468018
baz two    1.224574 -1.281108  0.875476
    three -1.710715 -0.450765  0.749164
qux one   -0.203933 -0.182175  0.680656
    two   -1.818499  0.047072  0.394844
    three -0.248432 -0.617707 -0.682884

# the levels are automatically included as data columns
In [350]: store.select('df_mi', 'foo=bar')
Out[350]: 
                A         B         C
foo bar                              
bar one  0.503592  0.285296  0.484288
    two  1.363482 -0.781105 -0.468018
</pre>    <h3 id="io-hdf5-query">Querying</h3>  <h4 id="querying">Querying a Table</h4> <div class="admonition warning"> <p class="first admonition-title">Warning</p> <p class="last">This query capabilities have changed substantially starting in <code>0.13.0</code>. Queries from prior version are accepted (with a <code>DeprecationWarning</code>) printed if its not string-like.</p> </div> <p><code>select</code> and <code>delete</code> operations have an optional criterion that can be specified to select/delete only a subset of the data. This allows one to have a very large on-disk table and retrieve only a portion of the data.</p> <p>A query is specified using the <code>Term</code> class under the hood, as a boolean expression.</p> <ul class="simple"> <li>
<code>index</code> and <code>columns</code> are supported indexers of a DataFrame</li> <li>
<code>major_axis</code>, <code>minor_axis</code>, and <code>items</code> are supported indexers of the Panel</li> <li>if <code>data_columns</code> are specified, these can be used as additional indexers</li> </ul> <p>Valid comparison operators are:</p> <p><code>=, ==, !=, &gt;, &gt;=, &lt;, &lt;=</code></p> <p>Valid boolean expressions are combined with:</p> <ul class="simple"> <li>
<code>|</code> : or</li> <li>
<code>&amp;</code> : and</li> <li>
<code>(</code> and <code>)</code> : for grouping</li> </ul> <p>These rules are similar to how boolean expressions are used in pandas for indexing.</p> <div class="admonition note"> <p class="first admonition-title">Note</p> <ul class="last simple"> <li>
<code>=</code> will be automatically expanded to the comparison operator <code>==</code>
</li> <li>
<code>~</code> is the not operator, but can only be used in very limited circumstances</li> <li>If a list/tuple of expressions is passed they will be combined via <code>&amp;</code>
</li> </ul> </div> <p>The following are valid expressions:</p> <ul class="simple"> <li><code>'index&gt;=date'</code></li> <li><code>"columns=['A', 'D']"</code></li> <li><code>"columns in ['A', 'D']"</code></li> <li><code>'columns=A'</code></li> <li><code>'columns==A'</code></li> <li><code>"~(columns=['A','B'])"</code></li> <li><code>'index&gt;df.index[3] &amp; string="bar"'</code></li> <li><code>'(index&gt;df.index[3] &amp; index&lt;=df.index[6]) | string="bar"'</code></li> <li><code>"ts&gt;=Timestamp('2012-02-01')"</code></li> <li><code>"major_axis&gt;=20130101"</code></li> </ul> <p>The <code>indexers</code> are on the left-hand side of the sub-expression:</p> <p><code>columns</code>, <code>major_axis</code>, <code>ts</code></p> <p>The right-hand side of the sub-expression (after a comparison operator) can be:</p> <ul class="simple"> <li>functions that will be evaluated, e.g. <code>Timestamp('2012-02-01')</code>
</li> <li>strings, e.g. <code>"bar"</code>
</li> <li>date-like, e.g. <code>20130101</code>, or <code>"20130101"</code>
</li> <li>lists, e.g. <code>"['A','B']"</code>
</li> <li>variables that are defined in the local names space, e.g. <code>date</code>
</li> </ul> <div class="admonition note"> <p class="first admonition-title">Note</p> <p>Passing a string to a query by interpolating it into the query expression is not recommended. Simply assign the string of interest to a variable and use that variable in an expression. For example, do this</p> <pre data-language="python">string = "HolyMoly'"
store.select('df', 'index == string')
</pre> <p>instead of this</p> <pre data-language="python">string = "HolyMoly'"
store.select('df',  'index == %s' % string)
</pre> <p>The latter will <strong>not</strong> work and will raise a <code>SyntaxError</code>.Note that there’s a single quote followed by a double quote in the <code>string</code> variable.</p> <p>If you <em>must</em> interpolate, use the <code>'%r'</code> format specifier</p> <pre data-language="python">store.select('df', 'index == %r' % string)
</pre> <p class="last">which will quote <code>string</code>.</p> </div> <p>Here are some examples:</p> <pre data-language="python">In [351]: dfq = pd.DataFrame(randn(10,4),columns=list('ABCD'),index=pd.date_range('20130101',periods=10))

In [352]: store.append('dfq',dfq,format='table',data_columns=True)
</pre> <p>Use boolean expressions, with in-line function evaluation.</p> <pre data-language="python">In [353]: store.select('dfq',"index&gt;pd.Timestamp('20130104') &amp; columns=['A', 'B']")
Out[353]: 
                   A         B
2013-01-05  1.210384  0.797435
2013-01-06 -0.850346  1.176812
2013-01-07  0.984188 -0.121728
2013-01-08  0.796595 -0.474021
2013-01-09 -0.804834 -2.123620
2013-01-10  0.334198  0.536784
</pre> <p>Use and inline column reference</p> <pre data-language="python">In [354]: store.select('dfq',where="A&gt;0 or C&gt;0")
Out[354]: 
                   A         B         C         D
2013-01-01  0.436258 -1.703013  0.393711 -0.479324
2013-01-02 -0.299016  0.694103  0.678630  0.239556
2013-01-03  0.151227  0.816127  1.893534  0.639633
2013-01-04 -0.962029 -2.085266  1.930247 -1.735349
2013-01-05  1.210384  0.797435 -0.379811  0.702562
2013-01-07  0.984188 -0.121728  2.365769  0.496143
2013-01-08  0.796595 -0.474021 -0.056696  1.357797
2013-01-10  0.334198  0.536784 -0.743830 -0.320204
</pre> <p>Works with a Panel as well.</p> <pre data-language="python">In [355]: store.append('wp',wp)

In [356]: store
Out[356]: 
&lt;class 'pandas.io.pytables.HDFStore'&gt;
File path: store.h5
/df                     frame_table  (typ-&gt;appendable,nrows-&gt;8,ncols-&gt;3,indexers-&gt;[index])                     
/df_mi                  frame_table  (typ-&gt;appendable_multi,nrows-&gt;10,ncols-&gt;5,indexers-&gt;[index],dc-&gt;[bar,foo])
/df_mixed               frame_table  (typ-&gt;appendable,nrows-&gt;8,ncols-&gt;7,indexers-&gt;[index])                     
/dfq                    frame_table  (typ-&gt;appendable,nrows-&gt;10,ncols-&gt;4,indexers-&gt;[index],dc-&gt;[A,B,C,D])      
/foo/bar/bah            frame        (shape-&gt;[8,3])                                                            
/wp                     wide_table   (typ-&gt;appendable,nrows-&gt;20,ncols-&gt;2,indexers-&gt;[major_axis,minor_axis])    

In [357]: store.select('wp', "major_axis&gt;pd.Timestamp('20000102') &amp; minor_axis=['A', 'B']")
Out[357]: 
&lt;class 'pandas.core.panel.Panel'&gt;
Dimensions: 2 (items) x 3 (major_axis) x 2 (minor_axis)
Items axis: Item1 to Item2
Major_axis axis: 2000-01-03 00:00:00 to 2000-01-05 00:00:00
Minor_axis axis: A to B
</pre> <p>The <code>columns</code> keyword can be supplied to select a list of columns to be returned, this is equivalent to passing a <code>'columns=list_of_columns_to_filter'</code>:</p> <pre data-language="python">In [358]: store.select('df', "columns=['A', 'B']")
Out[358]: 
                   A         B
2000-01-01  0.887163  0.859588
2000-01-02  0.015696 -2.242685
2000-01-03  0.991946  0.953324
2000-01-04 -0.334077  0.002118
2000-01-05  0.289092  1.321158
2000-01-06 -0.202646 -0.655969
2000-01-07  0.553439  1.318152
2000-01-08  0.675554 -1.817027
</pre> <p><code>start</code> and <code>stop</code> parameters can be specified to limit the total search space. These are in terms of the total number of rows in a table.</p> <pre data-language="python"># this is effectively what the storage of a Panel looks like
In [359]: wp.to_frame()
Out[359]: 
                     Item1     Item2
major      minor                    
2000-01-01 A      1.058969  0.215269
           B     -0.397840  0.841009
           C      0.337438 -1.445810
           D      1.047579 -1.401973
2000-01-02 A      1.045938 -0.100918
           B      0.863717 -0.548242
           C     -0.122092 -0.144620
...                    ...       ...
2000-01-04 B      0.036142  0.307969
           C     -2.074978 -0.208499
           D      0.247792  1.033801
2000-01-05 A     -0.897157 -2.400454
           B     -0.136795  2.030604
           C      0.018289 -1.142631
           D      0.755414  0.211883

[20 rows x 2 columns]

# limiting the search
In [360]: store.select('wp',"major_axis&gt;20000102 &amp; minor_axis=['A','B']",
   .....:              start=0, stop=10)
   .....: 
Out[360]: 
&lt;class 'pandas.core.panel.Panel'&gt;
Dimensions: 2 (items) x 1 (major_axis) x 2 (minor_axis)
Items axis: Item1 to Item2
Major_axis axis: 2000-01-03 00:00:00 to 2000-01-03 00:00:00
Minor_axis axis: A to B
</pre> <div class="admonition note"> <p class="first admonition-title">Note</p> <p><code>select</code> will raise a <code>ValueError</code> if the query expression has an unknown variable reference. Usually this means that you are trying to select on a column that is <strong>not</strong> a data_column.</p> <p class="last"><code>select</code> will raise a <code>SyntaxError</code> if the query expression is not valid.</p> </div>   <h4 id="io-hdf5-timedelta">Using timedelta64[ns]</h4> <div class="versionadded" id="using-timedelta64-ns"> <p><span class="versionmodified">New in version 0.13.</span></p> </div> <p>Beginning in 0.13.0, you can store and query using the <code>timedelta64[ns]</code> type. Terms can be specified in the format: <code>&lt;float&gt;(&lt;unit&gt;)</code>, where float may be signed (and fractional), and unit can be <code>D,s,ms,us,ns</code> for the timedelta. Here’s an example:</p> <pre data-language="python">In [361]: from datetime import timedelta

In [362]: dftd = pd.DataFrame(dict(A = pd.Timestamp('20130101'), B = [ pd.Timestamp('20130101') + timedelta(days=i,seconds=10) for i in range(10) ]))

In [363]: dftd['C'] = dftd['A']-dftd['B']

In [364]: dftd
Out[364]: 
           A                   B                  C
0 2013-01-01 2013-01-01 00:00:10  -1 days +23:59:50
1 2013-01-01 2013-01-02 00:00:10  -2 days +23:59:50
2 2013-01-01 2013-01-03 00:00:10  -3 days +23:59:50
3 2013-01-01 2013-01-04 00:00:10  -4 days +23:59:50
4 2013-01-01 2013-01-05 00:00:10  -5 days +23:59:50
5 2013-01-01 2013-01-06 00:00:10  -6 days +23:59:50
6 2013-01-01 2013-01-07 00:00:10  -7 days +23:59:50
7 2013-01-01 2013-01-08 00:00:10  -8 days +23:59:50
8 2013-01-01 2013-01-09 00:00:10  -9 days +23:59:50
9 2013-01-01 2013-01-10 00:00:10 -10 days +23:59:50

In [365]: store.append('dftd',dftd,data_columns=True)

In [366]: store.select('dftd',"C&lt;'-3.5D'")
Out[366]: 
           A                   B                  C
4 2013-01-01 2013-01-05 00:00:10  -5 days +23:59:50
5 2013-01-01 2013-01-06 00:00:10  -6 days +23:59:50
6 2013-01-01 2013-01-07 00:00:10  -7 days +23:59:50
7 2013-01-01 2013-01-08 00:00:10  -8 days +23:59:50
8 2013-01-01 2013-01-09 00:00:10  -9 days +23:59:50
9 2013-01-01 2013-01-10 00:00:10 -10 days +23:59:50
</pre>   <h4 id="indexing">Indexing</h4> <p>You can create/modify an index for a table with <code>create_table_index</code> after data is already in the table (after and <code>append/put</code> operation). Creating a table index is <strong>highly</strong> encouraged. This will speed your queries a great deal when you use a <code>select</code> with the indexed dimension as the <code>where</code>.</p> <div class="admonition note"> <p class="first admonition-title">Note</p> <p class="last">Indexes are automagically created (starting <code>0.10.1</code>) on the indexables and any data columns you specify. This behavior can be turned off by passing <code>index=False</code> to <code>append</code>.</p> </div> <pre data-language="python"># we have automagically already created an index (in the first section)
In [367]: i = store.root.df.table.cols.index.index

In [368]: i.optlevel, i.kind
Out[368]: (6, 'medium')

# change an index by passing new parameters
In [369]: store.create_table_index('df', optlevel=9, kind='full')

In [370]: i = store.root.df.table.cols.index.index

In [371]: i.optlevel, i.kind
Out[371]: (9, 'full')
</pre> <p>Oftentimes when appending large amounts of data to a store, it is useful to turn off index creation for each append, then recreate at the end.</p> <pre data-language="python">In [372]: df_1 = pd.DataFrame(randn(10,2),columns=list('AB'))

In [373]: df_2 = pd.DataFrame(randn(10,2),columns=list('AB'))

In [374]: st = pd.HDFStore('appends.h5',mode='w')

In [375]: st.append('df', df_1, data_columns=['B'], index=False)

In [376]: st.append('df', df_2, data_columns=['B'], index=False)

In [377]: st.get_storer('df').table
Out[377]: 
/df/table (Table(20,)) ''
  description := {
  "index": Int64Col(shape=(), dflt=0, pos=0),
  "values_block_0": Float64Col(shape=(1,), dflt=0.0, pos=1),
  "B": Float64Col(shape=(), dflt=0.0, pos=2)}
  byteorder := 'little'
  chunkshape := (2730,)
</pre> <p>Then create the index when finished appending.</p> <pre data-language="python">In [378]: st.create_table_index('df', columns=['B'], optlevel=9, kind='full')

In [379]: st.get_storer('df').table
Out[379]: 
/df/table (Table(20,)) ''
  description := {
  "index": Int64Col(shape=(), dflt=0, pos=0),
  "values_block_0": Float64Col(shape=(1,), dflt=0.0, pos=1),
  "B": Float64Col(shape=(), dflt=0.0, pos=2)}
  byteorder := 'little'
  chunkshape := (2730,)
  autoindex := True
  colindexes := {
    "B": Index(9, full, shuffle, zlib(1)).is_csi=True}

In [380]: st.close()
</pre> <p>See <a class="reference external" href="http://stackoverflow.com/questions/17893370/ptrepack-sortby-needs-full-index" target="_blank">here</a> for how to create a completely-sorted-index (CSI) on an existing store.</p>   <h4 id="query-via-data-columns">Query via Data Columns</h4> <p>You can designate (and index) certain columns that you want to be able to perform queries (other than the <code>indexable</code> columns, which you can always query). For instance say you want to perform this common operation, on-disk, and return just the frame that matches this query. You can specify <code>data_columns = True</code> to force all columns to be data_columns</p> <pre data-language="python">In [381]: df_dc = df.copy()

In [382]: df_dc['string'] = 'foo'

In [383]: df_dc.ix[4:6,'string'] = np.nan

In [384]: df_dc.ix[7:9,'string'] = 'bar'

In [385]: df_dc['string2'] = 'cool'

In [386]: df_dc.ix[1:3,['B','C']] = 1.0

In [387]: df_dc
Out[387]: 
                   A         B         C string string2
2000-01-01  0.887163  0.859588 -0.636524    foo    cool
2000-01-02  0.015696  1.000000  1.000000    foo    cool
2000-01-03  0.991946  1.000000  1.000000    foo    cool
2000-01-04 -0.334077  0.002118  0.405453    foo    cool
2000-01-05  0.289092  1.321158 -1.546906    NaN    cool
2000-01-06 -0.202646 -0.655969  0.193421    NaN    cool
2000-01-07  0.553439  1.318152 -0.469305    foo    cool
2000-01-08  0.675554 -1.817027 -0.183109    bar    cool

# on-disk operations
In [388]: store.append('df_dc', df_dc, data_columns = ['B', 'C', 'string', 'string2'])

In [389]: store.select('df_dc', [ pd.Term('B&gt;0') ])
Out[389]: 
                   A         B         C string string2
2000-01-01  0.887163  0.859588 -0.636524    foo    cool
2000-01-02  0.015696  1.000000  1.000000    foo    cool
2000-01-03  0.991946  1.000000  1.000000    foo    cool
2000-01-04 -0.334077  0.002118  0.405453    foo    cool
2000-01-05  0.289092  1.321158 -1.546906    NaN    cool
2000-01-07  0.553439  1.318152 -0.469305    foo    cool

# getting creative
In [390]: store.select('df_dc', 'B &gt; 0 &amp; C &gt; 0 &amp; string == foo')
Out[390]: 
                   A         B         C string string2
2000-01-02  0.015696  1.000000  1.000000    foo    cool
2000-01-03  0.991946  1.000000  1.000000    foo    cool
2000-01-04 -0.334077  0.002118  0.405453    foo    cool

# this is in-memory version of this type of selection
In [391]: df_dc[(df_dc.B &gt; 0) &amp; (df_dc.C &gt; 0) &amp; (df_dc.string == 'foo')]
Out[391]: 
                   A         B         C string string2
2000-01-02  0.015696  1.000000  1.000000    foo    cool
2000-01-03  0.991946  1.000000  1.000000    foo    cool
2000-01-04 -0.334077  0.002118  0.405453    foo    cool

# we have automagically created this index and the B/C/string/string2
# columns are stored separately as ``PyTables`` columns
In [392]: store.root.df_dc.table
Out[392]: 
/df_dc/table (Table(8,)) ''
  description := {
  "index": Int64Col(shape=(), dflt=0, pos=0),
  "values_block_0": Float64Col(shape=(1,), dflt=0.0, pos=1),
  "B": Float64Col(shape=(), dflt=0.0, pos=2),
  "C": Float64Col(shape=(), dflt=0.0, pos=3),
  "string": StringCol(itemsize=3, shape=(), dflt='', pos=4),
  "string2": StringCol(itemsize=4, shape=(), dflt='', pos=5)}
  byteorder := 'little'
  chunkshape := (1680,)
  autoindex := True
  colindexes := {
    "index": Index(6, medium, shuffle, zlib(1)).is_csi=False,
    "C": Index(6, medium, shuffle, zlib(1)).is_csi=False,
    "B": Index(6, medium, shuffle, zlib(1)).is_csi=False,
    "string2": Index(6, medium, shuffle, zlib(1)).is_csi=False,
    "string": Index(6, medium, shuffle, zlib(1)).is_csi=False}
</pre> <p>There is some performance degradation by making lots of columns into <code>data columns</code>, so it is up to the user to designate these. In addition, you cannot change data columns (nor indexables) after the first append/put operation (Of course you can simply read in the data and create a new table!)</p>   <h4 id="iterator">Iterator</h4> <p>Starting in <code>0.11.0</code>, you can pass, <code>iterator=True</code> or <code>chunksize=number_in_a_chunk</code> to <code>select</code> and <code>select_as_multiple</code> to return an iterator on the results. The default is 50,000 rows returned in a chunk.</p> <pre data-language="python">In [393]: for df in store.select('df', chunksize=3):
   .....:    print(df)
   .....: 
                   A         B         C
2000-01-01  0.887163  0.859588 -0.636524
2000-01-02  0.015696 -2.242685  1.150036
2000-01-03  0.991946  0.953324 -2.021255
                   A         B         C
2000-01-04 -0.334077  0.002118  0.405453
2000-01-05  0.289092  1.321158 -1.546906
2000-01-06 -0.202646 -0.655969  0.193421
                   A         B         C
2000-01-07  0.553439  1.318152 -0.469305
2000-01-08  0.675554 -1.817027 -0.183109
</pre> <div class="admonition note"> <p class="first admonition-title">Note</p> <div class="versionadded"> <p><span class="versionmodified">New in version 0.12.0.</span></p> </div> <p>You can also use the iterator with <code>read_hdf</code> which will open, then automatically close the store when finished iterating.</p> <pre data-language="python">for df in pd.read_hdf('store.h5','df', chunksize=3):
    print(df)
</pre> </div> <p>Note, that the chunksize keyword applies to the <strong>source</strong> rows. So if you are doing a query, then the chunksize will subdivide the total rows in the table and the query applied, returning an iterator on potentially unequal sized chunks.</p> <p>Here is a recipe for generating a query and using it to create equal sized return chunks.</p> <pre data-language="python">In [394]: dfeq = pd.DataFrame({'number': np.arange(1,11)})

In [395]: dfeq
Out[395]: 
   number
0       1
1       2
2       3
3       4
4       5
5       6
6       7
7       8
8       9
9      10

In [396]: store.append('dfeq', dfeq, data_columns=['number'])

In [397]: def chunks(l, n):
   .....:      return [l[i:i+n] for i in range(0, len(l), n)]
   .....: 

In [398]: evens = [2,4,6,8,10]

In [399]: coordinates = store.select_as_coordinates('dfeq','number=evens')

In [400]: for c in chunks(coordinates, 2):
   .....:      print store.select('dfeq',where=c)
   .....: 
   number
1       2
3       4
   number
5       6
7       8
   number
9      10
</pre>   <h4 id="advanced-queries">Advanced Queries</h4>  <h5 id="select-a-single-column">Select a Single Column</h5> <p>To retrieve a single indexable or data column, use the method <code>select_column</code>. This will, for example, enable you to get the index very quickly. These return a <code>Series</code> of the result, indexed by the row number. These do not currently accept the <code>where</code> selector.</p> <pre data-language="python">In [401]: store.select_column('df_dc', 'index')
Out[401]: 
0   2000-01-01
1   2000-01-02
2   2000-01-03
3   2000-01-04
4   2000-01-05
5   2000-01-06
6   2000-01-07
7   2000-01-08
Name: index, dtype: datetime64[ns]

In [402]: store.select_column('df_dc', 'string')
Out[402]: 
0    foo
1    foo
2    foo
3    foo
4    NaN
5    NaN
6    foo
7    bar
Name: string, dtype: object
</pre>   <h5 id="io-hdf5-selecting-coordinates">Selecting coordinates</h5> <p id="selecting-coordinates">Sometimes you want to get the coordinates (a.k.a the index locations) of your query. This returns an <code>Int64Index</code> of the resulting locations. These coordinates can also be passed to subsequent <code>where</code> operations.</p> <pre data-language="python">In [403]: df_coord = pd.DataFrame(np.random.randn(1000,2),index=pd.date_range('20000101',periods=1000))

In [404]: store.append('df_coord',df_coord)

In [405]: c = store.select_as_coordinates('df_coord','index&gt;20020101')

In [406]: c.summary()
Out[406]: u'Int64Index: 268 entries, 732 to 999'

In [407]: store.select('df_coord',where=c)
Out[407]: 
                   0         1
2002-01-02 -0.178266 -0.064638
2002-01-03 -1.204956 -3.880898
2002-01-04  0.974470  0.415160
2002-01-05  1.751967  0.485011
2002-01-06 -0.170894  0.748870
2002-01-07  0.629793  0.811053
2002-01-08  2.133776  0.238459
...              ...       ...
2002-09-20 -0.181434  0.612399
2002-09-21 -0.763324 -0.354962
2002-09-22 -0.261776  0.812126
2002-09-23  0.482615 -0.886512
2002-09-24 -0.037757 -0.562953
2002-09-25  0.897706  0.383232
2002-09-26 -1.324806  1.139269

[268 rows x 2 columns]
</pre>   <h5 id="io-hdf5-where-mask">Selecting using a where mask</h5> <p id="selecting-using-a-where-mask">Sometime your query can involve creating a list of rows to select. Usually this <code>mask</code> would be a resulting <code>index</code> from an indexing operation. This example selects the months of a datetimeindex which are 5.</p> <pre data-language="python">In [408]: df_mask = pd.DataFrame(np.random.randn(1000,2),index=pd.date_range('20000101',periods=1000))

In [409]: store.append('df_mask',df_mask)

In [410]: c = store.select_column('df_mask','index')

In [411]: where = c[pd.DatetimeIndex(c).month==5].index

In [412]: store.select('df_mask',where=where)
Out[412]: 
                   0         1
2000-05-01 -1.006245 -0.616759
2000-05-02  0.218940  0.717838
2000-05-03  0.013333  1.348060
2000-05-04  0.662176 -1.050645
2000-05-05 -1.034870 -0.243242
2000-05-06 -0.753366 -1.454329
2000-05-07 -1.022920 -0.476989
...              ...       ...
2002-05-25 -0.509090 -0.389376
2002-05-26  0.150674  1.164337
2002-05-27 -0.332944  0.115181
2002-05-28 -1.048127 -0.605733
2002-05-29  1.418754 -0.442835
2002-05-30 -0.433200  0.835001
2002-05-31 -1.041278  1.401811

[93 rows x 2 columns]
</pre>   <h5 id="storer-object">Storer Object</h5> <p>If you want to inspect the stored object, retrieve via <code>get_storer</code>. You could use this programmatically to say get the number of rows in an object.</p> <pre data-language="python">In [413]: store.get_storer('df_dc').nrows
Out[413]: 8
</pre>    <h4 id="multiple-table-queries">Multiple Table Queries</h4> <p>New in 0.10.1 are the methods <code>append_to_multiple</code> and <code>select_as_multiple</code>, that can perform appending/selecting from multiple tables at once. The idea is to have one table (call it the selector table) that you index most/all of the columns, and perform your queries. The other table(s) are data tables with an index matching the selector table’s index. You can then perform a very fast query on the selector table, yet get lots of data back. This method is similar to having a very wide table, but enables more efficient queries.</p> <p>The <code>append_to_multiple</code> method splits a given single DataFrame into multiple tables according to <code>d</code>, a dictionary that maps the table names to a list of ‘columns’ you want in that table. If <code>None</code> is used in place of a list, that table will have the remaining unspecified columns of the given DataFrame. The argument <code>selector</code> defines which table is the selector table (which you can make queries from). The argument <code>dropna</code> will drop rows from the input DataFrame to ensure tables are synchronized. This means that if a row for one of the tables being written to is entirely <code>np.NaN</code>, that row will be dropped from all tables.</p> <p>If <code>dropna</code> is False, <strong>THE USER IS RESPONSIBLE FOR SYNCHRONIZING THE TABLES</strong>. Remember that entirely <code>np.Nan</code> rows are not written to the HDFStore, so if you choose to call <code>dropna=False</code>, some tables may have more rows than others, and therefore <code>select_as_multiple</code> may not work or it may return unexpected results.</p> <pre data-language="python">In [414]: df_mt = pd.DataFrame(randn(8, 6), index=pd.date_range('1/1/2000', periods=8),
   .....:                                   columns=['A', 'B', 'C', 'D', 'E', 'F'])
   .....: 

In [415]: df_mt['foo'] = 'bar'

In [416]: df_mt.ix[1, ('A', 'B')] = np.nan

# you can also create the tables individually
In [417]: store.append_to_multiple({'df1_mt': ['A', 'B'], 'df2_mt': None },
   .....:                           df_mt, selector='df1_mt')
   .....: 

In [418]: store
Out[418]: 
&lt;class 'pandas.io.pytables.HDFStore'&gt;
File path: store.h5
/df                     frame_table  (typ-&gt;appendable,nrows-&gt;8,ncols-&gt;3,indexers-&gt;[index])                         
/df1_mt                 frame_table  (typ-&gt;appendable,nrows-&gt;8,ncols-&gt;2,indexers-&gt;[index],dc-&gt;[A,B])               
/df2_mt                 frame_table  (typ-&gt;appendable,nrows-&gt;8,ncols-&gt;5,indexers-&gt;[index])                         
/df_coord               frame_table  (typ-&gt;appendable,nrows-&gt;1000,ncols-&gt;2,indexers-&gt;[index])                      
/df_dc                  frame_table  (typ-&gt;appendable,nrows-&gt;8,ncols-&gt;5,indexers-&gt;[index],dc-&gt;[B,C,string,string2])
/df_mask                frame_table  (typ-&gt;appendable,nrows-&gt;1000,ncols-&gt;2,indexers-&gt;[index])                      
/df_mi                  frame_table  (typ-&gt;appendable_multi,nrows-&gt;10,ncols-&gt;5,indexers-&gt;[index],dc-&gt;[bar,foo])    
/df_mixed               frame_table  (typ-&gt;appendable,nrows-&gt;8,ncols-&gt;7,indexers-&gt;[index])                         
/dfeq                   frame_table  (typ-&gt;appendable,nrows-&gt;10,ncols-&gt;1,indexers-&gt;[index],dc-&gt;[number])           
/dfq                    frame_table  (typ-&gt;appendable,nrows-&gt;10,ncols-&gt;4,indexers-&gt;[index],dc-&gt;[A,B,C,D])          
/dftd                   frame_table  (typ-&gt;appendable,nrows-&gt;10,ncols-&gt;3,indexers-&gt;[index],dc-&gt;[A,B,C])            
/foo/bar/bah            frame        (shape-&gt;[8,3])                                                                
/wp                     wide_table   (typ-&gt;appendable,nrows-&gt;20,ncols-&gt;2,indexers-&gt;[major_axis,minor_axis])        

# individual tables were created
In [419]: store.select('df1_mt')
Out[419]: 
                   A         B
2000-01-01  0.714697  0.318215
2000-01-02       NaN       NaN
2000-01-03 -0.086919  0.416905
2000-01-04  0.489131 -0.253340
2000-01-05 -0.382952 -0.397373
2000-01-06  0.538116  0.226388
2000-01-07 -2.073479 -0.115926
2000-01-08 -0.695400  0.402493

In [420]: store.select('df2_mt')
Out[420]: 
                   C         D         E         F  foo
2000-01-01  0.607460  0.790907  0.852225  0.096696  bar
2000-01-02  0.811031 -0.356817  1.047085  0.664705  bar
2000-01-03 -0.764381 -0.287229 -0.089351 -1.035115  bar
2000-01-04 -1.948100 -0.116556  0.800597 -0.796154  bar
2000-01-05 -0.717627  0.156995 -0.344718 -0.171208  bar
2000-01-06  1.541729  0.205256  1.998065  0.953591  bar
2000-01-07  1.391070  0.303013  1.093347 -0.101000  bar
2000-01-08 -1.507639  0.089575  0.658822 -1.037627  bar

# as a multiple
In [421]: store.select_as_multiple(['df1_mt', 'df2_mt'], where=['A&gt;0', 'B&gt;0'],
   .....:                           selector = 'df1_mt')
   .....: 
Out[421]: 
                   A         B         C         D         E         F  foo
2000-01-01  0.714697  0.318215  0.607460  0.790907  0.852225  0.096696  bar
2000-01-06  0.538116  0.226388  1.541729  0.205256  1.998065  0.953591  bar
</pre>    <h3 id="delete-from-a-table">Delete from a Table</h3> <p>You can delete from a table selectively by specifying a <code>where</code>. In deleting rows, it is important to understand the <code>PyTables</code> deletes rows by erasing the rows, then <strong>moving</strong> the following data. Thus deleting can potentially be a very expensive operation depending on the orientation of your data. This is especially true in higher dimensional objects (<code>Panel</code> and <code>Panel4D</code>). To get optimal performance, it’s worthwhile to have the dimension you are deleting be the first of the <code>indexables</code>.</p> <p>Data is ordered (on the disk) in terms of the <code>indexables</code>. Here’s a simple use case. You store panel-type data, with dates in the <code>major_axis</code> and ids in the <code>minor_axis</code>. The data is then interleaved like this:</p> <ul class="simple"> <li>date_1 - id_1 - id_2 - . - id_n</li> <li>date_2 - id_1 - . - id_n</li> </ul> <p>It should be clear that a delete operation on the <code>major_axis</code> will be fairly quick, as one chunk is removed, then the following data moved. On the other hand a delete operation on the <code>minor_axis</code> will be very expensive. In this case it would almost certainly be faster to rewrite the table using a <code>where</code> that selects all but the missing data.</p> <pre data-language="python"># returns the number of rows deleted
In [422]: store.remove('wp', 'major_axis&gt;20000102' )
Out[422]: 12

In [423]: store.select('wp')
Out[423]: 
&lt;class 'pandas.core.panel.Panel'&gt;
Dimensions: 2 (items) x 2 (major_axis) x 4 (minor_axis)
Items axis: Item1 to Item2
Major_axis axis: 2000-01-01 00:00:00 to 2000-01-02 00:00:00
Minor_axis axis: A to D
</pre> <div class="admonition warning"> <p class="first admonition-title">Warning</p> <p>Please note that HDF5 <strong>DOES NOT RECLAIM SPACE</strong> in the h5 files automatically. Thus, repeatedly deleting (or removing nodes) and adding again, <strong>WILL TEND TO INCREASE THE FILE SIZE</strong>.</p> <p class="last">To <em>repack and clean</em> the file, use <a class="reference internal" href="#io-hdf5-ptrepack"><span class="std std-ref">ptrepack</span></a></p> </div>   <h3 id="io-hdf5-notes">Notes &amp; Caveats</h3>  <h4 id="notes-caveats">Compression</h4> <p><code>PyTables</code> allows the stored data to be compressed. This applies to all kinds of stores, not just tables.</p> <ul class="simple"> <li>Pass <code>complevel=int</code> for a compression level (1-9, with 0 being no compression, and the default)</li> <li>Pass <code>complib=lib</code> where lib is any of <code>zlib, bzip2, lzo, blosc</code> for whichever compression library you prefer.</li> </ul> <p><code>HDFStore</code> will use the file based compression scheme if no overriding <code>complib</code> or <code>complevel</code> options are provided. <code>blosc</code> offers very fast compression, and is my most used. Note that <code>lzo</code> and <code>bzip2</code> may not be installed (by Python) by default.</p> <p>Compression for all objects within the file</p> <pre data-language="python">store_compressed = pd.HDFStore('store_compressed.h5', complevel=9, complib='blosc')
</pre> <p>Or on-the-fly compression (this only applies to tables). You can turn off file compression for a specific table by passing <code>complevel=0</code></p> <pre data-language="python">store.append('df', df, complib='zlib', complevel=5)
</pre>   <h4 id="io-hdf5-ptrepack">ptrepack</h4> <p id="ptrepack"><code>PyTables</code> offers better write performance when tables are compressed after they are written, as opposed to turning on compression at the very beginning. You can use the supplied <code>PyTables</code> utility <code>ptrepack</code>. In addition, <code>ptrepack</code> can change compression levels after the fact.</p> <pre data-language="console">ptrepack --chunkshape=auto --propindexes --complevel=9 --complib=blosc in.h5 out.h5
</pre> <p>Furthermore <code>ptrepack in.h5 out.h5</code> will <em>repack</em> the file to allow you to reuse previously deleted space. Alternatively, one can simply remove the file and write again, or use the <code>copy</code> method.</p>   <h4 id="io-hdf5-caveats">Caveats</h4> <div class="admonition warning" id="caveats"> <p class="first admonition-title">Warning</p> <p class="last"><code>HDFStore</code> is <strong>not-threadsafe for writing</strong>. The underlying <code>PyTables</code> only supports concurrent reads (via threading or processes). If you need reading and writing <em>at the same time</em>, you need to serialize these operations in a single thread in a single process. You will corrupt your data otherwise. See the (<a class="reference external" href="https://github.com/pandas-dev/pandas/issues/2397" target="_blank">GH2397</a>) for more information.</p> </div> <ul class="simple"> <li>If you use locks to manage write access between multiple processes, you may want to use <a class="reference external" href="https://docs.python.org/3/library/os.html#os.fsync" title="(in Python v3.6)" target="_blank"><code>fsync()</code></a> before releasing write locks. For convenience you can use <code>store.flush(fsync=True)</code> to do this for you.</li> <li>Once a <code>table</code> is created its items (Panel) / columns (DataFrame) are fixed; only exactly the same columns can be appended</li> <li>Be aware that timezones (e.g., <code>pytz.timezone('US/Eastern')</code>) are not necessarily equal across timezone versions. So if data is localized to a specific timezone in the HDFStore using one version of a timezone library and that data is updated with another version, the data will be converted to UTC since these timezones are not considered equal. Either use the same version of timezone library or use <code>tz_convert</code> with the updated timezone definition.</li> </ul> <div class="admonition warning"> <p class="first admonition-title">Warning</p> <p class="last"><code>PyTables</code> will show a <code>NaturalNameWarning</code> if a column name cannot be used as an attribute selector. <em>Natural</em> identifiers contain only letters, numbers, and underscores, and may not begin with a number. Other identifiers cannot be used in a <code>where</code> clause and are generally a bad idea.</p> </div>    <h3 id="io-hdf5-data-types">DataTypes</h3> <p id="datatypes"><code>HDFStore</code> will map an object dtype to the <code>PyTables</code> underlying dtype. This means the following types are known to work:</p> <table class="docutils">  <thead valign="bottom"> <tr class="row-odd">
<th class="head">Type</th> <th class="head">Represents missing values</th> </tr> </thead>  <tr class="row-even">
<td>floating : <code>float64, float32, float16</code>
</td> <td><code>np.nan</code></td> </tr> <tr class="row-odd">
<td>integer : <code>int64, int32, int8, uint64,uint32, uint8</code>
</td> <td> </td> </tr> <tr class="row-even">
<td>boolean</td> <td> </td> </tr> <tr class="row-odd">
<td><code>datetime64[ns]</code></td> <td><code>NaT</code></td> </tr> <tr class="row-even">
<td><code>timedelta64[ns]</code></td> <td><code>NaT</code></td> </tr> <tr class="row-odd">
<td>categorical : see the section below</td> <td> </td> </tr> <tr class="row-even">
<td>object : <code>strings</code>
</td> <td><code>np.nan</code></td> </tr>  </table> <p><code>unicode</code> columns are not supported, and <strong>WILL FAIL</strong>.</p>  <h4 id="io-hdf5-categorical">Categorical Data</h4> <div class="versionadded" id="categorical-data"> <p><span class="versionmodified">New in version 0.15.2.</span></p> </div> <p>Writing data to a <code>HDFStore</code> that contains a <code>category</code> dtype was implemented in 0.15.2. Queries work the same as if it was an object array. However, the <code>category</code> dtyped data is stored in a more efficient manner.</p> <pre data-language="python">In [424]: dfcat = pd.DataFrame({ 'A' : pd.Series(list('aabbcdba')).astype('category'),
   .....:                        'B' : np.random.randn(8) })
   .....: 

In [425]: dfcat
Out[425]: 
   A         B
0  a  0.603273
1  a  0.262554
2  b -0.979586
3  b  2.132387
4  c  0.892485
5  d  1.996474
6  b  0.231425
7  a  0.980070

In [426]: dfcat.dtypes
Out[426]: 
A    category
B     float64
dtype: object

In [427]: cstore = pd.HDFStore('cats.h5', mode='w')

In [428]: cstore.append('dfcat', dfcat, format='table', data_columns=['A'])

In [429]: result = cstore.select('dfcat', where="A in ['b','c']")

In [430]: result
Out[430]: 
   A         B
2  b -0.979586
3  b  2.132387
4  c  0.892485
6  b  0.231425

In [431]: result.dtypes
Out[431]: 
A    category
B     float64
dtype: object
</pre> <div class="admonition warning"> <p class="first admonition-title">Warning</p> <p>The format of the <code>Categorical</code> is readable by prior versions of pandas (&lt; 0.15.2), but will retrieve the data as an integer based column (e.g. the <code>codes</code>). However, the <code>categories</code> <em>can</em> be retrieved but require the user to select them manually using the explicit meta path.</p> <p>The data is stored like so:</p> <pre data-language="python">In [432]: cstore
Out[432]: 
&lt;class 'pandas.io.pytables.HDFStore'&gt;
File path: cats.h5
/dfcat                        frame_table  (typ-&gt;appendable,nrows-&gt;8,ncols-&gt;2,indexers-&gt;[index],dc-&gt;[A])     
/dfcat/meta/A/meta            series_table (typ-&gt;appendable,nrows-&gt;4,ncols-&gt;1,indexers-&gt;[index],dc-&gt;[values])

# to get the categories
In [433]: cstore.select('dfcat/meta/A/meta')
Out[433]: 
0    a
1    b
2    c
3    d
dtype: object
</pre> </div>   <h4 id="string-columns">String Columns</h4> <p><strong>min_itemsize</strong></p> <p>The underlying implementation of <code>HDFStore</code> uses a fixed column width (itemsize) for string columns. A string column itemsize is calculated as the maximum of the length of data (for that column) that is passed to the <code>HDFStore</code>, <strong>in the first append</strong>. Subsequent appends, may introduce a string for a column <strong>larger</strong> than the column can hold, an Exception will be raised (otherwise you could have a silent truncation of these columns, leading to loss of information). In the future we may relax this and allow a user-specified truncation to occur.</p> <p>Pass <code>min_itemsize</code> on the first table creation to a-priori specify the minimum length of a particular string column. <code>min_itemsize</code> can be an integer, or a dict mapping a column name to an integer. You can pass <code>values</code> as a key to allow all <em>indexables</em> or <em>data_columns</em> to have this min_itemsize.</p> <p>Starting in 0.11.0, passing a <code>min_itemsize</code> dict will cause all passed columns to be created as <em>data_columns</em> automatically.</p> <div class="admonition note"> <p class="first admonition-title">Note</p> <p class="last">If you are not passing any <code>data_columns</code>, then the <code>min_itemsize</code> will be the maximum of the length of any string passed</p> </div> <pre data-language="python">In [434]: dfs = pd.DataFrame(dict(A = 'foo', B = 'bar'),index=list(range(5)))

In [435]: dfs
Out[435]: 
     A    B
0  foo  bar
1  foo  bar
2  foo  bar
3  foo  bar
4  foo  bar

# A and B have a size of 30
In [436]: store.append('dfs', dfs, min_itemsize = 30)

In [437]: store.get_storer('dfs').table
Out[437]: 
/dfs/table (Table(5,)) ''
  description := {
  "index": Int64Col(shape=(), dflt=0, pos=0),
  "values_block_0": StringCol(itemsize=30, shape=(2,), dflt='', pos=1)}
  byteorder := 'little'
  chunkshape := (963,)
  autoindex := True
  colindexes := {
    "index": Index(6, medium, shuffle, zlib(1)).is_csi=False}

# A is created as a data_column with a size of 30
# B is size is calculated
In [438]: store.append('dfs2', dfs, min_itemsize = { 'A' : 30 })

In [439]: store.get_storer('dfs2').table
Out[439]: 
/dfs2/table (Table(5,)) ''
  description := {
  "index": Int64Col(shape=(), dflt=0, pos=0),
  "values_block_0": StringCol(itemsize=3, shape=(1,), dflt='', pos=1),
  "A": StringCol(itemsize=30, shape=(), dflt='', pos=2)}
  byteorder := 'little'
  chunkshape := (1598,)
  autoindex := True
  colindexes := {
    "A": Index(6, medium, shuffle, zlib(1)).is_csi=False,
    "index": Index(6, medium, shuffle, zlib(1)).is_csi=False}
</pre> <p><strong>nan_rep</strong></p> <p>String columns will serialize a <code>np.nan</code> (a missing value) with the <code>nan_rep</code> string representation. This defaults to the string value <code>nan</code>. You could inadvertently turn an actual <code>nan</code> value into a missing value.</p> <pre data-language="python">In [440]: dfss = pd.DataFrame(dict(A = ['foo','bar','nan']))

In [441]: dfss
Out[441]: 
     A
0  foo
1  bar
2  nan

In [442]: store.append('dfss', dfss)

In [443]: store.select('dfss')
Out[443]: 
     A
0  foo
1  bar
2  NaN

# here you need to specify a different nan rep
In [444]: store.append('dfss2', dfss, nan_rep='_nan_')

In [445]: store.select('dfss2')
Out[445]: 
     A
0  foo
1  bar
2  nan
</pre>    <h3 id="io-external-compatibility">External Compatibility</h3> <p id="external-compatibility"><code>HDFStore</code> writes <code>table</code> format objects in specific formats suitable for producing loss-less round trips to pandas objects. For external compatibility, <code>HDFStore</code> can read native <code>PyTables</code> format tables.</p> <p>It is possible to write an <code>HDFStore</code> object that can easily be imported into <code>R</code> using the <code>rhdf5</code> library (<a class="reference external" href="http://www.bioconductor.org/packages/release/bioc/html/rhdf5.html" target="_blank">Package website</a>). Create a table format store like this:</p> <pre data-language="python">In [446]: np.random.seed(1)

In [447]: df_for_r = pd.DataFrame({"first": np.random.rand(100),
   .....:                          "second": np.random.rand(100),
   .....:                          "class": np.random.randint(0, 2, (100,))},
   .....:                          index=range(100))
   .....: 

In [448]: df_for_r.head()
Out[448]: 
   class     first    second
0      0  0.417022  0.326645
1      0  0.720324  0.527058
2      1  0.000114  0.885942
3      1  0.302333  0.357270
4      1  0.146756  0.908535

In [449]: store_export = pd.HDFStore('export.h5')

In [450]: store_export.append('df_for_r', df_for_r, data_columns=df_dc.columns)

In [451]: store_export
Out[451]: 
&lt;class 'pandas.io.pytables.HDFStore'&gt;
File path: export.h5
/df_for_r            frame_table  (typ-&gt;appendable,nrows-&gt;100,ncols-&gt;3,indexers-&gt;[index])
</pre> <p>In R this file can be read into a <code>data.frame</code> object using the <code>rhdf5</code> library. The following example function reads the corresponding column names and data values from the values and assembles them into a <code>data.frame</code>:</p> <pre data-language="R"># Load values and column names for all datasets from corresponding nodes and
# insert them into one data.frame object.

library(rhdf5)

loadhdf5data &lt;- function(h5File) {

listing &lt;- h5ls(h5File)
# Find all data nodes, values are stored in *_values and corresponding column
# titles in *_items
data_nodes &lt;- grep("_values", listing$name)
name_nodes &lt;- grep("_items", listing$name)
data_paths = paste(listing$group[data_nodes], listing$name[data_nodes], sep = "/")
name_paths = paste(listing$group[name_nodes], listing$name[name_nodes], sep = "/")
columns = list()
for (idx in seq(data_paths)) {
  # NOTE: matrices returned by h5read have to be transposed to to obtain
  # required Fortran order!
  data &lt;- data.frame(t(h5read(h5File, data_paths[idx])))
  names &lt;- t(h5read(h5File, name_paths[idx]))
  entry &lt;- data.frame(data)
  colnames(entry) &lt;- names
  columns &lt;- append(columns, entry)
}

data &lt;- data.frame(columns)

return(data)
}
</pre> <p>Now you can import the <code>DataFrame</code> into R:</p> <pre data-language="R">&gt; data = loadhdf5data("transfer.hdf5")
&gt; head(data)
         first    second class
1 0.4170220047 0.3266449     0
2 0.7203244934 0.5270581     0
3 0.0001143748 0.8859421     1
4 0.3023325726 0.3572698     1
5 0.1467558908 0.9085352     1
6 0.0923385948 0.6233601     1
</pre> <div class="admonition note"> <p class="first admonition-title">Note</p> <p class="last">The R function lists the entire HDF5 file’s contents and assembles the <code>data.frame</code> object from all matching nodes, so use this only as a starting point if you have stored multiple <code>DataFrame</code> objects to a single HDF5 file.</p> </div>   <h3 id="backwards-compatibility">Backwards Compatibility</h3> <p>0.10.1 of <code>HDFStore</code> can read tables created in a prior version of pandas, however query terms using the prior (undocumented) methodology are unsupported. <code>HDFStore</code> will issue a warning if you try to use a legacy-format file. You must read in the entire file and write it out using the new format, using the method <code>copy</code> to take advantage of the updates. The group attribute <code>pandas_version</code> contains the version information. <code>copy</code> takes a number of options, please see the docstring.</p> <pre data-language="python"># a legacy store
In [452]: legacy_store = pd.HDFStore(legacy_file_path,'r')

In [453]: legacy_store
Out[453]: 
&lt;class 'pandas.io.pytables.HDFStore'&gt;
File path: /home/joris/scipy/pandas/doc/source/_static/legacy_0.10.h5
/a                    series       (shape-&gt;[30])                                                                        
/b                    frame        (shape-&gt;[30,4])                                                                      
/df1_mixed            frame_table [0.10.0] (typ-&gt;appendable,nrows-&gt;30,ncols-&gt;11,indexers-&gt;[index])                      
/foo/bar              wide         (shape-&gt;[3,30,4])                                                                    
/p1_mixed             wide_table  [0.10.0] (typ-&gt;appendable,nrows-&gt;120,ncols-&gt;9,indexers-&gt;[major_axis,minor_axis])      
/p4d_mixed            ndim_table  [0.10.0] (typ-&gt;appendable,nrows-&gt;360,ncols-&gt;9,indexers-&gt;[items,major_axis,minor_axis])

# copy (and return the new handle)
In [454]: new_store = legacy_store.copy('store_new.h5')

In [455]: new_store
Out[455]: 
&lt;class 'pandas.io.pytables.HDFStore'&gt;
File path: store_new.h5
/a                    series       (shape-&gt;[30])                                                                
/b                    frame        (shape-&gt;[30,4])                                                              
/df1_mixed            frame_table  (typ-&gt;appendable,nrows-&gt;30,ncols-&gt;11,indexers-&gt;[index])                      
/foo/bar              wide         (shape-&gt;[3,30,4])                                                            
/p1_mixed             wide_table   (typ-&gt;appendable,nrows-&gt;120,ncols-&gt;9,indexers-&gt;[major_axis,minor_axis])      
/p4d_mixed            wide_table   (typ-&gt;appendable,nrows-&gt;360,ncols-&gt;9,indexers-&gt;[items,major_axis,minor_axis])

In [456]: new_store.close()
</pre>   <h3 id="performance">Performance</h3> <ul class="simple"> <li>
<code>tables</code> format come with a writing performance penalty as compared to <code>fixed</code> stores. The benefit is the ability to append/delete and query (potentially very large amounts of data). Write times are generally longer as compared with regular stores. Query times can be quite fast, especially on an indexed axis.</li> <li>You can pass <code>chunksize=&lt;int&gt;</code> to <code>append</code>, specifying the write chunksize (default is 50000). This will significantly lower your memory usage on writing.</li> <li>You can pass <code>expectedrows=&lt;int&gt;</code> to the first <code>append</code>, to set the TOTAL number of expected rows that <code>PyTables</code> will expected. This will optimize read/write performance.</li> <li>Duplicate rows can be written to tables, but are filtered out in selection (with the last items being selected; thus a table is unique on major, minor pairs)</li> <li>A <code>PerformanceWarning</code> will be raised if you are attempting to store types that will be pickled by PyTables (rather than stored as endemic types). See <a class="reference external" href="http://stackoverflow.com/questions/14355151/how-to-make-pandas-hdfstore-put-operation-faster/14370190#14370190" target="_blank">Here</a> for more information and some solutions.</li> </ul>   <h3 id="experimental">Experimental</h3> <p>HDFStore supports <code>Panel4D</code> storage.</p> <pre data-language="python">In [457]: p4d = pd.Panel4D({ 'l1' : wp })

In [458]: p4d
Out[458]: 
&lt;class 'pandas.core.panelnd.Panel4D'&gt;
Dimensions: 1 (labels) x 2 (items) x 5 (major_axis) x 4 (minor_axis)
Labels axis: l1 to l1
Items axis: Item1 to Item2
Major_axis axis: 2000-01-01 00:00:00 to 2000-01-05 00:00:00
Minor_axis axis: A to D

In [459]: store.append('p4d', p4d)

In [460]: store
Out[460]: 
&lt;class 'pandas.io.pytables.HDFStore'&gt;
File path: store.h5
/df                     frame_table  (typ-&gt;appendable,nrows-&gt;8,ncols-&gt;3,indexers-&gt;[index])                         
/df1_mt                 frame_table  (typ-&gt;appendable,nrows-&gt;8,ncols-&gt;2,indexers-&gt;[index],dc-&gt;[A,B])               
/df2_mt                 frame_table  (typ-&gt;appendable,nrows-&gt;8,ncols-&gt;5,indexers-&gt;[index])                         
/df_coord               frame_table  (typ-&gt;appendable,nrows-&gt;1000,ncols-&gt;2,indexers-&gt;[index])                      
/df_dc                  frame_table  (typ-&gt;appendable,nrows-&gt;8,ncols-&gt;5,indexers-&gt;[index],dc-&gt;[B,C,string,string2])
/df_mask                frame_table  (typ-&gt;appendable,nrows-&gt;1000,ncols-&gt;2,indexers-&gt;[index])                      
/df_mi                  frame_table  (typ-&gt;appendable_multi,nrows-&gt;10,ncols-&gt;5,indexers-&gt;[index],dc-&gt;[bar,foo])    
/df_mixed               frame_table  (typ-&gt;appendable,nrows-&gt;8,ncols-&gt;7,indexers-&gt;[index])                         
/dfeq                   frame_table  (typ-&gt;appendable,nrows-&gt;10,ncols-&gt;1,indexers-&gt;[index],dc-&gt;[number])           
/dfq                    frame_table  (typ-&gt;appendable,nrows-&gt;10,ncols-&gt;4,indexers-&gt;[index],dc-&gt;[A,B,C,D])          
/dfs                    frame_table  (typ-&gt;appendable,nrows-&gt;5,ncols-&gt;2,indexers-&gt;[index])                         
/dfs2                   frame_table  (typ-&gt;appendable,nrows-&gt;5,ncols-&gt;2,indexers-&gt;[index],dc-&gt;[A])                 
/dfss                   frame_table  (typ-&gt;appendable,nrows-&gt;3,ncols-&gt;1,indexers-&gt;[index])                         
/dfss2                  frame_table  (typ-&gt;appendable,nrows-&gt;3,ncols-&gt;1,indexers-&gt;[index])                         
/dftd                   frame_table  (typ-&gt;appendable,nrows-&gt;10,ncols-&gt;3,indexers-&gt;[index],dc-&gt;[A,B,C])            
/foo/bar/bah            frame        (shape-&gt;[8,3])                                                                
/p4d                    wide_table   (typ-&gt;appendable,nrows-&gt;40,ncols-&gt;1,indexers-&gt;[items,major_axis,minor_axis])  
/wp                     wide_table   (typ-&gt;appendable,nrows-&gt;8,ncols-&gt;2,indexers-&gt;[major_axis,minor_axis])         
</pre> <p>These, by default, index the three axes <code>items, major_axis,
minor_axis</code>. On an <code>AppendableTable</code> it is possible to setup with the first append a different indexing scheme, depending on how you want to store your data. Pass the <code>axes</code> keyword with a list of dimensions (currently must by exactly 1 less than the total dimensions of the object). This cannot be changed after table creation.</p> <pre data-language="python">In [461]: store.append('p4d2', p4d, axes=['labels', 'major_axis', 'minor_axis'])

In [462]: store
Out[462]: 
&lt;class 'pandas.io.pytables.HDFStore'&gt;
File path: store.h5
/df                     frame_table  (typ-&gt;appendable,nrows-&gt;8,ncols-&gt;3,indexers-&gt;[index])                         
/df1_mt                 frame_table  (typ-&gt;appendable,nrows-&gt;8,ncols-&gt;2,indexers-&gt;[index],dc-&gt;[A,B])               
/df2_mt                 frame_table  (typ-&gt;appendable,nrows-&gt;8,ncols-&gt;5,indexers-&gt;[index])                         
/df_coord               frame_table  (typ-&gt;appendable,nrows-&gt;1000,ncols-&gt;2,indexers-&gt;[index])                      
/df_dc                  frame_table  (typ-&gt;appendable,nrows-&gt;8,ncols-&gt;5,indexers-&gt;[index],dc-&gt;[B,C,string,string2])
/df_mask                frame_table  (typ-&gt;appendable,nrows-&gt;1000,ncols-&gt;2,indexers-&gt;[index])                      
/df_mi                  frame_table  (typ-&gt;appendable_multi,nrows-&gt;10,ncols-&gt;5,indexers-&gt;[index],dc-&gt;[bar,foo])    
/df_mixed               frame_table  (typ-&gt;appendable,nrows-&gt;8,ncols-&gt;7,indexers-&gt;[index])                         
/dfeq                   frame_table  (typ-&gt;appendable,nrows-&gt;10,ncols-&gt;1,indexers-&gt;[index],dc-&gt;[number])           
/dfq                    frame_table  (typ-&gt;appendable,nrows-&gt;10,ncols-&gt;4,indexers-&gt;[index],dc-&gt;[A,B,C,D])          
/dfs                    frame_table  (typ-&gt;appendable,nrows-&gt;5,ncols-&gt;2,indexers-&gt;[index])                         
/dfs2                   frame_table  (typ-&gt;appendable,nrows-&gt;5,ncols-&gt;2,indexers-&gt;[index],dc-&gt;[A])                 
/dfss                   frame_table  (typ-&gt;appendable,nrows-&gt;3,ncols-&gt;1,indexers-&gt;[index])                         
/dfss2                  frame_table  (typ-&gt;appendable,nrows-&gt;3,ncols-&gt;1,indexers-&gt;[index])                         
/dftd                   frame_table  (typ-&gt;appendable,nrows-&gt;10,ncols-&gt;3,indexers-&gt;[index],dc-&gt;[A,B,C])            
/foo/bar/bah            frame        (shape-&gt;[8,3])                                                                
/p4d                    wide_table   (typ-&gt;appendable,nrows-&gt;40,ncols-&gt;1,indexers-&gt;[items,major_axis,minor_axis])  
/p4d2                   wide_table   (typ-&gt;appendable,nrows-&gt;20,ncols-&gt;2,indexers-&gt;[labels,major_axis,minor_axis]) 
/wp                     wide_table   (typ-&gt;appendable,nrows-&gt;8,ncols-&gt;2,indexers-&gt;[major_axis,minor_axis])         

In [463]: store.select('p4d2', [ pd.Term('labels=l1'), pd.Term('items=Item1'), pd.Term('minor_axis=A_big_strings') ])
Out[463]: 
&lt;class 'pandas.core.panelnd.Panel4D'&gt;
Dimensions: 0 (labels) x 1 (items) x 0 (major_axis) x 0 (minor_axis)
Labels axis: None
Items axis: Item1 to Item1
Major_axis axis: None
Minor_axis axis: None
</pre>    <h2 id="io-sql">SQL Queries</h2> <p id="sql-queries">The <code>pandas.io.sql</code> module provides a collection of query wrappers to both facilitate data retrieval and to reduce dependency on DB-specific API. Database abstraction is provided by SQLAlchemy if installed. In addition you will need a driver library for your database. Examples of such drivers are <a class="reference external" href="http://initd.org/psycopg/" target="_blank">psycopg2</a> for PostgreSQL or <a class="reference external" href="https://github.com/PyMySQL/PyMySQL" target="_blank">pymysql</a> for MySQL. For <a class="reference external" href="https://docs.python.org/3.5/library/sqlite3.html" target="_blank">SQLite</a> this is included in Python’s standard library by default. You can find an overview of supported drivers for each SQL dialect in the <a class="reference external" href="http://docs.sqlalchemy.org/en/latest/dialects/index.html" target="_blank">SQLAlchemy docs</a>.</p> <div class="versionadded"> <p><span class="versionmodified">New in version 0.14.0.</span></p> </div> <p>If SQLAlchemy is not installed, a fallback is only provided for sqlite (and for mysql for backwards compatibility, but this is deprecated and will be removed in a future version). This mode requires a Python database adapter which respect the <a class="reference external" href="http://www.python.org/dev/peps/pep-0249/" target="_blank">Python DB-API</a>.</p> <p>See also some <a class="reference internal" href="../cookbook/#cookbook-sql"><span class="std std-ref">cookbook examples</span></a> for some advanced strategies.</p> <p>The key functions are:</p> <table class="longtable docutils">   <tr class="row-odd">
<td>
<a class="reference internal" href="../generated/pandas.read_sql_table/#pandas.read_sql_table" title="pandas.read_sql_table"><code>read_sql_table</code></a>(table_name, con[, schema, ...])</td> <td>Read SQL database table into a DataFrame.</td> </tr> <tr class="row-even">
<td>
<a class="reference internal" href="../generated/pandas.read_sql_query/#pandas.read_sql_query" title="pandas.read_sql_query"><code>read_sql_query</code></a>(sql, con[, index_col, ...])</td> <td>Read SQL query into a DataFrame.</td> </tr> <tr class="row-odd">
<td>
<a class="reference internal" href="../generated/pandas.read_sql/#pandas.read_sql" title="pandas.read_sql"><code>read_sql</code></a>(sql, con[, index_col, ...])</td> <td>Read SQL query or database table into a DataFrame.</td> </tr> <tr class="row-even">
<td>
<a class="reference internal" href="../generated/pandas.dataframe.to_sql/#pandas.DataFrame.to_sql" title="pandas.DataFrame.to_sql"><code>DataFrame.to_sql</code></a>(name, con[, flavor, ...])</td> <td>Write records stored in a DataFrame to a SQL database.</td> </tr>  </table> <div class="admonition note"> <p class="first admonition-title">Note</p> <p class="last">The function <a class="reference internal" href="../generated/pandas.read_sql/#pandas.read_sql" title="pandas.read_sql"><code>read_sql()</code></a> is a convenience wrapper around <a class="reference internal" href="../generated/pandas.read_sql_table/#pandas.read_sql_table" title="pandas.read_sql_table"><code>read_sql_table()</code></a> and <a class="reference internal" href="../generated/pandas.read_sql_query/#pandas.read_sql_query" title="pandas.read_sql_query"><code>read_sql_query()</code></a> (and for backward compatibility) and will delegate to specific function depending on the provided input (database table name or sql query). Table names do not need to be quoted if they have special characters.</p> </div> <p>In the following example, we use the <a class="reference external" href="http://www.sqlite.org/" target="_blank">SQlite</a> SQL database engine. You can use a temporary SQLite database where data are stored in “memory”.</p> <p>To connect with SQLAlchemy you use the <code>create_engine()</code> function to create an engine object from database URI. You only need to create the engine once per database you are connecting to. For more information on <code>create_engine()</code> and the URI formatting, see the examples below and the SQLAlchemy <a class="reference external" href="http://docs.sqlalchemy.org/en/latest/core/engines.html" target="_blank">documentation</a></p> <pre data-language="python">In [464]: from sqlalchemy import create_engine

# Create your engine.
In [465]: engine = create_engine('sqlite:///:memory:')
</pre> <p>If you want to manage your own connections you can pass one of those instead:</p> <pre data-language="python">with engine.connect() as conn, conn.begin():
    data = pd.read_sql_table('data', conn)
</pre>  <h3 id="writing-dataframes">Writing DataFrames</h3> <p>Assuming the following data is in a DataFrame <code>data</code>, we can insert it into the database using <a class="reference internal" href="../generated/pandas.dataframe.to_sql/#pandas.DataFrame.to_sql" title="pandas.DataFrame.to_sql"><code>to_sql()</code></a>.</p> <table class="docutils">  <thead valign="bottom"> <tr class="row-odd">
<th class="head">id</th> <th class="head">Date</th> <th class="head">Col_1</th> <th class="head">Col_2</th> <th class="head">Col_3</th> </tr> </thead>  <tr class="row-even">
<td>26</td> <td>2012-10-18</td> <td>X</td> <td>25.7</td> <td>True</td> </tr> <tr class="row-odd">
<td>42</td> <td>2012-10-19</td> <td>Y</td> <td>-12.4</td> <td>False</td> </tr> <tr class="row-even">
<td>63</td> <td>2012-10-20</td> <td>Z</td> <td>5.73</td> <td>True</td> </tr>  </table> <pre data-language="python">In [466]: data.to_sql('data', engine)
</pre> <p>With some databases, writing large DataFrames can result in errors due to packet size limitations being exceeded. This can be avoided by setting the <code>chunksize</code> parameter when calling <code>to_sql</code>. For example, the following writes <code>data</code> to the database in batches of 1000 rows at a time:</p> <pre data-language="python">In [467]: data.to_sql('data_chunked', engine, chunksize=1000)
</pre>  <h4 id="sql-data-types">SQL data types</h4> <p><a class="reference internal" href="../generated/pandas.dataframe.to_sql/#pandas.DataFrame.to_sql" title="pandas.DataFrame.to_sql"><code>to_sql()</code></a> will try to map your data to an appropriate SQL data type based on the dtype of the data. When you have columns of dtype <code>object</code>, pandas will try to infer the data type.</p> <p>You can always override the default type by specifying the desired SQL type of any of the columns by using the <code>dtype</code> argument. This argument needs a dictionary mapping column names to SQLAlchemy types (or strings for the sqlite3 fallback mode). For example, specifying to use the sqlalchemy <code>String</code> type instead of the default <code>Text</code> type for string columns:</p> <pre data-language="python">In [468]: from sqlalchemy.types import String

In [469]: data.to_sql('data_dtype', engine, dtype={'Col_1': String})
</pre> <div class="admonition note"> <p class="first admonition-title">Note</p> <p class="last">Due to the limited support for timedelta’s in the different database flavors, columns with type <code>timedelta64</code> will be written as integer values as nanoseconds to the database and a warning will be raised.</p> </div> <div class="admonition note"> <p class="first admonition-title">Note</p> <p class="last">Columns of <code>category</code> dtype will be converted to the dense representation as you would get with <code>np.asarray(categorical)</code> (e.g. for string categories this gives an array of strings). Because of this, reading the database table back in does <strong>not</strong> generate a categorical.</p> </div>    <h3 id="reading-tables">Reading Tables</h3> <p><a class="reference internal" href="../generated/pandas.read_sql_table/#pandas.read_sql_table" title="pandas.read_sql_table"><code>read_sql_table()</code></a> will read a database table given the table name and optionally a subset of columns to read.</p> <div class="admonition note"> <p class="first admonition-title">Note</p> <p class="last">In order to use <a class="reference internal" href="../generated/pandas.read_sql_table/#pandas.read_sql_table" title="pandas.read_sql_table"><code>read_sql_table()</code></a>, you <strong>must</strong> have the SQLAlchemy optional dependency installed.</p> </div> <pre data-language="python">In [470]: pd.read_sql_table('data', engine)
Out[470]: 
   index  id       Date Col_1  Col_2  Col_3
0      0  26 2010-10-18     X  27.50   True
1      1  42 2010-10-19     Y -12.50  False
2      2  63 2010-10-20     Z   5.73   True
</pre> <p>You can also specify the name of the column as the DataFrame index, and specify a subset of columns to be read.</p> <pre data-language="python">In [471]: pd.read_sql_table('data', engine, index_col='id')
Out[471]: 
    index       Date Col_1  Col_2  Col_3
id                                      
26      0 2010-10-18     X  27.50   True
42      1 2010-10-19     Y -12.50  False
63      2 2010-10-20     Z   5.73   True

In [472]: pd.read_sql_table('data', engine, columns=['Col_1', 'Col_2'])
Out[472]: 
  Col_1  Col_2
0     X  27.50
1     Y -12.50
2     Z   5.73
</pre> <p>And you can explicitly force columns to be parsed as dates:</p> <pre data-language="python">In [473]: pd.read_sql_table('data', engine, parse_dates=['Date'])
Out[473]: 
   index  id       Date Col_1  Col_2  Col_3
0      0  26 2010-10-18     X  27.50   True
1      1  42 2010-10-19     Y -12.50  False
2      2  63 2010-10-20     Z   5.73   True
</pre> <p>If needed you can explicitly specify a format string, or a dict of arguments to pass to <a class="reference internal" href="../generated/pandas.to_datetime/#pandas.to_datetime" title="pandas.to_datetime"><code>pandas.to_datetime()</code></a>:</p> <pre data-language="python">pd.read_sql_table('data', engine, parse_dates={'Date': '%Y-%m-%d'})
pd.read_sql_table('data', engine, parse_dates={'Date': {'format': '%Y-%m-%d %H:%M:%S'}})
</pre> <p>You can check if a table exists using <code>has_table()</code></p>   <h3 id="schema-support">Schema support</h3> <div class="versionadded"> <p><span class="versionmodified">New in version 0.15.0.</span></p> </div> <p>Reading from and writing to different schema’s is supported through the <code>schema</code> keyword in the <a class="reference internal" href="../generated/pandas.read_sql_table/#pandas.read_sql_table" title="pandas.read_sql_table"><code>read_sql_table()</code></a> and <a class="reference internal" href="../generated/pandas.dataframe.to_sql/#pandas.DataFrame.to_sql" title="pandas.DataFrame.to_sql"><code>to_sql()</code></a> functions. Note however that this depends on the database flavor (sqlite does not have schema’s). For example:</p> <pre data-language="python">df.to_sql('table', engine, schema='other_schema')
pd.read_sql_table('table', engine, schema='other_schema')
</pre>   <h3 id="id3">Querying</h3> <p>You can query using raw SQL in the <a class="reference internal" href="../generated/pandas.read_sql_query/#pandas.read_sql_query" title="pandas.read_sql_query"><code>read_sql_query()</code></a> function. In this case you must use the SQL variant appropriate for your database. When using SQLAlchemy, you can also pass SQLAlchemy Expression language constructs, which are database-agnostic.</p> <pre data-language="python">In [474]: pd.read_sql_query('SELECT * FROM data', engine)
Out[474]: 
   index  id                        Date Col_1  Col_2  Col_3
0      0  26  2010-10-18 00:00:00.000000     X  27.50      1
1      1  42  2010-10-19 00:00:00.000000     Y -12.50      0
2      2  63  2010-10-20 00:00:00.000000     Z   5.73      1
</pre> <p>Of course, you can specify a more “complex” query.</p> <pre data-language="python">In [475]: pd.read_sql_query("SELECT id, Col_1, Col_2 FROM data WHERE id = 42;", engine)
Out[475]: 
   id Col_1  Col_2
0  42     Y  -12.5
</pre> <p>The <a class="reference internal" href="../generated/pandas.read_sql_query/#pandas.read_sql_query" title="pandas.read_sql_query"><code>read_sql_query()</code></a> function supports a <code>chunksize</code> argument. Specifying this will return an iterator through chunks of the query result:</p> <pre data-language="python">In [476]: df = pd.DataFrame(np.random.randn(20, 3), columns=list('abc'))

In [477]: df.to_sql('data_chunks', engine, index=False)
</pre> <pre data-language="python">In [478]: for chunk in pd.read_sql_query("SELECT * FROM data_chunks", engine, chunksize=5):
   .....:     print(chunk)
   .....: 
          a         b         c
0  0.280665 -0.073113  1.160339
1  0.369493  1.904659  1.111057
2  0.659050 -1.627438  0.602319
3  0.420282  0.810952  1.044442
4 -0.400878  0.824006 -0.562305
          a         b         c
0  1.954878 -1.331952 -1.760689
1 -1.650721 -0.890556 -1.119115
2  1.956079 -0.326499 -1.342676
3  1.114383 -0.586524 -1.236853
4  0.875839  0.623362 -0.434957
          a         b         c
0  1.407540  0.129102  1.616950
1  0.502741  1.558806  0.109403
2 -1.219744  2.449369 -0.545774
3 -0.198838 -0.700399 -0.203394
4  0.242669  0.201830  0.661020
          a         b         c
0  1.792158 -0.120465 -1.233121
1 -1.182318 -0.665755 -1.674196
2  0.825030 -0.498214 -0.310985
3 -0.001891 -1.396620 -0.861316
4  0.674712  0.618539 -0.443172
</pre> <p>You can also run a plain query without creating a dataframe with <code>execute()</code>. This is useful for queries that don’t return values, such as INSERT. This is functionally equivalent to calling <code>execute</code> on the SQLAlchemy engine or db connection object. Again, you must use the SQL syntax variant appropriate for your database.</p> <pre data-language="python">from pandas.io import sql
sql.execute('SELECT * FROM table_name', engine)
sql.execute('INSERT INTO table_name VALUES(?, ?, ?)', engine, params=[('id', 1, 12.2, True)])
</pre>   <h3 id="engine-connection-examples">Engine connection examples</h3> <p>To connect with SQLAlchemy you use the <code>create_engine()</code> function to create an engine object from database URI. You only need to create the engine once per database you are connecting to.</p> <pre data-language="python">from sqlalchemy import create_engine

engine = create_engine('postgresql://scott:tiger@localhost:5432/mydatabase')

engine = create_engine('mysql+mysqldb://scott:tiger@localhost/foo')

engine = create_engine('oracle://scott:tiger@127.0.0.1:1521/sidname')

engine = create_engine('mssql+pyodbc://mydsn')

# sqlite://&lt;nohostname&gt;/&lt;path&gt;
# where &lt;path&gt; is relative:
engine = create_engine('sqlite:///foo.db')

# or absolute, starting with a slash:
engine = create_engine('sqlite:////absolute/path/to/foo.db')
</pre> <p>For more information see the examples the SQLAlchemy <a class="reference external" href="http://docs.sqlalchemy.org/en/latest/core/engines.html" target="_blank">documentation</a></p>   <h3 id="advanced-sqlalchemy-queries">Advanced SQLAlchemy queries</h3> <p>You can use SQLAlchemy constructs to describe your query.</p> <p>Use <code>sqlalchemy.text()</code> to specify query parameters in a backend-neutral way</p> <pre data-language="python">In [479]: import sqlalchemy as sa

In [480]: pd.read_sql(sa.text('SELECT * FROM data where Col_1=:col1'), engine, params={'col1': 'X'})
Out[480]: 
   index  id                        Date Col_1  Col_2  Col_3
0      0  26  2010-10-18 00:00:00.000000     X   27.5      1
</pre> <p>If you have an SQLAlchemy description of your database you can express where conditions using SQLAlchemy expressions</p> <pre data-language="python">In [481]: metadata = sa.MetaData()

In [482]: data_table = sa.Table('data', metadata,
   .....:     sa.Column('index', sa.Integer),
   .....:     sa.Column('Date', sa.DateTime),
   .....:     sa.Column('Col_1', sa.String),
   .....:     sa.Column('Col_2', sa.Float),
   .....:     sa.Column('Col_3', sa.Boolean),
   .....: )
   .....: 

In [483]: pd.read_sql(sa.select([data_table]).where(data_table.c.Col_3 == True), engine)
Out[483]: 
   index       Date Col_1  Col_2 Col_3
0      0 2010-10-18     X  27.50  True
1      2 2010-10-20     Z   5.73  True
</pre> <p>You can combine SQLAlchemy expressions with parameters passed to <a class="reference internal" href="../generated/pandas.read_sql/#pandas.read_sql" title="pandas.read_sql"><code>read_sql()</code></a> using <code>sqlalchemy.bindparam()</code></p> <pre data-language="python">In [484]: import datetime as dt

In [485]: expr = sa.select([data_table]).where(data_table.c.Date &gt; sa.bindparam('date'))

In [486]: pd.read_sql(expr, engine, params={'date': dt.datetime(2010, 10, 18)})
Out[486]: 
   index       Date Col_1  Col_2  Col_3
0      1 2010-10-19     Y -12.50  False
1      2 2010-10-20     Z   5.73   True
</pre>   <h3 id="sqlite-fallback">Sqlite fallback</h3> <p>The use of sqlite is supported without using SQLAlchemy. This mode requires a Python database adapter which respect the <a class="reference external" href="http://www.python.org/dev/peps/pep-0249/" target="_blank">Python DB-API</a>.</p> <p>You can create connections like so:</p> <pre data-language="python">import sqlite3
con = sqlite3.connect(':memory:')
</pre> <p>And then issue the following queries:</p> <pre data-language="python">data.to_sql('data', cnx)
pd.read_sql_query("SELECT * FROM data", con)
</pre>    <h2 id="io-bigquery">Google BigQuery (Experimental)</h2> <div class="versionadded" id="google-bigquery-experimental"> <p><span class="versionmodified">New in version 0.13.0.</span></p> </div> <p>The <code>pandas.io.gbq</code> module provides a wrapper for Google’s BigQuery analytics web service to simplify retrieving results from BigQuery tables using SQL-like queries. Result sets are parsed into a pandas DataFrame with a shape and data types derived from the source table. Additionally, DataFrames can be inserted into new BigQuery tables or appended to existing tables.</p> <p>You will need to install some additional dependencies:</p> <ul class="simple"> <li>Google’s <a class="reference external" href="https://github.com/google/python-gflags/" target="_blank">python-gflags</a>
</li> <li><a class="reference external" href="http://pypi.python.org/pypi/httplib2" target="_blank">httplib2</a></li> <li><a class="reference external" href="http://github.com/google/google-api-python-client" target="_blank">google-api-python-client</a></li> </ul> <div class="admonition warning"> <p class="first admonition-title">Warning</p> <p class="last">To use this module, you will need a valid BigQuery account. Refer to the <a class="reference external" href="https://cloud.google.com/bigquery/what-is-bigquery" target="_blank">BigQuery Documentation</a> for details on the service itself.</p> </div> <p>The key functions are:</p> <table class="longtable docutils">   <tr class="row-odd">
<td>
<a class="reference internal" href="../generated/pandas.io.gbq.read_gbq/#pandas.io.gbq.read_gbq" title="pandas.io.gbq.read_gbq"><code>read_gbq</code></a>(query[, project_id, index_col, ...])</td> <td>Load data from Google BigQuery.</td> </tr> <tr class="row-even">
<td>
<a class="reference internal" href="../generated/pandas.io.gbq.to_gbq/#pandas.io.gbq.to_gbq" title="pandas.io.gbq.to_gbq"><code>to_gbq</code></a>(dataframe, destination_table, project_id)</td> <td>Write a DataFrame to a Google BigQuery table.</td> </tr>  </table>  <h3 id="io-bigquery-reader">Authentication</h3> <div class="versionadded" id="authentication"> <p><span class="versionmodified">New in version 0.18.0.</span></p> </div> <p>Authentication to the Google <code>BigQuery</code> service is via <code>OAuth 2.0</code>. Is possible to authenticate with either user account credentials or service account credentials.</p> <p>Authenticating with user account credentials is as simple as following the prompts in a browser window which will be automatically opened for you. You will be authenticated to the specified <code>BigQuery</code> account using the product name <code>pandas GBQ</code>. It is only possible on local host. The remote authentication using user account credentials is not currently supported in Pandas. Additional information on the authentication mechanism can be found <a class="reference external" href="https://developers.google.com/identity/protocols/OAuth2#clientside/" target="_blank">here</a>.</p> <p>Authentication with service account credentials is possible via the <code>‘private_key’</code> parameter. This method is particularly useful when working on remote servers (eg. jupyter iPython notebook on remote host). Additional information on service accounts can be found <a class="reference external" href="https://developers.google.com/identity/protocols/OAuth2#serviceaccount" target="_blank">here</a>.</p> <p>You will need to install an additional dependency: <a class="reference external" href="https://github.com/google/oauth2client" target="_blank">oauth2client</a>.</p> <p>Authentication via <code>application default credentials</code> is also possible. This is only valid if the parameter <code>private_key</code> is not provided. This method also requires that the credentials can be fetched from the environment the code is running in. Otherwise, the OAuth2 client-side authentication is used. Additional information on <a class="reference external" href="https://developers.google.com/identity/protocols/application-default-credentials" target="_blank">application default credentials</a>.</p> <div class="versionadded"> <p><span class="versionmodified">New in version 0.19.0.</span></p> </div> <div class="admonition note"> <p class="first admonition-title">Note</p> <p class="last">The <code>‘private_key’</code> parameter can be set to either the file path of the service account key in JSON format, or key contents of the service account key in JSON format.</p> </div> <div class="admonition note"> <p class="first admonition-title">Note</p> <p class="last">A private key can be obtained from the Google developers console by clicking <a class="reference external" href="https://console.developers.google.com/permissions/serviceaccounts" target="_blank">here</a>. Use JSON key type.</p> </div>   <h3 id="id4">Querying</h3> <p>Suppose you want to load all data from an existing BigQuery table : <code>test_dataset.test_table</code> into a DataFrame using the <a class="reference internal" href="../generated/pandas.io.gbq.read_gbq/#pandas.io.gbq.read_gbq" title="pandas.io.gbq.read_gbq"><code>read_gbq()</code></a> function.</p> <pre data-language="python"># Insert your BigQuery Project ID Here
# Can be found in the Google web console
projectid = "xxxxxxxx"

data_frame = pd.read_gbq('SELECT * FROM test_dataset.test_table', projectid)
</pre> <p>You can define which column from BigQuery to use as an index in the destination DataFrame as well as a preferred column order as follows:</p> <pre data-language="python">data_frame = pd.read_gbq('SELECT * FROM test_dataset.test_table',
                          index_col='index_column_name',
                          col_order=['col1', 'col2', 'col3'], projectid)
</pre> <div class="admonition note"> <p class="first admonition-title">Note</p> <p class="last">You can find your project id in the <a class="reference external" href="https://console.developers.google.com" target="_blank">Google developers console</a>.</p> </div> <div class="admonition note"> <p class="first admonition-title">Note</p> <p class="last">You can toggle the verbose output via the <code>verbose</code> flag which defaults to <code>True</code>.</p> </div> <div class="admonition note"> <p class="first admonition-title">Note</p> <p class="last">The <code>dialect</code> argument can be used to indicate whether to use BigQuery’s <code>'legacy'</code> SQL or BigQuery’s <code>'standard'</code> SQL (beta). The default value is <code>'legacy'</code>. For more information on BigQuery’s standard SQL, see <a class="reference external" href="https://cloud.google.com/bigquery/sql-reference/" target="_blank">BigQuery SQL Reference</a></p> </div>   <h3 id="id5">Writing DataFrames</h3> <p id="io-bigquery-writer">Assume we want to write a DataFrame <code>df</code> into a BigQuery table using <a class="reference internal" href="../generated/pandas.dataframe.to_gbq/#pandas.DataFrame.to_gbq" title="pandas.DataFrame.to_gbq"><code>to_gbq()</code></a>.</p> <pre data-language="python">In [487]: df = pd.DataFrame({'my_string': list('abc'),
   .....:                    'my_int64': list(range(1, 4)),
   .....:                    'my_float64': np.arange(4.0, 7.0),
   .....:                    'my_bool1': [True, False, True],
   .....:                    'my_bool2': [False, True, False],
   .....:                    'my_dates': pd.date_range('now', periods=3)})
   .....: 

In [488]: df
Out[488]: 
  my_bool1 my_bool2                   my_dates  my_float64  my_int64 my_string
0     True    False 2016-12-24 18:33:33.411047         4.0         1         a
1    False     True 2016-12-25 18:33:33.411047         5.0         2         b
2     True    False 2016-12-26 18:33:33.411047         6.0         3         c

In [489]: df.dtypes
Out[489]: 
my_bool1                bool
my_bool2                bool
my_dates      datetime64[ns]
my_float64           float64
my_int64               int64
my_string             object
dtype: object
</pre> <pre data-language="python">df.to_gbq('my_dataset.my_table', projectid)
</pre> <div class="admonition note"> <p class="first admonition-title">Note</p> <p class="last">The destination table and destination dataset will automatically be created if they do not already exist.</p> </div> <p>The <code>if_exists</code> argument can be used to dictate whether to <code>'fail'</code>, <code>'replace'</code> or <code>'append'</code> if the destination table already exists. The default value is <code>'fail'</code>.</p> <p>For example, assume that <code>if_exists</code> is set to <code>'fail'</code>. The following snippet will raise a <code>TableCreationError</code> if the destination table already exists.</p> <pre data-language="python">df.to_gbq('my_dataset.my_table', projectid, if_exists='fail')
</pre> <div class="admonition note"> <p class="first admonition-title">Note</p> <p class="last">If the <code>if_exists</code> argument is set to <code>'append'</code>, the destination dataframe will be written to the table using the defined table schema and column types. The dataframe must match the destination table in structure and data types. If the <code>if_exists</code> argument is set to <code>'replace'</code>, and the existing table has a different schema, a delay of 2 minutes will be forced to ensure that the new schema has propagated in the Google environment. See <a class="reference external" href="https://code.google.com/p/google-bigquery/issues/detail?id=191" target="_blank">Google BigQuery issue 191</a>.</p> </div> <p>Writing large DataFrames can result in errors due to size limitations being exceeded. This can be avoided by setting the <code>chunksize</code> argument when calling <a class="reference internal" href="../generated/pandas.dataframe.to_gbq/#pandas.DataFrame.to_gbq" title="pandas.DataFrame.to_gbq"><code>to_gbq()</code></a>. For example, the following writes <code>df</code> to a BigQuery table in batches of 10000 rows at a time:</p> <pre data-language="python">df.to_gbq('my_dataset.my_table', projectid, chunksize=10000)
</pre> <p>You can also see the progress of your post via the <code>verbose</code> flag which defaults to <code>True</code>. For example:</p> <pre data-language="python">In [8]: df.to_gbq('my_dataset.my_table', projectid, chunksize=10000, verbose=True)

        Streaming Insert is 10% Complete
        Streaming Insert is 20% Complete
        Streaming Insert is 30% Complete
        Streaming Insert is 40% Complete
        Streaming Insert is 50% Complete
        Streaming Insert is 60% Complete
        Streaming Insert is 70% Complete
        Streaming Insert is 80% Complete
        Streaming Insert is 90% Complete
        Streaming Insert is 100% Complete
</pre> <div class="admonition note"> <p class="first admonition-title">Note</p> <p class="last">If an error occurs while streaming data to BigQuery, see <a class="reference external" href="https://cloud.google.com/bigquery/troubleshooting-errors" target="_blank">Troubleshooting BigQuery Errors</a>.</p> </div> <div class="admonition note"> <p class="first admonition-title">Note</p> <p class="last">The BigQuery SQL query language has some oddities, see the <a class="reference external" href="https://cloud.google.com/bigquery/query-reference" target="_blank">BigQuery Query Reference Documentation</a>.</p> </div> <div class="admonition note"> <p class="first admonition-title">Note</p> <p class="last">While BigQuery uses SQL-like syntax, it has some important differences from traditional databases both in functionality, API limitations (size and quantity of queries or uploads), and how Google charges for use of the service. You should refer to <a class="reference external" href="https://cloud.google.com/bigquery/what-is-bigquery" target="_blank">Google BigQuery documentation</a> often as the service seems to be changing and evolving. BiqQuery is best for analyzing large sets of data quickly, but it is not a direct replacement for a transactional database.</p> </div>   <h3 id="creating-bigquery-tables">Creating BigQuery Tables</h3> <div class="admonition warning"> <p class="first admonition-title">Warning</p> <p class="last">As of 0.17, the function <code>generate_bq_schema()</code> has been deprecated and will be removed in a future version.</p> </div> <p>As of 0.15.2, the gbq module has a function <code>generate_bq_schema()</code> which will produce the dictionary representation schema of the specified pandas DataFrame.</p> <pre data-language="python">In [10]: gbq.generate_bq_schema(df, default_type='STRING')

Out[10]: {'fields': [{'name': 'my_bool1', 'type': 'BOOLEAN'},
         {'name': 'my_bool2', 'type': 'BOOLEAN'},
         {'name': 'my_dates', 'type': 'TIMESTAMP'},
         {'name': 'my_float64', 'type': 'FLOAT'},
         {'name': 'my_int64', 'type': 'INTEGER'},
         {'name': 'my_string', 'type': 'STRING'}]}
</pre> <div class="admonition note"> <p class="first admonition-title">Note</p> <p class="last">If you delete and re-create a BigQuery table with the same name, but different table schema, you must wait 2 minutes before streaming data into the table. As a workaround, consider creating the new table with a different name. Refer to <a class="reference external" href="https://code.google.com/p/google-bigquery/issues/detail?id=191" target="_blank">Google BigQuery issue 191</a>.</p> </div>    <h2 id="io-stata">Stata Format</h2> <div class="versionadded" id="stata-format"> <p><span class="versionmodified">New in version 0.12.0.</span></p> </div>  <h3 id="io-stata-writer">Writing to Stata format</h3> <p id="writing-to-stata-format">The method <code>to_stata()</code> will write a DataFrame into a .dta file. The format version of this file is always 115 (Stata 12).</p> <pre data-language="python">In [490]: df = pd.DataFrame(randn(10, 2), columns=list('AB'))

In [491]: df.to_stata('stata.dta')
</pre> <p><em>Stata</em> data files have limited data type support; only strings with 244 or fewer characters, <code>int8</code>, <code>int16</code>, <code>int32</code>, <code>float32</code> and <code>float64</code> can be stored in <code>.dta</code> files. Additionally, <em>Stata</em> reserves certain values to represent missing data. Exporting a non-missing value that is outside of the permitted range in Stata for a particular data type will retype the variable to the next larger size. For example, <code>int8</code> values are restricted to lie between -127 and 100 in Stata, and so variables with values above 100 will trigger a conversion to <code>int16</code>. <code>nan</code> values in floating points data types are stored as the basic missing data type (<code>.</code> in <em>Stata</em>).</p> <div class="admonition note"> <p class="first admonition-title">Note</p> <p class="last">It is not possible to export missing data values for integer data types.</p> </div> <p>The <em>Stata</em> writer gracefully handles other data types including <code>int64</code>, <code>bool</code>, <code>uint8</code>, <code>uint16</code>, <code>uint32</code> by casting to the smallest supported type that can represent the data. For example, data with a type of <code>uint8</code> will be cast to <code>int8</code> if all values are less than 100 (the upper bound for non-missing <code>int8</code> data in <em>Stata</em>), or, if values are outside of this range, the variable is cast to <code>int16</code>.</p> <div class="admonition warning"> <p class="first admonition-title">Warning</p> <p class="last">Conversion from <code>int64</code> to <code>float64</code> may result in a loss of precision if <code>int64</code> values are larger than 2**53.</p> </div> <div class="admonition warning"> <p class="first admonition-title">Warning</p> <p class="last"><code>StataWriter</code> and <code>to_stata()</code> only support fixed width strings containing up to 244 characters, a limitation imposed by the version 115 dta file format. Attempting to write <em>Stata</em> dta files with strings longer than 244 characters raises a <code>ValueError</code>.</p> </div>   <h3 id="io-stata-reader">Reading from Stata format</h3> <p id="reading-from-stata-format">The top-level function <code>read_stata</code> will read a dta file and return either a DataFrame or a <code>StataReader</code> that can be used to read the file incrementally.</p> <pre data-language="python">In [492]: pd.read_stata('stata.dta')
Out[492]: 
   index         A         B
0      0  1.810535 -1.305727
1      1 -0.344987 -0.230840
2      2 -2.793085  1.937529
3      3  0.366332 -1.044589
4      4  2.051173  0.585662
5      5  0.429526 -0.606998
6      6  0.106223 -1.525680
7      7  0.795026 -0.374438
8      8  0.134048  1.202055
9      9  0.284748  0.262467
</pre> <div class="versionadded"> <p><span class="versionmodified">New in version 0.16.0.</span></p> </div> <p>Specifying a <code>chunksize</code> yields a <code>StataReader</code> instance that can be used to read <code>chunksize</code> lines from the file at a time. The <code>StataReader</code> object can be used as an iterator.</p> <pre data-language="python">In [493]: reader = pd.read_stata('stata.dta', chunksize=3)

In [494]: for df in reader:
   .....:     print(df.shape)
   .....: 
(3, 3)
(3, 3)
(3, 3)
(1, 3)
</pre> <p>For more fine-grained control, use <code>iterator=True</code> and specify <code>chunksize</code> with each call to <code>read()</code>.</p> <pre data-language="python">In [495]: reader = pd.read_stata('stata.dta', iterator=True)

In [496]: chunk1 = reader.read(5)

In [497]: chunk2 = reader.read(5)
</pre> <p>Currently the <code>index</code> is retrieved as a column.</p> <p>The parameter <code>convert_categoricals</code> indicates whether value labels should be read and used to create a <code>Categorical</code> variable from them. Value labels can also be retrieved by the function <code>value_labels</code>, which requires <code>read()</code> to be called before use.</p> <p>The parameter <code>convert_missing</code> indicates whether missing value representations in Stata should be preserved. If <code>False</code> (the default), missing values are represented as <code>np.nan</code>. If <code>True</code>, missing values are represented using <code>StataMissingValue</code> objects, and columns containing missing values will have <code>object</code> data type.</p> <div class="admonition note"> <p class="first admonition-title">Note</p> <p class="last"><a class="reference internal" href="../generated/pandas.read_stata/#pandas.read_stata" title="pandas.read_stata"><code>read_stata()</code></a> and <code>StataReader</code> support .dta formats 113-115 (Stata 10-12), 117 (Stata 13), and 118 (Stata 14).</p> </div> <div class="admonition note"> <p class="first admonition-title">Note</p> <p class="last">Setting <code>preserve_dtypes=False</code> will upcast to the standard pandas data types: <code>int64</code> for all integer types and <code>float64</code> for floating point data. By default, the Stata data types are preserved when importing.</p> </div>  <h4 id="id6">Categorical Data</h4> <div class="versionadded" id="io-stata-categorical"> <p><span class="versionmodified">New in version 0.15.2.</span></p> </div> <p><code>Categorical</code> data can be exported to <em>Stata</em> data files as value labeled data. The exported data consists of the underlying category codes as integer data values and the categories as value labels. <em>Stata</em> does not have an explicit equivalent to a <code>Categorical</code> and information about <em>whether</em> the variable is ordered is lost when exporting.</p> <div class="admonition warning"> <p class="first admonition-title">Warning</p> <p class="last"><em>Stata</em> only supports string value labels, and so <code>str</code> is called on the categories when exporting data. Exporting <code>Categorical</code> variables with non-string categories produces a warning, and can result a loss of information if the <code>str</code> representations of the categories are not unique.</p> </div> <p>Labeled data can similarly be imported from <em>Stata</em> data files as <code>Categorical</code> variables using the keyword argument <code>convert_categoricals</code> (<code>True</code> by default). The keyword argument <code>order_categoricals</code> (<code>True</code> by default) determines whether imported <code>Categorical</code> variables are ordered.</p> <div class="admonition note"> <p class="first admonition-title">Note</p> <p class="last">When importing categorical data, the values of the variables in the <em>Stata</em> data file are not preserved since <code>Categorical</code> variables always use integer data types between <code>-1</code> and <code>n-1</code> where <code>n</code> is the number of categories. If the original values in the <em>Stata</em> data file are required, these can be imported by setting <code>convert_categoricals=False</code>, which will import original data (but not the variable labels). The original values can be matched to the imported categorical data since there is a simple mapping between the original <em>Stata</em> data values and the category codes of imported Categorical variables: missing values are assigned code <code>-1</code>, and the smallest original value is assigned <code>0</code>, the second smallest is assigned <code>1</code> and so on until the largest original value is assigned the code <code>n-1</code>.</p> </div> <div class="admonition note"> <p class="first admonition-title">Note</p> <p class="last"><em>Stata</em> supports partially labeled series. These series have value labels for some but not all data values. Importing a partially labeled series will produce a <code>Categorical</code> with string categories for the values that are labeled and numeric categories for values with no label.</p> </div>     <h2 id="io-sas">SAS Formats</h2> <div class="versionadded" id="sas-formats"> <p><span class="versionmodified">New in version 0.17.0.</span></p> </div> <p>The top-level function <a class="reference internal" href="../generated/pandas.read_sas/#pandas.read_sas" title="pandas.read_sas"><code>read_sas()</code></a> can read (but not write) SAS <code>xport</code> (.XPT) and <code>SAS7BDAT</code> (.sas7bdat) format files were added in <em>v0.18.0</em>.</p> <p>SAS files only contain two value types: ASCII text and floating point values (usually 8 bytes but sometimes truncated). For xport files, there is no automatic type conversion to integers, dates, or categoricals. For SAS7BDAT files, the format codes may allow date variables to be automatically converted to dates. By default the whole file is read and returned as a <code>DataFrame</code>.</p> <p>Specify a <code>chunksize</code> or use <code>iterator=True</code> to obtain reader objects (<code>XportReader</code> or <code>SAS7BDATReader</code>) for incrementally reading the file. The reader objects also have attributes that contain additional information about the file and its variables.</p> <p>Read a SAS7BDAT file:</p> <pre data-language="python">df = pd.read_sas('sas_data.sas7bdat')
</pre> <p>Obtain an iterator and read an XPORT file 100,000 lines at a time:</p> <pre data-language="python">rdr = pd.read_sas('sas_xport.xpt', chunk=100000)
for chunk in rdr:
    do_something(chunk)
</pre> <p>The <a class="reference external" href="https://support.sas.com/techsup/technote/ts140.pdf" target="_blank">specification</a> for the xport file format is available from the SAS web site.</p> <p>No official documentation is available for the SAS7BDAT format.</p>   <h2 id="io-other">Other file formats</h2> <p id="other-file-formats">pandas itself only supports IO with a limited set of file formats that map cleanly to its tabular data model. For reading and writing other file formats into and from pandas, we recommend these packages from the broader community.</p>  <h3 id="netcdf">netCDF</h3> <p><a class="reference external" href="http://xarray.pydata.org/" target="_blank">xarray</a> provides data structures inspired by the pandas DataFrame for working with multi-dimensional datasets, with a focus on the netCDF file format and easy conversion to and from pandas.</p>    <h2 id="io-perf">Performance Considerations</h2> <p id="performance-considerations">This is an informal comparison of various IO methods, using pandas 0.13.1.</p> <pre data-language="python">In [1]: df = pd.DataFrame(randn(1000000,2),columns=list('AB'))

In [2]: df.info()
&lt;class 'pandas.core.frame.DataFrame'&gt;
Int64Index: 1000000 entries, 0 to 999999
Data columns (total 2 columns):
A    1000000 non-null float64
B    1000000 non-null float64
dtypes: float64(2)
memory usage: 22.9 MB
</pre> <p>Writing</p> <pre data-language="python">In [14]: %timeit test_sql_write(df)
1 loops, best of 3: 6.24 s per loop

In [15]: %timeit test_hdf_fixed_write(df)
1 loops, best of 3: 237 ms per loop

In [26]: %timeit test_hdf_fixed_write_compress(df)
1 loops, best of 3: 245 ms per loop

In [16]: %timeit test_hdf_table_write(df)
1 loops, best of 3: 901 ms per loop

In [27]: %timeit test_hdf_table_write_compress(df)
1 loops, best of 3: 952 ms per loop

In [17]: %timeit test_csv_write(df)
1 loops, best of 3: 3.44 s per loop
</pre> <p>Reading</p> <pre data-language="python">In [18]: %timeit test_sql_read()
1 loops, best of 3: 766 ms per loop

In [19]: %timeit test_hdf_fixed_read()
10 loops, best of 3: 19.1 ms per loop

In [28]: %timeit test_hdf_fixed_read_compress()
10 loops, best of 3: 36.3 ms per loop

In [20]: %timeit test_hdf_table_read()
10 loops, best of 3: 39 ms per loop

In [29]: %timeit test_hdf_table_read_compress()
10 loops, best of 3: 60.6 ms per loop

In [22]: %timeit test_csv_read()
1 loops, best of 3: 620 ms per loop
</pre> <p>Space on disk (in bytes)</p> <pre data-language="none">25843712 Apr  8 14:11 test.sql
24007368 Apr  8 14:11 test_fixed.hdf
15580682 Apr  8 14:11 test_fixed_compress.hdf
24458444 Apr  8 14:11 test_table.hdf
16797283 Apr  8 14:11 test_table_compress.hdf
46152810 Apr  8 14:11 test.csv
</pre> <p>And here’s the code</p> <pre data-language="python">import sqlite3
import os
from pandas.io import sql

df = pd.DataFrame(randn(1000000,2),columns=list('AB'))

def test_sql_write(df):
    if os.path.exists('test.sql'):
        os.remove('test.sql')
    sql_db = sqlite3.connect('test.sql')
    df.to_sql(name='test_table', con=sql_db)
    sql_db.close()

def test_sql_read():
    sql_db = sqlite3.connect('test.sql')
    pd.read_sql_query("select * from test_table", sql_db)
    sql_db.close()

def test_hdf_fixed_write(df):
    df.to_hdf('test_fixed.hdf','test',mode='w')

def test_hdf_fixed_read():
    pd.read_hdf('test_fixed.hdf','test')

def test_hdf_fixed_write_compress(df):
    df.to_hdf('test_fixed_compress.hdf','test',mode='w',complib='blosc')

def test_hdf_fixed_read_compress():
    pd.read_hdf('test_fixed_compress.hdf','test')

def test_hdf_table_write(df):
    df.to_hdf('test_table.hdf','test',mode='w',format='table')

def test_hdf_table_read():
    pd.read_hdf('test_table.hdf','test')

def test_hdf_table_write_compress(df):
    df.to_hdf('test_table_compress.hdf','test',mode='w',complib='blosc',format='table')

def test_hdf_table_read_compress():
    pd.read_hdf('test_table_compress.hdf','test')

def test_csv_write(df):
    df.to_csv('test.csv',mode='w')

def test_csv_read():
    pd.read_csv('test.csv',index_col=0)
</pre>
<div class="_attribution">
  <p class="_attribution-p">
    © 2011–2012 Lambda Foundry, Inc. and PyData Development Team<br>© 2008–2011 AQR Capital Management, LLC<br>© 2008–2014 the pandas development team<br>Licensed under the 3-clause BSD License.<br>
    <a href="http://pandas.pydata.org/pandas-docs/version/0.19.2/io.html" class="_attribution-link" target="_blank">http://pandas.pydata.org/pandas-docs/version/0.19.2/io.html</a>
  </p>
</div>

			</div>
		</div>
	</section>

	</div>
</body>
</html>
