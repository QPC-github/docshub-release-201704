
<!DOCTYPE HTML>

<html lang="en">

<head>
  <meta charset="utf-8">
  <title>Selections - D3.js 3 - W3cubDocs</title>
  
  <meta name="description" content=" API Reference ▸ Core ▸ Selections ">
  <meta name="keywords" content="selections, -, d, js, d3~3">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="http://docs.w3cub.com/d3~3/selections.md/">
  <link href="/favicon.png" rel="icon">
  <link type="text/css" rel="stylesheet" href="/assets/application-50364fff564ce3b6327021805f3f00e2957b441cf27f576a7dd4ff63bbc47047.css">
  <script type="text/javascript" src="/assets/application-db64bfd54ceb42be11af7995804cf4902548419ceb79d509b0b7d62c22d98e6f.js"></script>
  <script src="/json/d3~3.js"></script>
  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-71174418-1']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>


</head>

<body>
	<div class="_app">
	<header class="_header">
  
  <form class="_search">
    <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
    <a class="_search-clear"></a>
    <div class="_search-tag"></div>
  </form>
  
  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/d3~3/" class="_nav-link" title="" style="margin-left:0;">D3.js 3</a></span>
  
  <nav class="_nav">
    <a href="/app/" class="_nav-link ">App</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		<div class="_list">
			
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<div class="_page _d3">
				
<h1>Selections</h1>
<blockquote> <p><a href="../">API Reference</a> ▸ <a href="../core.md/">Core</a> ▸ <strong>Selections</strong></p> </blockquote>  <p>A <strong>selection</strong> is an array of elements pulled from the current document. D3 uses <a href="http://www.w3.org/TR/css3-selectors/" title="|http://www.w3.org/TR/css3-selectors/" target="_blank">CSS3</a> to select elements. For example, you can select by tag ("div"), class (".awesome"), unique identifier ("#foo"), attribute ("[color=red]"), or containment ("parent child"). Selectors can also be intersected (".this.that" for logical AND) or unioned (".this, .that" for logical OR). If your browser doesn't support selectors natively, you can include <a href="http://sizzlejs.com/" title="http://sizzlejs.com/" target="_blank">Sizzle</a> before D3 for backwards-compatibility.</p> <p>After selecting elements, you apply <strong>operators</strong> to them to do stuff. These operators can get or set <a href="../selections.md/#attr">attributes</a>, <a href="../selections.md/#style">styles</a>, <a href="../selections.md/#property">properties</a>, <a href="../selections.md/#html">HTML</a> and <a href="../selections.md/#text">text</a> content. Attribute values and such are specified as either constants or functions; the latter are evaluated for each element. You can also join selections to <a href="../selections.md/#data">data</a>; this data is available to operators for data-driven transformations. In addition, joining to data produces <a href="../selections.md/#enter">enter</a> and <a href="../selections.md/#enter">exit</a> subselections, so that you may <a href="../selections.md/#append">add</a> or <a href="../selections.md/#remove">remove</a> elements in response to changes in data.</p> <p>You won't generally need to use <code>for</code> loops or recursive functions to modify the document with D3. That's because you operate on entire selections at once, rather than looping over individual elements. However, you can still loop over elements manually if you wish: there's an <a href="../selections.md/#each">each</a> operator which invokes an arbitrary function, and selections are arrays, so elements can be accessed directly (e.g., <code>selection[0][0]</code>). D3 supports method chaining for brevity when applying multiple operators: the operator return value is the selection.</p> <h2 id="selecting-elements">
Selecting Elements</h2> <p>D3 provides two top-level methods for selecting elements: <a href="../selections.md/#d3_select">select</a> and <a href="../selections.md/#d3_selectAll">selectAll</a>. These methods accept selector strings; the former selects only the first matching element, while the latter selects <em>all</em> matching elements in document traversal order. These methods can also accept nodes, which is useful for integration with third-party libraries such as jQuery or developer tools (<code>$0</code>).</p> <h6 id="d3_select"> d3.<b>select</b>(<i>selector</i>)</h6> <p>Selects the first element that matches the specified selector string, returning a single-element selection. If no elements in the current document match the specified selector, returns the empty selection. If multiple elements match the selector, only the first matching element (in document traversal order) will be selected.</p> <h6 id="d3_select"> d3.<b>select</b>(<i>node</i>)</h6> <p>Selects the specified node. This is useful if you already have a reference to a node, such as <code>d3.select(this)</code> within an event listener, or a global such as <code>document.body</code>. This function does not traverse the DOM.</p> <h6 id="d3_selectAll"> d3.<b>selectAll</b>(<i>selector</i>)</h6> <p>Selects all elements that match the specified selector. The elements will be selected in document traversal order (top-to-bottom). If no elements in the current document match the specified selector, returns the empty selection.</p> <h6 id="d3_selectAll"> d3.<b>selectAll</b>(<i>nodes</i>)</h6> <p>Selects the specified array of elements. This is useful if you already have a reference to nodes, such as <code>d3.selectAll(this.childNodes)</code> within an event listener, or a global such as <code>document.links</code>. The <em>nodes</em> argument doesn't have to be an array, exactly; any pseudo-array that can be coerced into an array (e.g., a <code>NodeList</code> or <code>arguments</code>) will work. This function does not traverse the DOM.</p> <h2 id="operating-on-selections">
Operating on Selections</h2> <p>Selections are arrays of elements—literally (<a href="http://bost.ocks.org/mike/selection/#subclass" title="http://bost.ocks.org/mike/selection/#subclass" target="_blank">maybe not literally...</a>). D3 binds additional methods to the array so that you can apply operators to the selected elements, such as setting an attribute on all the selected elements. One nuance is that selections are <em>grouped</em>: rather than a one-dimensional array, each selection is an <em>array of arrays</em> of elements. This preserves the hierarchical structure of subselections. Most of the time, you can ignore this detail, but that's why a single-element selection looks like <code>[�[node]�]</code> rather than <code>[node]</code>. For more on nested selections, see <a href="http://bost.ocks.org/mike/nest/" title="http://bost.ocks.org/mike/nest/" target="_blank">Nested Selections</a>.</p> <p>If you want to learn how selections work, try selecting elements interactively using your browser's developer console. You can inspect the returned array to see which elements were selected, and how they are grouped. You can also then apply operators to the selected elements and see how the page content changes.</p> <h3 id="content">
Content</h3> <p>D3 has a variety of operators which affect the document content. These are what you'll use the most to display data! When used to set document content, the operators return the current selection, so you can chain multiple operators together in a concise statement.</p> <h6 id="attr"> selection.<b>attr</b>(<i>name</i>[, <i>value</i>])</h6> <p>If <em>value</em> is specified, sets the attribute with the specified name to the specified value on all selected elements. If <em>value</em> is a constant, then all elements are given the same attribute value; otherwise, if <em>value</em> is a function, then the function is evaluated for each selected element (in order), being passed the current datum <code>d</code> and the current index <code>i</code>, with the <code>this</code> context as the current DOM element. The function's return value is then used to set each element's attribute. A null value will remove the specified attribute.</p> <p>If <em>value</em> is not specified, returns the value of the specified attribute for the first non-null element in the selection. This is generally useful only if you know that the selection contains exactly one element.</p> <p>The specified <em>name</em> may have a namespace prefix, such as <code>xlink:href</code>, to specify an "href" attribute in the XLink namespace. By default, D3 supports svg, xhtml, xlink, xml, and xmlns namespaces. Additional namespaces can be registered by adding them to <a href="../namespaces.md/#prefix">d3.ns.prefix</a> using dot notation.</p> <p><em>name</em> can also be an Object of <em>name</em> and <em>value</em> attributes.</p> <h6 id="classed"> selection.<b>classed</b>(<i>name</i>[, <i>value</i>])</h6> <p>This operator is a convenience routine for setting the "class" attribute; it understands that the "class" attribute is a set of tokens separated by spaces. Under the hood, it will use the <a href="https://developer.mozilla.org/en/DOM/element.classList" title="https://developer.mozilla.org/en/DOM/element.classList" target="_blank">classList</a> if available, for convenient adding, removing and toggling of CSS classes.</p> <p>If <em>value</em> is specified, sets whether or not the specified class is associated with the selected elements. If <em>value</em> is a constant and truthy, then all elements are assigned the specified class, if not already assigned; if falsey, then the class is removed from all selected elements, if assigned. If <em>value</em> is a function, then the function is evaluated for each selected element (in order), being passed the current datum <code>d</code> and the current index <code>i</code>, with the <code>this</code> context as the current DOM element. The function's return value is then used to assign or unassign the specified class on each element.</p> <p>If you want to set several classes at once, use an object literal like so: <code>selection.classed({'foo': true, 'bar': false})</code>, or use a space-separated list of class names like so: <code>selection.classed('foo bar', true)</code>.</p> <p>If <em>value</em> is not specified, returns true if and only if the first non-null element in this selection has the specified class. This is generally useful only if you know the selection contains exactly one element.</p> <h6 id="style"> selection.<b>style</b>(<i>name</i>[, <i>value</i>[, <i>priority</i>]])</h6> <p>If <em>value</em> is specified, sets the CSS style property with the specified name to the specified value on all selected elements. If <em>value</em> is a constant, then all elements are given the same style value; otherwise, if <em>value</em> is a function, then the function is evaluated for each selected element (in order), being passed the current datum <code>d</code> and the current index <code>i</code>, with the <code>this</code> context as the current DOM element. The function's return value is then used to set each element's style property. A null value will remove the style property. An optional <em>priority</em> may also be specified, either as null or the string "important" (without the exclamation point).</p> <p>If you want to set several style properties at once, use an object literal. For example:</p> <pre data-language="javascript">selection.style({stroke: "black", "stroke-width": "2px"});</pre> <p>Note that CSS styles typically have associated units. For example, <code>"3px"</code> is a valid stroke-width property value, while <code>3</code> is not. Although some browsers implicitly assign the "px" (pixel) unit to numeric values, not all browsers do: IE, for example, throws an “invalid arguments” error and stops executing!</p> <p>If <em>value</em> is not specified, returns the current <em>computed</em> value of the specified style property for the first non-null element in the selection. This is generally useful only if you know the selection contains exactly one element. Note that the computed value may be <em>different</em> than the value that was previously set, particularly if the style property was set using a shorthand property (such as the "font" style, which is shorthand for "font-size", "font-face", etc.).</p> <h6 id="property"> selection.<b>property</b>(<i>name</i>[, <i>value</i>])</h6> <p>Some HTML elements have special properties that are not addressable using standard attributes or styles. For example, form text fields have a <code>value</code> string property, and checkboxes have a <code>checked</code> boolean property. You can use the <code>property</code> operator to get or set these properties, or any other addressable field on the underlying element, such as <code>className</code>.</p> <p>If <em>value</em> is specified, sets the property with the specified name to the specified value on all selected elements. If <em>value</em> is a constant, then all elements are given the same property value; otherwise, if <em>value</em> is a function, then the function is evaluated for each selected element (in order), being passed the current datum <code>d</code> and the current index <code>i</code>, with the <code>this</code> context as the current DOM element. The function's return value is then used to set each element's property. A null value will delete the specified property.</p> <p>If you want to set several properties at once, use an object literal like so: <code>selection.property({'foo': 'bar', 'baz': 'qux'})</code>.</p> <p>If <em>value</em> is not specified, returns the value of the specified property for the first non-null element in the selection. This is generally useful only if you know the selection contains exactly one element.</p> <h6 id="text"> selection.<b>text</b>([<i>value</i>])</h6> <p>The <code>text</code> operator is based on the <a href="http://www.w3.org/TR/DOM-Level-3-Core/core.html#Node3-textContent" title="http://www.w3.org/TR/DOM-Level-3-Core/core.html#Node3-textContent" target="_blank">textContent</a> property; setting the text content will replace any existing child elements.</p> <p>If <em>value</em> is specified, sets the text content to the specified value on all selected elements. If <em>value</em> is a constant, then all elements are given the same text content; otherwise, if <em>value</em> is a function, then the function is evaluated for each selected element (in order), being passed the current datum <code>d</code> and the current index <code>i</code>, with the <code>this</code> context as the current DOM element. The function's return value is then used to set each element's text content. A null value will clear the content.</p> <p>If <em>value</em> is not specified, returns the text content for the first non-null element in the selection. This is generally useful only if you know the selection contains exactly one element.</p> <h6 id="html"> selection.<b>html</b>([<i>value</i>])</h6> <p>The <code>html</code> operator is based on the <a href="http://dev.w3.org/html5/spec-LC/apis-in-html-documents.html#innerhtml" title="http://dev.w3.org/html5/spec-LC/apis-in-html-documents.html#innerhtml" target="_blank">innerHTML</a> property; setting the inner HTML content will replace any existing child elements. Also, you may prefer to use the <code>append</code> or <code>insert</code> operators to create HTML content in a data-driven way; this operator is intended for when you want a little bit of HTML, say for rich formatting.</p> <p>If <em>value</em> is specified, sets the inner HTML content to the specified value on all selected elements. If <em>value</em> is a constant, then all elements are given the same inner HTML content; otherwise, if <em>value</em> is a function, then the function is evaluated for each selected element (in order), being passed the current datum <code>d</code> and the current index <code>i</code>, with the <code>this</code> context as the current DOM element. The function's return value is then used to set each element's inner HTML content. A null value will clear the content.</p> <p>If <em>value</em> is not specified, returns the inner HTML content for the first non-null element in the selection. This is generally useful only if you know the selection contains exactly one element.</p> <p>Note: as its name suggests, selection.html is only supported on HTML elements. SVG elements and other non-HTML elements do not support the innerHTML property, and thus are incompatible with selection.html. Consider using <a href="https://developer.mozilla.org/en-US/docs/XMLSerializer" target="_blank">XMLSerializer</a> to convert a DOM subtree to text. See also the <a href="https://code.google.com/p/innersvg/" target="_blank">innersvg polyfill</a>, which provides a shim to support the innerHTML property on SVG elements.</p> <h6 id="append"> selection.<b>append</b>(<i>name</i>)</h6> <p>Appends a new element with the specified <em>name</em> as the last child of each element in the current selection, returning a new selection containing the appended elements. Each new element inherits the data of the current elements, if any, in the same manner as <a href="../selections.md/#select">select</a> for subselections.</p> <p>The <em>name</em> may be specified either as a constant string or as a function that returns the DOM element to append. If <em>name</em> is a function, it is passed the current datum <code>d</code> and the current index <code>i</code>, with the <code>this</code> context as the current DOM element. To append an arbitrary element based on the bound data it must be created in the function. For example:</p> <pre data-language="javascript">selection.enter().append(function(d) {
    return document.createElementNS("http://www.w3.org/2000/svg", d.type)
})</pre> <p>When the <em>name</em> is specified as a string, it may have a namespace prefix of the form "namespace:tag". For example, "svg:text" will create a "text" element in the SVG namespace. By default, D3 supports svg, xhtml, xlink, xml and xmlns namespaces. Additional namespaces can be registered by adding to <a href="../namespaces.md/#prefix">d3.ns.prefix</a>. If no namespace is specified, then the namespace will be inherited from the enclosing element; or, if the name is one of the known prefixes, the corresponding namespace will be used (for example, "svg" implies "svg:svg").</p> <h6 id="insert"> selection.<b>insert</b>(<i>name</i>[, <i>before</i>])</h6> <p>Inserts a new element with the specified <em>name</em> before the element matching the specified <em>before</em> selector, for each element in the current selection, returning a new selection containing the inserted elements. If the before selector does not match any elements, then the new element will be the last child as with <a href="../selections.md/#append">append</a>. Each new element inherits the data of the current elements (if any), in the same manner as <a href="../selections.md/#select">select</a> for subselections.</p> <p>The <em>name</em> may be specified either as a constant string or as a function that returns the DOM element to append. When the <em>name</em> is specified as a string, it may have a namespace prefix of the form "namespace:tag". For example, "svg:text" will create a "text" element in the SVG namespace. By default, D3 supports svg, xhtml, xlink, xml and xmlns namespaces. Additional namespaces can be registered by adding to <a href="../namespaces.md/#prefix">d3.ns.prefix</a>. If no namespace is specified, then the namespace will be inherited from the enclosing element; or, if the name is one of the known prefixes, the corresponding namespace will be used (for example, "svg" implies "svg:svg").</p> <p>Likewise, the <em>before</em> selector may be specified as a selector string or a function which returns a DOM element. For instance, <code>insert("div", ":first-child")</code> will prepend child div nodes to the current selection. For <a href="../selections.md/#enter">enter selections</a>, the <em>before</em> selector may be omitted, in which case entering elements will be inserted immediately before the next following sibling in the update selection, if any. This allows you to insert elements into the DOM in an order consistent with bound data. Note, however, the slower <a href="../selections.md/#order">selection.order</a> may still be required if updating elements change order.</p> <h6 id="remove"> selection.<b>remove</b>()</h6> <p>Removes the elements in the current selection from the current document. Returns the current selection (the same elements that were removed) which are now “off-screen”, detached from the DOM. Note that there is not currently a dedicated API to add removed elements back to the document; however, you can pass a function to selection.append or selection.insert to re-add elements.</p> <h3 id="data">
Data</h3> <h6 id="data"> selection.<b>data</b>([<i>values</i>[, <i>key</i>]])</h6> <p>Joins the specified array of data with the current selection. The specified <em>values</em> is an array of data values (e.g. numbers or objects), or a function that returns an array of values. If a <em>key</em> function is not specified, then the first datum in <em>values</em> is assigned to the first element in the current selection, the second datum to the second selected element, and so on. When data is assigned to an element, it is stored in the property <code>__data__</code> (defined by D3), thus making the data "sticky" so that it is available on re-selection.</p> <p>The result of the <code>data</code> method is the <em>update</em> selection; this represents the selected DOM elements that were successfully bound to the specified data elements. The <em>update</em> selection also contains a reference to the <a href="../selections.md/#enter">enter</a> and <a href="../selections.md/#exit">exit</a> selections, for adding and removing nodes in correspondence with data. The <em>update</em> and <em>enter</em> selections are returned in data order and the <em>exit</em> selection in document order at the time that the selection was queried. For more details, see the short tutorial <a href="http://bost.ocks.org/mike/join/" title="http://bost.ocks.org/mike/join/" target="_blank">Thinking With Joins</a>.</p> <p>A <em>key</em> function <strong>key</strong>([ <em>d</em> [, <em>i</em> ]]) may be specified to control how data is joined to elements (this replaces the default by-index behavior). The key function returns a string which is used to join a datum with its corresponding element, based on the previously-bound data. For example, if each datum has a unique field <code>name</code>, the join might be specified as <code>.data(data, function(d) { return d.name; })</code></p> <p>The key function is called twice during the data binding process, which proceeds in two phases.</p> <ol> <li><p>The <em>key</em> function is evaluated on the nodes to form <code>nodeByKeyValue</code> (an associative array of nodes) with the <code>this</code> context as the node, <code>d</code> as the node <code>__data__</code> member and the second argument <code>i</code> as the selection group index.</p></li> <li><p>The <em>key</em> function is evaluated on each element of the <em>values</em> array - this time with <em>values</em> as the <code>this</code> context, <em>values</em>[<code>i</code>] as the first argument <code>d</code> and the <em>values</em> index <code>i</code> as the second argument - and the results are then used to attempt to look up the nodes in the <code>nodeByKeyValue</code> collection. If the lookup is successful, the node is added to the <em>update selection</em>, any nodes not queried are added to the exit selection. Any data elements that failed to find a matching node are used to form the enter selection.</p></li> </ol> <p>If a key function is specified, the <code>data</code> operator also affects the index of nodes; this index is passed as the second argument <code>i</code> to any operator function arguments. However, note that existing DOM elements are not automatically reordered; use <a href="#sort">sort</a> or <a href="#order">order</a> as needed. For a more detailed example of how the key function affects the data join, see the tutorial <a href="http://bost.ocks.org/mike/bar/2/" title="http://bost.ocks.org/mike/bar/2/" target="_blank">A Bar Chart, Part 2</a>.</p> <p>The <em>values</em> array specifies the data <strong>for each group</strong> in the selection. Thus, if the selection has multiple groups (such as a <a href="#d3_selectAll">d3.selectAll</a> followed by a <a href="#selectAll">selection.selectAll</a>), then <em>data</em> should be specified as a function that returns an array (assuming that you want different data for each group). The function will be passed the current group data (or <code>undefined</code>) and the index, with the group as the <code>this</code> context. For example, you may bind a two-dimensional array to an initial selection, and then bind the contained inner arrays to each subselection. The <em>values</em> function in this case is the identity function: it is invoked for each group of child elements, being passed the data bound to the parent element, and returns this array of data.</p> <pre data-language="javascript">var matrix = [
  [11975,  5871, 8916, 2868],
  [ 1951, 10048, 2060, 6171],
  [ 8010, 16145, 8090, 8045],
  [ 1013,   990,  940, 6907]
];

var tr = d3.select("body").append("table").selectAll("tr")
    .data(matrix)
  .enter().append("tr");

var td = tr.selectAll("td")
    .data(function(d) { return d; })
  .enter().append("td")
    .text(function(d) { return d; });</pre> <p>If <em>values</em> is not specified, then this method returns the array of data for the first group in the selection. The length of the returned array will match the length of the first group, and the index of each datum in the returned array will match the corresponding index in the selection. If some of the elements in the selection are null, or if they have no associated data, then the corresponding element in the array will be <code>undefined</code>.</p> <p>Note: the <code>data</code> method cannot be used to clear previously-bound data; use <a href="#datum">selection.datum</a> instead.</p> <h6 id="enter"> selection.<b>enter()</b>
</h6> <p>Returns the enter selection: placeholder nodes for each data element for which no corresponding existing DOM element was found in the current selection. This method is only defined on the update selection, which is returned by the <a href="../selections.md/#data">data</a> operator. In addition, the enter selection only defines the <a href="../selections.md/#append">append</a>, <a href="../selections.md/#insert">insert</a>, <a href="../selections.md/#select">select</a> and <a href="../selections.md/#call">call</a> operators; you must use these operators to instantiate the entering elements before modifying any content. Enter selections also support <a href="../selections.md/#empty">empty</a> and <a href="../selections.md/#size">size</a>.</p> <p>As a simple example, consider the case where the existing selection is empty, and we wish to create new nodes to match our data:</p> <pre data-language="javascript">d3.select("body").selectAll("div")
    .data([4, 8, 15, 16, 23, 42])
  .enter().append("div")
    .text(function(d) { return d; });</pre> <p>Assuming that the body is initially empty, the above code will create six new DIV elements, append them to the body in order, and assign their text content as the associated (string-coerced) number:</p> <pre data-language="markup">&lt;div&gt;4&lt;/div&gt;
&lt;div&gt;8&lt;/div&gt;
&lt;div&gt;15&lt;/div&gt;
&lt;div&gt;16&lt;/div&gt;
&lt;div&gt;23&lt;/div&gt;
&lt;div&gt;42&lt;/div&gt;</pre> <p>Another way to think about the entering placeholder nodes is that they are pointers to the parent node (in this example, the document body); however, they only support append and insert. Once elements have been inserted, their indices will reflect the new positions and not necessarily start from zero or be continuous.</p> <p>The enter selection <strong>merges into the update selection</strong> when you append or insert. Rather than applying the same operators to the enter and update selections separately, you can now apply them only once to the update selection after entering the nodes. If you find yourself removing an entire selection's elements only to reinsert most of them, do this instead. For example:</p> <pre data-language="javascript">var update_sel = svg.selectAll("circle").data(data)
update_sel.attr(/* operate on old elements only */)
update_sel.enter().append("circle").attr(/* operate on new elements only */)
update_sel.attr(/* operate on old and new elements */)
update_sel.exit().remove() /* complete the enter-update-exit pattern */</pre> <h6 id="exit"> selection.<b>exit()</b>
</h6> <p>Returns the exit selection: existing DOM elements in the current selection for which no new data element was found. This method is only defined on the update selection, which is returned by the <a href="../selections.md/#data">data</a> operator. The exit selection defines all the normal operators, though typically the main one you'll want to use is <a href="../selections.md/#remove">remove</a>; the other operators exist primarily so you can define an exiting transition as desired. Note that the <em>exit</em> operator merely returns a reference to the exit selection, and it is up to you to remove the new nodes.</p> <p>As a simple example, consider updating the six DIV elements created in the above example for the enter operator. Here we bind those elements to a new array of data with some new and some old:</p> <pre data-language="javascript">var div = d3.select("body").selectAll("div")
    .data([1, 2, 4, 8, 16, 32], function(d) { return d; });</pre> <p>Now <code>div</code>—the result of the data operator—refers to the updating selection. Since we specified a key function using the identity function, and the new data array contains the numbers [4, 8, 16] which also exist in the old data array, this updating selection contains three DIV elements. Let's say we leave those elements as-is. We can instantiate and add the new elements [1, 2, 32] using the enter selection:</p> <pre data-language="javascript">div.enter().append("div")
    .text(function(d) { return d; });</pre> <p>Likewise, we can remove the exiting elements [15, 23, 42]:</p> <pre data-language="javascript">div.exit().remove();</pre> <p>Now the document body looks like this:</p> <pre data-language="markup">&lt;div&gt;4&lt;/div&gt;
&lt;div&gt;8&lt;/div&gt;
&lt;div&gt;16&lt;/div&gt;
&lt;div&gt;1&lt;/div&gt;
&lt;div&gt;2&lt;/div&gt;
&lt;div&gt;32&lt;/div&gt;</pre> <p>Note that the DOM elements are now out-of-order. However, the selection index <code>i</code> (the second argument to operator functions), will correctly match the new data array. For example, we could assign an index attribute:</p> <pre data-language="javascript">d3.selectAll("div").attr("index", function(d, i) { return i; });</pre> <p>This would result in:</p> <pre data-language="markup">&lt;div index="2"&gt;4&lt;/div&gt;
&lt;div index="3"&gt;8&lt;/div&gt;
&lt;div index="4"&gt;16&lt;/div&gt;
&lt;div index="0"&gt;1&lt;/div&gt;
&lt;div index="1"&gt;2&lt;/div&gt;
&lt;div index="5"&gt;32&lt;/div&gt;</pre> <p>If you want the document traversal order to match the selection data order, you can use <a href="#sort">sort</a> or <a href="#order">order</a>.</p> <h6 id="filter"> selection.<b>filter</b>(<i>selector</i>)</h6> <p>Filters the selection, returning a new selection that contains only the elements for which the specified <em>selector</em> is true. The <em>selector</em> may be specified either as a function or as a selector string, such as ".foo". As with other operators, the function is passed the current datum <code>d</code> and index <code>i</code>, with the <code>this</code> context as the current DOM element. Filter should only be called on selections with DOM elements bound, e.g. from <a href="../selections.md/#append">append</a> or <a href="../selections.md/#insert">insert</a>. To bind elements to only a subset of the data, call the built-in array <a href="https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/Filter" title="https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/Filter" target="_blank">filter</a> on the argument to <a href="../selections.md/#data">data</a>. Like the built-in function, D3's filter <em>does not</em> preserve the index of the original selection in the returned selection; it returns a copy with elements removed. If you want to preserve the index, use <a href="../selections.md/#select">select</a> instead.</p> <p>For example, to select every element with an odd index (relative to the zero-based index):</p> <pre data-language="javascript">var odds = selection.select(function(d, i) { return i % 2 === 1 ? this : null; });</pre> <p>Equivalently, using a filter function:</p> <pre data-language="javascript">var odds = selection.filter(function(d, i) { return i % 2 === 1; });</pre> <p>Or a filter selector (noting that the :nth-child pseudo-class is a one-based index rather than a zero-based index):</p> <pre data-language="javascript">var odds = selection.filter(":nth-child(even)");</pre> <p>Thus, you can use either select or filter to apply operators to a subset of elements.</p> <h6 id="datum"> selection.<b>datum</b>([<i>value</i>])</h6> <p>Gets or sets the bound data for each selected element. Unlike the <a href="#data">selection.data</a> method, this method does not compute a join (and thus does not compute enter and exit selections). This method is implemented on top of <a href="#property">selection.property</a>:</p> <pre data-language="javascript">d3.selection.prototype.datum = function(value) {
  return arguments.length &lt; 1
      ? this.property("__data__")
      : this.property("__data__", value);
};</pre> <p>If <em>value</em> is specified, sets the element's bound data to the specified value on all selected elements. If <em>value</em> is a constant, all elements are given the same data; otherwise, if <em>value</em> is a function, then the function is evaluated for each selected element, being passed the previous datum <code>d</code> and the current index <code>i</code>, with the <code>this</code> context as the current DOM element. The function is then used to set each element's data. A null value will delete the bound data. This operator has no effect on the index.</p> <p>If <em>value</em> is not specified, returns the bound datum for the first non-null element in the selection. This is generally useful only if you know the selection contains exactly one element.</p> <p>Note: this method was previously called "map". The old name is deprecated.</p> <p>The <code>datum</code> method is useful for accessing HTML5 <a href="http://www.w3.org/TR/html5/dom.html#custom-data-attribute" title="http://www.w3.org/TR/html5/dom.html#custom-data-attribute" target="_blank">custom data attributes</a> with D3. For example, given the following elements:</p> <pre data-language="markup">&lt;ul id="list"&gt;
  &lt;li data-username="shawnbot"&gt;Shawn Allen&lt;/li&gt;
  &lt;li data-username="mbostock"&gt;Mike Bostock&lt;/li&gt;
&lt;/ul&gt;</pre> <p>You can expose the custom data attributes to D3 by setting each element’s data as the built-in <a href="http://www.w3.org/TR/html5/dom.html#dom-dataset" title="http://www.w3.org/TR/html5/dom.html#dom-dataset" target="_blank">dataset</a> property:</p> <pre data-language="javascript">selection.datum(function() { return this.dataset; })</pre> <p>This can then be used, <a href="http://bl.ocks.org/1323729" title="http://bl.ocks.org/1323729" target="_blank">for example</a>, to sort elements by username.</p> <h6 id="sort"> selection.<b>sort</b>([<i>comparator</i>])</h6> <p>Sorts the elements in the current selection according to the <em>comparator</em> function, and then re-inserts the document elements to match. Returns the selection.</p> <p>The comparator function, which defaults to <a href="https://github.com/mbostock/d3/wiki/Arrays#d3_ascending" target="_blank">d3.ascending</a>, is passed two elements' data <em>a</em> and <em>b</em> to compare. It should return either a negative, positive, or zero value. If negative, then <em>a</em> should be before <em>b</em>; if positive, then <em>a</em> should be after <em>b</em>; otherwise, <em>a</em> and <em>b</em> are considered equal and the order is arbitrary.</p> <p>Note that the sort is not guaranteed to be stable; however, it is guaranteed to have the same behavior as your browser's built-in <a href="https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/sort" title="https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/sort" target="_blank">sort</a> method on arrays.</p> <h6 id="order"> selection.<b>order</b>()</h6> <p>Re-inserts elements into the document such that the document order matches the selection order. This is equivalent to calling sort() if the data is already sorted, but much faster.</p> <h3 id="animation--interaction">
Animation &amp; Interaction</h3> <h6 id="on"> selection.<b>on</b>(<i>type</i>[, <i>listener</i>[, <i>capture</i>]])</h6> <p>Adds or removes an event <em>listener</em> to each element in the current selection, for the specified <em>type</em>. The <em>type</em> is a string event type name, such as "click", "mouseover", or "submit". (Any <a href="https://developer.mozilla.org/en-US/docs/Web/Events#Standard_events" target="_blank">DOM event type</a> supported by your browser may be used.) The <em>listener</em> is stored by decorating the selected DOM elements using the naming convention "__on<em>type</em>". The specified <em>listener</em> is invoked in the same manner as other operator functions, being passed the current datum <code>d</code> and index <code>i</code>, with the <code>this</code> context as the current DOM element. To access the current event within a listener, use the global <a href="../selections.md/#d3_event">d3.event</a>. The return value of the event listener is ignored.</p> <p>If an event listener was already registered for the same type on the selected element, the existing listener is removed before the new listener is added. To register multiple listeners for the same event type, the type may be followed by an optional namespace, such as "click.foo" and "click.bar". The first part of the <em>type</em> ("click" for example) is used to register the event listener (using element.addEventListener()) and methods are added on the selected elements as __onclick.foo and __onclick.bar. To remove a listener, pass null as the <em>listener</em>. To remove all listeners for a particular event type, pass null as the <em>listener</em>, and <code>.type</code> as the <em>type</em>, e.g. <code>selection.on(".foo", null)</code>.</p> <p>An optional <em>capture</em> flag may be specified, which corresponds to the W3C <a href="http://www.w3.org/TR/DOM-Level-2-Events/events.html#Events-registration" title="http://www.w3.org/TR/DOM-Level-2-Events/events.html#Events-registration" target="_blank">useCapture flag</a>: "After initiating capture, all events of the specified type will be dispatched to the registered EventListener before being dispatched to any EventTargets beneath them in the tree. Events which are bubbling upward through the tree will not trigger an EventListener designated to use capture."</p> <p>If <em>listener</em> is not specified, returns the currently-assigned listener for the specified <em>type</em>, if any.</p> <p>Note that while listeners will always see the latest datum (<code>d</code>) for their element, the index (<code>i</code>) is a property of the selection, and is defined when the selection is created. Updating the index requires re-selecting and re-binding listeners.</p> <h6 id="d3_event"> d3.<b>event</b>
</h6> <p>Stores the current event, if any. This global is registered during an event listener callback with the <a href="../selections.md/#on">on</a> operator. The current event is reset after the listener is notified in a <code>finally</code> block. This allows the listener function to have the same form as other operator functions, being passed the current datum <code>d</code> and index <code>i</code>.</p> <p>The <code>d3.event</code> object is a <a href="https://developer.mozilla.org/en-US/docs/DOM/event" title="https://developer.mozilla.org/en-US/docs/DOM/event" target="_blank">DOM event</a> and implements the standard event fields like <code>timeStamp</code> and <code>keyCode</code> as well as methods like <code>preventDefault()</code> and <code>stopPropagation()</code>. While you can use the native event's <a href="https://developer.mozilla.org/en/DOM/event.pageX" title="https://developer.mozilla.org/en/DOM/event.pageX" target="_blank">pageX</a> and <a href="https://developer.mozilla.org/en/DOM/event.pageY" title="https://developer.mozilla.org/en/DOM/event.pageY" target="_blank">pageY</a>, it is often more convenient to transform the event position to the local coordinate system of the container that received the event. For example, if you embed an SVG in the normal flow of your page, you may want the event position relative to the top-left corner of the SVG image. If your SVG contains transforms, you might also want to know the position of the event relative to those transforms. Use the <a href="#d3_mouse">d3.mouse</a> operator for the standard mouse pointer, and use <a href="#d3_touches">d3.touches</a> for multitouch events on iOS.</p> <h6 id="d3_mouse"> d3.<b>mouse</b>(<i>container</i>)</h6> <p>Returns the <em>x</em> and <em>y</em> coordinates of the current <a href="#d3_event">d3.event</a>, relative to the specified <em>container</em>. The container may be an HTML or SVG container element, such as an <a href="http://www.w3.org/TR/SVG/struct.html#Groups" title="http://www.w3.org/TR/SVG/struct.html#Groups" target="_blank">svg:g</a> or <a href="http://www.w3.org/TR/SVG/struct.html#SVGElement" title="http://www.w3.org/TR/SVG/struct.html#SVGElement" target="_blank">svg:svg</a>. The coordinates are returned as a two-element array [<em>x</em>, <em>y</em>].</p> <h6 id="d3_touch"> d3.<b>touch</b>(<i>container</i>[, <i>touches</i>], <i>identifier</i>)</h6> <p>Returns the <em>x</em> and <em>y</em> coordinates of the touch with the specified identifier associated with the current <a href="#d3_event">d3.event</a>, relative to the specified <em>container</em>. If <em>touches</em> is not specified, defaults to the current event’s <a href="http://developer.apple.com/library/safari/documentation/UserExperience/Reference/TouchEventClassReference/TouchEvent/TouchEvent.html#//apple_ref/javascript/instp/TouchEvent/changedTouches" title="http://developer.apple.com/library/safari/documentation/UserExperience/Reference/TouchEventClassReference/TouchEvent/TouchEvent.html#//apple_ref/javascript/instp/TouchEvent/changedTouches" target="_blank">changedTouches</a>. The container may be an HTML or SVG container element, such as an svg:g or svg:svg. The coordinates are returned as an array of two-element arrays [ [ <em>x1</em>, <em>y1</em>], [ <em>x2</em>, <em>y2</em>], … ]. If there is no touch with the specified identifier in <em>touches</em>, returns null; this can be useful for ignoring touchmove events where the only some touches have moved.</p> <h6 id="d3_touches"> d3.<b>touches</b>(<i>container</i>[, <i>touches</i>])</h6> <p>Returns the <em>x</em> and <em>y</em> coordinates of each touch associated with the current <a href="#d3_event">d3.event</a>, based on the <a href="http://developer.apple.com/library/safari/documentation/UserExperience/Reference/TouchEventClassReference/TouchEvent/TouchEvent.html#//apple_ref/javascript/instp/TouchEvent/touches" title="http://developer.apple.com/library/safari/documentation/UserExperience/Reference/TouchEventClassReference/TouchEvent/TouchEvent.html#//apple_ref/javascript/instp/TouchEvent/touches" target="_blank">touches</a> attribute, relative to the specified <em>container</em>. The container may be an HTML or SVG container element, such as an svg:g or svg:svg. The coordinates are returned as an array of two-element arrays [ [ <em>x1</em>, <em>y1</em>], [ <em>x2</em>, <em>y2</em>], … ]. If <em>touches</em> is specified, returns the positions of the specified touches; if <em>touches</em> is not specified, it defaults to the <code>touches</code> property on the current event.</p> <h6 id="transition"> selection.<b>transition</b>([<i>name</i>])</h6> <p>Starts a <a href="../transitions.md/">transition</a> for the current selection. Transitions behave much like selections, except operators animate smoothly over time rather than applying instantaneously.</p> <p>Transitions of the same name are <a href="http://bost.ocks.org/mike/transition/" title="http://bost.ocks.org/mike/transition/" target="_blank">exclusive per-element</a>. When the new transition starts on a given element, it will interrupt an active transition of the same name on the element, if any. If a <em>name</em> is not specified, the empty name (“”) is used. Note that transitions with a zero delay do not start until the next timer tick, which is typically about 17ms after scheduling.</p> <h6 id="interrupt"> selection.<b>interrupt</b>([<i>name</i>])</h6> <p>Immediately interrupts the active <a href="../transitions.md/">transition</a> of the specified <em>name</em> on the selected elements, if any. If a <em>name</em> is not specified, the empty name (“”) is used. Does not cancel any scheduled transitions that have not yet started. To cancel scheduled transitions as well, simply create a new zero-delay transition after interrupting the current transition:</p> <pre data-language="javascript">selection
    .interrupt() // cancel the current transition
    .transition(); // preempt any scheduled transitions</pre> <h3 id="subselections">
Subselections</h3> <p>Whereas the top-level select methods query the entire document, a selection's <a href="../selections.md/#select">select</a> and <a href="../selections.md/#selectAll">selectAll</a> operators restrict queries to descendants of each selected element; we call this "subselection". For example, <code>d3.selectAll("p").select("b")</code> returns the first bold ("b") elements in every paragraph ("p") element. Subselecting via selectAll groups elements by ancestor. Thus, <code>d3.selectAll("p").selectAll("b")</code> groups by paragraph, while <code>d3.selectAll("p b")</code> returns a flat selection. Subselecting via select is similar, but preserves groups and propagates data. Grouping plays an important role in the data join, and functional operators may depend on the numeric index of the current element within its group.</p> <h6 id="select"> selection.<b>select</b>(<i>selector</i>)</h6> <p>For each element in the current selection, selects the first descendant element that matches the specified <em>selector</em> string. If no element matches the specified selector for the current element, the element at the current index will be null in the returned selection; operators (with the exception of <a href="../selections.md/#data">data</a>) automatically skip null elements, thereby preserving the index of the existing selection. If the current element has associated data, this data is inherited by the returned subselection, and automatically bound to the newly selected elements. If multiple elements match the selector, only the first matching element in document traversal order will be selected.</p> <p>The <em>selector</em> may also be specified as a function that returns an element, or null if there is no matching element. In this case, the specified <em>selector</em> is invoked in the same manner as other operator functions, being passed the current datum <code>d</code> and index <code>i</code>, with the <code>this</code> context as the current DOM element.</p> <h6 id="selectAll"> selection.<b>selectAll</b>(<i>selector</i>)</h6> <p>For each element in the current selection, selects descendant elements that match the specified <em>selector</em> string. The returned selection is grouped by the ancestor node in the current selection. If no element matches the specified selector for the current element, the group at the current index will be empty in the returned selection. The subselection does not inherit data from the current selection; however, if the <a href="../selections.md/#data">data</a> value is specified as a function, this function will be called with the data <code>d</code> of the ancestor node and the group index <code>i</code> to determine the data bindings for the subselection.</p> <p>Grouping by selectAll also affects subsequent entering placeholder nodes. Thus, to specify the parent node when appending entering nodes, use select followed by selectAll:</p> <pre data-language="javascript">d3.select("body").selectAll("div")</pre> <p>You can see the parent node of each group by inspecting the <code>parentNode</code> property of each group array, such as <code>selection[0].parentNode</code>.</p> <p>The <em>selector</em> may also be specified as a function that returns an array of elements (or a NodeList), or the empty array if there are no matching elements. In this case, the specified <em>selector</em> is invoked in the same manner as other operator functions, being passed the current datum <code>d</code> and index <code>i</code>, with the <code>this</code> context as the current DOM element.</p> <h3 id="control">
Control</h3> <p>For advanced usage, D3 has a few additional operators for custom control flow.</p> <h6 id="each"> selection.<b>each</b>(<i>function</i>)</h6> <p>Invokes the specified <em>function</em> for each element in the current selection, passing in the current datum <code>d</code> and index <code>i</code>, with the <code>this</code> context of the current DOM element. This operator is used internally by nearly every other operator, and can be used to invoke arbitrary code for each selected element. The each operator can be used to process selections recursively, by using <code>d3.select(this)</code> within the callback function.</p> <h6 id="call"> selection.<b>call</b>(<i>function</i>[, <i>arguments…</i>])</h6> <p>Invokes the specified <em>function</em> once, passing in the current selection along with any optional <em>arguments</em>. The call operator always returns the current selection, regardless of the return value of the specified function. The call operator is identical to invoking a function by hand; but it makes it easier to use method chaining. For example, say we want to set a number of attributes the same way in a number of different places. So we take the code and wrap it in a reusable function:</p> <pre data-language="javascript">function foo(selection) {
  selection
      .attr("name1", "value1")
      .attr("name2", "value2");
}</pre> <p>Now, we can say this:</p> <pre data-language="javascript">foo(d3.selectAll("div"));</pre> <p>Or equivalently:</p> <pre data-language="javascript">d3.selectAll("div").call(foo);</pre> <p>The <code>this</code> context of the called function is also the current selection. This is slightly redundant with the first argument, which we might fix in the future.</p> <p>If you use an object's method in selection.call and need <code>this</code> to point to that object you create a function <em>bound</em> to the object before calling.</p> <pre data-language="javascript">function Foo(text) {
    this.text = text;
}

Foo.prototype.setText = function(selection) {
    selection.text(this.text);
}

var bar = new Foo("Bar");

d3.selectAll("span").call(bar.setText.bind(bar));
// Or
d3.selectAll("span").call(Foo.prototype.setText.bind(bar));</pre> <h6 id="empty"> selection.<b>empty</b>()</h6> <p>Returns true if the current selection is empty; a selection is empty if it contains no elements or only null elements.</p> <h6 id="node"> selection.<b>node</b>()</h6> <p>Returns the first non-null element in the current selection. If the selection is empty, returns null.</p> <h6 id="size"> selection.<b>size</b>()</h6> <p>Returns the total number of elements in the current selection.</p> <h3 id="extension">
Extension</h3> <h6 id="d3_selection"> d3.<b>selection</b>()</h6> <p>Returns the root selection, equivalent to <code>d3.select(document.documentElement)</code>. This function can also be used to check if an object is a selection: <code>o instanceof d3.selection</code>. You can also add new methods to the selection prototype. For example, to add a convenience method for setting the "checked" property of checkboxes, you might say:</p> <pre data-language="javascript">d3.selection.prototype.checked = function(value) {
  return arguments.length &lt; 1
      ? this.property("checked")
      : this.property("checked", value);
};</pre>
<div class="_attribution">
  <p class="_attribution-p">
    © 2010–2016 Michael Bostock<br>Licensed under the BSD License.<br>
    <a href="https://github.com/d3/d3-3.x-api-reference/blob/master/Selections.md" class="_attribution-link" target="_blank">https://github.com/d3/d3-3.x-api-reference/blob/master/Selections.md</a>
  </p>
</div>

			</div>
		</div>
	</section>

	</div>
</body>
</html>
