
<!DOCTYPE HTML>

<html lang="en">

<head>
  <meta charset="utf-8">
  <title>Partial Indexes - SQLite - W3cubDocs</title>
  
  <meta name="description" content=" A partial index is an index over a subset of the rows of a table. ">
  <meta name="keywords" content="partial, indexes, introduction, creating, queries, using, supported, versions, -, sqlite">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="http://docs.w3cub.com/sqlite/partialindex/">
  <link href="/favicon.png" rel="icon">
  <link type="text/css" rel="stylesheet" href="/assets/application-50364fff564ce3b6327021805f3f00e2957b441cf27f576a7dd4ff63bbc47047.css">
  <script type="text/javascript" src="/assets/application-db64bfd54ceb42be11af7995804cf4902548419ceb79d509b0b7d62c22d98e6f.js"></script>
  <script src="/json/sqlite.js"></script>
  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-71174418-1']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>


</head>

<body>
	<div class="_app">
	<header class="_header">
  
  <form class="_search">
    <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
    <a class="_search-clear"></a>
    <div class="_search-tag"></div>
  </form>
  
  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/sqlite/" class="_nav-link" title="" style="margin-left:0;">SQLite</a></span>
  
  <nav class="_nav">
    <a href="/app/" class="_nav-link ">App</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		<div class="_list">
			
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<div class="_page _sqlite">
				
<h1 class="fancy_title"> Partial Indexes </h1> <div class="fancy_toc">  <div id="toc_sub">
<div class="fancy-toc1"><a href="#introduction">1. Introduction</a></div> <div class="fancy-toc1"><a href="#creating_partial_indexes">2. Creating Partial Indexes</a></div> <div class="fancy-toc2"><a href="#unique_partial_indexes">2.1. Unique Partial Indexes</a></div> <div class="fancy-toc1"><a href="#queries_using_partial_indexes">3. Queries Using Partial Indexes</a></div> <div class="fancy-toc1"><a href="#supported_versions">4. Supported Versions</a></div> </div> </div>   <h1 id="introduction">
<span>1. </span>Introduction</h1> <p> A partial index is an index over a subset of the rows of a table. </p> <p> In ordinary indexes, there is exactly one entry in the index for every row in the table. In partial indexes, only some subset of the rows in the table have corresponding index entries. For example, a partial index might omit entries for which the column being indexed is NULL. When used judiciously, partial indexes can result in smaller database files and improvements in both query and write performance. </p> <h1 id="creating_partial_indexes">
<span>2. </span>Creating Partial Indexes</h1> <p> Create a partial index by adding a WHERE clause to the end of an ordinary <a href="../lang_createindex/">CREATE INDEX</a> statement. </p> <p><b><a href="../syntax/create-index-stmt/">create-index-stmt:</a></b> <button id="x1445" class="_btn" data-toggle="x1446">hide</button></p> <div id="x1446" class="imgcontainer"> <img alt="syntax diagram create-index-stmt" src="https://sqlite.org/images/syntax/create-index-stmt.gif"> <p><b><a href="../syntax/expr/">expr:</a></b> <button id="x1447" class="_btn" data-toggle="x1448">show</button></p> <div id="x1448" style="display:none;" class="imgcontainer"> <img alt="syntax diagram expr" src="https://sqlite.org/images/syntax/expr.gif"> <p><b><a href="../syntax/literal-value/">literal-value:</a></b> <button id="x1449" class="_btn" data-toggle="x1450">show</button></p> <div id="x1450" style="display:none;" class="imgcontainer"> <img alt="syntax diagram literal-value" src="https://sqlite.org/images/syntax/literal-value.gif"> </div> <p><b><a href="../syntax/raise-function/">raise-function:</a></b> <button id="x1451" class="_btn" data-toggle="x1452">show</button></p> <div id="x1452" style="display:none;" class="imgcontainer"> <img alt="syntax diagram raise-function" src="https://sqlite.org/images/syntax/raise-function.gif"> </div> <p><b><a href="../syntax/select-stmt/">select-stmt:</a></b> <button id="x1453" class="_btn" data-toggle="x1454">show</button></p> <div id="x1454" style="display:none;" class="imgcontainer"> <img alt="syntax diagram select-stmt" src="https://sqlite.org/images/syntax/select-stmt.gif"> <p><b><a href="../syntax/common-table-expression/">common-table-expression:</a></b> <button id="x1455" class="_btn" data-toggle="x1456">show</button></p> <div id="x1456" style="display:none;" class="imgcontainer"> <img alt="syntax diagram common-table-expression" src="https://sqlite.org/images/syntax/common-table-expression.gif"> </div> <p><b><a href="../syntax/compound-operator/">compound-operator:</a></b> <button id="x1457" class="_btn" data-toggle="x1458">show</button></p> <div id="x1458" style="display:none;" class="imgcontainer"> <img alt="syntax diagram compound-operator" src="https://sqlite.org/images/syntax/compound-operator.gif"> </div> <p><b><a href="../syntax/join-clause/">join-clause:</a></b> <button id="x1459" class="_btn" data-toggle="x1460">show</button></p> <div id="x1460" style="display:none;" class="imgcontainer"> <img alt="syntax diagram join-clause" src="https://sqlite.org/images/syntax/join-clause.gif"> <p><b><a href="../syntax/join-constraint/">join-constraint:</a></b> <button id="x1461" class="_btn" data-toggle="x1462">show</button></p> <div id="x1462" style="display:none;" class="imgcontainer"> <img alt="syntax diagram join-constraint" src="https://sqlite.org/images/syntax/join-constraint.gif"> </div> <p><b><a href="../syntax/join-operator/">join-operator:</a></b> <button id="x1463" class="_btn" data-toggle="x1464">show</button></p> <div id="x1464" style="display:none;" class="imgcontainer"> <img alt="syntax diagram join-operator" src="https://sqlite.org/images/syntax/join-operator.gif"> </div> </div> <p><b><a href="../syntax/ordering-term/">ordering-term:</a></b> <button id="x1465" class="_btn" data-toggle="x1466">show</button></p> <div id="x1466" style="display:none;" class="imgcontainer"> <img alt="syntax diagram ordering-term" src="https://sqlite.org/images/syntax/ordering-term.gif"> </div> <p><b><a href="../syntax/result-column/">result-column:</a></b> <button id="x1467" class="_btn" data-toggle="x1468">show</button></p> <div id="x1468" style="display:none;" class="imgcontainer"> <img alt="syntax diagram result-column" src="https://sqlite.org/images/syntax/result-column.gif"> </div> <p><b><a href="../syntax/table-or-subquery/">table-or-subquery:</a></b> <button id="x1469" class="_btn" data-toggle="x1470">show</button></p> <div id="x1470" style="display:none;" class="imgcontainer"> <img alt="syntax diagram table-or-subquery" src="https://sqlite.org/images/syntax/table-or-subquery.gif"> </div> </div> <p><b><a href="../syntax/type-name/">type-name:</a></b> <button id="x1471" class="_btn" data-toggle="x1472">show</button></p> <div id="x1472" style="display:none;" class="imgcontainer"> <img alt="syntax diagram type-name" src="https://sqlite.org/images/syntax/type-name.gif"> <p><b><a href="../syntax/signed-number/">signed-number:</a></b> <button id="x1473" class="_btn" data-toggle="x1474">show</button></p> <div id="x1474" style="display:none;" class="imgcontainer"> <img alt="syntax diagram signed-number" src="https://sqlite.org/images/syntax/signed-number.gif"> </div> </div> </div> <p><b><a href="../syntax/indexed-column/">indexed-column:</a></b> <button id="x1475" class="_btn" data-toggle="x1476">show</button></p> <div id="x1476" style="display:none;" class="imgcontainer"> <img alt="syntax diagram indexed-column" src="https://sqlite.org/images/syntax/indexed-column.gif"> </div> </div> <p> Any index that includes the WHERE clause at the end is considered to be a partial index. Indexes that omit the WHERE clause (or indexes that are created by UNIQUE or PRIMARY KEY constraints inside of CREATE TABLE statements) are ordinary full indexes. </p> <p> The expression following the WHERE clause may contain operators, literal values, and names of columns in the table being indexed. The WHERE clause may <em>not</em> contain subqueries, references to other tables, <a href="../deterministic/">non-deterministic functions</a>, or <a href="../lang_expr/#varparam">bound parameters</a>. The LIKE, GLOB, MATCH, and REGEXP operators in SQLite are implemented as functions by the same name. Since functions are prohibited in the WHERE clause of a CREATE INDEX statement, so too are the LIKE, GLOB, MATCH, and REGEXP operators.</p> <p> Only rows of the table for which the WHERE clause evaluates to true are included in the index. If the WHERE clause expression evaluates to NULL or to false for some rows of the table, then those rows are omitted from the index. </p> <p> The columns referenced in the WHERE clause of a partial index can be any of the columns in the table, not just columns that happen to be indexed. However, it is very common for the WHERE clause expression of a partial index to be a simple expression on the column being indexed. The following is a typical example:</p> <pre data-language="sql">CREATE INDEX po_parent ON purchaseorder(parent_po) WHERE parent_po IS NOT NULL;
</pre> <p>In the example above, if most purchase orders do not have a "parent" purchase order, then most parent_po values will be NULL. That means only a small subset of the rows in the purchaseorder table will be indexed. Hence the index will take up much less space. And changes to the original purchaseorder table will run faster since the po_parent index only needs to be updated for those exceptional rows where parent_po is not NULL. But the index is still useful for querying. In particular, if one wants to know all "children" of a particular purchase order "?1", the query would be: </p>
<pre data-language="sql">SELECT po_num FROM purchaseorder WHERE parent_po=?1;
</pre> <p>The query above will use the po_parent index to help find the answer, since the po_parent index contains entries for all rows of interest. Note that since po_parent is smaller than a full index, the query will likely run faster too.</p> <h2 id="unique_partial_indexes">
<span>2.1. </span>Unique Partial Indexes</h2> <p>A partial index definition may include the UNIQUE keyword. If it does, then SQLite requires every entry <em>in the index</em> to be unique. This provides a mechanism for enforcing uniqueness across some subset of the rows in a table.</p> <p>For example, suppose you have a database of the members of a large organization where each person is assigned to a particular "team". Each team has a "leader" who is also a member of that team. The table might look something like this:</p> <pre data-language="sql">CREATE TABLE person(
  person_id       INTEGER PRIMARY KEY,
  team_id         INTEGER REFERENCES team,
  is_team_leader  BOOLEAN,
  -- other fields elided
);
</pre> <p>The team_id field cannot be unique because there usually multiple people on the same team. One cannot make the combination of team_id and is_team_leader unique since there are usually multiple non-leaders on each team. The solution to enforcing one leader per team is to create a unique index on team_id but restricted to those entries for which is_team_leader is true:</p> <pre data-language="sql">CREATE UNIQUE INDEX team_leader ON person(team_id) WHERE is_team_leader;
</pre> <p>Coincidentally, that same index is useful for locating the team leader of a particular team:</p> <pre data-language="sql">SELECT person_id FROM person WHERE is_team_leader AND team_id=?1;
</pre> <h1 id="queries_using_partial_indexes">
<span>3. </span>Queries Using Partial Indexes</h1> <p>Let X be the expression in the WHERE clause of a partial index, and let W be the WHERE clause of a query that uses the table that is indexed. Then, the query is permitted to use the partial index if W⇒X, where the ⇒ operator (usually pronounced "implies") is the logic operator equivalent to "X or not W". Hence, determining whether or not a partial index is usable in a particular query reduces to proving a theorem in first-order logic.</p> <p>SQLite does <u>not</u> have a sophisticated theorem prover with which to determine W⇒X. Instead, SQLite uses two simple rules to find the common cases where W⇒X is true, and it assumes all the other cases are false. The rules used by SQLite are these: </p>
<ol> <li>
<p>If W is AND-connected terms and X is OR-connected terms and if any term of W appears as a term of X, then the partial index is usable.</p> <p>For example, let the index be </p>
<pre data-language="sql">CREATE INDEX ex1 ON tab1(a,b) WHERE a=5 OR b=6;
</pre> <p>And let the query be: </p>
<pre data-language="sql">SELECT * FROM tab1 WHERE b=6 AND a=7; -- uses partial index
</pre> <p>Then the index is usable by the query because the "b=6" term appears in both the index definition and in the query. Remember: terms in the index should be OR-connected and terms in the query should be AND-connected.</p> <p>The terms in W and X must match exactly. SQLite does not do algebra to try to get them to look the same. The term "b=6" does not match "b=3+3" or "b-6=0" or "b BETWEEN 6 AND 6". "b=6" will match to "6=b" as long as "b=6" is on the index and "6=b" is in the query. If a term of the form "6=b" appears in the index, it will never match anything.</p> </li>
<li>
<p>If a term in X is of the form "z IS NOT NULL" and if a term in W is a comparison operator on "z" other than "IS", then those terms match.</p> <p>Example: Let the index be </p>
<pre data-language="sql">CREATE INDEX ex2 ON tab2(b,c) WHERE c IS NOT NULL;
</pre> <p>Then any query that uses operators =, &lt;, &gt;, &lt;=, &gt;=, &lt;&gt;, IN, LIKE, or GLOB on column "c" would be usable with the partial index because those comparison operators are only true if "c" is not NULL. So the following query could use the partial index: </p>
<pre data-language="sql">SELECT * FROM tab2 WHERE b=456 AND c&lt;&gt;0;  -- uses partial index
</pre> <p>But the next query can not use the partial index: </p>
<pre data-language="sql">SELECT * FROM tab2 WHERE b=456;  -- cannot use partial index
</pre> <p>The latter query can not use the partial index because there might be rows in the table with b=456 and where c is NULL. But those rows would not be in the partial index. </p>
</li>
</ol> <p>These two rules describe how the query planner for SQLite works as of this writing (2013-08-01). And the rules above will always be honored. However, future versions of SQLite might incorporate a better theorem prover that can find other cases where W⇒X is true and thus may find more instances where partial indexes are useful.</p> <h1 id="supported_versions">
<span>4. </span>Supported Versions</h1> <p> Partial indexes have been supported in SQLite since <a href="https://sqlite.org/releaselog/3_8_0.html" target="_blank">version 3.8.0</a> (2013-08-26). </p> <p>Database files that contain partial indices are not readable or writable by versions of SQLite prior to 3.8.0. However, a database file created by SQLite 3.8.0 is still readable and writable by prior versions as long as its schema contains no partial indexes. A database that is unreadable by legacy versions of SQLite can be made readable simply by running <a href="../lang_dropindex/">DROP INDEX</a> on the partial indexes.</p>
<div class="_attribution">
  <p class="_attribution-p">
    SQLite is in the Public Domain.<br>
    <a href="https://sqlite.org/partialindex.html" class="_attribution-link" target="_blank">https://sqlite.org/partialindex.html</a>
  </p>
</div>

			</div>
		</div>
	</section>

	</div>
</body>
</html>
