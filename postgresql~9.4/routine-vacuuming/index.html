
<!DOCTYPE HTML>

<html lang="en">

<head>
  <meta charset="utf-8">
  <title>Routine Vacuuming - PostgreSQL 9.4 - W3cubDocs</title>
  
  <meta name="description" content="PostgreSQL databases require periodic maintenance known as vacuuming. For many installations, it is sufficient to let vacuuming be performed by the &hellip;">
  <meta name="keywords" content="routine, vacuuming, -, postgresql, postgresql~9.4">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="http://docs.w3cub.com/postgresql~9.4/routine-vacuuming/">
  <link href="/favicon.png" rel="icon">
  <link type="text/css" rel="stylesheet" href="/assets/application-50364fff564ce3b6327021805f3f00e2957b441cf27f576a7dd4ff63bbc47047.css">
  <script type="text/javascript" src="/assets/application-db64bfd54ceb42be11af7995804cf4902548419ceb79d509b0b7d62c22d98e6f.js"></script>
  <script src="/json/postgresql~9.4.js"></script>
  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-71174418-1']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>


</head>

<body>
	<div class="_app">
	<header class="_header">
  
  <form class="_search">
    <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
    <a class="_search-clear"></a>
    <div class="_search-tag"></div>
  </form>
  
  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/postgresql~9.4/" class="_nav-link" title="" style="margin-left:0;">PostgreSQL 9.4</a></span>
  
  <nav class="_nav">
    <a href="/app/" class="_nav-link ">App</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		<div class="_list">
			
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<div class="_page _postgres">
				
<h1 class="SECT1" id="ROUTINE-VACUUMING">23.1. Routine Vacuuming</h1> <p><span class="PRODUCTNAME">PostgreSQL</span> databases require periodic maintenance known as <i class="FIRSTTERM">vacuuming</i>. For many installations, it is sufficient to let vacuuming be performed by the <i class="FIRSTTERM">autovacuum daemon</i>, which is described in <a href="../routine-vacuuming/#AUTOVACUUM">Section 23.1.6</a>. You might need to adjust the autovacuuming parameters described there to obtain best results for your situation. Some database administrators will want to supplement or replace the daemon's activities with manually-managed <code class="COMMAND">VACUUM</code> commands, which typically are executed according to a schedule by <span class="APPLICATION">cron</span> or <span class="APPLICATION">Task Scheduler</span> scripts. To set up manually-managed vacuuming properly, it is essential to understand the issues discussed in the next few subsections. Administrators who rely on autovacuuming may still wish to skim this material to help them understand and adjust autovacuuming.</p> <div class="SECT2"> <h2 class="SECT2" id="VACUUM-BASICS">23.1.1. Vacuuming Basics</h2> <p><span class="PRODUCTNAME">PostgreSQL</span>'s <a href="../sql-vacuum/">VACUUM</a> command has to process each table on a regular basis for several reasons:</p> <ol type="1"> <li> <p>To recover or reuse disk space occupied by updated or deleted rows.</p> </li> <li> <p>To update data statistics used by the <span class="PRODUCTNAME">PostgreSQL</span> query planner.</p> </li> <li> <p>To update the visibility map, which speeds up index-only scans.</p> </li> <li> <p>To protect against loss of very old data due to <i class="FIRSTTERM">transaction ID wraparound</i> or <i class="FIRSTTERM">multixact ID wraparound</i>.</p> </li> </ol> <p>Each of these reasons dictates performing <code class="COMMAND">VACUUM</code> operations of varying frequency and scope, as explained in the following subsections.</p> <p>There are two variants of <code class="COMMAND">VACUUM</code>: standard <code class="COMMAND">VACUUM</code> and <code class="COMMAND">VACUUM FULL</code>. <code class="COMMAND">VACUUM FULL</code> can reclaim more disk space but runs much more slowly. Also, the standard form of <code class="COMMAND">VACUUM</code> can run in parallel with production database operations. (Commands such as <code class="COMMAND">SELECT</code>, <code class="COMMAND">INSERT</code>, <code class="COMMAND">UPDATE</code>, and <code class="COMMAND">DELETE</code> will continue to function normally, though you will not be able to modify the definition of a table with commands such as <code class="COMMAND">ALTER TABLE</code> while it is being vacuumed.) <code class="COMMAND">VACUUM FULL</code> requires exclusive lock on the table it is working on, and therefore cannot be done in parallel with other use of the table. Generally, therefore, administrators should strive to use standard <code class="COMMAND">VACUUM</code> and avoid <code class="COMMAND">VACUUM FULL</code>.</p> <p><code class="COMMAND">VACUUM</code> creates a substantial amount of I/O traffic, which can cause poor performance for other active sessions. There are configuration parameters that can be adjusted to reduce the performance impact of background vacuuming â€” see <a href="../runtime-config-resource/#RUNTIME-CONFIG-RESOURCE-VACUUM-COST"> Section 18.4.4</a>.</p> </div> <div class="SECT2"> <h2 class="SECT2" id="VACUUM-FOR-SPACE-RECOVERY">23.1.2. Recovering Disk Space</h2> <p>In <span class="PRODUCTNAME">PostgreSQL</span>, an <code class="COMMAND">UPDATE</code> or <code class="COMMAND">DELETE</code> of a row does not immediately remove the old version of the row. This approach is necessary to gain the benefits of multiversion concurrency control (<acronym class="ACRONYM">MVCC</acronym>, see <a href="https://www.postgresql.org/docs/9.4/static/mvcc.html" target="_blank">Chapter 13</a>): the row version must not be deleted while it is still potentially visible to other transactions. But eventually, an outdated or deleted row version is no longer of interest to any transaction. The space it occupies must then be reclaimed for reuse by new rows, to avoid unbounded growth of disk space requirements. This is done by running <code class="COMMAND">VACUUM</code>.</p> <p>The standard form of <code class="COMMAND">VACUUM</code> removes dead row versions in tables and indexes and marks the space available for future reuse. However, it will not return the space to the operating system, except in the special case where one or more pages at the end of a table become entirely free and an exclusive table lock can be easily obtained. In contrast, <code class="COMMAND">VACUUM FULL</code> actively compacts tables by writing a complete new version of the table file with no dead space. This minimizes the size of the table, but can take a long time. It also requires extra disk space for the new copy of the table, until the operation completes.</p> <p>The usual goal of routine vacuuming is to do standard <code class="COMMAND">VACUUM</code>s often enough to avoid needing <code class="COMMAND">VACUUM FULL</code>. The autovacuum daemon attempts to work this way, and in fact will never issue <code class="COMMAND">VACUUM FULL</code>. In this approach, the idea is not to keep tables at their minimum size, but to maintain steady-state usage of disk space: each table occupies space equivalent to its minimum size plus however much space gets used up between vacuumings. Although <code class="COMMAND">VACUUM FULL</code> can be used to shrink a table back to its minimum size and return the disk space to the operating system, there is not much point in this if the table will just grow again in the future. Thus, moderately-frequent standard <code class="COMMAND">VACUUM</code> runs are a better approach than infrequent <code class="COMMAND">VACUUM FULL</code> runs for maintaining heavily-updated tables.</p> <p>Some administrators prefer to schedule vacuuming themselves, for example doing all the work at night when load is low. The difficulty with doing vacuuming according to a fixed schedule is that if a table has an unexpected spike in update activity, it may get bloated to the point that <code class="COMMAND">VACUUM FULL</code> is really necessary to reclaim space. Using the autovacuum daemon alleviates this problem, since the daemon schedules vacuuming dynamically in response to update activity. It is unwise to disable the daemon completely unless you have an extremely predictable workload. One possible compromise is to set the daemon's parameters so that it will only react to unusually heavy update activity, thus keeping things from getting out of hand, while scheduled <code class="COMMAND">VACUUM</code>s are expected to do the bulk of the work when the load is typical.</p> <p>For those not using autovacuum, a typical approach is to schedule a database-wide <code class="COMMAND">VACUUM</code> once a day during a low-usage period, supplemented by more frequent vacuuming of heavily-updated tables as necessary. (Some installations with extremely high update rates vacuum their busiest tables as often as once every few minutes.) If you have multiple databases in a cluster, don't forget to <code class="COMMAND">VACUUM</code> each one; the program <a href="../app-vacuumdb/"><span class="APPLICATION">vacuumdb</span></a> might be helpful.</p> <div class="TIP"> <blockquote class="TIP"> <p><b>Tip:</b> Plain <code class="COMMAND">VACUUM</code> may not be satisfactory when a table contains large numbers of dead row versions as a result of massive update or delete activity. If you have such a table and you need to reclaim the excess disk space it occupies, you will need to use <code class="COMMAND">VACUUM FULL</code>, or alternatively <a href="../sql-cluster/">CLUSTER</a> or one of the table-rewriting variants of <a href="../sql-altertable/">ALTER TABLE</a>. These commands rewrite an entire new copy of the table and build new indexes for it. All these options require exclusive lock. Note that they also temporarily use extra disk space approximately equal to the size of the table, since the old copies of the table and indexes can't be released until the new ones are complete.</p> </blockquote> </div> <div class="TIP"> <blockquote class="TIP"> <p><b>Tip:</b> If you have a table whose entire contents are deleted on a periodic basis, consider doing it with <a href="../sql-truncate/">TRUNCATE</a> rather than using <code class="COMMAND">DELETE</code> followed by <code class="COMMAND">VACUUM</code>. <code class="COMMAND">TRUNCATE</code> removes the entire content of the table immediately, without requiring a subsequent <code class="COMMAND">VACUUM</code> or <code class="COMMAND">VACUUM FULL</code> to reclaim the now-unused disk space. The disadvantage is that strict MVCC semantics are violated.</p> </blockquote> </div> </div> <div class="SECT2"> <h2 class="SECT2" id="VACUUM-FOR-STATISTICS">23.1.3. Updating Planner Statistics</h2> <p>The <span class="PRODUCTNAME">PostgreSQL</span> query planner relies on statistical information about the contents of tables in order to generate good plans for queries. These statistics are gathered by the <a href="../sql-analyze/">ANALYZE</a> command, which can be invoked by itself or as an optional step in <code class="COMMAND">VACUUM</code>. It is important to have reasonably accurate statistics, otherwise poor choices of plans might degrade database performance.</p> <p>The autovacuum daemon, if enabled, will automatically issue <code class="COMMAND">ANALYZE</code> commands whenever the content of a table has changed sufficiently. However, administrators might prefer to rely on manually-scheduled <code class="COMMAND">ANALYZE</code> operations, particularly if it is known that update activity on a table will not affect the statistics of <span class="QUOTE">"interesting"</span> columns. The daemon schedules <code class="COMMAND">ANALYZE</code> strictly as a function of the number of rows inserted or updated; it has no knowledge of whether that will lead to meaningful statistical changes.</p> <p>As with vacuuming for space recovery, frequent updates of statistics are more useful for heavily-updated tables than for seldom-updated ones. But even for a heavily-updated table, there might be no need for statistics updates if the statistical distribution of the data is not changing much. A simple rule of thumb is to think about how much the minimum and maximum values of the columns in the table change. For example, a <code class="TYPE">timestamp</code> column that contains the time of row update will have a constantly-increasing maximum value as rows are added and updated; such a column will probably need more frequent statistics updates than, say, a column containing URLs for pages accessed on a website. The URL column might receive changes just as often, but the statistical distribution of its values probably changes relatively slowly.</p> <p>It is possible to run <code class="COMMAND">ANALYZE</code> on specific tables and even just specific columns of a table, so the flexibility exists to update some statistics more frequently than others if your application requires it. In practice, however, it is usually best to just analyze the entire database, because it is a fast operation. <code class="COMMAND">ANALYZE</code> uses a statistically random sampling of the rows of a table rather than reading every single row.</p> <div class="TIP"> <blockquote class="TIP"> <p><b>Tip:</b> Although per-column tweaking of <code class="COMMAND">ANALYZE</code> frequency might not be very productive, you might find it worthwhile to do per-column adjustment of the level of detail of the statistics collected by <code class="COMMAND">ANALYZE</code>. Columns that are heavily used in <code class="LITERAL">WHERE</code> clauses and have highly irregular data distributions might require a finer-grain data histogram than other columns. See <code class="COMMAND">ALTER TABLE SET STATISTICS</code>, or change the database-wide default using the <a href="../runtime-config-query/#GUC-DEFAULT-STATISTICS-TARGET">default_statistics_target</a> configuration parameter.</p> <p>Also, by default there is limited information available about the selectivity of functions. However, if you create an expression index that uses a function call, useful statistics will be gathered about the function, which can greatly improve query plans that use the expression index.</p> </blockquote> </div> <div class="TIP"> <blockquote class="TIP"> <p><b>Tip:</b> The autovacuum daemon does not issue <code class="COMMAND">ANALYZE</code> commands for foreign tables, since it has no means of determining how often that might be useful. If your queries require statistics on foreign tables for proper planning, it's a good idea to run manually-managed <code class="COMMAND">ANALYZE</code> commands on those tables on a suitable schedule.</p> </blockquote> </div> </div> <div class="SECT2"> <h2 class="SECT2" id="VACUUM-FOR-VISIBILITY-MAP">23.1.4. Updating The Visibility Map</h2> <p>Vacuum maintains a <a href="../storage-vm/">visibility map</a> for each table to keep track of which pages contain only tuples that are known to be visible to all active transactions (and all future transactions, until the page is again modified). This has two purposes. First, vacuum itself can skip such pages on the next run, since there is nothing to clean up.</p> <p>Second, it allows <span class="PRODUCTNAME">PostgreSQL</span> to answer some queries using only the index, without reference to the underlying table. Since <span class="PRODUCTNAME">PostgreSQL</span> indexes don't contain tuple visibility information, a normal index scan fetches the heap tuple for each matching index entry, to check whether it should be seen by the current transaction. An <i class="FIRSTTERM">index-only scan</i>, on the other hand, checks the visibility map first. If it's known that all tuples on the page are visible, the heap fetch can be skipped. This is most noticeable on large data sets where the visibility map can prevent disk accesses. The visibility map is vastly smaller than the heap, so it can easily be cached even when the heap is very large.</p> </div> <div class="SECT2"> <h2 class="SECT2" id="VACUUM-FOR-WRAPAROUND">23.1.5. Preventing Transaction ID Wraparound Failures</h2> <p><span class="PRODUCTNAME">PostgreSQL</span>'s <a href="../mvcc-intro/">MVCC</a> transaction semantics depend on being able to compare transaction ID (<acronym class="ACRONYM">XID</acronym>) numbers: a row version with an insertion XID greater than the current transaction's XID is <span class="QUOTE">"in the future"</span> and should not be visible to the current transaction. But since transaction IDs have limited size (32 bits) a cluster that runs for a long time (more than 4 billion transactions) would suffer <i class="FIRSTTERM">transaction ID wraparound</i>: the XID counter wraps around to zero, and all of a sudden transactions that were in the past appear to be in the future â€” which means their output become invisible. In short, catastrophic data loss. (Actually the data is still there, but that's cold comfort if you cannot get at it.) To avoid this, it is necessary to vacuum every table in every database at least once every two billion transactions.</p> <p>The reason that periodic vacuuming solves the problem is that <code class="COMMAND">VACUUM</code> will mark rows as <span class="emphasis EMPHASIS c2">frozen</span>, indicating that they were inserted by a transaction that committed sufficiently far in the past that the effects of the inserting transaction are certain to be visible to all current and future transactions. Normal XIDs are compared using modulo-2<sup>32</sup> arithmetic. This means that for every normal XID, there are two billion XIDs that are <span class="QUOTE">"older"</span> and two billion that are <span class="QUOTE">"newer"</span>; another way to say it is that the normal XID space is circular with no endpoint. Therefore, once a row version has been created with a particular normal XID, the row version will appear to be <span class="QUOTE">"in the past"</span> for the next two billion transactions, no matter which normal XID we are talking about. If the row version still exists after more than two billion transactions, it will suddenly appear to be in the future. To prevent this, <span class="PRODUCTNAME">PostgreSQL</span> reserves a special XID, <code class="LITERAL">FrozenTransactionId</code>, which does not follow the normal XID comparison rules and is always considered older than every normal XID. Frozen row versions are treated as if the inserting XID were <code class="LITERAL">FrozenTransactionId</code>, so that they will appear to be <span class="QUOTE">"in the past"</span> to all normal transactions regardless of wraparound issues, and so such row versions will be valid until deleted, no matter how long that is.</p>  <blockquote class="NOTE"> <p><b>Note:</b> In <span class="PRODUCTNAME">PostgreSQL</span> versions before 9.4, freezing was implemented by actually replacing a row's insertion XID with <code class="LITERAL">FrozenTransactionId</code>, which was visible in the row's <code class="STRUCTNAME">xmin</code> system column. Newer versions just set a flag bit, preserving the row's original <code class="STRUCTNAME">xmin</code> for possible forensic use. However, rows with <code class="STRUCTNAME">xmin</code> equal to <code class="LITERAL">FrozenTransactionId</code> (2) may still be found in databases <span class="APPLICATION">pg_upgrade</span>'d from pre-9.4 versions.</p> <p>Also, system catalogs may contain rows with <code class="STRUCTNAME">xmin</code> equal to <code class="LITERAL">BootstrapTransactionId</code> (1), indicating that they were inserted during the first phase of <span class="APPLICATION">initdb</span>. Like <code class="LITERAL">FrozenTransactionId</code>, this special XID is treated as older than every normal XID.</p> </blockquote>  <p><a href="../runtime-config-client/#GUC-VACUUM-FREEZE-MIN-AGE">vacuum_freeze_min_age</a> controls how old an XID value has to be before rows bearing that XID will be frozen. Increasing this setting may avoid unnecessary work if the rows that would otherwise be frozen will soon be modified again, but decreasing this setting increases the number of transactions that can elapse before the table must be vacuumed again.</p> <p><code class="COMMAND">VACUUM</code> normally skips pages that don't have any dead row versions, but those pages might still have row versions with old XID values. To ensure all old row versions have been frozen, a scan of the whole table is needed. <a href="../runtime-config-client/#GUC-VACUUM-FREEZE-TABLE-AGE">vacuum_freeze_table_age</a> controls when <code class="COMMAND">VACUUM</code> does that: a whole table sweep is forced if the table hasn't been fully scanned for <code class="VARNAME">vacuum_freeze_table_age</code> minus <code class="VARNAME">vacuum_freeze_min_age</code> transactions. Setting it to 0 forces <code class="COMMAND">VACUUM</code> to always scan all pages, effectively ignoring the visibility map.</p> <p>The maximum time that a table can go unvacuumed is two billion transactions minus the <code class="VARNAME">vacuum_freeze_min_age</code> value at the time <code class="COMMAND">VACUUM</code> last scanned the whole table. If it were to go unvacuumed for longer than that, data loss could result. To ensure that this does not happen, autovacuum is invoked on any table that might contain unfrozen rows with XIDs older than the age specified by the configuration parameter <a href="../runtime-config-autovacuum/#GUC-AUTOVACUUM-FREEZE-MAX-AGE">autovacuum_freeze_max_age</a>. (This will happen even if autovacuum is disabled.)</p> <p>This implies that if a table is not otherwise vacuumed, autovacuum will be invoked on it approximately once every <code class="VARNAME">autovacuum_freeze_max_age</code> minus <code class="VARNAME">vacuum_freeze_min_age</code> transactions. For tables that are regularly vacuumed for space reclamation purposes, this is of little importance. However, for static tables (including tables that receive inserts, but no updates or deletes), there is no need to vacuum for space reclamation, so it can be useful to try to maximize the interval between forced autovacuums on very large static tables. Obviously one can do this either by increasing <code class="VARNAME">autovacuum_freeze_max_age</code> or decreasing <code class="VARNAME">vacuum_freeze_min_age</code>.</p> <p>The effective maximum for <code class="VARNAME">vacuum_freeze_table_age</code> is 0.95 * <code class="VARNAME">autovacuum_freeze_max_age</code>; a setting higher than that will be capped to the maximum. A value higher than <code class="VARNAME">autovacuum_freeze_max_age</code> wouldn't make sense because an anti-wraparound autovacuum would be triggered at that point anyway, and the 0.95 multiplier leaves some breathing room to run a manual <code class="COMMAND">VACUUM</code> before that happens. As a rule of thumb, <code class="COMMAND">vacuum_freeze_table_age</code> should be set to a value somewhat below <code class="VARNAME">autovacuum_freeze_max_age</code>, leaving enough gap so that a regularly scheduled <code class="COMMAND">VACUUM</code> or an autovacuum triggered by normal delete and update activity is run in that window. Setting it too close could lead to anti-wraparound autovacuums, even though the table was recently vacuumed to reclaim space, whereas lower values lead to more frequent whole-table scans.</p> <p>The sole disadvantage of increasing <code class="VARNAME">autovacuum_freeze_max_age</code> (and <code class="VARNAME">vacuum_freeze_table_age</code> along with it) is that the <code class="FILENAME">pg_clog</code> subdirectory of the database cluster will take more space, because it must store the commit status of all transactions back to the <code class="VARNAME">autovacuum_freeze_max_age</code> horizon. The commit status uses two bits per transaction, so if <code class="VARNAME">autovacuum_freeze_max_age</code> is set to its maximum allowed value of two billion, <code class="FILENAME">pg_clog</code> can be expected to grow to about half a gigabyte. If this is trivial compared to your total database size, setting <code class="VARNAME">autovacuum_freeze_max_age</code> to its maximum allowed value is recommended. Otherwise, set it depending on what you are willing to allow for <code class="FILENAME">pg_clog</code> storage. (The default, 200 million transactions, translates to about 50MB of <code class="FILENAME">pg_clog</code> storage.)</p> <p>One disadvantage of decreasing <code class="VARNAME">vacuum_freeze_min_age</code> is that it might cause <code class="COMMAND">VACUUM</code> to do useless work: freezing a row version is a waste of time if the row is modified soon thereafter (causing it to acquire a new XID). So the setting should be large enough that rows are not frozen until they are unlikely to change any more.</p> <p>To track the age of the oldest unfrozen XIDs in a database, <code class="COMMAND">VACUUM</code> stores XID statistics in the system tables <code class="STRUCTNAME">pg_class</code> and <code class="STRUCTNAME">pg_database</code>. In particular, the <code class="STRUCTFIELD">relfrozenxid</code> column of a table's <code class="STRUCTNAME">pg_class</code> row contains the freeze cutoff XID that was used by the last whole-table <code class="COMMAND">VACUUM</code> for that table. All rows inserted by transactions with XIDs older than this cutoff XID are guaranteed to have been frozen. Similarly, the <code class="STRUCTFIELD">datfrozenxid</code> column of a database's <code class="STRUCTNAME">pg_database</code> row is a lower bound on the unfrozen XIDs appearing in that database â€” it is just the minimum of the per-table <code class="STRUCTFIELD">relfrozenxid</code> values within the database. A convenient way to examine this information is to execute queries such as:</p> <pre class="PROGRAMLISTING" data-language="sql">
SELECT c.oid::regclass as table_name,
       greatest(age(c.relfrozenxid),age(t.relfrozenxid)) as age
FROM pg_class c
LEFT JOIN pg_class t ON c.reltoastrelid = t.oid
WHERE c.relkind IN ('r', 'm');

SELECT datname, age(datfrozenxid) FROM pg_database;
</pre> <p>The <code class="LITERAL">age</code> column measures the number of transactions from the cutoff XID to the current transaction's XID.</p> <p><code class="COMMAND">VACUUM</code> normally only scans pages that have been modified since the last vacuum, but <code class="STRUCTFIELD">relfrozenxid</code> can only be advanced when the whole table is scanned. The whole table is scanned when <code class="STRUCTFIELD">relfrozenxid</code> is more than <code class="VARNAME">vacuum_freeze_table_age</code> transactions old, when <code class="COMMAND">VACUUM</code>'s <code class="LITERAL">FREEZE</code> option is used, or when all pages happen to require vacuuming to remove dead row versions. When <code class="COMMAND">VACUUM</code> scans the whole table, after it's finished <code class="LITERAL">age(relfrozenxid)</code> should be a little more than the <code class="VARNAME">vacuum_freeze_min_age</code> setting that was used (more by the number of transactions started since the <code class="COMMAND">VACUUM</code> started). If no whole-table-scanning <code class="COMMAND">VACUUM</code> is issued on the table until <code class="VARNAME">autovacuum_freeze_max_age</code> is reached, an autovacuum will soon be forced for the table.</p> <p>If for some reason autovacuum fails to clear old XIDs from a table, the system will begin to emit warning messages like this when the database's oldest XIDs reach ten million transactions from the wraparound point:</p> <pre class="PROGRAMLISTING" data-language="sql">
WARNING:  database "mydb" must be vacuumed within 177009986 transactions
HINT:  To avoid a database shutdown, execute a database-wide VACUUM in "mydb".
</pre> <p>(A manual <code class="COMMAND">VACUUM</code> should fix the problem, as suggested by the hint; but note that the <code class="COMMAND">VACUUM</code> must be performed by a superuser, else it will fail to process system catalogs and thus not be able to advance the database's <code class="STRUCTFIELD">datfrozenxid</code>.) If these warnings are ignored, the system will shut down and refuse to start any new transactions once there are fewer than 1 million transactions left until wraparound:</p> <pre class="PROGRAMLISTING" data-language="sql">
ERROR:  database is not accepting commands to avoid wraparound data loss in database "mydb"
HINT:  Stop the postmaster and vacuum that database in single-user mode.
</pre> <p>The 1-million-transaction safety margin exists to let the administrator recover without data loss, by manually executing the required <code class="COMMAND">VACUUM</code> commands. However, since the system will not execute commands once it has gone into the safety shutdown mode, the only way to do this is to stop the server and start the server in single-user mode to execute <code class="COMMAND">VACUUM</code>. The shutdown mode is not enforced in single-user mode. See the <a href="../app-postgres/"><span class="APPLICATION">postgres</span></a> reference page for details about using single-user mode.</p> <div class="SECT3"> <h3 class="SECT3" id="VACUUM-FOR-MULTIXACT-WRAPAROUND">23.1.5.1. Multixacts and Wraparound</h3> <p><i class="FIRSTTERM">Multixact IDs</i> are used to support row locking by multiple transactions. Since there is only limited space in a tuple header to store lock information, that information is encoded as a <span class="QUOTE">"multiple transaction ID"</span>, or multixact ID for short, whenever there is more than one transaction concurrently locking a row. Information about which transaction IDs are included in any particular multixact ID is stored separately in the <code class="FILENAME">pg_multixact</code> subdirectory, and only the multixact ID appears in the <code class="STRUCTFIELD">xmax</code> field in the tuple header. Like transaction IDs, multixact IDs are implemented as a 32-bit counter and corresponding storage, all of which requires careful aging management, storage cleanup, and wraparound handling. There is a separate storage area which holds the list of members in each multixact, which also uses a 32-bit counter and which must also be managed.</p> <p>During a <code class="COMMAND">VACUUM</code> table scan, either partial or of the whole table, any multixact ID older than <a href="../runtime-config-client/#GUC-VACUUM-MULTIXACT-FREEZE-MIN-AGE"> vacuum_multixact_freeze_min_age</a> is replaced by a different value, which can be the zero value, a single transaction ID, or a newer multixact ID. For each table, <code class="STRUCTNAME">pg_class</code>.<code class="STRUCTFIELD">relminmxid</code> stores the oldest possible multixact ID still appearing in any tuple of that table. If this value is older than <a href="../runtime-config-client/#GUC-VACUUM-MULTIXACT-FREEZE-TABLE-AGE"> vacuum_multixact_freeze_table_age</a>, a whole-table scan is forced. Whole-table <code class="COMMAND">VACUUM</code> scans, regardless of what causes them, enable advancing the value for that table. Eventually, as all tables in all databases are scanned and their oldest multixact values are advanced, on-disk storage for older multixacts can be removed.</p> <p>As a safety device, a whole-table vacuum scan will occur for any table whose multixact-age is greater than <a href="../runtime-config-autovacuum/#GUC-AUTOVACUUM-MULTIXACT-FREEZE-MAX-AGE"> autovacuum_multixact_freeze_max_age</a>. Whole-table vacuum scans will also occur progressively for all tables, starting with those that have the oldest multixact-age, if the amount of used member storage space exceeds the amount 50% of the addressible storage space. Both of these kinds of whole-table scans will occur even if autovacuum is nominally disabled.</p> </div> </div> <div class="SECT2"> <h2 class="SECT2" id="AUTOVACUUM">23.1.6. The Autovacuum Daemon</h2> <p><span class="PRODUCTNAME">PostgreSQL</span> has an optional but highly recommended feature called <i class="FIRSTTERM">autovacuum</i>, whose purpose is to automate the execution of <code class="COMMAND">VACUUM</code> and <code class="COMMAND">ANALYZE</code> commands. When enabled, autovacuum checks for tables that have had a large number of inserted, updated or deleted tuples. These checks use the statistics collection facility; therefore, autovacuum cannot be used unless <a href="../runtime-config-statistics/#GUC-TRACK-COUNTS">track_counts</a> is set to <code class="LITERAL">true</code>. In the default configuration, autovacuuming is enabled and the related configuration parameters are appropriately set.</p> <p>The <span class="QUOTE">"autovacuum daemon"</span> actually consists of multiple processes. There is a persistent daemon process, called the <i class="FIRSTTERM">autovacuum launcher</i>, which is in charge of starting <i class="FIRSTTERM">autovacuum worker</i> processes for all databases. The launcher will distribute the work across time, attempting to start one worker within each database every <a href="../runtime-config-autovacuum/#GUC-AUTOVACUUM-NAPTIME">autovacuum_naptime</a> seconds. (Therefore, if the installation has <code class="REPLACEABLE c3">N</code> databases, a new worker will be launched every <code class="VARNAME">autovacuum_naptime</code>/<code class="REPLACEABLE c3">N</code> seconds.) A maximum of <a href="../runtime-config-autovacuum/#GUC-AUTOVACUUM-MAX-WORKERS">autovacuum_max_workers</a> worker processes are allowed to run at the same time. If there are more than <code class="VARNAME">autovacuum_max_workers</code> databases to be processed, the next database will be processed as soon as the first worker finishes. Each worker process will check each table within its database and execute <code class="COMMAND">VACUUM</code> and/or <code class="COMMAND">ANALYZE</code> as needed. <code class="VARNAME">log_autovacuum_min_duration</code> can be used to monitor autovacuum activity.</p> <p>If several large tables all become eligible for vacuuming in a short amount of time, all autovacuum workers might become occupied with vacuuming those tables for a long period. This would result in other tables and databases not being vacuumed until a worker became available. There is no limit on how many workers might be in a single database, but workers do try to avoid repeating work that has already been done by other workers. Note that the number of running workers does not count towards <a href="../runtime-config-connection/#GUC-MAX-CONNECTIONS">max_connections</a> or <a href="../runtime-config-connection/#GUC-SUPERUSER-RESERVED-CONNECTIONS"> superuser_reserved_connections</a> limits.</p> <p>Tables whose <code class="STRUCTFIELD">relfrozenxid</code> value is more than <a href="../runtime-config-autovacuum/#GUC-AUTOVACUUM-FREEZE-MAX-AGE">autovacuum_freeze_max_age</a> transactions old are always vacuumed (this also applies to those tables whose freeze max age has been modified via storage parameters; see below). Otherwise, if the number of tuples obsoleted since the last <code class="COMMAND">VACUUM</code> exceeds the <span class="QUOTE">"vacuum threshold"</span>, the table is vacuumed. The vacuum threshold is defined as:</p> <pre class="PROGRAMLISTING" data-language="sql">
vacuum threshold = vacuum base threshold + vacuum scale factor * number of tuples
</pre> <p>where the vacuum base threshold is <a href="../runtime-config-autovacuum/#GUC-AUTOVACUUM-VACUUM-THRESHOLD"> autovacuum_vacuum_threshold</a>, the vacuum scale factor is <a href="../runtime-config-autovacuum/#GUC-AUTOVACUUM-VACUUM-SCALE-FACTOR"> autovacuum_vacuum_scale_factor</a>, and the number of tuples is <code class="STRUCTNAME">pg_class</code>.<code class="STRUCTFIELD">reltuples</code>. The number of obsolete tuples is obtained from the statistics collector; it is a semi-accurate count updated by each <code class="COMMAND">UPDATE</code> and <code class="COMMAND">DELETE</code> operation. (It is only semi-accurate because some information might be lost under heavy load.) If the <code class="STRUCTFIELD">relfrozenxid</code> value of the table is more than <code class="VARNAME">vacuum_freeze_table_age</code> transactions old, the whole table is scanned to freeze old tuples and advance <code class="STRUCTFIELD">relfrozenxid</code>, otherwise only pages that have been modified since the last vacuum are scanned.</p> <p>For analyze, a similar condition is used: the threshold, defined as:</p> <pre class="PROGRAMLISTING" data-language="sql">
analyze threshold = analyze base threshold + analyze scale factor * number of tuples
</pre> <p>is compared to the total number of tuples inserted, updated, or deleted since the last <code class="COMMAND">ANALYZE</code>.</p> <p>Temporary tables cannot be accessed by autovacuum. Therefore, appropriate vacuum and analyze operations should be performed via session SQL commands.</p> <p>The default thresholds and scale factors are taken from <code class="FILENAME">postgresql.conf</code>, but it is possible to override them on a table-by-table basis; see <a class="c4" href="../sql-createtable/#SQL-CREATETABLE-STORAGE-PARAMETERS">Storage Parameters</a> for more information. If a setting has been changed via storage parameters, that value is used; otherwise the global settings are used. See <a href="../runtime-config-autovacuum/">Section 18.10</a> for more details on the global settings.</p> <p>Besides the base threshold values and scale factors, there are six more autovacuum parameters that can be set for each table via storage parameters. The first parameter, <code class="LITERAL">autovacuum_enabled</code>, can be set to <code class="LITERAL">false</code> to instruct the autovacuum daemon to skip that particular table entirely. In this case autovacuum will only touch the table if it must do so to prevent transaction ID wraparound. Another two parameters, <code class="VARNAME">autovacuum_vacuum_cost_delay</code> and <code class="VARNAME">autovacuum_vacuum_cost_limit</code>, are used to set table-specific values for the cost-based vacuum delay feature (see <a href="../runtime-config-resource/#RUNTIME-CONFIG-RESOURCE-VACUUM-COST"> Section 18.4.4</a>). <code class="VARNAME">autovacuum_freeze_min_age</code>, <code class="VARNAME">autovacuum_freeze_max_age</code> and <code class="VARNAME">autovacuum_freeze_table_age</code> are used to set values for <a href="../runtime-config-client/#GUC-VACUUM-FREEZE-MIN-AGE">vacuum_freeze_min_age</a>, <a href="../runtime-config-autovacuum/#GUC-AUTOVACUUM-FREEZE-MAX-AGE">autovacuum_freeze_max_age</a> and <a href="../runtime-config-client/#GUC-VACUUM-FREEZE-TABLE-AGE">vacuum_freeze_table_age</a> respectively.</p> <p>When multiple workers are running, the cost delay parameters are <span class="QUOTE">"balanced"</span> among all the running workers, so that the total I/O impact on the system is the same regardless of the number of workers actually running. However, any workers processing tables whose <code class="LITERAL">autovacuum_vacuum_cost_delay</code> or <code class="LITERAL">autovacuum_vacuum_cost_limit</code> have been set are not considered in the balancing algorithm.</p> </div>  <div class="NAVFOOTER">  <table summary="Footer navigation table"> <tr> <td width="33%" align="left"><a href="https://www.postgresql.org/docs/9.4/static/maintenance.html" accesskey="P" target="_blank">Prev</a></td> <td width="34%" align="center"></td> <td width="33%" align="right"><a href="../routine-reindex/" accesskey="N">Next</a></td> </tr> <tr> <td width="33%" align="left">Routine Database Maintenance Tasks</td> <td width="34%" align="center"><a href="https://www.postgresql.org/docs/9.4/static/maintenance.html" accesskey="U" target="_blank">Up</a></td> <td width="33%" align="right">Routine Reindexing</td> </tr> </table> </div>
<div class="_attribution">
  <p class="_attribution-p">
    Â© 1996â€“2017 The PostgreSQL Global Development Group<br>Licensed under the PostgreSQL License.<br>
    <a href="https://www.postgresql.org/docs/9.4/static/routine-vacuuming.html" class="_attribution-link" target="_blank">https://www.postgresql.org/docs/9.4/static/routine-vacuuming.html</a>
  </p>
</div>

			</div>
		</div>
	</section>

	</div>
</body>
</html>
