
<!DOCTYPE HTML>

<html lang="en">

<head>
  <meta charset="utf-8">
  <title>Authentication Methods - PostgreSQL 9.4 - W3cubDocs</title>
  
  <meta name="description" content=" The following subsections describe the authentication methods in more detail. ">
  <meta name="keywords" content="authentication, methods, -, postgresql, postgresql~9.4">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="http://docs.w3cub.com/postgresql~9.4/auth-methods/">
  <link href="/favicon.png" rel="icon">
  <link type="text/css" rel="stylesheet" href="/assets/application-50364fff564ce3b6327021805f3f00e2957b441cf27f576a7dd4ff63bbc47047.css">
  <script type="text/javascript" src="/assets/application-db64bfd54ceb42be11af7995804cf4902548419ceb79d509b0b7d62c22d98e6f.js"></script>
  <script src="/json/postgresql~9.4.js"></script>
  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-71174418-1']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>


</head>

<body>
	<div class="_app">
	<header class="_header">
  
  <form class="_search">
    <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
    <a class="_search-clear"></a>
    <div class="_search-tag"></div>
  </form>
  
  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/postgresql~9.4/" class="_nav-link" title="" style="margin-left:0;">PostgreSQL 9.4</a></span>
  
  <nav class="_nav">
    <a href="/app/" class="_nav-link ">App</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		<div class="_list">
			
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<div class="_page _postgres">
				
<h1 class="SECT1" id="AUTH-METHODS">19.3. Authentication Methods</h1> <p>The following subsections describe the authentication methods in more detail.</p> <div class="SECT2"> <h2 class="SECT2" id="AUTH-TRUST">19.3.1. Trust Authentication</h2> <p>When <code class="LITERAL">trust</code> authentication is specified, <span class="PRODUCTNAME">PostgreSQL</span> assumes that anyone who can connect to the server is authorized to access the database with whatever database user name they specify (even superuser names). Of course, restrictions made in the <code class="LITERAL">database</code> and <code class="LITERAL">user</code> columns still apply. This method should only be used when there is adequate operating-system-level protection on connections to the server.</p> <p><code class="LITERAL">trust</code> authentication is appropriate and very convenient for local connections on a single-user workstation. It is usually <span class="emphasis EMPHASIS c2">not</span> appropriate by itself on a multiuser machine. However, you might be able to use <code class="LITERAL">trust</code> even on a multiuser machine, if you restrict access to the server's Unix-domain socket file using file-system permissions. To do this, set the <code class="VARNAME">unix_socket_permissions</code> (and possibly <code class="VARNAME">unix_socket_group</code>) configuration parameters as described in <a href="../runtime-config-connection/">Section 18.3</a>. Or you could set the <code class="VARNAME">unix_socket_directories</code> configuration parameter to place the socket file in a suitably restricted directory.</p> <p>Setting file-system permissions only helps for Unix-socket connections. Local TCP/IP connections are not restricted by file-system permissions. Therefore, if you want to use file-system permissions for local security, remove the <code class="LITERAL">host ... 127.0.0.1 ...</code> line from <code class="FILENAME">pg_hba.conf</code>, or change it to a non-<code class="LITERAL">trust</code> authentication method.</p> <p><code class="LITERAL">trust</code> authentication is only suitable for TCP/IP connections if you trust every user on every machine that is allowed to connect to the server by the <code class="FILENAME">pg_hba.conf</code> lines that specify <code class="LITERAL">trust</code>. It is seldom reasonable to use <code class="LITERAL">trust</code> for any TCP/IP connections other than those from <span class="SYSTEMITEM">localhost</span> (127.0.0.1).</p> </div> <div class="SECT2"> <h2 class="SECT2" id="AUTH-PASSWORD">19.3.2. Password Authentication</h2> <p>The password-based authentication methods are <code class="LITERAL">md5</code> and <code class="LITERAL">password</code>. These methods operate similarly except for the way that the password is sent across the connection, namely MD5-hashed and clear-text respectively.</p> <p>If you are at all concerned about password <span class="QUOTE">"sniffing"</span> attacks then <code class="LITERAL">md5</code> is preferred. Plain <code class="LITERAL">password</code> should always be avoided if possible. However, <code class="LITERAL">md5</code> cannot be used with the <a href="../runtime-config-connection/#GUC-DB-USER-NAMESPACE">db_user_namespace</a> feature. If the connection is protected by SSL encryption then <code class="LITERAL">password</code> can be used safely (though SSL certificate authentication might be a better choice if one is depending on using SSL).</p> <p><span class="PRODUCTNAME">PostgreSQL</span> database passwords are separate from operating system user passwords. The password for each database user is stored in the <code class="LITERAL">pg_authid</code> system catalog. Passwords can be managed with the SQL commands <a href="../sql-createuser/">CREATE USER</a> and <a href="../sql-alterrole/">ALTER ROLE</a>, e.g., <kbd class="USERINPUT">CREATE USER foo WITH PASSWORD 'secret'</kbd>. If no password has been set up for a user, the stored password is null and password authentication will always fail for that user.</p> </div> <div class="SECT2"> <h2 class="SECT2" id="GSSAPI-AUTH">19.3.3. GSSAPI Authentication</h2> <p><span class="PRODUCTNAME">GSSAPI</span> is an industry-standard protocol for secure authentication defined in RFC 2743. <span class="PRODUCTNAME">PostgreSQL</span> supports <span class="PRODUCTNAME">GSSAPI</span> with <span class="PRODUCTNAME">Kerberos</span> authentication according to RFC 1964. <span class="PRODUCTNAME">GSSAPI</span> provides automatic authentication (single sign-on) for systems that support it. The authentication itself is secure, but the data sent over the database connection will be sent unencrypted unless <acronym class="ACRONYM">SSL</acronym> is used.</p> <p>GSSAPI support has to be enabled when <span class="PRODUCTNAME">PostgreSQL</span> is built; see <a href="https://www.postgresql.org/docs/9.4/static/installation.html" target="_blank">Chapter 15</a> for more information.</p> <p>When <span class="PRODUCTNAME">GSSAPI</span> uses <span class="PRODUCTNAME">Kerberos</span>, it uses a standard principal in the format <code class="LITERAL"><code class="REPLACEABLE c3">servicename</code>/<code class="REPLACEABLE c3">hostname</code>@<code class="REPLACEABLE c3">realm</code></code>. The PostgreSQL server will accept any principal that is included in the keytab used by the server, but care needs to be taken to specify the correct principal details when making the connection from the client using the <code class="LITERAL">krbsrvname</code> connection parameter. (See also <a href="https://www.postgresql.org/docs/9.4/static/libpq-connect.html#LIBPQ-PARAMKEYWORDS" target="_blank">Section 31.1.2</a>.) The installation default can be changed from the default <code class="LITERAL">postgres</code> at build time using <code class="LITERAL">./configure --with-krb-srvnam=</code><code class="REPLACEABLE c3">whatever</code>. In most environments, this parameter never needs to be changed. Some Kerberos implementations might require a different service name, such as Microsoft Active Directory which requires the service name to be in upper case (<code class="LITERAL">POSTGRES</code>).</p> <p><code class="REPLACEABLE c3">hostname</code> is the fully qualified host name of the server machine. The service principal's realm is the preferred realm of the server machine.</p> <p>Client principals must have their <span class="PRODUCTNAME">PostgreSQL</span> database user name as their first component, for example <code class="LITERAL">pgusername@realm</code>. Alternatively, you can use a user name mapping to map from the first component of the principal name to the database user name. By default, the realm of the client is not checked by <span class="PRODUCTNAME">PostgreSQL</span>. If you have cross-realm authentication enabled and need to verify the realm, use the <code class="LITERAL">krb_realm</code> parameter, or enable <code class="LITERAL">include_realm</code> and use user name mapping to check the realm.</p> <p>Make sure that your server keytab file is readable (and preferably only readable) by the <span class="PRODUCTNAME">PostgreSQL</span> server account. (See also <a href="../postgres-user/">Section 17.1</a>.) The location of the key file is specified by the <a href="../runtime-config-connection/#GUC-KRB-SERVER-KEYFILE">krb_server_keyfile</a> configuration parameter. The default is <code class="FILENAME">/usr/local/pgsql/etc/krb5.keytab</code> (or whatever directory was specified as <code class="VARNAME">sysconfdir</code> at build time). For security reasons, it is recommended to use a separate keytab just for the <span class="PRODUCTNAME">PostgreSQL</span> server rather than opening up permissions on the system keytab file.</p> <p>The keytab file is generated by the Kerberos software; see the Kerberos documentation for details. The following example is for MIT-compatible Kerberos 5 implementations:</p> <pre class="SCREEN">
<samp class="PROMPT">kadmin% </samp>ank -randkey postgres/server.my.domain.org
<samp class="PROMPT">kadmin% </samp>ktadd -k krb5.keytab postgres/server.my.domain.org
</pre> <p>When connecting to the database make sure you have a ticket for a principal matching the requested database user name. For example, for database user name <code class="LITERAL">fred</code>, principal <code class="LITERAL">fred@EXAMPLE.COM</code> would be able to connect. To also allow principal <code class="LITERAL">fred/users.example.com@EXAMPLE.COM</code>, use a user name map, as described in <a href="../auth-username-maps/">Section 19.2</a>.</p> <p>The following configuration options are supported for <span class="PRODUCTNAME">GSSAPI</span>:</p> <div class="VARIABLELIST"> <dl> <dt><code class="LITERAL">include_realm</code></dt> <dd> <p>If set to 1, the realm name from the authenticated user principal is included in the system user name that's passed through user name mapping (<a href="../auth-username-maps/">Section 19.2</a>). This is the recommended configuration as, otherwise, it is impossible to differentiate users with the same username who are from different realms. The default for this parameter is 0 (meaning to not include the realm in the system user name) but may change to 1 in a future version of <span class="PRODUCTNAME">PostgreSQL</span>. Users can set it explicitly to avoid any issues when upgrading.</p> </dd> <dt><code class="LITERAL">map</code></dt> <dd> <p>Allows for mapping between system and database user names. See <a href="../auth-username-maps/">Section 19.2</a> for details. For a GSSAPI/Kerberos principal, such as <code class="LITERAL">username@EXAMPLE.COM</code> (or, less commonly, <code class="LITERAL">username/hostbased@EXAMPLE.COM</code>), the default user name used for mapping is <code class="LITERAL">username</code> (or <code class="LITERAL">username/hostbased</code>, respectively), unless <code class="LITERAL">include_realm</code> has been set to 1 (as recommended, see above), in which case <code class="LITERAL">username@EXAMPLE.COM</code> (or <code class="LITERAL">username/hostbased@EXAMPLE.COM</code>) is what is seen as the system username when mapping.</p> </dd> <dt><code class="LITERAL">krb_realm</code></dt> <dd> <p>Sets the realm to match user principal names against. If this parameter is set, only users of that realm will be accepted. If it is not set, users of any realm can connect, subject to whatever user name mapping is done.</p> </dd> </dl> </div> </div> <div class="SECT2"> <h2 class="SECT2" id="SSPI-AUTH">19.3.4. SSPI Authentication</h2> <p><span class="PRODUCTNAME">SSPI</span> is a <span class="PRODUCTNAME">Windows</span> technology for secure authentication with single sign-on. <span class="PRODUCTNAME">PostgreSQL</span> will use SSPI in <code class="LITERAL">negotiate</code> mode, which will use <span class="PRODUCTNAME">Kerberos</span> when possible and automatically fall back to <span class="PRODUCTNAME">NTLM</span> in other cases. <span class="PRODUCTNAME">SSPI</span> authentication only works when both server and client are running <span class="PRODUCTNAME">Windows</span>, or, on non-Windows platforms, when <span class="PRODUCTNAME">GSSAPI</span> is available.</p> <p>When using <span class="PRODUCTNAME">Kerberos</span> authentication, <span class="PRODUCTNAME">SSPI</span> works the same way <span class="PRODUCTNAME">GSSAPI</span> does; see <a href="../auth-methods/#GSSAPI-AUTH">Section 19.3.3</a> for details.</p> <p>The following configuration options are supported for <span class="PRODUCTNAME">SSPI</span>:</p> <div class="VARIABLELIST"> <dl> <dt><code class="LITERAL">include_realm</code></dt> <dd> <p>If set to 1, the realm name from the authenticated user principal is included in the system user name that's passed through user name mapping (<a href="../auth-username-maps/">Section 19.2</a>). This is the recommended configuration as, otherwise, it is impossible to differentiate users with the same username who are from different realms. The default for this parameter is 0 (meaning to not include the realm in the system user name) but may change to 1 in a future version of <span class="PRODUCTNAME">PostgreSQL</span>. Users can set it explicitly to avoid any issues when upgrading.</p> </dd> <dt><code class="LITERAL">map</code></dt> <dd> <p>Allows for mapping between system and database user names. See <a href="../auth-username-maps/">Section 19.2</a> for details. For a SSPI/Kerberos principal, such as <code class="LITERAL">username@EXAMPLE.COM</code> (or, less commonly, <code class="LITERAL">username/hostbased@EXAMPLE.COM</code>), the default user name used for mapping is <code class="LITERAL">username</code> (or <code class="LITERAL">username/hostbased</code>, respectively), unless <code class="LITERAL">include_realm</code> has been set to 1 (as recommended, see above), in which case <code class="LITERAL">username@EXAMPLE.COM</code> (or <code class="LITERAL">username/hostbased@EXAMPLE.COM</code>) is what is seen as the system username when mapping.</p> </dd> <dt><code class="LITERAL">krb_realm</code></dt> <dd> <p>Sets the realm to match user principal names against. If this parameter is set, only users of that realm will be accepted. If it is not set, users of any realm can connect, subject to whatever user name mapping is done.</p> </dd> </dl> </div> </div> <div class="SECT2"> <h2 class="SECT2" id="AUTH-IDENT">19.3.5. Ident Authentication</h2> <p>The ident authentication method works by obtaining the client's operating system user name from an ident server and using it as the allowed database user name (with an optional user name mapping). This is only supported on TCP/IP connections.</p>  <blockquote class="NOTE"> <p><b>Note:</b> When ident is specified for a local (non-TCP/IP) connection, peer authentication (see <a href="../auth-methods/#AUTH-PEER">Section 19.3.6</a>) will be used instead.</p> </blockquote>  <p>The following configuration options are supported for <span class="PRODUCTNAME">ident</span>:</p> <div class="VARIABLELIST"> <dl> <dt><code class="LITERAL">map</code></dt> <dd> <p>Allows for mapping between system and database user names. See <a href="../auth-username-maps/">Section 19.2</a> for details.</p> </dd> </dl> </div> <p>The <span class="QUOTE">"Identification Protocol"</span> is described in RFC 1413. Virtually every Unix-like operating system ships with an ident server that listens on TCP port 113 by default. The basic functionality of an ident server is to answer questions like <span class="QUOTE">"What user initiated the connection that goes out of your port <code class="REPLACEABLE c3">X</code> and connects to my port <code class="REPLACEABLE c3">Y</code>?"</span>. Since <span class="PRODUCTNAME">PostgreSQL</span> knows both <code class="REPLACEABLE c3">X</code> and <code class="REPLACEABLE c3">Y</code> when a physical connection is established, it can interrogate the ident server on the host of the connecting client and can theoretically determine the operating system user for any given connection.</p> <p id="AEN34571">The drawback of this procedure is that it depends on the integrity of the client: if the client machine is untrusted or compromised, an attacker could run just about any program on port 113 and return any user name he chooses. This authentication method is therefore only appropriate for closed networks where each client machine is under tight control and where the database and system administrators operate in close contact. In other words, you must trust the machine running the ident server. Heed the warning: </p> <table class="BLOCKQUOTE"> <tr> <td width="10%"> </td> <td> <p>The Identification Protocol is not intended as an authorization or access control protocol.</p> </td> <td width="10%"> </td> </tr> <tr> <td colspan="2" align="right">--<span class="ATTRIBUTION">RFC 1413</span>
</td> <td width="10%"> </td> </tr> </table> <p>Some ident servers have a nonstandard option that causes the returned user name to be encrypted, using a key that only the originating machine's administrator knows. This option <span class="emphasis EMPHASIS c2">must not</span> be used when using the ident server with <span class="PRODUCTNAME">PostgreSQL</span>, since <span class="PRODUCTNAME">PostgreSQL</span> does not have any way to decrypt the returned string to determine the actual user name.</p> </div> <div class="SECT2"> <h2 class="SECT2" id="AUTH-PEER">19.3.6. Peer Authentication</h2> <p>The peer authentication method works by obtaining the client's operating system user name from the kernel and using it as the allowed database user name (with optional user name mapping). This method is only supported on local connections.</p> <p>The following configuration options are supported for <span class="PRODUCTNAME">peer</span>:</p> <div class="VARIABLELIST"> <dl> <dt><code class="LITERAL">map</code></dt> <dd> <p>Allows for mapping between system and database user names. See <a href="../auth-username-maps/">Section 19.2</a> for details.</p> </dd> </dl> </div> <p>Peer authentication is only available on operating systems providing the <code class="FUNCTION">getpeereid()</code> function, the <code class="SYMBOL">SO_PEERCRED</code> socket parameter, or similar mechanisms. Currently that includes <span class="SYSTEMITEM">Linux</span>, most flavors of <span class="SYSTEMITEM">BSD</span> including <span class="SYSTEMITEM">OS X</span>, and <span class="SYSTEMITEM">Solaris</span>.</p> </div> <div class="SECT2"> <h2 class="SECT2" id="AUTH-LDAP">19.3.7. LDAP Authentication</h2> <p>This authentication method operates similarly to <code class="LITERAL">password</code> except that it uses LDAP as the password verification method. LDAP is used only to validate the user name/password pairs. Therefore the user must already exist in the database before LDAP can be used for authentication.</p> <p>LDAP authentication can operate in two modes. In the first mode, which we will call the simple bind mode, the server will bind to the distinguished name constructed as <code class="REPLACEABLE c3">prefix</code> <code class="REPLACEABLE c3">username</code> <code class="REPLACEABLE c3">suffix</code>. Typically, the <code class="REPLACEABLE c3">prefix</code> parameter is used to specify <code class="LITERAL">cn=</code>, or <code class="REPLACEABLE c3">DOMAIN</code><code class="LITERAL">\</code> in an Active Directory environment. <code class="REPLACEABLE c3">suffix</code> is used to specify the remaining part of the DN in a non-Active Directory environment.</p> <p>In the second mode, which we will call the search+bind mode, the server first binds to the LDAP directory with a fixed user name and password, specified with <code class="REPLACEABLE c3">ldapbinddn</code> and <code class="REPLACEABLE c3">ldapbindpasswd</code>, and performs a search for the user trying to log in to the database. If no user and password is configured, an anonymous bind will be attempted to the directory. The search will be performed over the subtree at <code class="REPLACEABLE c3">ldapbasedn</code>, and will try to do an exact match of the attribute specified in <code class="REPLACEABLE c3">ldapsearchattribute</code>. Once the user has been found in this search, the server disconnects and re-binds to the directory as this user, using the password specified by the client, to verify that the login is correct. This mode is the same as that used by LDAP authentication schemes in other software, such as Apache mod_authnz_ldap and pam_ldap. This method allows for significantly more flexibility in where the user objects are located in the directory, but will cause two separate connections to the LDAP server to be made.</p> <p>The following configuration options are used in both modes:</p> <div class="VARIABLELIST"> <dl> <dt><code class="LITERAL">ldapserver</code></dt> <dd> <p>Names or IP addresses of LDAP servers to connect to. Multiple servers may be specified, separated by spaces.</p> </dd> <dt><code class="LITERAL">ldapport</code></dt> <dd> <p>Port number on LDAP server to connect to. If no port is specified, the LDAP library's default port setting will be used.</p> </dd> <dt><code class="LITERAL">ldaptls</code></dt> <dd> <p>Set to 1 to make the connection between PostgreSQL and the LDAP server use TLS encryption. Note that this only encrypts the traffic to the LDAP server — the connection to the client will still be unencrypted unless SSL is used.</p> </dd> </dl> </div> <p>The following options are used in simple bind mode only:</p> <div class="VARIABLELIST"> <dl> <dt><code class="LITERAL">ldapprefix</code></dt> <dd> <p>String to prepend to the user name when forming the DN to bind as, when doing simple bind authentication.</p> </dd> <dt><code class="LITERAL">ldapsuffix</code></dt> <dd> <p>String to append to the user name when forming the DN to bind as, when doing simple bind authentication.</p> </dd> </dl> </div> <p>The following options are used in search+bind mode only:</p> <div class="VARIABLELIST"> <dl> <dt><code class="LITERAL">ldapbasedn</code></dt> <dd> <p>Root DN to begin the search for the user in, when doing search+bind authentication.</p> </dd> <dt><code class="LITERAL">ldapbinddn</code></dt> <dd> <p>DN of user to bind to the directory with to perform the search when doing search+bind authentication.</p> </dd> <dt><code class="LITERAL">ldapbindpasswd</code></dt> <dd> <p>Password for user to bind to the directory with to perform the search when doing search+bind authentication.</p> </dd> <dt><code class="LITERAL">ldapsearchattribute</code></dt> <dd> <p>Attribute to match against the user name in the search when doing search+bind authentication. If no attribute is specified, the <code class="LITERAL">uid</code> attribute will be used.</p> </dd> <dt><code class="LITERAL">ldapurl</code></dt> <dd> <p>An RFC 4516 LDAP URL. This is an alternative way to write some of the other LDAP options in a more compact and standard form. The format is</p> <pre class="SYNOPSIS" data-language="sql">
ldap://host[:port]/basedn[?[attribute][?[scope]]]
</pre> <p><code class="REPLACEABLE c3">scope</code> must be one of <code class="LITERAL">base</code>, <code class="LITERAL">one</code>, <code class="LITERAL">sub</code>, typically the latter. Only one attribute is used, and some other components of standard LDAP URLs such as filters and extensions are not supported.</p> <p>For non-anonymous binds, <code class="LITERAL">ldapbinddn</code> and <code class="LITERAL">ldapbindpasswd</code> must be specified as separate options.</p> <p>To use encrypted LDAP connections, the <code class="LITERAL">ldaptls</code> option has to be used in addition to <code class="LITERAL">ldapurl</code>. The <code class="LITERAL">ldaps</code> URL scheme (direct SSL connection) is not supported.</p> <p>LDAP URLs are currently only supported with OpenLDAP, not on Windows.</p> </dd> </dl> </div> <p>It is an error to mix configuration options for simple bind with options for search+bind.</p> <p>Here is an example for a simple-bind LDAP configuration:</p> <pre class="PROGRAMLISTING" data-language="sql">
host ... ldap ldapserver=ldap.example.net ldapprefix="cn=" ldapsuffix=", dc=example, dc=net"
</pre> <p>When a connection to the database server as database user <code class="LITERAL">someuser</code> is requested, PostgreSQL will attempt to bind to the LDAP server using the DN <code class="LITERAL">cn=someuser, dc=example, dc=net</code> and the password provided by the client. If that connection succeeds, the database access is granted.</p> <p>Here is an example for a search+bind configuration:</p> <pre class="PROGRAMLISTING" data-language="sql">
host ... ldap ldapserver=ldap.example.net ldapbasedn="dc=example, dc=net" ldapsearchattribute=uid
</pre> <p>When a connection to the database server as database user <code class="LITERAL">someuser</code> is requested, PostgreSQL will attempt to bind anonymously (since <code class="LITERAL">ldapbinddn</code> was not specified) to the LDAP server, perform a search for <code class="LITERAL">(uid=someuser)</code> under the specified base DN. If an entry is found, it will then attempt to bind using that found information and the password supplied by the client. If that second connection succeeds, the database access is granted.</p> <p>Here is the same search+bind configuration written as a URL:</p> <pre class="PROGRAMLISTING" data-language="sql">
host ... ldap ldapurl="ldap://ldap.example.net/dc=example,dc=net?uid?sub"
</pre> <p>Some other software that supports authentication against LDAP uses the same URL format, so it will be easier to share the configuration.</p> <div class="TIP"> <blockquote class="TIP"> <p><b>Tip:</b> Since LDAP often uses commas and spaces to separate the different parts of a DN, it is often necessary to use double-quoted parameter values when configuring LDAP options, as shown in the examples.</p> </blockquote> </div> </div> <div class="SECT2"> <h2 class="SECT2" id="AUTH-RADIUS">19.3.8. RADIUS Authentication</h2> <p>This authentication method operates similarly to <code class="LITERAL">password</code> except that it uses RADIUS as the password verification method. RADIUS is used only to validate the user name/password pairs. Therefore the user must already exist in the database before RADIUS can be used for authentication.</p> <p>When using RADIUS authentication, an Access Request message will be sent to the configured RADIUS server. This request will be of type <code class="LITERAL">Authenticate Only</code>, and include parameters for <code class="LITERAL">user name</code>, <code class="LITERAL">password</code> (encrypted) and <code class="LITERAL">NAS Identifier</code>. The request will be encrypted using a secret shared with the server. The RADIUS server will respond to this server with either <code class="LITERAL">Access Accept</code> or <code class="LITERAL">Access Reject</code>. There is no support for RADIUS accounting.</p> <p>The following configuration options are supported for RADIUS:</p> <div class="VARIABLELIST"> <dl> <dt><code class="LITERAL">radiusserver</code></dt> <dd> <p>The name or IP address of the RADIUS server to connect to. This parameter is required.</p> </dd> <dt><code class="LITERAL">radiussecret</code></dt> <dd> <p>The shared secret used when talking securely to the RADIUS server. This must have exactly the same value on the PostgreSQL and RADIUS servers. It is recommended that this be a string of at least 16 characters. This parameter is required.</p>  <blockquote class="NOTE"> <p><b>Note:</b> The encryption vector used will only be cryptographically strong if <span class="PRODUCTNAME">PostgreSQL</span> is built with support for <span class="PRODUCTNAME">OpenSSL</span>. In other cases, the transmission to the RADIUS server should only be considered obfuscated, not secured, and external security measures should be applied if necessary.</p> </blockquote>  </dd> <dt><code class="LITERAL">radiusport</code></dt> <dd> <p>The port number on the RADIUS server to connect to. If no port is specified, the default port <code class="LITERAL">1812</code> will be used.</p> </dd> <dt><code class="LITERAL">radiusidentifier</code></dt> <dd> <p>The string used as <code class="LITERAL">NAS Identifier</code> in the RADIUS requests. This parameter can be used as a second parameter identifying for example which database user the user is attempting to authenticate as, which can be used for policy matching on the RADIUS server. If no identifier is specified, the default <code class="LITERAL">postgresql</code> will be used.</p> </dd> </dl> </div> </div> <div class="SECT2"> <h2 class="SECT2" id="AUTH-CERT">19.3.9. Certificate Authentication</h2> <p>This authentication method uses SSL client certificates to perform authentication. It is therefore only available for SSL connections. When using this authentication method, the server will require that the client provide a valid certificate. No password prompt will be sent to the client. The <code class="LITERAL">cn</code> (Common Name) attribute of the certificate will be compared to the requested database user name, and if they match the login will be allowed. User name mapping can be used to allow <code class="LITERAL">cn</code> to be different from the database user name.</p> <p>The following configuration options are supported for SSL certificate authentication:</p> <div class="VARIABLELIST"> <dl> <dt><code class="LITERAL">map</code></dt> <dd> <p>Allows for mapping between system and database user names. See <a href="../auth-username-maps/">Section 19.2</a> for details.</p> </dd> </dl> </div> </div> <div class="SECT2"> <h2 class="SECT2" id="AUTH-PAM">19.3.10. PAM Authentication</h2> <p>This authentication method operates similarly to <code class="LITERAL">password</code> except that it uses PAM (Pluggable Authentication Modules) as the authentication mechanism. The default PAM service name is <code class="LITERAL">postgresql</code>. PAM is used only to validate user name/password pairs. Therefore the user must already exist in the database before PAM can be used for authentication. For more information about PAM, please read the <a href="http://www.kernel.org/pub/linux/libs/pam/" target="_blank"><span class="PRODUCTNAME">Linux-PAM</span> Page</a>.</p> <p>The following configuration options are supported for PAM:</p> <div class="VARIABLELIST"> <dl> <dt><code class="LITERAL">pamservice</code></dt> <dd> <p>PAM service name.</p> </dd> </dl> </div>  <blockquote class="NOTE"> <p><b>Note:</b> If PAM is set up to read <code class="FILENAME">/etc/shadow</code>, authentication will fail because the PostgreSQL server is started by a non-root user. However, this is not an issue when PAM is configured to use LDAP or other authentication methods.</p> </blockquote>  </div>  <div class="NAVFOOTER">  <table summary="Footer navigation table"> <tr> <td width="33%" align="left"><a href="../auth-username-maps/" accesskey="P">Prev</a></td> <td width="34%" align="center"></td> <td width="33%" align="right"><a href="../client-authentication-problems/" accesskey="N">Next</a></td> </tr> <tr> <td width="33%" align="left">User Name Maps</td> <td width="34%" align="center"><a href="https://www.postgresql.org/docs/9.4/static/client-authentication.html" accesskey="U" target="_blank">Up</a></td> <td width="33%" align="right">Authentication Problems</td> </tr> </table> </div>
<div class="_attribution">
  <p class="_attribution-p">
    © 1996–2017 The PostgreSQL Global Development Group<br>Licensed under the PostgreSQL License.<br>
    <a href="https://www.postgresql.org/docs/9.4/static/auth-methods.html" class="_attribution-link" target="_blank">https://www.postgresql.org/docs/9.4/static/auth-methods.html</a>
  </p>
</div>

			</div>
		</div>
	</section>

	</div>
</body>
</html>
