
<!DOCTYPE HTML>

<html lang="en">

<head>
  <meta charset="utf-8">
  <title>JSON Functions and Operators - PostgreSQL 9.4 - W3cubDocs</title>
  
  <meta name="description" content=" Table 9-40 shows the operators that are available for use with the two JSON data types (see Section 8.14). ">
  <meta name="keywords" content="json, functions, and, operators, -, postgresql, postgresql~9.4">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="http://docs.w3cub.com/postgresql~9.4/functions-json/">
  <link href="/favicon.png" rel="icon">
  <link type="text/css" rel="stylesheet" href="/assets/application-50364fff564ce3b6327021805f3f00e2957b441cf27f576a7dd4ff63bbc47047.css">
  <script type="text/javascript" src="/assets/application-db64bfd54ceb42be11af7995804cf4902548419ceb79d509b0b7d62c22d98e6f.js"></script>
  <script src="/json/postgresql~9.4.js"></script>
  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-71174418-1']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>


</head>

<body>
	<div class="_app">
	<header class="_header">
  
  <form class="_search">
    <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
    <a class="_search-clear"></a>
    <div class="_search-tag"></div>
  </form>
  
  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/postgresql~9.4/" class="_nav-link" title="" style="margin-left:0;">PostgreSQL 9.4</a></span>
  
  <nav class="_nav">
    <a href="/app/" class="_nav-link ">App</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		<div class="_list">
			
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<div class="_page _postgres">
				
<h1 class="SECT1" id="FUNCTIONS-JSON">9.15. JSON Functions and Operators</h1> <p><a href="../functions-json/#FUNCTIONS-JSON-OP-TABLE">Table 9-40</a> shows the operators that are available for use with the two JSON data types (see <a href="../datatype-json/">Section 8.14</a>).</p> <div class="TABLE" id="FUNCTIONS-JSON-OP-TABLE">  <p class="c2">Table 9-40. <code class="TYPE">json</code> and <code class="TYPE">jsonb</code> Operators</p> <table class="CALSTABLE"> <col> <col> <col> <col> <col> <thead> <tr> <th>Operator</th> <th>Right Operand Type</th> <th>Description</th> <th>Example</th> <th>Example Result</th> </tr> </thead> <tbody> <tr> <td><code class="LITERAL" id="62">-&gt;</code></td> <td><code class="TYPE">int</code></td> <td>Get JSON array element (indexed from zero)</td> <td><code class="LITERAL">'[{"a":"foo"},{"b":"bar"},{"c":"baz"}]'::json-&gt;2</code></td> <td><code class="LITERAL">{"c":"baz"}</code></td> </tr> <tr> <td><code class="LITERAL">-&gt;</code></td> <td><code class="TYPE">text</code></td> <td>Get JSON object field by key</td> <td><code class="LITERAL">'{"a": {"b":"foo"}}'::json-&gt;'a'</code></td> <td><code class="LITERAL">{"b":"foo"}</code></td> </tr> <tr> <td><code class="LITERAL" id="6262">-&gt;&gt;</code></td> <td><code class="TYPE">int</code></td> <td>Get JSON array element as <code class="TYPE">text</code>
</td> <td><code class="LITERAL">'[1,2,3]'::json-&gt;&gt;2</code></td> <td><code class="LITERAL">3</code></td> </tr> <tr> <td><code class="LITERAL">-&gt;&gt;</code></td> <td><code class="TYPE">text</code></td> <td>Get JSON object field as <code class="TYPE">text</code>
</td> <td><code class="LITERAL">'{"a":1,"b":2}'::json-&gt;&gt;'b'</code></td> <td><code class="LITERAL">2</code></td> </tr> <tr> <td><code class="LITERAL" id="3562">#&gt;</code></td> <td><code class="TYPE">text[]</code></td> <td>Get JSON object at specified path</td> <td><code class="LITERAL">'{"a": {"b":{"c": "foo"}}}'::json#&gt;'{a,b}'</code></td> <td><code class="LITERAL">{"c": "foo"}</code></td> </tr> <tr> <td><code class="LITERAL" id="356262">#&gt;&gt;</code></td> <td><code class="TYPE">text[]</code></td> <td>Get JSON object at specified path as <code class="TYPE">text</code>
</td> <td><code class="LITERAL">'{"a":[1,2,3],"b":[4,5,6]}'::json#&gt;&gt;'{a,2}'</code></td> <td><code class="LITERAL">3</code></td> </tr> </tbody> </table> </div>  <blockquote class="NOTE"> <p><b>Note:</b> There are parallel variants of these operators for both the <code class="TYPE">json</code> and <code class="TYPE">jsonb</code> types. The field/element/path extraction operators return the same type as their left-hand input (either <code class="TYPE">json</code> or <code class="TYPE">jsonb</code>), except for those specified as returning <code class="TYPE">text</code>, which coerce the value to text. The field/element/path extraction operators return NULL, rather than failing, if the JSON input does not have the right structure to match the request; for example if no such element exists.</p> </blockquote>  <p>The standard comparison operators shown in <a href="../functions-comparison/#FUNCTIONS-COMPARISON-TABLE">Table 9-1</a> are available for <code class="TYPE">jsonb</code>, but not for <code class="TYPE">json</code>. They follow the ordering rules for B-tree operations outlined at <a href="../datatype-json/#JSON-INDEXING">Section 8.14.4</a>.</p> <p>Some further operators also exist only for <code class="TYPE">jsonb</code>, as shown in <a href="../functions-json/#FUNCTIONS-JSONB-OP-TABLE">Table 9-41</a>. Many of these operators can be indexed by <code class="TYPE">jsonb</code> operator classes. For a full description of <code class="TYPE">jsonb</code> containment and existence semantics, see <a href="../datatype-json/#JSON-CONTAINMENT">Section 8.14.3</a>. <a href="../datatype-json/#JSON-INDEXING">Section 8.14.4</a> describes how these operators can be used to effectively index <code class="TYPE">jsonb</code> data.</p> <div class="TABLE" id="FUNCTIONS-JSONB-OP-TABLE">  <p class="c2">Table 9-41. Additional <code class="TYPE">jsonb</code> Operators</p> <table class="CALSTABLE"> <col> <col> <col> <col> <thead> <tr> <th>Operator</th> <th>Right Operand Type</th> <th>Description</th> <th>Example</th> </tr> </thead> <tbody> <tr> <td><code class="LITERAL" id="6462">@&gt;</code></td> <td><code class="TYPE">jsonb</code></td> <td>Does the left JSON value contain within it the right value?</td> <td><code class="LITERAL">'{"a":1, "b":2}'::jsonb @&gt; '{"b":2}'::jsonb</code></td> </tr> <tr> <td><code class="LITERAL" id="6064">&lt;@</code></td> <td><code class="TYPE">jsonb</code></td> <td>Is the left JSON value contained within the right value?</td> <td><code class="LITERAL">'{"b":2}'::jsonb &lt;@ '{"a":1, "b":2}'::jsonb</code></td> </tr> <tr> <td><code class="LITERAL" id="63">?</code></td> <td><code class="TYPE">text</code></td> <td>Does the key/element <span class="emphasis EMPHASIS c3">string</span> exist within the JSON value?</td> <td><code class="LITERAL">'{"a":1, "b":2}'::jsonb ? 'b'</code></td> </tr> <tr> <td><code class="LITERAL" id="63124">?|</code></td> <td><code class="TYPE">text[]</code></td> <td>Do any of these key/element <span class="emphasis EMPHASIS c3">strings</span> exist?</td> <td><code class="LITERAL">'{"a":1, "b":2, "c":3}'::jsonb ?| array['b', 'c']</code></td> </tr> <tr> <td><code class="LITERAL" id="6338">?&amp;</code></td> <td><code class="TYPE">text[]</code></td> <td>Do all of these key/element <span class="emphasis EMPHASIS c3">strings</span> exist?</td> <td><code class="LITERAL">'["a", "b"]'::jsonb ?&amp; array['a', 'b']</code></td> </tr> </tbody> </table> </div> <p><a href="../functions-json/#FUNCTIONS-JSON-CREATION-TABLE">Table 9-42</a> shows the functions that are available for creating <code class="TYPE">json</code> values. (Currently, there are no equivalent functions for <code class="TYPE">jsonb</code>, but you can cast the result of one of these functions to <code class="TYPE">jsonb</code>.)</p> <div class="TABLE" id="FUNCTIONS-JSON-CREATION-TABLE">  <p class="c2">Table 9-42. JSON Creation Functions</p> <table class="CALSTABLE"> <col> <col> <col> <col> <thead> <tr> <th>Function</th> <th>Description</th> <th>Example</th> <th>Example Result</th> </tr> </thead> <tbody> <tr> <td><code class="LITERAL" id="to_json">to_json(anyelement)</code></td> <td>Returns the value as JSON. Arrays and composites are converted (recursively) to arrays and objects; otherwise, if there is a cast from the type to <code class="TYPE">json</code>, the cast function will be used to perform the conversion; otherwise, a JSON scalar value is produced. For any scalar type other than a number, a Boolean, or a null value, the text representation will be used, properly quoted and escaped so that it is a valid JSON string.</td> <td><code class="LITERAL">to_json('Fred said "Hi."'::text)</code></td> <td><code class="LITERAL">"Fred said \"Hi.\""</code></td> </tr> <tr> <td><code class="LITERAL" id="array_to_json">array_to_json(anyarray [, pretty_bool])</code></td> <td>Returns the array as a JSON array. A PostgreSQL multidimensional array becomes a JSON array of arrays. Line feeds will be added between dimension-1 elements if <code class="PARAMETER">pretty_bool</code> is true.</td> <td><code class="LITERAL">array_to_json('{{1,5},{99,100}}'::int[])</code></td> <td><code class="LITERAL">[[1,5],[99,100]]</code></td> </tr> <tr> <td><code class="LITERAL" id="row_to_json">row_to_json(record [, pretty_bool])</code></td> <td>Returns the row as a JSON object. Line feeds will be added between level-1 elements if <code class="PARAMETER">pretty_bool</code> is true.</td> <td><code class="LITERAL">row_to_json(row(1,'foo'))</code></td> <td><code class="LITERAL">{"f1":1,"f2":"foo"}</code></td> </tr> <tr> <td><code class="LITERAL" id="json_build_array">json_build_array(VARIADIC "any")</code></td> <td>Builds a possibly-heterogeneously-typed JSON array out of a variadic argument list.</td> <td><code class="LITERAL">json_build_array(1,2,'3',4,5)</code></td> <td><code class="LITERAL">[1, 2, "3", 4, 5]</code></td> </tr> <tr> <td><code class="LITERAL" id="json_build_object">json_build_object(VARIADIC "any")</code></td> <td>Builds a JSON object out of a variadic argument list. By convention, the argument list consists of alternating keys and values.</td> <td><code class="LITERAL">json_build_object('foo',1,'bar',2)</code></td> <td><code class="LITERAL">{"foo": 1, "bar": 2}</code></td> </tr> <tr> <td><code class="LITERAL" id="json_object">json_object(text[])</code></td> <td>Builds a JSON object out of a text array. The array must have either exactly one dimension with an even number of members, in which case they are taken as alternating key/value pairs, or two dimensions such that each inner array has exactly two elements, which are taken as a key/value pair.</td> <td> <p><code class="LITERAL">json_object('{a, 1, b, "def", c, 3.5}')</code></p> <p><code class="LITERAL">json_object('{{a, 1},{b, "def"},{c, 3.5}}')</code></p> </td> <td><code class="LITERAL">{"a": "1", "b": "def", "c": "3.5"}</code></td> </tr> <tr> <td><code class="LITERAL">json_object(keys text[], values text[])</code></td> <td>This form of <code class="FUNCTION">json_object</code> takes keys and values pairwise from two separate arrays. In all other respects it is identical to the one-argument form.</td> <td><code class="LITERAL">json_object('{a, b}', '{1,2}')</code></td> <td><code class="LITERAL">{"a": "1", "b": "2"}</code></td> </tr> </tbody> </table> </div>  <blockquote class="NOTE"> <p><b>Note:</b> <code class="FUNCTION">array_to_json</code> and <code class="FUNCTION">row_to_json</code> have the same behavior as <code class="FUNCTION">to_json</code> except for offering a pretty-printing option. The behavior described for <code class="FUNCTION">to_json</code> likewise applies to each individual value converted by the other JSON creation functions.</p> </blockquote>   <blockquote class="NOTE"> <p><b>Note:</b> The <a href="../hstore/">hstore</a> extension has a cast from <code class="TYPE">hstore</code> to <code class="TYPE">json</code>, so that <code class="TYPE">hstore</code> values converted via the JSON creation functions will be represented as JSON objects, not as primitive string values.</p> </blockquote>  <p><a href="../functions-json/#FUNCTIONS-JSON-PROCESSING-TABLE">Table 9-43</a> shows the functions that are available for processing <code class="TYPE">json</code> and <code class="TYPE">jsonb</code> values.</p> <div class="TABLE" id="FUNCTIONS-JSON-PROCESSING-TABLE">  <p class="c2">Table 9-43. JSON Processing Functions</p> <table class="CALSTABLE"> <col> <col> <col> <col> <col> <thead> <tr> <th>Function</th> <th>Return Type</th> <th>Description</th> <th>Example</th> <th>Example Result</th> </tr> </thead> <tbody> <tr> <td> <p><code class="LITERAL" id="json_array_length">json_array_length(json)</code></p> <p><code class="LITERAL" id="jsonb_array_length">jsonb_array_length(jsonb)</code></p> </td> <td><code class="TYPE">int</code></td> <td>Returns the number of elements in the outermost JSON array.</td> <td><code class="LITERAL">json_array_length('[1,2,3,{"f1":1,"f2":[5,6]},4]')</code></td> <td><code class="LITERAL">5</code></td> </tr> <tr> <td> <p><code class="LITERAL" id="json_each">json_each(json)</code></p> <p><code class="LITERAL" id="jsonb_each">jsonb_each(jsonb)</code></p> </td> <td> <p><code class="LITERAL">setof key text, value json</code></p> <p><code class="LITERAL">setof key text, value jsonb</code></p> </td> <td>Expands the outermost JSON object into a set of key/value pairs.</td> <td><code class="LITERAL">select * from json_each('{"a":"foo", "b":"bar"}')</code></td> <td> <pre class="PROGRAMLISTING" data-language="sql">
 key | value
-----+-------
 a   | "foo"
 b   | "bar"
</pre> </td> </tr> <tr> <td> <p><code class="LITERAL" id="json_each_text">json_each_text(json)</code></p> <p><code class="LITERAL" id="jsonb_each_text">jsonb_each_text(jsonb)</code></p> </td> <td><code class="TYPE">setof key text, value text</code></td> <td>Expands the outermost JSON object into a set of key/value pairs. The returned values will be of type <code class="TYPE">text</code>.</td> <td><code class="LITERAL">select * from json_each_text('{"a":"foo", "b":"bar"}')</code></td> <td> <pre class="PROGRAMLISTING" data-language="sql">
 key | value
-----+-------
 a   | foo
 b   | bar
</pre> </td> </tr> <tr> <td> <p><code class="LITERAL" id="json_extract_path">json_extract_path(from_json json, VARIADIC path_elems text[])</code></p> <p><code class="LITERAL" id="jsonb_extract_path">jsonb_extract_path(from_json jsonb, VARIADIC path_elems text[])</code></p> </td> <td> <p><code class="TYPE">json</code></p> <p><code class="TYPE">jsonb</code></p> </td> <td>Returns JSON value pointed to by <code class="REPLACEABLE c4">path_elems</code> (equivalent to <code class="LITERAL">#&gt;</code> operator).</td> <td><code class="LITERAL">json_extract_path('{"f2":{"f3":1},"f4":{"f5":99,"f6":"foo"}}','f4')</code></td> <td><code class="LITERAL">{"f5":99,"f6":"foo"}</code></td> </tr> <tr> <td> <p><code class="LITERAL" id="json_extract_path_text">json_extract_path_text(from_json json, VARIADIC path_elems text[])</code></p> <p><code class="LITERAL" id="jsonb_extract_path_text">jsonb_extract_path_text(from_json jsonb, VARIADIC path_elems text[])</code></p> </td> <td><code class="TYPE">text</code></td> <td>Returns JSON value pointed to by <code class="REPLACEABLE c4">path_elems</code> as <code class="TYPE">text</code> (equivalent to <code class="LITERAL">#&gt;&gt;</code> operator).</td> <td><code class="LITERAL">json_extract_path_text('{"f2":{"f3":1},"f4":{"f5":99,"f6":"foo"}}','f4', 'f6')</code></td> <td><code class="LITERAL">foo</code></td> </tr> <tr> <td> <p><code class="LITERAL" id="json_object_keys">json_object_keys(json)</code></p> <p><code class="LITERAL" id="jsonb_object_keys">jsonb_object_keys(jsonb)</code></p> </td> <td><code class="TYPE">setof text</code></td> <td>Returns set of keys in the outermost JSON object.</td> <td><code class="LITERAL">json_object_keys('{"f1":"abc","f2":{"f3":"a", "f4":"b"}}')</code></td> <td> <pre class="PROGRAMLISTING" data-language="sql">
 json_object_keys
------------------
 f1
 f2
</pre> </td> </tr> <tr> <td> <p><code class="LITERAL" id="json_populate_record">json_populate_record(base anyelement, from_json json)</code></p> <p><code class="LITERAL" id="jsonb_populate_record">jsonb_populate_record(base anyelement, from_json jsonb)</code></p> </td> <td><code class="TYPE">anyelement</code></td> <td>Expands the object in <code class="REPLACEABLE c4">from_json</code> to a row whose columns match the record type defined by <code class="REPLACEABLE c4">base</code> (see note below).</td> <td><code class="LITERAL">select * from json_populate_record(null::myrowtype, '{"a":1,"b":2}')</code></td> <td> <pre class="PROGRAMLISTING" data-language="sql">
 a | b
---+---
 1 | 2
</pre> </td> </tr> <tr> <td> <p><code class="LITERAL" id="json_populate_recordset">json_populate_recordset(base anyelement, from_json json)</code></p> <p><code class="LITERAL" id="jsonb_populate_recordset">jsonb_populate_recordset(base anyelement, from_json jsonb)</code></p> </td> <td><code class="TYPE">setof anyelement</code></td> <td>Expands the outermost array of objects in <code class="REPLACEABLE c4">from_json</code> to a set of rows whose columns match the record type defined by <code class="REPLACEABLE c4">base</code> (see note below).</td> <td><code class="LITERAL">select * from json_populate_recordset(null::myrowtype, '[{"a":1,"b":2},{"a":3,"b":4}]')</code></td> <td> <pre class="PROGRAMLISTING" data-language="sql">
 a | b
---+---
 1 | 2
 3 | 4
</pre> </td> </tr> <tr> <td> <p><code class="LITERAL" id="json_array_elements">json_array_elements(json)</code></p> <p><code class="LITERAL" id="jsonb_array_elements">jsonb_array_elements(jsonb)</code></p> </td> <td> <p><code class="TYPE">setof json</code></p> <p><code class="TYPE">setof jsonb</code></p> </td> <td>Expands a JSON array to a set of JSON values.</td> <td><code class="LITERAL">select * from json_array_elements('[1,true, [2,false]]')</code></td> <td> <pre class="PROGRAMLISTING" data-language="sql">
   value
-----------
 1
 true
 [2,false]
</pre> </td> </tr> <tr> <td> <p><code class="LITERAL" id="json_array_elements_text">json_array_elements_text(json)</code></p> <p><code class="LITERAL" id="jsonb_array_elements_text">jsonb_array_elements_text(jsonb)</code></p> </td> <td><code class="TYPE">setof text</code></td> <td>Expands a JSON array to a set of <code class="TYPE">text</code> values.</td> <td><code class="LITERAL">select * from json_array_elements_text('["foo", "bar"]')</code></td> <td> <pre class="PROGRAMLISTING" data-language="sql">
   value
-----------
 foo
 bar
</pre> </td> </tr> <tr> <td> <p><code class="LITERAL" id="json_typeof">json_typeof(json)</code></p> <p><code class="LITERAL" id="jsonb_typeof">jsonb_typeof(jsonb)</code></p> </td> <td><code class="TYPE">text</code></td> <td>Returns the type of the outermost JSON value as a text string. Possible types are <code class="LITERAL">object</code>, <code class="LITERAL">array</code>, <code class="LITERAL">string</code>, <code class="LITERAL">number</code>, <code class="LITERAL">boolean</code>, and <code class="LITERAL">null</code>.</td> <td><code class="LITERAL">json_typeof('-123.4')</code></td> <td><code class="LITERAL">number</code></td> </tr> <tr> <td> <p><code class="LITERAL" id="json_to_record">json_to_record(json)</code></p> <p><code class="LITERAL" id="jsonb_to_record">jsonb_to_record(jsonb)</code></p> </td> <td><code class="TYPE">record</code></td> <td>Builds an arbitrary record from a JSON object (see note below). As with all functions returning <code class="TYPE">record</code>, the caller must explicitly define the structure of the record with an <code class="LITERAL">AS</code> clause.</td> <td><code class="LITERAL">select * from json_to_record('{"a":1,"b":[1,2,3],"c":"bar"}') as x(a int, b text, d text)</code></td> <td> <pre class="PROGRAMLISTING" data-language="sql">
 a |    b    | d
---+---------+---
 1 | [1,2,3] |
</pre> </td> </tr> <tr> <td> <p><code class="LITERAL" id="json_to_recordset">json_to_recordset(json)</code></p> <p><code class="LITERAL" id="jsonb_to_recordset">jsonb_to_recordset(jsonb)</code></p> </td> <td><code class="TYPE">setof record</code></td> <td>Builds an arbitrary set of records from a JSON array of objects (see note below). As with all functions returning <code class="TYPE">record</code>, the caller must explicitly define the structure of the record with an <code class="LITERAL">AS</code> clause.</td> <td><code class="LITERAL">select * from json_to_recordset('[{"a":1,"b":"foo"},{"a":"2","c":"bar"}]') as x(a int, b text);</code></td> <td> <pre class="PROGRAMLISTING" data-language="sql">
 a |  b
---+-----
 1 | foo
 2 |
</pre> </td> </tr> </tbody> </table> </div>  <blockquote class="NOTE"> <p><b>Note:</b> Many of these functions and operators will convert Unicode escapes in JSON strings to the appropriate single character. This is a non-issue if the input is type <code class="TYPE">jsonb</code>, because the conversion was already done; but for <code class="TYPE">json</code> input, this may result in throwing an error, as noted in <a href="../datatype-json/">Section 8.14</a>.</p> </blockquote>   <blockquote class="NOTE"> <p><b>Note:</b> In <code class="FUNCTION">json_populate_record</code>, <code class="FUNCTION">json_populate_recordset</code>, <code class="FUNCTION">json_to_record</code> and <code class="FUNCTION">json_to_recordset</code>, type coercion from the JSON is <span class="QUOTE">"best effort"</span> and may not result in desired values for some types. JSON keys are matched to identical column names in the target row type. JSON fields that do not appear in the target row type will be omitted from the output, and target columns that do not match any JSON field will simply be NULL.</p> </blockquote>   <blockquote class="NOTE"> <p><b>Note:</b> The <code class="LITERAL">json_typeof</code> function's <code class="LITERAL">null</code> return value should not be confused with a SQL NULL. While calling <code class="LITERAL">json_typeof('null'::json)</code> will return <code class="LITERAL">null</code>, calling <code class="LITERAL">json_typeof(NULL::json)</code> will return a SQL NULL.</p> </blockquote>  <p>See also <a href="../functions-aggregate/">Section 9.20</a> for the aggregate function <code class="FUNCTION">json_agg</code> which aggregates record values as JSON, and the aggregate function <code class="FUNCTION">json_object_agg</code> which aggregates pairs of values into a JSON object.</p>  <div class="NAVFOOTER">  <table summary="Footer navigation table"> <tr> <td width="33%" align="left"><a href="../functions-xml/" accesskey="P">Prev</a></td> <td width="34%" align="center"></td> <td width="33%" align="right"><a href="../functions-sequence/" accesskey="N">Next</a></td> </tr> <tr> <td width="33%" align="left">XML Functions</td> <td width="34%" align="center"><a href="https://www.postgresql.org/docs/9.4/static/functions.html" accesskey="U" target="_blank">Up</a></td> <td width="33%" align="right">Sequence Manipulation Functions</td> </tr> </table> </div>
<div class="_attribution">
  <p class="_attribution-p">
    © 1996–2017 The PostgreSQL Global Development Group<br>Licensed under the PostgreSQL License.<br>
    <a href="https://www.postgresql.org/docs/9.4/static/functions-json.html" class="_attribution-link" target="_blank">https://www.postgresql.org/docs/9.4/static/functions-json.html</a>
  </p>
</div>

			</div>
		</div>
	</section>

	</div>
</body>
</html>
