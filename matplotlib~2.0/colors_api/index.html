
<!DOCTYPE HTML>

<html lang="en">

<head>
  <meta charset="utf-8">
  <title>Colors - Matplotlib 2.0 - W3cubDocs</title>
  
  <meta name="description" content=" For a visual representation of the matplotlib colormaps, see the “Color” section in the gallery. ">
  <meta name="keywords" content="colors, -, matplotlib, matplotlib~2.0">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="http://docs.w3cub.com/matplotlib~2.0/colors_api/">
  <link href="/favicon.png" rel="icon">
  <link type="text/css" rel="stylesheet" href="/assets/application-50364fff564ce3b6327021805f3f00e2957b441cf27f576a7dd4ff63bbc47047.css">
  <script type="text/javascript" src="/assets/application-db64bfd54ceb42be11af7995804cf4902548419ceb79d509b0b7d62c22d98e6f.js"></script>
  <script src="/json/matplotlib~2.0.js"></script>
  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-71174418-1']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>


</head>

<body>
	<div class="_app">
	<header class="_header">
  
  <form class="_search">
    <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
    <a class="_search-clear"></a>
    <div class="_search-tag"></div>
  </form>
  
  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/matplotlib~2.0/" class="_nav-link" title="" style="margin-left:0;">Matplotlib 2.0</a></span>
  
  <nav class="_nav">
    <a href="/app/" class="_nav-link ">App</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		<div class="_list">
			
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<div class="_page _sphinx">
				
<h1 id="colors">colors</h1> <p>For a visual representation of the matplotlib colormaps, see the “Color” section in the gallery.</p>  <h2 id="matplotlib-colors">matplotlib.colors</h2> <p id="module-matplotlib.colors">A module for converting numbers or color arguments to <em>RGB</em> or <em>RGBA</em></p> <p><em>RGB</em> and <em>RGBA</em> are sequences of, respectively, 3 or 4 floats in the range 0-1.</p> <p>This module includes functions and classes for color specification conversions, and for mapping numbers to colors in a 1-D array of colors called a colormap. Colormapping typically involves two steps: a data array is first mapped onto the range 0-1 using an instance of <a class="reference internal" href="#matplotlib.colors.Normalize" title="matplotlib.colors.Normalize"><code>Normalize</code></a> or of a subclass; then this number in the 0-1 range is mapped to a color using an instance of a subclass of <a class="reference internal" href="#matplotlib.colors.Colormap" title="matplotlib.colors.Colormap"><code>Colormap</code></a>. Two are provided here: <a class="reference internal" href="#matplotlib.colors.LinearSegmentedColormap" title="matplotlib.colors.LinearSegmentedColormap"><code>LinearSegmentedColormap</code></a>, which is used to generate all the built-in colormap instances, but is also useful for making custom colormaps, and <a class="reference internal" href="#matplotlib.colors.ListedColormap" title="matplotlib.colors.ListedColormap"><code>ListedColormap</code></a>, which is used for generating a custom colormap from a list of color specifications.</p> <p>The module also provides functions for checking whether an object can be interpreted as a color (<a class="reference internal" href="#matplotlib.colors.is_color_like" title="matplotlib.colors.is_color_like"><code>is_color_like()</code></a>), for converting such an object to an RGBA tuple (<a class="reference internal" href="#matplotlib.colors.to_rgba" title="matplotlib.colors.to_rgba"><code>to_rgba()</code></a>) or to an HTML-like hex string in the <code>#rrggbb</code> format (<a class="reference internal" href="#matplotlib.colors.to_hex" title="matplotlib.colors.to_hex"><code>to_hex()</code></a>), and a sequence of colors to an <code>(n, 4)</code> RGBA array (<a class="reference internal" href="#matplotlib.colors.to_rgba_array" title="matplotlib.colors.to_rgba_array"><code>to_rgba_array()</code></a>). Caching is used for efficiency.</p> <p>Commands which take color arguments can use several formats to specify the colors. For the basic built-in colors, you can use a single letter</p>  <ul class="simple"> <li>
<code>b</code>: blue</li> <li>
<code>g</code>: green</li> <li>
<code>r</code>: red</li> <li>
<code>c</code>: cyan</li> <li>
<code>m</code>: magenta</li> <li>
<code>y</code>: yellow</li> <li>
<code>k</code>: black</li> <li>
<code>w</code>: white</li> </ul>  <p>To use the colors that are part of the active color cycle in the current style, use <code>C</code> followed by a digit. For example:</p>  <ul class="simple"> <li>
<code>C0</code>: The first color in the cycle</li> <li>
<code>C1</code>: The second color in the cycle</li> </ul>  <p>Gray shades can be given as a string encoding a float in the 0-1 range, e.g.:</p> <pre data-language="python">color = '0.75'
</pre> <p>For a greater range of colors, you have two options. You can specify the color using an html hex string, as in:</p> <pre data-language="python">color = '#eeefff'
</pre> <p>(possibly specifying an alpha value as well), or you can pass an <code>(r, g, b)</code> or <code>(r, g, b, a)</code> tuple, where each of <code>r</code>, <code>g</code>, <code>b</code> and <code>a</code> are in the range [0,1].</p> <p>Finally, legal html names for colors, like ‘red’, ‘burlywood’ and ‘chartreuse’ are supported.</p> <dl class="class"> <dt id="matplotlib.colors.BoundaryNorm">
<code>class matplotlib.colors.BoundaryNorm(boundaries, ncolors, clip=False)</code> </dt> <dd>
<p>Bases: <a class="reference internal" href="#matplotlib.colors.Normalize" title="matplotlib.colors.Normalize"><code>matplotlib.colors.Normalize</code></a></p> <p>Generate a colormap index based on discrete intervals.</p> <p>Unlike <a class="reference internal" href="#matplotlib.colors.Normalize" title="matplotlib.colors.Normalize"><code>Normalize</code></a> or <a class="reference internal" href="#matplotlib.colors.LogNorm" title="matplotlib.colors.LogNorm"><code>LogNorm</code></a>, <a class="reference internal" href="#matplotlib.colors.BoundaryNorm" title="matplotlib.colors.BoundaryNorm"><code>BoundaryNorm</code></a> maps values to integers instead of to the interval 0-1.</p> <p>Mapping to the 0-1 interval could have been done via piece-wise linear interpolation, but using integers seems simpler, and reduces the number of conversions back and forth between integer and floating point.</p> <dl class="docutils"> <dt><em>boundaries</em></dt> <dd>a monotonically increasing sequence</dd> <dt><em>ncolors</em></dt> <dd>number of colors in the colormap to be used</dd> </dl> <p>If:</p> <pre data-language="python">b[i] &lt;= v &lt; b[i+1]
</pre> <p>then v is mapped to color j; as i varies from 0 to len(boundaries)-2, j goes from 0 to ncolors-1.</p> <p>Out-of-range values are mapped to -1 if low and ncolors if high; these are converted to valid indices by <code>Colormap.__call__()</code> . If clip == True, out-of-range values are mapped to 0 if low and ncolors-1 if high.</p> <dl class="method"> <dt id="matplotlib.colors.BoundaryNorm.inverse">
<code>inverse(value)</code> </dt> 
</dl> </dd>
</dl> <dl class="class"> <dt id="matplotlib.colors.Colormap">
<code>class matplotlib.colors.Colormap(name, N=256)</code> </dt> <dd>
<p>Bases: <code>object</code></p> <p>Baseclass for all scalar to RGBA mappings.</p> <p>Typically Colormap instances are used to convert data values (floats) from the interval <code>[0, 1]</code> to the RGBA color that the respective Colormap represents. For scaling of data into the <code>[0, 1]</code> interval see <a class="reference internal" href="#matplotlib.colors.Normalize" title="matplotlib.colors.Normalize"><code>matplotlib.colors.Normalize</code></a>. It is worth noting that <a class="reference internal" href="../cm_api/#matplotlib.cm.ScalarMappable" title="matplotlib.cm.ScalarMappable"><code>matplotlib.cm.ScalarMappable</code></a> subclasses make heavy use of this <code>data-&gt;normalize-&gt;map-to-color</code> processing chain.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr class="field-odd field">
<th class="field-name">Parameters:</th>
<td class="field-body">
<p class="first"><strong>name</strong> : str</p>  <p>The name of the colormap.</p>  <p><strong>N</strong> : int</p>  <p>The number of rgb quantization levels.</p>  </td> </tr>  </table> <dl class="attribute"> <dt id="matplotlib.colors.Colormap.colorbar_extend">
<code>colorbar_extend = None</code> </dt> <dd>
<p>When this colormap exists on a scalar mappable and colorbar_extend is not False, colorbar creation will pick up <code>colorbar_extend</code> as the default value for the <code>extend</code> keyword in the <a class="reference internal" href="../colorbar_api/#matplotlib.colorbar.Colorbar" title="matplotlib.colorbar.Colorbar"><code>matplotlib.colorbar.Colorbar</code></a> constructor.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.colors.Colormap.is_gray">
<code>is_gray()</code> </dt> 
</dl> <dl class="method"> <dt id="matplotlib.colors.Colormap.set_bad">
<code>set_bad(color='k', alpha=None)</code> </dt> <dd>
<p>Set color to be used for masked values.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.colors.Colormap.set_over">
<code>set_over(color='k', alpha=None)</code> </dt> <dd>
<p>Set color to be used for high out-of-range values. Requires norm.clip = False</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.colors.Colormap.set_under">
<code>set_under(color='k', alpha=None)</code> </dt> <dd>
<p>Set color to be used for low out-of-range values. Requires norm.clip = False</p> </dd>
</dl> </dd>
</dl> <dl class="class"> <dt id="matplotlib.colors.LightSource">
<code>class matplotlib.colors.LightSource(azdeg=315, altdeg=45, hsv_min_val=0, hsv_max_val=1, hsv_min_sat=1, hsv_max_sat=0)</code> </dt> <dd>
<p>Bases: <code>object</code></p> <p>Create a light source coming from the specified azimuth and elevation. Angles are in degrees, with the azimuth measured clockwise from north and elevation up from the zero plane of the surface.</p> <p>The <a class="reference internal" href="#matplotlib.colors.LightSource.shade" title="matplotlib.colors.LightSource.shade"><code>shade()</code></a> is used to produce “shaded” rgb values for a data array. <a class="reference internal" href="#matplotlib.colors.LightSource.shade_rgb" title="matplotlib.colors.LightSource.shade_rgb"><code>shade_rgb()</code></a> can be used to combine an rgb image with The <a class="reference internal" href="#matplotlib.colors.LightSource.shade_rgb" title="matplotlib.colors.LightSource.shade_rgb"><code>shade_rgb()</code></a> The <a class="reference internal" href="#matplotlib.colors.LightSource.hillshade" title="matplotlib.colors.LightSource.hillshade"><code>hillshade()</code></a> produces an illumination map of a surface.</p> <p>Specify the azimuth (measured clockwise from south) and altitude (measured up from the plane of the surface) of the light source in degrees.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr class="field-odd field">
<th class="field-name">Parameters:</th>
<td class="field-body">
<p class="first"><strong>azdeg</strong> : number, optional</p>  <p>The azimuth (0-360, degrees clockwise from North) of the light source. Defaults to 315 degrees (from the northwest).</p>  <p><strong>altdeg</strong> : number, optional</p>  <p>The altitude (0-90, degrees up from horizontal) of the light source. Defaults to 45 degrees from horizontal.</p>  </td> </tr>  </table> <h4 class="rubric">Notes</h4> <p>For backwards compatibility, the parameters <em>hsv_min_val</em>, <em>hsv_max_val</em>, <em>hsv_min_sat</em>, and <em>hsv_max_sat</em> may be supplied at initialization as well. However, these parameters will only be used if “blend_mode=’hsv’” is passed into <a class="reference internal" href="#matplotlib.colors.LightSource.shade" title="matplotlib.colors.LightSource.shade"><code>shade()</code></a> or <a class="reference internal" href="#matplotlib.colors.LightSource.shade_rgb" title="matplotlib.colors.LightSource.shade_rgb"><code>shade_rgb()</code></a>. See the documentation for <a class="reference internal" href="#matplotlib.colors.LightSource.blend_hsv" title="matplotlib.colors.LightSource.blend_hsv"><code>blend_hsv()</code></a> for more details.</p> <dl class="method"> <dt id="matplotlib.colors.LightSource.blend_hsv">
<code>blend_hsv(rgb, intensity, hsv_max_sat=None, hsv_max_val=None, hsv_min_val=None, hsv_min_sat=None)</code> </dt> <dd>
<p>Take the input data array, convert to HSV values in the given colormap, then adjust those color values to give the impression of a shaded relief map with a specified light source. RGBA values are returned, which can then be used to plot the shaded image with imshow.</p> <p>The color of the resulting image will be darkened by moving the (s,v) values (in hsv colorspace) toward (hsv_min_sat, hsv_min_val) in the shaded regions, or lightened by sliding (s,v) toward (hsv_max_sat hsv_max_val) in regions that are illuminated. The default extremes are chose so that completely shaded points are nearly black (s = 1, v = 0) and completely illuminated points are nearly white (s = 0, v = 1).</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr class="field-odd field">
<th class="field-name">Parameters:</th>
<td class="field-body">
<p class="first"><strong>rgb</strong> : ndarray</p>  <p>An MxNx3 RGB array of floats ranging from 0 to 1 (color image).</p>  <p><strong>intensity</strong> : ndarray</p>  <p>An MxNx1 array of floats ranging from 0 to 1 (grayscale image).</p>  <p><strong>hsv_max_sat</strong> : number, optional</p>  <p>The maximum saturation value that the <em>intensity</em> map can shift the output image to. Defaults to 1.</p>  <p><strong>hsv_min_sat</strong> : number, optional</p>  <p>The minimum saturation value that the <em>intensity</em> map can shift the output image to. Defaults to 0.</p>  <p><strong>hsv_max_val</strong> : number, optional</p>  <p>The maximum value (“v” in “hsv”) that the <em>intensity</em> map can shift the output image to. Defaults to 1.</p>  <p><strong>hsv_min_val: number, optional</strong></p>  <p>The minimum value (“v” in “hsv”) that the <em>intensity</em> map can shift the output image to. Defaults to 0.</p>  </td> </tr> <tr class="field-even field">
<th class="field-name">Returns:</th>
<td class="field-body">
<p class="first"><strong>rgb</strong> : ndarray</p>  <p>An MxNx3 RGB array representing the combined images.</p>  </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="matplotlib.colors.LightSource.blend_overlay">
<code>blend_overlay(rgb, intensity)</code> </dt> <dd>
<p>Combines an rgb image with an intensity map using “overlay” blending.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr class="field-odd field">
<th class="field-name">Parameters:</th>
<td class="field-body">
<p class="first"><strong>rgb</strong> : ndarray</p>  <p>An MxNx3 RGB array of floats ranging from 0 to 1 (color image).</p>  <p><strong>intensity</strong> : ndarray</p>  <p>An MxNx1 array of floats ranging from 0 to 1 (grayscale image).</p>  </td> </tr> <tr class="field-even field">
<th class="field-name">Returns:</th>
<td class="field-body">
<p class="first"><strong>rgb</strong> : ndarray</p>  <p>An MxNx3 RGB array representing the combined images.</p>  </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="matplotlib.colors.LightSource.blend_soft_light">
<code>blend_soft_light(rgb, intensity)</code> </dt> <dd>
<p>Combines an rgb image with an intensity map using “soft light” blending. Uses the “pegtop” formula.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr class="field-odd field">
<th class="field-name">Parameters:</th>
<td class="field-body">
<p class="first"><strong>rgb</strong> : ndarray</p>  <p>An MxNx3 RGB array of floats ranging from 0 to 1 (color image).</p>  <p><strong>intensity</strong> : ndarray</p>  <p>An MxNx1 array of floats ranging from 0 to 1 (grayscale image).</p>  </td> </tr> <tr class="field-even field">
<th class="field-name">Returns:</th>
<td class="field-body">
<p class="first"><strong>rgb</strong> : ndarray</p>  <p>An MxNx3 RGB array representing the combined images.</p>  </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="matplotlib.colors.LightSource.hillshade">
<code>hillshade(elevation, vert_exag=1, dx=1, dy=1, fraction=1.0)</code> </dt> <dd>
<p>Calculates the illumination intensity for a surface using the defined azimuth and elevation for the light source.</p> <p>Imagine an artificial sun placed at infinity in some azimuth and elevation position illuminating our surface. The parts of the surface that slope toward the sun should brighten while those sides facing away should become darker.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr class="field-odd field">
<th class="field-name">Parameters:</th>
<td class="field-body">
<p class="first"><strong>elevation</strong> : array-like</p>  <p>A 2d array (or equivalent) of the height values used to generate an illumination map</p>  <p><strong>vert_exag</strong> : number, optional</p>  <p>The amount to exaggerate the elevation values by when calculating illumination. This can be used either to correct for differences in units between the x-y coordinate system and the elevation coordinate system (e.g. decimal degrees vs meters) or to exaggerate or de-emphasize topographic effects.</p>  <p><strong>dx</strong> : number, optional</p>  <p>The x-spacing (columns) of the input <em>elevation</em> grid.</p>  <p><strong>dy</strong> : number, optional</p>  <p>The y-spacing (rows) of the input <em>elevation</em> grid.</p>  <p><strong>fraction</strong> : number, optional</p>  <p>Increases or decreases the contrast of the hillshade. Values greater than one will cause intermediate values to move closer to full illumination or shadow (and clipping any values that move beyond 0 or 1). Note that this is not visually or mathematically the same as vertical exaggeration.</p>  <p><strong>Returns</strong></p> <p><strong>——-</strong></p> <p><strong>intensity</strong> : ndarray</p>  <p>A 2d array of illumination values between 0-1, where 0 is completely in shadow and 1 is completely illuminated.</p>  </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="matplotlib.colors.LightSource.shade">
<code>shade(data, cmap, norm=None, blend_mode='overlay', vmin=None, vmax=None, vert_exag=1, dx=1, dy=1, fraction=1, **kwargs)</code> </dt> <dd>
<p>Combine colormapped data values with an illumination intensity map (a.k.a. “hillshade”) of the values.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr class="field-odd field">
<th class="field-name">Parameters:</th>
<td class="field-body">
<p class="first"><strong>data</strong> : array-like</p>  <p>A 2d array (or equivalent) of the height values used to generate a shaded map.</p>  <p><strong>cmap</strong> : <a class="reference internal" href="#matplotlib.colors.Colormap" title="matplotlib.colors.Colormap"><code>Colormap</code></a> instance</p>  <p>The colormap used to color the <em>data</em> array. Note that this must be a <a class="reference internal" href="#matplotlib.colors.Colormap" title="matplotlib.colors.Colormap"><code>Colormap</code></a> instance. For example, rather than passing in <code>cmap='gist_earth'</code>, use <code>cmap=plt.get_cmap('gist_earth')</code> instead.</p>  <p><strong>norm</strong> : <a class="reference internal" href="#matplotlib.colors.Normalize" title="matplotlib.colors.Normalize"><code>Normalize</code></a> instance, optional</p>  <p>The normalization used to scale values before colormapping. If None, the input will be linearly scaled between its min and max.</p>  <p><strong>blend_mode</strong> : {‘hsv’, ‘overlay’, ‘soft’} or callable, optional</p>  <p>The type of blending used to combine the colormapped data values with the illumination intensity. Default is “overlay”. Note that for most topographic surfaces, “overlay” or “soft” appear more visually realistic. If a user-defined function is supplied, it is expected to combine an MxNx3 RGB array of floats (ranging 0 to 1) with an MxNx1 hillshade array (also 0 to 1). (Call signature <code>func(rgb, illum, **kwargs)</code>) Additional kwargs supplied to this function will be passed on to the <em>blend_mode</em> function.</p>  <p><strong>vmin</strong> : scalar or None, optional</p>  <p>The minimum value used in colormapping <em>data</em>. If <em>None</em> the minimum value in <em>data</em> is used. If <em>norm</em> is specified, then this argument will be ignored.</p>  <p><strong>vmax</strong> : scalar or None, optional</p>  <p>The maximum value used in colormapping <em>data</em>. If <em>None</em> the maximum value in <em>data</em> is used. If <em>norm</em> is specified, then this argument will be ignored.</p>  <p><strong>vert_exag</strong> : number, optional</p>  <p>The amount to exaggerate the elevation values by when calculating illumination. This can be used either to correct for differences in units between the x-y coordinate system and the elevation coordinate system (e.g. decimal degrees vs meters) or to exaggerate or de-emphasize topography.</p>  <p><strong>dx</strong> : number, optional</p>  <p>The x-spacing (columns) of the input <em>elevation</em> grid.</p>  <p><strong>dy</strong> : number, optional</p>  <p>The y-spacing (rows) of the input <em>elevation</em> grid.</p>  <p><strong>fraction</strong> : number, optional</p>  <p>Increases or decreases the contrast of the hillshade. Values greater than one will cause intermediate values to move closer to full illumination or shadow (and clipping any values that move beyond 0 or 1). Note that this is not visually or mathematically the same as vertical exaggeration.</p>  <p><strong>Additional kwargs are passed on to the *blend_mode* function.</strong></p> </td> </tr> <tr class="field-even field">
<th class="field-name">Returns:</th>
<td class="field-body">
<p class="first"><strong>rgba</strong> : ndarray</p>  <p>An MxNx4 array of floats ranging between 0-1.</p>  </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="matplotlib.colors.LightSource.shade_rgb">
<code>shade_rgb(rgb, elevation, fraction=1.0, blend_mode='hsv', vert_exag=1, dx=1, dy=1, **kwargs)</code> </dt> <dd>
<p>Take the input RGB array (ny*nx*3) adjust their color values to given the impression of a shaded relief map with a specified light source using the elevation (ny*nx). A new RGB array ((ny*nx*3)) is returned.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr class="field-odd field">
<th class="field-name">Parameters:</th>
<td class="field-body">
<p class="first"><strong>rgb</strong> : array-like</p>  <p>An MxNx3 RGB array, assumed to be in the range of 0 to 1.</p>  <p><strong>elevation</strong> : array-like</p>  <p>A 2d array (or equivalent) of the height values used to generate a shaded map.</p>  <p><strong>fraction</strong> : number</p>  <p>Increases or decreases the contrast of the hillshade. Values greater than one will cause intermediate values to move closer to full illumination or shadow (and clipping any values that move beyond 0 or 1). Note that this is not visually or mathematically the same as vertical exaggeration.</p>  <p><strong>blend_mode</strong> : {‘hsv’, ‘overlay’, ‘soft’} or callable, optional</p>  <p>The type of blending used to combine the colormapped data values with the illumination intensity. For backwards compatibility, this defaults to “hsv”. Note that for most topographic surfaces, “overlay” or “soft” appear more visually realistic. If a user-defined function is supplied, it is expected to combine an MxNx3 RGB array of floats (ranging 0 to 1) with an MxNx1 hillshade array (also 0 to 1). (Call signature <code>func(rgb, illum, **kwargs)</code>) Additional kwargs supplied to this function will be passed on to the <em>blend_mode</em> function.</p>  <p><strong>vert_exag</strong> : number, optional</p>  <p>The amount to exaggerate the elevation values by when calculating illumination. This can be used either to correct for differences in units between the x-y coordinate system and the elevation coordinate system (e.g. decimal degrees vs meters) or to exaggerate or de-emphasize topography.</p>  <p><strong>dx</strong> : number, optional</p>  <p>The x-spacing (columns) of the input <em>elevation</em> grid.</p>  <p><strong>dy</strong> : number, optional</p>  <p>The y-spacing (rows) of the input <em>elevation</em> grid.</p>  <p><strong>Additional kwargs are passed on to the *blend_mode* function.</strong></p> </td> </tr> <tr class="field-even field">
<th class="field-name">Returns:</th>
<td class="field-body">
<p class="first"><strong>shaded_rgb</strong> : ndarray</p>  <p>An MxNx3 array of floats ranging between 0-1.</p>  </td> </tr>  </table> </dd>
</dl> </dd>
</dl> <dl class="class"> <dt id="matplotlib.colors.LinearSegmentedColormap">
<code>class matplotlib.colors.LinearSegmentedColormap(name, segmentdata, N=256, gamma=1.0)</code> </dt> <dd>
<p>Bases: <a class="reference internal" href="#matplotlib.colors.Colormap" title="matplotlib.colors.Colormap"><code>matplotlib.colors.Colormap</code></a></p> <p>Colormap objects based on lookup tables using linear segments.</p> <p>The lookup table is generated using linear interpolation for each primary color, with the 0-1 domain divided into any number of segments.</p> <p>Create color map from linear mapping segments</p> <p>segmentdata argument is a dictionary with a red, green and blue entries. Each entry should be a list of <em>x</em>, <em>y0</em>, <em>y1</em> tuples, forming rows in a table. Entries for alpha are optional.</p> <p>Example: suppose you want red to increase from 0 to 1 over the bottom half, green to do the same over the middle half, and blue over the top half. Then you would use:</p> <pre data-language="python">cdict = {'red':   [(0.0,  0.0, 0.0),
                   (0.5,  1.0, 1.0),
                   (1.0,  1.0, 1.0)],

         'green': [(0.0,  0.0, 0.0),
                   (0.25, 0.0, 0.0),
                   (0.75, 1.0, 1.0),
                   (1.0,  1.0, 1.0)],

         'blue':  [(0.0,  0.0, 0.0),
                   (0.5,  0.0, 0.0),
                   (1.0,  1.0, 1.0)]}
</pre> <p>Each row in the table for a given color is a sequence of <em>x</em>, <em>y0</em>, <em>y1</em> tuples. In each sequence, <em>x</em> must increase monotonically from 0 to 1. For any input value <em>z</em> falling between <em>x[i]</em> and <em>x[i+1]</em>, the output value of a given color will be linearly interpolated between <em>y1[i]</em> and <em>y0[i+1]</em>:</p> <pre data-language="python">row i:   x  y0  y1
               /
              /
row i+1: x  y0  y1
</pre> <p>Hence y0 in the first row and y1 in the last row are never used.</p> <div class="admonition seealso"> <p class="first admonition-title">See also</p> <p><a class="reference internal" href="#matplotlib.colors.LinearSegmentedColormap.from_list" title="matplotlib.colors.LinearSegmentedColormap.from_list"><code>LinearSegmentedColormap.from_list()</code></a> Static method; factory function for generating a smoothly-varying LinearSegmentedColormap.</p> <p class="last"><a class="reference internal" href="#matplotlib.colors.makeMappingArray" title="matplotlib.colors.makeMappingArray"><code>makeMappingArray()</code></a> For information about making a mapping array.</p> </div> <dl class="staticmethod"> <dt id="matplotlib.colors.LinearSegmentedColormap.from_list">
<code>static from_list(name, colors, N=256, gamma=1.0)</code> </dt> <dd>
<p>Make a linear segmented colormap with <em>name</em> from a sequence of <em>colors</em> which evenly transitions from colors[0] at val=0 to colors[-1] at val=1. <em>N</em> is the number of rgb quantization levels. Alternatively, a list of (value, color) tuples can be given to divide the range unevenly.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.colors.LinearSegmentedColormap.set_gamma">
<code>set_gamma(gamma)</code> </dt> <dd>
<p>Set a new gamma value and regenerate color map.</p> </dd>
</dl> </dd>
</dl> <dl class="class"> <dt id="matplotlib.colors.ListedColormap">
<code>class matplotlib.colors.ListedColormap(colors, name='from_list', N=None)</code> </dt> <dd>
<p>Bases: <a class="reference internal" href="#matplotlib.colors.Colormap" title="matplotlib.colors.Colormap"><code>matplotlib.colors.Colormap</code></a></p> <p>Colormap object generated from a list of colors.</p> <p>This may be most useful when indexing directly into a colormap, but it can also be used to generate special colormaps for ordinary mapping.</p> <p>Make a colormap from a list of colors.</p> <dl class="docutils"> <dt><em>colors</em></dt> <dd>a list of matplotlib color specifications, or an equivalent Nx3 or Nx4 floating point array (<em>N</em> rgb or rgba values)</dd> <dt><em>name</em></dt> <dd>a string to identify the colormap</dd> <dt><em>N</em></dt> <dd>
<p class="first">the number of entries in the map. The default is <em>None</em>, in which case there is one colormap entry for each element in the list of colors. If:</p> <pre data-language="python">N &lt; len(colors)
</pre> <p>the list will be truncated at <em>N</em>. If:</p> <pre data-language="python">N &gt; len(colors)
</pre> <p class="last">the list will be extended by repetition.</p> </dd> </dl> </dd>
</dl> <dl class="class"> <dt id="matplotlib.colors.LogNorm">
<code>class matplotlib.colors.LogNorm(vmin=None, vmax=None, clip=False)</code> </dt> <dd>
<p>Bases: <a class="reference internal" href="#matplotlib.colors.Normalize" title="matplotlib.colors.Normalize"><code>matplotlib.colors.Normalize</code></a></p> <p>Normalize a given value to the 0-1 range on a log scale</p> <p>If <em>vmin</em> or <em>vmax</em> is not given, they are initialized from the minimum and maximum value respectively of the first input processed. That is, <em>__call__(A)</em> calls <em>autoscale_None(A)</em>. If <em>clip</em> is <em>True</em> and the given value falls outside the range, the returned value will be 0 or 1, whichever is closer. Returns 0 if:</p> <pre data-language="python">vmin==vmax
</pre> <p>Works with scalars or arrays, including masked arrays. If <em>clip</em> is <em>True</em>, masked values are set to 1; otherwise they remain masked. Clipping silently defeats the purpose of setting the over, under, and masked colors in the colormap, so it is likely to lead to surprises; therefore the default is <em>clip</em> = <em>False</em>.</p> <dl class="method"> <dt id="matplotlib.colors.LogNorm.autoscale">
<code>autoscale(A)</code> </dt> <dd>
<p>Set <em>vmin</em>, <em>vmax</em> to min, max of <em>A</em>.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.colors.LogNorm.autoscale_None">
<code>autoscale_None(A)</code> </dt> <dd>
<p>autoscale only None-valued vmin or vmax</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.colors.LogNorm.inverse">
<code>inverse(value)</code> </dt> 
</dl> </dd>
</dl> <dl class="class"> <dt id="matplotlib.colors.NoNorm">
<code>class matplotlib.colors.NoNorm(vmin=None, vmax=None, clip=False)</code> </dt> <dd>
<p>Bases: <a class="reference internal" href="#matplotlib.colors.Normalize" title="matplotlib.colors.Normalize"><code>matplotlib.colors.Normalize</code></a></p> <p>Dummy replacement for Normalize, for the case where we want to use indices directly in a <a class="reference internal" href="../cm_api/#matplotlib.cm.ScalarMappable" title="matplotlib.cm.ScalarMappable"><code>ScalarMappable</code></a> .</p> <p>If <em>vmin</em> or <em>vmax</em> is not given, they are initialized from the minimum and maximum value respectively of the first input processed. That is, <em>__call__(A)</em> calls <em>autoscale_None(A)</em>. If <em>clip</em> is <em>True</em> and the given value falls outside the range, the returned value will be 0 or 1, whichever is closer. Returns 0 if:</p> <pre data-language="python">vmin==vmax
</pre> <p>Works with scalars or arrays, including masked arrays. If <em>clip</em> is <em>True</em>, masked values are set to 1; otherwise they remain masked. Clipping silently defeats the purpose of setting the over, under, and masked colors in the colormap, so it is likely to lead to surprises; therefore the default is <em>clip</em> = <em>False</em>.</p> <dl class="method"> <dt id="matplotlib.colors.NoNorm.inverse">
<code>inverse(value)</code> </dt> 
</dl> </dd>
</dl> <dl class="class"> <dt id="matplotlib.colors.Normalize">
<code>class matplotlib.colors.Normalize(vmin=None, vmax=None, clip=False)</code> </dt> <dd>
<p>Bases: <code>object</code></p> <p>A class which, when called, can normalize data into the <code>[0.0, 1.0]</code> interval.</p> <p>If <em>vmin</em> or <em>vmax</em> is not given, they are initialized from the minimum and maximum value respectively of the first input processed. That is, <em>__call__(A)</em> calls <em>autoscale_None(A)</em>. If <em>clip</em> is <em>True</em> and the given value falls outside the range, the returned value will be 0 or 1, whichever is closer. Returns 0 if:</p> <pre data-language="python">vmin==vmax
</pre> <p>Works with scalars or arrays, including masked arrays. If <em>clip</em> is <em>True</em>, masked values are set to 1; otherwise they remain masked. Clipping silently defeats the purpose of setting the over, under, and masked colors in the colormap, so it is likely to lead to surprises; therefore the default is <em>clip</em> = <em>False</em>.</p> <dl class="method"> <dt id="matplotlib.colors.Normalize.autoscale">
<code>autoscale(A)</code> </dt> <dd>
<p>Set <em>vmin</em>, <em>vmax</em> to min, max of <em>A</em>.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.colors.Normalize.autoscale_None">
<code>autoscale_None(A)</code> </dt> <dd>
<p>autoscale only None-valued vmin or vmax</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.colors.Normalize.inverse">
<code>inverse(value)</code> </dt> 
</dl> <dl class="staticmethod"> <dt id="matplotlib.colors.Normalize.process_value">
<code>static process_value(value)</code> </dt> <dd>
<p>Homogenize the input <em>value</em> for easy and efficient normalization.</p> <p><em>value</em> can be a scalar or sequence.</p> <p>Returns <em>result</em>, <em>is_scalar</em>, where <em>result</em> is a masked array matching <em>value</em>. Float dtypes are preserved; integer types with two bytes or smaller are converted to np.float32, and larger types are converted to np.float. Preserving float32 when possible, and using in-place operations, can greatly improve speed for large arrays.</p> <p>Experimental; we may want to add an option to force the use of float32.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.colors.Normalize.scaled">
<code>scaled()</code> </dt> <dd>
<p>return true if vmin and vmax set</p> </dd>
</dl> </dd>
</dl> <dl class="class"> <dt id="matplotlib.colors.PowerNorm">
<code>class matplotlib.colors.PowerNorm(gamma, vmin=None, vmax=None, clip=False)</code> </dt> <dd>
<p>Bases: <a class="reference internal" href="#matplotlib.colors.Normalize" title="matplotlib.colors.Normalize"><code>matplotlib.colors.Normalize</code></a></p> <p>Normalize a given value to the <code>[0, 1]</code> interval with a power-law scaling. This will clip any negative data points to 0.</p> <dl class="method"> <dt id="matplotlib.colors.PowerNorm.autoscale">
<code>autoscale(A)</code> </dt> <dd>
<p>Set <em>vmin</em>, <em>vmax</em> to min, max of <em>A</em>.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.colors.PowerNorm.autoscale_None">
<code>autoscale_None(A)</code> </dt> <dd>
<p>autoscale only None-valued vmin or vmax</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.colors.PowerNorm.inverse">
<code>inverse(value)</code> </dt> 
</dl> </dd>
</dl> <dl class="class"> <dt id="matplotlib.colors.SymLogNorm">
<code>class matplotlib.colors.SymLogNorm(linthresh, linscale=1.0, vmin=None, vmax=None, clip=False)</code> </dt> <dd>
<p>Bases: <a class="reference internal" href="#matplotlib.colors.Normalize" title="matplotlib.colors.Normalize"><code>matplotlib.colors.Normalize</code></a></p> <p>The symmetrical logarithmic scale is logarithmic in both the positive and negative directions from the origin.</p> <p>Since the values close to zero tend toward infinity, there is a need to have a range around zero that is linear. The parameter <em>linthresh</em> allows the user to specify the size of this range (-<em>linthresh</em>, <em>linthresh</em>).</p> <p><em>linthresh</em>: The range within which the plot is linear (to avoid having the plot go to infinity around zero).</p> <p><em>linscale</em>: This allows the linear range (-<em>linthresh</em> to <em>linthresh</em>) to be stretched relative to the logarithmic range. Its value is the number of decades to use for each half of the linear range. For example, when <em>linscale</em> == 1.0 (the default), the space used for the positive and negative halves of the linear range will be equal to one decade in the logarithmic range. Defaults to 1.</p> <dl class="method"> <dt id="matplotlib.colors.SymLogNorm.autoscale">
<code>autoscale(A)</code> </dt> <dd>
<p>Set <em>vmin</em>, <em>vmax</em> to min, max of <em>A</em>.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.colors.SymLogNorm.autoscale_None">
<code>autoscale_None(A)</code> </dt> <dd>
<p>autoscale only None-valued vmin or vmax</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.colors.SymLogNorm.inverse">
<code>inverse(value)</code> </dt> 
</dl> </dd>
</dl> <dl class="function"> <dt id="matplotlib.colors.from_levels_and_colors">
<code>matplotlib.colors.from_levels_and_colors(levels, colors, extend='neither')</code> </dt> <dd>
<p>A helper routine to generate a cmap and a norm instance which behave similar to contourf’s levels and colors arguments.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr class="field-odd field">
<th class="field-name">Parameters:</th>
<td class="field-body">
<p class="first"><strong>levels</strong> : sequence of numbers</p>  <p>The quantization levels used to construct the <a class="reference internal" href="#matplotlib.colors.BoundaryNorm" title="matplotlib.colors.BoundaryNorm"><code>BoundaryNorm</code></a>. Values <code>v</code> are quantizized to level <code>i</code> if <code>lev[i] &lt;= v &lt; lev[i+1]</code>.</p>  <p><strong>colors</strong> : sequence of colors</p>  <p>The fill color to use for each level. If <code>extend</code> is “neither” there must be <code>n_level - 1</code> colors. For an <code>extend</code> of “min” or “max” add one extra color, and for an <code>extend</code> of “both” add two colors.</p>  <p><strong>extend</strong> : {‘neither’, ‘min’, ‘max’, ‘both’}, optional</p>  <p>The behaviour when a value falls out of range of the given levels. See <a class="reference internal" href="../pyplot_api/#matplotlib.pyplot.contourf" title="matplotlib.pyplot.contourf"><code>contourf()</code></a> for details.</p>  </td> </tr> <tr class="field-even field">
<th class="field-name">Returns:</th>
<td class="field-body">
<p class="first last"><strong>(cmap, norm)</strong> : tuple containing a <a class="reference internal" href="#matplotlib.colors.Colormap" title="matplotlib.colors.Colormap"><code>Colormap</code></a> and a <a class="reference internal" href="#matplotlib.colors.Normalize" title="matplotlib.colors.Normalize"><code>Normalize</code></a> instance</p> </td> </tr>  </table> </dd>
</dl> <dl class="function"> <dt id="matplotlib.colors.get_named_colors_mapping">
<code>matplotlib.colors.get_named_colors_mapping()</code> </dt> <dd>
<p>Return the global mapping of names to named colors.</p> </dd>
</dl> <dl class="function"> <dt id="matplotlib.colors.hsv_to_rgb">
<code>matplotlib.colors.hsv_to_rgb(hsv)</code> </dt> <dd>
<p>convert hsv values in a numpy array to rgb values all values assumed to be in range [0, 1]</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr class="field-odd field">
<th class="field-name">Parameters:</th>
<td class="field-body">
<p class="first"><strong>hsv</strong> : (..., 3) array-like</p>  <p>All values assumed to be in range [0, 1]</p>  </td> </tr> <tr class="field-even field">
<th class="field-name">Returns:</th>
<td class="field-body">
<p class="first"><strong>rgb</strong> : (..., 3) ndarray</p>  <p>Colors converted to RGB values in range [0, 1]</p>  </td> </tr>  </table> </dd>
</dl> <dl class="function"> <dt id="matplotlib.colors.is_color_like">
<code>matplotlib.colors.is_color_like(c)</code> </dt> <dd>
<p>Return whether <code>c</code> can be interpreted as an RGB(A) color.</p> </dd>
</dl> <dl class="function"> <dt id="matplotlib.colors.makeMappingArray">
<code>matplotlib.colors.makeMappingArray(N, data, gamma=1.0)</code> </dt> <dd>
<p>Create an <em>N</em> -element 1-d lookup table</p> <p><em>data</em> represented by a list of x,y0,y1 mapping correspondences. Each element in this list represents how a value between 0 and 1 (inclusive) represented by x is mapped to a corresponding value between 0 and 1 (inclusive). The two values of y are to allow for discontinuous mapping functions (say as might be found in a sawtooth) where y0 represents the value of y for values of x &lt;= to that given, and y1 is the value to be used for x &gt; than that given). The list must start with x=0, end with x=1, and all values of x must be in increasing order. Values between the given mapping points are determined by simple linear interpolation.</p> <p>Alternatively, data can be a function mapping values between 0 - 1 to 0 - 1.</p> <p>The function returns an array “result” where <code>result[x*(N-1)]</code> gives the closest value for values of x between 0 and 1.</p> </dd>
</dl> <dl class="function"> <dt id="matplotlib.colors.rgb_to_hsv">
<code>matplotlib.colors.rgb_to_hsv(arr)</code> </dt> <dd>
<p>convert float rgb values (in the range [0, 1]), in a numpy array to hsv values.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr class="field-odd field">
<th class="field-name">Parameters:</th>
<td class="field-body">
<p class="first"><strong>arr</strong> : (..., 3) array-like</p>  <p>All values must be in the range [0, 1]</p>  </td> </tr> <tr class="field-even field">
<th class="field-name">Returns:</th>
<td class="field-body">
<p class="first"><strong>hsv</strong> : (..., 3) ndarray</p>  <p>Colors converted to hsv values in range [0, 1]</p>  </td> </tr>  </table> </dd>
</dl> <dl class="function"> <dt id="matplotlib.colors.to_hex">
<code>matplotlib.colors.to_hex(c, keep_alpha=False)</code> </dt> <dd>
<p>Convert <code>c</code> to a hex color.</p> <p>Uses the #rrggbb format if <code>keep_alpha</code> is False (the default), <code>#rrggbbaa</code> otherwise.</p> </dd>
</dl> <dl class="function"> <dt id="matplotlib.colors.to_rgb">
<code>matplotlib.colors.to_rgb(c)</code> </dt> <dd>
<p>Convert <code>c</code> to an RGB color, silently dropping the alpha channel.</p> </dd>
</dl> <dl class="function"> <dt id="matplotlib.colors.to_rgba">
<code>matplotlib.colors.to_rgba(c, alpha=None)</code> </dt> <dd>
<p>Convert <code>c</code> to an RGBA color.</p> <p>If <code>alpha</code> is not <code>None</code>, it forces the alpha value, except if <code>c</code> is “none” (case-insensitive), which always maps to <code>(0, 0, 0, 0)</code>.</p> </dd>
</dl> <dl class="function"> <dt id="matplotlib.colors.to_rgba_array">
<code>matplotlib.colors.to_rgba_array(c, alpha=None)</code> </dt> <dd>
<p>Convert <code>c</code> to a (n, 4) array of RGBA colors.</p> <p>If <code>alpha</code> is not <code>None</code>, it forces the alpha value. If <code>c</code> is “none” (case-insensitive) or an empty list, an empty array is returned.</p> </dd>
</dl>
<div class="_attribution">
  <p class="_attribution-p">
    © 2012–2017 Matplotlib Development Team. All rights reserved.<br>Licensed under the Matplotlib License Agreement.<br>
    <a href="http://matplotlib.org/2.0.0/api/colors_api.html" class="_attribution-link" target="_blank">http://matplotlib.org/2.0.0/api/colors_api.html</a>
  </p>
</div>

			</div>
		</div>
	</section>

	</div>
</body>
</html>
