
<!DOCTYPE HTML>

<html lang="en">

<head>
  <meta charset="utf-8">
  <title>Cbook - Matplotlib 1.5 - W3cubDocs</title>
  
  <meta name="description" content=" A collection of utility functions and classes. Originally, many (but not all) were from the Python Cookbook – hence the name cbook. ">
  <meta name="keywords" content="cbook, -, matplotlib, matplotlib~1.5">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="http://docs.w3cub.com/matplotlib~1.5/cbook_api/">
  <link href="/favicon.png" rel="icon">
  <link type="text/css" rel="stylesheet" href="/assets/application-50364fff564ce3b6327021805f3f00e2957b441cf27f576a7dd4ff63bbc47047.css">
  <script type="text/javascript" src="/assets/application-db64bfd54ceb42be11af7995804cf4902548419ceb79d509b0b7d62c22d98e6f.js"></script>
  <script src="/json/matplotlib~1.5.js"></script>
  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-71174418-1']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>


</head>

<body>
	<div class="_app">
	<header class="_header">
  
  <form class="_search">
    <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
    <a class="_search-clear"></a>
    <div class="_search-tag"></div>
  </form>
  
  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/matplotlib~1.5/" class="_nav-link" title="" style="margin-left:0;">Matplotlib 1.5</a></span>
  
  <nav class="_nav">
    <a href="/app/" class="_nav-link ">App</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		<div class="_list">
			
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<div class="_page _sphinx">
				
<h1 id="cbook">cbook</h1>  <h2 id="matplotlib-cbook">matplotlib.cbook</h2> <p id="module-matplotlib.cbook">A collection of utility functions and classes. Originally, many (but not all) were from the Python Cookbook – hence the name cbook.</p> <p>This module is safe to import from anywhere within matplotlib; it imports matplotlib only at runtime.</p> <dl class="class"> <dt id="matplotlib.cbook.Bunch">
<code>class matplotlib.cbook.Bunch(**kwds)</code> </dt> <dd>
<p>Bases: <code>object</code></p> <p>Often we want to just collect a bunch of stuff together, naming each item of the bunch; a dictionary’s OK for that, but a small do- nothing class is even handier, and prettier to use. Whenever you want to group a few variables:</p> <pre data-language="python">&gt;&gt;&gt; point = Bunch(datum=2, squared=4, coord=12)
&gt;&gt;&gt; point.datum

By: Alex Martelli
From: http://aspn.activestate.com/ASPN/Cookbook/Python/Recipe/52308
</pre> </dd>
</dl> <dl class="class"> <dt id="matplotlib.cbook.CallbackRegistry">
<code>class matplotlib.cbook.CallbackRegistry</code> </dt> <dd>
<p>Bases: <code>object</code></p> <p>Handle registering and disconnecting for a set of signals and callbacks:</p> <pre data-language="python">&gt;&gt;&gt; def oneat(x):
...    print('eat', x)
&gt;&gt;&gt; def ondrink(x):
...    print('drink', x)
</pre> <pre data-language="python">&gt;&gt;&gt; from matplotlib.cbook import CallbackRegistry
&gt;&gt;&gt; callbacks = CallbackRegistry()
</pre> <pre data-language="python">&gt;&gt;&gt; id_eat = callbacks.connect('eat', oneat)
&gt;&gt;&gt; id_drink = callbacks.connect('drink', ondrink)
</pre> <pre data-language="python">&gt;&gt;&gt; callbacks.process('drink', 123)
drink 123
&gt;&gt;&gt; callbacks.process('eat', 456)
eat 456
&gt;&gt;&gt; callbacks.process('be merry', 456) # nothing will be called
&gt;&gt;&gt; callbacks.disconnect(id_eat)
&gt;&gt;&gt; callbacks.process('eat', 456)      # nothing will be called
</pre> <p>In practice, one should always disconnect all callbacks when they are no longer needed to avoid dangling references (and thus memory leaks). However, real code in matplotlib rarely does so, and due to its design, it is rather difficult to place this kind of code. To get around this, and prevent this class of memory leaks, we instead store weak references to bound methods only, so when the destination object needs to die, the CallbackRegistry won’t keep it alive. The Python stdlib weakref module can not create weak references to bound methods directly, so we need to create a proxy object to handle weak references to bound methods (or regular free functions). This technique was shared by Peter Parente on his <a class="reference external" href="http://mindtrove.info/python-weak-references/" target="_blank">“Mindtrove” blog</a>.</p> <dl class="method"> <dt id="matplotlib.cbook.CallbackRegistry.connect">
<code>connect(s, func)</code> </dt> <dd>
<p>register <em>func</em> to be called when a signal <em>s</em> is generated func will be called</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.cbook.CallbackRegistry.disconnect">
<code>disconnect(cid)</code> </dt> <dd>
<p>disconnect the callback registered with callback id <em>cid</em></p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.cbook.CallbackRegistry.process">
<code>process(s, *args, **kwargs)</code> </dt> <dd>
<p>process signal <em>s</em>. All of the functions registered to receive callbacks on <em>s</em> will be called with <em>*args</em> and <em>**kwargs</em></p> </dd>
</dl> </dd>
</dl> <dl class="class"> <dt id="matplotlib.cbook.GetRealpathAndStat">
<code>class matplotlib.cbook.GetRealpathAndStat</code> </dt> <dd>
<p>Bases: <code>object</code></p> </dd>
</dl> <dl class="class"> <dt id="matplotlib.cbook.Grouper">
<code>class matplotlib.cbook.Grouper(init=())</code> </dt> <dd>
<p>Bases: <code>object</code></p> <p>This class provides a lightweight way to group arbitrary objects together into disjoint sets when a full-blown graph data structure would be overkill.</p> <p>Objects can be joined using <a class="reference internal" href="#matplotlib.cbook.Grouper.join" title="matplotlib.cbook.Grouper.join"><code>join()</code></a>, tested for connectedness using <a class="reference internal" href="#matplotlib.cbook.Grouper.joined" title="matplotlib.cbook.Grouper.joined"><code>joined()</code></a>, and all disjoint sets can be retreived by using the object as an iterator.</p> <p>The objects being joined must be hashable and weak-referenceable.</p> <p>For example:</p> <pre data-language="python">&gt;&gt;&gt; from matplotlib.cbook import Grouper
&gt;&gt;&gt; class Foo(object):
...     def __init__(self, s):
...         self.s = s
...     def __repr__(self):
...         return self.s
...
&gt;&gt;&gt; a, b, c, d, e, f = [Foo(x) for x in 'abcdef']
&gt;&gt;&gt; grp = Grouper()
&gt;&gt;&gt; grp.join(a, b)
&gt;&gt;&gt; grp.join(b, c)
&gt;&gt;&gt; grp.join(d, e)
&gt;&gt;&gt; sorted(map(tuple, grp))
[(a, b, c), (d, e)]
&gt;&gt;&gt; grp.joined(a, b)
True
&gt;&gt;&gt; grp.joined(a, c)
True
&gt;&gt;&gt; grp.joined(a, d)
False
</pre> <dl class="method"> <dt id="matplotlib.cbook.Grouper.clean">
<code>clean()</code> </dt> <dd>
<p>Clean dead weak references from the dictionary</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.cbook.Grouper.get_siblings">
<code>get_siblings(a)</code> </dt> <dd>
<p>Returns all of the items joined with <em>a</em>, including itself.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.cbook.Grouper.join">
<code>join(a, *args)</code> </dt> <dd>
<p>Join given arguments into the same set. Accepts one or more arguments.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.cbook.Grouper.joined">
<code>joined(a, b)</code> </dt> <dd>
<p>Returns True if <em>a</em> and <em>b</em> are members of the same set.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.cbook.Grouper.remove">
<code>remove(a)</code> </dt> 
</dl> </dd>
</dl> <dl class="exception"> <dt id="matplotlib.cbook.IgnoredKeywordWarning">
<code>exception matplotlib.cbook.IgnoredKeywordWarning</code> </dt> <dd>
<p>Bases: <code>UserWarning</code></p> <p>A class for issuing warnings about keyword arguments that will be ignored by matplotlib</p> </dd>
</dl> <dl class="exception"> <dt id="matplotlib.cbook.MatplotlibDeprecationWarning">
<code>exception matplotlib.cbook.MatplotlibDeprecationWarning</code> </dt> <dd>
<p>Bases: <code>UserWarning</code></p> <p>A class for issuing deprecation warnings for Matplotlib users.</p> <p>In light of the fact that Python builtin DeprecationWarnings are ignored by default as of Python 2.7 (see link below), this class was put in to allow for the signaling of deprecation, but via UserWarnings which are not ignored by default.</p> <p><a class="reference external" href="http://docs.python.org/dev/whatsnew/2.7.html#the-future-for-python-2-x" target="_blank">http://docs.python.org/dev/whatsnew/2.7.html#the-future-for-python-2-x</a></p> </dd>
</dl> <dl class="class"> <dt id="matplotlib.cbook.MemoryMonitor">
<code>class matplotlib.cbook.MemoryMonitor(nmax=20000)</code> </dt> <dd>
<p>Bases: <code>object</code></p> <dl class="method"> <dt id="matplotlib.cbook.MemoryMonitor.clear">
<code>clear()</code> </dt> 
</dl> <dl class="method"> <dt id="matplotlib.cbook.MemoryMonitor.plot">
<code>plot(i0=0, isub=1, fig=None)</code> </dt> 
</dl> <dl class="method"> <dt id="matplotlib.cbook.MemoryMonitor.report">
<code>report(segments=4)</code> </dt> 
</dl> <dl class="method"> <dt id="matplotlib.cbook.MemoryMonitor.xy">
<code>xy(i0=0, isub=1)</code> </dt> 
</dl> </dd>
</dl> <dl class="class"> <dt id="matplotlib.cbook.Null">
<code>class matplotlib.cbook.Null(*args, **kwargs)</code> </dt> <dd>
<p>Bases: <code>object</code></p> <p>Null objects always and reliably “do nothing.”</p> </dd>
</dl> <dl class="class"> <dt id="matplotlib.cbook.RingBuffer">
<code>class matplotlib.cbook.RingBuffer(size_max)</code> </dt> <dd>
<p>Bases: <code>object</code></p> <p>class that implements a not-yet-full buffer</p> <dl class="method"> <dt id="matplotlib.cbook.RingBuffer.append">
<code>append(x)</code> </dt> <dd>
<p>append an element at the end of the buffer</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.cbook.RingBuffer.get">
<code>get()</code> </dt> <dd>
<p>Return a list of elements from the oldest to the newest.</p> </dd>
</dl> </dd>
</dl> <dl class="class"> <dt id="matplotlib.cbook.Sorter">
<code>class matplotlib.cbook.Sorter</code> </dt> <dd>
<p>Bases: <code>object</code></p> <p>Sort by attribute or item</p> <p>Example usage:</p> <pre data-language="python">sort = Sorter()

list = [(1, 2), (4, 8), (0, 3)]
dict = [{'a': 3, 'b': 4}, {'a': 5, 'b': 2}, {'a': 0, 'b': 0},
        {'a': 9, 'b': 9}]

sort(list)       # default sort
sort(list, 1)    # sort by index 1
sort(dict, 'a')  # sort a list of dicts by key 'a'
</pre> <dl class="method"> <dt id="matplotlib.cbook.Sorter.byAttribute">
<code>byAttribute(data, attributename, inplace=1)</code> </dt> 
</dl> <dl class="method"> <dt id="matplotlib.cbook.Sorter.byItem">
<code>byItem(data, itemindex=None, inplace=1)</code> </dt> 
</dl> <dl class="method"> <dt id="matplotlib.cbook.Sorter.sort">
<code>sort(data, itemindex=None, inplace=1)</code> </dt> 
</dl> </dd>
</dl> <dl class="class"> <dt id="matplotlib.cbook.Stack">
<code>class matplotlib.cbook.Stack(default=None)</code> </dt> <dd>
<p>Bases: <code>object</code></p> <p>Implement a stack where elements can be pushed on and you can move back and forth. But no pop. Should mimic home / back / forward in a browser</p> <dl class="method"> <dt id="matplotlib.cbook.Stack.back">
<code>back()</code> </dt> <dd>
<p>move the position back and return the current element</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.cbook.Stack.bubble">
<code>bubble(o)</code> </dt> <dd>
<p>raise <em>o</em> to the top of the stack and return <em>o</em>. <em>o</em> must be in the stack</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.cbook.Stack.clear">
<code>clear()</code> </dt> <dd>
<p>empty the stack</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.cbook.Stack.empty">
<code>empty()</code> </dt> 
</dl> <dl class="method"> <dt id="matplotlib.cbook.Stack.forward">
<code>forward()</code> </dt> <dd>
<p>move the position forward and return the current element</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.cbook.Stack.home">
<code>home()</code> </dt> <dd>
<p>push the first element onto the top of the stack</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.cbook.Stack.push">
<code>push(o)</code> </dt> <dd>
<p>push object onto stack at current position - all elements occurring later than the current position are discarded</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.cbook.Stack.remove">
<code>remove(o)</code> </dt> <dd>
<p>remove element <em>o</em> from the stack</p> </dd>
</dl> </dd>
</dl> <dl class="class"> <dt id="matplotlib.cbook.Xlator">
<code>class matplotlib.cbook.Xlator</code> </dt> <dd>
<p>Bases: <code>dict</code></p> <p>All-in-one multiple-string-substitution class</p> <p>Example usage:</p> <pre data-language="python">text = "Larry Wall is the creator of Perl"
adict = {
"Larry Wall" : "Guido van Rossum",
"creator" : "Benevolent Dictator for Life",
"Perl" : "Python",
}

print(multiple_replace(adict, text))

xlat = Xlator(adict)
print(xlat.xlat(text))
</pre> <dl class="method"> <dt id="matplotlib.cbook.Xlator.xlat">
<code>xlat(text)</code> </dt> <dd>
<p>Translate <em>text</em>, returns the modified text.</p> </dd>
</dl> </dd>
</dl> <dl class="function"> <dt id="matplotlib.cbook.align_iterators">
<code>matplotlib.cbook.align_iterators(func, *iterables)</code> </dt> <dd>
<p>This generator takes a bunch of iterables that are ordered by func It sends out ordered tuples:</p> <pre data-language="python">(func(row), [rows from all iterators matching func(row)])
</pre> <p>It is used by <a class="reference internal" href="../mlab_api/#matplotlib.mlab.recs_join" title="matplotlib.mlab.recs_join"><code>matplotlib.mlab.recs_join()</code></a> to join record arrays</p> </dd>
</dl> <dl class="function"> <dt id="matplotlib.cbook.allequal">
<code>matplotlib.cbook.allequal(seq)</code> </dt> <dd>
<p>Return <em>True</em> if all elements of <em>seq</em> compare equal. If <em>seq</em> is 0 or 1 length, return <em>True</em></p> </dd>
</dl> <dl class="function"> <dt id="matplotlib.cbook.allpairs">
<code>matplotlib.cbook.allpairs(x)</code> </dt> <dd>
<p>return all possible pairs in sequence <em>x</em></p> <p>Condensed by Alex Martelli from this <a class="reference external" href="http://groups.google.com/groups?q=all+pairs+group:*python*&amp;hl=en&amp;lr=&amp;ie=UTF-8&amp;selm=mailman.4028.1096403649.5135.python-list%40python.org&amp;rnum=1" target="_blank">thread</a> on c.l.python</p> </dd>
</dl> <dl class="function"> <dt id="matplotlib.cbook.alltrue">
<code>matplotlib.cbook.alltrue(seq)</code> </dt> <dd>
<p>Return <em>True</em> if all elements of <em>seq</em> evaluate to <em>True</em>. If <em>seq</em> is empty, return <em>False</em>.</p> </dd>
</dl> <dl class="function"> <dt id="matplotlib.cbook.boxplot_stats">
<code>matplotlib.cbook.boxplot_stats(X, whis=1.5, bootstrap=None, labels=None, autorange=False)</code> </dt> <dd>
<p>Returns list of dictionaries of statistics used to draw a series of box and whisker plots. The <code>Returns</code> section enumerates the required keys of the dictionary. Users can skip this function and pass a user-defined set of dictionaries to the new <code>axes.bxp</code> method instead of relying on MPL to do the calculations.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr class="field-odd field">
<th class="field-name">Parameters:</th>
<td class="field-body">
<p class="first"><strong>X</strong> : array-like</p>  <p>Data that will be represented in the boxplots. Should have 2 or fewer dimensions.</p>  <p><strong>whis</strong> : float, string, or sequence (default = 1.5)</p>  <p>As a float, determines the reach of the whiskers past the first and third quartiles (e.g., Q3 + whis*IQR, QR = interquartile range, Q3-Q1). Beyond the whiskers, data are considered outliers and are plotted as individual points. This can be set this to an ascending sequence of percentile (e.g., [5, 95]) to set the whiskers at specific percentiles of the data. Finally, <code>whis</code> can be the string <code>'range'</code> to force the whiskers to the minimum and maximum of the data. In the edge case that the 25th and 75th percentiles are equivalent, <code>whis</code> can be automatically set to <code>'range'</code> via the <code>autorange</code> option.</p>  <p><strong>bootstrap</strong> : int, optional</p>  <p>Number of times the confidence intervals around the median should be bootstrapped (percentile method).</p>  <p><strong>labels</strong> : array-like, optional</p>  <p>Labels for each dataset. Length must be compatible with dimensions of <code>X</code>.</p>  <p><strong>autorange</strong> : bool, optional (False)</p>  <p>When <code>True</code> and the data are distributed such that the 25th and 75th percentiles are equal, <code>whis</code> is set to <code>'range'</code> such that the whisker ends are at the minimum and maximum of the data.</p>  </td> </tr> <tr class="field-even field">
<th class="field-name">Returns:</th>
<td class="field-body">
<p class="first"><strong>bxpstats</strong> : list of dict</p>  <p>A list of dictionaries containing the results for each column of data. Keys of each dictionary are the following:</p> <table class="docutils">  <thead valign="bottom"> <tr class="row-odd">
<th class="head">Key</th> <th class="head">Value Description</th> </tr> </thead>  <tr class="row-even">
<td>label</td> <td>tick label for the boxplot</td> </tr> <tr class="row-odd">
<td>mean</td> <td>arithemetic mean value</td> </tr> <tr class="row-even">
<td>med</td> <td>50th percentile</td> </tr> <tr class="row-odd">
<td>q1</td> <td>first quartile (25th percentile)</td> </tr> <tr class="row-even">
<td>q3</td> <td>third quartile (75th percentile)</td> </tr> <tr class="row-odd">
<td>cilo</td> <td>lower notch around the median</td> </tr> <tr class="row-even">
<td>cihi</td> <td>upper notch around the median</td> </tr> <tr class="row-odd">
<td>whislo</td> <td>end of the lower whisker</td> </tr> <tr class="row-even">
<td>whishi</td> <td>end of the upper whisker</td> </tr> <tr class="row-odd">
<td>fliers</td> <td>outliers</td> </tr>  </table>  </td> </tr>  </table> <h4 class="rubric">Notes</h4> <p>Non-bootstrapping approach to confidence interval uses Gaussian- based asymptotic approximation:</p> <img src="http://matplotlib.org/1.5.3/_images/mathmpl/math-1742f7b9ed.png" class="center"><p>General approach from: McGill, R., Tukey, J.W., and Larsen, W.A. (1978) “Variations of Boxplots”, The American Statistician, 32:12-16.</p> </dd>
</dl> <dl class="class"> <dt id="matplotlib.cbook.converter">
<code>class matplotlib.cbook.converter(missing='Null', missingval=None)</code> </dt> <dd>
<p>Bases: <code>object</code></p> <p>Base class for handling string -&gt; python type with support for missing values</p> <dl class="method"> <dt id="matplotlib.cbook.converter.is_missing">
<code>is_missing(s)</code> </dt> 
</dl> </dd>
</dl> <dl class="function"> <dt id="matplotlib.cbook.dedent">
<code>matplotlib.cbook.dedent(s)</code> </dt> <dd>
<p>Remove excess indentation from docstring <em>s</em>.</p> <p>Discards any leading blank lines, then removes up to n whitespace characters from each line, where n is the number of leading whitespace characters in the first line. It differs from textwrap.dedent in its deletion of leading blank lines and its use of the first non-blank line to determine the indentation.</p> <p>It is also faster in most cases.</p> </dd>
</dl> <dl class="function"> <dt id="matplotlib.cbook.delete_masked_points">
<code>matplotlib.cbook.delete_masked_points(*args)</code> </dt> <dd>
<p>Find all masked and/or non-finite points in a set of arguments, and return the arguments with only the unmasked points remaining.</p> <p>Arguments can be in any of 5 categories:</p> <ol class="arabic simple"> <li>1-D masked arrays</li> <li>1-D ndarrays</li> <li>ndarrays with more than one dimension</li> <li>other non-string iterables</li> <li>anything else</li> </ol> <p>The first argument must be in one of the first four categories; any argument with a length differing from that of the first argument (and hence anything in category 5) then will be passed through unchanged.</p> <p>Masks are obtained from all arguments of the correct length in categories 1, 2, and 4; a point is bad if masked in a masked array or if it is a nan or inf. No attempt is made to extract a mask from categories 2, 3, and 4 if <code>np.isfinite()</code> does not yield a Boolean array.</p> <p>All input arguments that are not passed unchanged are returned as ndarrays after removing the points or rows corresponding to masks in any of the arguments.</p> <p>A vastly simpler version of this function was originally written as a helper for Axes.scatter().</p> </dd>
</dl> <dl class="function"> <dt id="matplotlib.cbook.deprecated">
<code>matplotlib.cbook.deprecated(since, message='', name='', alternative='', pending=False, obj_type='function')</code> </dt> <dd>
<p>Decorator to mark a function as deprecated.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr class="field-odd field">
<th class="field-name">Parameters:</th>
<td class="field-body">
<p class="first"><strong>since</strong> : str</p>  <p>The release at which this API became deprecated. This is required.</p>  <p><strong>message</strong> : str, optional</p>  <p>Override the default deprecation message. The format specifier <code>%(func)s</code> may be used for the name of the function, and <code>%(alternative)s</code> may be used in the deprecation message to insert the name of an alternative to the deprecated function. <code>%(obj_type)</code> may be used to insert a friendly name for the type of object being deprecated.</p>  <p><strong>name</strong> : str, optional</p>  <p>The name of the deprecated function; if not provided the name is automatically determined from the passed in function, though this is useful in the case of renamed functions, where the new function is just assigned to the name of the deprecated function. For example:</p> <pre data-language="python">def new_function():
    ...
oldFunction = new_function
</pre>  <p><strong>alternative</strong> : str, optional</p>  <p>An alternative function that the user may use in place of the deprecated function. The deprecation warning will tell the user about this alternative if provided.</p>  <p><strong>pending</strong> : bool, optional</p>  <p>If True, uses a PendingDeprecationWarning instead of a DeprecationWarning.</p>  </td> </tr>  </table> <h4 class="rubric">Examples</h4> <p>Basic example:</p> <pre data-language="python">@deprecated('1.4.0')
def the_function_to_deprecate():
    pass
</pre> </dd>
</dl> <dl class="function"> <dt id="matplotlib.cbook.dict_delall">
<code>matplotlib.cbook.dict_delall(d, keys)</code> </dt> <dd>
<p>delete all of the <em>keys</em> from the <code>dict</code> <em>d</em></p> </dd>
</dl> <dl class="function"> <dt id="matplotlib.cbook.exception_to_str">
<code>matplotlib.cbook.exception_to_str(s=None)</code> </dt> 
</dl> <dl class="function"> <dt id="matplotlib.cbook.file_requires_unicode">
<code>matplotlib.cbook.file_requires_unicode(x)</code> </dt> <dd>
<p>Returns <code>True</code> if the given writable file-like object requires Unicode to be written to it.</p> </dd>
</dl> <dl class="function"> <dt id="matplotlib.cbook.finddir">
<code>matplotlib.cbook.finddir(o, match, case=False)</code> </dt> <dd>
<p>return all attributes of <em>o</em> which match string in match. if case is True require an exact case match.</p> </dd>
</dl> <dl class="function"> <dt id="matplotlib.cbook.flatten">
<code>matplotlib.cbook.flatten(seq, scalarp=<function is_scalar_or_string>)</function></code> </dt> <dd>
<p>Returns a generator of flattened nested containers</p> <p>For example:</p> <pre data-language="python">&gt;&gt;&gt; from matplotlib.cbook import flatten
&gt;&gt;&gt; l = (('John', ['Hunter']), (1, 23), [[([42, (5, 23)], )]])
&gt;&gt;&gt; print(list(flatten(l)))
['John', 'Hunter', 1, 23, 42, 5, 23]
</pre> <p>By: Composite of Holger Krekel and Luther Blissett From: <a class="reference external" href="http://aspn.activestate.com/ASPN/Cookbook/Python/Recipe/121294" target="_blank">http://aspn.activestate.com/ASPN/Cookbook/Python/Recipe/121294</a> and Recipe 1.12 in cookbook</p> </dd>
</dl> <dl class="function"> <dt id="matplotlib.cbook.get_label">
<code>matplotlib.cbook.get_label(y, default_name)</code> </dt> 
</dl> <dl class="function"> <dt id="matplotlib.cbook.get_recursive_filelist">
<code>matplotlib.cbook.get_recursive_filelist(args)</code> </dt> <dd>
<p>Recurse all the files and dirs in <em>args</em> ignoring symbolic links and return the files as a list of strings</p> </dd>
</dl> <dl class="function"> <dt id="matplotlib.cbook.get_sample_data">
<code>matplotlib.cbook.get_sample_data(fname, asfileobj=True)</code> </dt> <dd>
<p>Return a sample data file. <em>fname</em> is a path relative to the <code>mpl-data/sample_data</code> directory. If <em>asfileobj</em> is <code>True</code> return a file object, otherwise just a file path.</p> <p>Set the rc parameter examples.directory to the directory where we should look, if sample_data files are stored in a location different than default (which is ‘mpl-data/sample_data` at the same level of ‘matplotlib` Python module files).</p> <p>If the filename ends in .gz, the file is implicitly ungzipped.</p> </dd>
</dl> <dl class="function"> <dt id="matplotlib.cbook.get_split_ind">
<code>matplotlib.cbook.get_split_ind(seq, N)</code> </dt> <dd>
<p><em>seq</em> is a list of words. Return the index into seq such that:</p> <pre data-language="python">len(' '.join(seq[:ind])&lt;=N
</pre> <p>.</p> </dd>
</dl> <dl class="function"> <dt id="matplotlib.cbook.index_of">
<code>matplotlib.cbook.index_of(y)</code> </dt> <dd>
<p>A helper function to get the index of an input to plot against if x values are not explicitly given.</p> <p>Tries to get <code>y.index</code> (works if this is a pd.Series), if that fails, return np.arange(y.shape[0]).</p> <p>This will be extended in the future to deal with more types of labeled data.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr class="field-odd field">
<th class="field-name">Parameters:</th>
<td class="field-body">
<p class="first"><strong>y</strong> : scalar or array-like</p>  <p>The proposed y-value</p>  </td> </tr> <tr class="field-even field">
<th class="field-name">Returns:</th>
<td class="field-body">
<p class="first"><strong>x, y</strong> : ndarray</p>  <p>The x and y values to plot.</p>  </td> </tr>  </table> </dd>
</dl> <dl class="function"> <dt id="matplotlib.cbook.is_hashable">
<code>matplotlib.cbook.is_hashable(obj)</code> </dt> <dd>
<p>Returns true if <em>obj</em> can be hashed</p> </dd>
</dl> <dl class="function"> <dt id="matplotlib.cbook.is_math_text">
<code>matplotlib.cbook.is_math_text(s)</code> </dt> 
</dl> <dl class="function"> <dt id="matplotlib.cbook.is_numlike">
<code>matplotlib.cbook.is_numlike(obj)</code> </dt> <dd>
<p>return true if <em>obj</em> looks like a number</p> </dd>
</dl> <dl class="function"> <dt id="matplotlib.cbook.is_scalar">
<code>matplotlib.cbook.is_scalar(obj)</code> </dt> <dd>
<p>return true if <em>obj</em> is not string like and is not iterable</p> </dd>
</dl> <dl class="function"> <dt id="matplotlib.cbook.is_scalar_or_string">
<code>matplotlib.cbook.is_scalar_or_string(val)</code> </dt> <dd>
<p>Return whether the given object is a scalar or string like.</p> </dd>
</dl> <dl class="function"> <dt id="matplotlib.cbook.is_sequence_of_strings">
<code>matplotlib.cbook.is_sequence_of_strings(obj)</code> </dt> <dd>
<p>Returns true if <em>obj</em> is iterable and contains strings</p> </dd>
</dl> <dl class="function"> <dt id="matplotlib.cbook.is_string_like">
<code>matplotlib.cbook.is_string_like(obj)</code> </dt> <dd>
<p>Return True if <em>obj</em> looks like a string</p> </dd>
</dl> <dl class="function"> <dt id="matplotlib.cbook.is_writable_file_like">
<code>matplotlib.cbook.is_writable_file_like(obj)</code> </dt> <dd>
<p>return true if <em>obj</em> looks like a file object with a <em>write</em> method</p> </dd>
</dl> <dl class="function"> <dt id="matplotlib.cbook.issubclass_safe">
<code>matplotlib.cbook.issubclass_safe(x, klass)</code> </dt> <dd>
<p>return issubclass(x, klass) and return False on a TypeError</p> </dd>
</dl> <dl class="function"> <dt id="matplotlib.cbook.iterable">
<code>matplotlib.cbook.iterable(obj)</code> </dt> <dd>
<p>return true if <em>obj</em> is iterable</p> </dd>
</dl> <dl class="function"> <dt id="matplotlib.cbook.listFiles">
<code>matplotlib.cbook.listFiles(root, patterns='*', recurse=1, return_folders=0)</code> </dt> <dd>
<p>Recursively list files</p> <p>from Parmar and Martelli in the Python Cookbook</p> </dd>
</dl> <dl class="function"> <dt id="matplotlib.cbook.local_over_kwdict">
<code>matplotlib.cbook.local_over_kwdict(local_var, kwargs, *keys)</code> </dt> <dd>
<p>Enforces the priority of a local variable over potentially conflicting argument(s) from a kwargs dict. The following possible output values are considered in order of priority:</p>  local_var &gt; kwargs[keys[0]] &gt; ... &gt; kwargs[keys[-1]] <p>The first of these whose value is not None will be returned. If all are None then None will be returned. Each key in keys will be removed from the kwargs dict in place.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr class="field-odd field">
<th class="field-name">Parameters:</th>
<td class="field-body">
<p class="first"><strong>local_var: any object</strong></p>   <p>The local variable (highest priority)</p>  <dl class="docutils"> <dt>kwargs: dict</dt> <dd>
<p class="first last">Dictionary of keyword arguments; modified in place</p> </dd> <dt>keys: str(s)</dt> <dd>
<p class="first last">Name(s) of keyword arguments to process, in descending order of priority</p> </dd> </dl>  </td> </tr> <tr class="field-even field">
<th class="field-name">Returns:</th>
<td class="field-body">
<p class="first">out: any object</p>  <p>Either local_var or one of kwargs[key] for key in keys</p>  </td> </tr> <tr class="field-odd field">
<th class="field-name">Raises:</th>
<td class="field-body">
<p class="first"><strong>IgnoredKeywordWarning</strong></p>  <p>For each key in keys that is removed from kwargs but not used as the output value</p>  </td> </tr>  </table> </dd>
</dl> <dl class="class"> <dt id="matplotlib.cbook.maxdict">
<code>class matplotlib.cbook.maxdict(maxsize)</code> </dt> <dd>
<p>Bases: <code>dict</code></p> <p>A dictionary with a maximum size; this doesn’t override all the relevant methods to contrain size, just setitem, so use with caution</p> </dd>
</dl> <dl class="function"> <dt id="matplotlib.cbook.mkdirs">
<code>matplotlib.cbook.mkdirs(newdir, mode=511)</code> </dt> <dd>
<p>make directory <em>newdir</em> recursively, and set <em>mode</em>. Equivalent to</p> <pre data-language="python">&gt; mkdir -p NEWDIR
&gt; chmod MODE NEWDIR
</pre> </dd>
</dl> <dl class="attribute"> <dt id="matplotlib.cbook.mplDeprecation">
<code>matplotlib.cbook.mplDeprecation</code> </dt> <dd>
<p>alias of <a class="reference internal" href="#matplotlib.cbook.MatplotlibDeprecationWarning" title="matplotlib.cbook.MatplotlibDeprecationWarning"><code>MatplotlibDeprecationWarning</code></a></p> </dd>
</dl> <dl class="function"> <dt id="matplotlib.cbook.normalize_kwargs">
<code>matplotlib.cbook.normalize_kwargs(kw, alias_mapping=None, required=(), forbidden=(), allowed=None)</code> </dt> <dd>
<p>Helper function to normalize kwarg inputs</p> <p>The order they are resolved are:</p>  <ol class="arabic simple"> <li>aliasing</li> <li>required</li> <li>forbidden</li> <li>allowed</li> </ol>  <p>This order means that only the canonical names need appear in <code>allowed</code>, <code>forbidden</code>, <code>required</code></p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr class="field-odd field">
<th class="field-name">Parameters:</th>
<td class="field-body">
<p class="first"><strong>alias_mapping, dict, optional</strong></p>  <p>A mapping between a canonical name to a list of aliases, in order of precedence from lowest to highest.</p> <p>If the canonical value is not in the list it is assumed to have the highest priority.</p>  <p><strong>required</strong> : iterable, optional</p>  <p>A tuple of fields that must be in kwargs.</p>  <p><strong>forbidden</strong> : iterable, optional</p>  <p>A list of keys which may not be in kwargs</p>  <p><strong>allowed</strong> : tuple, optional</p>  <p>A tuple of allowed fields. If this not None, then raise if <code>kw</code> contains any keys not in the union of <code>required</code> and <code>allowed</code>. To allow only the required fields pass in <code>()</code> for <code>allowed</code></p>  </td> </tr> <tr class="field-even field">
<th class="field-name">Raises:</th>
<td class="field-body">
<p class="first"><strong>TypeError</strong></p>  <p>To match what python raises if invalid args/kwargs are passed to a callable.</p>  </td> </tr>  </table> </dd>
</dl> <dl class="function"> <dt id="matplotlib.cbook.onetrue">
<code>matplotlib.cbook.onetrue(seq)</code> </dt> <dd>
<p>Return <em>True</em> if one element of <em>seq</em> is <em>True</em>. It <em>seq</em> is empty, return <em>False</em>.</p> </dd>
</dl> <dl class="function"> <dt id="matplotlib.cbook.pieces">
<code>matplotlib.cbook.pieces(seq, num=2)</code> </dt> <dd>
<p>Break up the <em>seq</em> into <em>num</em> tuples</p> </dd>
</dl> <dl class="function"> <dt id="matplotlib.cbook.popall">
<code>matplotlib.cbook.popall(seq)</code> </dt> <dd>
<p>empty a list</p> </dd>
</dl> <dl class="function"> <dt id="matplotlib.cbook.print_cycles">
<code>matplotlib.cbook.print_cycles(objects, outstream=<_io.textiowrapper name="&lt;stdout&gt;" mode="w" encoding="UTF-8">, show_progress=False)</_io.textiowrapper></code> </dt> <dd>
<dl class="docutils"> <dt><em>objects</em></dt> <dd>A list of objects to find cycles in. It is often useful to pass in gc.garbage to find the cycles that are preventing some objects from being garbage collected.</dd> <dt><em>outstream</em></dt> <dd>The stream for output.</dd> <dt><em>show_progress</em></dt> <dd>If True, print the number of objects reached as they are found.</dd> </dl> </dd>
</dl> <dl class="function"> <dt id="matplotlib.cbook.pts_to_midstep">
<code>matplotlib.cbook.pts_to_midstep(x, *args)</code> </dt> <dd>
<p>Covert continuous line to pre-steps</p> <p>Given a set of N points convert to 2 N -1 points which when connected linearly give a step function which changes values at the begining the intervals.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr class="field-odd field">
<th class="field-name">Parameters:</th>
<td class="field-body">
<p class="first"><strong>x</strong> : array</p>  <p>The x location of the steps</p>  <p><strong>y1, y2, ...</strong> : array</p>  <p>Any number of y arrays to be turned into steps. All must be the same length as <code>x</code></p>  </td> </tr> <tr class="field-even field">
<th class="field-name">Returns:</th>
<td class="field-body">
<p class="first"><strong>x, y1, y2, ..</strong> : array</p>  <p>The x and y values converted to steps in the same order as the input. If the input is length <code>N</code>, each of these arrays will be length <code>2N + 1</code></p>  </td> </tr>  </table> <h4 class="rubric">Examples</h4> <p>&gt;&gt; x_s, y1_s, y2_s = pts_to_prestep(x, y1, y2)</p> </dd>
</dl> <dl class="function"> <dt id="matplotlib.cbook.pts_to_poststep">
<code>matplotlib.cbook.pts_to_poststep(x, *args)</code> </dt> <dd>
<p>Covert continuous line to pre-steps</p> <p>Given a set of N points convert to 2 N -1 points which when connected linearly give a step function which changes values at the begining the intervals.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr class="field-odd field">
<th class="field-name">Parameters:</th>
<td class="field-body">
<p class="first"><strong>x</strong> : array</p>  <p>The x location of the steps</p>  <p><strong>y1, y2, ...</strong> : array</p>  <p>Any number of y arrays to be turned into steps. All must be the same length as <code>x</code></p>  </td> </tr> <tr class="field-even field">
<th class="field-name">Returns:</th>
<td class="field-body">
<p class="first"><strong>x, y1, y2, ..</strong> : array</p>  <p>The x and y values converted to steps in the same order as the input. If the input is length <code>N</code>, each of these arrays will be length <code>2N + 1</code></p>  </td> </tr>  </table> <h4 class="rubric">Examples</h4> <p>&gt;&gt; x_s, y1_s, y2_s = pts_to_prestep(x, y1, y2)</p> </dd>
</dl> <dl class="function"> <dt id="matplotlib.cbook.pts_to_prestep">
<code>matplotlib.cbook.pts_to_prestep(x, *args)</code> </dt> <dd>
<p>Covert continuous line to pre-steps</p> <p>Given a set of N points convert to 2 N -1 points which when connected linearly give a step function which changes values at the begining the intervals.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr class="field-odd field">
<th class="field-name">Parameters:</th>
<td class="field-body">
<p class="first"><strong>x</strong> : array</p>  <p>The x location of the steps</p>  <p><strong>y1, y2, ...</strong> : array</p>  <p>Any number of y arrays to be turned into steps. All must be the same length as <code>x</code></p>  </td> </tr> <tr class="field-even field">
<th class="field-name">Returns:</th>
<td class="field-body">
<p class="first"><strong>x, y1, y2, ..</strong> : array</p>  <p>The x and y values converted to steps in the same order as the input. If the input is length <code>N</code>, each of these arrays will be length <code>2N + 1</code></p>  </td> </tr>  </table> <h4 class="rubric">Examples</h4> <p>&gt;&gt; x_s, y1_s, y2_s = pts_to_prestep(x, y1, y2)</p> </dd>
</dl> <dl class="function"> <dt id="matplotlib.cbook.recursive_remove">
<code>matplotlib.cbook.recursive_remove(path)</code> </dt> 
</dl> <dl class="function"> <dt id="matplotlib.cbook.report_memory">
<code>matplotlib.cbook.report_memory(i=0)</code> </dt> <dd>
<p>return the memory consumed by process</p> </dd>
</dl> <dl class="function"> <dt id="matplotlib.cbook.restrict_dict">
<code>matplotlib.cbook.restrict_dict(d, keys)</code> </dt> <dd>
<p>Return a dictionary that contains those keys that appear in both d and keys, with values from d.</p> </dd>
</dl> <dl class="function"> <dt id="matplotlib.cbook.reverse_dict">
<code>matplotlib.cbook.reverse_dict(d)</code> </dt> <dd>
<p>reverse the dictionary – may lose data if values are not unique!</p> </dd>
</dl> <dl class="function"> <dt id="matplotlib.cbook.safe_first_element">
<code>matplotlib.cbook.safe_first_element(obj)</code> </dt> 
</dl> <dl class="function"> <dt id="matplotlib.cbook.safe_masked_invalid">
<code>matplotlib.cbook.safe_masked_invalid(x, copy=False)</code> </dt> 
</dl> <dl class="function"> <dt id="matplotlib.cbook.safezip">
<code>matplotlib.cbook.safezip(*args)</code> </dt> <dd>
<p>make sure <em>args</em> are equal len before zipping</p> </dd>
</dl> <dl class="class"> <dt id="matplotlib.cbook.silent_list">
<code>class matplotlib.cbook.silent_list(type, seq=None)</code> </dt> <dd>
<p>Bases: <code>list</code></p> <p>override repr when returning a list of matplotlib artists to prevent long, meaningless output. This is meant to be used for a homogeneous list of a given type</p> </dd>
</dl> <dl class="function"> <dt id="matplotlib.cbook.simple_linear_interpolation">
<code>matplotlib.cbook.simple_linear_interpolation(a, steps)</code> </dt> 
</dl> <dl class="function"> <dt id="matplotlib.cbook.soundex">
<code>matplotlib.cbook.soundex(name, len=4)</code> </dt> <dd>
<p>soundex module conforming to Odell-Russell algorithm</p> </dd>
</dl> <dl class="function"> <dt id="matplotlib.cbook.strip_math">
<code>matplotlib.cbook.strip_math(s)</code> </dt> <dd>
<p>remove latex formatting from mathtext</p> </dd>
</dl> <dl class="function"> <dt id="matplotlib.cbook.to_filehandle">
<code>matplotlib.cbook.to_filehandle(fname, flag='rU', return_opened=False)</code> </dt> <dd>
<p><em>fname</em> can be a filename or a file handle. Support for gzipped files is automatic, if the filename ends in .gz. <em>flag</em> is a read/write flag for <code>file()</code></p> </dd>
</dl> <dl class="class"> <dt id="matplotlib.cbook.todate">
<code>class matplotlib.cbook.todate(fmt='%Y-%m-%d', missing='Null', missingval=None)</code> </dt> <dd>
<p>Bases: <a class="reference internal" href="#matplotlib.cbook.converter" title="matplotlib.cbook.converter"><code>matplotlib.cbook.converter</code></a></p> <p>convert to a date or None</p> <p>use a <code>time.strptime()</code> format string for conversion</p> </dd>
</dl> <dl class="class"> <dt id="matplotlib.cbook.todatetime">
<code>class matplotlib.cbook.todatetime(fmt='%Y-%m-%d', missing='Null', missingval=None)</code> </dt> <dd>
<p>Bases: <a class="reference internal" href="#matplotlib.cbook.converter" title="matplotlib.cbook.converter"><code>matplotlib.cbook.converter</code></a></p> <p>convert to a datetime or None</p> <p>use a <code>time.strptime()</code> format string for conversion</p> </dd>
</dl> <dl class="class"> <dt id="matplotlib.cbook.tofloat">
<code>class matplotlib.cbook.tofloat(missing='Null', missingval=None)</code> </dt> <dd>
<p>Bases: <a class="reference internal" href="#matplotlib.cbook.converter" title="matplotlib.cbook.converter"><code>matplotlib.cbook.converter</code></a></p> <p>convert to a float or None</p> </dd>
</dl> <dl class="class"> <dt id="matplotlib.cbook.toint">
<code>class matplotlib.cbook.toint(missing='Null', missingval=None)</code> </dt> <dd>
<p>Bases: <a class="reference internal" href="#matplotlib.cbook.converter" title="matplotlib.cbook.converter"><code>matplotlib.cbook.converter</code></a></p> <p>convert to an int or None</p> </dd>
</dl> <dl class="class"> <dt id="matplotlib.cbook.tostr">
<code>class matplotlib.cbook.tostr(missing='Null', missingval='')</code> </dt> <dd>
<p>Bases: <a class="reference internal" href="#matplotlib.cbook.converter" title="matplotlib.cbook.converter"><code>matplotlib.cbook.converter</code></a></p> <p>convert to string or None</p> </dd>
</dl> <dl class="function"> <dt id="matplotlib.cbook.unicode_safe">
<code>matplotlib.cbook.unicode_safe(s)</code> </dt> 
</dl> <dl class="function"> <dt id="matplotlib.cbook.unique">
<code>matplotlib.cbook.unique(x)</code> </dt> <dd>
<p>Return a list of unique elements of <em>x</em></p> </dd>
</dl> <dl class="function"> <dt id="matplotlib.cbook.unmasked_index_ranges">
<code>matplotlib.cbook.unmasked_index_ranges(mask, compressed=True)</code> </dt> <dd>
<p>Find index ranges where <em>mask</em> is <em>False</em>.</p> <p><em>mask</em> will be flattened if it is not already 1-D.</p> <p>Returns Nx2 <code>numpy.ndarray</code> with each row the start and stop indices for slices of the compressed <code>numpy.ndarray</code> corresponding to each of <em>N</em> uninterrupted runs of unmasked values. If optional argument <em>compressed</em> is <em>False</em>, it returns the start and stop indices into the original <code>numpy.ndarray</code>, not the compressed <code>numpy.ndarray</code>. Returns <em>None</em> if there are no unmasked values.</p> <p>Example:</p> <pre data-language="python">y = ma.array(np.arange(5), mask = [0,0,1,0,0])
ii = unmasked_index_ranges(ma.getmaskarray(y))
# returns array [[0,2,] [2,4,]]

y.compressed()[ii[1,0]:ii[1,1]]
# returns array [3,4,]

ii = unmasked_index_ranges(ma.getmaskarray(y), compressed=False)
# returns array [[0, 2], [3, 5]]

y.filled()[ii[1,0]:ii[1,1]]
# returns array [3,4,]
</pre> <p>Prior to the transforms refactoring, this was used to support masked arrays in Line2D.</p> </dd>
</dl> <dl class="function"> <dt id="matplotlib.cbook.violin_stats">
<code>matplotlib.cbook.violin_stats(X, method, points=100)</code> </dt> <dd>
<p>Returns a list of dictionaries of data which can be used to draw a series of violin plots. See the <code>Returns</code> section below to view the required keys of the dictionary. Users can skip this function and pass a user-defined set of dictionaries to the <code>axes.vplot</code> method instead of using MPL to do the calculations.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr class="field-odd field">
<th class="field-name">Parameters:</th>
<td class="field-body">
<p class="first"><strong>X</strong> : array-like</p>  <p>Sample data that will be used to produce the gaussian kernel density estimates. Must have 2 or fewer dimensions.</p>  <p><strong>method</strong> : callable</p>  <p>The method used to calculate the kernel density estimate for each column of data. When called via <code>method(v, coords)</code>, it should return a vector of the values of the KDE evaluated at the values specified in coords.</p>  <p><strong>points</strong> : scalar, default = 100</p>  <p>Defines the number of points to evaluate each of the gaussian kernel density estimates at.</p>  </td> </tr> <tr class="field-even field">
<th class="field-name">Returns:</th>
<td class="field-body">
<p class="first">A list of dictionaries containing the results for each column of data.</p> <p>The dictionaries contain at least the following:</p>  <ul class="simple"> <li>coords: A list of scalars containing the coordinates this particular kernel density estimate was evaluated at.</li> <li>vals: A list of scalars containing the values of the kernel density estimate at each of the coordinates given in <code>coords</code>.</li> <li>mean: The mean value for this column of data.</li> <li>median: The median value for this column of data.</li> <li>min: The minimum value for this column of data.</li> <li>max: The maximum value for this column of data.</li> </ul>  </td> </tr>  </table> </dd>
</dl> <dl class="function"> <dt id="matplotlib.cbook.warn_deprecated">
<code>matplotlib.cbook.warn_deprecated(since, message='', name='', alternative='', pending=False, obj_type='attribute')</code> </dt> <dd>
<p>Used to display deprecation warning in a standard way.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr class="field-odd field">
<th class="field-name">Parameters:</th>
<td class="field-body">
<p class="first"><strong>since</strong> : str</p>  <p>The release at which this API became deprecated.</p>  <p><strong>message</strong> : str, optional</p>  <p>Override the default deprecation message. The format specifier <code>%(func)s</code> may be used for the name of the function, and <code>%(alternative)s</code> may be used in the deprecation message to insert the name of an alternative to the deprecated function. <code>%(obj_type)</code> may be used to insert a friendly name for the type of object being deprecated.</p>  <p><strong>name</strong> : str, optional</p>  <p>The name of the deprecated function; if not provided the name is automatically determined from the passed in function, though this is useful in the case of renamed functions, where the new function is just assigned to the name of the deprecated function. For example:</p> <pre data-language="python">def new_function():
    ...
oldFunction = new_function
</pre>  <p><strong>alternative</strong> : str, optional</p>  <p>An alternative function that the user may use in place of the deprecated function. The deprecation warning will tell the user about this alternative if provided.</p>  <p><strong>pending</strong> : bool, optional</p>  <p>If True, uses a PendingDeprecationWarning instead of a DeprecationWarning.</p>  <p><strong>obj_type</strong> : str, optional</p>  <p>The object type being deprecated.</p>  </td> </tr>  </table> <h4 class="rubric">Examples</h4> <p>Basic example:</p> <pre data-language="python"># To warn of the deprecation of "matplotlib.name_of_module"
warn_deprecated('1.4.0', name='matplotlib.name_of_module',
                obj_type='module')
</pre> </dd>
</dl> <dl class="function"> <dt id="matplotlib.cbook.wrap">
<code>matplotlib.cbook.wrap(prefix, text, cols)</code> </dt> <dd>
<p>wrap <em>text</em> with <em>prefix</em> at length <em>cols</em></p> </dd>
</dl>
<div class="_attribution">
  <p class="_attribution-p">
    © 2012–2016 Matplotlib Development Team. All rights reserved.<br>Licensed under the Matplotlib License Agreement.<br>
    <a href="http://matplotlib.org/1.5.3/api/cbook_api.html" class="_attribution-link" target="_blank">http://matplotlib.org/1.5.3/api/cbook_api.html</a>
  </p>
</div>

			</div>
		</div>
	</section>

	</div>
</body>
</html>
