
<!DOCTYPE HTML>

<html lang="en">

<head>
  <meta charset="utf-8">
  <title>6.8. Filenames and Separate Compilation - Haskell 8 - W3cubDocs</title>
  
  <meta name="description" content=" This section describes what files GHC expects to find, what files it creates, where these files are stored, and what options affect this behaviour. ">
  <meta name="keywords" content="filenames, and, separate, compilation, -, haskell, haskell~8">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="http://docs.w3cub.com/haskell~8/users_guide/separate_compilation/">
  <link href="/favicon.png" rel="icon">
  <link type="text/css" rel="stylesheet" href="/assets/application-50364fff564ce3b6327021805f3f00e2957b441cf27f576a7dd4ff63bbc47047.css">
  <script type="text/javascript" src="/assets/application-db64bfd54ceb42be11af7995804cf4902548419ceb79d509b0b7d62c22d98e6f.js"></script>
  <script src="/json/haskell~8.js"></script>
  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-71174418-1']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>


</head>

<body>
	<div class="_app">
	<header class="_header">
  
  <form class="_search">
    <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
    <a class="_search-clear"></a>
    <div class="_search-tag"></div>
  </form>
  
  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/haskell~8/" class="_nav-link" title="" style="margin-left:0;">Haskell 8</a></span>
  
  <nav class="_nav">
    <a href="/app/" class="_nav-link ">App</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		<div class="_list">
			
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<div class="_page _haskell">
				
<h1 id="separate-compilation">6.8. Filenames and separate compilation</h1>
<div class="_sphinx">   <p id="filenames-and-separate-compilation">This section describes what files GHC expects to find, what files it creates, where these files are stored, and what options affect this behaviour.</p> <p>Pathname conventions vary from system to system. In particular, the directory separator is “<code>/</code>” on Unix systems and “<code>\</code>” on Windows systems. In the sections that follow, we shall consistently use “<code>/</code>” as the directory separator; substitute this for the appropriate character for your system.</p>  <h2 id="source-files">6.8.1. Haskell source files</h2> <p id="haskell-source-files">Each Haskell source module should be placed in a file on its own.</p> <p>Usually, the file should be named after the module name, replacing dots in the module name by directory separators. For example, on a Unix system, the module <code>A.B.C</code> should be placed in the file <code>A/B/C.hs</code>, relative to some base directory. If the module is not going to be imported by another module (<code>Main</code>, for example), then you are free to use any filename for it.</p> <p id="index-2">GHC assumes that source files are ASCII or UTF-8 only, other encoding are not recognised. However, invalid UTF-8 sequences will be ignored in comments, so it is possible to use other encodings such as Latin-1, as long as the non-comment source code is ASCII only.</p>   <h2 id="id1">6.8.2. Output files</h2> <p id="output-files">When asked to compile a source file, GHC normally generates two files: an object file, and an interface file.</p> <p>The object file, which normally ends in a <code>.o</code> suffix, contains the compiled code for the module.</p> <p>The interface file, which normally ends in a <code>.hi</code> suffix, contains the information that GHC needs in order to compile further modules that depend on this module. It contains things like the types of exported functions, definitions of data types, and so on. It is stored in a binary format, so don’t try to read one; use the <a class="reference internal" href="../using/#ghc-flag---show-iface"><code>--show-iface</code></a> option instead (see <a class="reference internal" href="#hi-options">Other options related to interface files</a>).</p> <p>You should think of the object file and the interface file as a pair, since the interface file is in a sense a compiler-readable description of the contents of the object file. If the interface file and object file get out of sync for any reason, then the compiler may end up making assumptions about the object file that aren’t true; trouble will almost certainly follow. For this reason, we recommend keeping object files and interface files in the same place (GHC does this by default, but it is possible to override the defaults as we’ll explain shortly).</p> <p>Every module has a <em>module name</em> defined in its source code (<code>module A.B.C where ...</code>).</p> <p>The name of the object file generated by GHC is derived according to the following rules, where ⟨osuf⟩ is the object-file suffix (this can be changed with the <code>-osuf</code> option).</p> <ul class="simple"> <li>If there is no <code>-odir</code> option (the default), then the object filename is derived from the source filename (ignoring the module name) by replacing the suffix with ⟨osuf⟩.</li> <li>If <code>-odir ⟨dir⟩</code> has been specified, then the object filename is ⟨dir⟩/⟨mod⟩.⟨osuf⟩, where ⟨mod⟩ is the module name with dots replaced by slashes. GHC will silently create the necessary directory structure underneath ⟨dir⟩, if it does not already exist.</li> </ul> <p>The name of the interface file is derived using the same rules, except that the suffix is ⟨hisuf⟩ (<code>.hi</code> by default) instead of ⟨osuf⟩, and the relevant options are <a class="reference internal" href="#ghc-flag--hidir"><code>-hidir</code></a> and <a class="reference internal" href="#ghc-flag--hisuf"><code>-hisuf</code></a> instead of <a class="reference internal" href="#ghc-flag--odir"><code>-odir</code></a> and <a class="reference internal" href="#ghc-flag--osuf"><code>-osuf</code></a> respectively.</p> <p>For example, if GHC compiles the module <code>A.B.C</code> in the file <code>src/A/B/C.hs</code>, with no <code>-odir</code> or <code>-hidir</code> flags, the interface file will be put in <code>src/A/B/C.hi</code> and the object file in <code>src/A/B/C.o</code>.</p> <p>For any module that is imported, GHC requires that the name of the module in the import statement exactly matches the name of the module in the interface file (or source file) found using the strategy specified in <a class="reference internal" href="#search-path">The search path</a>. This means that for most modules, the source file name should match the module name.</p> <p>However, note that it is reasonable to have a module <code>Main</code> in a file named <code>foo.hs</code>, but this only works because GHC never needs to search for the interface for module <code>Main</code> (because it is never imported). It is therefore possible to have several <code>Main</code> modules in separate source files in the same directory, and GHC will not get confused.</p> <p>In batch compilation mode, the name of the object file can also be overridden using the <a class="reference internal" href="#ghc-flag--o"><code>-o</code></a> option, and the name of the interface file can be specified directly using the <a class="reference internal" href="#ghc-flag--ohi"><code>-ohi</code></a> option.</p>   <h2 id="search-path">6.8.3. The search path</h2> <p id="the-search-path">In your program, you import a module <code>Foo</code> by saying <code>import Foo</code>. In <a class="reference internal" href="../using/#ghc-flag---make"><code>--make</code></a> mode or GHCi, GHC will look for a source file for <code>Foo</code> and arrange to compile it first. Without <a class="reference internal" href="../using/#ghc-flag---make"><code>--make</code></a>, GHC will look for the interface file for <code>Foo</code>, which should have been created by an earlier compilation of <code>Foo</code>. GHC uses the same strategy in each of these cases for finding the appropriate file.</p> <p>This strategy is as follows: GHC keeps a list of directories called the search path. For each of these directories, it tries appending <code>⟨basename⟩.⟨extension⟩</code> to the directory, and checks whether the file exists. The value of ⟨basename⟩ is the module name with dots replaced by the directory separator (“<code>/</code>” or “<code>\\"</code>, depending on the system), and ⟨extension⟩ is a source extension (<code>hs</code>, <code>lhs</code>) if we are in <a class="reference internal" href="../using/#ghc-flag---make"><code>--make</code></a> mode or GHCi, or ⟨hisuf⟩ otherwise.</p> <p>For example, suppose the search path contains directories <code>d1</code>, <code>d2</code>, and <code>d3</code>, and we are in <a class="reference internal" href="../using/#ghc-flag---make"><code>--make</code></a> mode looking for the source file for a module <code>A.B.C</code>. GHC will look in <code>d1/A/B/C.hs</code>, <code>d1/A/B/C.lhs</code>, <code>d2/A/B/C.hs</code>, and so on.</p> <p>The search path by default contains a single directory: “<code>.</code>” (i.e. the current directory). The following options can be used to add to or change the contents of the search path:</p> <dl class="ghc-flag"> <dt id="ghc-flag--i⟨dir⟩[:⟨dir⟩]*">
<code>-i⟨dir⟩[:⟨dir⟩]*</code> </dt> <dd>
<p id="index-5">This flag appends a colon-separated list of <code>dirs</code> to the search path.</p> </dd>
</dl> <dl class="ghc-flag"> <dt id="ghc-flag--i">
<code>-i</code> </dt> <dt id="ghc-flag-resets">
<code>resetsthe search path back to nothing.</code> </dt> 
</dl> <p>This isn’t the whole story: GHC also looks for modules in pre-compiled libraries, known as packages. See the section on packages (<a class="reference internal" href="../packages/#packages">Packages</a>) for details.</p>   <h2 id="options-output">6.8.4. Redirecting the compilation output(s)</h2> <dl class="ghc-flag" id="redirecting-the-compilation-output-s"> <dt id="ghc-flag--o">
<code>-o⟨file⟩</code> </dt> <dd>
<p>GHC’s compiled output normally goes into a <code>.hc</code>, <code>.o</code>, etc., file, depending on the last-run compilation phase. The option <code>-o file</code> re-directs the output of that last-run phase to ⟨file⟩.</p> <div class="admonition note"> <p class="first admonition-title">Note</p> <p class="last">This “feature” can be counterintuitive: <code>ghc -C -o foo.o foo.hs</code> will put the intermediate C code in the file <code>foo.o</code>, name notwithstanding!</p> </div> <p>This option is most often used when creating an executable file, to set the filename of the executable. For example:</p> <pre data-language="none">ghc -o prog --make Main
</pre> <p>will compile the program starting with module <code>Main</code> and put the executable in the file <code>prog</code>.</p> <p>Note: on Windows, if the result is an executable file, the extension “<code>.exe</code>” is added if the specified filename does not already have an extension. Thus</p> <pre data-language="none">ghc -o foo Main.hs
</pre> <p>will compile and link the module <code>Main.hs</code>, and put the resulting executable in <code>foo.exe</code> (not <code>foo</code>).</p> <p>If you use <code>ghc --make</code> and you don’t use the <code>-o</code>, the name GHC will choose for the executable will be based on the name of the file containing the module <code>Main</code>. Note that with GHC the <code>Main</code> module doesn’t have to be put in file <code>Main.hs</code>. Thus both</p> <pre data-language="none">ghc --make Prog
</pre> <p>and</p> <pre data-language="none">ghc --make Prog.hs
</pre> <p>will produce <code>Prog</code> (or <code>Prog.exe</code> if you are on Windows).</p> </dd>
</dl> <dl class="ghc-flag"> <dt id="ghc-flag--odir">
<code>-odir⟨dir⟩</code> </dt> <dd>
<p>Redirects object files to directory ⟨dir⟩. For example:</p> <pre data-language="none">$ ghc -c parse/Foo.hs parse/Bar.hs gurgle/Bumble.hs -odir `uname -m`
</pre> <p>The object files, <code>Foo.o</code>, <code>Bar.o</code>, and <code>Bumble.o</code> would be put into a subdirectory named after the architecture of the executing machine (<code>x86</code>, <code>mips</code>, etc).</p> <p>Note that the <code>-odir</code> option does <em>not</em> affect where the interface files are put; use the <code>-hidir</code> option for that. In the above example, they would still be put in <code>parse/Foo.hi</code>, <code>parse/Bar.hi</code>, and <code>gurgle/Bumble.hi</code>.</p> </dd>
</dl> <dl class="ghc-flag"> <dt id="ghc-flag--ohi">
<code>-ohi⟨file⟩</code> </dt> <dd>
<p>The interface output may be directed to another file <code>bar2/Wurble.iface</code> with the option <code>-ohi bar2/Wurble.iface</code> (not recommended).</p> <div class="admonition warning"> <p class="first admonition-title">Warning</p> <p class="last">If you redirect the interface file somewhere that GHC can’t find it, then the recompilation checker may get confused (at the least, you won’t get any recompilation avoidance). We recommend using a combination of <code>-hidir</code> and <code>-hisuf</code> options instead, if possible.</p> </div> <p>To avoid generating an interface at all, you could use this option to redirect the interface into the bit bucket: <code>-ohi /dev/null</code>, for example.</p> </dd>
</dl> <dl class="ghc-flag"> <dt id="ghc-flag--hidir">
<code>-hidir⟨dir⟩</code> </dt> <dd>
<p>Redirects all generated interface files into ⟨dir⟩, instead of the default.</p> </dd>
</dl> <dl class="ghc-flag"> <dt id="ghc-flag--stubdir">
<code>-stubdir⟨dir⟩</code> </dt> <dd>
<p>Redirects all generated FFI stub files into ⟨dir⟩. Stub files are generated when the Haskell source contains a <code>foreign export</code> or <code>foreign import "&amp;wrapper"</code> declaration (see <a class="reference internal" href="../ffi-chap/#foreign-export-ghc">Using foreign export and foreign import ccall “wrapper” with GHC</a>). The <code>-stubdir</code> option behaves in exactly the same way as <code>-odir</code> and <code>-hidir</code> with respect to hierarchical modules.</p> </dd>
</dl> <dl class="ghc-flag"> <dt id="ghc-flag--dumpdir">
<code>-dumpdir⟨dir⟩</code> </dt> <dd>
<p>Redirects all dump files into ⟨dir⟩. Dump files are generated when <code>-ddump-to-file</code> is used with other <code>-ddump-*</code> flags.</p> </dd>
</dl> <dl class="ghc-flag"> <dt id="ghc-flag--outputdir">
<code>-outputdir⟨dir⟩</code> </dt> <dd>
<p>The <code>-outputdir</code> option is shorthand for the combination of <a class="reference internal" href="#ghc-flag--odir"><code>-odir</code></a>, <a class="reference internal" href="#ghc-flag--hidir"><code>-hidir</code></a>, <a class="reference internal" href="#ghc-flag--stubdir"><code>-stubdir</code></a> and <a class="reference internal" href="#ghc-flag--dumpdir"><code>-dumpdir</code></a>.</p> </dd>
</dl> <dl class="ghc-flag"> <dt id="ghc-flag--osuf">
<code>-osuf⟨suffix⟩</code> </dt> <dt id="ghc-flag--hisuf">
<code>-hisuf⟨suffix⟩</code> </dt> <dt id="ghc-flag--hcsuf">
<code>-hcsuf⟨suffix⟩</code> </dt> <dd>
<p>The <code>-osuf</code> ⟨suffix⟩ will change the <code>.o</code> file suffix for object files to whatever you specify. We use this when compiling libraries, so that objects for the profiling versions of the libraries don’t clobber the normal ones.</p> <p>Similarly, the <code>-hisuf</code> ⟨suffix⟩ will change the <code>.hi</code> file suffix for non-system interface files (see <a class="reference internal" href="#hi-options">Other options related to interface files</a>).</p> <p>Finally, the option <code>-hcsuf</code> ⟨suffix⟩ will change the <code>.hc</code> file suffix for compiler-generated intermediate C files.</p> <p>The <code>-hisuf</code>/<code>-osuf</code> game is particularly useful if you want to compile a program both with and without profiling, in the same directory. You can say:</p> <pre data-language="none">ghc ...
</pre> <p>to get the ordinary version, and</p> <pre data-language="none">ghc ... -osuf prof.o -hisuf prof.hi -prof -auto-all
</pre> <p>to get the profiled version.</p> </dd>
</dl>   <h2 id="keeping-intermediates">6.8.5. Keeping Intermediate Files</h2> <p id="keeping-intermediate-files">The following options are useful for keeping certain intermediate files around, when normally GHC would throw these away after compilation:</p> <dl class="ghc-flag"> <dt id="ghc-flag--keep-hc-file">
<code>-keep-hc-file</code> </dt> <dt id="ghc-flag--keep-hc-files">
<code>-keep-hc-files</code> </dt> <dd>
<p>Keep intermediate <code>.hc</code> files when doing <code>.hs</code>-to-<code>.o</code> compilations via <a class="reference internal" href="../codegens/#c-code-gen">C</a> (Note: <code>.hc</code> files are only generated by <a class="reference internal" href="../codegens/#unreg">unregisterised</a> compilers).</p> </dd>
</dl> <dl class="ghc-flag"> <dt id="ghc-flag--keep-llvm-file">
<code>-keep-llvm-file</code> </dt> <dt id="ghc-flag--keep-llvm-files">
<code>-keep-llvm-files</code> </dt> <dd>
<table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr class="field-odd field">
<th class="field-name">Implies:</th>
<td class="field-body"><a class="reference internal" href="../phases/#ghc-flag--fllvm"><code>-fllvm</code></a></td> </tr>  </table> <p>Keep intermediate <code>.ll</code> files when doing <code>.hs</code>-to-<code>.o</code> compilations via <a class="reference internal" href="../codegens/#llvm-code-gen">LLVM</a> (Note: <code>.ll</code> files aren’t generated when using the native code generator, you may need to use <a class="reference internal" href="../phases/#ghc-flag--fllvm"><code>-fllvm</code></a> to force them to be produced).</p> </dd>
</dl> <dl class="ghc-flag"> <dt id="ghc-flag--keep-s-file">
<code>-keep-s-file</code> </dt> <dt id="ghc-flag--keep-s-files">
<code>-keep-s-files</code> </dt> <dd>
<p>Keep intermediate <code>.s</code> files.</p> </dd>
</dl> <dl class="ghc-flag"> <dt id="ghc-flag--keep-tmp-files">
<code>-keep-tmp-files</code> </dt> <dd>
<p id="index-8">Instructs the GHC driver not to delete any of its temporary files, which it normally keeps in <code>/tmp</code> (or possibly elsewhere; see <a class="reference internal" href="#temp-files">Redirecting temporary files</a>). Running GHC with <code>-v</code> will show you what temporary files were generated along the way.</p> </dd>
</dl>   <h2 id="temp-files">6.8.6. Redirecting temporary files</h2> <dl class="ghc-flag" id="redirecting-temporary-files"> <dt id="ghc-flag--tmpdir">
<code>-tmpdir</code> </dt> <dd>
<p>If you have trouble because of running out of space in <code>/tmp</code> (or wherever your installation thinks temporary files should go), you may use the <code>-tmpdir &lt;dir&gt;</code>-tmpdir &lt;dir&gt; option option to specify an alternate directory. For example, <code>-tmpdir .</code> says to put temporary files in the current working directory.</p> <p id="index-10">Alternatively, use your <code id="index-11">TMPDIR</code> environment variable. Set it to the name of the directory where temporary files should be put. GCC and other programs will honour the <code id="index-12">TMPDIR</code> variable as well.</p> <p>Even better idea: Set the <code id="index-13">DEFAULT_TMPDIR</code> <strong class="command">make</strong> variable when building GHC, and never worry about <code id="index-14">TMPDIR</code> again. (see the build documentation).</p> </dd>
</dl>   <h2 id="hi-options">6.8.7. Other options related to interface files</h2> <dl class="ghc-flag" id="other-options-related-to-interface-files"> <dt id="ghc-flag--ddump-hi">
<code>-ddump-hi</code> </dt> <dd>
<p>Dumps the new interface to standard output.</p> </dd>
</dl> <dl class="ghc-flag"> <dt id="ghc-flag--ddump-hi-diffs">
<code>-ddump-hi-diffs</code> </dt> <dd>
<p>The compiler does not overwrite an existing <code>.hi</code> interface file if the new one is the same as the old one; this is friendly to <strong class="command">make</strong>. When an interface does change, it is often enlightening to be informed. The <a class="reference internal" href="#ghc-flag--ddump-hi-diffs"><code>-ddump-hi-diffs</code></a> option will make GHC report the differences between the old and new <code>.hi</code> files.</p> </dd>
</dl> <dl class="ghc-flag"> <dt id="ghc-flag--ddump-minimal-imports">
<code>-ddump-minimal-imports</code> </dt> <dd>
<p>Dump to the file <code><em>M</em>.imports</code> (where ⟨M⟩ is the name of the module being compiled) a “minimal” set of import declarations. The directory where the <code>.imports</code> files are created can be controlled via the <a class="reference internal" href="#ghc-flag--dumpdir"><code>-dumpdir</code></a> option.</p> <p>You can safely replace all the import declarations in <code><em>M</em>.hs</code> with those found in its respective <code>.imports</code> file. Why would you want to do that? Because the “minimal” imports (a) import everything explicitly, by name, and (b) import nothing that is not required. It can be quite painful to maintain this property by hand, so this flag is intended to reduce the labour.</p> </dd>
</dl> <dl class="ghc-flag"> <dt id="ghc-flag---show-iface">
<code>--show-iface⟨file⟩</code> </dt> <dd>
<p>where ⟨file⟩ is the name of an interface file, dumps the contents of that interface in a human-readable format. See <a class="reference internal" href="../using/#modes">Modes of operation</a>.</p> </dd>
</dl>   <h2 id="recomp">6.8.8. The recompilation checker</h2> <dl class="ghc-flag" id="the-recompilation-checker"> <dt id="ghc-flag--fforce-recomp">
<code>-fforce-recomp</code> </dt> <dd>
<p>Turn off recompilation checking (which is on by default). Recompilation checking normally stops compilation early, leaving an existing <code>.o</code> file in place, if it can be determined that the module does not need to be recompiled.</p> </dd>
</dl> <p>In the olden days, GHC compared the newly-generated <code>.hi</code> file with the previous version; if they were identical, it left the old one alone and didn’t change its modification date. In consequence, importers of a module with an unchanged output <code>.hi</code> file were not recompiled.</p> <p>This doesn’t work any more. Suppose module <code>C</code> imports module <code>B</code>, and <code>B</code> imports module <code>A</code>. So changes to module <code>A</code> might require module <code>C</code> to be recompiled, and hence when <code>A.hi</code> changes we should check whether <code>C</code> should be recompiled. However, the dependencies of <code>C</code> will only list <code>B.hi</code>, not <code>A.hi</code>, and some changes to <code>A</code> (changing the definition of a function that appears in an inlining of a function exported by <code>B</code>, say) may conceivably not change <code>B.hi</code> one jot. So now…</p> <p>GHC calculates a fingerprint (in fact an MD5 hash) of each interface file, and of each declaration within the interface file. It also keeps in every interface file a list of the fingerprints of everything it used when it last compiled the file. If the source file’s modification date is earlier than the <code>.o</code> file’s date (i.e. the source hasn’t changed since the file was last compiled), and the recompilation checking is on, GHC will be clever. It compares the fingerprints on the things it needs this time with the fingerprints on the things it needed last time (gleaned from the interface file of the module being compiled); if they are all the same it stops compiling early in the process saying “Compilation IS NOT required”. What a beautiful sight!</p> <p>You can read about <a class="reference external" href="http://ghc.haskell.org/trac/ghc/wiki/Commentary/Compiler/RecompilationAvoidance" target="_blank">how all this works</a> in the GHC commentary.</p>   <h2 id="mutual-recursion">6.8.9. How to compile mutually recursive modules</h2> <p id="how-to-compile-mutually-recursive-modules">GHC supports the compilation of mutually recursive modules. This section explains how.</p> <p>Every cycle in the module import graph must be broken by a <code>hs-boot</code> file. Suppose that modules <code>A.hs</code> and <code>B.hs</code> are Haskell source files, thus:</p> <pre data-language="haskell">module A where
    import B( TB(..) )

    newtype TA = MkTA Int

    f :: TB -&gt; TA
    f (MkTB x) = MkTA x

module B where
    import {-# SOURCE #-} A( TA(..) )

    data TB = MkTB !Int

    g :: TA -&gt; TB
    g (MkTA x) = MkTB x
</pre> <p><code>hs-boot</code> files importing, <code>hi-boot</code> files Here <code>A</code> imports <code>B</code>, but <code>B</code> imports <code>A</code> with a <code>{-# SOURCE #-}</code> pragma, which breaks the circular dependency. Every loop in the module import graph must be broken by a <code>{-# SOURCE #-}</code> import; or, equivalently, the module import graph must be acyclic if <code>{-# SOURCE #-}</code> imports are ignored.</p> <p>For every module <code>A.hs</code> that is <code>{-# SOURCE #-}</code>-imported in this way there must exist a source file <code>A.hs-boot</code>. This file contains an abbreviated version of <code>A.hs</code>, thus:</p> <pre data-language="haskell">module A where
    newtype TA = MkTA Int
</pre> <p>To compile these three files, issue the following commands:</p> <pre data-language="none">ghc -c A.hs-boot    -- Produces A.hi-boot, A.o-boot
ghc -c B.hs         -- Consumes A.hi-boot, produces B.hi, B.o
ghc -c A.hs         -- Consumes B.hi, produces A.hi, A.o
ghc -o foo A.o B.o  -- Linking the program
</pre> <p>There are several points to note here:</p> <ul> <li>The file <code>A.hs-boot</code> is a programmer-written source file. It must live in the same directory as its parent source file <code>A.hs</code>. Currently, if you use a literate source file <code>A.lhs</code> you must also use a literate boot file, <code>A.lhs-boot</code>; and vice versa. </li> <li>
<p class="first">A <code>hs-boot</code> file is compiled by GHC, just like a <code>hs</code> file:</p> <pre data-language="none">ghc -c A.hs-boot
</pre> <p>When a hs-boot file <code>A.hs-boot</code> is compiled, it is checked for scope and type errors. When its parent module <code>A.hs</code> is compiled, the two are compared, and an error is reported if the two are inconsistent.</p> </li> <li>
<p class="first">Just as compiling <code>A.hs</code> produces an interface file <code>A.hi</code>, and an object file <code>A.o</code>, so compiling <code>A.hs-boot</code> produces an interface file <code>A.hi-boot</code>, and an pseudo-object file <code>A.o-boot</code>:</p> <ul class="simple"> <li>The pseudo-object file <code>A.o-boot</code> is empty (don’t link it!), but it is very useful when using a Makefile, to record when the <code>A.hi-boot</code> was last brought up to date (see <a class="reference internal" href="#using-make">Using make</a>).</li> <li>The <code>hi-boot</code> generated by compiling a <code>hs-boot</code> file is in the same machine-generated binary format as any other GHC-generated interface file (e.g. <code>B.hi</code>). You can display its contents with <code>ghc --show-iface</code>. If you specify a directory for interface files, the <code>-ohidir</code> flag, then that affects <code>hi-boot</code> files too.</li> </ul> </li> <li>If hs-boot files are considered distinct from their parent source files, and if a <code>{-# SOURCE #-}</code> import is considered to refer to the hs-boot file, then the module import graph must have no cycles. The command <code>ghc -M</code> will report an error if a cycle is found. </li> <li>A module <code>M</code> that is <code>{-# SOURCE #-}</code>-imported in a program will usually also be ordinarily imported elsewhere. If not, <code>ghc --make</code> automatically adds <code>M</code> to the set of modules it tries to compile and link, to ensure that <code>M</code>‘s implementation is included in the final program. </li> </ul> <p>A hs-boot file need only contain the bare minimum of information needed to get the bootstrapping process started. For example, it doesn’t need to contain declarations for <em>everything</em> that module <code>A</code> exports, only the things required by the module(s) that import <code>A</code> recursively.</p> <p>A hs-boot file is written in a subset of Haskell:</p> <ul> <li>The module header (including the export list), and import statements, are exactly as in Haskell, and so are the scoping rules. Hence, to mention a non-Prelude type or class, you must import it. </li> <li>
<p class="first">There must be no value declarations, but there can be type signatures for values. For example:</p> <pre data-language="haskell">double :: Int -&gt; Int
</pre> </li> <li>Fixity declarations are exactly as in Haskell. </li> <li>Vanilla type synonym declarations are exactly as in Haskell. </li> <li>Open type and data family declarations are exactly as in Haskell. </li> <li>
<p class="first">A closed type family may optionally omit its equations, as in the following example:</p> <pre data-language="haskell">type family ClosedFam a where ..
</pre> <p>The <code>..</code> is meant literally – you should write two dots in your file. Note that the <code>where</code> clause is still necessary to distinguish closed families from open ones. If you give any equations of a closed family, you must give all of them, in the same order as they appear in the accompanying Haskell file.</p> </li> <li>
<p class="first">A data type declaration can either be given in full, exactly as in Haskell, or it can be given abstractly, by omitting the ‘=’ sign and everything that follows. For example:</p> <pre data-language="haskell">data T a b
</pre> <p>In a <em>source</em> program this would declare TA to have no constructors (a GHC extension: see <a class="reference internal" href="../glasgow_exts/#nullary-types">Data types with no constructors</a>), but in an hi-boot file it means “I don’t know or care what the constructors are”. This is the most common form of data type declaration, because it’s easy to get right. You <em>can</em> also write out the constructors but, if you do so, you must write it out precisely as in its real definition.</p> <p>If you do not write out the constructors, you may need to give a kind annotation (<a class="reference internal" href="../glasgow_exts/#kinding">Explicitly-kinded quantification</a>), to tell GHC the kind of the type variable, if it is not “*”. (In source files, this is worked out from the way the type variable is used in the constructors.) For example:</p> <pre data-language="haskell">data R (x :: * -&gt; *) y
</pre> <p>You cannot use <code>deriving</code> on a data type declaration; write an <code>instance</code> declaration instead.</p> </li> <li>Class declarations is exactly as in Haskell, except that you may not put default method declarations. You can also omit all the superclasses and class methods entirely; but you must either omit them all or put them all in. </li> <li>You can include instance declarations just as in Haskell; but omit the “where” part. </li> <li>The default role for abstract datatype parameters is now representational. (An abstract datatype is one with no constructors listed.) To get another role, use a role annotation. (See <a class="reference internal" href="../glasgow_exts/#roles">Roles</a>.) </li> </ul>   <h2 id="id2">6.8.10. Module signatures</h2> <p id="module-signatures">GHC supports the specification of module signatures, which both implementations and users can typecheck against separately. This functionality should be considered experimental for now; some details, especially for type classes and type families, may change. This system was originally described in <a class="reference external" href="http://plv.mpi-sws.org/backpack/" target="_blank">Backpack: Retrofitting Haskell with Interfaces</a>. Signature files are somewhat similar to <code>hs-boot</code> files, but have the <code>hsig</code> extension and behave slightly differently.</p> <p>Suppose that I have modules <code>String.hs</code> and <code>A.hs</code>, thus:</p> <pre data-language="haskell">module Text where
    data Text = Text String

    empty :: Text
    empty = Text ""

    toString :: Text -&gt; String
    toString (Text s) = s

module A where
    import Text
    z = toString empty
</pre> <p>Presently, module <code>A</code> depends explicitly on a concrete implementation of <code>Text</code>. What if we wanted to a signature <code>Text</code>, so we could vary the implementation with other possibilities (e.g. packed UTF-8 encoded bytestrings)? To do this, we can write a signature <code>TextSig.hsig</code>, and modify <code>A</code> to include the signature instead:</p> <pre data-language="haskell">module TextSig where
    data Text
    empty :: Text
    toString :: Text -&gt; String

module A where
    import TextSig
    z = toString empty
</pre> <p>To compile these two files, we need to specify what module we would like to use to implement the signature. This can be done by compiling the implementation, and then using the <a class="reference internal" href="#ghc-flag--sig-of"><code>-sig-of</code></a> flag to specify the implementation backing a signature:</p> <pre data-language="none">ghc -c Text.hs
ghc -c TextSig.hsig -sig-of "TextSig is main:Text"
ghc -c A.hs
</pre> <p>To specify multiple signatures, use a comma-separated list. The <code>-sig-of</code> parameter is required to specify the backing implementations of all home modules, even in one-shot compilation mode. At the moment, you must specify the full module name (unit ID, colon, and then module name), although in the future we may support more user-friendly syntax.</p> <dl class="ghc-flag"> <dt id="ghc-flag--sig-of">
<code>-sig-of"⟨sig⟩ is ⟨package⟩:⟨module⟩"</code> </dt> <dd>
<p>Specify the module to be used at the implementation for the given signature.</p> </dd>
</dl> <p>To just type-check an interface file, no <code>-sig-of</code> is necessary; instead, just pass the options <code>-fno-code -fwrite-interface</code>. <code>hsig</code> files will generate normal interface files which other files can also use to type-check against. However, at the moment, we always assume that an entity defined in a signature is a unique identifier (even though we may happen to know it is type equal with another identifier). In the future, we will support passing shaping information to the compiler in order to let it know about these type equalities.</p> <p>Just like <code>hs-boot</code> files, when an <code>hsig</code> file is compiled it is checked for type consistency against the backing implementation. Signature files are also written in a subset of Haskell essentially identical to that of <code>hs-boot</code> files.</p> <p>There is one important gotcha with the current implementation: currently, instances from backing implementations will “leak” code that uses signatures, and explicit instance declarations in signatures are forbidden. This behavior will be subject to change.</p>   <h2 id="id3">6.8.11. Using <code>make</code>
</h2> <p id="using-make">It is reasonably straightforward to set up a <code>Makefile</code> to use with GHC, assuming you name your source files the same as your modules. Thus:</p> <pre data-language="makefile">HC      = ghc
HC_OPTS = -cpp $(EXTRA_HC_OPTS)

SRCS = Main.lhs Foo.lhs Bar.lhs
OBJS = Main.o   Foo.o   Bar.o

.SUFFIXES : .o .hs .hi .lhs .hc .s

cool_pgm : $(OBJS)
        rm -f $@
        $(HC) -o $@ $(HC_OPTS) $(OBJS)

# Standard suffix rules
.o.hi:
        @:

.lhs.o:
        $(HC) -c $&lt; $(HC_OPTS)

.hs.o:
        $(HC) -c $&lt; $(HC_OPTS)

.o-boot.hi-boot:
        @:

.lhs-boot.o-boot:
        $(HC) -c $&lt; $(HC_OPTS)

.hs-boot.o-boot:
        $(HC) -c $&lt; $(HC_OPTS)

# Inter-module dependencies
Foo.o Foo.hc Foo.s    : Baz.hi          # Foo imports Baz
Main.o Main.hc Main.s : Foo.hi Baz.hi   # Main imports Foo and Baz
</pre> <div class="admonition note"> <p class="first admonition-title">Note</p> <p>Sophisticated <strong class="command">make</strong> variants may achieve some of the above more elegantly. Notably, <strong class="command">gmake</strong>‘s pattern rules let you write the more comprehensible:</p> <pre data-language="make">%.o : %.lhs
        $(HC) -c $&lt; $(HC_OPTS)
</pre> <p class="last">What we’ve shown should work with any <code>make</code>.</p> </div> <p>Note the cheesy <code>.o.hi</code> rule: It records the dependency of the interface (<code>.hi</code>) file on the source. The rule says a <code>.hi</code> file can be made from a <code>.o</code> file by doing…nothing. Which is true.</p> <p>Note that the suffix rules are all repeated twice, once for normal Haskell source files, and once for <code>hs-boot</code> files (see <a class="reference internal" href="#mutual-recursion">How to compile mutually recursive modules</a>).</p> <p>Note also the inter-module dependencies at the end of the Makefile, which take the form</p> <pre data-language="make">Foo.o Foo.hc Foo.s    : Baz.hi          # Foo imports Baz
</pre> <p>They tell <code>make</code> that if any of <code>Foo.o</code>, <code>Foo.hc</code> or <code>Foo.s</code> have an earlier modification date than <code>Baz.hi</code>, then the out-of-date file must be brought up to date. To bring it up to date, <code>make</code> looks for a rule to do so; one of the preceding suffix rules does the job nicely. These dependencies can be generated automatically by <code>ghc</code>; see <a class="reference internal" href="#makefile-dependencies">Dependency generation</a></p>   <h2 id="makefile-dependencies">6.8.12. Dependency generation</h2> <p id="dependency-generation">Putting inter-dependencies of the form <code>Foo.o : Bar.hi</code> into your <code>Makefile</code> by hand is rather error-prone. Don’t worry, GHC has support for automatically generating the required dependencies. Add the following to your <code>Makefile</code>:</p> <pre data-language="make">depend :
        ghc -dep-suffix '' -M $(HC_OPTS) $(SRCS)
</pre> <p>Now, before you start compiling, and any time you change the <code>imports</code> in your program, do <code>make depend</code> before you do <code>make cool_pgm</code>. The command <code>ghc -M</code> will append the needed dependencies to your <code>Makefile</code>.</p> <p>In general, <code>ghc -M Foo</code> does the following. For each module <code>M</code> in the set <code>Foo</code> plus all its imports (transitively), it adds to the Makefile:</p> <ul> <li>
<p class="first">A line recording the dependence of the object file on the source file.</p> <pre data-language="make">M.o : M.hs
</pre> <p>(or <code>M.lhs</code> if that is the filename you used).</p> </li> <li>
<p class="first">For each import declaration <code>import X</code> in <code>M</code>, a line recording the dependence of <code>M</code> on <code>X</code>:</p> <pre data-language="make">M.o : X.hi
</pre> </li> <li>
<p class="first">For each import declaration <code>import {-# SOURCE #-} X</code> in <code>M</code>, a line recording the dependence of <code>M</code> on <code>X</code>:</p> <pre data-language="make">M.o : X.hi-boot
</pre> <p>(See <a class="reference internal" href="#mutual-recursion">How to compile mutually recursive modules</a> for details of <code>hi-boot</code> style interface files.)</p> </li> </ul> <p>If <code>M</code> imports multiple modules, then there will be multiple lines with <code>M.o</code> as the target.</p> <p>There is no need to list all of the source files as arguments to the <code>ghc -M</code> command; <code>ghc</code> traces the dependencies, just like <code>ghc --make</code> (a new feature in GHC 6.4).</p> <p>Note that <code>ghc -M</code> needs to find a <em>source file</em> for each module in the dependency graph, so that it can parse the import declarations and follow dependencies. Any pre-compiled modules without source files must therefore belong to a package <a class="footnote-reference" href="#id5" id="id4">[1]</a>.</p> <p>By default, <code>ghc -M</code> generates all the dependencies, and then concatenates them onto the end of <code>makefile</code> (or <code>Makefile</code> if <code>makefile</code> doesn’t exist) bracketed by the lines “<code># DO NOT DELETE: Beginning of Haskell dependencies</code>” and “<code># DO NOT DELETE: End of Haskell dependencies</code>”. If these lines already exist in the <code>makefile</code>, then the old dependencies are deleted first.</p> <p>Don’t forget to use the same <code>-package</code> options on the <code>ghc -M</code> command line as you would when compiling; this enables the dependency generator to locate any imported modules that come from packages. The package modules won’t be included in the dependencies generated, though (but see the <code>-include-pkg-deps</code> option below).</p> <p>The dependency generation phase of GHC can take some additional options, which you may find useful. The options which affect dependency generation are:</p> <dl class="ghc-flag"> <dt id="ghc-flag--ddump-mod-cycles">
<code>-ddump-mod-cycles</code> </dt> <dd>
<p>Display a list of the cycles in the module graph. This is useful when trying to eliminate such cycles.</p> </dd>
</dl> <dl class="ghc-flag"> <dt>
<code>-v2</code> </dt> <dd>
<p>Print a full list of the module dependencies to stdout. (This is the standard verbosity flag, so the list will also be displayed with <code>-v3</code> and <code>-v4</code>; see <a class="reference internal" href="../using/#options-help">Verbosity options</a>.)</p> </dd>
</dl> <dl class="ghc-flag"> <dt id="ghc-flag--dep-makefile">
<code>-dep-makefile⟨file⟩</code> </dt> <dd>
<p>Use ⟨file⟩ as the makefile, rather than <code>makefile</code> or <code>Makefile</code>. If ⟨file⟩ doesn’t exist, <code>mkdependHS</code> creates it. We often use <code>-dep-makefile .depend</code> to put the dependencies in <code>.depend</code> and then <code>include</code> the file <code>.depend</code> into <code>Makefile</code>.</p> </dd>
</dl> <dl class="ghc-flag"> <dt id="ghc-flag--dep-suffix">
<code>-dep-suffix⟨suf⟩</code> </dt> <dd>
<p>Make extra dependencies that declare that files with suffix <code>.&lt;suf&gt;_&lt;osuf&gt;</code> depend on interface files with suffix <code>.&lt;suf&gt;_hi</code>, or (for <code>{-# SOURCE #-}</code> imports) on <code>.hi-boot</code>. Multiple <code>-dep-suffix</code> flags are permitted. For example, <code>-dep-suffix a -dep-suffix b</code> will make dependencies for <code>.hs</code> on <code>.hi</code>, <code>.a_hs</code> on <code>.a_hi</code>, and <code>.b_hs</code> on <code>.b_hi</code>. (Useful in conjunction with NoFib “ways”.)</p> </dd>
</dl> <dl class="ghc-flag"> <dt id="ghc-flag---exclude-module">
<code>--exclude-module=⟨file⟩</code> </dt> <dd>
<p>Regard <code>&lt;file&gt;</code> as “stable”; i.e., exclude it from having dependencies on it.</p> </dd>
</dl> <dl class="ghc-flag"> <dt id="ghc-flag--include-pkg-deps">
<code>-include-pkg-deps</code> </dt> <dd>
<p>Regard modules imported from packages as unstable, i.e., generate dependencies on any imported package modules (including <code>Prelude</code>, and all other standard Haskell libraries). Dependencies are not traced recursively into packages; dependencies are only generated for home-package modules on external-package modules directly imported by the home package module. This option is normally only used by the various system libraries.</p> </dd>
</dl>   <h2 id="orphan-modules">6.8.13. Orphan modules and instance declarations</h2> <p id="orphan-modules-and-instance-declarations">Haskell specifies that when compiling module <code>M</code>, any instance declaration in any module “below” <code>M</code> is visible. (Module <code>A</code> is “below” <code>M</code> if <code>A</code> is imported directly by <code>M</code>, or if <code>A</code> is below a module that <code>M</code> imports directly.) In principle, GHC must therefore read the interface files of every module below <code>M</code>, just in case they contain an instance declaration that matters to <code>M</code>. This would be a disaster in practice, so GHC tries to be clever.</p> <p>In particular, if an instance declaration is in the same module as the definition of any type or class mentioned in the <em>head</em> of the instance declaration (the part after the “<code>=&gt;</code>”; see <a class="reference internal" href="../glasgow_exts/#instance-rules">Relaxed rules for instance contexts</a>), then GHC has to visit that interface file anyway. Example:</p> <pre data-language="haskell">module A where
  instance C a =&gt; D (T a) where ...
  data T a = ...
</pre> <p>The instance declaration is only relevant if the type <code>T</code> is in use, and if so, GHC will have visited <code>A</code>‘s interface file to find <code>T</code>‘s definition.</p> <p>The only problem comes when a module contains an instance declaration and GHC has no other reason for visiting the module. Example:</p> <pre data-language="haskell">module Orphan where
  instance C a =&gt; D (T a) where ...
  class C a where ...
</pre> <p>Here, neither <code>D</code> nor <code>T</code> is declared in module <code>Orphan</code>. We call such modules “orphan modules”. GHC identifies orphan modules, and visits the interface file of every orphan module below the module being compiled. This is usually wasted work, but there is no avoiding it. You should therefore do your best to have as few orphan modules as possible.</p> <p>Functional dependencies complicate matters. Suppose we have:</p> <pre data-language="haskell">module B where
  instance E T Int where ...
  data T = ...
</pre> <p>Is this an orphan module? Apparently not, because <code>T</code> is declared in the same module. But suppose class <code>E</code> had a functional dependency:</p> <pre data-language="haskell">module Lib where
  class E x y | y -&gt; x where ...
</pre> <p>Then in some importing module <code>M</code>, the constraint <code>(E a Int)</code> should be “improved” by setting <code>a = T</code>, <em>even though there is no explicit mention</em> of <code>T</code> in <code>M</code>.</p> <p>These considerations lead to the following definition of an orphan module:</p> <ul> <li>An <em>orphan module</em> orphan module contains at least one <em>orphan instance</em> or at least one <em>orphan rule</em>. </li> <li>
<p class="first">An instance declaration in a module <code>M</code> is an <em>orphan instance</em> if orphan instance</p> <ul class="simple"> <li>The class of the instance declaration is not declared in <code>M</code>, and</li> <li>
<em>Either</em> the class has no functional dependencies, and none of the type constructors in the instance head is declared in <code>M</code>; <em>or</em> there is a functional dependency for which none of the type constructors mentioned in the <em>non-determined</em> part of the instance head is defined in <code>M</code>.</li> </ul> <p>Only the instance head counts. In the example above, it is not good enough for <code>C</code>‘s declaration to be in module <code>A</code>; it must be the declaration of <code>D</code> or <code>T</code>.</p> </li> <li>A rewrite rule in a module <code>M</code> is an <em>orphan rule</em> orphan rule if none of the variables, type constructors, or classes that are free in the left hand side of the rule are declared in <code>M</code>. </li> </ul> <p>If you use the flag <a class="reference internal" href="../using-warnings/#ghc-flag--Worphans"><code>-Worphans</code></a>, GHC will warn you if you are creating an orphan module. Like any warning, you can switch the warning off with <a class="reference internal" href="../using-warnings/#ghc-flag--Worphans"><code>-Wno-orphans</code></a>, and <a class="reference internal" href="../using-warnings/#ghc-flag--Werror"><code>-Werror</code></a> will make the compilation fail if the warning is issued.</p> <p>You can identify an orphan module by looking in its interface file, <code>M.hi</code>, using the <a class="reference internal" href="../using/#ghc-flag---show-iface"><code>--show-iface</code></a> <a class="reference internal" href="../using/#modes">mode</a>. If there is a <code>[orphan module]</code> on the first line, GHC considers it an orphan module.</p> <table class="docutils footnote" frame="void" id="id5" rules="none">   <tr>
<td class="label"><a class="fn-backref" href="#id4">[1]</a></td>
<td>This is a change in behaviour relative to 6.2 and earlier.</td>
</tr>  </table>   </div>
<div class="_attribution">
  <p class="_attribution-p">
    © 2002–2007 The University Court of the University of Glasgow. All rights reserved.<br>Licensed under the Glasgow Haskell Compiler License.<br>
    <a href="https://downloads.haskell.org/~ghc/8.0.1/docs/html/users_guide/separate_compilation.html" class="_attribution-link" target="_blank">https://downloads.haskell.org/~ghc/8.0.1/docs/html/users_guide/separate_compilation.html</a>
  </p>
</div>

			</div>
		</div>
	</section>

	</div>
</body>
</html>
