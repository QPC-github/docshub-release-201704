
<!DOCTYPE HTML>

<html lang="en">

<head>
  <meta charset="utf-8">
  <title>Templates.helpers - Ember.js - W3cubDocs</title>
  
  <meta name="description" content=" Module&#58; ember-glimmer ">
  <meta name="keywords" content="ember, templates, helpers, class, -, js">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="http://docs.w3cub.com/ember/classes/ember.templates.helpers/">
  <link href="/favicon.png" rel="icon">
  <link type="text/css" rel="stylesheet" href="/assets/application-50364fff564ce3b6327021805f3f00e2957b441cf27f576a7dd4ff63bbc47047.css">
  <script type="text/javascript" src="/assets/application-db64bfd54ceb42be11af7995804cf4902548419ceb79d509b0b7d62c22d98e6f.js"></script>
  <script src="/json/ember.js"></script>
  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-71174418-1']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>


</head>

<body>
	<div class="_app">
	<header class="_header">
  
  <form class="_search">
    <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
    <a class="_search-clear"></a>
    <div class="_search-tag"></div>
  </form>
  
  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/ember/" class="_nav-link" title="" style="margin-left:0;">Ember.js</a></span>
  
  <nav class="_nav">
    <a href="/app/" class="_nav-link ">App</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		<div class="_list">
			
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<div class="_page _ember">
				
<h1 class="api-header"> Ember.Templates.helpers Class </h1>  <blockquote class="class-info"> <p>Module: <a href="../../modules/ember-glimmer/">ember-glimmer</a></p> </blockquote>    <h2 id="method_action">action<span class="flag public">public</span>
</h2>  <p class="meta"> Defined in <a class="api-file-link" href="https://github.com/emberjs/ember.js/tree/v2.12.0/packages/ember-glimmer/lib/helpers/action.js#L21" target="_blank">packages/ember-glimmer/lib/helpers/action.js:21</a> </p> <div class="description"> <p>The <code>{{action}}</code> helper provides a way to pass triggers for behavior (usually just a function) between components, and into components from controllers.</p> <h3 class="anchorable-toc" id="toc_passing-functions-with-the-action-helper">Passing functions with the action helper</h3> <p>There are three contexts an action helper can be used in. The first two contexts to discuss are attribute context, and Handlebars value context.</p> <pre class="highlight handlebars " data-language="html">{{! An example of attribute context }}
&lt;div onclick={{action "save"}}&gt;&lt;/div&gt;
{{! Examples of Handlebars value context }}
{{input on-input=(action "save")}}
{{yield (action "refreshData") andAnotherParam}}
</pre> <p>In these contexts, the helper is called a "closure action" helper. Its behavior is simple: If passed a function name, read that function off the <code>actions</code> property of the current context. Once that function is read (or if a function was passed), create a closure over that function and any arguments. The resulting value of an action helper used this way is simply a function.</p> <p>For example, in the attribute context:</p> <pre class="highlight handlebars " data-language="html">{{! An example of attribute context }}
&lt;div onclick={{action "save"}}&gt;&lt;/div&gt;
</pre> <p>The resulting template render logic would be:</p> <pre class="highlight js " data-language="js">var div = document.createElement('div');
var actionFunction = (function(context){
  return function() {
    return context.actions.save.apply(context, arguments);
  };
})(context);
div.onclick = actionFunction;
</pre> <p>Thus when the div is clicked, the action on that context is called. Because the <code>actionFunction</code> is just a function, closure actions can be passed between components and still execute in the correct context.</p> <p>Here is an example action handler on a component:</p> <pre class="highlight js " data-language="js">import Ember from 'ember';

export default Ember.Component.extend({
  actions: {
    save() {
      this.get('model').save();
    }
  }
});
</pre> <p>Actions are always looked up on the <code>actions</code> property of the current context. This avoids collisions in the naming of common actions, such as <code>destroy</code>. Two options can be passed to the <code>action</code> helper when it is used in this way.</p> <ul> <li>
<code>target=someProperty</code> will look to <code>someProperty</code> instead of the current context for the <code>actions</code> hash. This can be useful when targetting a service for actions.</li> <li>
<code>value="target.value"</code> will read the path <code>target.value</code> off the first argument to the action when it is called and rewrite the first argument to be that value. This is useful when attaching actions to event listeners.</li> </ul> <h3 class="anchorable-toc" id="toc_invoking-an-action">Invoking an action</h3> <p>Closure actions curry both their scope and any arguments. When invoked, any additional arguments are added to the already curried list. Actions should be invoked using the <a href="../ember.component/#method_sendAction">sendAction</a> method. The first argument to <code>sendAction</code> is the action to be called, and additional arguments are passed to the action function. This has interesting properties combined with currying of arguments. For example:</p> <pre class="highlight js " data-language="js">export default Ember.Component.extend({
  actions: {
    // Usage {{input on-input=(action (action 'setName' model) value="target.value")}}
    setName(model, name) {
      model.set('name', name);
    }
  }
});
</pre> <p>The first argument (<code>model</code>) was curried over, and the run-time argument (<code>event</code>) becomes a second argument. Action calls can be nested this way because each simply returns a function. Any function can be passed to the <code>{{action}}</code> helper, including other actions.</p> <p>Actions invoked with <code>sendAction</code> have the same currying behavior as demonstrated with <code>on-input</code> above. For example:</p> <div class="pre-title"><code>app/components/my-input.js</code></div>
<pre class="highlight javascript " data-language="javascript">import Ember from 'ember';

export default Ember.Component.extend({
  actions: {
    setName(model, name) {
      model.set('name', name);
    }
  }
});
</pre>
<pre class="highlight handlebars " data-language="html">{{my-input submit=(action 'setName' model)}}
</pre>
<div class="pre-title"><code>app/components/my-component.js</code></div>
<pre class="highlight javascript " data-language="javascript">import Ember from 'ember';

export default Ember.Component.extend({
  click() {
    // Note that model is not passed, it was curried in the template
    this.sendAction('submit', 'bob');
  }
});
</pre>
<h3 class="anchorable-toc" id="toc_attaching-actions-to-dom-elements">Attaching actions to DOM elements</h3> <p>The third context of the <code>{{action}}</code> helper can be called "element space". For example:</p> <pre class="highlight handlebars " data-language="html">{{! An example of element space }}
&lt;div {{action "save"}}&gt;&lt;/div&gt;
</pre> <p>Used this way, the <code>{{action}}</code> helper provides a useful shortcut for registering an HTML element in a template for a single DOM event and forwarding that interaction to the template's context (controller or component). If the context of a template is a controller, actions used this way will bubble to routes when the controller does not implement the specified action. Once an action hits a route, it will bubble through the route hierarchy.</p> <h3 class="anchorable-toc" id="toc_event-propagation">Event Propagation</h3> <p><code>{{action}}</code> helpers called in element space can control event bubbling. Note that the closure style actions cannot.</p> <p>Events triggered through the action helper will automatically have <code>.preventDefault()</code> called on them. You do not need to do so in your event handlers. If you need to allow event propagation (to handle file inputs for example) you can supply the <code>preventDefault=false</code> option to the <code>{{action}}</code> helper:</p> <pre class="highlight handlebars " data-language="html">&lt;div {{action "sayHello" preventDefault=false}}&gt;
  &lt;input type="file" /&gt;
  &lt;input type="checkbox" /&gt;
&lt;/div&gt;
</pre> <p>To disable bubbling, pass <code>bubbles=false</code> to the helper:</p> <pre class="highlight handlebars " data-language="html">&lt;button {{action 'edit' post bubbles=false}}&gt;Edit&lt;/button&gt;
</pre> <p>To disable bubbling with closure style actions you must create your own wrapper helper that makes use of <code>event.stopPropagation()</code>:</p> <pre class="highlight handlebars " data-language="html">&lt;div onclick={{disable-bubbling (action "sayHello")}}&gt;Hello&lt;/div&gt;
</pre>
<div class="pre-title"><code>app/helpers/disable-bubbling.js</code></div>
<pre class="highlight javascript " data-language="javascript">import Ember from 'ember';

export function disableBubbling([action]) {
  return function(event) {
    event.stopPropagation();
    return action(event);
  };
}
export default Ember.Helper.helper(disableBubbling);
</pre> <p>If you need the default handler to trigger you should either register your own event handler, or use event methods on your view class. See <a href="../ember.view/#toc_responding-to-browser-events">"Responding to Browser Events"</a> in the documentation for Ember.View for more information.</p> <h3 class="anchorable-toc" id="toc_specifying-dom-event-type">Specifying DOM event type</h3> <p><code>{{action}}</code> helpers called in element space can specify an event type. By default the <code>{{action}}</code> helper registers for DOM <code>click</code> events. You can supply an <code>on</code> option to the helper to specify a different DOM event name:</p> <pre class="highlight handlebars " data-language="html">&lt;div {{action "anActionName" on="doubleClick"}}&gt;
  click me
&lt;/div&gt;
</pre> <p>See <a href="../ember.view/#toc_event-names">"Event Names"</a> for a list of acceptable DOM event names.</p> <h3 class="anchorable-toc" id="toc_specifying-whitelisted-modifier-keys">Specifying whitelisted modifier keys</h3> <p><code>{{action}}</code> helpers called in element space can specify modifier keys. By default the <code>{{action}}</code> helper will ignore click events with pressed modifier keys. You can supply an <code>allowedKeys</code> option to specify which keys should not be ignored.</p> <pre class="highlight handlebars " data-language="html">&lt;div {{action "anActionName" allowedKeys="alt"}}&gt;
  click me
&lt;/div&gt;
</pre> <p>This way the action will fire when clicking with the alt key pressed down. Alternatively, supply "any" to the <code>allowedKeys</code> option to accept any combination of modifier keys.</p> <pre class="highlight handlebars " data-language="html">&lt;div {{action "anActionName" allowedKeys="any"}}&gt;
  click me with any key pressed
&lt;/div&gt;
</pre>
<h3 class="anchorable-toc" id="toc_specifying-a-target">Specifying a Target</h3> <p>A <code>target</code> option can be provided to the helper to change which object will receive the method call. This option must be a path to an object, accessible in the current context:</p> <div class="pre-title"><code>app/templates/application.hbs</code></div>
<pre class="highlight handlebars " data-language="html">&lt;div {{action "anActionName" target=someService}}&gt;
  click me
&lt;/div&gt;
</pre>
<div class="pre-title"><code>app/controllers/application.js</code></div>
<pre class="highlight javascript " data-language="javascript">import Ember from 'ember';

export default Ember.Controller.extend({
  someService: Ember.inject.service()
});
</pre> </div>    <h2 id="method_component">component<span class="flag public">public</span>
</h2>  <p class="meta"> Defined in <a class="api-file-link" href="https://github.com/emberjs/ember.js/tree/v2.12.0/packages/ember-glimmer/lib/helpers/component.js#L20" target="_blank">packages/ember-glimmer/lib/helpers/component.js:20</a> <br>Available since 1.11.0 </p> <div class="description"> <p>The <code>{{component}}</code> helper lets you add instances of <code>Ember.Component</code> to a template. See <a href="../ember.component/">Ember.Component</a> for additional information on how a <code>Component</code> functions. <code>{{component}}</code>'s primary use is for cases where you want to dynamically change which type of component is rendered as the state of your application changes. This helper has three modes: inline, block, and nested.</p> <h3 class="anchorable-toc" id="toc_inline-form">Inline Form</h3> <p>Given the following template:</p> <div class="pre-title"><code>app/application.hbs</code></div>
<pre class="highlight handlebars " data-language="html">{{component infographicComponentName}}
</pre> <p>And the following application code:</p> <div class="pre-title"><code>app/controllers/application.js</code></div>
<pre class="highlight javascript " data-language="javascript">export default Ember.Controller.extend({
  infographicComponentName: computed('isMarketOpen', {
    get() {
      if (this.get('isMarketOpen')) {
        return 'live-updating-chart';
      } else {
        return 'market-close-summary';
      }
    }
  })
});
</pre> <p>The <code>live-updating-chart</code> component will be appended when <code>isMarketOpen</code> is <code>true</code>, and the <code>market-close-summary</code> component will be appended when <code>isMarketOpen</code> is <code>false</code>. If the value changes while the app is running, the component will be automatically swapped out accordingly. Note: You should not use this helper when you are consistently rendering the same component. In that case, use standard component syntax, for example:</p> <div class="pre-title"><code>app/templates/application.hbs</code></div>
<pre class="highlight handlebars " data-language="html">{{live-updating-chart}}
</pre>
<h3 class="anchorable-toc" id="toc_block-form">Block Form</h3> <p>Using the block form of this helper is similar to using the block form of a component. Given the following application template:</p> <div class="pre-title"><code>app/templates/application.hbs</code></div>
<pre class="highlight handlebars " data-language="html">{{#component infographicComponentName}}
  Last update: {{lastUpdateTimestamp}}
{{/component}}
</pre> <p>The following controller code:</p> <div class="pre-title"><code>app/controllers/application.js</code></div>
<pre class="highlight javascript " data-language="javascript">export default Ember.Controller.extend({
  lastUpdateTimestamp: computed(function() {
    return new Date();
  }),

  infographicComponentName: computed('isMarketOpen', {
    get() {
      if (this.get('isMarketOpen')) {
        return 'live-updating-chart';
      } else {
        return 'market-close-summary';
      }
    }
  })
});
</pre> <p>And the following component template:</p> <div class="pre-title"><code>app/templates/components/live-updating-chart.hbs</code></div>
<pre class="highlight handlebars " data-language="html">{{! chart }}
{{yield}}
</pre> <p>The <code>Last Update: {{lastUpdateTimestamp}}</code> will be rendered in place of the <code>{{yield}}</code>.</p> <h3 class="anchorable-toc" id="toc_nested-usage">Nested Usage</h3> <p>The <code>component</code> helper can be used to package a component path with initial attrs. The included attrs can then be merged during the final invocation. For example, given a <code>person-form</code> component with the following template:</p> <div class="pre-title"><code>app/templates/components/person-form.hbs</code></div>
<pre class="highlight handlebars " data-language="html">{{yield (hash
  nameInput=(component "my-input-component" value=model.name placeholder="First Name")
)}}
</pre> <p>When yielding the component via the <code>hash</code> helper, the component is invoked directly. See the following snippet:</p> <pre class="highlight text " data-language="">{{#person-form as |form|}}
  {{form.nameInput placeholder="Username"}}
{{/person-form}}
</pre> <p>Which outputs an input whose value is already bound to <code>model.name</code> and <code>placeholder</code> is "Username".</p> <p>When yielding the component without the hash helper use the <code>component</code> helper. For example, below is a <code>full-name</code> component template:</p> <pre class="highlight handlebars " data-language="html">{{yield (component "my-input-component" value=model.name placeholder="Name")}}
</pre>
<pre class="highlight text " data-language="">{{#full-name as |field|}}
  {{component field placeholder="Full name"}}
{{/full-name}}
</pre> </div>    <h2 id="method_concat">concat<span class="flag public">public</span>
</h2>  <p class="meta"> Defined in <a class="api-file-link" href="https://github.com/emberjs/ember.js/tree/v2.12.0/packages/ember-glimmer/lib/helpers/concat.js#L9" target="_blank">packages/ember-glimmer/lib/helpers/concat.js:9</a> <br>Available since 1.13.0 </p> <div class="description"> <p>Concatenates the given arguments into a string.</p> <p>Example:</p> <pre class="highlight handlebars " data-language="html">{{some-component name=(concat firstName " " lastName)}}

{{! would pass name="&lt;first name value&gt; &lt;last name value&gt;" to the component}}
</pre> </div>    <h2 id="method_debugger">debugger<span class="flag public">public</span>
</h2>  <p class="meta"> Inherited from <a href="../ember.templates.helpers/#method_debugger">Ember.Templates.helpers</a> but overwritten in <a class="api-file-link" href="https://github.com/emberjs/ember.js/tree/v2.12.0/packages/ember-glimmer/lib/index.js#L114" target="_blank">packages/ember-glimmer/lib/index.js:114</a> </p> <div class="description"> <p>Execute the <code>debugger</code> statement in the current template's context.</p> <pre class="highlight handlebars " data-language="html">{{debugger}}
</pre> <p>When using the debugger helper you will have access to a <code>get</code> function. This function retrieves values available in the context of the template. For example, if you're wondering why a value <code>{{foo}}</code> isn't rendering as expected within a template, you could place a <code>{{debugger}}</code> statement and, when the <code>debugger;</code> breakpoint is hit, you can attempt to retrieve this value:</p> <pre class="highlight text " data-language="">&gt; get('foo')
</pre> <p><code>get</code> is also aware of keywords. So in this situation</p> <pre class="highlight handlebars " data-language="html">{{#each items as |item|}}
  {{debugger}}
{{/each}}
</pre> <p>You'll be able to get values from the current item:</p> <pre class="highlight text " data-language="">&gt; get('item.name')
</pre> <p>You can also access the context of the view to make sure it is the object that you expect:</p> <pre class="highlight text " data-language="">&gt; context
</pre> </div>    <h2 id="method_each">each<span class="flag public">public</span>
</h2>  <p class="meta"> Defined in <a class="api-file-link" href="https://github.com/emberjs/ember.js/tree/v2.12.0/packages/ember-glimmer/lib/helpers/each-in.js#L7" target="_blank">packages/ember-glimmer/lib/helpers/each-in.js:7</a> </p> <div class="description"> <p>The <code>{{#each}}</code> helper loops over elements in a collection. It is an extension of the base Handlebars <code>{{#each}}</code> helper. The default behavior of <code>{{#each}}</code> is to yield its inner block once for every item in an array passing the item as the first block parameter.</p> <pre class="highlight javascript " data-language="javascript">var developers = [{ name: 'Yehuda' },{ name: 'Tom' }, { name: 'Paul' }];
</pre>
<pre class="highlight handlebars " data-language="html">{{#each developers key="name" as |person|}}
  {{person.name}}
  {{! `this` is whatever it was outside the #each }}
{{/each}}
</pre> <p>The same rules apply to arrays of primitives.</p> <pre class="highlight javascript " data-language="javascript">var developerNames = ['Yehuda', 'Tom', 'Paul']
</pre>
<pre class="highlight handlebars " data-language="html">{{#each developerNames key="@index" as |name|}}
  {{name}}
{{/each}}
</pre> <p>During iteration, the index of each item in the array is provided as a second block parameter.</p> <pre class="highlight handlebars " data-language="html">&lt;ul&gt;
  {{#each people as |person index|}}
    &lt;li&gt;Hello, {{person.name}}! You're number {{index}} in line&lt;/li&gt;
  {{/each}}
&lt;/ul&gt;
</pre>
<h3 class="anchorable-toc" id="toc_specifying-keys">Specifying Keys</h3> <p>The <code>key</code> option is used to tell Ember how to determine if the array being iterated over with <code>{{#each}}</code> has changed between renders. By helping Ember detect that some elements in the array are the same, DOM elements can be re-used, significantly improving rendering speed.</p> <p>For example, here's the <code>{{#each}}</code> helper with its <code>key</code> set to <code>id</code>:</p> <pre class="highlight handlebars " data-language="html">{{#each model key="id" as |item|}}
{{/each}}
</pre> <p>When this <code>{{#each}}</code> re-renders, Ember will match up the previously rendered items (and reorder the generated DOM elements) based on each item's <code>id</code> property. By default the item's own reference is used.</p> <h3 class="anchorable-toc" id="toc_else-condition">{{else}} condition</h3> <p><code>{{#each}}</code> can have a matching <code>{{else}}</code>. The contents of this block will render if the collection is empty.</p> <pre class="highlight handlebars " data-language="html">{{#each developers as |person|}}
  {{person.name}}
{{else}}
  &lt;p&gt;Sorry, nobody is available for this task.&lt;/p&gt;
{{/each}}
</pre> </div>    <h2 id="method_each-in">each-in<span class="flag public">public</span>
</h2>  <p class="meta"> Defined in <a class="api-file-link" href="https://github.com/emberjs/ember.js/tree/v2.12.0/packages/ember-glimmer/lib/helpers/each-in.js#L83" target="_blank">packages/ember-glimmer/lib/helpers/each-in.js:83</a> <br>Available since 2.1.0 </p> <div class="description"> <p>The <code>{{each-in}}</code> helper loops over properties on an object.</p> <p>For example, given a <code>user</code> object that looks like:</p> <pre class="highlight javascript " data-language="javascript">{
  "name": "Shelly Sails",
  "age": 42
}
</pre> <p>This template would display all properties on the <code>user</code> object in a list:</p> <pre class="highlight handlebars " data-language="html">&lt;ul&gt;
{{#each-in user as |key value|}}
  &lt;li&gt;{{key}}: {{value}}&lt;/li&gt;
{{/each-in}}
&lt;/ul&gt;
</pre> <p>Outputting their name and age.</p> </div>    <h2 id="method_get">get<span class="flag public">public</span>
</h2>  <p class="meta"> Defined in <a class="api-file-link" href="https://github.com/emberjs/ember.js/tree/v2.12.0/packages/ember-glimmer/lib/helpers/get.js#L16" target="_blank">packages/ember-glimmer/lib/helpers/get.js:16</a> <br>Available since 2.1.0 </p> <div class="description"> <p>Dynamically look up a property on an object. The second argument to <code>{{get}}</code> should have a string value, although it can be bound.</p> <p>For example, these two usages are equivilent:</p> <pre class="highlight handlebars " data-language="html">{{person.height}}
{{get person "height"}}
</pre> <p>If there were several facts about a person, the <code>{{get}}</code> helper can dynamically pick one:</p> <pre class="highlight handlebars " data-language="html">{{get person factName}}
</pre> <p>For a more complex example, this template would allow the user to switch between showing the user's height and weight with a click:</p> <pre class="highlight handlebars " data-language="html">{{get person factName}}
&lt;button {{action (action (mut factName)) "height"}}&gt;Show height&lt;/button&gt;
&lt;button {{action (action (mut factName)) "weight"}}&gt;Show weight&lt;/button&gt;
</pre> <p>The <code>{{get}}</code> helper can also respect mutable values itself. For example:</p> <pre class="highlight handlebars " data-language="html">{{input value=(mut (get person factName)) type="text"}}
&lt;button {{action (action (mut factName)) "height"}}&gt;Show height&lt;/button&gt;
&lt;button {{action (action (mut factName)) "weight"}}&gt;Show weight&lt;/button&gt;
</pre> <p>Would allow the user to swap what fact is being displayed, and also edit that fact via a two-way mutable binding.</p> </div>    <h2 id="method_hash">hash<span class="args"> (options) </span><code class="type">Object</code><span class="flag public">public</span>
</h2>    <p class="meta"> Defined in <a class="api-file-link" href="https://github.com/emberjs/ember.js/tree/v2.12.0/packages/ember-glimmer/lib/helpers/hash.js#L6" target="_blank">packages/ember-glimmer/lib/helpers/hash.js:6</a> <br>Available since 2.3.0 </p> <div class="description"> <p>Use the <code>{{hash}}</code> helper to create a hash to pass as an option to your components. This is specially useful for contextual components where you can just yield a hash:</p> <pre class="highlight handlebars " data-language="html">{{yield (hash
   name='Sarah'
   title=office
)}}
</pre> <p>Would result in an object such as:</p> <pre class="highlight js " data-language="js">{ name: 'Sarah', title: this.get('office') }
</pre> <p>Where the <code>title</code> is bound to updates of the <code>office</code> property.</p> </div>  <div class="params"> <h3>Parameters:</h3> <dl> <dt>
<strong>options</strong> <code class="type">Object</code>
</dt>  </dl> </div> <div class="return"> <h3>Returns:</h3> <dl> <dt>
<code class="type">Object</code> </dt>
<dd> Hash</dd> </dl> </div>   <h2 id="method_if">if<span class="flag public">public</span>
</h2>  <p class="meta"> Inherited from <a href="../ember.templates.helpers/#method_if">Ember.Templates.helpers</a> but overwritten in <a class="api-file-link" href="https://github.com/emberjs/ember.js/tree/v2.12.0/packages/ember-glimmer/lib/helpers/if-unless.js#L112" target="_blank">packages/ember-glimmer/lib/helpers/if-unless.js:112</a> </p> <div class="description"> <p>The inline <code>if</code> helper conditionally renders a single property or string. This helper acts like a ternary operator. If the first property is truthy, the second argument will be displayed, otherwise, the third argument will be displayed</p> <pre class="highlight handlebars " data-language="html">{{if useLongGreeting "Hello" "Hi"}} Alex
</pre> <p>You can use the <code>if</code> helper inside another helper as a subexpression.</p> <pre class="highlight handlebars " data-language="html">{{some-component height=(if isBig "100" "10")}}
</pre> </div>    <h2 id="method_input">input<span class="args"> (options) </span><span class="flag public">public</span>
</h2>   <p class="meta"> Defined in <a class="api-file-link" href="https://github.com/emberjs/ember.js/tree/v2.12.0/packages/ember-glimmer/lib/syntax/input.js#L16" target="_blank">packages/ember-glimmer/lib/syntax/input.js:16</a> </p> <div class="description"> <p>The <code>{{input}}</code> helper lets you create an HTML <code>&lt;input /&gt;</code> component. It causes an <code>Ember.TextField</code> component to be rendered. For more info, see the <a href="../ember.textfield/">Ember.TextField</a> docs and the <a href="http://emberjs.com/guides/templates/input-helpers/" target="_blank">templates guide</a>.</p> <pre class="highlight handlebars " data-language="html">{{input value="987"}}
</pre> <p>renders as:</p> <pre class="highlight HTML " data-language="">&lt;input type="text" value="987" /&gt;
</pre>
<h3 class="anchorable-toc" id="toc_text-field">Text field</h3> <p>If no <code>type</code> option is specified, a default of type 'text' is used. Many of the standard HTML attributes may be passed to this helper. </p>
<table> <tr>
<td><code>readonly</code></td>
<td><code>required</code></td>
<td><code>autofocus</code></td>
</tr> <tr>
<td><code>value</code></td>
<td><code>placeholder</code></td>
<td><code>disabled</code></td>
</tr> <tr>
<td><code>size</code></td>
<td><code>tabindex</code></td>
<td><code>maxlength</code></td>
</tr> <tr>
<td><code>name</code></td>
<td><code>min</code></td>
<td><code>max</code></td>
</tr> <tr>
<td><code>pattern</code></td>
<td><code>accept</code></td>
<td><code>autocomplete</code></td>
</tr> <tr>
<td><code>autosave</code></td>
<td><code>formaction</code></td>
<td><code>formenctype</code></td>
</tr> <tr>
<td><code>formmethod</code></td>
<td><code>formnovalidate</code></td>
<td><code>formtarget</code></td>
</tr> <tr>
<td><code>height</code></td>
<td><code>inputmode</code></td>
<td><code>multiple</code></td>
</tr> <tr>
<td><code>step</code></td>
<td><code>width</code></td>
<td><code>form</code></td>
</tr> <tr>
<td><code>selectionDirection</code></td>
<td><code>spellcheck</code></td>
<td> </td>
</tr> </table> When set to a quoted string, these values will be directly applied to the HTML element. When left unquoted, these values will be bound to a property on the template's current rendering context (most typically a controller instance). A very common use of this helper is to bind the <code>value</code> of an input to an Object's attribute: <pre class="highlight handlebars " data-language="html">Search:
{{input value=searchWord}}
</pre> <p>In this example, the inital value in the <code>&lt;input /&gt;</code> will be set to the value of <code>searchWord</code>. If the user changes the text, the value of <code>searchWord</code> will also be updated.</p> <h3 class="anchorable-toc" id="toc_actions">Actions</h3> <p>The helper can send multiple actions based on user events. The action property defines the action which is sent when the user presses the return key.</p> <pre class="highlight handlebars " data-language="html">{{input action="submit"}}
</pre> <p>The helper allows some user events to send actions.</p> <ul> <li><code>enter</code></li> <li><code>insert-newline</code></li> <li><code>escape-press</code></li> <li><code>focus-in</code></li> <li><code>focus-out</code></li> <li><code>key-press</code></li> <li><code>key-up</code></li> </ul> <p>For example, if you desire an action to be sent when the input is blurred, you only need to setup the action name to the event name property.</p> <pre class="highlight handlebars " data-language="html">{{input focus-out="alertMessage"}}
</pre> <p>See more about <a href="../ember.textfield/">Text Support Actions</a></p> <h3 class="anchorable-toc" id="toc_extending-code-ember-textfield-code">Extending <code>Ember.TextField</code>
</h3> <p>Internally, <code>{{input type="text"}}</code> creates an instance of <code>Ember.TextField</code>, passing arguments from the helper to <code>Ember.TextField</code>'s <code>create</code> method. You can extend the capabilities of text inputs in your applications by reopening this class. For example, if you are building a Bootstrap project where <code>data-*</code> attributes are used, you can add one to the <code>TextField</code>'s <code>attributeBindings</code> property:</p> <pre class="highlight javascript " data-language="javascript">Ember.TextField.reopen({
  attributeBindings: ['data-error']
});
</pre> <p>Keep in mind when writing <code>Ember.TextField</code> subclasses that <code>Ember.TextField</code> itself extends <code>Ember.Component</code>. Expect isolated component semantics, not legacy 1.x view semantics (like <code>controller</code> being present). See more about <a href="../ember.component/">Ember components</a></p> <h3 class="anchorable-toc" id="toc_checkbox">Checkbox</h3> <p>Checkboxes are special forms of the <code>{{input}}</code> helper. To create a <code>&lt;checkbox /&gt;</code>:</p> <pre class="highlight handlebars " data-language="html">Emberize Everything:
{{input type="checkbox" name="isEmberized" checked=isEmberized}}
</pre> <p>This will bind checked state of this checkbox to the value of <code>isEmberized</code> -- if either one changes, it will be reflected in the other.</p> <p>The following HTML attributes can be set via the helper:</p> <ul> <li><code>checked</code></li> <li><code>disabled</code></li> <li><code>tabindex</code></li> <li><code>indeterminate</code></li> <li><code>name</code></li> <li><code>autofocus</code></li> <li><code>form</code></li> </ul> <h3 class="anchorable-toc" id="toc_extending-code-ember-checkbox-code">Extending <code>Ember.Checkbox</code>
</h3> <p>Internally, <code>{{input type="checkbox"}}</code> creates an instance of <code>Ember.Checkbox</code>, passing arguments from the helper to <code>Ember.Checkbox</code>'s <code>create</code> method. You can extend the capablilties of checkbox inputs in your applications by reopening this class. For example, if you wanted to add a css class to all checkboxes in your application:</p> <pre class="highlight javascript " data-language="javascript">Ember.Checkbox.reopen({
  classNames: ['my-app-checkbox']
});
</pre> </div>  <div class="params"> <h3>Parameters:</h3> <dl> <dt>
<strong>options</strong> <code class="type">Hash</code>
</dt>  </dl> </div>   <h2 id="method_link-to">link-to<span class="args"> (routeName, context, options) </span><code class="type"><a href="http://emberjs.com/api/classes/String.html" target="_blank">String</a></code><span class="flag public">public</span>
</h2>    <p class="meta"> Defined in <a class="api-file-link" href="https://github.com/emberjs/ember.js/tree/v2.12.0/packages/ember-glimmer/lib/components/link-to.js#L6" target="_blank">packages/ember-glimmer/lib/components/link-to.js:6</a> </p> <div class="description"> <p>The <code>{{link-to}}</code> component renders a link to the supplied <code>routeName</code> passing an optionally supplied model to the route as its <code>model</code> context of the route. The block for <code>{{link-to}}</code> becomes the innerHTML of the rendered element:</p> <pre class="highlight handlebars " data-language="html">{{#link-to 'photoGallery'}}
  Great Hamster Photos
{{/link-to}}
</pre> <p>You can also use an inline form of <code>{{link-to}}</code> component by passing the link text as the first argument to the component:</p> <pre class="highlight handlebars " data-language="html">{{link-to 'Great Hamster Photos' 'photoGallery'}}
</pre> <p>Both will result in:</p> <pre class="highlight html " data-language="html">&lt;a href="/hamster-photos"&gt;
  Great Hamster Photos
&lt;/a&gt;
</pre>
<h3 class="anchorable-toc" id="toc_supplying-a-tagname">Supplying a tagName</h3> <p>By default <code>{{link-to}}</code> renders an <code>&lt;a&gt;</code> element. This can be overridden for a single use of <code>{{link-to}}</code> by supplying a <code>tagName</code> option:</p> <pre class="highlight handlebars " data-language="html">{{#link-to 'photoGallery' tagName="li"}}
  Great Hamster Photos
{{/link-to}}
</pre>
<pre class="highlight html " data-language="html">&lt;li&gt;
  Great Hamster Photos
&lt;/li&gt;
</pre> <p>To override this option for your entire application, see "Overriding Application-wide Defaults".</p> <h3 class="anchorable-toc" id="toc_disabling-the-code-link-to-code-component">Disabling the <code>link-to</code> component</h3> <p>By default <code>{{link-to}}</code> is enabled. any passed value to the <code>disabled</code> component property will disable the <code>link-to</code> component.</p> <p>static use: the <code>disabled</code> option:</p> <pre class="highlight handlebars " data-language="html">{{#link-to 'photoGallery' disabled=true}}
  Great Hamster Photos
{{/link-to}}
</pre> <p>dynamic use: the <code>disabledWhen</code> option:</p> <pre class="highlight handlebars " data-language="html">{{#link-to 'photoGallery' disabledWhen=controller.someProperty}}
  Great Hamster Photos
{{/link-to}}
</pre> <p>any passed value to <code>disabled</code> will disable it except <code>undefined</code>. to ensure that only <code>true</code> disable the <code>link-to</code> component you can override the global behaviour of <code>Ember.LinkComponent</code>.</p> <pre class="highlight javascript " data-language="javascript">Ember.LinkComponent.reopen({
  disabled: Ember.computed(function(key, value) {
    if (value !== undefined) {
      this.set('_isDisabled', value === true);
    }
    return value === true ? get(this, 'disabledClass') : false;
  })
});
</pre> <p>see "Overriding Application-wide Defaults" for more.</p> <h3 class="anchorable-toc" id="toc_handling-code-href-code">Handling <code>href</code>
</h3> <p><code>{{link-to}}</code> will use your application's Router to fill the element's <code>href</code> property with a url that matches the path to the supplied <code>routeName</code> for your router's configured <code>Location</code> scheme, which defaults to Ember.HashLocation.</p> <h3 class="anchorable-toc" id="toc_handling-current-route">Handling current route</h3> <p><code>{{link-to}}</code> will apply a CSS class name of 'active' when the application's current route matches the supplied routeName. For example, if the application's current route is 'photoGallery.recent' the following use of <code>{{link-to}}</code>:</p> <pre class="highlight handlebars " data-language="html">{{#link-to 'photoGallery.recent'}}
  Great Hamster Photos
{{/link-to}}
</pre> <p>will result in</p> <pre class="highlight html " data-language="html">&lt;a href="/hamster-photos/this-week" class="active"&gt;
  Great Hamster Photos
&lt;/a&gt;
</pre> <p>The CSS class name used for active classes can be customized for a single use of <code>{{link-to}}</code> by passing an <code>activeClass</code> option:</p> <pre class="highlight handlebars " data-language="html">{{#link-to 'photoGallery.recent' activeClass="current-url"}}
  Great Hamster Photos
{{/link-to}}
</pre>
<pre class="highlight html " data-language="html">&lt;a href="/hamster-photos/this-week" class="current-url"&gt;
  Great Hamster Photos
&lt;/a&gt;
</pre> <p>To override this option for your entire application, see "Overriding Application-wide Defaults".</p> <h3 class="anchorable-toc" id="toc_keeping-a-link-active-for-other-routes">Keeping a link active for other routes</h3> <p>If you need a link to be 'active' even when it doesn't match the current route, you can use the <code>current-when</code> argument.</p> <pre class="highlight handlebars " data-language="html">{{#link-to 'photoGallery' current-when='photos'}}
  Photo Gallery
{{/link-to}}
</pre> <p>This may be helpful for keeping links active for:</p> <ul> <li>non-nested routes that are logically related</li> <li>some secondary menu approaches</li> <li>'top navigation' with 'sub navigation' scenarios</li> </ul> <p>A link will be active if <code>current-when</code> is <code>true</code> or the current route is the route this link would transition to.</p> <p>To match multiple routes 'space-separate' the routes:</p> <pre class="highlight handlebars " data-language="html">{{#link-to 'gallery' current-when='photos drawings paintings'}}
  Art Gallery
{{/link-to}}
</pre>
<h3 class="anchorable-toc" id="toc_supplying-a-model">Supplying a model</h3> <p>An optional model argument can be used for routes whose paths contain dynamic segments. This argument will become the model context of the linked route:</p> <pre class="highlight javascript " data-language="javascript">Router.map(function() {
  this.route("photoGallery", {path: "hamster-photos/:photo_id"});
});
</pre>
<pre class="highlight handlebars " data-language="html">{{#link-to 'photoGallery' aPhoto}}
  {{aPhoto.title}}
{{/link-to}}
</pre>
<pre class="highlight html " data-language="html">&lt;a href="/hamster-photos/42"&gt;
  Tomster
&lt;/a&gt;
</pre>
<h3 class="anchorable-toc" id="toc_supplying-multiple-models">Supplying multiple models</h3> <p>For deep-linking to route paths that contain multiple dynamic segments, multiple model arguments can be used. As the router transitions through the route path, each supplied model argument will become the context for the route with the dynamic segments:</p> <pre class="highlight javascript " data-language="javascript">Router.map(function() {
  this.route("photoGallery", { path: "hamster-photos/:photo_id" }, function() {
    this.route("comment", {path: "comments/:comment_id"});
  });
});
</pre> <p>This argument will become the model context of the linked route:</p> <pre class="highlight handlebars " data-language="html">{{#link-to 'photoGallery.comment' aPhoto comment}}
  {{comment.body}}
{{/link-to}}
</pre>
<pre class="highlight html " data-language="html">&lt;a href="/hamster-photos/42/comments/718"&gt;
  A+++ would snuggle again.
&lt;/a&gt;
</pre>
<h3 class="anchorable-toc" id="toc_supplying-an-explicit-dynamic-segment-value">Supplying an explicit dynamic segment value</h3> <p>If you don't have a model object available to pass to <code>{{link-to}}</code>, an optional string or integer argument can be passed for routes whose paths contain dynamic segments. This argument will become the value of the dynamic segment:</p> <pre class="highlight javascript " data-language="javascript">Router.map(function() {
  this.route("photoGallery", { path: "hamster-photos/:photo_id" });
});
</pre>
<pre class="highlight handlebars " data-language="html">{{#link-to 'photoGallery' aPhotoId}}
  {{aPhoto.title}}
{{/link-to}}
</pre>
<pre class="highlight html " data-language="html">&lt;a href="/hamster-photos/42"&gt;
  Tomster
&lt;/a&gt;
</pre> <p>When transitioning into the linked route, the <code>model</code> hook will be triggered with parameters including this passed identifier.</p> <h3 class="anchorable-toc" id="toc_allowing-default-action">Allowing Default Action</h3> <p>By default the <code>{{link-to}}</code> component prevents the default browser action by calling <code>preventDefault()</code> as this sort of action bubbling is normally handled internally and we do not want to take the browser to a new URL (for example).</p> <p>If you need to override this behavior specify <code>preventDefault=false</code> in your template:</p> <pre class="highlight handlebars " data-language="html">{{#link-to 'photoGallery' aPhotoId preventDefault=false}}
  {{aPhotoId.title}}
{{/link-to}}
</pre>
<h3 class="anchorable-toc" id="toc_overriding-attributes">Overriding attributes</h3> <p>You can override any given property of the <code>Ember.LinkComponent</code> that is generated by the <code>{{link-to}}</code> component by passing key/value pairs, like so:</p> <pre class="highlight handlebars " data-language="html">{{#link-to  aPhoto tagName='li' title='Following this link will change your life' classNames='pic sweet'}}
  Uh-mazing!
{{/link-to}}
</pre> <p>See <a href="../ember.linkcomponent/">Ember.LinkComponent</a> for a complete list of overrideable properties. Be sure to also check out inherited properties of <code>LinkComponent</code>.</p> <h3 class="anchorable-toc" id="toc_overriding-application-wide-defaults">Overriding Application-wide Defaults</h3> <p><code>{{link-to}}</code> creates an instance of <code>Ember.LinkComponent</code> for rendering. To override options for your entire application, reopen <code>Ember.LinkComponent</code> and supply the desired values:</p> <pre class="highlight javascript " data-language="javascript">Ember.LinkComponent.reopen({
  activeClass: "is-active",
  tagName: 'li'
})
</pre> <p>It is also possible to override the default event in this manner:</p> <pre class="highlight javascript " data-language="javascript">Ember.LinkComponent.reopen({
  eventName: 'customEventName'
});
</pre> </div>  <div class="params"> <h3>Parameters:</h3> <dl> <dt>
<strong>routeName</strong> <code class="type"><a href="http://emberjs.com/api/classes/String.html" target="_blank">String</a></code>
</dt>  <dt>
<strong>context</strong> <code class="type">[Object]</code>
</dt>  <dt>
<strong>options</strong> <code class="type">[Object]</code>
</dt> <dd> Handlebars key/value pairs of options, you can override any property of Ember.LinkComponent </dd> </dl> </div> <div class="return"> <h3>Returns:</h3> <dl> <dt>
<code class="type"><a href="http://emberjs.com/api/classes/String.html" target="_blank">String</a></code> </dt>
<dd> HTML string</dd> </dl> </div>   <h2 id="method_loc">loc<span class="args"> (str) </span><span class="flag public">public</span>
</h2>   <p class="meta"> Defined in <a class="api-file-link" href="https://github.com/emberjs/ember.js/tree/v2.12.0/packages/ember-glimmer/lib/helpers/loc.js#L9" target="_blank">packages/ember-glimmer/lib/helpers/loc.js:9</a> </p> <div class="description"> <p>Calls <a href="../ember.string/#method_loc">Ember.String.loc</a> with the provided string. This is a convenient way to localize text within a template. For example:</p> <pre class="highlight javascript " data-language="javascript">Ember.STRINGS = {
  '_welcome_': 'Bonjour'
};
</pre>
<pre class="highlight handlebars " data-language="html">&lt;div class='message'&gt;
  {{loc '_welcome_'}}
&lt;/div&gt;
</pre>
<pre class="highlight html " data-language="html">&lt;div class='message'&gt;
  Bonjour
&lt;/div&gt;
</pre> <p>See <a href="../ember.string/#method_loc">Ember.String.loc</a> for how to set up localized string references.</p> </div>  <div class="params"> <h3>Parameters:</h3> <dl> <dt>
<strong>str</strong> <code class="type"><a href="http://emberjs.com/api/classes/String.html" target="_blank">String</a></code>
</dt> <dd> The string to format. </dd> </dl> </div>   <h2 id="method_log">log<span class="args"> (params) </span><span class="flag public">public</span>
</h2>   <p class="meta"> Defined in <a class="api-file-link" href="https://github.com/emberjs/ember.js/tree/v2.12.0/packages/ember-glimmer/lib/helpers/log.js#L9" target="_blank">packages/ember-glimmer/lib/helpers/log.js:9</a> </p> <div class="description"> <p><code>log</code> allows you to output the value of variables in the current rendering context. <code>log</code> also accepts primitive types such as strings or numbers.</p> <pre class="highlight handlebars " data-language="html">{{log "myVariable:" myVariable }}
</pre> </div>  <div class="params"> <h3>Parameters:</h3> <dl> <dt>
<strong>params</strong> <code class="type">Array</code>
</dt>  </dl> </div>   <h2 id="method_mount">mount<span class="flag public">public</span>
</h2>  <p class="meta"> Defined in <a class="api-file-link" href="https://github.com/emberjs/ember.js/tree/v2.12.0/packages/ember-glimmer/lib/syntax/mount.js#L18" target="_blank">packages/ember-glimmer/lib/syntax/mount.js:18</a> </p> <div class="description"> <p>The <code>{{mount}}</code> helper lets you embed a routeless engine in a template. Mounting an engine will cause an instance to be booted and its <code>application</code> template to be rendered.</p> <p>For example, the following template mounts the <code>ember-chat</code> engine:</p> <pre class="highlight handlebars " data-language="html">{{! application.hbs }}
{{mount "ember-chat"}}
</pre> <p>Currently, the engine name is the only argument that can be passed to <code>{{mount}}</code>.</p> </div>    <h2 id="method_mut">mut<span class="args"> (attr) </span><span class="flag public">public</span>
</h2>   <p class="meta"> Defined in <a class="api-file-link" href="https://github.com/emberjs/ember.js/tree/v2.12.0/packages/ember-glimmer/lib/helpers/mut.js#L10" target="_blank">packages/ember-glimmer/lib/helpers/mut.js:10</a> </p> <div class="description"> <p>The <code>mut</code> helper lets you <strong>clearly specify</strong> that a child <code>Component</code> can update the (mutable) value passed to it, which will <strong>change the value of the parent component</strong>.</p> <p>To specify that a parameter is mutable, when invoking the child <code>Component</code>:</p> <pre class="highlight handlebars " data-language="html">{{my-child childClickCount=(mut totalClicks)}}
</pre> <p>The child <code>Component</code> can then modify the parent's value just by modifying its own property:</p> <pre class="highlight javascript " data-language="javascript">// my-child.js
export default Component.extend({
  click() {
    this.incrementProperty('childClickCount');
  }
});
</pre> <p>Note that for curly components (<code>{{my-component}}</code>) the bindings are already mutable, making the <code>mut</code> unnecessary.</p> <p>Additionally, the <code>mut</code> helper can be combined with the <code>action</code> helper to mutate a value. For example:</p> <pre class="highlight handlebars " data-language="html">{{my-child childClickCount=totalClicks click-count-change=(action (mut totalClicks))}}
</pre> <p>The child <code>Component</code> would invoke the action with the new click value:</p> <pre class="highlight javascript " data-language="javascript">// my-child.js
export default Component.extend({
  click() {
    this.get('click-count-change')(this.get('childClickCount') + 1);
  }
});
</pre> <p>The <code>mut</code> helper changes the <code>totalClicks</code> value to what was provided as the action argument.</p> <p>The <code>mut</code> helper, when used with <code>action</code>, will return a function that sets the value passed to <code>mut</code> to its first argument. This works like any other closure action and interacts with the other features <code>action</code> provides. As an example, we can create a button that increments a value passing the value directly to the <code>action</code>:</p> <pre class="highlight handlebars " data-language="html">{{! inc helper is not provided by Ember }}
&lt;button onclick={{action (mut count) (inc count)}}&gt;
  Increment count
&lt;/button&gt;
</pre> <p>You can also use the <code>value</code> option:</p> <pre class="highlight handlebars " data-language="html">&lt;input value={{name}} oninput={{action (mut name) value="target.value"}}&gt;
</pre> </div>  <div class="params"> <h3>Parameters:</h3> <dl> <dt>
<strong>attr</strong> <code class="type">[Object]</code>
</dt> <dd> the "two-way" attribute that can be modified. </dd> </dl> </div>   <h2 id="method_outlet">outlet<span class="args"> (name) </span><span class="flag public">public</span>
</h2>   <p class="meta"> Defined in <a class="api-file-link" href="https://github.com/emberjs/ember.js/tree/v2.12.0/packages/ember-glimmer/lib/syntax/outlet.js#L34" target="_blank">packages/ember-glimmer/lib/syntax/outlet.js:34</a> </p> <div class="description"> <p>The <code>{{outlet}}</code> helper lets you specify where a child route will render in your template. An important use of the <code>{{outlet}}</code> helper is in your application's <code>application.hbs</code> file:</p> <pre class="highlight handlebars " data-language="html">{{! app/templates/application.hbs }}
&lt;!-- header content goes here, and will always display --&gt;
{{my-header}}
&lt;div class="my-dynamic-content"&gt;
  &lt;!-- this content will change based on the current route, which depends on the current URL --&gt;
  {{outlet}}
&lt;/div&gt;
&lt;!-- footer content goes here, and will always display --&gt;
{{my-footer}}
</pre> <p>See <a href="http://emberjs.com/guides/templates/the-application-template/" target="_blank">templates guide</a> for additional information on using <code>{{outlet}}</code> in <code>application.hbs</code>. You may also specify a name for the <code>{{outlet}}</code>, which is useful when using more than one <code>{{outlet}}</code> in a template:</p> <pre class="highlight handlebars " data-language="html">{{outlet "menu"}}
{{outlet "sidebar"}}
{{outlet "main"}}
</pre> <p>Your routes can then render into a specific one of these <code>outlet</code>s by specifying the <code>outlet</code> attribute in your <code>renderTemplate</code> function:</p> <pre class="highlight javascript " data-language="javascript">// app/routes/menu.js
export default Ember.Route.extend({
  renderTemplate() {
    this.render({ outlet: 'menu' });
  }
});
</pre> <p>See the <a href="http://emberjs.com/guides/routing/rendering-a-template/" target="_blank">routing guide</a> for more information on how your <code>route</code> interacts with the <code>{{outlet}}</code> helper. Note: Your content <strong>will not render</strong> if there isn't an <code>{{outlet}}</code> for it.</p> </div>  <div class="params"> <h3>Parameters:</h3> <dl> <dt>
<strong>name</strong> <code class="type">[<a href="http://emberjs.com/api/classes/String.html" target="_blank">String</a>]</code>
</dt>  </dl> </div>   <h2 id="method_partial">partial<span class="args"> (partialName) </span><span class="flag public">public</span>
</h2>   <p class="meta"> Defined in <a class="api-file-link" href="https://github.com/emberjs/ember.js/tree/v2.12.0/packages/ember-glimmer/lib/index.js#L157" target="_blank">packages/ember-glimmer/lib/index.js:157</a> </p> <div class="description"> <p>The <code>partial</code> helper renders another template without changing the template context:</p> <pre class="highlight handlebars " data-language="html">{{foo}}
{{partial "nav"}}
</pre> <p>The above example template will render a template named "-nav", which has the same context as the parent template it's rendered into, so if the "-nav" template also referenced <code>{{foo}}</code>, it would print the same thing as the <code>{{foo}}</code> in the above example.</p> <p>If a "-nav" template isn't found, the <code>partial</code> helper will fall back to a template named "nav".</p> <h3 class="anchorable-toc" id="toc_bound-template-names">Bound template names</h3> <p>The parameter supplied to <code>partial</code> can also be a path to a property containing a template name, e.g.:</p> <pre class="highlight handlebars " data-language="html">{{partial someTemplateName}}
</pre> <p>The above example will look up the value of <code>someTemplateName</code> on the template context (e.g. a controller) and use that value as the name of the template to render. If the resolved value is falsy, nothing will be rendered. If <code>someTemplateName</code> changes, the partial will be re-rendered using the new template name.</p> </div>  <div class="params"> <h3>Parameters:</h3> <dl> <dt>
<strong>partialName</strong> <code class="type"><a href="http://emberjs.com/api/classes/String.html" target="_blank">String</a></code>
</dt> <dd> The name of the template to render minus the leading underscore. </dd> </dl> </div>   <h2 id="method_query-params">query-params<span class="args"> (hash) </span><code class="type">Object</code><span class="flag public">public</span>
</h2>    <p class="meta"> Defined in <a class="api-file-link" href="https://github.com/emberjs/ember.js/tree/v2.12.0/packages/ember-glimmer/lib/helpers/query-param.js#L10" target="_blank">packages/ember-glimmer/lib/helpers/query-param.js:10</a> </p> <div class="description"> <p>This is a helper to be used in conjunction with the link-to helper. It will supply url query parameters to the target route.</p> <p>Example</p> <pre class="highlight handlebars " data-language="html">{{#link-to 'posts' (query-params direction="asc")}}Sort{{/link-to}}
</pre> </div>  <div class="params"> <h3>Parameters:</h3> <dl> <dt>
<strong>hash</strong> <code class="type">Object</code>
</dt> <dd> takes a hash of query parameters </dd> </dl> </div> <div class="return"> <h3>Returns:</h3> <dl> <dt>
<code class="type">Object</code> </dt>
<dd> A `QueryParams` object for `{{link-to}}`</dd> </dl> </div>   <h2 id="method_readonly">readonly<span class="args"> (attr) </span><span class="flag private">private</span>
</h2>   <p class="meta"> Defined in <a class="api-file-link" href="https://github.com/emberjs/ember.js/tree/v2.12.0/packages/ember-glimmer/lib/helpers/readonly.js#L9" target="_blank">packages/ember-glimmer/lib/helpers/readonly.js:9</a> </p> <div class="description"> <p>The <code>readonly</code> helper let's you specify that a binding is one-way only, instead of two-way. When you pass a <code>readonly</code> binding from an outer context (e.g. parent component), to to an inner context (e.g. child component), you are saying that changing that property in the inner context does not change the value in the outer context.</p> <p>To specify that a binding is read-only, when invoking the child <code>Component</code>:</p> <div class="pre-title"><code>app/components/my-parent.js</code></div>
<pre class="highlight javascript " data-language="javascript">export default Component.extend({
  totalClicks: 3
});
</pre>
<div class="pre-title"><code>app/templates/components/my-parent.hbs</code></div>
<pre class="highlight handlebars " data-language="html">{{log totalClicks}} // -&gt; 3
{{my-child childClickCount=(readonly totalClicks)}}
</pre> <p>Now, when you update <code>childClickCount</code>:</p> <div class="pre-title"><code>app/components/my-child.js</code></div>
<pre class="highlight javascript " data-language="javascript">export default Component.extend({
  click() {
    this.incrementProperty('childClickCount');
  }
});
</pre> <p>The value updates in the child component, but not the parent component:</p> <div class="pre-title"><code>app/templates/components/my-child.hbs</code></div>
<pre class="highlight handlebars " data-language="html">{{log childClickCount}} //-&gt; 4
</pre>
<div class="pre-title"><code>app/templates/components/my-parent.hbs</code></div>
<pre class="highlight handlebars " data-language="html">{{log totalClicks}} //-&gt; 3
{{my-child childClickCount=(readonly totalClicks)}}
</pre>
<h3 class="anchorable-toc" id="toc_objects-and-arrays">Objects and Arrays</h3> <p>When passing a property that is a complex object (e.g. object, array) instead of a primitive object (e.g. number, string), only the reference to the object is protected using the readonly helper. This means that you can change properties of the object both on the parent component, as well as the child component. The <code>readonly</code> binding behaves similar to the <code>const</code> keyword in JavaScript.</p> <p>Let's look at an example:</p> <p>First let's set up the parent component:</p> <div class="pre-title"><code>app/components/my-parent.js</code></div>
<pre class="highlight javascript " data-language="javascript">export default Ember.Component.extend({
  clicks: null,

  init() {
    this._super(...arguments);
    this.set('clicks', { total: 3 });
  }
});
</pre>
<div class="pre-title"><code>app/templates/components/my-parent.hbs</code></div>
<pre class="highlight handlebars " data-language="html">{{log clicks.total}} //-&gt; 3
{{my-child childClicks=(readonly clicks)}}
</pre> <p>Now, if you update the <code>total</code> property of <code>childClicks</code>:</p> <div class="pre-title"><code>app/components/my-child.js</code></div>
<pre class="highlight javascript " data-language="javascript">export default Ember.Component.extend({
  click() {
    this.get('clicks').incrementProperty('total');
  }
});
</pre> <p>You will see the following happen:</p> <div class="pre-title"><code>app/templates/components/my-parent.hbs</code></div>
<pre class="highlight handlebars " data-language="html">{{log clicks.total}} //-&gt; 4
{{my-child childClicks=(readonly clicks)}}
</pre>
<div class="pre-title"><code>app/templates/components/my-child.hbs</code></div>
<pre class="highlight handlebars " data-language="html">{{log childClicks.total}} //-&gt; 4
</pre> </div>  <div class="params"> <h3>Parameters:</h3> <dl> <dt>
<strong>attr</strong> <code class="type">[Object]</code>
</dt> <dd> the read-only attribute. </dd> </dl> </div>   <h2 id="method_render">render<span class="args"> (name, context, options) </span><code class="type"><a href="http://emberjs.com/api/classes/String.html" target="_blank">String</a></code><span class="flag public">public</span>
</h2>    <p class="meta"> Defined in <a class="api-file-link" href="https://github.com/emberjs/ember.js/tree/v2.12.0/packages/ember-glimmer/lib/syntax/render.js#L53" target="_blank">packages/ember-glimmer/lib/syntax/render.js:53</a> </p> <div class="description"> <p>Calling <code>{{render}}</code> from within a template will insert another template that matches the provided name. The inserted template will access its properties on its own controller (rather than the controller of the parent template).</p> <p>If a view class with the same name exists, the view class also will be used. Note: A given controller may only be used <em>once</em> in your app in this manner. A singleton instance of the controller will be created for you.</p> <p>Example:</p> <pre class="highlight javascript " data-language="javascript">App.NavigationController = Ember.Controller.extend({
  who: "world"
});
</pre>
<pre class="highlight handlebars " data-language="html">&lt;!-- navigation.hbs --&gt;
Hello, {{who}}.
</pre>
<pre class="highlight handlebars " data-language="html">&lt;!-- application.hbs --&gt;
&lt;h1&gt;My great app&lt;/h1&gt;
{{render "navigation"}}
</pre>
<pre class="highlight html " data-language="html">&lt;h1&gt;My great app&lt;/h1&gt;
&lt;div class='ember-view'&gt;
  Hello, world.
&lt;/div&gt;
</pre> <p>Optionally you may provide a second argument: a property path that will be bound to the <code>model</code> property of the controller. If a <code>model</code> property path is specified, then a new instance of the controller will be created and <code>{{render}}</code> can be used multiple times with the same name.</p> <p>For example if you had this <code>author</code> template.</p> <pre class="highlight handlebars " data-language="html">&lt;div class="author"&gt;
  Written by {{firstName}} {{lastName}}.
  Total Posts: {{postCount}}
&lt;/div&gt;
</pre> <p>You could render it inside the <code>post</code> template using the <code>render</code> helper.</p> <pre class="highlight handlebars " data-language="html">&lt;div class="post"&gt;
  &lt;h1&gt;{{title}}&lt;/h1&gt;
  &lt;div&gt;{{body}}&lt;/div&gt;
  {{render "author" author}}
&lt;/div&gt;
</pre> </div>  <div class="params"> <h3>Parameters:</h3> <dl> <dt>
<strong>name</strong> <code class="type"><a href="http://emberjs.com/api/classes/String.html" target="_blank">String</a></code>
</dt>  <dt>
<strong>context</strong> <code class="type">Object?</code>
</dt>  <dt>
<strong>options</strong> <code class="type">Hash</code>
</dt>  </dl> </div> <div class="return"> <h3>Returns:</h3> <dl> <dt>
<code class="type"><a href="http://emberjs.com/api/classes/String.html" target="_blank">String</a></code> </dt>
<dd> HTML string</dd> </dl> </div>   <h2 id="method_textarea">textarea<span class="args"> (options) </span><span class="flag public">public</span>
</h2>   <p class="meta"> Defined in <a class="api-file-link" href="https://github.com/emberjs/ember.js/tree/v2.12.0/packages/ember-glimmer/lib/components/text_area.js#L9" target="_blank">packages/ember-glimmer/lib/components/text_area.js:9</a> </p> <div class="description"> <p><code>{{textarea}}</code> inserts a new instance of <code>&lt;textarea&gt;</code> tag into the template. The attributes of <code>{{textarea}}</code> match those of the native HTML tags as closely as possible.</p> <p>The following HTML attributes can be set:</p> <ul> <li><code>value</code></li> <li><code>name</code></li> <li><code>rows</code></li> <li><code>cols</code></li> <li><code>placeholder</code></li> <li><code>disabled</code></li> <li><code>maxlength</code></li> <li><code>tabindex</code></li> <li><code>selectionEnd</code></li> <li><code>selectionStart</code></li> <li><code>selectionDirection</code></li> <li><code>wrap</code></li> <li><code>readonly</code></li> <li><code>autofocus</code></li> <li><code>form</code></li> <li><code>spellcheck</code></li> <li><code>required</code></li> </ul> <p>When set to a quoted string, these value will be directly applied to the HTML element. When left unquoted, these values will be bound to a property on the template's current rendering context (most typically a controller instance).</p> <p>Unbound:</p> <pre class="highlight handlebars " data-language="html">{{textarea value="Lots of static text that ISN'T bound"}}
</pre> <p>Would result in the following HTML:</p> <pre class="highlight html " data-language="html">&lt;textarea class="ember-text-area"&gt;
  Lots of static text that ISN'T bound
&lt;/textarea&gt;
</pre> <p>Bound:</p> <p>In the following example, the <code>writtenWords</code> property on <code>App.ApplicationController</code> will be updated live as the user types 'Lots of text that IS bound' into the text area of their browser's window.</p> <pre class="highlight javascript " data-language="javascript">App.ApplicationController = Ember.Controller.extend({
  writtenWords: "Lots of text that IS bound"
});
</pre>
<pre class="highlight handlebars " data-language="html">{{textarea value=writtenWords}}
</pre> <p>Would result in the following HTML:</p> <pre class="highlight html " data-language="html">&lt;textarea class="ember-text-area"&gt;
  Lots of text that IS bound
&lt;/textarea&gt;
</pre> <p>If you wanted a one way binding between the text area and a div tag somewhere else on your screen, you could use <code>Ember.computed.oneWay</code>:</p> <pre class="highlight javascript " data-language="javascript">App.ApplicationController = Ember.Controller.extend({
  writtenWords: "Lots of text that IS bound",
  outputWrittenWords: Ember.computed.oneWay("writtenWords")
});
</pre>
<pre class="highlight handlebars " data-language="html">{{textarea value=writtenWords}}
&lt;div&gt;
  {{outputWrittenWords}}
&lt;/div&gt;
</pre> <p>Would result in the following HTML:</p> <pre class="highlight html " data-language="html">&lt;textarea class="ember-text-area"&gt;
  Lots of text that IS bound
&lt;/textarea&gt;
&lt;-- the following div will be updated in real time as you type --&gt;
&lt;div&gt;
  Lots of text that IS bound
&lt;/div&gt;
</pre> <p>Finally, this example really shows the power and ease of Ember when two properties are bound to eachother via <code>Ember.computed.alias</code>. Type into either text area box and they'll both stay in sync. Note that <code>Ember.computed.alias</code> costs more in terms of performance, so only use it when your really binding in both directions:</p> <pre class="highlight javascript " data-language="javascript">App.ApplicationController = Ember.Controller.extend({
  writtenWords: "Lots of text that IS bound",
  twoWayWrittenWords: Ember.computed.alias("writtenWords")
});
</pre>
<pre class="highlight handlebars " data-language="html">{{textarea value=writtenWords}}
{{textarea value=twoWayWrittenWords}}
</pre>
<pre class="highlight html " data-language="html">&lt;textarea id="ember1" class="ember-text-area"&gt;
  Lots of text that IS bound
&lt;/textarea&gt;
&lt;-- both updated in real time --&gt;
&lt;textarea id="ember2" class="ember-text-area"&gt;
  Lots of text that IS bound
&lt;/textarea&gt;
</pre>
<h3 class="anchorable-toc" id="toc_actions">Actions</h3> <p>The helper can send multiple actions based on user events. The action property defines the action which is send when the user presses the return key.</p> <pre class="highlight handlebars " data-language="html">{{input action="submit"}}
</pre> <p>The helper allows some user events to send actions.</p> <ul> <li><code>enter</code></li> <li><code>insert-newline</code></li> <li><code>escape-press</code></li> <li><code>focus-in</code></li> <li><code>focus-out</code></li> <li><code>key-press</code></li> </ul> <p>For example, if you desire an action to be sent when the input is blurred, you only need to setup the action name to the event name property.</p> <pre class="highlight handlebars " data-language="html">{{textarea focus-out="alertMessage"}}
</pre> <p>See more about <a href="../ember.textarea/">Text Support Actions</a></p> <h3 class="anchorable-toc" id="toc_extension">Extension</h3> <p>Internally, <code>{{textarea}}</code> creates an instance of <code>Ember.TextArea</code>, passing arguments from the helper to <code>Ember.TextArea</code>'s <code>create</code> method. You can extend the capabilities of text areas in your application by reopening this class. For example, if you are building a Bootstrap project where <code>data-*</code> attributes are used, you can globally add support for a <code>data-*</code> attribute on all <code>{{textarea}}</code>s' in your app by reopening <code>Ember.TextArea</code> or <code>Ember.TextSupport</code> and adding it to the <code>attributeBindings</code> concatenated property:</p> <pre class="highlight javascript " data-language="javascript">Ember.TextArea.reopen({
  attributeBindings: ['data-error']
});
</pre> <p>Keep in mind when writing <code>Ember.TextArea</code> subclasses that <code>Ember.TextArea</code> itself extends <code>Ember.Component</code>. Expect isolated component semantics, not legacy 1.x view semantics (like <code>controller</code> being present).</p> <p>See more about <a href="../ember.component/">Ember components</a></p> </div>  <div class="params"> <h3>Parameters:</h3> <dl> <dt>
<strong>options</strong> <code class="type">Hash</code>
</dt>  </dl> </div>   <h2 id="method_unbound">unbound<span class="flag public">public</span>
</h2>  <p class="meta"> Defined in <a class="api-file-link" href="https://github.com/emberjs/ember.js/tree/v2.12.0/packages/ember-glimmer/lib/helpers/unbound.js#L9" target="_blank">packages/ember-glimmer/lib/helpers/unbound.js:9</a> </p> <div class="description"> <p>The <code>{{unbound}}</code> helper disconnects the one-way binding of a property, essentially freezing its value at the moment of rendering. For example, in this example the display of the variable <code>name</code> will not change even if it is set with a new value:</p> <pre class="highlight handlebars " data-language="html">{{unbound name}}
</pre> <p>Like any helper, the <code>unbound</code> helper can accept a nested helper expression. This allows for custom helpers to be rendered unbound:</p> <pre class="highlight handlebars " data-language="html">{{unbound (some-custom-helper)}}
{{unbound (capitalize name)}}
{{! You can use any helper, including unbound, in a nested expression }}
{{capitalize (unbound name)}}
</pre> <p>The <code>unbound</code> helper only accepts a single argument, and it return an unbound value.</p> </div>    <h2 id="method_unless">unless<span class="flag public">public</span>
</h2>  <p class="meta"> Defined in <a class="api-file-link" href="https://github.com/emberjs/ember.js/tree/v2.12.0/packages/ember-glimmer/lib/helpers/if-unless.js#L144" target="_blank">packages/ember-glimmer/lib/helpers/if-unless.js:144</a> </p> <div class="description"> <p>The inline <code>unless</code> helper conditionally renders a single property or string. This helper acts like a ternary operator. If the first property is falsy, the second argument will be displayed, otherwise, the third argument will be displayed</p> <pre class="highlight handlebars " data-language="html">{{unless useLongGreeting "Hi" "Hello"}} Ben
</pre> <p>You can use the <code>unless</code> helper inside another helper as a subexpression.</p> <pre class="highlight handlebars " data-language="html">{{some-component height=(unless isBig "10" "100")}}
</pre> </div>    <h2 id="method_with">with<span class="args"> (options) </span><code class="type"><a href="http://emberjs.com/api/classes/String.html" target="_blank">String</a></code><span class="flag public">public</span>
</h2>    <p class="meta"> Defined in <a class="api-file-link" href="https://github.com/emberjs/ember.js/tree/v2.12.0/packages/ember-glimmer/lib/index.js#L79" target="_blank">packages/ember-glimmer/lib/index.js:79</a> </p> <div class="description"> <p>Use the <code>{{with}}</code> helper when you want to alias a property to a new name. This is helpful for semantic clarity as it allows you to retain default scope or to reference a property from another <code>{{with}}</code> block.</p> <p>If the aliased property is "falsey", for example: <code>false</code>, <code>undefined</code> <code>null</code>, <code>""</code>, <code>0</code>, NaN or an empty array, the block will not be rendered.</p> <pre class="highlight handlebars " data-language="html">{{! Will only render if user.posts contains items}}
{{#with user.posts as |blogPosts|}}
  &lt;div class="notice"&gt;
    There are {{blogPosts.length}} blog posts written by {{user.name}}.
  &lt;/div&gt;
  {{#each blogPosts as |post|}}
    &lt;li&gt;{{post.title}}&lt;/li&gt;
  {{/each}}
{{/with}}
</pre> <p>Without the <code>as</code> operator, it would be impossible to reference <code>user.name</code> in the example above.</p> <p>NOTE: The alias should not reuse a name from the bound property path.</p> <p>For example: <code>{{#with foo.bar as |foo|}}</code> is not supported because it attempts to alias using the first part of the property path, <code>foo</code>. Instead, use <code>{{#with foo.bar as |baz|}}</code>.</p> </div>  <div class="params"> <h3>Parameters:</h3> <dl> <dt>
<strong>options</strong> <code class="type">Object</code>
</dt>  </dl> </div> <div class="return"> <h3>Returns:</h3> <dl> <dt>
<code class="type"><a href="http://emberjs.com/api/classes/String.html" target="_blank">String</a></code> </dt>
<dd> HTML string</dd> </dl> </div>
<div class="_attribution">
  <p class="_attribution-p">
    © 2017 Yehuda Katz, Tom Dale and Ember.js contributors<br>Licensed under the MIT License.<br>
    <a href="http://emberjs.com/api/classes/Ember.Templates.helpers.html" class="_attribution-link" target="_blank">http://emberjs.com/api/classes/Ember.Templates.helpers.html</a>
  </p>
</div>

			</div>
		</div>
	</section>

	</div>
</body>
</html>
