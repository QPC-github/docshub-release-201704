
<!DOCTYPE HTML>

<html lang="en">

<head>
  <meta charset="utf-8">
  <title>Information Functions - PostgreSQL 9.5 - W3cubDocs</title>
  
  <meta name="description" content=" Table 9-57 shows several functions that extract session and system information. ">
  <meta name="keywords" content="system, information, functions, -, postgresql, postgresql~9.5">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="http://docs.w3cub.com/postgresql~9.5/functions-info/">
  <link href="/favicon.png" rel="icon">
  <link type="text/css" rel="stylesheet" href="/assets/application-50364fff564ce3b6327021805f3f00e2957b441cf27f576a7dd4ff63bbc47047.css">
  <script type="text/javascript" src="/assets/application-db64bfd54ceb42be11af7995804cf4902548419ceb79d509b0b7d62c22d98e6f.js"></script>
  <script src="/json/postgresql~9.5.js"></script>
  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-71174418-1']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>


</head>

<body>
	<div class="_app">
	<header class="_header">
  
  <form class="_search">
    <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
    <a class="_search-clear"></a>
    <div class="_search-tag"></div>
  </form>
  
  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/postgresql~9.5/" class="_nav-link" title="" style="margin-left:0;">PostgreSQL 9.5</a></span>
  
  <nav class="_nav">
    <a href="/app/" class="_nav-link ">App</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		<div class="_list">
			
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<div class="_page _postgres">
				
<h1 class="SECT1" id="FUNCTIONS-INFO">9.25. System Information Functions</h1> <p><a href="../functions-info/#FUNCTIONS-INFO-SESSION-TABLE">Table 9-57</a> shows several functions that extract session and system information.</p> <p>In addition to the functions listed in this section, there are a number of functions related to the statistics system that also provide system information. See <a href="../monitoring-stats/#MONITORING-STATS-VIEWS">Section 27.2.2</a> for more information.</p> <div class="TABLE" id="FUNCTIONS-INFO-SESSION-TABLE">  <p class="c2">Table 9-57. Session Information Functions</p> <table class="CALSTABLE"> <col> <col> <col> <thead> <tr> <th>Name</th> <th>Return Type</th> <th>Description</th> </tr> </thead> <tbody> <tr> <td><code class="LITERAL" id="current_catalog">current_catalog</code></td> <td><code class="TYPE">name</code></td> <td>name of current database (called <span class="QUOTE">"catalog"</span> in the SQL standard)</td> </tr> <tr> <td><code class="LITERAL" id="current_database">current_database()</code></td> <td><code class="TYPE">name</code></td> <td>name of current database</td> </tr> <tr> <td><code class="LITERAL" id="current_query">current_query()</code></td> <td><code class="TYPE">text</code></td> <td>text of the currently executing query, as submitted by the client (might contain more than one statement)</td> </tr> <tr> <td><code class="LITERAL" id="current_schema">current_schema[()]</code></td> <td><code class="TYPE">name</code></td> <td>name of current schema</td> </tr> <tr> <td><code class="LITERAL" id="current_schemas">current_schemas(<code class="TYPE">boolean</code>)</code></td> <td><code class="TYPE">name[]</code></td> <td>names of schemas in search path, optionally including implicit schemas</td> </tr> <tr> <td><code class="LITERAL" id="current_user">current_user</code></td> <td><code class="TYPE">name</code></td> <td>user name of current execution context</td> </tr> <tr> <td><code class="LITERAL" id="inet_client_addr">inet_client_addr()</code></td> <td><code class="TYPE">inet</code></td> <td>address of the remote connection</td> </tr> <tr> <td><code class="LITERAL" id="inet_client_port">inet_client_port()</code></td> <td><code class="TYPE">int</code></td> <td>port of the remote connection</td> </tr> <tr> <td><code class="LITERAL" id="inet_server_addr">inet_server_addr()</code></td> <td><code class="TYPE">inet</code></td> <td>address of the local connection</td> </tr> <tr> <td><code class="LITERAL" id="inet_server_port">inet_server_port()</code></td> <td><code class="TYPE">int</code></td> <td>port of the local connection</td> </tr> <tr> <td><code class="LITERAL" id="pg_backend_pid">pg_backend_pid()</code></td> <td><code class="TYPE">int</code></td> <td>Process ID of the server process attached to the current session</td> </tr> <tr> <td><code class="LITERAL" id="pg_conf_load_time">pg_conf_load_time()</code></td> <td><code class="TYPE">timestamp with time zone</code></td> <td>configuration load time</td> </tr> <tr> <td><code class="LITERAL" id="pg_is_other_temp_schema">pg_is_other_temp_schema(<code class="TYPE">oid</code>)</code></td> <td><code class="TYPE">boolean</code></td> <td>is schema another session's temporary schema?</td> </tr> <tr> <td><code class="LITERAL" id="pg_listening_channels">pg_listening_channels()</code></td> <td><code class="TYPE">setof text</code></td> <td>channel names that the session is currently listening on</td> </tr> <tr> <td><code class="LITERAL" id="pg_my_temp_schema">pg_my_temp_schema()</code></td> <td><code class="TYPE">oid</code></td> <td>OID of session's temporary schema, or 0 if none</td> </tr> <tr> <td><code class="LITERAL" id="pg_postmaster_start_time">pg_postmaster_start_time()</code></td> <td><code class="TYPE">timestamp with time zone</code></td> <td>server start time</td> </tr> <tr> <td><code class="LITERAL" id="pg_trigger_depth">pg_trigger_depth()</code></td> <td><code class="TYPE">int</code></td> <td>current nesting level of <span class="PRODUCTNAME">PostgreSQL</span> triggers (0 if not called, directly or indirectly, from inside a trigger)</td> </tr> <tr> <td><code class="LITERAL" id="session_user">session_user</code></td> <td><code class="TYPE">name</code></td> <td>session user name</td> </tr> <tr> <td><code class="LITERAL" id="user">user</code></td> <td><code class="TYPE">name</code></td> <td>equivalent to <code class="FUNCTION">current_user</code>
</td> </tr> <tr> <td><code class="LITERAL" id="version">version()</code></td> <td><code class="TYPE">text</code></td> <td>
<span class="PRODUCTNAME">PostgreSQL</span> version information. See also <a href="../runtime-config-preset/#GUC-SERVER-VERSION-NUM">server_version_num</a> for a machine-readable version.</td> </tr> </tbody> </table> </div>  <blockquote class="NOTE"> <p><b>Note:</b> <code class="FUNCTION">current_catalog</code>, <code class="FUNCTION">current_schema</code>, <code class="FUNCTION">current_user</code>, <code class="FUNCTION">session_user</code>, and <code class="FUNCTION">user</code> have special syntactic status in <acronym class="ACRONYM">SQL</acronym>: they must be called without trailing parentheses. (In PostgreSQL, parentheses can optionally be used with <code class="FUNCTION">current_schema</code>, but not with the others.)</p> </blockquote>  <p>The <code class="FUNCTION">session_user</code> is normally the user who initiated the current database connection; but superusers can change this setting with <a href="../sql-set-session-authorization/">SET SESSION AUTHORIZATION</a>. The <code class="FUNCTION">current_user</code> is the user identifier that is applicable for permission checking. Normally it is equal to the session user, but it can be changed with <a href="../sql-set-role/">SET ROLE</a>. It also changes during the execution of functions with the attribute <code class="LITERAL">SECURITY DEFINER</code>. In Unix parlance, the session user is the <span class="QUOTE">"real user"</span> and the current user is the <span class="QUOTE">"effective user"</span>.</p> <p><code class="FUNCTION">current_schema</code> returns the name of the schema that is first in the search path (or a null value if the search path is empty). This is the schema that will be used for any tables or other named objects that are created without specifying a target schema. <code class="FUNCTION">current_schemas(boolean)</code> returns an array of the names of all schemas presently in the search path. The Boolean option determines whether or not implicitly included system schemas such as <code class="LITERAL">pg_catalog</code> are included in the returned search path.</p>  <blockquote class="NOTE"> <p><b>Note:</b> The search path can be altered at run time. The command is:</p> <pre class="PROGRAMLISTING" data-language="sql">
SET search_path TO schema [, schema, ...]
</pre> </blockquote>  <p><code class="FUNCTION">pg_listening_channels</code> returns a set of names of channels that the current session is listening to. See <a href="../sql-listen/">LISTEN</a> for more information.</p> <p><code class="FUNCTION">inet_client_addr</code> returns the IP address of the current client, and <code class="FUNCTION">inet_client_port</code> returns the port number. <code class="FUNCTION">inet_server_addr</code> returns the IP address on which the server accepted the current connection, and <code class="FUNCTION">inet_server_port</code> returns the port number. All these functions return NULL if the current connection is via a Unix-domain socket.</p> <p><code class="FUNCTION">pg_my_temp_schema</code> returns the OID of the current session's temporary schema, or zero if it has none (because it has not created any temporary tables). <code class="FUNCTION">pg_is_other_temp_schema</code> returns true if the given OID is the OID of another session's temporary schema. (This can be useful, for example, to exclude other sessions' temporary tables from a catalog display.)</p> <p><code class="FUNCTION">pg_postmaster_start_time</code> returns the <code class="TYPE">timestamp with time zone</code> when the server started.</p> <p><code class="FUNCTION">pg_conf_load_time</code> returns the <code class="TYPE">timestamp with time zone</code> when the server configuration files were last loaded. (If the current session was alive at the time, this will be the time when the session itself re-read the configuration files, so the reading will vary a little in different sessions. Otherwise it is the time when the postmaster process re-read the configuration files.)</p> <p><code class="FUNCTION">version</code> returns a string describing the <span class="PRODUCTNAME">PostgreSQL</span> server's version. You can also get this information from <a href="../runtime-config-preset/#GUC-SERVER-VERSION">server_version</a> or for a machine-readable version, <a href="../runtime-config-preset/#GUC-SERVER-VERSION-NUM">server_version_num</a>. Software developers should use <code class="LITERAL">server_version_num</code> (available since 8.2) or <a class="TERM c4" href="https://www.postgresql.org/docs/9.5/static/libpq-status.html#LIBPQ-PQSERVERVERSION" target="_blank"><code class="FUNCTION">PQserverVersion</code></a> instead of parsing the text version.</p> <p><a href="../functions-info/#FUNCTIONS-INFO-ACCESS-TABLE">Table 9-58</a> lists functions that allow the user to query object access privileges programmatically. See <a href="../ddl-priv/">Section 5.6</a> for more information about privileges.</p> <div class="TABLE" id="FUNCTIONS-INFO-ACCESS-TABLE">  <p class="c2">Table 9-58. Access Privilege Inquiry Functions</p> <table class="CALSTABLE"> <col> <col> <col> <thead> <tr> <th>Name</th> <th>Return Type</th> <th>Description</th> </tr> </thead> <tbody> <tr> <td><code class="LITERAL" id="has_any_column_privilege">has_any_column_privilege(<code class="PARAMETER">user</code>, <code class="PARAMETER">table</code>, <code class="PARAMETER">privilege</code>)</code></td> <td><code class="TYPE">boolean</code></td> <td>does user have privilege for any column of table</td> </tr> <tr> <td><code class="LITERAL">has_any_column_privilege(<code class="PARAMETER">table</code>, <code class="PARAMETER">privilege</code>)</code></td> <td><code class="TYPE">boolean</code></td> <td>does current user have privilege for any column of table</td> </tr> <tr> <td><code class="LITERAL" id="has_column_privilege">has_column_privilege(<code class="PARAMETER">user</code>, <code class="PARAMETER">table</code>, <code class="PARAMETER">column</code>, <code class="PARAMETER">privilege</code>)</code></td> <td><code class="TYPE">boolean</code></td> <td>does user have privilege for column</td> </tr> <tr> <td><code class="LITERAL">has_column_privilege(<code class="PARAMETER">table</code>, <code class="PARAMETER">column</code>, <code class="PARAMETER">privilege</code>)</code></td> <td><code class="TYPE">boolean</code></td> <td>does current user have privilege for column</td> </tr> <tr> <td><code class="LITERAL" id="has_database_privilege">has_database_privilege(<code class="PARAMETER">user</code>, <code class="PARAMETER">database</code>, <code class="PARAMETER">privilege</code>)</code></td> <td><code class="TYPE">boolean</code></td> <td>does user have privilege for database</td> </tr> <tr> <td><code class="LITERAL">has_database_privilege(<code class="PARAMETER">database</code>, <code class="PARAMETER">privilege</code>)</code></td> <td><code class="TYPE">boolean</code></td> <td>does current user have privilege for database</td> </tr> <tr> <td><code class="LITERAL" id="has_foreign_data_wrapper_privilege">has_foreign_data_wrapper_privilege(<code class="PARAMETER">user</code>, <code class="PARAMETER">fdw</code>, <code class="PARAMETER">privilege</code>)</code></td> <td><code class="TYPE">boolean</code></td> <td>does user have privilege for foreign-data wrapper</td> </tr> <tr> <td><code class="LITERAL">has_foreign_data_wrapper_privilege(<code class="PARAMETER">fdw</code>, <code class="PARAMETER">privilege</code>)</code></td> <td><code class="TYPE">boolean</code></td> <td>does current user have privilege for foreign-data wrapper</td> </tr> <tr> <td><code class="LITERAL" id="has_function_privilege">has_function_privilege(<code class="PARAMETER">user</code>, <code class="PARAMETER">function</code>, <code class="PARAMETER">privilege</code>)</code></td> <td><code class="TYPE">boolean</code></td> <td>does user have privilege for function</td> </tr> <tr> <td><code class="LITERAL">has_function_privilege(<code class="PARAMETER">function</code>, <code class="PARAMETER">privilege</code>)</code></td> <td><code class="TYPE">boolean</code></td> <td>does current user have privilege for function</td> </tr> <tr> <td><code class="LITERAL" id="has_language_privilege">has_language_privilege(<code class="PARAMETER">user</code>, <code class="PARAMETER">language</code>, <code class="PARAMETER">privilege</code>)</code></td> <td><code class="TYPE">boolean</code></td> <td>does user have privilege for language</td> </tr> <tr> <td><code class="LITERAL">has_language_privilege(<code class="PARAMETER">language</code>, <code class="PARAMETER">privilege</code>)</code></td> <td><code class="TYPE">boolean</code></td> <td>does current user have privilege for language</td> </tr> <tr> <td><code class="LITERAL" id="has_schema_privilege">has_schema_privilege(<code class="PARAMETER">user</code>, <code class="PARAMETER">schema</code>, <code class="PARAMETER">privilege</code>)</code></td> <td><code class="TYPE">boolean</code></td> <td>does user have privilege for schema</td> </tr> <tr> <td><code class="LITERAL">has_schema_privilege(<code class="PARAMETER">schema</code>, <code class="PARAMETER">privilege</code>)</code></td> <td><code class="TYPE">boolean</code></td> <td>does current user have privilege for schema</td> </tr> <tr> <td><code class="LITERAL" id="has_sequence_privilege">has_sequence_privilege(<code class="PARAMETER">user</code>, <code class="PARAMETER">sequence</code>, <code class="PARAMETER">privilege</code>)</code></td> <td><code class="TYPE">boolean</code></td> <td>does user have privilege for sequence</td> </tr> <tr> <td><code class="LITERAL">has_sequence_privilege(<code class="PARAMETER">sequence</code>, <code class="PARAMETER">privilege</code>)</code></td> <td><code class="TYPE">boolean</code></td> <td>does current user have privilege for sequence</td> </tr> <tr> <td><code class="LITERAL" id="has_server_privilege">has_server_privilege(<code class="PARAMETER">user</code>, <code class="PARAMETER">server</code>, <code class="PARAMETER">privilege</code>)</code></td> <td><code class="TYPE">boolean</code></td> <td>does user have privilege for foreign server</td> </tr> <tr> <td><code class="LITERAL">has_server_privilege(<code class="PARAMETER">server</code>, <code class="PARAMETER">privilege</code>)</code></td> <td><code class="TYPE">boolean</code></td> <td>does current user have privilege for foreign server</td> </tr> <tr> <td><code class="LITERAL" id="has_table_privilege">has_table_privilege(<code class="PARAMETER">user</code>, <code class="PARAMETER">table</code>, <code class="PARAMETER">privilege</code>)</code></td> <td><code class="TYPE">boolean</code></td> <td>does user have privilege for table</td> </tr> <tr> <td><code class="LITERAL">has_table_privilege(<code class="PARAMETER">table</code>, <code class="PARAMETER">privilege</code>)</code></td> <td><code class="TYPE">boolean</code></td> <td>does current user have privilege for table</td> </tr> <tr> <td><code class="LITERAL" id="has_tablespace_privilege">has_tablespace_privilege(<code class="PARAMETER">user</code>, <code class="PARAMETER">tablespace</code>, <code class="PARAMETER">privilege</code>)</code></td> <td><code class="TYPE">boolean</code></td> <td>does user have privilege for tablespace</td> </tr> <tr> <td><code class="LITERAL">has_tablespace_privilege(<code class="PARAMETER">tablespace</code>, <code class="PARAMETER">privilege</code>)</code></td> <td><code class="TYPE">boolean</code></td> <td>does current user have privilege for tablespace</td> </tr> <tr> <td><code class="LITERAL" id="has_type_privilege">has_type_privilege(<code class="PARAMETER">user</code>, <code class="PARAMETER">type</code>, <code class="PARAMETER">privilege</code>)</code></td> <td><code class="TYPE">boolean</code></td> <td>does user have privilege for type</td> </tr> <tr> <td><code class="LITERAL">has_type_privilege(<code class="PARAMETER">type</code>, <code class="PARAMETER">privilege</code>)</code></td> <td><code class="TYPE">boolean</code></td> <td>does current user have privilege for type</td> </tr> <tr> <td><code class="LITERAL" id="pg_has_role">pg_has_role(<code class="PARAMETER">user</code>, <code class="PARAMETER">role</code>, <code class="PARAMETER">privilege</code>)</code></td> <td><code class="TYPE">boolean</code></td> <td>does user have privilege for role</td> </tr> <tr> <td><code class="LITERAL">pg_has_role(<code class="PARAMETER">role</code>, <code class="PARAMETER">privilege</code>)</code></td> <td><code class="TYPE">boolean</code></td> <td>does current user have privilege for role</td> </tr> <tr> <td><code class="LITERAL" id="row_security_active">row_security_active(<code class="PARAMETER">table</code>)</code></td> <td><code class="TYPE">boolean</code></td> <td>does current user have row level security active for table</td> </tr> </tbody> </table> </div> <p><code class="FUNCTION">has_table_privilege</code> checks whether a user can access a table in a particular way. The user can be specified by name, by OID (<code class="LITERAL">pg_authid.oid</code>), <code class="LITERAL">public</code> to indicate the PUBLIC pseudo-role, or if the argument is omitted <code class="FUNCTION">current_user</code> is assumed. The table can be specified by name or by OID. (Thus, there are actually six variants of <code class="FUNCTION">has_table_privilege</code>, which can be distinguished by the number and types of their arguments.) When specifying by name, the name can be schema-qualified if necessary. The desired access privilege type is specified by a text string, which must evaluate to one of the values <code class="LITERAL">SELECT</code>, <code class="LITERAL">INSERT</code>, <code class="LITERAL">UPDATE</code>, <code class="LITERAL">DELETE</code>, <code class="LITERAL">TRUNCATE</code>, <code class="LITERAL">REFERENCES</code>, or <code class="LITERAL">TRIGGER</code>. Optionally, <code class="LITERAL">WITH GRANT OPTION</code> can be added to a privilege type to test whether the privilege is held with grant option. Also, multiple privilege types can be listed separated by commas, in which case the result will be <code class="LITERAL">true</code> if any of the listed privileges is held. (Case of the privilege string is not significant, and extra whitespace is allowed between but not within privilege names.) Some examples:</p> <pre class="PROGRAMLISTING" data-language="sql">
SELECT has_table_privilege('myschema.mytable', 'select');
SELECT has_table_privilege('joe', 'mytable', 'INSERT, SELECT WITH GRANT OPTION');
</pre> <p><code class="FUNCTION">has_sequence_privilege</code> checks whether a user can access a sequence in a particular way. The possibilities for its arguments are analogous to <code class="FUNCTION">has_table_privilege</code>. The desired access privilege type must evaluate to one of <code class="LITERAL">USAGE</code>, <code class="LITERAL">SELECT</code>, or <code class="LITERAL">UPDATE</code>.</p> <p><code class="FUNCTION">has_any_column_privilege</code> checks whether a user can access any column of a table in a particular way. Its argument possibilities are analogous to <code class="FUNCTION">has_table_privilege</code>, except that the desired access privilege type must evaluate to some combination of <code class="LITERAL">SELECT</code>, <code class="LITERAL">INSERT</code>, <code class="LITERAL">UPDATE</code>, or <code class="LITERAL">REFERENCES</code>. Note that having any of these privileges at the table level implicitly grants it for each column of the table, so <code class="FUNCTION">has_any_column_privilege</code> will always return <code class="LITERAL">true</code> if <code class="FUNCTION">has_table_privilege</code> does for the same arguments. But <code class="FUNCTION">has_any_column_privilege</code> also succeeds if there is a column-level grant of the privilege for at least one column.</p> <p><code class="FUNCTION">has_column_privilege</code> checks whether a user can access a column in a particular way. Its argument possibilities are analogous to <code class="FUNCTION">has_table_privilege</code>, with the addition that the column can be specified either by name or attribute number. The desired access privilege type must evaluate to some combination of <code class="LITERAL">SELECT</code>, <code class="LITERAL">INSERT</code>, <code class="LITERAL">UPDATE</code>, or <code class="LITERAL">REFERENCES</code>. Note that having any of these privileges at the table level implicitly grants it for each column of the table.</p> <p><code class="FUNCTION">has_database_privilege</code> checks whether a user can access a database in a particular way. Its argument possibilities are analogous to <code class="FUNCTION">has_table_privilege</code>. The desired access privilege type must evaluate to some combination of <code class="LITERAL">CREATE</code>, <code class="LITERAL">CONNECT</code>, <code class="LITERAL">TEMPORARY</code>, or <code class="LITERAL">TEMP</code> (which is equivalent to <code class="LITERAL">TEMPORARY</code>).</p> <p><code class="FUNCTION">has_function_privilege</code> checks whether a user can access a function in a particular way. Its argument possibilities are analogous to <code class="FUNCTION">has_table_privilege</code>. When specifying a function by a text string rather than by OID, the allowed input is the same as for the <code class="TYPE">regprocedure</code> data type (see <a href="../datatype-oid/">Section 8.18</a>). The desired access privilege type must evaluate to <code class="LITERAL">EXECUTE</code>. An example is:</p> <pre class="PROGRAMLISTING" data-language="sql">
SELECT has_function_privilege('joeuser', 'myfunc(int, text)', 'execute');
</pre> <p><code class="FUNCTION">has_foreign_data_wrapper_privilege</code> checks whether a user can access a foreign-data wrapper in a particular way. Its argument possibilities are analogous to <code class="FUNCTION">has_table_privilege</code>. The desired access privilege type must evaluate to <code class="LITERAL">USAGE</code>.</p> <p><code class="FUNCTION">has_language_privilege</code> checks whether a user can access a procedural language in a particular way. Its argument possibilities are analogous to <code class="FUNCTION">has_table_privilege</code>. The desired access privilege type must evaluate to <code class="LITERAL">USAGE</code>.</p> <p><code class="FUNCTION">has_schema_privilege</code> checks whether a user can access a schema in a particular way. Its argument possibilities are analogous to <code class="FUNCTION">has_table_privilege</code>. The desired access privilege type must evaluate to some combination of <code class="LITERAL">CREATE</code> or <code class="LITERAL">USAGE</code>.</p> <p><code class="FUNCTION">has_server_privilege</code> checks whether a user can access a foreign server in a particular way. Its argument possibilities are analogous to <code class="FUNCTION">has_table_privilege</code>. The desired access privilege type must evaluate to <code class="LITERAL">USAGE</code>.</p> <p><code class="FUNCTION">has_tablespace_privilege</code> checks whether a user can access a tablespace in a particular way. Its argument possibilities are analogous to <code class="FUNCTION">has_table_privilege</code>. The desired access privilege type must evaluate to <code class="LITERAL">CREATE</code>.</p> <p><code class="FUNCTION">has_type_privilege</code> checks whether a user can access a type in a particular way. Its argument possibilities are analogous to <code class="FUNCTION">has_table_privilege</code>. When specifying a type by a text string rather than by OID, the allowed input is the same as for the <code class="TYPE">regtype</code> data type (see <a href="../datatype-oid/">Section 8.18</a>). The desired access privilege type must evaluate to <code class="LITERAL">USAGE</code>.</p> <p><code class="FUNCTION">pg_has_role</code> checks whether a user can access a role in a particular way. Its argument possibilities are analogous to <code class="FUNCTION">has_table_privilege</code>, except that <code class="LITERAL">public</code> is not allowed as a user name. The desired access privilege type must evaluate to some combination of <code class="LITERAL">MEMBER</code> or <code class="LITERAL">USAGE</code>. <code class="LITERAL">MEMBER</code> denotes direct or indirect membership in the role (that is, the right to do <code class="COMMAND">SET ROLE</code>), while <code class="LITERAL">USAGE</code> denotes whether the privileges of the role are immediately available without doing <code class="COMMAND">SET ROLE</code>.</p> <p><code class="FUNCTION">row_security_active</code> checks whether row level security is active for the specified table in the context of the <code class="FUNCTION">current_user</code> and environment. The table can be specified by name or by OID.</p> <p><a href="../functions-info/#FUNCTIONS-INFO-SCHEMA-TABLE">Table 9-59</a> shows functions that determine whether a certain object is <i class="FIRSTTERM">visible</i> in the current schema search path. For example, a table is said to be visible if its containing schema is in the search path and no table of the same name appears earlier in the search path. This is equivalent to the statement that the table can be referenced by name without explicit schema qualification. To list the names of all visible tables:</p> <pre class="PROGRAMLISTING" data-language="sql">
SELECT relname FROM pg_class WHERE pg_table_is_visible(oid);
</pre> <div class="TABLE" id="FUNCTIONS-INFO-SCHEMA-TABLE">  <p class="c2">Table 9-59. Schema Visibility Inquiry Functions</p> <table class="CALSTABLE"> <col> <col> <col> <thead> <tr> <th>Name</th> <th>Return Type</th> <th>Description</th> </tr> </thead> <tbody> <tr> <td><code class="LITERAL" id="pg_collation_is_visible">pg_collation_is_visible(<code class="PARAMETER">collation_oid</code>)</code></td> <td><code class="TYPE">boolean</code></td> <td>is collation visible in search path</td> </tr> <tr> <td><code class="LITERAL" id="pg_conversion_is_visible">pg_conversion_is_visible(<code class="PARAMETER">conversion_oid</code>)</code></td> <td><code class="TYPE">boolean</code></td> <td>is conversion visible in search path</td> </tr> <tr> <td><code class="LITERAL" id="pg_function_is_visible">pg_function_is_visible(<code class="PARAMETER">function_oid</code>)</code></td> <td><code class="TYPE">boolean</code></td> <td>is function visible in search path</td> </tr> <tr> <td><code class="LITERAL" id="pg_opclass_is_visible">pg_opclass_is_visible(<code class="PARAMETER">opclass_oid</code>)</code></td> <td><code class="TYPE">boolean</code></td> <td>is operator class visible in search path</td> </tr> <tr> <td><code class="LITERAL" id="pg_operator_is_visible">pg_operator_is_visible(<code class="PARAMETER">operator_oid</code>)</code></td> <td><code class="TYPE">boolean</code></td> <td>is operator visible in search path</td> </tr> <tr> <td><code class="LITERAL" id="pg_opfamily_is_visible">pg_opfamily_is_visible(<code class="PARAMETER">opclass_oid</code>)</code></td> <td><code class="TYPE">boolean</code></td> <td>is operator family visible in search path</td> </tr> <tr> <td><code class="LITERAL" id="pg_table_is_visible">pg_table_is_visible(<code class="PARAMETER">table_oid</code>)</code></td> <td><code class="TYPE">boolean</code></td> <td>is table visible in search path</td> </tr> <tr> <td><code class="LITERAL" id="pg_ts_config_is_visible">pg_ts_config_is_visible(<code class="PARAMETER">config_oid</code>)</code></td> <td><code class="TYPE">boolean</code></td> <td>is text search configuration visible in search path</td> </tr> <tr> <td><code class="LITERAL" id="pg_ts_dict_is_visible">pg_ts_dict_is_visible(<code class="PARAMETER">dict_oid</code>)</code></td> <td><code class="TYPE">boolean</code></td> <td>is text search dictionary visible in search path</td> </tr> <tr> <td><code class="LITERAL" id="pg_ts_parser_is_visible">pg_ts_parser_is_visible(<code class="PARAMETER">parser_oid</code>)</code></td> <td><code class="TYPE">boolean</code></td> <td>is text search parser visible in search path</td> </tr> <tr> <td><code class="LITERAL" id="pg_ts_template_is_visible">pg_ts_template_is_visible(<code class="PARAMETER">template_oid</code>)</code></td> <td><code class="TYPE">boolean</code></td> <td>is text search template visible in search path</td> </tr> <tr> <td><code class="LITERAL" id="pg_type_is_visible">pg_type_is_visible(<code class="PARAMETER">type_oid</code>)</code></td> <td><code class="TYPE">boolean</code></td> <td>is type (or domain) visible in search path</td> </tr> </tbody> </table> </div> <p>Each function performs the visibility check for one type of database object. Note that <code class="FUNCTION">pg_table_is_visible</code> can also be used with views, materialized views, indexes, sequences and foreign tables; <code class="FUNCTION">pg_type_is_visible</code> can also be used with domains. For functions and operators, an object in the search path is visible if there is no object of the same name <span class="emphasis EMPHASIS c5">and argument data type(s)</span> earlier in the path. For operator classes, both name and associated index access method are considered.</p> <p>All these functions require object OIDs to identify the object to be checked. If you want to test an object by name, it is convenient to use the OID alias types (<code class="TYPE">regclass</code>, <code class="TYPE">regtype</code>, <code class="TYPE">regprocedure</code>, <code class="TYPE">regoperator</code>, <code class="TYPE">regconfig</code>, or <code class="TYPE">regdictionary</code>), for example:</p> <pre class="PROGRAMLISTING" data-language="sql">
SELECT pg_type_is_visible('myschema.widget'::regtype);
</pre> <p>Note that it would not make much sense to test a non-schema-qualified type name in this way — if the name can be recognized at all, it must be visible.</p> <p><a href="../functions-info/#FUNCTIONS-INFO-CATALOG-TABLE">Table 9-60</a> lists functions that extract information from the system catalogs.</p> <div class="TABLE" id="FUNCTIONS-INFO-CATALOG-TABLE">  <p class="c2">Table 9-60. System Catalog Information Functions</p> <table class="CALSTABLE"> <col> <col> <col> <thead> <tr> <th>Name</th> <th>Return Type</th> <th>Description</th> </tr> </thead> <tbody> <tr> <td><code class="LITERAL" id="format_type">format_type(<code class="PARAMETER">type_oid</code>, <code class="PARAMETER">typemod</code>)</code></td> <td><code class="TYPE">text</code></td> <td>get SQL name of a data type</td> </tr> <tr> <td><code class="LITERAL" id="pg_get_constraintdef">pg_get_constraintdef(<code class="PARAMETER">constraint_oid</code>)</code></td> <td><code class="TYPE">text</code></td> <td>get definition of a constraint</td> </tr> <tr> <td><code class="LITERAL">pg_get_constraintdef(<code class="PARAMETER">constraint_oid</code>, <code class="PARAMETER">pretty_bool</code>)</code></td> <td><code class="TYPE">text</code></td> <td>get definition of a constraint</td> </tr> <tr> <td><code class="LITERAL" id="pg_get_expr">pg_get_expr(<code class="PARAMETER">pg_node_tree</code>, <code class="PARAMETER">relation_oid</code>)</code></td> <td><code class="TYPE">text</code></td> <td>decompile internal form of an expression, assuming that any Vars in it refer to the relation indicated by the second parameter</td> </tr> <tr> <td><code class="LITERAL">pg_get_expr(<code class="PARAMETER">pg_node_tree</code>, <code class="PARAMETER">relation_oid</code>, <code class="PARAMETER">pretty_bool</code>)</code></td> <td><code class="TYPE">text</code></td> <td>decompile internal form of an expression, assuming that any Vars in it refer to the relation indicated by the second parameter</td> </tr> <tr> <td><code class="LITERAL" id="pg_get_functiondef">pg_get_functiondef(<code class="PARAMETER">func_oid</code>)</code></td> <td><code class="TYPE">text</code></td> <td>get definition of a function</td> </tr> <tr> <td><code class="LITERAL" id="pg_get_function_arguments">pg_get_function_arguments(<code class="PARAMETER">func_oid</code>)</code></td> <td><code class="TYPE">text</code></td> <td>get argument list of function's definition (with default values)</td> </tr> <tr> <td><code class="LITERAL" id="pg_get_function_identity_arguments">pg_get_function_identity_arguments(<code class="PARAMETER">func_oid</code>)</code></td> <td><code class="TYPE">text</code></td> <td>get argument list to identify a function (without default values)</td> </tr> <tr> <td><code class="LITERAL" id="pg_get_function_result">pg_get_function_result(<code class="PARAMETER">func_oid</code>)</code></td> <td><code class="TYPE">text</code></td> <td>get <code class="LITERAL">RETURNS</code> clause for function</td> </tr> <tr> <td><code class="LITERAL" id="pg_get_indexdef">pg_get_indexdef(<code class="PARAMETER">index_oid</code>)</code></td> <td><code class="TYPE">text</code></td> <td>get <code class="COMMAND">CREATE INDEX</code> command for index</td> </tr> <tr> <td><code class="LITERAL">pg_get_indexdef(<code class="PARAMETER">index_oid</code>, <code class="PARAMETER">column_no</code>, <code class="PARAMETER">pretty_bool</code>)</code></td> <td><code class="TYPE">text</code></td> <td>get <code class="COMMAND">CREATE INDEX</code> command for index, or definition of just one index column when <code class="PARAMETER">column_no</code> is not zero</td> </tr> <tr> <td><code class="LITERAL" id="pg_get_keywords">pg_get_keywords()</code></td> <td><code class="TYPE">setof record</code></td> <td>get list of SQL keywords and their categories</td> </tr> <tr> <td><code class="LITERAL" id="pg_get_ruledef">pg_get_ruledef(<code class="PARAMETER">rule_oid</code>)</code></td> <td><code class="TYPE">text</code></td> <td>get <code class="COMMAND">CREATE RULE</code> command for rule</td> </tr> <tr> <td><code class="LITERAL">pg_get_ruledef(<code class="PARAMETER">rule_oid</code>, <code class="PARAMETER">pretty_bool</code>)</code></td> <td><code class="TYPE">text</code></td> <td>get <code class="COMMAND">CREATE RULE</code> command for rule</td> </tr> <tr> <td><code class="LITERAL" id="pg_get_serial_sequence">pg_get_serial_sequence(<code class="PARAMETER">table_name</code>, <code class="PARAMETER">column_name</code>)</code></td> <td><code class="TYPE">text</code></td> <td>get name of the sequence that a <code class="TYPE">serial</code>, <code class="TYPE">smallserial</code> or <code class="TYPE">bigserial</code> column uses</td> </tr> <tr> <td>
<code class="FUNCTION" id="pg_get_triggerdef">pg_get_triggerdef</code>(<code class="PARAMETER">trigger_oid</code>)</td> <td><code class="TYPE">text</code></td> <td>get <code class="COMMAND">CREATE [ CONSTRAINT ] TRIGGER</code> command for trigger</td> </tr> <tr> <td>
<code class="FUNCTION">pg_get_triggerdef</code>(<code class="PARAMETER">trigger_oid</code>, <code class="PARAMETER">pretty_bool</code>)</td> <td><code class="TYPE">text</code></td> <td>get <code class="COMMAND">CREATE [ CONSTRAINT ] TRIGGER</code> command for trigger</td> </tr> <tr> <td><code class="LITERAL" id="pg_get_userbyid">pg_get_userbyid(<code class="PARAMETER">role_oid</code>)</code></td> <td><code class="TYPE">name</code></td> <td>get role name with given OID</td> </tr> <tr> <td><code class="LITERAL" id="pg_get_viewdef">pg_get_viewdef(<code class="PARAMETER">view_name</code>)</code></td> <td><code class="TYPE">text</code></td> <td>get underlying <code class="COMMAND">SELECT</code> command for view or materialized view (<span class="emphasis EMPHASIS c5">deprecated</span>)</td> </tr> <tr> <td><code class="LITERAL">pg_get_viewdef(<code class="PARAMETER">view_name</code>, <code class="PARAMETER">pretty_bool</code>)</code></td> <td><code class="TYPE">text</code></td> <td>get underlying <code class="COMMAND">SELECT</code> command for view or materialized view (<span class="emphasis EMPHASIS c5">deprecated</span>)</td> </tr> <tr> <td><code class="LITERAL">pg_get_viewdef(<code class="PARAMETER">view_oid</code>)</code></td> <td><code class="TYPE">text</code></td> <td>get underlying <code class="COMMAND">SELECT</code> command for view or materialized view</td> </tr> <tr> <td><code class="LITERAL">pg_get_viewdef(<code class="PARAMETER">view_oid</code>, <code class="PARAMETER">pretty_bool</code>)</code></td> <td><code class="TYPE">text</code></td> <td>get underlying <code class="COMMAND">SELECT</code> command for view or materialized view</td> </tr> <tr> <td><code class="LITERAL">pg_get_viewdef(<code class="PARAMETER">view_oid</code>, <code class="PARAMETER">wrap_column_int</code>)</code></td> <td><code class="TYPE">text</code></td> <td>get underlying <code class="COMMAND">SELECT</code> command for view or materialized view; lines with fields are wrapped to specified number of columns, pretty-printing is implied</td> </tr> <tr> <td><code class="LITERAL" id="pg_options_to_table">pg_options_to_table(<code class="PARAMETER">reloptions</code>)</code></td> <td><code class="TYPE">setof record</code></td> <td>get the set of storage option name/value pairs</td> </tr> <tr> <td><code class="LITERAL" id="pg_tablespace_databases">pg_tablespace_databases(<code class="PARAMETER">tablespace_oid</code>)</code></td> <td><code class="TYPE">setof oid</code></td> <td>get the set of database OIDs that have objects in the tablespace</td> </tr> <tr> <td><code class="LITERAL" id="pg_tablespace_location">pg_tablespace_location(<code class="PARAMETER">tablespace_oid</code>)</code></td> <td><code class="TYPE">text</code></td> <td>get the path in the file system that this tablespace is located in</td> </tr> <tr> <td><code class="LITERAL" id="pg_typeof">pg_typeof(<code class="PARAMETER">any</code>)</code></td> <td><code class="TYPE">regtype</code></td> <td>get the data type of any value</td> </tr> <tr> <td><code class="LITERAL" id="collation1032for32">collation
          for (<code class="PARAMETER">any</code>)</code></td> <td><code class="TYPE">text</code></td> <td>get the collation of the argument</td> </tr> <tr> <td><code class="LITERAL" id="to_regclass">to_regclass(<code class="PARAMETER">rel_name</code>)</code></td> <td><code class="TYPE">regclass</code></td> <td>get the OID of the named relation</td> </tr> <tr> <td><code class="LITERAL" id="to_regproc">to_regproc(<code class="PARAMETER">func_name</code>)</code></td> <td><code class="TYPE">regproc</code></td> <td>get the OID of the named function</td> </tr> <tr> <td><code class="LITERAL" id="to_regprocedure">to_regprocedure(<code class="PARAMETER">func_name</code>)</code></td> <td><code class="TYPE">regprocedure</code></td> <td>get the OID of the named function</td> </tr> <tr> <td><code class="LITERAL" id="to_regoper">to_regoper(<code class="PARAMETER">operator_name</code>)</code></td> <td><code class="TYPE">regoper</code></td> <td>get the OID of the named operator</td> </tr> <tr> <td><code class="LITERAL" id="to_regoperator">to_regoperator(<code class="PARAMETER">operator_name</code>)</code></td> <td><code class="TYPE">regoperator</code></td> <td>get the OID of the named operator</td> </tr> <tr> <td><code class="LITERAL" id="to_regtype">to_regtype(<code class="PARAMETER">type_name</code>)</code></td> <td><code class="TYPE">regtype</code></td> <td>get the OID of the named type</td> </tr> <tr> <td><code class="LITERAL" id="to_regnamespace">to_regnamespace(<code class="PARAMETER">schema_name</code>)</code></td> <td><code class="TYPE">regnamespace</code></td> <td>get the OID of the named schema</td> </tr> <tr> <td><code class="LITERAL" id="to_regrole">to_regrole(<code class="PARAMETER">role_name</code>)</code></td> <td><code class="TYPE">regrole</code></td> <td>get the OID of the named role</td> </tr> </tbody> </table> </div> <p><code class="FUNCTION">format_type</code> returns the SQL name of a data type that is identified by its type OID and possibly a type modifier. Pass NULL for the type modifier if no specific modifier is known.</p> <p><code class="FUNCTION">pg_get_keywords</code> returns a set of records describing the SQL keywords recognized by the server. The <code class="STRUCTFIELD">word</code> column contains the keyword. The <code class="STRUCTFIELD">catcode</code> column contains a category code: <code class="LITERAL">U</code> for unreserved, <code class="LITERAL">C</code> for column name, <code class="LITERAL">T</code> for type or function name, or <code class="LITERAL">R</code> for reserved. The <code class="STRUCTFIELD">catdesc</code> column contains a possibly-localized string describing the category.</p> <p><code class="FUNCTION">pg_get_constraintdef</code>, <code class="FUNCTION">pg_get_indexdef</code>, <code class="FUNCTION">pg_get_ruledef</code>, and <code class="FUNCTION">pg_get_triggerdef</code>, respectively reconstruct the creating command for a constraint, index, rule, or trigger. (Note that this is a decompiled reconstruction, not the original text of the command.) <code class="FUNCTION">pg_get_expr</code> decompiles the internal form of an individual expression, such as the default value for a column. It can be useful when examining the contents of system catalogs. If the expression might contain Vars, specify the OID of the relation they refer to as the second parameter; if no Vars are expected, zero is sufficient. <code class="FUNCTION">pg_get_viewdef</code> reconstructs the <code class="COMMAND">SELECT</code> query that defines a view. Most of these functions come in two variants, one of which can optionally <span class="QUOTE">"pretty-print"</span> the result. The pretty-printed format is more readable, but the default format is more likely to be interpreted the same way by future versions of <span class="PRODUCTNAME">PostgreSQL</span>; avoid using pretty-printed output for dump purposes. Passing <code class="LITERAL">false</code> for the pretty-print parameter yields the same result as the variant that does not have the parameter at all.</p> <p><code class="FUNCTION">pg_get_functiondef</code> returns a complete <code class="COMMAND">CREATE OR REPLACE FUNCTION</code> statement for a function. <code class="FUNCTION">pg_get_function_arguments</code> returns the argument list of a function, in the form it would need to appear in within <code class="COMMAND">CREATE FUNCTION</code>. <code class="FUNCTION">pg_get_function_result</code> similarly returns the appropriate <code class="LITERAL">RETURNS</code> clause for the function. <code class="FUNCTION">pg_get_function_identity_arguments</code> returns the argument list necessary to identify a function, in the form it would need to appear in within <code class="COMMAND">ALTER FUNCTION</code>, for instance. This form omits default values.</p> <p><code class="FUNCTION">pg_get_serial_sequence</code> returns the name of the sequence associated with a column, or NULL if no sequence is associated with the column. The first input parameter is a table name with optional schema, and the second parameter is a column name. Because the first parameter is potentially a schema and table, it is not treated as a double-quoted identifier, meaning it is lower cased by default, while the second parameter, being just a column name, is treated as double-quoted and has its case preserved. The function returns a value suitably formatted for passing to sequence functions (see <a href="../functions-sequence/">Section 9.16</a>). This association can be modified or removed with <code class="COMMAND">ALTER SEQUENCE OWNED BY</code>. (The function probably should have been called <code class="FUNCTION">pg_get_owned_sequence</code>; its current name reflects the fact that it's typically used with <code class="TYPE">serial</code> or <code class="TYPE">bigserial</code> columns.)</p> <p><code class="FUNCTION">pg_get_userbyid</code> extracts a role's name given its OID.</p> <p><code class="FUNCTION">pg_options_to_table</code> returns the set of storage option name/value pairs (<code class="LITERAL">option_name</code>/<code class="LITERAL">option_value</code>) when passed <code class="STRUCTNAME">pg_class</code>.<code class="STRUCTFIELD">reloptions</code> or <code class="STRUCTNAME">pg_attribute</code>.<code class="STRUCTFIELD">attoptions</code>.</p> <p><code class="FUNCTION">pg_tablespace_databases</code> allows a tablespace to be examined. It returns the set of OIDs of databases that have objects stored in the tablespace. If this function returns any rows, the tablespace is not empty and cannot be dropped. To display the specific objects populating the tablespace, you will need to connect to the databases identified by <code class="FUNCTION">pg_tablespace_databases</code> and query their <code class="STRUCTNAME">pg_class</code> catalogs.</p> <p><code class="FUNCTION">pg_typeof</code> returns the OID of the data type of the value that is passed to it. This can be helpful for troubleshooting or dynamically constructing SQL queries. The function is declared as returning <code class="TYPE">regtype</code>, which is an OID alias type (see <a href="../datatype-oid/">Section 8.18</a>); this means that it is the same as an OID for comparison purposes but displays as a type name. For example:</p> <pre class="PROGRAMLISTING" data-language="sql">
SELECT pg_typeof(33);

 pg_typeof 
-----------
 integer
(1 row)

SELECT typlen FROM pg_type WHERE oid = pg_typeof(33);
 typlen 
--------
      4
(1 row)
</pre> <p>The expression <code class="LITERAL">collation for</code> returns the collation of the value that is passed to it. Example:</p> <pre class="PROGRAMLISTING" data-language="sql">
SELECT collation for (description) FROM pg_description LIMIT 1;
 pg_collation_for 
------------------
 "default"
(1 row)

SELECT collation for ('foo' COLLATE "de_DE");
 pg_collation_for 
------------------
 "de_DE"
(1 row)
</pre> <p>The value might be quoted and schema-qualified. If no collation is derived for the argument expression, then a null value is returned. If the argument is not of a collatable data type, then an error is raised.</p> <p>The <code class="FUNCTION">to_regclass</code>, <code class="FUNCTION">to_regproc</code>, <code class="FUNCTION">to_regprocedure</code>, <code class="FUNCTION">to_regoper</code>, <code class="FUNCTION">to_regoperator</code>, <code class="FUNCTION">to_regtype</code>, <code class="FUNCTION">to_regnamespace</code>, and <code class="FUNCTION">to_regrole</code> functions translate relation, function, operator, type, schema, and role names to objects of type <code class="TYPE">regclass</code>, <code class="TYPE">regproc</code>, <code class="TYPE">regprocedure</code>, <code class="TYPE">regoper</code>, <code class="TYPE">regoperator</code>, <code class="TYPE">regtype</code>, <code class="TYPE">regnamespace</code>, and <code class="TYPE">regrole</code> respectively. These functions differ from a cast from text in that they don't accept a numeric OID, and that they return null rather than throwing an error if the name is not found (or, for <code class="FUNCTION">to_regproc</code> and <code class="FUNCTION">to_regoper</code>, if the given name matches multiple objects).</p> <p><a href="../functions-info/#FUNCTIONS-INFO-OBJECT-TABLE">Table 9-61</a> lists functions related to database object identification and addressing.</p> <div class="TABLE" id="FUNCTIONS-INFO-OBJECT-TABLE">  <p class="c2">Table 9-61. Object Information and Addressing Functions</p> <table class="CALSTABLE"> <col> <col> <col> <thead> <tr> <th>Name</th> <th>Return Type</th> <th>Description</th> </tr> </thead> <tbody> <tr> <td><code class="LITERAL" id="pg_describe_object">pg_describe_object(<code class="PARAMETER">catalog_id</code>, <code class="PARAMETER">object_id</code>, <code class="PARAMETER">object_sub_id</code>)</code></td> <td><code class="TYPE">text</code></td> <td>get description of a database object</td> </tr> <tr> <td><code class="LITERAL" id="pg_identify_object">pg_identify_object(<code class="PARAMETER">catalog_id</code> <code class="TYPE">oid</code>,
          <code class="PARAMETER">object_id</code> <code class="TYPE">oid</code>, <code class="PARAMETER">object_sub_id</code>
          <code class="TYPE">integer</code>)</code></td> <td>
<code class="PARAMETER">type</code> <code class="TYPE">text</code>, <code class="PARAMETER">schema</code> <code class="TYPE">text</code>, <code class="PARAMETER">name</code> <code class="TYPE">text</code>, <code class="PARAMETER">identity</code> <code class="TYPE">text</code>
</td> <td>get identity of a database object</td> </tr> <tr> <td><code class="LITERAL" id="pg_identify_object_as_address">pg_identify_object_as_address(<code class="PARAMETER">catalog_id</code> <code class="TYPE">oid</code>,
          <code class="PARAMETER">object_id</code> <code class="TYPE">oid</code>, <code class="PARAMETER">object_sub_id</code>
          <code class="TYPE">integer</code>)</code></td> <td>
<code class="PARAMETER">type</code> <code class="TYPE">text</code>, <code class="PARAMETER">name</code> <code class="TYPE">text[]</code>, <code class="PARAMETER">args</code> <code class="TYPE">text[]</code>
</td> <td>get external representation of a database object's address</td> </tr> <tr> <td><code class="LITERAL" id="pg_get_object_address">pg_get_object_address(<code class="PARAMETER">type</code> <code class="TYPE">text</code>,
          <code class="PARAMETER">name</code> <code class="TYPE">text[]</code>, <code class="PARAMETER">args</code>
          <code class="TYPE">text[]</code>)</code></td> <td>
<code class="PARAMETER">catalog_id</code> <code class="TYPE">oid</code>, <code class="PARAMETER">object_id</code> <code class="TYPE">oid</code>, <code class="PARAMETER">object_sub_id</code> <code class="TYPE">int32</code>
</td> <td>get address of a database object, from its external representation</td> </tr> </tbody> </table> </div> <p><code class="FUNCTION">pg_describe_object</code> returns a textual description of a database object specified by catalog OID, object OID and a (possibly zero) sub-object ID. This description is intended to be human-readable, and might be translated, depending on server configuration. This is useful to determine the identity of an object as stored in the <code class="STRUCTNAME">pg_depend</code> catalog.</p> <p><code class="FUNCTION">pg_identify_object</code> returns a row containing enough information to uniquely identify the database object specified by catalog OID, object OID and a (possibly zero) sub-object ID. This information is intended to be machine-readable, and is never translated. <code class="PARAMETER">type</code> identifies the type of database object; <code class="PARAMETER">schema</code> is the schema name that the object belongs in, or <code class="LITERAL">NULL</code> for object types that do not belong to schemas; <code class="PARAMETER">name</code> is the name of the object, quoted if necessary, only present if it can be used (alongside schema name, if pertinent) as a unique identifier of the object, otherwise <code class="LITERAL">NULL</code>; <code class="PARAMETER">identity</code> is the complete object identity, with the precise format depending on object type, and each part within the format being schema-qualified and quoted as necessary.</p> <p><code class="FUNCTION">pg_identify_object_as_address</code> returns a row containing enough information to uniquely identify the database object specified by catalog OID, object OID and a (possibly zero) sub-object ID. The returned information is independent of the current server, that is, it could be used to identify an identically named object in another server. <code class="PARAMETER">type</code> identifies the type of database object; <code class="PARAMETER">name</code> and <code class="PARAMETER">args</code> are text arrays that together form a reference to the object. These three columns can be passed to <code class="FUNCTION">pg_get_object_address</code> to obtain the internal address of the object. This function is the inverse of <code class="FUNCTION">pg_get_object_address</code>.</p> <p><code class="FUNCTION">pg_get_object_address</code> returns a row containing enough information to uniquely identify the database object specified by its type and object name and argument arrays. The returned values are the ones that would be used in system catalogs such as <code class="STRUCTNAME">pg_depend</code> and can be passed to other system functions such as <code class="FUNCTION">pg_identify_object</code> or <code class="FUNCTION">pg_describe_object</code>. <code class="PARAMETER">catalog_id</code> is the OID of the system catalog containing the object; <code class="PARAMETER">object_id</code> is the OID of the object itself, and <code class="PARAMETER">object_sub_id</code> is the object sub-ID, or zero if none. This function is the inverse of <code class="FUNCTION">pg_identify_object_as_address</code>.</p> <p>The functions shown in <a href="../functions-info/#FUNCTIONS-INFO-COMMENT-TABLE">Table 9-62</a> extract comments previously stored with the <a href="../sql-comment/">COMMENT</a> command. A null value is returned if no comment could be found for the specified parameters.</p> <div class="TABLE" id="FUNCTIONS-INFO-COMMENT-TABLE">  <p class="c2">Table 9-62. Comment Information Functions</p> <table class="CALSTABLE"> <col> <col> <col> <thead> <tr> <th>Name</th> <th>Return Type</th> <th>Description</th> </tr> </thead> <tbody> <tr> <td><code class="LITERAL" id="col_description">col_description(<code class="PARAMETER">table_oid</code>, <code class="PARAMETER">column_number</code>)</code></td> <td><code class="TYPE">text</code></td> <td>get comment for a table column</td> </tr> <tr> <td><code class="LITERAL" id="obj_description">obj_description(<code class="PARAMETER">object_oid</code>, <code class="PARAMETER">catalog_name</code>)</code></td> <td><code class="TYPE">text</code></td> <td>get comment for a database object</td> </tr> <tr> <td><code class="LITERAL">obj_description(<code class="PARAMETER">object_oid</code>)</code></td> <td><code class="TYPE">text</code></td> <td>get comment for a database object (<span class="emphasis EMPHASIS c5">deprecated</span>)</td> </tr> <tr> <td><code class="LITERAL" id="shobj_description">shobj_description(<code class="PARAMETER">object_oid</code>, <code class="PARAMETER">catalog_name</code>)</code></td> <td><code class="TYPE">text</code></td> <td>get comment for a shared database object</td> </tr> </tbody> </table> </div> <p><code class="FUNCTION">col_description</code> returns the comment for a table column, which is specified by the OID of its table and its column number. (<code class="FUNCTION">obj_description</code> cannot be used for table columns since columns do not have OIDs of their own.)</p> <p>The two-parameter form of <code class="FUNCTION">obj_description</code> returns the comment for a database object specified by its OID and the name of the containing system catalog. For example, <code class="LITERAL">obj_description(123456,'pg_class')</code> would retrieve the comment for the table with OID 123456. The one-parameter form of <code class="FUNCTION">obj_description</code> requires only the object OID. It is deprecated since there is no guarantee that OIDs are unique across different system catalogs; therefore, the wrong comment might be returned.</p> <p><code class="FUNCTION">shobj_description</code> is used just like <code class="FUNCTION">obj_description</code> except it is used for retrieving comments on shared objects. Some system catalogs are global to all databases within each cluster, and the descriptions for objects in them are stored globally as well.</p> <p>The functions shown in <a href="../functions-info/#FUNCTIONS-TXID-SNAPSHOT">Table 9-63</a> provide server transaction information in an exportable form. The main use of these functions is to determine which transactions were committed between two snapshots.</p> <div class="TABLE" id="FUNCTIONS-TXID-SNAPSHOT">  <p class="c2">Table 9-63. Transaction IDs and Snapshots</p> <table class="CALSTABLE"> <col> <col> <col> <thead> <tr> <th>Name</th> <th>Return Type</th> <th>Description</th> </tr> </thead> <tbody> <tr> <td><code class="LITERAL" id="txid_current">txid_current()</code></td> <td><code class="TYPE">bigint</code></td> <td>get current transaction ID, assigning a new one if the current transaction does not have one</td> </tr> <tr> <td><code class="LITERAL" id="txid_current_snapshot">txid_current_snapshot()</code></td> <td><code class="TYPE">txid_snapshot</code></td> <td>get current snapshot</td> </tr> <tr> <td><code class="LITERAL" id="txid_snapshot_xip">txid_snapshot_xip(<code class="PARAMETER">txid_snapshot</code>)</code></td> <td><code class="TYPE">setof bigint</code></td> <td>get in-progress transaction IDs in snapshot</td> </tr> <tr> <td><code class="LITERAL" id="txid_snapshot_xmax">txid_snapshot_xmax(<code class="PARAMETER">txid_snapshot</code>)</code></td> <td><code class="TYPE">bigint</code></td> <td>get <code class="LITERAL">xmax</code> of snapshot</td> </tr> <tr> <td><code class="LITERAL" id="txid_snapshot_xmin">txid_snapshot_xmin(<code class="PARAMETER">txid_snapshot</code>)</code></td> <td><code class="TYPE">bigint</code></td> <td>get <code class="LITERAL">xmin</code> of snapshot</td> </tr> <tr> <td><code class="LITERAL" id="txid_visible_in_snapshot">txid_visible_in_snapshot(<code class="PARAMETER">bigint</code>, <code class="PARAMETER">txid_snapshot</code>)</code></td> <td><code class="TYPE">boolean</code></td> <td>is transaction ID visible in snapshot? (do not use with subtransaction ids)</td> </tr> </tbody> </table> </div> <p>The internal transaction ID type (<code class="TYPE">xid</code>) is 32 bits wide and wraps around every 4 billion transactions. However, these functions export a 64-bit format that is extended with an <span class="QUOTE">"epoch"</span> counter so it will not wrap around during the life of an installation. The data type used by these functions, <code class="TYPE">txid_snapshot</code>, stores information about transaction ID visibility at a particular moment in time. Its components are described in <a href="../functions-info/#FUNCTIONS-TXID-SNAPSHOT-PARTS">Table 9-64</a>.</p> <div class="TABLE" id="FUNCTIONS-TXID-SNAPSHOT-PARTS">  <p class="c2">Table 9-64. Snapshot Components</p> <table class="CALSTABLE"> <col> <col> <thead> <tr> <th>Name</th> <th>Description</th> </tr> </thead> <tbody> <tr> <td><code class="TYPE">xmin</code></td> <td>Earliest transaction ID (txid) that is still active. All earlier transactions will either be committed and visible, or rolled back and dead.</td> </tr> <tr> <td><code class="TYPE">xmax</code></td> <td>First as-yet-unassigned txid. All txids greater than or equal to this are not yet started as of the time of the snapshot, and thus invisible.</td> </tr> <tr> <td><code class="TYPE">xip_list</code></td> <td>Active txids at the time of the snapshot. The list includes only those active txids between <code class="LITERAL">xmin</code> and <code class="LITERAL">xmax</code>; there might be active txids higher than <code class="LITERAL">xmax</code>. A txid that is <code class="LITERAL">xmin &lt;= txid &lt; xmax</code> and not in this list was already completed at the time of the snapshot, and thus either visible or dead according to its commit status. The list does not include txids of subtransactions.</td> </tr> </tbody> </table> </div> <p><code class="TYPE">txid_snapshot</code>'s textual representation is <code class="LITERAL"><code class="REPLACEABLE c3">xmin</code>:<code class="REPLACEABLE c3">xmax</code>:<code class="REPLACEABLE c3">xip_list</code></code>. For example <code class="LITERAL">10:20:10,14,15</code> means <code class="LITERAL">xmin=10, xmax=20, xip_list=10, 14, 15</code>.</p> <p>The functions shown in <a href="../functions-info/#FUNCTIONS-COMMIT-TIMESTAMP">Table 9-65</a> provide information about transactions that have been already committed. These functions mainly provide information about when the transactions were committed. They only provide useful data when <a href="../runtime-config-replication/#GUC-TRACK-COMMIT-TIMESTAMP">track_commit_timestamp</a> configuration option is enabled and only for transactions that were committed after it was enabled.</p> <div class="TABLE" id="FUNCTIONS-COMMIT-TIMESTAMP">  <p class="c2">Table 9-65. Committed transaction information</p> <table class="CALSTABLE"> <col> <col> <col> <thead> <tr> <th>Name</th> <th>Return Type</th> <th>Description</th> </tr> </thead> <tbody> <tr> <td><code class="LITERAL" id="pg_xact_commit_timestamp">pg_xact_commit_timestamp(<code class="PARAMETER">xid</code>)</code></td> <td><code class="TYPE">timestamp with time zone</code></td> <td>get commit timestamp of a transaction</td> </tr> <tr> <td><code class="LITERAL" id="pg_last_committed_xact">pg_last_committed_xact()</code></td> <td>
<code class="PARAMETER">xid</code> <code class="TYPE">xid</code>, <code class="PARAMETER">timestamp</code> <code class="TYPE">timestamp with time zone</code>
</td> <td>get transaction ID and commit timestamp of latest committed transaction</td> </tr> </tbody> </table> </div>  <div class="NAVFOOTER">  <table summary="Footer navigation table"> <tr> <td width="33%" align="left"><a href="../functions-srf/" accesskey="P">Prev</a></td> <td width="34%" align="center"></td> <td width="33%" align="right"><a href="../functions-admin/" accesskey="N">Next</a></td> </tr> <tr> <td width="33%" align="left">Set Returning Functions</td> <td width="34%" align="center"><a href="https://www.postgresql.org/docs/9.5/static/functions.html" accesskey="U" target="_blank">Up</a></td> <td width="33%" align="right">System Administration Functions</td> </tr> </table> </div>
<div class="_attribution">
  <p class="_attribution-p">
    © 1996–2017 The PostgreSQL Global Development Group<br>Licensed under the PostgreSQL License.<br>
    <a href="https://www.postgresql.org/docs/9.5/static/functions-info.html" class="_attribution-link" target="_blank">https://www.postgresql.org/docs/9.5/static/functions-info.html</a>
  </p>
</div>

			</div>
		</div>
	</section>

	</div>
</body>
</html>
