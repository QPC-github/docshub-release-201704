
<!DOCTYPE HTML>

<html lang="en">

<head>
  <meta charset="utf-8">
  <title>Pgbench - PostgreSQL 9.5 - W3cubDocs</title>
  
  <meta name="description" content="pgbench is a simple program for running benchmark tests on PostgreSQL. It runs the same sequence of SQL commands over and over, possibly in multiple &hellip;">
  <meta name="keywords" content="pgbench, -, postgresql, postgresql~9.5">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="http://docs.w3cub.com/postgresql~9.5/pgbench/">
  <link href="/favicon.png" rel="icon">
  <link type="text/css" rel="stylesheet" href="/assets/application-50364fff564ce3b6327021805f3f00e2957b441cf27f576a7dd4ff63bbc47047.css">
  <script type="text/javascript" src="/assets/application-db64bfd54ceb42be11af7995804cf4902548419ceb79d509b0b7d62c22d98e6f.js"></script>
  <script src="/json/postgresql~9.5.js"></script>
  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-71174418-1']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>


</head>

<body>
	<div class="_app">
	<header class="_header">
  
  <form class="_search">
    <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
    <a class="_search-clear"></a>
    <div class="_search-tag"></div>
  </form>
  
  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/postgresql~9.5/" class="_nav-link" title="" style="margin-left:0;">PostgreSQL 9.5</a></span>
  
  <nav class="_nav">
    <a href="/app/" class="_nav-link ">App</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		<div class="_list">
			
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<div class="_page _postgres">
				
<h1 id="PGBENCH"><span class="APPLICATION">pgbench</span></h1> <div class="REFNAMEDIV" id="AEN91497">  <h2>Name</h2>pgbench -- run a benchmark test on <span class="PRODUCTNAME">PostgreSQL</span> </div> <div class="REFSYNOPSISDIV" id="AEN91501">  <h2>Synopsis</h2> <pre>pgbench -i [option...] [dbname]</pre> <pre>pgbench [option...] [dbname]</pre> </div> <div class="REFSECT1" id="AEN91516">  <h2>Description</h2> <p><span class="APPLICATION">pgbench</span> is a simple program for running benchmark tests on <span class="PRODUCTNAME">PostgreSQL</span>. It runs the same sequence of SQL commands over and over, possibly in multiple concurrent database sessions, and then calculates the average transaction rate (transactions per second). By default, <span class="APPLICATION">pgbench</span> tests a scenario that is loosely based on TPC-B, involving five <code class="COMMAND">SELECT</code>, <code class="COMMAND">UPDATE</code>, and <code class="COMMAND">INSERT</code> commands per transaction. However, it is easy to test other cases by writing your own transaction script files.</p> <p>Typical output from <span class="APPLICATION">pgbench</span> looks like:</p> <pre class="SCREEN">
transaction type: TPC-B (sort of)
scaling factor: 10
query mode: simple
number of clients: 10
number of threads: 1
number of transactions per client: 1000
number of transactions actually processed: 10000/10000
tps = 85.184871 (including connections establishing)
tps = 85.296346 (excluding connections establishing)
</pre> <p>The first six lines report some of the most important parameter settings. The next line reports the number of transactions completed and intended (the latter being just the product of number of clients and number of transactions per client); these will be equal unless the run failed before completion. (In <code class="OPTION">-T</code> mode, only the actual number of transactions is printed.) The last two lines report the number of transactions per second, figured with and without counting the time to start database sessions.</p> <p>The default TPC-B-like transaction test requires specific tables to be set up beforehand. <span class="APPLICATION">pgbench</span> should be invoked with the <code class="OPTION">-i</code> (initialize) option to create and populate these tables. (When you are testing a custom script, you don't need this step, but will instead need to do whatever setup your test needs.) Initialization looks like:</p> <pre class="PROGRAMLISTING" data-language="sql">
pgbench -i [ other-options ] dbname
</pre> <p>where <code class="REPLACEABLE c2">dbname</code> is the name of the already-created database to test in. (You may also need <code class="OPTION">-h</code>, <code class="OPTION">-p</code>, and/or <code class="OPTION">-U</code> options to specify how to connect to the database server.)</p> <blockquote class="CAUTION"> <p><strong>Caution:</strong> <code class="LITERAL">pgbench -i</code> creates four tables <code class="STRUCTNAME">pgbench_accounts</code>, <code class="STRUCTNAME">pgbench_branches</code>, <code class="STRUCTNAME">pgbench_history</code>, and <code class="STRUCTNAME">pgbench_tellers</code>, destroying any existing tables of these names. Be very careful to use another database if you have tables having these names!</p> </blockquote> <p>At the default <span class="QUOTE">"scale factor"</span> of 1, the tables initially contain this many rows:</p> <pre class="SCREEN">
table                   # of rows
---------------------------------
pgbench_branches        1
pgbench_tellers         10
pgbench_accounts        100000
pgbench_history         0
</pre> <p>You can (and, for most purposes, probably should) increase the number of rows by using the <code class="OPTION">-s</code> (scale factor) option. The <code class="OPTION">-F</code> (fillfactor) option might also be used at this point.</p> <p>Once you have done the necessary setup, you can run your benchmark with a command that doesn't include <code class="OPTION">-i</code>, that is</p> <pre class="PROGRAMLISTING" data-language="sql">
pgbench [ options ] dbname
</pre> <p>In nearly all cases, you'll need some options to make a useful test. The most important options are <code class="OPTION">-c</code> (number of clients), <code class="OPTION">-t</code> (number of transactions), <code class="OPTION">-T</code> (time limit), and <code class="OPTION">-f</code> (specify a custom script file). See below for a full list.</p> </div> <div class="REFSECT1" id="AEN91562">  <h2>Options</h2> <p>The following is divided into three subsections: Different options are used during database initialization and while running benchmarks, some options are useful in both cases.</p> <div class="REFSECT2" id="PGBENCH-INIT-OPTIONS">  <h3>Initialization Options</h3> <p><span class="APPLICATION">pgbench</span> accepts the following command-line initialization arguments:</p> <div class="VARIABLELIST"> <dl> <dt>
<code class="OPTION">-i</code><br> <code class="OPTION">--initialize</code>
</dt> <dd> <p>Required to invoke initialization mode.</p> </dd> <dt>
<code class="OPTION">-F</code> <code class="REPLACEABLE c2">fillfactor</code><br> <code class="OPTION">--fillfactor=</code><code class="REPLACEABLE c2">fillfactor</code>
</dt> <dd> <p>Create the <code class="STRUCTNAME">pgbench_accounts</code>, <code class="STRUCTNAME">pgbench_tellers</code> and <code class="STRUCTNAME">pgbench_branches</code> tables with the given fillfactor. Default is 100.</p> </dd> <dt>
<code class="OPTION">-n</code><br> <code class="OPTION">--no-vacuum</code>
</dt> <dd> <p>Perform no vacuuming after initialization.</p> </dd> <dt>
<code class="OPTION">-q</code><br> <code class="OPTION">--quiet</code>
</dt> <dd> <p>Switch logging to quiet mode, producing only one progress message per 5 seconds. The default logging prints one message each 100000 rows, which often outputs many lines per second (especially on good hardware).</p> </dd> <dt>
<code class="OPTION">-s</code> <code class="REPLACEABLE c2">scale_factor</code><br> <code class="OPTION">--scale=</code><code class="REPLACEABLE c2">scale_factor</code>
</dt> <dd> <p>Multiply the number of rows generated by the scale factor. For example, <code class="LITERAL">-s 100</code> will create 10,000,000 rows in the <code class="STRUCTNAME">pgbench_accounts</code> table. Default is 1. When the scale is 20,000 or larger, the columns used to hold account identifiers (<code class="STRUCTFIELD">aid</code> columns) will switch to using larger integers (<code class="TYPE">bigint</code>), in order to be big enough to hold the range of account identifiers.</p> </dd> <dt><code class="OPTION">--foreign-keys</code></dt> <dd> <p>Create foreign key constraints between the standard tables.</p> </dd> <dt><code class="OPTION">--index-tablespace=<code class="REPLACEABLE c2">index_tablespace</code></code></dt> <dd> <p>Create indexes in the specified tablespace, rather than the default tablespace.</p> </dd> <dt><code class="OPTION">--tablespace=<code class="REPLACEABLE c2">tablespace</code></code></dt> <dd> <p>Create tables in the specified tablespace, rather than the default tablespace.</p> </dd> <dt><code class="OPTION">--unlogged-tables</code></dt> <dd> <p>Create all tables as unlogged tables, rather than permanent tables.</p> </dd> </dl> </div> </div> <div class="REFSECT2" id="PGBENCH-RUN-OPTIONS">  <h3>Benchmarking Options</h3> <p><span class="APPLICATION">pgbench</span> accepts the following command-line benchmarking arguments:</p> <div class="VARIABLELIST"> <dl> <dt>
<code class="OPTION">-c</code> <code class="REPLACEABLE c2">clients</code><br> <code class="OPTION">--client=</code><code class="REPLACEABLE c2">clients</code>
</dt> <dd> <p>Number of clients simulated, that is, number of concurrent database sessions. Default is 1.</p> </dd> <dt>
<code class="OPTION">-C</code><br> <code class="OPTION">--connect</code>
</dt> <dd> <p>Establish a new connection for each transaction, rather than doing it just once per client session. This is useful to measure the connection overhead.</p> </dd> <dt>
<code class="OPTION">-d</code><br> <code class="OPTION">--debug</code>
</dt> <dd> <p>Print debugging output.</p> </dd> <dt>
<code class="OPTION">-D</code> <code class="REPLACEABLE c2">varname</code><code class="LITERAL">=</code><code class="REPLACEABLE c2">value</code><br> <code class="OPTION">--define=</code><code class="REPLACEABLE c2">varname</code><code class="LITERAL">=</code><code class="REPLACEABLE c2">value</code>
</dt> <dd> <p>Define a variable for use by a custom script (see below). Multiple <code class="OPTION">-D</code> options are allowed.</p> </dd> <dt>
<code class="OPTION">-f</code> <code class="REPLACEABLE c2">filename</code><br> <code class="OPTION">--file=</code><code class="REPLACEABLE c2">filename</code>
</dt> <dd> <p>Read transaction script from <code class="REPLACEABLE c2">filename</code>. See below for details. <code class="OPTION">-N</code>, <code class="OPTION">-S</code>, and <code class="OPTION">-f</code> are mutually exclusive.</p> </dd> <dt>
<code class="OPTION">-j</code> <code class="REPLACEABLE c2">threads</code><br> <code class="OPTION">--jobs=</code><code class="REPLACEABLE c2">threads</code>
</dt> <dd> <p>Number of worker threads within <span class="APPLICATION">pgbench</span>. Using more than one thread can be helpful on multi-CPU machines. The number of clients must be a multiple of the number of threads, since each thread is given the same number of client sessions to manage. Default is 1.</p> </dd> <dt>
<code class="OPTION">-l</code><br> <code class="OPTION">--log</code>
</dt> <dd> <p>Write the time taken by each transaction to a log file. See below for details.</p> </dd> <dt>
<code class="OPTION">-L</code> <code class="REPLACEABLE c2">limit</code><br> <code class="OPTION">--latency-limit=</code><code class="REPLACEABLE c2">limit</code>
</dt> <dd> <p>Transaction which last more than <code class="REPLACEABLE c2">limit</code> milliseconds are counted and reported separately, as <i class="FIRSTTERM">late</i>.</p> <p>When throttling is used (<code class="OPTION">--rate=...</code>), transactions that lag behind schedule by more than <code class="REPLACEABLE c2">limit</code> ms, and thus have no hope of meeting the latency limit, are not sent to the server at all. They are counted and reported separately as <i class="FIRSTTERM">skipped</i>.</p> </dd> <dt>
<code class="OPTION">-M</code> <code class="REPLACEABLE c2">querymode</code><br> <code class="OPTION">--protocol=</code><code class="REPLACEABLE c2">querymode</code>
</dt> <dd> <p>Protocol to use for submitting queries to the server:</p> <ul> <li> <p><code class="LITERAL">simple</code>: use simple query protocol.</p> </li> <li> <p><code class="LITERAL">extended</code>: use extended query protocol.</p> </li> <li> <p><code class="LITERAL">prepared</code>: use extended query protocol with prepared statements.</p> </li> </ul> <p>The default is simple query protocol. (See <a href="https://www.postgresql.org/docs/9.5/static/protocol.html" target="_blank">Chapter 50</a> for more information.)</p> </dd> <dt>
<code class="OPTION">-n</code><br> <code class="OPTION">--no-vacuum</code>
</dt> <dd> <p>Perform no vacuuming before running the test. This option is <span class="emphasis EMPHASIS c4">necessary</span> if you are running a custom test scenario that does not include the standard tables <code class="STRUCTNAME">pgbench_accounts</code>, <code class="STRUCTNAME">pgbench_branches</code>, <code class="STRUCTNAME">pgbench_history</code>, and <code class="STRUCTNAME">pgbench_tellers</code>.</p> </dd> <dt>
<code class="OPTION">-N</code><br> <code class="OPTION">--skip-some-updates</code>
</dt> <dd> <p>Do not update <code class="STRUCTNAME">pgbench_tellers</code> and <code class="STRUCTNAME">pgbench_branches</code>. This will avoid update contention on these tables, but it makes the test case even less like TPC-B.</p> </dd> <dt>
<code class="OPTION">-P</code> <code class="REPLACEABLE c2">sec</code><br> <code class="OPTION">--progress=</code><code class="REPLACEABLE c2">sec</code>
</dt> <dd> <p>Show progress report every <code class="LITERAL">sec</code> seconds. The report includes the time since the beginning of the run, the tps since the last report, and the transaction latency average and standard deviation since the last report. Under throttling (<code class="OPTION">-R</code>), the latency is computed with respect to the transaction scheduled start time, not the actual transaction beginning time, thus it also includes the average schedule lag time.</p> </dd> <dt>
<code class="OPTION">-r</code><br> <code class="OPTION">--report-latencies</code>
</dt> <dd> <p>Report the average per-statement latency (execution time from the perspective of the client) of each command after the benchmark finishes. See below for details.</p> </dd> <dt>
<code class="OPTION">-R</code> <code class="REPLACEABLE c2">rate</code><br> <code class="OPTION">--rate=</code><code class="REPLACEABLE c2">rate</code>
</dt> <dd> <p>Execute transactions targeting the specified rate instead of running as fast as possible (the default). The rate is given in transactions per second. If the targeted rate is above the maximum possible rate, the rate limit won't impact the results.</p> <p>The rate is targeted by starting transactions along a Poisson-distributed schedule time line. The expected start time schedule moves forward based on when the client first started, not when the previous transaction ended. That approach means that when transactions go past their original scheduled end time, it is possible for later ones to catch up again.</p> <p>When throttling is active, the transaction latency reported at the end of the run is calculated from the scheduled start times, so it includes the time each transaction had to wait for the previous transaction to finish. The wait time is called the schedule lag time, and its average and maximum are also reported separately. The transaction latency with respect to the actual transaction start time, i.e. the time spent executing the transaction in the database, can be computed by subtracting the schedule lag time from the reported latency.</p> <p>If <code class="OPTION">--latency-limit</code> is used together with <code class="OPTION">--rate</code>, a transaction can lag behind so much that it is already over the latency limit when the previous transaction ends, because the latency is calculated from the scheduled start time. Such transactions are not sent to the server, but are skipped altogether and counted separately.</p> <p>A high schedule lag time is an indication that the system cannot process transactions at the specified rate, with the chosen number of clients and threads. When the average transaction execution time is longer than the scheduled interval between each transaction, each successive transaction will fall further behind, and the schedule lag time will keep increasing the longer the test run is. When that happens, you will have to reduce the specified transaction rate.</p> </dd> <dt>
<code class="OPTION">-s</code> <code class="REPLACEABLE c2">scale_factor</code><br> <code class="OPTION">--scale=</code><code class="REPLACEABLE c2">scale_factor</code>
</dt> <dd> <p>Report the specified scale factor in <span class="APPLICATION">pgbench</span>'s output. With the built-in tests, this is not necessary; the correct scale factor will be detected by counting the number of rows in the <code class="STRUCTNAME">pgbench_branches</code> table. However, when testing custom benchmarks (<code class="OPTION">-f</code> option), the scale factor will be reported as 1 unless this option is used.</p> </dd> <dt>
<code class="OPTION">-S</code><br> <code class="OPTION">--select-only</code>
</dt> <dd> <p>Perform select-only transactions instead of TPC-B-like test.</p> </dd> <dt>
<code class="OPTION">-t</code> <code class="REPLACEABLE c2">transactions</code><br> <code class="OPTION">--transactions=</code><code class="REPLACEABLE c2">transactions</code>
</dt> <dd> <p>Number of transactions each client runs. Default is 10.</p> </dd> <dt>
<code class="OPTION">-T</code> <code class="REPLACEABLE c2">seconds</code><br> <code class="OPTION">--time=</code><code class="REPLACEABLE c2">seconds</code>
</dt> <dd> <p>Run the test for this many seconds, rather than a fixed number of transactions per client. <code class="OPTION">-t</code> and <code class="OPTION">-T</code> are mutually exclusive.</p> </dd> <dt>
<code class="OPTION">-v</code><br> <code class="OPTION">--vacuum-all</code>
</dt> <dd> <p>Vacuum all four standard tables before running the test. With neither <code class="OPTION">-n</code> nor <code class="OPTION">-v</code>, <span class="APPLICATION">pgbench</span> will vacuum the <code class="STRUCTNAME">pgbench_tellers</code> and <code class="STRUCTNAME">pgbench_branches</code> tables, and will truncate <code class="STRUCTNAME">pgbench_history</code>.</p> </dd> <dt><code class="OPTION">--aggregate-interval=<code class="REPLACEABLE c2">seconds</code></code></dt> <dd> <p>Length of aggregation interval (in seconds). May be used only together with <span class="APPLICATION">-l</span> - with this option, the log contains per-interval summary (number of transactions, min/max latency and two additional fields useful for variance estimation).</p> <p>This option is not currently supported on Windows.</p> </dd> <dt><code class="OPTION">--sampling-rate=<code class="REPLACEABLE c2">rate</code></code></dt> <dd> <p>Sampling rate, used when writing data into the log, to reduce the amount of log generated. If this option is given, only the specified fraction of transactions are logged. 1.0 means all transactions will be logged, 0.05 means only 5% of the transactions will be logged.</p> <p>Remember to take the sampling rate into account when processing the log file. For example, when computing tps values, you need to multiply the numbers accordingly (e.g. with 0.01 sample rate, you'll only get 1/100 of the actual tps).</p> </dd> </dl> </div> </div> <div class="REFSECT2" id="PGBENCH-COMMON-OPTIONS">  <h3>Common Options</h3> <p><span class="APPLICATION">pgbench</span> accepts the following command-line common arguments:</p> <div class="VARIABLELIST"> <dl> <dt>
<code class="OPTION">-h</code> <code class="REPLACEABLE c2">hostname</code><br> <code class="OPTION">--host=</code><code class="REPLACEABLE c2">hostname</code>
</dt> <dd> <p>The database server's host name</p> </dd> <dt>
<code class="OPTION">-p</code> <code class="REPLACEABLE c2">port</code><br> <code class="OPTION">--port=</code><code class="REPLACEABLE c2">port</code>
</dt> <dd> <p>The database server's port number</p> </dd> <dt>
<code class="OPTION">-U</code> <code class="REPLACEABLE c2">login</code><br> <code class="OPTION">--username=</code><code class="REPLACEABLE c2">login</code>
</dt> <dd> <p>The user name to connect as</p> </dd> <dt>
<code class="OPTION">-V</code><br> <code class="OPTION">--version</code>
</dt> <dd> <p>Print the <span class="APPLICATION">pgbench</span> version and exit.</p> </dd> <dt>
<code class="OPTION">-?</code><br> <code class="OPTION">--help</code>
</dt> <dd> <p>Show help about <span class="APPLICATION">pgbench</span> command line arguments, and exit.</p> </dd> </dl> </div> </div> </div> <div class="REFSECT1" id="AEN91914">  <h2>Notes</h2> <div class="REFSECT2" id="AEN91916">  <h3>What is the <span class="QUOTE">"Transaction"</span> Actually Performed in <span class="APPLICATION">pgbench</span>?</h3> <p>The default transaction script issues seven commands per transaction:</p> <ol type="1"> <li> <p><code class="LITERAL">BEGIN;</code></p> </li> <li> <p><code class="LITERAL">UPDATE pgbench_accounts SET abalance = abalance + :delta WHERE aid = :aid;</code></p> </li> <li> <p><code class="LITERAL">SELECT abalance FROM pgbench_accounts WHERE aid = :aid;</code></p> </li> <li> <p><code class="LITERAL">UPDATE pgbench_tellers SET tbalance = tbalance + :delta WHERE tid = :tid;</code></p> </li> <li> <p><code class="LITERAL">UPDATE pgbench_branches SET bbalance = bbalance + :delta WHERE bid = :bid;</code></p> </li> <li> <p><code class="LITERAL">INSERT INTO pgbench_history (tid, bid, aid, delta, mtime) VALUES (:tid, :bid, :aid, :delta, CURRENT_TIMESTAMP);</code></p> </li> <li> <p><code class="LITERAL">END;</code></p> </li> </ol> <p>If you specify <code class="OPTION">-N</code>, steps 4 and 5 aren't included in the transaction. If you specify <code class="OPTION">-S</code>, only the <code class="COMMAND">SELECT</code> is issued.</p> </div> <div class="REFSECT2" id="AEN91947">  <h3>Custom Scripts</h3> <p><span class="APPLICATION">pgbench</span> has support for running custom benchmark scenarios by replacing the default transaction script (described above) with a transaction script read from a file (<code class="OPTION">-f</code> option). In this case a <span class="QUOTE">"transaction"</span> counts as one execution of a script file. You can even specify multiple scripts (multiple <code class="OPTION">-f</code> options), in which case a random one of the scripts is chosen each time a client session starts a new transaction.</p> <p>The format of a script file is one SQL command per line; multiline SQL commands are not supported. Empty lines and lines beginning with <code class="LITERAL">--</code> are ignored. Script file lines can also be <span class="QUOTE">"meta commands"</span>, which are interpreted by <span class="APPLICATION">pgbench</span> itself, as described below.</p> <p>There is a simple variable-substitution facility for script files. Variables can be set by the command-line <code class="OPTION">-D</code> option, explained above, or by the meta commands explained below. In addition to any variables preset by <code class="OPTION">-D</code> command-line options, there are a few variables that are preset automatically, listed in <a href="../pgbench/#PGBENCH-AUTOMATIC-VARIABLES">Table 1</a>. A value specified for these variables using <code class="OPTION">-D</code> takes precedence over the automatic presets. Once set, a variable's value can be inserted into a SQL command by writing <code class="LITERAL">:</code><code class="REPLACEABLE c2">variablename</code>. When running more than one client session, each session has its own set of variables.</p> <div class="TABLE" id="PGBENCH-AUTOMATIC-VARIABLES">  <p class="c5">Table 1. Automatic variables</p> <table class="CALSTABLE"> <col> <col> <thead> <tr> <th>Variable</th> <th>Description</th> </tr> </thead> <tbody> <tr> <td><code class="LITERAL">scale</code></td> <td>current scale factor</td> </tr> <tr> <td><code class="LITERAL">client_id</code></td> <td>unique number identifying the client session (starts from zero)</td> </tr> </tbody> </table> </div> <p>Script file meta commands begin with a backslash (<code class="LITERAL">\</code>). Arguments to a meta command are separated by white space. These meta commands are supported:</p> <div class="VARIABLELIST"> <dl> <dt><code class="LITERAL">\set <code class="REPLACEABLE c2">varname</code> <code class="REPLACEABLE c2">expression</code></code></dt> <dd> <p>Sets variable <code class="REPLACEABLE c2">varname</code> to an integer value calculated from <code class="REPLACEABLE c2">expression</code>. The expression may contain integer constants such as <code class="LITERAL">5432</code>, references to variables <code class="LITERAL">:</code><code class="REPLACEABLE c2">variablename</code>, and expressions composed of unary (<code class="LITERAL">-</code>) or binary operators (<code class="LITERAL">+</code>, <code class="LITERAL">-</code>, <code class="LITERAL">*</code>, <code class="LITERAL">/</code>, <code class="LITERAL">%</code>) with their usual associativity, and parentheses.</p> <p>Examples:</p> <pre class="PROGRAMLISTING" data-language="sql">
\set ntellers 10 * :scale
\set aid (1021 * :aid) % (100000 * :scale) + 1
</pre> </dd> <dt><code class="LITERAL">\setrandom <code class="REPLACEABLE c2">varname</code> <code class="REPLACEABLE c2">min</code> <code class="REPLACEABLE c2">max</code> [ uniform | { gaussian | exponential } <code class="REPLACEABLE c2">parameter</code> ]</code></dt> <dd> <p>Sets variable <code class="REPLACEABLE c2">varname</code> to a random integer value between the limits <code class="REPLACEABLE c2">min</code> and <code class="REPLACEABLE c2">max</code> inclusive. Each limit can be either an integer constant or a <code class="LITERAL">:</code><code class="REPLACEABLE c2">variablename</code> reference to a variable having an integer value.</p> <p>By default, or when <code class="LITERAL">uniform</code> is specified, all values in the range are drawn with equal probability. Specifying <code class="LITERAL">gaussian</code> or <code class="LITERAL">exponential</code> options modifies this behavior; each requires a mandatory parameter which determines the precise shape of the distribution.</p> <p>For a Gaussian distribution, the interval is mapped onto a standard normal distribution (the classical bell-shaped Gaussian curve) truncated at <code class="LITERAL">-parameter</code> on the left and <code class="LITERAL">+parameter</code> on the right. Values in the middle of the interval are more likely to be drawn. To be precise, if <code class="LITERAL">PHI(x)</code> is the cumulative distribution function of the standard normal distribution, with mean <code class="LITERAL">mu</code> defined as <code class="LITERAL">(max + min) / 2.0</code>, with</p> <p class="LITERALLAYOUT"> f(x) = PHI(2.0 * parameter * (x - mu) / (max - min + 1)) /<br> (2.0 * PHI(parameter) - 1.0)</p>then value <code class="REPLACEABLE c2">i</code> between <code class="REPLACEABLE c2">min</code> and <code class="REPLACEABLE c2">max</code> inclusive is drawn with probability: <code class="LITERAL">f(i + 0.5) - f(i - 0.5)</code>. Intuitively, the larger <code class="REPLACEABLE c2">parameter</code>, the more frequently values close to the middle of the interval are drawn, and the less frequently values close to the <code class="REPLACEABLE c2">min</code> and <code class="REPLACEABLE c2">max</code> bounds. About 67% of values are drawn from the middle <code class="LITERAL">1.0 / parameter</code>, that is a relative <code class="LITERAL">0.5 / parameter</code> around the mean, and 95% in the middle <code class="LITERAL">2.0 / parameter</code>, that is a relative <code class="LITERAL">1.0 / parameter</code> around the mean; for instance, if <code class="REPLACEABLE c2">parameter</code> is 4.0, 67% of values are drawn from the middle quarter (1.0 / 4.0) of the interval (i.e. from <code class="LITERAL">3.0 / 8.0</code> to <code class="LITERAL">5.0 / 8.0</code>) and 95% from the middle half (<code class="LITERAL">2.0 / 4.0</code>) of the interval (second and third quartiles). The minimum <code class="REPLACEABLE c2">parameter</code> is 2.0 for performance of the Box-Muller transform. <p>For an exponential distribution, <code class="REPLACEABLE c2">parameter</code> controls the distribution by truncating a quickly-decreasing exponential distribution at <code class="REPLACEABLE c2">parameter</code>, and then projecting onto integers between the bounds. To be precise, with</p> <p class="LITERALLAYOUT"> f(x) = exp(-parameter * (x - min) / (max - min + 1)) / (1.0 - exp(-parameter))</p>Then value <code class="REPLACEABLE c2">i</code> between <code class="REPLACEABLE c2">min</code> and <code class="REPLACEABLE c2">max</code> inclusive is drawn with probability: <code class="LITERAL">f(x) - f(x + 1)</code>. Intuitively, the larger <code class="REPLACEABLE c2">parameter</code>, the more frequently values close to <code class="REPLACEABLE c2">min</code> are accessed, and the less frequently values close to <code class="REPLACEABLE c2">max</code> are accessed. The closer to 0 <code class="REPLACEABLE c2">parameter</code>, the flatter (more uniform) the access distribution. A crude approximation of the distribution is that the most frequent 1% values in the range, close to <code class="REPLACEABLE c2">min</code>, are drawn <code class="REPLACEABLE c2">parameter</code>% of the time. <code class="REPLACEABLE c2">parameter</code> value must be strictly positive. <p>Example:</p> <pre class="PROGRAMLISTING" data-language="sql">
\setrandom aid 1 :naccounts gaussian 5.0
</pre> </dd> <dt><code class="LITERAL">\sleep <code class="REPLACEABLE c2">number</code> [ us | ms | s ]</code></dt> <dd> <p>Causes script execution to sleep for the specified duration in microseconds (<code class="LITERAL">us</code>), milliseconds (<code class="LITERAL">ms</code>) or seconds (<code class="LITERAL">s</code>). If the unit is omitted then seconds are the default. <code class="REPLACEABLE c2">number</code> can be either an integer constant or a <code class="LITERAL">:</code><code class="REPLACEABLE c2">variablename</code> reference to a variable having an integer value.</p> <p>Example:</p> <pre class="PROGRAMLISTING" data-language="sql">
\sleep 10 ms
</pre> </dd> <dt><code class="LITERAL">\setshell <code class="REPLACEABLE c2">varname</code> <code class="REPLACEABLE c2">command</code> [ <code class="REPLACEABLE c2">argument</code> ... ]</code></dt> <dd> <p>Sets variable <code class="REPLACEABLE c2">varname</code> to the result of the shell command <code class="REPLACEABLE c2">command</code>. The command must return an integer value through its standard output.</p> <p><code class="REPLACEABLE c2">argument</code> can be either a text constant or a <code class="LITERAL">:</code><code class="REPLACEABLE c2">variablename</code> reference to a variable of any types. If you want to use <code class="REPLACEABLE c2">argument</code> starting with colons, you need to add an additional colon at the beginning of <code class="REPLACEABLE c2">argument</code>.</p> <p>Example:</p> <pre class="PROGRAMLISTING" data-language="sql">
\setshell variable_to_be_assigned command literal_argument :variable ::literal_starting_with_colon
</pre> </dd> <dt><code class="LITERAL">\shell <code class="REPLACEABLE c2">command</code> [ <code class="REPLACEABLE c2">argument</code> ... ]</code></dt> <dd> <p>Same as <code class="LITERAL">\setshell</code>, but the result is ignored.</p> <p>Example:</p> <pre class="PROGRAMLISTING" data-language="sql">
\shell command literal_argument :variable ::literal_starting_with_colon
</pre> </dd> </dl> </div> <p>As an example, the full definition of the built-in TPC-B-like transaction is:</p> <pre class="PROGRAMLISTING" data-language="sql">
\set nbranches :scale
\set ntellers 10 * :scale
\set naccounts 100000 * :scale
\setrandom aid 1 :naccounts
\setrandom bid 1 :nbranches
\setrandom tid 1 :ntellers
\setrandom delta -5000 5000
BEGIN;
UPDATE pgbench_accounts SET abalance = abalance + :delta WHERE aid = :aid;
SELECT abalance FROM pgbench_accounts WHERE aid = :aid;
UPDATE pgbench_tellers SET tbalance = tbalance + :delta WHERE tid = :tid;
UPDATE pgbench_branches SET bbalance = bbalance + :delta WHERE bid = :bid;
INSERT INTO pgbench_history (tid, bid, aid, delta, mtime) VALUES (:tid, :bid, :aid, :delta, CURRENT_TIMESTAMP);
END;
</pre> <p>This script allows each iteration of the transaction to reference different, randomly-chosen rows. (This example also shows why it's important for each client session to have its own variables — otherwise they'd not be independently touching different rows.)</p> </div> <div class="REFSECT2" id="AEN92106">  <h3>Per-Transaction Logging</h3> <p>With the <code class="OPTION">-l</code> option but without the <code class="OPTION">--aggregate-interval</code>, <span class="APPLICATION">pgbench</span> writes the time taken by each transaction to a log file. The log file will be named <code class="FILENAME">pgbench_log.<code class="REPLACEABLE c2">nnn</code></code>, where <code class="REPLACEABLE c2">nnn</code> is the PID of the <span class="APPLICATION">pgbench</span> process. If the <code class="OPTION">-j</code> option is 2 or higher, creating multiple worker threads, each will have its own log file. The first worker will use the same name for its log file as in the standard single worker case. The additional log files for the other workers will be named <code class="FILENAME">pgbench_log.<code class="REPLACEABLE c2">nnn</code>.<code class="REPLACEABLE c2">mmm</code></code>, where <code class="REPLACEABLE c2">mmm</code> is a sequential number for each worker starting with 1.</p> <p>The format of the log is:</p> <pre class="SYNOPSIS" data-language="sql">
client_id transaction_no time file_no time_epoch time_us [schedule_lag]
</pre> <p>where <code class="REPLACEABLE c2">time</code> is the total elapsed transaction time in microseconds, <code class="REPLACEABLE c2">file_no</code> identifies which script file was used (useful when multiple scripts were specified with <code class="OPTION">-f</code>), and <code class="REPLACEABLE c2">time_epoch</code>/<code class="REPLACEABLE c2">time_us</code> are a Unix epoch format time stamp and an offset in microseconds (suitable for creating an ISO 8601 time stamp with fractional seconds) showing when the transaction completed. Field <code class="REPLACEABLE c2">schedule_lag</code> is the difference between the transaction's scheduled start time, and the time it actually started, in microseconds. It is only present when the <code class="OPTION">--rate</code> option is used. When both <code class="OPTION">--rate</code> and <code class="OPTION">--latency-limit</code> are used, the <code class="REPLACEABLE c2">time</code> for a skipped transaction will be reported as <code class="LITERAL">skipped</code>.</p> <p>Here is a snippet of the log file generated:</p> <pre class="SCREEN">
 0 199 2241 0 1175850568 995598
 0 200 2465 0 1175850568 998079
 0 201 2513 0 1175850569 608
 0 202 2038 0 1175850569 2663
</pre> <p>Another example with --rate=100 and --latency-limit=5 (note the additional <code class="REPLACEABLE c2">schedule_lag</code> column):</p> <pre class="SCREEN">
 0 81 4621 0 1412881037 912698 3005
 0 82 6173 0 1412881037 914578 4304
 0 83 skipped 0 1412881037 914578 5217
 0 83 skipped 0 1412881037 914578 5099
 0 83 4722 0 1412881037 916203 3108
 0 84 4142 0 1412881037 918023 2333
 0 85 2465 0 1412881037 919759 740
</pre> <p>In this example, transaction 82 was late, because its latency (6.173 ms) was over the 5 ms limit. The next two transactions were skipped, because they were already late before they were even started.</p> <p>When running a long test on hardware that can handle a lot of transactions, the log files can become very large. The <code class="OPTION">--sampling-rate</code> option can be used to log only a random sample of transactions.</p> </div> <div class="REFSECT2" id="AEN92148">  <h3>Aggregated Logging</h3> <p>With the <code class="OPTION">--aggregate-interval</code> option, the logs use a bit different format:</p> <pre class="SYNOPSIS" data-language="sql">
interval_start num_of_transactions latency_sum latency_2_sum min_latency max_latency [lag_sum lag_2_sum min_lag max_lag [skipped_transactions]]
</pre> <p>where <code class="REPLACEABLE c2">interval_start</code> is the start of the interval (Unix epoch format time stamp), <code class="REPLACEABLE c2">num_of_transactions</code> is the number of transactions within the interval, <code class="REPLACEABLE c2">latency_sum</code> is a sum of latencies (so you can compute average latency easily). The following two fields are useful for variance estimation - <code class="REPLACEABLE c2">latency_sum</code> is a sum of latencies and <code class="REPLACEABLE c2">latency_2_sum</code> is a sum of 2nd powers of latencies. The next two fields are <code class="REPLACEABLE c2">min_latency</code> - a minimum latency within the interval, and <code class="REPLACEABLE c2">max_latency</code> - maximum latency within the interval. A transaction is counted into the interval when it was committed. The fields in the end, <code class="REPLACEABLE c2">lag_sum</code>, <code class="REPLACEABLE c2">lag_2_sum</code>, <code class="REPLACEABLE c2">min_lag</code>, and <code class="REPLACEABLE c2">max_lag</code>, are only present if the <code class="OPTION">--rate</code> option is used. The very last one, <code class="REPLACEABLE c2">skipped_transactions</code>, is only present if the option <code class="OPTION">--latency-limit</code> is present, too. They are calculated from the time each transaction had to wait for the previous one to finish, i.e. the difference between each transaction's scheduled start time and the time it actually started.</p> <p>Here is example output:</p> <pre class="SCREEN">
1345828501 5601 1542744 483552416 61 2573
1345828503 7884 1979812 565806736 60 1479
1345828505 7208 1979422 567277552 59 1391
1345828507 7685 1980268 569784714 60 1398
1345828509 7073 1979779 573489941 236 1411
</pre> <p>Notice that while the plain (unaggregated) log file contains a reference to the custom script files, the aggregated log does not. Therefore if you need per script data, you need to aggregate the data on your own.</p> </div> <div class="REFSECT2" id="AEN92183">  <h3>Per-Statement Latencies</h3> <p>With the <code class="OPTION">-r</code> option, <span class="APPLICATION">pgbench</span> collects the elapsed transaction time of each statement executed by every client. It then reports an average of those values, referred to as the latency for each statement, after the benchmark has finished.</p> <p>For the default script, the output will look similar to this:</p> <pre class="SCREEN">
starting vacuum...end.
transaction type: TPC-B (sort of)
scaling factor: 1
query mode: simple
number of clients: 10
number of threads: 1
number of transactions per client: 1000
number of transactions actually processed: 10000/10000
tps = 618.764555 (including connections establishing)
tps = 622.977698 (excluding connections establishing)
statement latencies in milliseconds:
        0.004386        \set nbranches 1 * :scale
        0.001343        \set ntellers 10 * :scale
        0.001212        \set naccounts 100000 * :scale
        0.001310        \setrandom aid 1 :naccounts
        0.001073        \setrandom bid 1 :nbranches
        0.001005        \setrandom tid 1 :ntellers
        0.001078        \setrandom delta -5000 5000
        0.326152        BEGIN;
        0.603376        UPDATE pgbench_accounts SET abalance = abalance + :delta WHERE aid = :aid;
        0.454643        SELECT abalance FROM pgbench_accounts WHERE aid = :aid;
        5.528491        UPDATE pgbench_tellers SET tbalance = tbalance + :delta WHERE tid = :tid;
        7.335435        UPDATE pgbench_branches SET bbalance = bbalance + :delta WHERE bid = :bid;
        0.371851        INSERT INTO pgbench_history (tid, bid, aid, delta, mtime) VALUES (:tid, :bid, :aid, :delta, CURRENT_TIMESTAMP);
        1.212976        END;
</pre> <p>If multiple script files are specified, the averages are reported separately for each script file.</p> <p>Note that collecting the additional timing information needed for per-statement latency computation adds some overhead. This will slow average execution speed and lower the computed TPS. The amount of slowdown varies significantly depending on platform and hardware. Comparing average TPS values with and without latency reporting enabled is a good way to measure if the timing overhead is significant.</p> </div> <div class="REFSECT2" id="AEN92192">  <h3>Good Practices</h3> <p>It is very easy to use <span class="APPLICATION">pgbench</span> to produce completely meaningless numbers. Here are some guidelines to help you get useful results.</p> <p>In the first place, <span class="emphasis EMPHASIS c4">never</span> believe any test that runs for only a few seconds. Use the <code class="OPTION">-t</code> or <code class="OPTION">-T</code> option to make the run last at least a few minutes, so as to average out noise. In some cases you could need hours to get numbers that are reproducible. It's a good idea to try the test run a few times, to find out if your numbers are reproducible or not.</p> <p>For the default TPC-B-like test scenario, the initialization scale factor (<code class="OPTION">-s</code>) should be at least as large as the largest number of clients you intend to test (<code class="OPTION">-c</code>); else you'll mostly be measuring update contention. There are only <code class="OPTION">-s</code> rows in the <code class="STRUCTNAME">pgbench_branches</code> table, and every transaction wants to update one of them, so <code class="OPTION">-c</code> values in excess of <code class="OPTION">-s</code> will undoubtedly result in lots of transactions blocked waiting for other transactions.</p> <p>The default test scenario is also quite sensitive to how long it's been since the tables were initialized: accumulation of dead rows and dead space in the tables changes the results. To understand the results you must keep track of the total number of updates and when vacuuming happens. If autovacuum is enabled it can result in unpredictable changes in measured performance.</p> <p>A limitation of <span class="APPLICATION">pgbench</span> is that it can itself become the bottleneck when trying to test a large number of client sessions. This can be alleviated by running <span class="APPLICATION">pgbench</span> on a different machine from the database server, although low network latency will be essential. It might even be useful to run several <span class="APPLICATION">pgbench</span> instances concurrently, on several client machines, against the same database server.</p> </div> </div> <div class="NAVFOOTER">  <table summary="Footer navigation table"> <tr> <td width="33%" align="left"><a href="../app-pgbasebackup/" accesskey="P">Prev</a></td> <td width="34%" align="center"></td> <td width="33%" align="right"><a href="../app-pgconfig/" accesskey="N">Next</a></td> </tr> <tr> <td width="33%" align="left">pg_basebackup</td> <td width="34%" align="center"><a href="https://www.postgresql.org/docs/9.5/static/reference-client.html" accesskey="U" target="_blank">Up</a></td> <td width="33%" align="right">pg_config</td> </tr> </table> </div>
<div class="_attribution">
  <p class="_attribution-p">
    © 1996–2017 The PostgreSQL Global Development Group<br>Licensed under the PostgreSQL License.<br>
    <a href="https://www.postgresql.org/docs/9.5/static/pgbench.html" class="_attribution-link" target="_blank">https://www.postgresql.org/docs/9.5/static/pgbench.html</a>
  </p>
</div>

			</div>
		</div>
	</section>

	</div>
</body>
</html>
