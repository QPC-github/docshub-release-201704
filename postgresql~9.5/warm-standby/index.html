
<!DOCTYPE HTML>

<html lang="en">

<head>
  <meta charset="utf-8">
  <title>Log-Shipping Standby Servers - PostgreSQL 9.5 - W3cubDocs</title>
  
  <meta name="description" content="Continuous archiving can be used to create a high availability (HA) cluster configuration with one or more standby servers ready to take over &hellip;">
  <meta name="keywords" content="log-shipping, standby, servers, -, postgresql, postgresql~9.5">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="http://docs.w3cub.com/postgresql~9.5/warm-standby/">
  <link href="/favicon.png" rel="icon">
  <link type="text/css" rel="stylesheet" href="/assets/application-50364fff564ce3b6327021805f3f00e2957b441cf27f576a7dd4ff63bbc47047.css">
  <script type="text/javascript" src="/assets/application-db64bfd54ceb42be11af7995804cf4902548419ceb79d509b0b7d62c22d98e6f.js"></script>
  <script src="/json/postgresql~9.5.js"></script>
  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-71174418-1']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>


</head>

<body>
	<div class="_app">
	<header class="_header">
  
  <form class="_search">
    <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
    <a class="_search-clear"></a>
    <div class="_search-tag"></div>
  </form>
  
  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/postgresql~9.5/" class="_nav-link" title="" style="margin-left:0;">PostgreSQL 9.5</a></span>
  
  <nav class="_nav">
    <a href="/app/" class="_nav-link ">App</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		<div class="_list">
			
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<div class="_page _postgres">
				
<h1 class="SECT1" id="WARM-STANDBY">25.2. Log-Shipping Standby Servers</h1> <p>Continuous archiving can be used to create a <i class="FIRSTTERM">high availability</i> (HA) cluster configuration with one or more <i class="FIRSTTERM">standby servers</i> ready to take over operations if the primary server fails. This capability is widely referred to as <i class="FIRSTTERM">warm standby</i> or <i class="FIRSTTERM">log shipping</i>.</p> <p>The primary and standby server work together to provide this capability, though the servers are only loosely coupled. The primary server operates in continuous archiving mode, while each standby server operates in continuous recovery mode, reading the WAL files from the primary. No changes to the database tables are required to enable this capability, so it offers low administration overhead compared to some other replication solutions. This configuration also has relatively low performance impact on the primary server.</p> <p>Directly moving WAL records from one database server to another is typically described as log shipping. <span class="PRODUCTNAME">PostgreSQL</span> implements file-based log shipping by transferring WAL records one file (WAL segment) at a time. WAL files (16MB) can be shipped easily and cheaply over any distance, whether it be to an adjacent system, another system at the same site, or another system on the far side of the globe. The bandwidth required for this technique varies according to the transaction rate of the primary server. Record-based log shipping is more granular and streams WAL changes incrementally over a network connection (see <a href="../warm-standby/#STREAMING-REPLICATION">Section 25.2.5</a>).</p> <p>It should be noted that log shipping is asynchronous, i.e., the WAL records are shipped after transaction commit. As a result, there is a window for data loss should the primary server suffer a catastrophic failure; transactions not yet shipped will be lost. The size of the data loss window in file-based log shipping can be limited by use of the <code class="VARNAME">archive_timeout</code> parameter, which can be set as low as a few seconds. However such a low setting will substantially increase the bandwidth required for file shipping. Streaming replication (see <a href="../warm-standby/#STREAMING-REPLICATION">Section 25.2.5</a>) allows a much smaller window of data loss.</p> <p>Recovery performance is sufficiently good that the standby will typically be only moments away from full availability once it has been activated. As a result, this is called a warm standby configuration which offers high availability. Restoring a server from an archived base backup and rollforward will take considerably longer, so that technique only offers a solution for disaster recovery, not high availability. A standby server can also be used for read-only queries, in which case it is called a Hot Standby server. See <a href="../hot-standby/">Section 25.5</a> for more information.</p> <div class="SECT2"> <h2 class="SECT2" id="STANDBY-PLANNING">25.2.1. Planning</h2> <p>It is usually wise to create the primary and standby servers so that they are as similar as possible, at least from the perspective of the database server. In particular, the path names associated with tablespaces will be passed across unmodified, so both primary and standby servers must have the same mount paths for tablespaces if that feature is used. Keep in mind that if <a href="../sql-createtablespace/">CREATE TABLESPACE</a> is executed on the primary, any new mount point needed for it must be created on the primary and all standby servers before the command is executed. Hardware need not be exactly the same, but experience shows that maintaining two identical systems is easier than maintaining two dissimilar ones over the lifetime of the application and system. In any case the hardware architecture must be the same — shipping from, say, a 32-bit to a 64-bit system will not work.</p> <p>In general, log shipping between servers running different major <span class="PRODUCTNAME">PostgreSQL</span> release levels is not possible. It is the policy of the PostgreSQL Global Development Group not to make changes to disk formats during minor release upgrades, so it is likely that running different minor release levels on primary and standby servers will work successfully. However, no formal support for that is offered and you are advised to keep primary and standby servers at the same release level as much as possible. When updating to a new minor release, the safest policy is to update the standby servers first — a new minor release is more likely to be able to read WAL files from a previous minor release than vice versa.</p> </div> <div class="SECT2"> <h2 class="SECT2" id="STANDBY-SERVER-OPERATION">25.2.2. Standby Server Operation</h2> <p>In standby mode, the server continuously applies WAL received from the master server. The standby server can read WAL from a WAL archive (see <a href="../archive-recovery-settings/#RESTORE-COMMAND">restore_command</a>) or directly from the master over a TCP connection (streaming replication). The standby server will also attempt to restore any WAL found in the standby cluster's <code class="FILENAME">pg_xlog</code> directory. That typically happens after a server restart, when the standby replays again WAL that was streamed from the master before the restart, but you can also manually copy files to <code class="FILENAME">pg_xlog</code> at any time to have them replayed.</p> <p>At startup, the standby begins by restoring all WAL available in the archive location, calling <code class="VARNAME">restore_command</code>. Once it reaches the end of WAL available there and <code class="VARNAME">restore_command</code> fails, it tries to restore any WAL available in the <code class="FILENAME">pg_xlog</code> directory. If that fails, and streaming replication has been configured, the standby tries to connect to the primary server and start streaming WAL from the last valid record found in archive or <code class="FILENAME">pg_xlog</code>. If that fails or streaming replication is not configured, or if the connection is later disconnected, the standby goes back to step 1 and tries to restore the file from the archive again. This loop of retries from the archive, <code class="FILENAME">pg_xlog</code>, and via streaming replication goes on until the server is stopped or failover is triggered by a trigger file.</p> <p>Standby mode is exited and the server switches to normal operation when <code class="COMMAND">pg_ctl promote</code> is run or a trigger file is found (<code class="VARNAME">trigger_file</code>). Before failover, any WAL immediately available in the archive or in <code class="FILENAME">pg_xlog</code> will be restored, but no attempt is made to connect to the master.</p> </div> <div class="SECT2"> <h2 class="SECT2" id="PREPARING-MASTER-FOR-STANDBY">25.2.3. Preparing the Master for Standby Servers</h2> <p>Set up continuous archiving on the primary to an archive directory accessible from the standby, as described in <a href="../continuous-archiving/">Section 24.3</a>. The archive location should be accessible from the standby even when the master is down, i.e. it should reside on the standby server itself or another trusted server, not on the master server.</p> <p>If you want to use streaming replication, set up authentication on the primary server to allow replication connections from the standby server(s); that is, create a role and provide a suitable entry or entries in <code class="FILENAME">pg_hba.conf</code> with the database field set to <code class="LITERAL">replication</code>. Also ensure <code class="VARNAME">max_wal_senders</code> is set to a sufficiently large value in the configuration file of the primary server. If replication slots will be used, ensure that <code class="VARNAME">max_replication_slots</code> is set sufficiently high as well.</p> <p>Take a base backup as described in <a href="../continuous-archiving/#BACKUP-BASE-BACKUP">Section 24.3.2</a> to bootstrap the standby server.</p> </div> <div class="SECT2"> <h2 class="SECT2" id="STANDBY-SERVER-SETUP">25.2.4. Setting Up a Standby Server</h2> <p>To set up the standby server, restore the base backup taken from primary server (see <a href="../continuous-archiving/#BACKUP-PITR-RECOVERY">Section 24.3.4</a>). Create a recovery command file <code class="FILENAME">recovery.conf</code> in the standby's cluster data directory, and turn on <code class="VARNAME">standby_mode</code>. Set <code class="VARNAME">restore_command</code> to a simple command to copy files from the WAL archive. If you plan to have multiple standby servers for high availability purposes, set <code class="VARNAME">recovery_target_timeline</code> to <code class="LITERAL">latest</code>, to make the standby server follow the timeline change that occurs at failover to another standby.</p>  <blockquote class="NOTE"> <p><b>Note:</b> Do not use pg_standby or similar tools with the built-in standby mode described here. <code class="VARNAME">restore_command</code> should return immediately if the file does not exist; the server will retry the command again if necessary. See <a href="../log-shipping-alternative/">Section 25.4</a> for using tools like pg_standby.</p> </blockquote>  <p>If you want to use streaming replication, fill in <code class="VARNAME">primary_conninfo</code> with a libpq connection string, including the host name (or IP address) and any additional details needed to connect to the primary server. If the primary needs a password for authentication, the password needs to be specified in <code class="VARNAME">primary_conninfo</code> as well.</p> <p>If you're setting up the standby server for high availability purposes, set up WAL archiving, connections and authentication like the primary server, because the standby server will work as a primary server after failover.</p> <p>If you're using a WAL archive, its size can be minimized using the <a href="../archive-recovery-settings/#ARCHIVE-CLEANUP-COMMAND">archive_cleanup_command</a> parameter to remove files that are no longer required by the standby server. The <span class="APPLICATION">pg_archivecleanup</span> utility is designed specifically to be used with <code class="VARNAME">archive_cleanup_command</code> in typical single-standby configurations, see <a href="../pgarchivecleanup/"><span class="APPLICATION">pg_archivecleanup</span></a>. Note however, that if you're using the archive for backup purposes, you need to retain files needed to recover from at least the latest base backup, even if they're no longer needed by the standby.</p> <p>A simple example of a <code class="FILENAME">recovery.conf</code> is:</p> <pre class="PROGRAMLISTING" data-language="sql">
standby_mode = 'on'
primary_conninfo = 'host=192.168.1.50 port=5432 user=foo password=foopass'
restore_command = 'cp /path/to/archive/%f %p'
archive_cleanup_command = 'pg_archivecleanup /path/to/archive %r'
</pre> <p>You can have any number of standby servers, but if you use streaming replication, make sure you set <code class="VARNAME">max_wal_senders</code> high enough in the primary to allow them to be connected simultaneously.</p> </div> <div class="SECT2"> <h2 class="SECT2" id="STREAMING-REPLICATION">25.2.5. Streaming Replication</h2> <p>Streaming replication allows a standby server to stay more up-to-date than is possible with file-based log shipping. The standby connects to the primary, which streams WAL records to the standby as they're generated, without waiting for the WAL file to be filled.</p> <p>Streaming replication is asynchronous by default (see <a href="../warm-standby/#SYNCHRONOUS-REPLICATION">Section 25.2.8</a>), in which case there is a small delay between committing a transaction in the primary and the changes becoming visible in the standby. This delay is however much smaller than with file-based log shipping, typically under one second assuming the standby is powerful enough to keep up with the load. With streaming replication, <code class="VARNAME">archive_timeout</code> is not required to reduce the data loss window.</p> <p>If you use streaming replication without file-based continuous archiving, the server might recycle old WAL segments before the standby has received them. If this occurs, the standby will need to be reinitialized from a new base backup. You can avoid this by setting <code class="VARNAME">wal_keep_segments</code> to a value large enough to ensure that WAL segments are not recycled too early, or by configuring a replication slot for the standby. If you set up a WAL archive that's accessible from the standby, these solutions are not required, since the standby can always use the archive to catch up provided it retains enough segments.</p> <p>To use streaming replication, set up a file-based log-shipping standby server as described in <a href="../warm-standby/">Section 25.2</a>. The step that turns a file-based log-shipping standby into streaming replication standby is setting <code class="VARNAME">primary_conninfo</code> setting in the <code class="FILENAME">recovery.conf</code> file to point to the primary server. Set <a href="../runtime-config-connection/#GUC-LISTEN-ADDRESSES">listen_addresses</a> and authentication options (see <code class="FILENAME">pg_hba.conf</code>) on the primary so that the standby server can connect to the <code class="LITERAL">replication</code> pseudo-database on the primary server (see <a href="../warm-standby/#STREAMING-REPLICATION-AUTHENTICATION">Section 25.2.5.1</a>).</p> <p>On systems that support the keepalive socket option, setting <a href="../runtime-config-connection/#GUC-TCP-KEEPALIVES-IDLE">tcp_keepalives_idle</a>, <a href="../runtime-config-connection/#GUC-TCP-KEEPALIVES-INTERVAL">tcp_keepalives_interval</a> and <a href="../runtime-config-connection/#GUC-TCP-KEEPALIVES-COUNT">tcp_keepalives_count</a> helps the primary promptly notice a broken connection.</p> <p>Set the maximum number of concurrent connections from the standby servers (see <a href="../runtime-config-replication/#GUC-MAX-WAL-SENDERS">max_wal_senders</a> for details).</p> <p>When the standby is started and <code class="VARNAME">primary_conninfo</code> is set correctly, the standby will connect to the primary after replaying all WAL files available in the archive. If the connection is established successfully, you will see a walreceiver process in the standby, and a corresponding walsender process in the primary.</p> <div class="SECT3"> <h3 class="SECT3" id="STREAMING-REPLICATION-AUTHENTICATION">25.2.5.1. Authentication</h3> <p>It is very important that the access privileges for replication be set up so that only trusted users can read the WAL stream, because it is easy to extract privileged information from it. Standby servers must authenticate to the primary as a superuser or an account that has the <code class="LITERAL">REPLICATION</code> privilege. It is recommended to create a dedicated user account with <code class="LITERAL">REPLICATION</code> and <code class="LITERAL">LOGIN</code> privileges for replication. While <code class="LITERAL">REPLICATION</code> privilege gives very high permissions, it does not allow the user to modify any data on the primary system, which the <code class="LITERAL">SUPERUSER</code> privilege does.</p> <p>Client authentication for replication is controlled by a <code class="FILENAME">pg_hba.conf</code> record specifying <code class="LITERAL">replication</code> in the <code class="REPLACEABLE c2">database</code> field. For example, if the standby is running on host IP <code class="LITERAL">192.168.1.100</code> and the account name for replication is <code class="LITERAL">foo</code>, the administrator can add the following line to the <code class="FILENAME">pg_hba.conf</code> file on the primary:</p> <pre class="PROGRAMLISTING" data-language="sql">
# Allow the user "foo" from host 192.168.1.100 to connect to the primary
# as a replication standby if the user's password is correctly supplied.
#
# TYPE  DATABASE        USER            ADDRESS                 METHOD
host    replication     foo             192.168.1.100/32        md5
</pre> <p>The host name and port number of the primary, connection user name, and password are specified in the <code class="FILENAME">recovery.conf</code> file. The password can also be set in the <code class="FILENAME">~/.pgpass</code> file on the standby (specify <code class="LITERAL">replication</code> in the <code class="REPLACEABLE c2">database</code> field). For example, if the primary is running on host IP <code class="LITERAL">192.168.1.50</code>, port <code class="LITERAL">5432</code>, the account name for replication is <code class="LITERAL">foo</code>, and the password is <code class="LITERAL">foopass</code>, the administrator can add the following line to the <code class="FILENAME">recovery.conf</code> file on the standby:</p> <pre class="PROGRAMLISTING" data-language="sql">
# The standby connects to the primary that is running on host 192.168.1.50
# and port 5432 as the user "foo" whose password is "foopass".
primary_conninfo = 'host=192.168.1.50 port=5432 user=foo password=foopass'
</pre> </div> <div class="SECT3"> <h3 class="SECT3" id="STREAMING-REPLICATION-MONITORING">25.2.5.2. Monitoring</h3> <p>An important health indicator of streaming replication is the amount of WAL records generated in the primary, but not yet applied in the standby. You can calculate this lag by comparing the current WAL write location on the primary with the last WAL location received by the standby. They can be retrieved using <code class="FUNCTION">pg_current_xlog_location</code> on the primary and the <code class="FUNCTION">pg_last_xlog_receive_location</code> on the standby, respectively (see <a href="../functions-admin/#FUNCTIONS-ADMIN-BACKUP-TABLE">Table 9-68</a> and <a href="../functions-admin/#FUNCTIONS-RECOVERY-INFO-TABLE">Table 9-69</a> for details). The last WAL receive location in the standby is also displayed in the process status of the WAL receiver process, displayed using the <code class="COMMAND">ps</code> command (see <a href="../monitoring-ps/">Section 27.1</a> for details).</p> <p>You can retrieve a list of WAL sender processes via the <a href="../monitoring-stats/#MONITORING-STATS-VIEWS-TABLE"><code class="LITERAL"> pg_stat_replication</code></a> view. Large differences between <code class="FUNCTION">pg_current_xlog_location</code> and <code class="LITERAL">sent_location</code> field might indicate that the master server is under heavy load, while differences between <code class="LITERAL">sent_location</code> and <code class="FUNCTION">pg_last_xlog_receive_location</code> on the standby might indicate network delay, or that the standby is under heavy load.</p> </div> </div> <div class="SECT2"> <h2 class="SECT2" id="STREAMING-REPLICATION-SLOTS">25.2.6. Replication Slots</h2> <p>Replication slots provide an automated way to ensure that the master does not remove WAL segments until they have been received by all standbys, and that the master does not remove rows which could cause a <a href="../hot-standby/#HOT-STANDBY-CONFLICT">recovery conflict</a> even when the standby is disconnected.</p> <p>In lieu of using replication slots, it is possible to prevent the removal of old WAL segments using <a href="../runtime-config-replication/#GUC-WAL-KEEP-SEGMENTS">wal_keep_segments</a>, or by storing the segments in an archive using <a href="../runtime-config-wal/#GUC-ARCHIVE-COMMAND">archive_command</a>. However, these methods often result in retaining more WAL segments than required, whereas replication slots retain only the number of segments known to be needed. An advantage of these methods is that they bound the space requirement for <code class="LITERAL">pg_xlog</code>; there is currently no way to do this using replication slots.</p> <p>Similarly, <a href="../runtime-config-replication/#GUC-HOT-STANDBY-FEEDBACK">hot_standby_feedback</a> and <a href="../runtime-config-replication/#GUC-VACUUM-DEFER-CLEANUP-AGE">vacuum_defer_cleanup_age</a> provide protection against relevant rows being removed by vacuum, but the former provides no protection during any time period when the standby is not connected, and the latter often needs to be set to a high value to provide adequate protection. Replication slots overcome these disadvantages.</p> <div class="SECT3"> <h3 class="SECT3" id="STREAMING-REPLICATION-SLOTS-MANIPULATION">25.2.6.1. Querying and manipulating replication slots</h3> <p>Each replication slot has a name, which can contain lower-case letters, numbers, and the underscore character.</p> <p>Existing replication slots and their state can be seen in the <a href="../view-pg-replication-slots/"><code class="STRUCTNAME">pg_replication_slots</code></a> view.</p> <p>Slots can be created and dropped either via the streaming replication protocol (see <a href="https://www.postgresql.org/docs/9.5/static/protocol-replication.html" target="_blank">Section 50.3</a>) or via SQL functions (see <a href="../functions-admin/#FUNCTIONS-REPLICATION">Section 9.26.6</a>).</p> </div> <div class="SECT3"> <h3 class="SECT3" id="STREAMING-REPLICATION-SLOTS-CONFIG">25.2.6.2. Configuration Example</h3> <p>You can create a replication slot like this:</p> <pre class="PROGRAMLISTING" data-language="sql">
postgres=# SELECT * FROM pg_create_physical_replication_slot('node_a_slot');
  slot_name  | xlog_position
-------------+---------------
 node_a_slot |

postgres=# SELECT * FROM pg_replication_slots;
  slot_name  | slot_type | datoid | database | active | xmin | restart_lsn
-------------+-----------+--------+----------+--------+------+-------------
 node_a_slot | physical  |        |          | f      |      |
(1 row)
</pre> <p>To configure the standby to use this slot, <code class="VARNAME">primary_slot_name</code> should be configured in the standby's <code class="FILENAME">recovery.conf</code>. Here is a simple example:</p> <pre class="PROGRAMLISTING" data-language="sql">
standby_mode = 'on'
primary_conninfo = 'host=192.168.1.50 port=5432 user=foo password=foopass'
primary_slot_name = 'node_a_slot'
</pre> </div> </div> <div class="SECT2"> <h2 class="SECT2" id="CASCADING-REPLICATION">25.2.7. Cascading Replication</h2> <p>The cascading replication feature allows a standby server to accept replication connections and stream WAL records to other standbys, acting as a relay. This can be used to reduce the number of direct connections to the master and also to minimize inter-site bandwidth overheads.</p> <p>A standby acting as both a receiver and a sender is known as a cascading standby. Standbys that are more directly connected to the master are known as upstream servers, while those standby servers further away are downstream servers. Cascading replication does not place limits on the number or arrangement of downstream servers, though each standby connects to only one upstream server which eventually links to a single master/primary server.</p> <p>A cascading standby sends not only WAL records received from the master but also those restored from the archive. So even if the replication connection in some upstream connection is terminated, streaming replication continues downstream for as long as new WAL records are available.</p> <p>Cascading replication is currently asynchronous. Synchronous replication (see <a href="../warm-standby/#SYNCHRONOUS-REPLICATION">Section 25.2.8</a>) settings have no effect on cascading replication at present.</p> <p>Hot Standby feedback propagates upstream, whatever the cascaded arrangement.</p> <p>If an upstream standby server is promoted to become new master, downstream servers will continue to stream from the new master if <code class="VARNAME">recovery_target_timeline</code> is set to <code class="LITERAL">'latest'</code>.</p> <p>To use cascading replication, set up the cascading standby so that it can accept replication connections (that is, set <a href="../runtime-config-replication/#GUC-MAX-WAL-SENDERS">max_wal_senders</a> and <a href="../runtime-config-replication/#GUC-HOT-STANDBY">hot_standby</a>, and configure <a href="../auth-pg-hba-conf/">host-based authentication</a>). You will also need to set <code class="VARNAME">primary_conninfo</code> in the downstream standby to point to the cascading standby.</p> </div> <div class="SECT2"> <h2 class="SECT2" id="SYNCHRONOUS-REPLICATION">25.2.8. Synchronous Replication</h2> <p><span class="PRODUCTNAME">PostgreSQL</span> streaming replication is asynchronous by default. If the primary server crashes then some transactions that were committed may not have been replicated to the standby server, causing data loss. The amount of data loss is proportional to the replication delay at the time of failover.</p> <p>Synchronous replication offers the ability to confirm that all changes made by a transaction have been transferred to one synchronous standby server. This extends the standard level of durability offered by a transaction commit. This level of protection is referred to as 2-safe replication in computer science theory.</p> <p>When requesting synchronous replication, each commit of a write transaction will wait until confirmation is received that the commit has been written to the transaction log on disk of both the primary and standby server. The only possibility that data can be lost is if both the primary and the standby suffer crashes at the same time. This can provide a much higher level of durability, though only if the sysadmin is cautious about the placement and management of the two servers. Waiting for confirmation increases the user's confidence that the changes will not be lost in the event of server crashes but it also necessarily increases the response time for the requesting transaction. The minimum wait time is the roundtrip time between primary to standby.</p> <p>Read only transactions and transaction rollbacks need not wait for replies from standby servers. Subtransaction commits do not wait for responses from standby servers, only top-level commits. Long running actions such as data loading or index building do not wait until the very final commit message. All two-phase commit actions require commit waits, including both prepare and commit.</p> <div class="SECT3"> <h3 class="SECT3" id="SYNCHRONOUS-REPLICATION-CONFIG">25.2.8.1. Basic Configuration</h3> <p>Once streaming replication has been configured, configuring synchronous replication requires only one additional configuration step: <a href="../runtime-config-replication/#GUC-SYNCHRONOUS-STANDBY-NAMES"> synchronous_standby_names</a> must be set to a non-empty value. <code class="VARNAME">synchronous_commit</code> must also be set to <code class="LITERAL">on</code>, but since this is the default value, typically no change is required. (See <a href="../runtime-config-wal/#RUNTIME-CONFIG-WAL-SETTINGS">Section 18.5.1</a> and <a href="../runtime-config-replication/#RUNTIME-CONFIG-REPLICATION-MASTER"> Section 18.6.2</a>.) This configuration will cause each commit to wait for confirmation that the standby has written the commit record to durable storage. <code class="VARNAME">synchronous_commit</code> can be set by individual users, so it can be configured in the configuration file, for particular users or databases, or dynamically by applications, in order to control the durability guarantee on a per-transaction basis.</p> <p>After a commit record has been written to disk on the primary, the WAL record is then sent to the standby. The standby sends reply messages each time a new batch of WAL data is written to disk, unless <code class="VARNAME">wal_receiver_status_interval</code> is set to zero on the standby. If the standby is the first matching standby, as specified in <code class="VARNAME">synchronous_standby_names</code> on the primary, the reply messages from that standby will be used to wake users waiting for confirmation that the commit record has been received. These parameters allow the administrator to specify which standby servers should be synchronous standbys. Note that the configuration of synchronous replication is mainly on the master. Named standbys must be directly connected to the master; the master knows nothing about downstream standby servers using cascaded replication.</p> <p>Setting <code class="VARNAME">synchronous_commit</code> to <code class="LITERAL">remote_write</code> will cause each commit to wait for confirmation that the standby has received the commit record and written it out to its own operating system, but not for the data to be flushed to disk on the standby. This setting provides a weaker guarantee of durability than <code class="LITERAL">on</code> does: the standby could lose the data in the event of an operating system crash, though not a <span class="PRODUCTNAME">PostgreSQL</span> crash. However, it's a useful setting in practice because it can decrease the response time for the transaction. Data loss could only occur if both the primary and the standby crash and the database of the primary gets corrupted at the same time.</p> <p>Users will stop waiting if a fast shutdown is requested. However, as when using asynchronous replication, the server will not fully shutdown until all outstanding WAL records are transferred to the currently connected standby servers.</p> </div> <div class="SECT3"> <h3 class="SECT3" id="SYNCHRONOUS-REPLICATION-PERFORMANCE">25.2.8.2. Planning for Performance</h3> <p>Synchronous replication usually requires carefully planned and placed standby servers to ensure applications perform acceptably. Waiting doesn't utilize system resources, but transaction locks continue to be held until the transfer is confirmed. As a result, incautious use of synchronous replication will reduce performance for database applications because of increased response times and higher contention.</p> <p><span class="PRODUCTNAME">PostgreSQL</span> allows the application developer to specify the durability level required via replication. This can be specified for the system overall, though it can also be specified for specific users or connections, or even individual transactions.</p> <p>For example, an application workload might consist of: 10% of changes are important customer details, while 90% of changes are less important data that the business can more easily survive if it is lost, such as chat messages between users.</p> <p>With synchronous replication options specified at the application level (on the primary) we can offer synchronous replication for the most important changes, without slowing down the bulk of the total workload. Application level options are an important and practical tool for allowing the benefits of synchronous replication for high performance applications.</p> <p>You should consider that the network bandwidth must be higher than the rate of generation of WAL data.</p> </div> <div class="SECT3"> <h3 class="SECT3" id="SYNCHRONOUS-REPLICATION-HA">25.2.8.3. Planning for High Availability</h3> <p>Commits made when <code class="VARNAME">synchronous_commit</code> is set to <code class="LITERAL">on</code> or <code class="LITERAL">remote_write</code> will wait until the synchronous standby responds. The response may never occur if the last, or only, standby should crash.</p> <p>The best solution for avoiding data loss is to ensure you don't lose your last remaining synchronous standby. This can be achieved by naming multiple potential synchronous standbys using <code class="VARNAME">synchronous_standby_names</code>. The first named standby will be used as the synchronous standby. Standbys listed after this will take over the role of synchronous standby if the first one should fail.</p> <p>When a standby first attaches to the primary, it will not yet be properly synchronized. This is described as <code class="LITERAL">catchup</code> mode. Once the lag between standby and primary reaches zero for the first time we move to real-time <code class="LITERAL">streaming</code> state. The catch-up duration may be long immediately after the standby has been created. If the standby is shut down, then the catch-up period will increase according to the length of time the standby has been down. The standby is only able to become a synchronous standby once it has reached <code class="LITERAL">streaming</code> state.</p> <p>If primary restarts while commits are waiting for acknowledgement, those waiting transactions will be marked fully committed once the primary database recovers. There is no way to be certain that all standbys have received all outstanding WAL data at time of the crash of the primary. Some transactions may not show as committed on the standby, even though they show as committed on the primary. The guarantee we offer is that the application will not receive explicit acknowledgement of the successful commit of a transaction until the WAL data is known to be safely received by the standby.</p> <p>If you really do lose your last standby server then you should disable <code class="VARNAME">synchronous_standby_names</code> and reload the configuration file on the primary server.</p> <p>If the primary is isolated from remaining standby servers you should fail over to the best candidate of those other remaining standby servers.</p> <p>If you need to re-create a standby server while transactions are waiting, make sure that the commands pg_start_backup() and pg_stop_backup() are run in a session with <code class="VARNAME">synchronous_commit</code> = <code class="LITERAL">off</code>, otherwise those requests will wait forever for the standby to appear.</p> </div> </div> <div class="SECT2"> <h2 class="SECT2" id="CONTINUOUS-ARCHIVING-IN-STANDBY">25.2.9. Continuous archiving in standby</h2> <p>When continuous WAL archiving is used in a standby, there are two different scenarios: the WAL archive can be shared between the primary and the standby, or the standby can have its own WAL archive. When the standby has its own WAL archive, set <code class="VARNAME">archive_mode</code> to <code class="LITERAL">always</code>, and the standby will call the archive command for every WAL segment it receives, whether it's by restoring from the archive or by streaming replication. The shared archive can be handled similarly, but the <code class="VARNAME">archive_command</code> must test if the file being archived exists already, and if the existing file has identical contents. This requires more care in the <code class="VARNAME">archive_command</code>, as it must be careful to not overwrite an existing file with different contents, but return success if the exactly same file is archived twice. And all that must be done free of race conditions, if two servers attempt to archive the same file at the same time.</p> <p>If <code class="VARNAME">archive_mode</code> is set to <code class="LITERAL">on</code>, the archiver is not enabled during recovery or standby mode. If the standby server is promoted, it will start archiving after the promotion, but will not archive any WAL it did not generate itself. To get a complete series of WAL files in the archive, you must ensure that all WAL is archived, before it reaches the standby. This is inherently true with file-based log shipping, as the standby can only restore files that are found in the archive, but not if streaming replication is enabled. When a server is not in recovery mode, there is no difference between <code class="LITERAL">on</code> and <code class="LITERAL">always</code> modes.</p> </div>  <div class="NAVFOOTER">  <table summary="Footer navigation table"> <tr> <td width="33%" align="left"><a href="../different-replication-solutions/" accesskey="P">Prev</a></td> <td width="34%" align="center"></td> <td width="33%" align="right"><a href="../warm-standby-failover/" accesskey="N">Next</a></td> </tr> <tr> <td width="33%" align="left">Comparison of Different Solutions</td> <td width="34%" align="center"><a href="https://www.postgresql.org/docs/9.5/static/high-availability.html" accesskey="U" target="_blank">Up</a></td> <td width="33%" align="right">Failover</td> </tr> </table> </div>
<div class="_attribution">
  <p class="_attribution-p">
    © 1996–2017 The PostgreSQL Global Development Group<br>Licensed under the PostgreSQL License.<br>
    <a href="https://www.postgresql.org/docs/9.5/static/warm-standby.html" class="_attribution-link" target="_blank">https://www.postgresql.org/docs/9.5/static/warm-standby.html</a>
  </p>
</div>

			</div>
		</div>
	</section>

	</div>
</body>
</html>
