
<!DOCTYPE HTML>

<html lang="en">

<head>
  <meta charset="utf-8">
  <title>Pg_upgrade - PostgreSQL 9.5 - W3cubDocs</title>
  
  <meta name="description" content="pg_upgrade (formerly called pg_migrator) allows data stored in PostgreSQL data files to be upgraded to a later PostgreSQL major version without the &hellip;">
  <meta name="keywords" content="pg, upgrade, -, postgresql, postgresql~9.5">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="http://docs.w3cub.com/postgresql~9.5/pgupgrade/">
  <link href="/favicon.png" rel="icon">
  <link type="text/css" rel="stylesheet" href="/assets/application-50364fff564ce3b6327021805f3f00e2957b441cf27f576a7dd4ff63bbc47047.css">
  <script type="text/javascript" src="/assets/application-db64bfd54ceb42be11af7995804cf4902548419ceb79d509b0b7d62c22d98e6f.js"></script>
  <script src="/json/postgresql~9.5.js"></script>
  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-71174418-1']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>


</head>

<body>
	<div class="_app">
	<header class="_header">
  
  <form class="_search">
    <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
    <a class="_search-clear"></a>
    <div class="_search-tag"></div>
  </form>
  
  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/postgresql~9.5/" class="_nav-link" title="" style="margin-left:0;">PostgreSQL 9.5</a></span>
  
  <nav class="_nav">
    <a href="/app/" class="_nav-link ">App</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		<div class="_list">
			
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<div class="_page _postgres">
				
<h1 id="PGUPGRADE"><span class="APPLICATION">pg_upgrade</span></h1> <div class="REFNAMEDIV" id="AEN99049">  <h2>Name</h2>pg_upgrade -- upgrade a <span class="PRODUCTNAME">PostgreSQL</span> server instance </div> <div class="REFSYNOPSISDIV" id="AEN99053">  <h2>Synopsis</h2> <pre>pg_upgrade -b oldbindir -B newbindir -d olddatadir -D newdatadir [option...]</pre> </div> <div class="REFSECT1" id="AEN99074">  <h2>Description</h2> <p><span class="APPLICATION">pg_upgrade</span> (formerly called <span class="APPLICATION">pg_migrator</span>) allows data stored in <span class="PRODUCTNAME">PostgreSQL</span> data files to be upgraded to a later <span class="PRODUCTNAME">PostgreSQL</span> major version without the data dump/reload typically required for major version upgrades, e.g. from 8.4.7 to the current major release of <span class="PRODUCTNAME">PostgreSQL</span>. It is not required for minor version upgrades, e.g. from 9.0.1 to 9.0.4.</p> <p>Major PostgreSQL releases regularly add new features that often change the layout of the system tables, but the internal data storage format rarely changes. <span class="APPLICATION">pg_upgrade</span> uses this fact to perform rapid upgrades by creating new system tables and simply reusing the old user data files. If a future major release ever changes the data storage format in a way that makes the old data format unreadable, <span class="APPLICATION">pg_upgrade</span> will not be usable for such upgrades. (The community will attempt to avoid such situations.)</p> <p><span class="APPLICATION">pg_upgrade</span> does its best to make sure the old and new clusters are binary-compatible, e.g. by checking for compatible compile-time settings, including 32/64-bit binaries. It is important that any external modules are also binary compatible, though this cannot be checked by <span class="APPLICATION">pg_upgrade</span>.</p> <p>pg_upgrade supports upgrades from 8.4.X and later to the current major release of <span class="PRODUCTNAME">PostgreSQL</span>, including snapshot and alpha releases.</p> </div> <div class="REFSECT1" id="AEN99090">  <h2>Options</h2> <p><span class="APPLICATION">pg_upgrade</span> accepts the following command-line arguments:</p> <div class="VARIABLELIST"> <dl> <dt>
<code class="OPTION">-b</code> <code class="REPLACEABLE c2">bindir</code><br> <code class="OPTION">--old-bindir=</code><code class="REPLACEABLE c2">bindir</code>
</dt> <dd> <p>the old PostgreSQL executable directory; environment variable <code class="ENVAR">PGBINOLD</code></p> </dd> <dt>
<code class="OPTION">-B</code> <code class="REPLACEABLE c2">bindir</code><br> <code class="OPTION">--new-bindir=</code><code class="REPLACEABLE c2">bindir</code>
</dt> <dd> <p>the new PostgreSQL executable directory; environment variable <code class="ENVAR">PGBINNEW</code></p> </dd> <dt>
<code class="OPTION">-c</code><br> <code class="OPTION">--check</code>
</dt> <dd> <p>check clusters only, don't change any data</p> </dd> <dt>
<code class="OPTION">-d</code> <code class="REPLACEABLE c2">datadir</code><br> <code class="OPTION">--old-datadir=</code><code class="REPLACEABLE c2">datadir</code>
</dt> <dd> <p>the old cluster data directory; environment variable <code class="ENVAR">PGDATAOLD</code></p> </dd> <dt>
<code class="OPTION">-D</code> <code class="REPLACEABLE c2">datadir</code><br> <code class="OPTION">--new-datadir=</code><code class="REPLACEABLE c2">datadir</code>
</dt> <dd> <p>the new cluster data directory; environment variable <code class="ENVAR">PGDATANEW</code></p> </dd> <dt>
<code class="OPTION">-j</code><br> <code class="OPTION">--jobs</code>
</dt> <dd> <p>number of simultaneous processes or threads to use</p> </dd> <dt>
<code class="OPTION">-k</code><br> <code class="OPTION">--link</code>
</dt> <dd> <p>use hard links instead of copying files to the new cluster (use junction points on Windows)</p> </dd> <dt>
<code class="OPTION">-o</code> <code class="REPLACEABLE c2">options</code><br> <code class="OPTION">--old-options</code> <code class="REPLACEABLE c2">options</code>
</dt> <dd> <p>options to be passed directly to the old <code class="COMMAND">postgres</code> command; multiple option invocations are appended</p> </dd> <dt>
<code class="OPTION">-O</code> <code class="REPLACEABLE c2">options</code><br> <code class="OPTION">--new-options</code> <code class="REPLACEABLE c2">options</code>
</dt> <dd> <p>options to be passed directly to the new <code class="COMMAND">postgres</code> command; multiple option invocations are appended</p> </dd> <dt>
<code class="OPTION">-p</code> <code class="REPLACEABLE c2">port</code><br> <code class="OPTION">--old-port=</code><code class="REPLACEABLE c2">port</code>
</dt> <dd> <p>the old cluster port number; environment variable <code class="ENVAR">PGPORTOLD</code></p> </dd> <dt>
<code class="OPTION">-P</code> <code class="REPLACEABLE c2">port</code><br> <code class="OPTION">--new-port=</code><code class="REPLACEABLE c2">port</code>
</dt> <dd> <p>the new cluster port number; environment variable <code class="ENVAR">PGPORTNEW</code></p> </dd> <dt>
<code class="OPTION">-r</code><br> <code class="OPTION">--retain</code>
</dt> <dd> <p>retain SQL and log files even after successful completion</p> </dd> <dt>
<code class="OPTION">-U</code> <code class="REPLACEABLE c2">username</code><br> <code class="OPTION">--username=</code><code class="REPLACEABLE c2">username</code>
</dt> <dd> <p>cluster's install user name; environment variable <code class="ENVAR">PGUSER</code></p> </dd> <dt>
<code class="OPTION">-v</code><br> <code class="OPTION">--verbose</code>
</dt> <dd> <p>enable verbose internal logging</p> </dd> <dt>
<code class="OPTION">-V</code><br> <code class="OPTION">--version</code>
</dt> <dd> <p>display version information, then exit</p> </dd> <dt>
<code class="OPTION">-?</code><br> <code class="OPTION">--help</code>
</dt> <dd> <p>show help, then exit</p> </dd> </dl> </div> </div> <div class="REFSECT1" id="AEN99234">  <h2>Usage</h2> <p>These are the steps to perform an upgrade with <span class="APPLICATION">pg_upgrade</span>:</p> <div class="PROCEDURE"> <ol type="1"> <li class="STEP"> <p class="c3">Optionally move the old cluster</p> <p>If you are using a version-specific installation directory, e.g. <code class="FILENAME">/opt/PostgreSQL/9.1</code>, you do not need to move the old cluster. The graphical installers all use version-specific installation directories.</p> <p>If your installation directory is not version-specific, e.g. <code class="FILENAME">/usr/local/pgsql</code>, it is necessary to move the current PostgreSQL install directory so it does not interfere with the new <span class="PRODUCTNAME">PostgreSQL</span> installation. Once the current <span class="PRODUCTNAME">PostgreSQL</span> server is shut down, it is safe to rename the PostgreSQL installation directory; assuming the old directory is <code class="FILENAME">/usr/local/pgsql</code>, you can do:</p> <pre class="PROGRAMLISTING" data-language="sql">
mv /usr/local/pgsql /usr/local/pgsql.old
</pre> <p>to rename the directory.</p> </li> <li class="STEP"> <p class="c3">For source installs, build the new version</p> <p>Build the new PostgreSQL source with <code class="COMMAND">configure</code> flags that are compatible with the old cluster. <span class="APPLICATION">pg_upgrade</span> will check <code class="COMMAND">pg_controldata</code> to make sure all settings are compatible before starting the upgrade.</p> </li> <li class="STEP"> <p class="c3">Install the new PostgreSQL binaries</p> <p>Install the new server's binaries and support files. <span class="APPLICATION">pg_upgrade</span> is included in a default installation.</p> <p>For source installs, if you wish to install the new server in a custom location, use the <code class="LITERAL">prefix</code> variable:</p> <pre class="PROGRAMLISTING" data-language="sql">
make prefix=/usr/local/pgsql.new install
</pre> </li> <li class="STEP"> <p class="c3">Initialize the new PostgreSQL cluster</p> <p>Initialize the new cluster using <code class="COMMAND">initdb</code>. Again, use compatible <code class="COMMAND">initdb</code> flags that match the old cluster. Many prebuilt installers do this step automatically. There is no need to start the new cluster.</p> </li> <li class="STEP"> <p class="c3">Install custom shared object files</p> <p>Install any custom shared object files (or DLLs) used by the old cluster into the new cluster, e.g. <code class="FILENAME">pgcrypto.so</code>, whether they are from <code class="FILENAME">contrib</code> or some other source. Do not install the schema definitions, e.g. <code class="FILENAME">pgcrypto.sql</code>, because these will be upgraded from the old cluster. Also, any custom full text search files (dictionary, synonym, thesaurus, stop words) must also be copied to the new cluster.</p> </li> <li class="STEP"> <p class="c3">Adjust authentication</p> <p><code class="COMMAND">pg_upgrade</code> will connect to the old and new servers several times, so you might want to set authentication to <code class="LITERAL">peer</code> in <code class="FILENAME">pg_hba.conf</code> or use a <code class="FILENAME">~/.pgpass</code> file (see <a href="https://www.postgresql.org/docs/9.5/static/libpq-pgpass.html" target="_blank">Section 31.15</a>).</p> </li> <li class="STEP"> <p class="c3">Stop both servers</p> <p>Make sure both database servers are stopped using, on Unix, e.g.:</p> <pre class="PROGRAMLISTING" data-language="sql">
pg_ctl -D /opt/PostgreSQL/8.4 stop
pg_ctl -D /opt/PostgreSQL/9.0 stop
</pre> <p>or on Windows, using the proper service names:</p> <pre class="PROGRAMLISTING" data-language="sql">
NET STOP postgresql-8.4
NET STOP postgresql-9.0
</pre> <p>Streaming replication and log-shipping standby servers can remain running until a later step.</p> </li> <li class="STEP"> <p class="c3">Verify standby servers</p> <p>If you are upgrading Streaming Replication and Log-Shipping standby servers, verify that the old standby servers are caught up by running <span class="APPLICATION">pg_controldata</span> against the old primary and standby clusters. Verify that the <span class="QUOTE">"Latest checkpoint location"</span> values match in all clusters. (There will be a mismatch if old standby servers were shut down before the old primary.)</p> </li> <li class="STEP"> <p class="c3">Run <span class="APPLICATION">pg_upgrade</span></p> <p>Always run the <span class="APPLICATION">pg_upgrade</span> binary of the new server, not the old one. <span class="APPLICATION">pg_upgrade</span> requires the specification of the old and new cluster's data and executable (<code class="FILENAME">bin</code>) directories. You can also specify user and port values, and whether you want the data linked instead of copied (the default).</p> <p>If you use link mode, the upgrade will be much faster (no file copying) and use less disk space, but you will not be able to access your old cluster once you start the new cluster after the upgrade. Link mode also requires that the old and new cluster data directories be in the same file system. (Tablespaces and <code class="FILENAME">pg_xlog</code> can be on different file systems.) See <code class="LITERAL">pg_upgrade --help</code> for a full list of options.</p> <p>The <code class="OPTION">--jobs</code> option allows multiple CPU cores to be used for copying/linking of files and to dump and reload database schemas in parallel; a good place to start is the maximum of the number of CPU cores and tablespaces. This option can dramatically reduce the time to upgrade a multi-database server running on a multiprocessor machine.</p> <p>For Windows users, you must be logged into an administrative account, and then start a shell as the <code class="LITERAL">postgres</code> user and set the proper path:</p> <pre class="PROGRAMLISTING" data-language="sql">
RUNAS /USER:postgres "CMD.EXE"
SET PATH=%PATH%;C:\Program Files\PostgreSQL\9.0\bin;
</pre> <p>and then run <span class="APPLICATION">pg_upgrade</span> with quoted directories, e.g.:</p> <pre class="PROGRAMLISTING" data-language="sql">
pg_upgrade.exe
        --old-datadir "C:/Program Files/PostgreSQL/8.4/data"
        --new-datadir "C:/Program Files/PostgreSQL/9.0/data"
        --old-bindir "C:/Program Files/PostgreSQL/8.4/bin"
        --new-bindir "C:/Program Files/PostgreSQL/9.0/bin"
</pre> <p>Once started, <code class="COMMAND">pg_upgrade</code> will verify the two clusters are compatible and then do the upgrade. You can use <code class="COMMAND">pg_upgrade --check</code> to perform only the checks, even if the old server is still running. <code class="COMMAND">pg_upgrade --check</code> will also outline any manual adjustments you will need to make after the upgrade. If you are going to be using link mode, you should use the <code class="OPTION">--link</code> option with <code class="OPTION">--check</code> to enable link-mode-specific checks. <code class="COMMAND">pg_upgrade</code> requires write permission in the current directory.</p> <p>Obviously, no one should be accessing the clusters during the upgrade. <span class="APPLICATION">pg_upgrade</span> defaults to running servers on port 50432 to avoid unintended client connections. You can use the same port number for both clusters when doing an upgrade because the old and new clusters will not be running at the same time. However, when checking an old running server, the old and new port numbers must be different.</p> <p>If an error occurs while restoring the database schema, <code class="COMMAND">pg_upgrade</code> will exit and you will have to revert to the old cluster as outlined in <a href="../pgupgrade/#PGUPGRADE-STEP-REVERT">step 16</a> below. To try <code class="COMMAND">pg_upgrade</code> again, you will need to modify the old cluster so the pg_upgrade schema restore succeeds. If the problem is a <code class="FILENAME">contrib</code> module, you might need to uninstall the <code class="FILENAME">contrib</code> module from the old cluster and install it in the new cluster after the upgrade, assuming the module is not being used to store user data.</p> </li> <li class="STEP"> <p class="c3">Upgrade Streaming Replication and Log-Shipping standby servers</p> <p>If you have Streaming Replication (see <a href="../warm-standby/#STREAMING-REPLICATION">Section 25.2.5</a>) or Log-Shipping (see <a href="../warm-standby/">Section 25.2</a>) standby servers, follow these steps to upgrade them. You will not be running <span class="APPLICATION">pg_upgrade</span> on the standby servers, but rather <span class="APPLICATION">rsync</span>. Do not start any servers yet.</p> <ol class="SUBSTEPS" type="a"> <li class="STEP"> <p class="c3">Install the new PostgreSQL binaries on standby servers</p> <p>Make sure the new binaries and support files are installed on all standby servers.</p> </li> <li class="STEP"> <p class="c3">Make sure the new standby data directories do <span class="emphasis EMPHASIS c4">not</span> exist</p> <p>Make sure the new standby data directories do <span class="emphasis EMPHASIS c4">not</span> exist or are empty. If <span class="APPLICATION">initdb</span> was run, delete the standby server data directories.</p> </li> <li class="STEP"> <p class="c3">Install custom shared object files</p> <p>Install the same custom shared object files on the new standbys that you installed in the new master cluster.</p> </li> <li class="STEP"> <p class="c3">Stop standby servers</p> <p>If the standby servers are still running, stop them now using the above instructions.</p> </li> <li class="STEP"> <p class="c3">Save configuration files</p> <p>Save any configuration files from the standbys you need to keep, e.g. <code class="FILENAME">postgresql.conf</code>, <code class="LITERAL">recovery.conf</code>, as these will be overwritten or removed in the next step.</p> </li> <li class="STEP"> <p class="c3">Start and stop the new master cluster</p> <p>In the new master cluster, change <code class="VARNAME">wal_level</code> to <code class="LITERAL">hot_standby</code> in the <code class="FILENAME">postgresql.conf</code> file and then start and stop the cluster.</p> </li> <li class="STEP"> <p class="c3">Run <span class="APPLICATION">rsync</span></p> <p>From a directory that is above the old and new database cluster directories, run this for each slave:</p> <pre class="PROGRAMLISTING" data-language="sql">
rsync --archive --delete --hard-links --size-only old_pgdata new_pgdata remote_dir
</pre> <p>where <code class="OPTION">old_pgdata</code> and <code class="OPTION">new_pgdata</code> are relative to the current directory, and <code class="OPTION">remote_dir</code> is <span class="emphasis EMPHASIS c4">above</span> the old and new cluster directories on the standby server. The old and new relative cluster paths must match on the master and standby server. Consult the <span class="APPLICATION">rsync</span> manual page for details on specifying the remote directory, e.g. <code class="LITERAL">standbyhost:/opt/PostgreSQL/</code>. <span class="APPLICATION">rsync</span> will be fast when <span class="APPLICATION">pg_upgrade</span>'s <code class="OPTION">--link</code> mode is used because it will create hard links on the remote server rather than transferring user data.</p> <p>If you have tablespaces, you will need to run a similar <span class="APPLICATION">rsync</span> command for each tablespace directory. If you have relocated <code class="FILENAME">pg_xlog</code> outside the data directories, <span class="APPLICATION">rsync</span> must be run on those directories too.</p> </li> <li class="STEP"> <p class="c3">Configure streaming replication and log-shipping standby servers</p> <p>Configure the servers for log shipping. (You do not need to run <code class="FUNCTION">pg_start_backup()</code> and <code class="FUNCTION">pg_stop_backup()</code> or take a file system backup as the slaves are still synchronized with the master.)</p> </li> </ol> </li> <li class="STEP"> <p class="c3">Restore <code class="FILENAME">pg_hba.conf</code></p> <p>If you modified <code class="FILENAME">pg_hba.conf</code>, restore its original settings. It might also be necessary to adjust other configuration files in the new cluster to match the old cluster, e.g. <code class="FILENAME">postgresql.conf</code>.</p> </li> <li class="STEP"> <p class="c3">Start the new server</p> <p>The new server can now be safely started, and then any <span class="APPLICATION">rsync</span>'ed standby servers.</p> </li> <li class="STEP"> <p class="c3">Post-Upgrade processing</p> <p>If any post-upgrade processing is required, pg_upgrade will issue warnings as it completes. It will also generate script files that must be run by the administrator. The script files will connect to each database that needs post-upgrade processing. Each script should be run using:</p> <pre class="PROGRAMLISTING" data-language="sql">
psql --username postgres --file script.sql postgres
</pre> <p>The scripts can be run in any order and can be deleted once they have been run.</p> <blockquote class="CAUTION"> <p><strong>Caution:</strong> In general it is unsafe to access tables referenced in rebuild scripts until the rebuild scripts have run to completion; doing so could yield incorrect results or poor performance. Tables not referenced in rebuild scripts can be accessed immediately.</p> </blockquote> </li> <li class="STEP"> <p class="c3">Statistics</p> <p>Because optimizer statistics are not transferred by <code class="COMMAND">pg_upgrade</code>, you will be instructed to run a command to regenerate that information at the end of the upgrade. You might need to set connection parameters to match your new cluster.</p> </li> <li class="STEP"> <p class="c3">Delete old cluster</p> <p>Once you are satisfied with the upgrade, you can delete the old cluster's data directories by running the script mentioned when <code class="COMMAND">pg_upgrade</code> completes. (Automatic deletion is not possible if you have user-defined tablespaces inside the old data directory.) You can also delete the old installation directories (e.g. <code class="FILENAME">bin</code>, <code class="FILENAME">share</code>).</p> </li> <li class="STEP" id="PGUPGRADE-STEP-REVERT">  <p class="c3">Reverting to old cluster</p> <p>If, after running <code class="COMMAND">pg_upgrade</code>, you wish to revert to the old cluster, there are several options:</p> <ul> <li> <p>If you ran <code class="COMMAND">pg_upgrade</code> with <code class="OPTION">--check</code>, no modifications were made to the old cluster and you can re-use it anytime.</p> </li> <li> <p>If you ran <code class="COMMAND">pg_upgrade</code> with <code class="OPTION">--link</code>, the data files are shared between the old and new cluster. If you started the new cluster, the new server has written to those shared files and it is unsafe to use the old cluster.</p> </li> <li> <p>If you ran <code class="COMMAND">pg_upgrade</code> <span class="emphasis EMPHASIS c4">without</span> <code class="OPTION">--link</code> or did not start the new server, the old cluster was not modified except that, if linking started, a <code class="LITERAL">.old</code> suffix was appended to <code class="FILENAME">$PGDATA/global/pg_control</code>. To reuse the old cluster, possibly remove the <code class="FILENAME">.old</code> suffix from <code class="FILENAME">$PGDATA/global/pg_control</code>; you can then restart the old cluster.</p> </li> </ul> </li> </ol> </div> </div> <div class="REFSECT1" id="AEN99428">  <h2>Notes</h2> <p><span class="APPLICATION">pg_upgrade</span> does not support upgrading of databases containing these <code class="TYPE">reg*</code> OID-referencing system data types: <code class="TYPE">regproc</code>, <code class="TYPE">regprocedure</code>, <code class="TYPE">regoper</code>, <code class="TYPE">regoperator</code>, <code class="TYPE">regconfig</code>, and <code class="TYPE">regdictionary</code>. (<code class="TYPE">regtype</code> can be upgraded.)</p> <p>All failure, rebuild, and reindex cases will be reported by <span class="APPLICATION">pg_upgrade</span> if they affect your installation; post-upgrade scripts to rebuild tables and indexes will be generated automatically. If you are trying to automate the upgrade of many clusters, you should find that clusters with identical database schemas require the same post-upgrade steps for all cluster upgrades; this is because the post-upgrade steps are based on the database schemas, and not user data.</p> <p>For deployment testing, create a schema-only copy of the old cluster, insert dummy data, and upgrade that.</p> <p>If you are upgrading a pre-<span class="PRODUCTNAME">PostgreSQL</span> 9.2 cluster that uses a configuration-file-only directory, you must pass the real data directory location to <span class="APPLICATION">pg_upgrade</span>, and pass the configuration directory location to the server, e.g. <code class="LITERAL">-d /real-data-directory -o '-D /configuration-directory'</code>.</p> <p>If using a pre-9.1 old server that is using a non-default Unix-domain socket directory or a default that differs from the default of the new cluster, set <code class="ENVAR">PGHOST</code> to point to the old server's socket location. (This is not relevant on Windows.)</p> <p>If you want to use link mode and you do not want your old cluster to be modified when the new cluster is started, make a copy of the old cluster and upgrade that in link mode. To make a valid copy of the old cluster, use <code class="COMMAND">rsync</code> to create a dirty copy of the old cluster while the server is running, then shut down the old server and run <code class="COMMAND">rsync --checksum</code> again to update the copy with any changes to make it consistent. (<code class="OPTION">--checksum</code> is necessary because <code class="COMMAND">rsync</code> only has file modification-time granularity of one second.) You might want to exclude some files, e.g. <code class="FILENAME">postmaster.pid</code>, as documented in <a href="../continuous-archiving/#BACKUP-LOWLEVEL-BASE-BACKUP">Section 24.3.3</a>. If your file system supports file system snapshots or copy-on-write file copies, you can use that to make a backup of the old cluster and tablespaces, though the snapshot and copies must be created simultaneously or while the database server is down.</p> </div> <div class="REFSECT1" id="AEN99456">  <h2>See Also</h2>
<a href="../app-initdb/">initdb</a>, <a href="../app-pg-ctl/"><span class="APPLICATION">pg_ctl</span></a>, <a href="../app-pgdump/">pg_dump</a>, <a href="../app-postgres/"><span class="APPLICATION">postgres</span></a> </div> <div class="NAVFOOTER">  <table summary="Footer navigation table"> <tr> <td width="33%" align="left"><a href="../pgtesttiming/" accesskey="P">Prev</a></td> <td width="34%" align="center"></td> <td width="33%" align="right"><a href="../pgxlogdump/" accesskey="N">Next</a></td> </tr> <tr> <td width="33%" align="left"><span class="APPLICATION">pg_test_timing</span></td> <td width="34%" align="center"><a href="https://www.postgresql.org/docs/9.5/static/reference-server.html" accesskey="U" target="_blank">Up</a></td> <td width="33%" align="right"><span class="APPLICATION">pg_xlogdump</span></td> </tr> </table> </div>
<div class="_attribution">
  <p class="_attribution-p">
    © 1996–2017 The PostgreSQL Global Development Group<br>Licensed under the PostgreSQL License.<br>
    <a href="https://www.postgresql.org/docs/9.5/static/pgupgrade.html" class="_attribution-link" target="_blank">https://www.postgresql.org/docs/9.5/static/pgupgrade.html</a>
  </p>
</div>

			</div>
		</div>
	</section>

	</div>
</body>
</html>
