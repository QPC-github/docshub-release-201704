
<!DOCTYPE HTML>

<html lang="en">

<head>
  <meta charset="utf-8">
  <title>Pattern Matching - PostgreSQL 9.5 - W3cubDocs</title>
  
  <meta name="description" content="There are three separate approaches to pattern matching provided by PostgreSQL&#58; the traditional SQL LIKE operator, the more recent SIMILAR TO &hellip;">
  <meta name="keywords" content="pattern, matching, -, postgresql, postgresql~9.5">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="http://docs.w3cub.com/postgresql~9.5/functions-matching/">
  <link href="/favicon.png" rel="icon">
  <link type="text/css" rel="stylesheet" href="/assets/application-50364fff564ce3b6327021805f3f00e2957b441cf27f576a7dd4ff63bbc47047.css">
  <script type="text/javascript" src="/assets/application-db64bfd54ceb42be11af7995804cf4902548419ceb79d509b0b7d62c22d98e6f.js"></script>
  <script src="/json/postgresql~9.5.js"></script>
  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-71174418-1']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>


</head>

<body>
	<div class="_app">
	<header class="_header">
  
  <form class="_search">
    <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
    <a class="_search-clear"></a>
    <div class="_search-tag"></div>
  </form>
  
  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/postgresql~9.5/" class="_nav-link" title="" style="margin-left:0;">PostgreSQL 9.5</a></span>
  
  <nav class="_nav">
    <a href="/app/" class="_nav-link ">App</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		<div class="_list">
			
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<div class="_page _postgres">
				
<h1 class="SECT1" id="FUNCTIONS-MATCHING">9.7. Pattern Matching</h1> <p>There are three separate approaches to pattern matching provided by <span class="PRODUCTNAME">PostgreSQL</span>: the traditional <acronym class="ACRONYM">SQL</acronym> <code class="FUNCTION">LIKE</code> operator, the more recent <code class="FUNCTION">SIMILAR TO</code> operator (added in SQL:1999), and <acronym class="ACRONYM">POSIX</acronym>-style regular expressions. Aside from the basic <span class="QUOTE">"does this string match this pattern?"</span> operators, functions are available to extract or replace matching substrings and to split a string at matching locations.</p> <div class="TIP"> <blockquote class="TIP"> <p><b>Tip:</b> If you have pattern matching needs that go beyond this, consider writing a user-defined function in Perl or Tcl.</p> </blockquote> </div> <blockquote class="CAUTION"> <p><strong>Caution:</strong> While most regular-expression searches can be executed very quickly, regular expressions can be contrived that take arbitrary amounts of time and memory to process. Be wary of accepting regular-expression search patterns from hostile sources. If you must do so, it is advisable to impose a statement timeout.</p>
<p>Searches using <code class="FUNCTION">SIMILAR
          TO</code> patterns have the same security hazards, since <code class="FUNCTION">SIMILAR TO</code> provides many of the same capabilities as <acronym class="ACRONYM">POSIX</acronym>-style regular expressions.</p>
<p><code class="FUNCTION">LIKE</code> searches, being much simpler than the other two options, are safer to use with possibly-hostile pattern sources.</p> </blockquote> <div class="SECT2"> <h2 class="SECT2" id="FUNCTIONS-LIKE">9.7.1. <code class="FUNCTION">LIKE</code>
</h2> <pre class="SYNOPSIS" data-language="sql">
string LIKE pattern [ESCAPE escape-character]
string NOT LIKE pattern [ESCAPE escape-character]
</pre> <p>The <code class="FUNCTION">LIKE</code> expression returns true if the <code class="REPLACEABLE c3">string</code> matches the supplied <code class="REPLACEABLE c3">pattern</code>. (As expected, the <code class="FUNCTION">NOT LIKE</code> expression returns false if <code class="FUNCTION">LIKE</code> returns true, and vice versa. An equivalent expression is <code class="LITERAL">NOT (<code class="REPLACEABLE c3">string</code> LIKE <code class="REPLACEABLE c3">pattern</code>)</code>.)</p> <p>If <code class="REPLACEABLE c3">pattern</code> does not contain percent signs or underscores, then the pattern only represents the string itself; in that case <code class="FUNCTION">LIKE</code> acts like the equals operator. An underscore (<code class="LITERAL">_</code>) in <code class="REPLACEABLE c3">pattern</code> stands for (matches) any single character; a percent sign (<code class="LITERAL">%</code>) matches any sequence of zero or more characters.</p> <p>Some examples:</p> <pre class="PROGRAMLISTING" data-language="sql">
'abc' LIKE 'abc'    <i class="LINEANNOTATION">true</i>
'abc' LIKE 'a%'     <i class="LINEANNOTATION">true</i>
'abc' LIKE '_b_'    <i class="LINEANNOTATION">true</i>
'abc' LIKE 'c'      <i class="LINEANNOTATION">false</i>
</pre> <p><code class="FUNCTION">LIKE</code> pattern matching always covers the entire string. Therefore, if it's desired to match a sequence anywhere within a string, the pattern must start and end with a percent sign.</p> <p>To match a literal underscore or percent sign without matching other characters, the respective character in <code class="REPLACEABLE c3">pattern</code> must be preceded by the escape character. The default escape character is the backslash but a different one can be selected by using the <code class="LITERAL">ESCAPE</code> clause. To match the escape character itself, write two escape characters.</p>  <blockquote class="NOTE"> <p><b>Note:</b> If you have <a href="../runtime-config-compatible/#GUC-STANDARD-CONFORMING-STRINGS"> standard_conforming_strings</a> turned off, any backslashes you write in literal string constants will need to be doubled. See <a href="../sql-syntax-lexical/#SQL-SYNTAX-STRINGS">Section 4.1.2.1</a> for more information.</p> </blockquote>  <p>It's also possible to select no escape character by writing <code class="LITERAL">ESCAPE ''</code>. This effectively disables the escape mechanism, which makes it impossible to turn off the special meaning of underscore and percent signs in the pattern.</p> <p>The key word <code class="TOKEN">ILIKE</code> can be used instead of <code class="TOKEN">LIKE</code> to make the match case-insensitive according to the active locale. This is not in the <acronym class="ACRONYM">SQL</acronym> standard but is a <span class="PRODUCTNAME">PostgreSQL</span> extension.</p> <p>The operator <code class="LITERAL">~~</code> is equivalent to <code class="FUNCTION">LIKE</code>, and <code class="LITERAL">~~*</code> corresponds to <code class="FUNCTION">ILIKE</code>. There are also <code class="LITERAL">!~~</code> and <code class="LITERAL">!~~*</code> operators that represent <code class="FUNCTION">NOT LIKE</code> and <code class="FUNCTION">NOT ILIKE</code>, respectively. All of these operators are <span class="PRODUCTNAME">PostgreSQL</span>-specific.</p> </div> <div class="SECT2"> <h2 class="SECT2" id="FUNCTIONS-SIMILARTO-REGEXP">9.7.2. <code class="FUNCTION">SIMILAR TO</code> Regular Expressions</h2> <pre class="SYNOPSIS" data-language="sql">
string SIMILAR TO pattern [ESCAPE escape-character]
string NOT SIMILAR TO pattern [ESCAPE escape-character]
</pre> <p>The <code class="FUNCTION">SIMILAR TO</code> operator returns true or false depending on whether its pattern matches the given string. It is similar to <code class="FUNCTION">LIKE</code>, except that it interprets the pattern using the SQL standard's definition of a regular expression. SQL regular expressions are a curious cross between <code class="FUNCTION">LIKE</code> notation and common regular expression notation.</p> <p>Like <code class="FUNCTION">LIKE</code>, the <code class="FUNCTION">SIMILAR TO</code> operator succeeds only if its pattern matches the entire string; this is unlike common regular expression behavior where the pattern can match any part of the string. Also like <code class="FUNCTION">LIKE</code>, <code class="FUNCTION">SIMILAR
    TO</code> uses <code class="LITERAL">_</code> and <code class="LITERAL">%</code> as wildcard characters denoting any single character and any string, respectively (these are comparable to <code class="LITERAL">.</code> and <code class="LITERAL">.*</code> in POSIX regular expressions).</p> <p>In addition to these facilities borrowed from <code class="FUNCTION">LIKE</code>, <code class="FUNCTION">SIMILAR
    TO</code> supports these pattern-matching metacharacters borrowed from POSIX regular expressions:</p> <ul> <li> <p><code class="LITERAL">|</code> denotes alternation (either of two alternatives).</p> </li> <li> <p><code class="LITERAL">*</code> denotes repetition of the previous item zero or more times.</p> </li> <li> <p><code class="LITERAL">+</code> denotes repetition of the previous item one or more times.</p> </li> <li> <p><code class="LITERAL">?</code> denotes repetition of the previous item zero or one time.</p> </li> <li> <p><code class="LITERAL">{</code><code class="REPLACEABLE c3">m</code><code class="LITERAL">}</code> denotes repetition of the previous item exactly <code class="REPLACEABLE c3">m</code> times.</p> </li> <li> <p><code class="LITERAL">{</code><code class="REPLACEABLE c3">m</code><code class="LITERAL">,}</code> denotes repetition of the previous item <code class="REPLACEABLE c3">m</code> or more times.</p> </li> <li> <p><code class="LITERAL">{</code><code class="REPLACEABLE c3">m</code><code class="LITERAL">,</code><code class="REPLACEABLE c3">n</code><code class="LITERAL">}</code> denotes repetition of the previous item at least <code class="REPLACEABLE c3">m</code> and not more than <code class="REPLACEABLE c3">n</code> times.</p> </li> <li> <p>Parentheses <code class="LITERAL">()</code> can be used to group items into a single logical item.</p> </li> <li> <p>A bracket expression <code class="LITERAL">[...]</code> specifies a character class, just as in POSIX regular expressions.</p> </li> </ul> <p>Notice that the period (<code class="LITERAL">.</code>) is not a metacharacter for <code class="FUNCTION">SIMILAR TO</code>.</p> <p>As with <code class="FUNCTION">LIKE</code>, a backslash disables the special meaning of any of these metacharacters; or a different escape character can be specified with <code class="LITERAL">ESCAPE</code>.</p> <p>Some examples:</p> <pre class="PROGRAMLISTING" data-language="sql">
'abc' SIMILAR TO 'abc'      <i class="LINEANNOTATION">true</i>
'abc' SIMILAR TO 'a'        <i class="LINEANNOTATION">false</i>
'abc' SIMILAR TO '%(b|d)%'  <i class="LINEANNOTATION">true</i>
'abc' SIMILAR TO '(b|c)%'   <i class="LINEANNOTATION">false</i>
</pre> <p>The <code class="FUNCTION">substring</code> function with three parameters, <code class="FUNCTION">substring(<code class="REPLACEABLE c3">string</code> from <code class="REPLACEABLE c3">pattern</code> for <code class="REPLACEABLE c3">escape-character</code>)</code>, provides extraction of a substring that matches an SQL regular expression pattern. As with <code class="LITERAL">SIMILAR TO</code>, the specified pattern must match the entire data string, or else the function fails and returns null. To indicate the part of the pattern that should be returned on success, the pattern must contain two occurrences of the escape character followed by a double quote (<code class="LITERAL">"</code>). The text matching the portion of the pattern between these markers is returned.</p> <p>Some examples, with <code class="LITERAL">#"</code> delimiting the return string:</p> <pre class="PROGRAMLISTING" data-language="sql">
substring('foobar' from '%#"o_b#"%' for '#')   <i class="LINEANNOTATION">oob</i>
substring('foobar' from '#"o_b#"%' for '#')    <i class="LINEANNOTATION">NULL</i>
</pre> </div> <div class="SECT2"> <h2 class="SECT2" id="FUNCTIONS-POSIX-REGEXP">9.7.3. <acronym class="ACRONYM">POSIX</acronym> Regular Expressions</h2> <p><a href="../functions-matching/#FUNCTIONS-POSIX-TABLE">Table 9-12</a> lists the available operators for pattern matching using POSIX regular expressions.</p> <div class="TABLE" id="FUNCTIONS-POSIX-TABLE">  <p class="c4">Table 9-12. Regular Expression Match Operators</p> <table class="CALSTABLE"> <col> <col> <col> <thead> <tr> <th>Operator</th> <th>Description</th> <th>Example</th> </tr> </thead> <tbody> <tr> <td><code class="LITERAL">~</code></td> <td>Matches regular expression, case sensitive</td> <td><code class="LITERAL">'thomas' ~ '.*thomas.*'</code></td> </tr> <tr> <td><code class="LITERAL">~*</code></td> <td>Matches regular expression, case insensitive</td> <td><code class="LITERAL">'thomas' ~* '.*Thomas.*'</code></td> </tr> <tr> <td><code class="LITERAL">!~</code></td> <td>Does not match regular expression, case sensitive</td> <td><code class="LITERAL">'thomas' !~ '.*Thomas.*'</code></td> </tr> <tr> <td><code class="LITERAL">!~*</code></td> <td>Does not match regular expression, case insensitive</td> <td><code class="LITERAL">'thomas' !~* '.*vadim.*'</code></td> </tr> </tbody> </table> </div> <p><acronym class="ACRONYM">POSIX</acronym> regular expressions provide a more powerful means for pattern matching than the <code class="FUNCTION">LIKE</code> and <code class="FUNCTION">SIMILAR TO</code> operators. Many Unix tools such as <code class="COMMAND">egrep</code>, <code class="COMMAND">sed</code>, or <code class="COMMAND">awk</code> use a pattern matching language that is similar to the one described here.</p> <p>A regular expression is a character sequence that is an abbreviated definition of a set of strings (a <i class="FIRSTTERM">regular set</i>). A string is said to match a regular expression if it is a member of the regular set described by the regular expression. As with <code class="FUNCTION">LIKE</code>, pattern characters match string characters exactly unless they are special characters in the regular expression language — but regular expressions use different special characters than <code class="FUNCTION">LIKE</code> does. Unlike <code class="FUNCTION">LIKE</code> patterns, a regular expression is allowed to match anywhere within a string, unless the regular expression is explicitly anchored to the beginning or end of the string.</p> <p>Some examples:</p> <pre class="PROGRAMLISTING" data-language="sql">
'abc' ~ 'abc'    <i class="LINEANNOTATION">true</i>
'abc' ~ '^a'     <i class="LINEANNOTATION">true</i>
'abc' ~ '(b|d)'  <i class="LINEANNOTATION">true</i>
'abc' ~ '^(b|c)' <i class="LINEANNOTATION">false</i>
</pre> <p>The <acronym class="ACRONYM">POSIX</acronym> pattern language is described in much greater detail below.</p> <p>The <code class="FUNCTION">substring</code> function with two parameters, <code class="FUNCTION">substring(<code class="REPLACEABLE c3">string</code> from <code class="REPLACEABLE c3">pattern</code>)</code>, provides extraction of a substring that matches a POSIX regular expression pattern. It returns null if there is no match, otherwise the portion of the text that matched the pattern. But if the pattern contains any parentheses, the portion of the text that matched the first parenthesized subexpression (the one whose left parenthesis comes first) is returned. You can put parentheses around the whole expression if you want to use parentheses within it without triggering this exception. If you need parentheses in the pattern before the subexpression you want to extract, see the non-capturing parentheses described below.</p> <p>Some examples:</p> <pre class="PROGRAMLISTING" data-language="sql">
substring('foobar' from 'o.b')     <i class="LINEANNOTATION">oob</i>
substring('foobar' from 'o(.)b')   <i class="LINEANNOTATION">o</i>
</pre> <p>The <code class="FUNCTION">regexp_replace</code> function provides substitution of new text for substrings that match POSIX regular expression patterns. It has the syntax <code class="FUNCTION">regexp_replace</code>(<code class="REPLACEABLE c3">source</code>, <code class="REPLACEABLE c3">pattern</code>, <code class="REPLACEABLE c3">replacement</code> [<span class="OPTIONAL">, <code class="REPLACEABLE c3">flags</code></span> ]). The <code class="REPLACEABLE c3">source</code> string is returned unchanged if there is no match to the <code class="REPLACEABLE c3">pattern</code>. If there is a match, the <code class="REPLACEABLE c3">source</code> string is returned with the <code class="REPLACEABLE c3">replacement</code> string substituted for the matching substring. The <code class="REPLACEABLE c3">replacement</code> string can contain <code class="LITERAL">\</code><code class="REPLACEABLE c3">n</code>, where <code class="REPLACEABLE c3">n</code> is 1 through 9, to indicate that the source substring matching the <code class="REPLACEABLE c3">n</code>'th parenthesized subexpression of the pattern should be inserted, and it can contain <code class="LITERAL">\&amp;</code> to indicate that the substring matching the entire pattern should be inserted. Write <code class="LITERAL">\\</code> if you need to put a literal backslash in the replacement text. The <code class="REPLACEABLE c3">flags</code> parameter is an optional text string containing zero or more single-letter flags that change the function's behavior. Flag <code class="LITERAL">i</code> specifies case-insensitive matching, while flag <code class="LITERAL">g</code> specifies replacement of each matching substring rather than only the first one. Supported flags (though not <code class="LITERAL">g</code>) are described in <a href="../functions-matching/#POSIX-EMBEDDED-OPTIONS-TABLE">Table 9-20</a>.</p> <p>Some examples:</p> <pre class="PROGRAMLISTING" data-language="sql">
regexp_replace('foobarbaz', 'b..', 'X')
                                   <i class="LINEANNOTATION">fooXbaz</i>
regexp_replace('foobarbaz', 'b..', 'X', 'g')
                                   <i class="LINEANNOTATION">fooXX</i>
regexp_replace('foobarbaz', 'b(..)', E'X\\1Y', 'g')
                                   <i class="LINEANNOTATION">fooXarYXazY</i>
</pre> <p>The <code class="FUNCTION">regexp_matches</code> function returns a text array of all of the captured substrings resulting from matching a POSIX regular expression pattern. It has the syntax <code class="FUNCTION">regexp_matches</code>(<code class="REPLACEABLE c3">string</code>, <code class="REPLACEABLE c3">pattern</code> [<span class="OPTIONAL">, <code class="REPLACEABLE c3">flags</code></span> ]). The function can return no rows, one row, or multiple rows (see the <code class="LITERAL">g</code> flag below). If the <code class="REPLACEABLE c3">pattern</code> does not match, the function returns no rows. If the pattern contains no parenthesized subexpressions, then each row returned is a single-element text array containing the substring matching the whole pattern. If the pattern contains parenthesized subexpressions, the function returns a text array whose <code class="REPLACEABLE c3">n</code>'th element is the substring matching the <code class="REPLACEABLE c3">n</code>'th parenthesized subexpression of the pattern (not counting <span class="QUOTE">"non-capturing"</span> parentheses; see below for details). The <code class="REPLACEABLE c3">flags</code> parameter is an optional text string containing zero or more single-letter flags that change the function's behavior. Flag <code class="LITERAL">g</code> causes the function to find each match in the string, not only the first one, and return a row for each such match. Supported flags (though not <code class="LITERAL">g</code>) are described in <a href="../functions-matching/#POSIX-EMBEDDED-OPTIONS-TABLE">Table 9-20</a>.</p> <p>Some examples:</p> <pre class="PROGRAMLISTING" data-language="sql">
SELECT regexp_matches('foobarbequebaz', '(bar)(beque)');
 regexp_matches 
----------------
 {bar,beque}
(1 row)

SELECT regexp_matches('foobarbequebazilbarfbonk', '(b[^b]+)(b[^b]+)', 'g');
 regexp_matches 
----------------
 {bar,beque}
 {bazil,barf}
(2 rows)

SELECT regexp_matches('foobarbequebaz', 'barbeque');
 regexp_matches 
----------------
 {barbeque}
(1 row)
</pre> <p>It is possible to force <code class="FUNCTION">regexp_matches()</code> to always return one row by using a sub-select; this is particularly useful in a <code class="LITERAL">SELECT</code> target list when you want all rows returned, even non-matching ones:</p> <pre class="PROGRAMLISTING" data-language="sql">
SELECT col1, (SELECT regexp_matches(col2, '(bar)(beque)')) FROM tab;
</pre> <p>The <code class="FUNCTION">regexp_split_to_table</code> function splits a string using a POSIX regular expression pattern as a delimiter. It has the syntax <code class="FUNCTION">regexp_split_to_table</code>(<code class="REPLACEABLE c3">string</code>, <code class="REPLACEABLE c3">pattern</code> [<span class="OPTIONAL">, <code class="REPLACEABLE c3">flags</code></span> ]). If there is no match to the <code class="REPLACEABLE c3">pattern</code>, the function returns the <code class="REPLACEABLE c3">string</code>. If there is at least one match, for each match it returns the text from the end of the last match (or the beginning of the string) to the beginning of the match. When there are no more matches, it returns the text from the end of the last match to the end of the string. The <code class="REPLACEABLE c3">flags</code> parameter is an optional text string containing zero or more single-letter flags that change the function's behavior. <code class="FUNCTION">regexp_split_to_table</code> supports the flags described in <a href="../functions-matching/#POSIX-EMBEDDED-OPTIONS-TABLE">Table 9-20</a>.</p> <p>The <code class="FUNCTION">regexp_split_to_array</code> function behaves the same as <code class="FUNCTION">regexp_split_to_table</code>, except that <code class="FUNCTION">regexp_split_to_array</code> returns its result as an array of <code class="TYPE">text</code>. It has the syntax <code class="FUNCTION">regexp_split_to_array</code>(<code class="REPLACEABLE c3">string</code>, <code class="REPLACEABLE c3">pattern</code> [<span class="OPTIONAL">, <code class="REPLACEABLE c3">flags</code></span> ]). The parameters are the same as for <code class="FUNCTION">regexp_split_to_table</code>.</p> <p>Some examples:</p> <pre class="PROGRAMLISTING" data-language="sql">
SELECT foo FROM regexp_split_to_table('the quick brown fox jumps over the lazy dog', E'\\s+') AS foo;
  foo   
-------
 the    
 quick  
 brown  
 fox    
 jumps 
 over   
 the    
 lazy   
 dog    
(9 rows)

SELECT regexp_split_to_array('the quick brown fox jumps over the lazy dog', E'\\s+');
              regexp_split_to_array             
-----------------------------------------------
 {the,quick,brown,fox,jumps,over,the,lazy,dog}
(1 row)

SELECT foo FROM regexp_split_to_table('the quick brown fox', E'\\s*') AS foo;
 foo 
-----
 t         
 h         
 e         
 q         
 u         
 i         
 c         
 k         
 b         
 r         
 o         
 w         
 n         
 f         
 o         
 x         
(16 rows)
</pre> <p>As the last example demonstrates, the regexp split functions ignore zero-length matches that occur at the start or end of the string or immediately after a previous match. This is contrary to the strict definition of regexp matching that is implemented by <code class="FUNCTION">regexp_matches</code>, but is usually the most convenient behavior in practice. Other software systems such as Perl use similar definitions.</p> <div class="SECT3"> <h3 class="SECT3" id="POSIX-SYNTAX-DETAILS">9.7.3.1. Regular Expression Details</h3> <p><span class="PRODUCTNAME">PostgreSQL</span>'s regular expressions are implemented using a software package written by Henry Spencer. Much of the description of regular expressions below is copied verbatim from his manual.</p> <p>Regular expressions (<acronym class="ACRONYM">RE</acronym>s), as defined in <acronym class="ACRONYM">POSIX</acronym> 1003.2, come in two forms: <i class="FIRSTTERM">extended</i> <acronym class="ACRONYM">RE</acronym>s or <acronym class="ACRONYM">ERE</acronym>s (roughly those of <code class="COMMAND">egrep</code>), and <i class="FIRSTTERM">basic</i> <acronym class="ACRONYM">RE</acronym>s or <acronym class="ACRONYM">BRE</acronym>s (roughly those of <code class="COMMAND">ed</code>). <span class="PRODUCTNAME">PostgreSQL</span> supports both forms, and also implements some extensions that are not in the POSIX standard, but have become widely used due to their availability in programming languages such as Perl and Tcl. <acronym class="ACRONYM">RE</acronym>s using these non-POSIX extensions are called <i class="FIRSTTERM">advanced</i> <acronym class="ACRONYM">RE</acronym>s or <acronym class="ACRONYM">ARE</acronym>s in this documentation. AREs are almost an exact superset of EREs, but BREs have several notational incompatibilities (as well as being much more limited). We first describe the ARE and ERE forms, noting features that apply only to AREs, and then describe how BREs differ.</p>  <blockquote class="NOTE"> <p><b>Note:</b> <span class="PRODUCTNAME">PostgreSQL</span> always initially presumes that a regular expression follows the ARE rules. However, the more limited ERE or BRE rules can be chosen by prepending an <i class="FIRSTTERM">embedded option</i> to the RE pattern, as described in <a href="../functions-matching/#POSIX-METASYNTAX">Section 9.7.3.4</a>. This can be useful for compatibility with applications that expect exactly the <acronym class="ACRONYM">POSIX</acronym> 1003.2 rules.</p> </blockquote>  <p>A regular expression is defined as one or more <i class="FIRSTTERM">branches</i>, separated by <code class="LITERAL">|</code>. It matches anything that matches one of the branches.</p> <p>A branch is zero or more <i class="FIRSTTERM">quantified atoms</i> or <i class="FIRSTTERM">constraints</i>, concatenated. It matches a match for the first, followed by a match for the second, etc; an empty branch matches the empty string.</p> <p>A quantified atom is an <i class="FIRSTTERM">atom</i> possibly followed by a single <i class="FIRSTTERM">quantifier</i>. Without a quantifier, it matches a match for the atom. With a quantifier, it can match some number of matches of the atom. An <i class="FIRSTTERM">atom</i> can be any of the possibilities shown in <a href="../functions-matching/#POSIX-ATOMS-TABLE">Table 9-13</a>. The possible quantifiers and their meanings are shown in <a href="../functions-matching/#POSIX-QUANTIFIERS-TABLE">Table 9-14</a>.</p> <p>A <i class="FIRSTTERM">constraint</i> matches an empty string, but matches only when specific conditions are met. A constraint can be used where an atom could be used, except it cannot be followed by a quantifier. The simple constraints are shown in <a href="../functions-matching/#POSIX-CONSTRAINTS-TABLE">Table 9-15</a>; some more constraints are described later.</p> <div class="TABLE" id="POSIX-ATOMS-TABLE">  <p class="c4">Table 9-13. Regular Expression Atoms</p> <table class="CALSTABLE"> <col> <col> <thead> <tr> <th>Atom</th> <th>Description</th> </tr> </thead> <tbody> <tr> <td>
<code class="LITERAL">(</code><code class="REPLACEABLE c3">re</code><code class="LITERAL">)</code>
</td> <td>(where <code class="REPLACEABLE c3">re</code> is any regular expression) matches a match for <code class="REPLACEABLE c3">re</code>, with the match noted for possible reporting</td> </tr> <tr> <td>
<code class="LITERAL">(?:</code><code class="REPLACEABLE c3">re</code><code class="LITERAL">)</code>
</td> <td>as above, but the match is not noted for reporting (a <span class="QUOTE">"non-capturing"</span> set of parentheses) (AREs only)</td> </tr> <tr> <td><code class="LITERAL">.</code></td> <td>matches any single character</td> </tr> <tr> <td>
<code class="LITERAL">[</code><code class="REPLACEABLE c3">chars</code><code class="LITERAL">]</code>
</td> <td>a <i class="FIRSTTERM">bracket expression</i>, matching any one of the <code class="REPLACEABLE c3">chars</code> (see <a href="../functions-matching/#POSIX-BRACKET-EXPRESSIONS">Section 9.7.3.2</a> for more detail)</td> </tr> <tr> <td>
<code class="LITERAL">\</code><code class="REPLACEABLE c3">k</code>
</td> <td>(where <code class="REPLACEABLE c3">k</code> is a non-alphanumeric character) matches that character taken as an ordinary character, e.g., <code class="LITERAL">\\</code> matches a backslash character</td> </tr> <tr> <td>
<code class="LITERAL">\</code><code class="REPLACEABLE c3">c</code>
</td> <td>where <code class="REPLACEABLE c3">c</code> is alphanumeric (possibly followed by other characters) is an <i class="FIRSTTERM">escape</i>, see <a href="../functions-matching/#POSIX-ESCAPE-SEQUENCES">Section 9.7.3.3</a> (AREs only; in EREs and BREs, this matches <code class="REPLACEABLE c3">c</code>)</td> </tr> <tr> <td><code class="LITERAL">{</code></td> <td>when followed by a character other than a digit, matches the left-brace character <code class="LITERAL">{</code>; when followed by a digit, it is the beginning of a <code class="REPLACEABLE c3">bound</code> (see below)</td> </tr> <tr> <td><code class="REPLACEABLE c3">x</code></td> <td>where <code class="REPLACEABLE c3">x</code> is a single character with no other significance, matches that character</td> </tr> </tbody> </table> </div> <p>An RE cannot end with a backslash (<code class="LITERAL">\</code>).</p>  <blockquote class="NOTE"> <p><b>Note:</b> If you have <a href="../runtime-config-compatible/#GUC-STANDARD-CONFORMING-STRINGS"> standard_conforming_strings</a> turned off, any backslashes you write in literal string constants will need to be doubled. See <a href="../sql-syntax-lexical/#SQL-SYNTAX-STRINGS">Section 4.1.2.1</a> for more information.</p> </blockquote>  <div class="TABLE" id="POSIX-QUANTIFIERS-TABLE">  <p class="c4">Table 9-14. Regular Expression Quantifiers</p> <table class="CALSTABLE"> <col> <col> <thead> <tr> <th>Quantifier</th> <th>Matches</th> </tr> </thead> <tbody> <tr> <td><code class="LITERAL">*</code></td> <td>a sequence of 0 or more matches of the atom</td> </tr> <tr> <td><code class="LITERAL">+</code></td> <td>a sequence of 1 or more matches of the atom</td> </tr> <tr> <td><code class="LITERAL">?</code></td> <td>a sequence of 0 or 1 matches of the atom</td> </tr> <tr> <td>
<code class="LITERAL">{</code><code class="REPLACEABLE c3">m</code><code class="LITERAL">}</code>
</td> <td>a sequence of exactly <code class="REPLACEABLE c3">m</code> matches of the atom</td> </tr> <tr> <td>
<code class="LITERAL">{</code><code class="REPLACEABLE c3">m</code><code class="LITERAL">,}</code>
</td> <td>a sequence of <code class="REPLACEABLE c3">m</code> or more matches of the atom</td> </tr> <tr> <td>
<code class="LITERAL">{</code><code class="REPLACEABLE c3">m</code><code class="LITERAL">,</code><code class="REPLACEABLE c3">n</code><code class="LITERAL">}</code>
</td> <td>a sequence of <code class="REPLACEABLE c3">m</code> through <code class="REPLACEABLE c3">n</code> (inclusive) matches of the atom; <code class="REPLACEABLE c3">m</code> cannot exceed <code class="REPLACEABLE c3">n</code>
</td> </tr> <tr> <td><code class="LITERAL">*?</code></td> <td>non-greedy version of <code class="LITERAL">*</code>
</td> </tr> <tr> <td><code class="LITERAL">+?</code></td> <td>non-greedy version of <code class="LITERAL">+</code>
</td> </tr> <tr> <td><code class="LITERAL">??</code></td> <td>non-greedy version of <code class="LITERAL">?</code>
</td> </tr> <tr> <td>
<code class="LITERAL">{</code><code class="REPLACEABLE c3">m</code><code class="LITERAL">}?</code>
</td> <td>non-greedy version of <code class="LITERAL">{</code><code class="REPLACEABLE c3">m</code><code class="LITERAL">}</code>
</td> </tr> <tr> <td>
<code class="LITERAL">{</code><code class="REPLACEABLE c3">m</code><code class="LITERAL">,}?</code>
</td> <td>non-greedy version of <code class="LITERAL">{</code><code class="REPLACEABLE c3">m</code><code class="LITERAL">,}</code>
</td> </tr> <tr> <td>
<code class="LITERAL">{</code><code class="REPLACEABLE c3">m</code><code class="LITERAL">,</code><code class="REPLACEABLE c3">n</code><code class="LITERAL">}?</code>
</td> <td>non-greedy version of <code class="LITERAL">{</code><code class="REPLACEABLE c3">m</code><code class="LITERAL">,</code><code class="REPLACEABLE c3">n</code><code class="LITERAL">}</code>
</td> </tr> </tbody> </table> </div> <p>The forms using <code class="LITERAL">{</code><code class="REPLACEABLE c3">...</code><code class="LITERAL">}</code> are known as <i class="FIRSTTERM">bounds</i>. The numbers <code class="REPLACEABLE c3">m</code> and <code class="REPLACEABLE c3">n</code> within a bound are unsigned decimal integers with permissible values from 0 to 255 inclusive.</p> <p><i class="FIRSTTERM">Non-greedy</i> quantifiers (available in AREs only) match the same possibilities as their corresponding normal (<i class="FIRSTTERM">greedy</i>) counterparts, but prefer the smallest number rather than the largest number of matches. See <a href="../functions-matching/#POSIX-MATCHING-RULES">Section 9.7.3.5</a> for more detail.</p>  <blockquote class="NOTE"> <p><b>Note:</b> A quantifier cannot immediately follow another quantifier, e.g., <code class="LITERAL">**</code> is invalid. A quantifier cannot begin an expression or subexpression or follow <code class="LITERAL">^</code> or <code class="LITERAL">|</code>.</p> </blockquote>  <div class="TABLE" id="POSIX-CONSTRAINTS-TABLE">  <p class="c4">Table 9-15. Regular Expression Constraints</p> <table class="CALSTABLE"> <col> <col> <thead> <tr> <th>Constraint</th> <th>Description</th> </tr> </thead> <tbody> <tr> <td><code class="LITERAL">^</code></td> <td>matches at the beginning of the string</td> </tr> <tr> <td><code class="LITERAL">$</code></td> <td>matches at the end of the string</td> </tr> <tr> <td>
<code class="LITERAL">(?=</code><code class="REPLACEABLE c3">re</code><code class="LITERAL">)</code>
</td> <td>
<i class="FIRSTTERM">positive lookahead</i> matches at any point where a substring matching <code class="REPLACEABLE c3">re</code> begins (AREs only)</td> </tr> <tr> <td>
<code class="LITERAL">(?!</code><code class="REPLACEABLE c3">re</code><code class="LITERAL">)</code>
</td> <td>
<i class="FIRSTTERM">negative lookahead</i> matches at any point where no substring matching <code class="REPLACEABLE c3">re</code> begins (AREs only)</td> </tr> </tbody> </table> </div> <p>Lookahead constraints cannot contain <i class="FIRSTTERM">back references</i> (see <a href="../functions-matching/#POSIX-ESCAPE-SEQUENCES">Section 9.7.3.3</a>), and all parentheses within them are considered non-capturing.</p> </div> <div class="SECT3"> <h3 class="SECT3" id="POSIX-BRACKET-EXPRESSIONS">9.7.3.2. Bracket Expressions</h3> <p>A <i class="FIRSTTERM">bracket expression</i> is a list of characters enclosed in <code class="LITERAL">[]</code>. It normally matches any single character from the list (but see below). If the list begins with <code class="LITERAL">^</code>, it matches any single character <span class="emphasis EMPHASIS c5">not</span> from the rest of the list. If two characters in the list are separated by <code class="LITERAL">-</code>, this is shorthand for the full range of characters between those two (inclusive) in the collating sequence, e.g., <code class="LITERAL">[0-9]</code> in <acronym class="ACRONYM">ASCII</acronym> matches any decimal digit. It is illegal for two ranges to share an endpoint, e.g., <code class="LITERAL">a-c-e</code>. Ranges are very collating-sequence-dependent, so portable programs should avoid relying on them.</p> <p>To include a literal <code class="LITERAL">]</code> in the list, make it the first character (after <code class="LITERAL">^</code>, if that is used). To include a literal <code class="LITERAL">-</code>, make it the first or last character, or the second endpoint of a range. To use a literal <code class="LITERAL">-</code> as the first endpoint of a range, enclose it in <code class="LITERAL">[.</code> and <code class="LITERAL">.]</code> to make it a collating element (see below). With the exception of these characters, some combinations using <code class="LITERAL">[</code> (see next paragraphs), and escapes (AREs only), all other special characters lose their special significance within a bracket expression. In particular, <code class="LITERAL">\</code> is not special when following ERE or BRE rules, though it is special (as introducing an escape) in AREs.</p> <p>Within a bracket expression, a collating element (a character, a multiple-character sequence that collates as if it were a single character, or a collating-sequence name for either) enclosed in <code class="LITERAL">[.</code> and <code class="LITERAL">.]</code> stands for the sequence of characters of that collating element. The sequence is treated as a single element of the bracket expression's list. This allows a bracket expression containing a multiple-character collating element to match more than one character, e.g., if the collating sequence includes a <code class="LITERAL">ch</code> collating element, then the RE <code class="LITERAL">[[.ch.]]*c</code> matches the first five characters of <code class="LITERAL">chchcc</code>.</p>  <blockquote class="NOTE"> <p><b>Note:</b> <span class="PRODUCTNAME">PostgreSQL</span> currently does not support multi-character collating elements. This information describes possible future behavior.</p> </blockquote>  <p>Within a bracket expression, a collating element enclosed in <code class="LITERAL">[=</code> and <code class="LITERAL">=]</code> is an <i class="FIRSTTERM">equivalence class</i>, standing for the sequences of characters of all collating elements equivalent to that one, including itself. (If there are no other equivalent collating elements, the treatment is as if the enclosing delimiters were <code class="LITERAL">[.</code> and <code class="LITERAL">.]</code>.) For example, if <code class="LITERAL">o</code> and <code class="LITERAL">^</code> are the members of an equivalence class, then <code class="LITERAL">[[=o=]]</code>, <code class="LITERAL">[[=^=]]</code>, and <code class="LITERAL">[o^]</code> are all synonymous. An equivalence class cannot be an endpoint of a range.</p> <p>Within a bracket expression, the name of a character class enclosed in <code class="LITERAL">[:</code> and <code class="LITERAL">:]</code> stands for the list of all characters belonging to that class. Standard character class names are: <code class="LITERAL">alnum</code>, <code class="LITERAL">alpha</code>, <code class="LITERAL">blank</code>, <code class="LITERAL">cntrl</code>, <code class="LITERAL">digit</code>, <code class="LITERAL">graph</code>, <code class="LITERAL">lower</code>, <code class="LITERAL">print</code>, <code class="LITERAL">punct</code>, <code class="LITERAL">space</code>, <code class="LITERAL">upper</code>, <code class="LITERAL">xdigit</code>. These stand for the character classes defined in <span class="CITEREFENTRY REFENTRYTITLE">ctype</span>. A locale can provide others. A character class cannot be used as an endpoint of a range.</p> <p>There are two special cases of bracket expressions: the bracket expressions <code class="LITERAL">[[:&lt;:]]</code> and <code class="LITERAL">[[:&gt;:]]</code> are constraints, matching empty strings at the beginning and end of a word respectively. A word is defined as a sequence of word characters that is neither preceded nor followed by word characters. A word character is an <code class="LITERAL">alnum</code> character (as defined by <span class="CITEREFENTRY REFENTRYTITLE">ctype</span>) or an underscore. This is an extension, compatible with but not specified by <acronym class="ACRONYM">POSIX</acronym> 1003.2, and should be used with caution in software intended to be portable to other systems. The constraint escapes described below are usually preferable; they are no more standard, but are easier to type.</p> </div> <div class="SECT3"> <h3 class="SECT3" id="POSIX-ESCAPE-SEQUENCES">9.7.3.3. Regular Expression Escapes</h3> <p><i class="FIRSTTERM">Escapes</i> are special sequences beginning with <code class="LITERAL">\</code> followed by an alphanumeric character. Escapes come in several varieties: character entry, class shorthands, constraint escapes, and back references. A <code class="LITERAL">\</code> followed by an alphanumeric character but not constituting a valid escape is illegal in AREs. In EREs, there are no escapes: outside a bracket expression, a <code class="LITERAL">\</code> followed by an alphanumeric character merely stands for that character as an ordinary character, and inside a bracket expression, <code class="LITERAL">\</code> is an ordinary character. (The latter is the one actual incompatibility between EREs and AREs.)</p> <p><i class="FIRSTTERM">Character-entry escapes</i> exist to make it easier to specify non-printing and other inconvenient characters in REs. They are shown in <a href="../functions-matching/#POSIX-CHARACTER-ENTRY-ESCAPES-TABLE"> Table 9-16</a>.</p> <p><i class="FIRSTTERM">Class-shorthand escapes</i> provide shorthands for certain commonly-used character classes. They are shown in <a href="../functions-matching/#POSIX-CLASS-SHORTHAND-ESCAPES-TABLE"> Table 9-17</a>.</p> <p>A <i class="FIRSTTERM">constraint escape</i> is a constraint, matching the empty string if specific conditions are met, written as an escape. They are shown in <a href="../functions-matching/#POSIX-CONSTRAINT-ESCAPES-TABLE">Table 9-18</a>.</p> <p>A <i class="FIRSTTERM">back reference</i> (<code class="LITERAL">\</code><code class="REPLACEABLE c3">n</code>) matches the same string matched by the previous parenthesized subexpression specified by the number <code class="REPLACEABLE c3">n</code> (see <a href="../functions-matching/#POSIX-CONSTRAINT-BACKREF-TABLE">Table 9-19</a>). For example, <code class="LITERAL">([bc])\1</code> matches <code class="LITERAL">bb</code> or <code class="LITERAL">cc</code> but not <code class="LITERAL">bc</code> or <code class="LITERAL">cb</code>. The subexpression must entirely precede the back reference in the RE. Subexpressions are numbered in the order of their leading parentheses. Non-capturing parentheses do not define subexpressions.</p> <div class="TABLE" id="POSIX-CHARACTER-ENTRY-ESCAPES-TABLE">  <p class="c4">Table 9-16. Regular Expression Character-entry Escapes</p> <table class="CALSTABLE"> <col> <col> <thead> <tr> <th>Escape</th> <th>Description</th> </tr> </thead> <tbody> <tr> <td><code class="LITERAL">\a</code></td> <td>alert (bell) character, as in C</td> </tr> <tr> <td><code class="LITERAL">\b</code></td> <td>backspace, as in C</td> </tr> <tr> <td><code class="LITERAL">\B</code></td> <td>synonym for backslash (<code class="LITERAL">\</code>) to help reduce the need for backslash doubling</td> </tr> <tr> <td>
<code class="LITERAL">\c</code><code class="REPLACEABLE c3">X</code>
</td> <td>(where <code class="REPLACEABLE c3">X</code> is any character) the character whose low-order 5 bits are the same as those of <code class="REPLACEABLE c3">X</code>, and whose other bits are all zero</td> </tr> <tr> <td><code class="LITERAL">\e</code></td> <td>the character whose collating-sequence name is <code class="LITERAL">ESC</code>, or failing that, the character with octal value <code class="LITERAL">033</code>
</td> </tr> <tr> <td><code class="LITERAL">\f</code></td> <td>form feed, as in C</td> </tr> <tr> <td><code class="LITERAL">\n</code></td> <td>newline, as in C</td> </tr> <tr> <td><code class="LITERAL">\r</code></td> <td>carriage return, as in C</td> </tr> <tr> <td><code class="LITERAL">\t</code></td> <td>horizontal tab, as in C</td> </tr> <tr> <td>
<code class="LITERAL">\u</code><code class="REPLACEABLE c3">wxyz</code>
</td> <td>(where <code class="REPLACEABLE c3">wxyz</code> is exactly four hexadecimal digits) the character whose hexadecimal value is <code class="LITERAL">0x</code><code class="REPLACEABLE c3">wxyz</code>
</td> </tr> <tr> <td>
<code class="LITERAL">\U</code><code class="REPLACEABLE c3">stuvwxyz</code>
</td> <td>(where <code class="REPLACEABLE c3">stuvwxyz</code> is exactly eight hexadecimal digits) the character whose hexadecimal value is <code class="LITERAL">0x</code><code class="REPLACEABLE c3">stuvwxyz</code>
</td> </tr> <tr> <td><code class="LITERAL">\v</code></td> <td>vertical tab, as in C</td> </tr> <tr> <td>
<code class="LITERAL">\x</code><code class="REPLACEABLE c3">hhh</code>
</td> <td>(where <code class="REPLACEABLE c3">hhh</code> is any sequence of hexadecimal digits) the character whose hexadecimal value is <code class="LITERAL">0x</code><code class="REPLACEABLE c3">hhh</code> (a single character no matter how many hexadecimal digits are used)</td> </tr> <tr> <td><code class="LITERAL">\0</code></td> <td>the character whose value is <code class="LITERAL">0</code> (the null byte)</td> </tr> <tr> <td>
<code class="LITERAL">\</code><code class="REPLACEABLE c3">xy</code>
</td> <td>(where <code class="REPLACEABLE c3">xy</code> is exactly two octal digits, and is not a <i class="FIRSTTERM">back reference</i>) the character whose octal value is <code class="LITERAL">0</code><code class="REPLACEABLE c3">xy</code>
</td> </tr> <tr> <td>
<code class="LITERAL">\</code><code class="REPLACEABLE c3">xyz</code>
</td> <td>(where <code class="REPLACEABLE c3">xyz</code> is exactly three octal digits, and is not a <i class="FIRSTTERM">back reference</i>) the character whose octal value is <code class="LITERAL">0</code><code class="REPLACEABLE c3">xyz</code>
</td> </tr> </tbody> </table> </div> <p>Hexadecimal digits are <code class="LITERAL">0</code>-<code class="LITERAL">9</code>, <code class="LITERAL">a</code>-<code class="LITERAL">f</code>, and <code class="LITERAL">A</code>-<code class="LITERAL">F</code>. Octal digits are <code class="LITERAL">0</code>-<code class="LITERAL">7</code>.</p> <p>Numeric character-entry escapes specifying values outside the ASCII range (0-127) have meanings dependent on the database encoding. When the encoding is UTF-8, escape values are equivalent to Unicode code points, for example <code class="LITERAL">\u1234</code> means the character <code class="LITERAL">U+1234</code>. For other multibyte encodings, character-entry escapes usually just specify the concatenation of the byte values for the character. If the escape value does not correspond to any legal character in the database encoding, no error will be raised, but it will never match any data.</p> <p>The character-entry escapes are always taken as ordinary characters. For example, <code class="LITERAL">\135</code> is <code class="LITERAL">]</code> in ASCII, but <code class="LITERAL">\135</code> does not terminate a bracket expression.</p> <div class="TABLE" id="POSIX-CLASS-SHORTHAND-ESCAPES-TABLE">  <p class="c4">Table 9-17. Regular Expression Class-shorthand Escapes</p> <table class="CALSTABLE"> <col> <col> <thead> <tr> <th>Escape</th> <th>Description</th> </tr> </thead> <tbody> <tr> <td><code class="LITERAL">\d</code></td> <td><code class="LITERAL">[[:digit:]]</code></td> </tr> <tr> <td><code class="LITERAL">\s</code></td> <td><code class="LITERAL">[[:space:]]</code></td> </tr> <tr> <td><code class="LITERAL">\w</code></td> <td>
<code class="LITERAL">[[:alnum:]_]</code> (note underscore is included)</td> </tr> <tr> <td><code class="LITERAL">\D</code></td> <td><code class="LITERAL">[^[:digit:]]</code></td> </tr> <tr> <td><code class="LITERAL">\S</code></td> <td><code class="LITERAL">[^[:space:]]</code></td> </tr> <tr> <td><code class="LITERAL">\W</code></td> <td>
<code class="LITERAL">[^[:alnum:]_]</code> (note underscore is included)</td> </tr> </tbody> </table> </div> <p>Within bracket expressions, <code class="LITERAL">\d</code>, <code class="LITERAL">\s</code>, and <code class="LITERAL">\w</code> lose their outer brackets, and <code class="LITERAL">\D</code>, <code class="LITERAL">\S</code>, and <code class="LITERAL">\W</code> are illegal. (So, for example, <code class="LITERAL">[a-c\d]</code> is equivalent to <code class="LITERAL">[a-c[:digit:]]</code>. Also, <code class="LITERAL">[a-c\D]</code>, which is equivalent to <code class="LITERAL">[a-c^[:digit:]]</code>, is illegal.)</p> <div class="TABLE" id="POSIX-CONSTRAINT-ESCAPES-TABLE">  <p class="c4">Table 9-18. Regular Expression Constraint Escapes</p> <table class="CALSTABLE"> <col> <col> <thead> <tr> <th>Escape</th> <th>Description</th> </tr> </thead> <tbody> <tr> <td><code class="LITERAL">\A</code></td> <td>matches only at the beginning of the string (see <a href="../functions-matching/#POSIX-MATCHING-RULES">Section 9.7.3.5</a> for how this differs from <code class="LITERAL">^</code>)</td> </tr> <tr> <td><code class="LITERAL">\m</code></td> <td>matches only at the beginning of a word</td> </tr> <tr> <td><code class="LITERAL">\M</code></td> <td>matches only at the end of a word</td> </tr> <tr> <td><code class="LITERAL">\y</code></td> <td>matches only at the beginning or end of a word</td> </tr> <tr> <td><code class="LITERAL">\Y</code></td> <td>matches only at a point that is not the beginning or end of a word</td> </tr> <tr> <td><code class="LITERAL">\Z</code></td> <td>matches only at the end of the string (see <a href="../functions-matching/#POSIX-MATCHING-RULES">Section 9.7.3.5</a> for how this differs from <code class="LITERAL">$</code>)</td> </tr> </tbody> </table> </div> <p>A word is defined as in the specification of <code class="LITERAL">[[:&lt;:]]</code> and <code class="LITERAL">[[:&gt;:]]</code> above. Constraint escapes are illegal within bracket expressions.</p> <div class="TABLE" id="POSIX-CONSTRAINT-BACKREF-TABLE">  <p class="c4">Table 9-19. Regular Expression Back References</p> <table class="CALSTABLE"> <col> <col> <thead> <tr> <th>Escape</th> <th>Description</th> </tr> </thead> <tbody> <tr> <td>
<code class="LITERAL">\</code><code class="REPLACEABLE c3">m</code>
</td> <td>(where <code class="REPLACEABLE c3">m</code> is a nonzero digit) a back reference to the <code class="REPLACEABLE c3">m</code>'th subexpression</td> </tr> <tr> <td>
<code class="LITERAL">\</code><code class="REPLACEABLE c3">mnn</code>
</td> <td>(where <code class="REPLACEABLE c3">m</code> is a nonzero digit, and <code class="REPLACEABLE c3">nn</code> is some more digits, and the decimal value <code class="REPLACEABLE c3">mnn</code> is not greater than the number of closing capturing parentheses seen so far) a back reference to the <code class="REPLACEABLE c3">mnn</code>'th subexpression</td> </tr> </tbody> </table> </div>  <blockquote class="NOTE"> <p><b>Note:</b> There is an inherent ambiguity between octal character-entry escapes and back references, which is resolved by the following heuristics, as hinted at above. A leading zero always indicates an octal escape. A single non-zero digit, not followed by another digit, is always taken as a back reference. A multi-digit sequence not starting with a zero is taken as a back reference if it comes after a suitable subexpression (i.e., the number is in the legal range for a back reference), and otherwise is taken as octal.</p> </blockquote>  </div> <div class="SECT3"> <h3 class="SECT3" id="POSIX-METASYNTAX">9.7.3.4. Regular Expression Metasyntax</h3> <p>In addition to the main syntax described above, there are some special forms and miscellaneous syntactic facilities available.</p> <p>An RE can begin with one of two special <i class="FIRSTTERM">director</i> prefixes. If an RE begins with <code class="LITERAL">***:</code>, the rest of the RE is taken as an ARE. (This normally has no effect in <span class="PRODUCTNAME">PostgreSQL</span>, since REs are assumed to be AREs; but it does have an effect if ERE or BRE mode had been specified by the <code class="REPLACEABLE c3">flags</code> parameter to a regex function.) If an RE begins with <code class="LITERAL">***=</code>, the rest of the RE is taken to be a literal string, with all characters considered ordinary characters.</p> <p>An ARE can begin with <i class="FIRSTTERM">embedded options</i>: a sequence <code class="LITERAL">(?</code><code class="REPLACEABLE c3">xyz</code><code class="LITERAL">)</code> (where <code class="REPLACEABLE c3">xyz</code> is one or more alphabetic characters) specifies options affecting the rest of the RE. These options override any previously determined options — in particular, they can override the case-sensitivity behavior implied by a regex operator, or the <code class="REPLACEABLE c3">flags</code> parameter to a regex function. The available option letters are shown in <a href="../functions-matching/#POSIX-EMBEDDED-OPTIONS-TABLE">Table 9-20</a>. Note that these same option letters are used in the <code class="REPLACEABLE c3">flags</code> parameters of regex functions.</p> <div class="TABLE" id="POSIX-EMBEDDED-OPTIONS-TABLE">  <p class="c4">Table 9-20. ARE Embedded-option Letters</p> <table class="CALSTABLE"> <col> <col> <thead> <tr> <th>Option</th> <th>Description</th> </tr> </thead> <tbody> <tr> <td><code class="LITERAL">b</code></td> <td>rest of RE is a BRE</td> </tr> <tr> <td><code class="LITERAL">c</code></td> <td>case-sensitive matching (overrides operator type)</td> </tr> <tr> <td><code class="LITERAL">e</code></td> <td>rest of RE is an ERE</td> </tr> <tr> <td><code class="LITERAL">i</code></td> <td>case-insensitive matching (see <a href="../functions-matching/#POSIX-MATCHING-RULES">Section 9.7.3.5</a>) (overrides operator type)</td> </tr> <tr> <td><code class="LITERAL">m</code></td> <td>historical synonym for <code class="LITERAL">n</code>
</td> </tr> <tr> <td><code class="LITERAL">n</code></td> <td>newline-sensitive matching (see <a href="../functions-matching/#POSIX-MATCHING-RULES">Section 9.7.3.5</a>)</td> </tr> <tr> <td><code class="LITERAL">p</code></td> <td>partial newline-sensitive matching (see <a href="../functions-matching/#POSIX-MATCHING-RULES">Section 9.7.3.5</a>)</td> </tr> <tr> <td><code class="LITERAL">q</code></td> <td>rest of RE is a literal (<span class="QUOTE">"quoted"</span>) string, all ordinary characters</td> </tr> <tr> <td><code class="LITERAL">s</code></td> <td>non-newline-sensitive matching (default)</td> </tr> <tr> <td><code class="LITERAL">t</code></td> <td>tight syntax (default; see below)</td> </tr> <tr> <td><code class="LITERAL">w</code></td> <td>inverse partial newline-sensitive (<span class="QUOTE">"weird"</span>) matching (see <a href="../functions-matching/#POSIX-MATCHING-RULES">Section 9.7.3.5</a>)</td> </tr> <tr> <td><code class="LITERAL">x</code></td> <td>expanded syntax (see below)</td> </tr> </tbody> </table> </div> <p>Embedded options take effect at the <code class="LITERAL">)</code> terminating the sequence. They can appear only at the start of an ARE (after the <code class="LITERAL">***:</code> director if any).</p> <p>In addition to the usual (<i class="FIRSTTERM">tight</i>) RE syntax, in which all characters are significant, there is an <i class="FIRSTTERM">expanded</i> syntax, available by specifying the embedded <code class="LITERAL">x</code> option. In the expanded syntax, white-space characters in the RE are ignored, as are all characters between a <code class="LITERAL">#</code> and the following newline (or the end of the RE). This permits paragraphing and commenting a complex RE. There are three exceptions to that basic rule:</p> <ul> <li> <p>a white-space character or <code class="LITERAL">#</code> preceded by <code class="LITERAL">\</code> is retained</p> </li> <li> <p>white space or <code class="LITERAL">#</code> within a bracket expression is retained</p> </li> <li> <p>white space and comments cannot appear within multi-character symbols, such as <code class="LITERAL">(?:</code></p> </li> </ul> <p>For this purpose, white-space characters are blank, tab, newline, and any character that belongs to the <code class="REPLACEABLE c3">space</code> character class.</p> <p>Finally, in an ARE, outside bracket expressions, the sequence <code class="LITERAL">(?#</code><code class="REPLACEABLE c3">ttt</code><code class="LITERAL">)</code> (where <code class="REPLACEABLE c3">ttt</code> is any text not containing a <code class="LITERAL">)</code>) is a comment, completely ignored. Again, this is not allowed between the characters of multi-character symbols, like <code class="LITERAL">(?:</code>. Such comments are more a historical artifact than a useful facility, and their use is deprecated; use the expanded syntax instead.</p> <p><span class="emphasis EMPHASIS c5">None</span> of these metasyntax extensions is available if an initial <code class="LITERAL">***=</code> director has specified that the user's input be treated as a literal string rather than as an RE.</p> </div> <div class="SECT3"> <h3 class="SECT3" id="POSIX-MATCHING-RULES">9.7.3.5. Regular Expression Matching Rules</h3> <p>In the event that an RE could match more than one substring of a given string, the RE matches the one starting earliest in the string. If the RE could match more than one substring starting at that point, either the longest possible match or the shortest possible match will be taken, depending on whether the RE is <i class="FIRSTTERM">greedy</i> or <i class="FIRSTTERM">non-greedy</i>.</p> <p>Whether an RE is greedy or not is determined by the following rules:</p> <ul> <li> <p>Most atoms, and all constraints, have no greediness attribute (because they cannot match variable amounts of text anyway).</p> </li> <li> <p>Adding parentheses around an RE does not change its greediness.</p> </li> <li> <p>A quantified atom with a fixed-repetition quantifier (<code class="LITERAL">{</code><code class="REPLACEABLE c3">m</code><code class="LITERAL">}</code> or <code class="LITERAL">{</code><code class="REPLACEABLE c3">m</code><code class="LITERAL">}?</code>) has the same greediness (possibly none) as the atom itself.</p> </li> <li> <p>A quantified atom with other normal quantifiers (including <code class="LITERAL">{</code><code class="REPLACEABLE c3">m</code><code class="LITERAL">,</code><code class="REPLACEABLE c3">n</code><code class="LITERAL">}</code> with <code class="REPLACEABLE c3">m</code> equal to <code class="REPLACEABLE c3">n</code>) is greedy (prefers longest match).</p> </li> <li> <p>A quantified atom with a non-greedy quantifier (including <code class="LITERAL">{</code><code class="REPLACEABLE c3">m</code><code class="LITERAL">,</code><code class="REPLACEABLE c3">n</code><code class="LITERAL">}?</code> with <code class="REPLACEABLE c3">m</code> equal to <code class="REPLACEABLE c3">n</code>) is non-greedy (prefers shortest match).</p> </li> <li> <p>A branch — that is, an RE that has no top-level <code class="LITERAL">|</code> operator — has the same greediness as the first quantified atom in it that has a greediness attribute.</p> </li> <li> <p>An RE consisting of two or more branches connected by the <code class="LITERAL">|</code> operator is always greedy.</p> </li> </ul> <p>The above rules associate greediness attributes not only with individual quantified atoms, but with branches and entire REs that contain quantified atoms. What that means is that the matching is done in such a way that the branch, or whole RE, matches the longest or shortest possible substring <span class="emphasis EMPHASIS c5">as a whole</span>. Once the length of the entire match is determined, the part of it that matches any particular subexpression is determined on the basis of the greediness attribute of that subexpression, with subexpressions starting earlier in the RE taking priority over ones starting later.</p> <p>An example of what this means:</p> <pre class="SCREEN">
SELECT SUBSTRING('XY1234Z', 'Y*([0-9]{1,3})');
<i class="LINEANNOTATION">Result: </i><samp class="COMPUTEROUTPUT">123</samp>
SELECT SUBSTRING('XY1234Z', 'Y*?([0-9]{1,3})');
<i class="LINEANNOTATION">Result: </i><samp class="COMPUTEROUTPUT">1</samp>
</pre> <p>In the first case, the RE as a whole is greedy because <code class="LITERAL">Y*</code> is greedy. It can match beginning at the <code class="LITERAL">Y</code>, and it matches the longest possible string starting there, i.e., <code class="LITERAL">Y123</code>. The output is the parenthesized part of that, or <code class="LITERAL">123</code>. In the second case, the RE as a whole is non-greedy because <code class="LITERAL">Y*?</code> is non-greedy. It can match beginning at the <code class="LITERAL">Y</code>, and it matches the shortest possible string starting there, i.e., <code class="LITERAL">Y1</code>. The subexpression <code class="LITERAL">[0-9]{1,3}</code> is greedy but it cannot change the decision as to the overall match length; so it is forced to match just <code class="LITERAL">1</code>.</p> <p>In short, when an RE contains both greedy and non-greedy subexpressions, the total match length is either as long as possible or as short as possible, according to the attribute assigned to the whole RE. The attributes assigned to the subexpressions only affect how much of that match they are allowed to <span class="QUOTE">"eat"</span> relative to each other.</p> <p>The quantifiers <code class="LITERAL">{1,1}</code> and <code class="LITERAL">{1,1}?</code> can be used to force greediness or non-greediness, respectively, on a subexpression or a whole RE. This is useful when you need the whole RE to have a greediness attribute different from what's deduced from its elements. As an example, suppose that we are trying to separate a string containing some digits into the digits and the parts before and after them. We might try to do that like this:</p> <pre class="SCREEN">
SELECT regexp_matches('abc01234xyz', '(.*)(\d+)(.*)');
<i class="LINEANNOTATION">Result: </i><samp class="COMPUTEROUTPUT">{abc0123,4,xyz}</samp>
</pre> <p>That didn't work: the first <code class="LITERAL">.*</code> is greedy so it <span class="QUOTE">"eats"</span> as much as it can, leaving the <code class="LITERAL">\d+</code> to match at the last possible place, the last digit. We might try to fix that by making it non-greedy:</p> <pre class="SCREEN">
SELECT regexp_matches('abc01234xyz', '(.*?)(\d+)(.*)');
<i class="LINEANNOTATION">Result: </i><samp class="COMPUTEROUTPUT">{abc,0,""}</samp>
</pre> <p>That didn't work either, because now the RE as a whole is non-greedy and so it ends the overall match as soon as possible. We can get what we want by forcing the RE as a whole to be greedy:</p> <pre class="SCREEN">
SELECT regexp_matches('abc01234xyz', '(?:(.*?)(\d+)(.*)){1,1}');
<i class="LINEANNOTATION">Result: </i><samp class="COMPUTEROUTPUT">{abc,01234,xyz}</samp>
</pre> <p>Controlling the RE's overall greediness separately from its components' greediness allows great flexibility in handling variable-length patterns.</p> <p>When deciding what is a longer or shorter match, match lengths are measured in characters, not collating elements. An empty string is considered longer than no match at all. For example: <code class="LITERAL">bb*</code> matches the three middle characters of <code class="LITERAL">abbbc</code>; <code class="LITERAL">(week|wee)(night|knights)</code> matches all ten characters of <code class="LITERAL">weeknights</code>; when <code class="LITERAL">(.*).*</code> is matched against <code class="LITERAL">abc</code> the parenthesized subexpression matches all three characters; and when <code class="LITERAL">(a*)*</code> is matched against <code class="LITERAL">bc</code> both the whole RE and the parenthesized subexpression match an empty string.</p> <p>If case-independent matching is specified, the effect is much as if all case distinctions had vanished from the alphabet. When an alphabetic that exists in multiple cases appears as an ordinary character outside a bracket expression, it is effectively transformed into a bracket expression containing both cases, e.g., <code class="LITERAL">x</code> becomes <code class="LITERAL">[xX]</code>. When it appears inside a bracket expression, all case counterparts of it are added to the bracket expression, e.g., <code class="LITERAL">[x]</code> becomes <code class="LITERAL">[xX]</code> and <code class="LITERAL">[^x]</code> becomes <code class="LITERAL">[^xX]</code>.</p> <p>If newline-sensitive matching is specified, <code class="LITERAL">.</code> and bracket expressions using <code class="LITERAL">^</code> will never match the newline character (so that matches will never cross newlines unless the RE explicitly arranges it) and <code class="LITERAL">^</code> and <code class="LITERAL">$</code> will match the empty string after and before a newline respectively, in addition to matching at beginning and end of string respectively. But the ARE escapes <code class="LITERAL">\A</code> and <code class="LITERAL">\Z</code> continue to match beginning or end of string <span class="emphasis EMPHASIS c5">only</span>.</p> <p>If partial newline-sensitive matching is specified, this affects <code class="LITERAL">.</code> and bracket expressions as with newline-sensitive matching, but not <code class="LITERAL">^</code> and <code class="LITERAL">$</code>.</p> <p>If inverse partial newline-sensitive matching is specified, this affects <code class="LITERAL">^</code> and <code class="LITERAL">$</code> as with newline-sensitive matching, but not <code class="LITERAL">.</code> and bracket expressions. This isn't very useful but is provided for symmetry.</p> </div> <div class="SECT3"> <h3 class="SECT3" id="POSIX-LIMITS-COMPATIBILITY">9.7.3.6. Limits and Compatibility</h3> <p>No particular limit is imposed on the length of REs in this implementation. However, programs intended to be highly portable should not employ REs longer than 256 bytes, as a POSIX-compliant implementation can refuse to accept such REs.</p> <p>The only feature of AREs that is actually incompatible with POSIX EREs is that <code class="LITERAL">\</code> does not lose its special significance inside bracket expressions. All other ARE features use syntax which is illegal or has undefined or unspecified effects in POSIX EREs; the <code class="LITERAL">***</code> syntax of directors likewise is outside the POSIX syntax for both BREs and EREs.</p> <p>Many of the ARE extensions are borrowed from Perl, but some have been changed to clean them up, and a few Perl extensions are not present. Incompatibilities of note include <code class="LITERAL">\b</code>, <code class="LITERAL">\B</code>, the lack of special treatment for a trailing newline, the addition of complemented bracket expressions to the things affected by newline-sensitive matching, the restrictions on parentheses and back references in lookahead constraints, and the longest/shortest-match (rather than first-match) matching semantics.</p> <p>Two significant incompatibilities exist between AREs and the ERE syntax recognized by pre-7.4 releases of <span class="PRODUCTNAME">PostgreSQL</span>:</p> <ul> <li> <p>In AREs, <code class="LITERAL">\</code> followed by an alphanumeric character is either an escape or an error, while in previous releases, it was just another way of writing the alphanumeric. This should not be much of a problem because there was no reason to write such a sequence in earlier releases.</p> </li> <li> <p>In AREs, <code class="LITERAL">\</code> remains a special character within <code class="LITERAL">[]</code>, so a literal <code class="LITERAL">\</code> within a bracket expression must be written <code class="LITERAL">\\</code>.</p> </li> </ul> </div> <div class="SECT3"> <h3 class="SECT3" id="POSIX-BASIC-REGEXES">9.7.3.7. Basic Regular Expressions</h3> <p>BREs differ from EREs in several respects. In BREs, <code class="LITERAL">|</code>, <code class="LITERAL">+</code>, and <code class="LITERAL">?</code> are ordinary characters and there is no equivalent for their functionality. The delimiters for bounds are <code class="LITERAL">\{</code> and <code class="LITERAL">\}</code>, with <code class="LITERAL">{</code> and <code class="LITERAL">}</code> by themselves ordinary characters. The parentheses for nested subexpressions are <code class="LITERAL">\(</code> and <code class="LITERAL">\)</code>, with <code class="LITERAL">(</code> and <code class="LITERAL">)</code> by themselves ordinary characters. <code class="LITERAL">^</code> is an ordinary character except at the beginning of the RE or the beginning of a parenthesized subexpression, <code class="LITERAL">$</code> is an ordinary character except at the end of the RE or the end of a parenthesized subexpression, and <code class="LITERAL">*</code> is an ordinary character if it appears at the beginning of the RE or the beginning of a parenthesized subexpression (after a possible leading <code class="LITERAL">^</code>). Finally, single-digit back references are available, and <code class="LITERAL">\&lt;</code> and <code class="LITERAL">\&gt;</code> are synonyms for <code class="LITERAL">[[:&lt;:]]</code> and <code class="LITERAL">[[:&gt;:]]</code> respectively; no other escapes are available in BREs.</p> </div> </div>  <div class="NAVFOOTER">  <table summary="Footer navigation table"> <tr> <td width="33%" align="left"><a href="../functions-bitstring/" accesskey="P">Prev</a></td> <td width="34%" align="center"></td> <td width="33%" align="right"><a href="../functions-formatting/" accesskey="N">Next</a></td> </tr> <tr> <td width="33%" align="left">Bit String Functions and Operators</td> <td width="34%" align="center"><a href="https://www.postgresql.org/docs/9.5/static/functions.html" accesskey="U" target="_blank">Up</a></td> <td width="33%" align="right">Data Type Formatting Functions</td> </tr> </table> </div>
<div class="_attribution">
  <p class="_attribution-p">
    © 1996–2017 The PostgreSQL Global Development Group<br>Licensed under the PostgreSQL License.<br>
    <a href="https://www.postgresql.org/docs/9.5/static/functions-matching.html" class="_attribution-link" target="_blank">https://www.postgresql.org/docs/9.5/static/functions-matching.html</a>
  </p>
</div>

			</div>
		</div>
	</section>

	</div>
</body>
</html>
