
<!DOCTYPE HTML>

<html lang="en">

<head>
  <meta charset="utf-8">
  <title>Transform - Scikit-image - W3cubDocs</title>
  
  <meta name="description" content=" Down-sample N-dimensional image by local averaging. ">
  <meta name="keywords" content="module, transform, -, scikit-image, scikit_image">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="http://docs.w3cub.com/scikit_image/api/skimage.transform/">
  <link href="/favicon.png" rel="icon">
  <link type="text/css" rel="stylesheet" href="/assets/application-50364fff564ce3b6327021805f3f00e2957b441cf27f576a7dd4ff63bbc47047.css">
  <script type="text/javascript" src="/assets/application-db64bfd54ceb42be11af7995804cf4902548419ceb79d509b0b7d62c22d98e6f.js"></script>
  <script src="/json/scikit_image.js"></script>
  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-71174418-1']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>


</head>

<body>
	<div class="_app">
	<header class="_header">
  
  <form class="_search">
    <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
    <a class="_search-clear"></a>
    <div class="_search-tag"></div>
  </form>
  
  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/scikit_image/" class="_nav-link" title="" style="margin-left:0;">scikit-image</a></span>
  
  <nav class="_nav">
    <a href="/app/" class="_nav-link ">App</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		<div class="_list">
			
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<div class="_page _sphinx">
				
<h1 id="module-transform">Module: transform</h1> <table class="longtable docutils" id="module-skimage.transform">   <tr class="row-odd">
<td>
<a class="reference internal" href="#skimage.transform.downscale_local_mean" title="skimage.transform.downscale_local_mean"><code>skimage.transform.downscale_local_mean</code></a>(...)</td> <td>Down-sample N-dimensional image by local averaging.</td> </tr> <tr class="row-even">
<td>
<a class="reference internal" href="#skimage.transform.estimate_transform" title="skimage.transform.estimate_transform"><code>skimage.transform.estimate_transform</code></a>(ttype, ...)</td> <td>Estimate 2D geometric transformation parameters.</td> </tr> <tr class="row-odd">
<td>
<a class="reference internal" href="#skimage.transform.frt2" title="skimage.transform.frt2"><code>skimage.transform.frt2</code></a>(a)</td> <td>Compute the 2-dimensional finite radon transform (FRT) for an n x n integer array.</td> </tr> <tr class="row-even">
<td>
<a class="reference internal" href="#skimage.transform.hough_circle" title="skimage.transform.hough_circle"><code>skimage.transform.hough_circle</code></a>(image, radius)</td> <td>Perform a circular Hough transform.</td> </tr> <tr class="row-odd">
<td>
<a class="reference internal" href="#skimage.transform.hough_ellipse" title="skimage.transform.hough_ellipse"><code>skimage.transform.hough_ellipse</code></a>(img[, ...])</td> <td>Perform an elliptical Hough transform.</td> </tr> <tr class="row-even">
<td>
<a class="reference internal" href="#skimage.transform.hough_line" title="skimage.transform.hough_line"><code>skimage.transform.hough_line</code></a>(img[, theta])</td> <td>Perform a straight line Hough transform.</td> </tr> <tr class="row-odd">
<td>
<a class="reference internal" href="#skimage.transform.hough_line_peaks" title="skimage.transform.hough_line_peaks"><code>skimage.transform.hough_line_peaks</code></a>(hspace, ...)</td> <td>Return peaks in hough transform.</td> </tr> <tr class="row-even">
<td>
<a class="reference internal" href="#skimage.transform.ifrt2" title="skimage.transform.ifrt2"><code>skimage.transform.ifrt2</code></a>(a)</td> <td>Compute the 2-dimensional inverse finite radon transform (iFRT) for an (n+1) x n integer array.</td> </tr> <tr class="row-odd">
<td>
<a class="reference internal" href="#skimage.transform.integral_image" title="skimage.transform.integral_image"><code>skimage.transform.integral_image</code></a>(img)</td> <td>Integral image / summed area table.</td> </tr> <tr class="row-even">
<td>
<a class="reference internal" href="#skimage.transform.integrate" title="skimage.transform.integrate"><code>skimage.transform.integrate</code></a>(ii, start, end, ...)</td> <td>Use an integral image to integrate over a given window.</td> </tr> <tr class="row-odd">
<td>
<a class="reference internal" href="#skimage.transform.iradon" title="skimage.transform.iradon"><code>skimage.transform.iradon</code></a>(radon_image[, ...])</td> <td>Inverse radon transform.</td> </tr> <tr class="row-even">
<td>
<a class="reference internal" href="#skimage.transform.iradon_sart" title="skimage.transform.iradon_sart"><code>skimage.transform.iradon_sart</code></a>(radon_image[, ...])</td> <td>Inverse radon transform</td> </tr> <tr class="row-odd">
<td>
<a class="reference internal" href="#skimage.transform.matrix_transform" title="skimage.transform.matrix_transform"><code>skimage.transform.matrix_transform</code></a>(coords, ...)</td> <td>Apply 2D matrix transform.</td> </tr> <tr class="row-even">
<td>
<a class="reference internal" href="#skimage.transform.probabilistic_hough_line" title="skimage.transform.probabilistic_hough_line"><code>skimage.transform.probabilistic_hough_line</code></a>(img)</td> <td>Return lines from a progressive probabilistic line Hough transform.</td> </tr> <tr class="row-odd">
<td>
<a class="reference internal" href="#skimage.transform.pyramid_expand" title="skimage.transform.pyramid_expand"><code>skimage.transform.pyramid_expand</code></a>(image[, ...])</td> <td>Upsample and then smooth image.</td> </tr> <tr class="row-even">
<td>
<a class="reference internal" href="#skimage.transform.pyramid_gaussian" title="skimage.transform.pyramid_gaussian"><code>skimage.transform.pyramid_gaussian</code></a>(image[, ...])</td> <td>Yield images of the Gaussian pyramid formed by the input image.</td> </tr> <tr class="row-odd">
<td>
<a class="reference internal" href="#skimage.transform.pyramid_laplacian" title="skimage.transform.pyramid_laplacian"><code>skimage.transform.pyramid_laplacian</code></a>(image[, ...])</td> <td>Yield images of the laplacian pyramid formed by the input image.</td> </tr> <tr class="row-even">
<td>
<a class="reference internal" href="#skimage.transform.pyramid_reduce" title="skimage.transform.pyramid_reduce"><code>skimage.transform.pyramid_reduce</code></a>(image[, ...])</td> <td>Smooth and then downsample image.</td> </tr> <tr class="row-odd">
<td>
<a class="reference internal" href="#skimage.transform.radon" title="skimage.transform.radon"><code>skimage.transform.radon</code></a>(image[, theta, circle])</td> <td>Calculates the radon transform of an image given specified projection angles.</td> </tr> <tr class="row-even">
<td>
<a class="reference internal" href="#skimage.transform.rescale" title="skimage.transform.rescale"><code>skimage.transform.rescale</code></a>(image, scale[, ...])</td> <td>Scale image by a certain factor.</td> </tr> <tr class="row-odd">
<td>
<a class="reference internal" href="#skimage.transform.resize" title="skimage.transform.resize"><code>skimage.transform.resize</code></a>(image, output_shape)</td> <td>Resize image to match a certain size.</td> </tr> <tr class="row-even">
<td>
<a class="reference internal" href="#skimage.transform.rotate" title="skimage.transform.rotate"><code>skimage.transform.rotate</code></a>(image, angle[, ...])</td> <td>Rotate image by a certain angle around its center.</td> </tr> <tr class="row-odd">
<td>
<a class="reference internal" href="#skimage.transform.seam_carve" title="skimage.transform.seam_carve"><code>skimage.transform.seam_carve</code></a>(img, ...[, ...])</td> <td>Carve vertical or horizontal seams off an image.</td> </tr> <tr class="row-even">
<td>
<a class="reference internal" href="#skimage.transform.swirl" title="skimage.transform.swirl"><code>skimage.transform.swirl</code></a>(image[, center, ...])</td> <td>Perform a swirl transformation.</td> </tr> <tr class="row-odd">
<td>
<a class="reference internal" href="#skimage.transform.warp" title="skimage.transform.warp"><code>skimage.transform.warp</code></a>(image[, inverse_map, ...])</td> <td>Warp an image according to a given coordinate transformation.</td> </tr> <tr class="row-even">
<td>
<a class="reference internal" href="#skimage.transform.warp_coords" title="skimage.transform.warp_coords"><code>skimage.transform.warp_coords</code></a>(coord_map, shape)</td> <td>Build the source coordinates for the output of a 2-D image warp.</td> </tr> <tr class="row-odd">
<td>
<a class="reference internal" href="#skimage.transform.AffineTransform" title="skimage.transform.AffineTransform"><code>skimage.transform.AffineTransform</code></a>([matrix, ...])</td> <td>2D affine transformation of the form:</td> </tr> <tr class="row-even">
<td>
<a class="reference internal" href="#skimage.transform.PiecewiseAffineTransform" title="skimage.transform.PiecewiseAffineTransform"><code>skimage.transform.PiecewiseAffineTransform</code></a>()</td> <td>2D piecewise affine transformation.</td> </tr> <tr class="row-odd">
<td>
<a class="reference internal" href="#skimage.transform.PolynomialTransform" title="skimage.transform.PolynomialTransform"><code>skimage.transform.PolynomialTransform</code></a>([params])</td> <td>2D transformation of the form:</td> </tr> <tr class="row-even">
<td>
<a class="reference internal" href="#skimage.transform.ProjectiveTransform" title="skimage.transform.ProjectiveTransform"><code>skimage.transform.ProjectiveTransform</code></a>([matrix])</td> <td>Matrix transformation.</td> </tr> <tr class="row-odd">
<td>
<a class="reference internal" href="#skimage.transform.SimilarityTransform" title="skimage.transform.SimilarityTransform"><code>skimage.transform.SimilarityTransform</code></a>([...])</td> <td>2D similarity transformation of the form:</td> </tr>  </table>  <h2 id="downscale-local-mean">downscale_local_mean</h2> <dl class="function"> <dt id="skimage.transform.downscale_local_mean">
<code>skimage.transform.downscale_local_mean(image, factors, cval=0, clip=True)</code> <a class="reference external" href="http://github.com/scikit-image/scikit-image/blob/v0.12.2/skimage/transform/_warps.py#L286" target="_blank"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Down-sample N-dimensional image by local averaging.</p> <p>The image is padded with <code>cval</code> if it is not perfectly divisible by the integer factors.</p> <p>In contrast to the 2-D interpolation in <code>skimage.transform.resize</code> and <code>skimage.transform.rescale</code> this function may be applied to N-dimensional images and calculates the local mean of elements in each block of size <code>factors</code> in the input image.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr class="field-odd field">
<th class="field-name">Parameters:</th>
<td class="field-body">
<p class="first"><strong>image</strong> : ndarray</p>  <p>N-dimensional input image.</p>  <p><strong>factors</strong> : array_like</p>  <p>Array containing down-sampling integer factor along each axis.</p>  <p><strong>cval</strong> : float, optional</p>  <p>Constant padding value if image is not perfectly divisible by the integer factors.</p>  </td> </tr> <tr class="field-even field">
<th class="field-name">Returns:</th>
<td class="field-body">
<p class="first"><strong>image</strong> : ndarray</p>  <p>Down-sampled image with same number of dimensions as input image.</p>  </td> </tr>  </table> <h4 class="rubric">Examples</h4> <pre data-language="python">&gt;&gt;&gt; a = np.arange(15).reshape(3, 5)
&gt;&gt;&gt; a
array([[ 0,  1,  2,  3,  4],
       [ 5,  6,  7,  8,  9],
       [10, 11, 12, 13, 14]])
&gt;&gt;&gt; downscale_local_mean(a, (2, 3))
array([[ 3.5,  4. ],
       [ 5.5,  4.5]])
</pre> </dd>
</dl>   <h2 id="estimate-transform">estimate_transform</h2> <dl class="function"> <dt id="skimage.transform.estimate_transform">
<code>skimage.transform.estimate_transform(ttype, src, dst, **kwargs)</code> <a class="reference external" href="http://github.com/scikit-image/scikit-image/blob/v0.12.2/skimage/transform/_geometric.py#L910" target="_blank"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Estimate 2D geometric transformation parameters.</p> <p>You can determine the over-, well- and under-determined parameters with the total least-squares method.</p> <p>Number of source and destination coordinates must match.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr class="field-odd field">
<th class="field-name">Parameters:</th>
<td class="field-body">
<p class="first"><strong>ttype</strong> : {‘similarity’, ‘affine’, ‘piecewise-affine’, ‘projective’, ‘polynomial’}</p>  <p>Type of transform.</p>  <p><strong>kwargs</strong> : array or int</p>  <p>Function parameters (src, dst, n, angle):</p> <pre data-language="python">NAME / TTYPE        FUNCTION PARAMETERS
'similarity'        `src, `dst`
'affine'            `src, `dst`
'piecewise-affine'  `src, `dst`
'projective'        `src, `dst`
'polynomial'        `src, `dst`, `order` (polynomial order,
                                          default order is 2)
</pre> <p>Also see examples below.</p>  </td> </tr> <tr class="field-even field">
<th class="field-name">Returns:</th>
<td class="field-body">
<p class="first"><strong>tform</strong> : <code>GeometricTransform</code></p>  <p>Transform object containing the transformation parameters and providing access to forward and inverse transformation functions.</p>  </td> </tr>  </table> <h4 class="rubric">Examples</h4> <pre data-language="python">&gt;&gt;&gt; import numpy as np
&gt;&gt;&gt; from skimage import transform as tf
</pre> <pre data-language="python">&gt;&gt;&gt; # estimate transformation parameters
&gt;&gt;&gt; src = np.array([0, 0, 10, 10]).reshape((2, 2))
&gt;&gt;&gt; dst = np.array([12, 14, 1, -20]).reshape((2, 2))
</pre> <pre data-language="python">&gt;&gt;&gt; tform = tf.estimate_transform('similarity', src, dst)
</pre> <pre data-language="python">&gt;&gt;&gt; np.allclose(tform.inverse(tform(src)), src)
True
</pre> <pre data-language="python">&gt;&gt;&gt; # warp image using the estimated transformation
&gt;&gt;&gt; from skimage import data
&gt;&gt;&gt; image = data.camera()
</pre> <pre data-language="python">&gt;&gt;&gt; warp(image, inverse_map=tform.inverse) 
</pre> <pre data-language="python">&gt;&gt;&gt; # create transformation with explicit parameters
&gt;&gt;&gt; tform2 = tf.SimilarityTransform(scale=1.1, rotation=1,
...     translation=(10, 20))
</pre> <pre data-language="python">&gt;&gt;&gt; # unite transformations, applied in order from left to right
&gt;&gt;&gt; tform3 = tform + tform2
&gt;&gt;&gt; np.allclose(tform3(src), tform2(tform(src)))
True
</pre> </dd>
</dl>   <h2 id="frt2">frt2</h2> <dl class="function"> <dt id="skimage.transform.frt2">
<code>skimage.transform.frt2(a)</code> <a class="reference external" href="http://github.com/scikit-image/scikit-image/blob/v0.12.2/skimage/transform/finite_radon_transform.py#L12" target="_blank"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Compute the 2-dimensional finite radon transform (FRT) for an n x n integer array.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr class="field-odd field">
<th class="field-name">Parameters:</th>
<td class="field-body">
<p class="first"><strong>a</strong> : array_like</p>  <p>A 2-D square n x n integer array.</p>  </td> </tr> <tr class="field-even field">
<th class="field-name">Returns:</th>
<td class="field-body">
<p class="first"><strong>FRT</strong> : 2-D ndarray</p>  <p>Finite Radon Transform array of (n+1) x n integer coefficients.</p>  </td> </tr>  </table> <div class="admonition seealso"> <p class="first admonition-title">See also</p> <dl class="last docutils"> <dt>
 <a class="reference internal" href="#skimage.transform.ifrt2" title="skimage.transform.ifrt2"><code>ifrt2</code></a>
</dt> <dd>The two-dimensional inverse FRT.</dd> </dl> </div> <h4 class="rubric">Notes</h4> <p>The FRT has a unique inverse if and only if n is prime. [FRT] The idea for this algorithm is due to Vlad Negnevitski.</p> <h4 class="rubric">References</h4> <table class="docutils citation" frame="void" id="frt" rules="none">   <tr>
<td class="label"><a class="fn-backref" href="#id1">[FRT]</a></td>
<td>A. Kingston and I. Svalbe, “Projective transforms on periodic discrete image arrays,” in P. Hawkes (Ed), Advances in Imaging and Electron Physics, 139 (2006)</td>
</tr>  </table> <h4 class="rubric">Examples</h4> <p>Generate a test image: Use a prime number for the array dimensions</p> <pre data-language="python">&gt;&gt;&gt; SIZE = 59
&gt;&gt;&gt; img = np.tri(SIZE, dtype=np.int32)
</pre> <p>Apply the Finite Radon Transform:</p> <pre data-language="python">&gt;&gt;&gt; f = frt2(img)
</pre> </dd>
</dl>   <h2 id="hough-circle">hough_circle</h2> <dl class="function"> <dt id="skimage.transform.hough_circle">
<code>skimage.transform.hough_circle(image, radius, normalize=True, full_output=False)</code> <a class="reference external" href="http://github.com/scikit-image/scikit-image/blob/v0.12.2/skimage/transform/hough_transform.py#L234" target="_blank"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Perform a circular Hough transform.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr class="field-odd field">
<th class="field-name">Parameters:</th>
<td class="field-body">
<p class="first"><strong>image</strong> : (M, N) ndarray</p>  <p>Input image with nonzero values representing edges.</p>  <p><strong>radius</strong> : scalar or sequence of scalars</p>  <p>Radii at which to compute the Hough transform. Floats are converted to integers.</p>  <p><strong>normalize</strong> : boolean, optional (default True)</p>  <p>Normalize the accumulator with the number of pixels used to draw the radius.</p>  <p><strong>full_output</strong> : boolean, optional (default False)</p>  <p>Extend the output size by twice the largest radius in order to detect centers outside the input picture.</p>  </td> </tr> <tr class="field-even field">
<th class="field-name">Returns:</th>
<td class="field-body">
<p class="first"><strong>H</strong> : 3D ndarray (radius index, (M + 2R, N + 2R) ndarray)</p>  <p>Hough transform accumulator for each radius. R designates the larger radius if full_output is True. Otherwise, R = 0.</p>  </td> </tr>  </table> <h4 class="rubric">Examples</h4> <pre data-language="python">&gt;&gt;&gt; from skimage.transform import hough_circle
&gt;&gt;&gt; from skimage.draw import circle_perimeter
&gt;&gt;&gt; img = np.zeros((100, 100), dtype=np.bool_)
&gt;&gt;&gt; rr, cc = circle_perimeter(25, 35, 23)
&gt;&gt;&gt; img[rr, cc] = 1
&gt;&gt;&gt; try_radii = np.arange(5, 50)
&gt;&gt;&gt; res = hough_circle(img, try_radii)
&gt;&gt;&gt; ridx, r, c = np.unravel_index(np.argmax(res), res.shape)
&gt;&gt;&gt; r, c, try_radii[ridx]
(25, 35, 23)
</pre> </dd>
</dl>   <h2 id="hough-ellipse">hough_ellipse</h2> <dl class="function"> <dt id="skimage.transform.hough_ellipse">
<code>skimage.transform.hough_ellipse(img, threshold=4, accuracy=1, min_size=4, max_size=None)</code> <a class="reference external" href="http://github.com/scikit-image/scikit-image/blob/v0.12.2/skimage/transform/hough_transform.py#L280" target="_blank"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Perform an elliptical Hough transform.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr class="field-odd field">
<th class="field-name">Parameters:</th>
<td class="field-body">
<p class="first"><strong>img</strong> : (M, N) ndarray</p>  <p>Input image with nonzero values representing edges.</p>  <p><strong>threshold: int, optional (default 4)</strong></p>  <p>Accumulator threshold value.</p>  <p><strong>accuracy</strong> : double, optional (default 1)</p>  <p>Bin size on the minor axis used in the accumulator.</p>  <p><strong>min_size</strong> : int, optional (default 4)</p>  <p>Minimal major axis length.</p>  <p><strong>max_size</strong> : int, optional</p>  <p>Maximal minor axis length. (default None) If None, the value is set to the half of the smaller image dimension.</p>  </td> </tr> <tr class="field-even field">
<th class="field-name">Returns:</th>
<td class="field-body">
<p class="first"><strong>result</strong> : ndarray with fields [(accumulator, y0, x0, a, b, orientation)]</p>  <p>Where <code>(yc, xc)</code> is the center, <code>(a, b)</code> the major and minor axes, respectively. The <code>orientation</code> value follows <code>skimage.draw.ellipse_perimeter</code> convention.</p>  </td> </tr>  </table> <h4 class="rubric">Notes</h4> <p>The accuracy must be chosen to produce a peak in the accumulator distribution. In other words, a flat accumulator distribution with low values may be caused by a too low bin size.</p> <h4 class="rubric">References</h4> <table class="docutils citation" frame="void" id="r367" rules="none">   <tr>
<td class="label"><a class="fn-backref" href="#id2">[R367]</a></td>
<td>Xie, Yonghong, and Qiang Ji. “A new efficient ellipse detection method.” Pattern Recognition, 2002. Proceedings. 16th International Conference on. Vol. 2. IEEE, 2002</td>
</tr>  </table> <h4 class="rubric">Examples</h4> <pre data-language="python">&gt;&gt;&gt; from skimage.transform import hough_ellipse
&gt;&gt;&gt; from skimage.draw import ellipse_perimeter
&gt;&gt;&gt; img = np.zeros((25, 25), dtype=np.uint8)
&gt;&gt;&gt; rr, cc = ellipse_perimeter(10, 10, 6, 8)
&gt;&gt;&gt; img[cc, rr] = 1
&gt;&gt;&gt; result = hough_ellipse(img, threshold=8)
&gt;&gt;&gt; result.tolist()
[(10, 10.0, 10.0, 8.0, 6.0, 0.0)]
</pre> </dd>
</dl>   <h2 id="hough-line">hough_line</h2> <dl class="function"> <dt id="skimage.transform.hough_line">
<code>skimage.transform.hough_line(img, theta=None)</code> <a class="reference external" href="http://github.com/scikit-image/scikit-image/blob/v0.12.2/skimage/transform/hough_transform.py#L11" target="_blank"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Perform a straight line Hough transform.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr class="field-odd field">
<th class="field-name">Parameters:</th>
<td class="field-body">
<p class="first"><strong>img</strong> : (M, N) ndarray</p>  <p>Input image with nonzero values representing edges.</p>  <p><strong>theta</strong> : 1D ndarray of double</p>  <p>Angles at which to compute the transform, in radians. Defaults to -pi/2 .. pi/2</p>  </td> </tr> <tr class="field-even field">
<th class="field-name">Returns:</th>
<td class="field-body">
<p class="first"><strong>H</strong> : 2-D ndarray of uint64</p>  <p>Hough transform accumulator.</p>  <p><strong>theta</strong> : ndarray</p>  <p>Angles at which the transform was computed, in radians.</p>  <p><strong>distances</strong> : ndarray</p>  <p>Distance values.</p>  </td> </tr>  </table> <h4 class="rubric">Notes</h4> <p>The origin is the top left corner of the original image. X and Y axis are horizontal and vertical edges respectively. The distance is the minimal algebraic distance from the origin to the detected line.</p> <h4 class="rubric">Examples</h4> <p>Generate a test image:</p> <pre data-language="python">&gt;&gt;&gt; img = np.zeros((100, 150), dtype=bool)
&gt;&gt;&gt; img[30, :] = 1
&gt;&gt;&gt; img[:, 65] = 1
&gt;&gt;&gt; img[35:45, 35:50] = 1
&gt;&gt;&gt; for i in range(90):
...     img[i, i] = 1
&gt;&gt;&gt; img += np.random.random(img.shape) &gt; 0.95
</pre> <p>Apply the Hough transform:</p> <pre data-language="python">&gt;&gt;&gt; out, angles, d = hough_line(img)
</pre> <pre data-language="python">import numpy as np
import matplotlib.pyplot as plt

from skimage.transform import hough_line
from skimage.draw import line

img = np.zeros((100, 150), dtype=bool)
img[30, :] = 1
img[:, 65] = 1
img[35:45, 35:50] = 1
rr, cc = line(60, 130, 80, 10)
img[rr, cc] = 1
img += np.random.random(img.shape) &gt; 0.95

out, angles, d = hough_line(img)

plt.subplot(1, 2, 1)

plt.imshow(img, cmap=plt.cm.gray)
plt.title('Input image')

plt.subplot(1, 2, 2)
plt.imshow(out, cmap=plt.cm.bone,
           extent=(np.rad2deg(angles[-1]), np.rad2deg(angles[0]),
                   d[-1], d[0]))
plt.title('Hough transform')
plt.xlabel('Angle (degree)')
plt.ylabel('Distance (pixel)')

plt.subplots_adjust(wspace=0.4)
plt.show()
</pre> <p>(<a class="reference external" href="http://scikit-image.org/docs/0.12.x/plots/hough_tf.py" target="_blank">Source code</a>, <a class="reference external" href="http://scikit-image.org/docs/0.12.x/plots/hough_tf.png" target="_blank">png</a>, <a class="reference external" href="http://scikit-image.org/docs/0.12.x/plots/hough_tf.pdf" target="_blank">pdf</a>)</p> <div class="figure"> <img alt="../_images/hough_tf.png" src="http://scikit-image.org/docs/0.12.x/_images/hough_tf.png"> </div> </dd>
</dl>   <h2 id="hough-line-peaks">hough_line_peaks</h2> <dl class="function"> <dt id="skimage.transform.hough_line_peaks">
<code>skimage.transform.hough_line_peaks(hspace, angles, dists, min_distance=9, min_angle=10, threshold=None, num_peaks=inf)</code> <a class="reference external" href="http://github.com/scikit-image/scikit-image/blob/v0.12.2/skimage/transform/hough_transform.py#L67" target="_blank"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Return peaks in hough transform.</p> <p>Identifies most prominent lines separated by a certain angle and distance in a hough transform. Non-maximum suppression with different sizes is applied separately in the first (distances) and second (angles) dimension of the hough space to identify peaks.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr class="field-odd field">
<th class="field-name">Parameters:</th>
<td class="field-body">
<p class="first"><strong>hspace</strong> : (N, M) array</p>  <p>Hough space returned by the <code>hough_line</code> function.</p>  <p><strong>angles</strong> : (M,) array</p>  <p>Angles returned by the <code>hough_line</code> function. Assumed to be continuous. (<code>angles[-1] - angles[0] == PI</code>).</p>  <p><strong>dists</strong> : (N, ) array</p>  <p>Distances returned by the <code>hough_line</code> function.</p>  <p><strong>min_distance</strong> : int</p>  <p>Minimum distance separating lines (maximum filter size for first dimension of hough space).</p>  <p><strong>min_angle</strong> : int</p>  <p>Minimum angle separating lines (maximum filter size for second dimension of hough space).</p>  <p><strong>threshold</strong> : float</p>  <p>Minimum intensity of peaks. Default is <code>0.5 * max(hspace)</code>.</p>  <p><strong>num_peaks</strong> : int</p>  <p>Maximum number of peaks. When the number of peaks exceeds <code>num_peaks</code>, return <code>num_peaks</code> coordinates based on peak intensity.</p>  </td> </tr> <tr class="field-even field">
<th class="field-name">Returns:</th>
<td class="field-body">
<p class="first"><strong>hspace, angles, dists</strong> : tuple of array</p>  <p>Peak values in hough space, angles and distances.</p>  </td> </tr>  </table> <h4 class="rubric">Examples</h4> <pre data-language="python">&gt;&gt;&gt; from skimage.transform import hough_line, hough_line_peaks
&gt;&gt;&gt; from skimage.draw import line
&gt;&gt;&gt; img = np.zeros((15, 15), dtype=np.bool_)
&gt;&gt;&gt; rr, cc = line(0, 0, 14, 14)
&gt;&gt;&gt; img[rr, cc] = 1
&gt;&gt;&gt; rr, cc = line(0, 14, 14, 0)
&gt;&gt;&gt; img[cc, rr] = 1
&gt;&gt;&gt; hspace, angles, dists = hough_line(img)
&gt;&gt;&gt; hspace, angles, dists = hough_line_peaks(hspace, angles, dists)
&gt;&gt;&gt; len(angles)
2
</pre> </dd>
</dl>   <h2 id="ifrt2">ifrt2</h2> <dl class="function"> <dt id="skimage.transform.ifrt2">
<code>skimage.transform.ifrt2(a)</code> <a class="reference external" href="http://github.com/scikit-image/scikit-image/blob/v0.12.2/skimage/transform/finite_radon_transform.py#L71" target="_blank"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Compute the 2-dimensional inverse finite radon transform (iFRT) for an (n+1) x n integer array.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr class="field-odd field">
<th class="field-name">Parameters:</th>
<td class="field-body">
<p class="first"><strong>a</strong> : array_like</p>  <p>A 2-D (n+1) row x n column integer array.</p>  </td> </tr> <tr class="field-even field">
<th class="field-name">Returns:</th>
<td class="field-body">
<p class="first"><strong>iFRT</strong> : 2-D n x n ndarray</p>  <p>Inverse Finite Radon Transform array of n x n integer coefficients.</p>  </td> </tr>  </table> <div class="admonition seealso"> <p class="first admonition-title">See also</p> <dl class="last docutils"> <dt>
 <a class="reference internal" href="#skimage.transform.frt2" title="skimage.transform.frt2"><code>frt2</code></a>
</dt> <dd>The two-dimensional FRT</dd> </dl> </div> <h4 class="rubric">Notes</h4> <p>The FRT has a unique inverse if and only if n is prime. See <a class="reference internal" href="#r368" id="id3">[R368]</a> for an overview. The idea for this algorithm is due to Vlad Negnevitski.</p> <h4 class="rubric">References</h4> <table class="docutils citation" frame="void" id="r368" rules="none">   <tr>
<td class="label">[R368]</td>
<td>
<em>(<a class="fn-backref" href="#id3">1</a>, <a class="fn-backref" href="#id4">2</a>)</em> A. Kingston and I. Svalbe, “Projective transforms on periodic discrete image arrays,” in P. Hawkes (Ed), Advances in Imaging and Electron Physics, 139 (2006)</td>
</tr>  </table> <h4 class="rubric">Examples</h4> <pre data-language="python">&gt;&gt;&gt; SIZE = 59
&gt;&gt;&gt; img = np.tri(SIZE, dtype=np.int32)
</pre> <p>Apply the Finite Radon Transform:</p> <pre data-language="python">&gt;&gt;&gt; f = frt2(img)
</pre> <p>Apply the Inverse Finite Radon Transform to recover the input</p> <pre data-language="python">&gt;&gt;&gt; fi = ifrt2(f)
</pre> <p>Check that it’s identical to the original</p> <pre data-language="python">&gt;&gt;&gt; assert len(np.nonzero(img-fi)[0]) == 0
</pre> </dd>
</dl>   <h2 id="integral-image">integral_image</h2> <dl class="function"> <dt id="skimage.transform.integral_image">
<code>skimage.transform.integral_image(img)</code> <a class="reference external" href="http://github.com/scikit-image/scikit-image/blob/v0.12.2/skimage/transform/integral.py#L7" target="_blank"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Integral image / summed area table.</p> <p>The integral image contains the sum of all elements above and to the left of it, i.e.:</p> <div class="math"> <p><img src="http://scikit-image.org/docs/0.12.x/_images/math/2042fb2f31cb75a62c3b7a25687987efcd3f5302.png" alt="S[m, n] = \sum_{i \leq m} \sum_{j \leq n} X[i, j]"></p> </div>
<table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr class="field-odd field">
<th class="field-name">Parameters:</th>
<td class="field-body">
<p class="first"><strong>img</strong> : ndarray</p>  <p>Input image.</p>  </td> </tr> <tr class="field-even field">
<th class="field-name">Returns:</th>
<td class="field-body">
<p class="first"><strong>S</strong> : ndarray</p>  <p>Integral image/summed area table of same shape as input image.</p>  </td> </tr>  </table> <h4 class="rubric">References</h4> <table class="docutils citation" frame="void" id="r369" rules="none">   <tr>
<td class="label"><a class="fn-backref" href="#id5">[R369]</a></td>
<td>F.C. Crow, “Summed-area tables for texture mapping,” ACM SIGGRAPH Computer Graphics, vol. 18, 1984, pp. 207-212.</td>
</tr>  </table> </dd>
</dl>   <h2 id="integrate">integrate</h2> <dl class="function"> <dt id="skimage.transform.integrate">
<code>skimage.transform.integrate(ii, start, end, *args)</code> <a class="reference external" href="http://github.com/scikit-image/scikit-image/blob/v0.12.2/skimage/transform/integral.py#L39" target="_blank"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Use an integral image to integrate over a given window.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr class="field-odd field">
<th class="field-name">Parameters:</th>
<td class="field-body">
<p class="first"><strong>ii</strong> : ndarray</p>  <p>Integral image.</p>  <p><strong>start</strong> : List of tuples, each tuple of length equal to dimension of <code>ii</code></p>  <p>Coordinates of top left corner of window(s). Each tuple in the list contains the starting row, col, ... index i.e <code>[(row_win1, col_win1, ...), (row_win2, col_win2,...), ...]</code>.</p>  <p><strong>end</strong> : List of tuples, each tuple of length equal to dimension of <code>ii</code></p>  <p>Coordinates of bottom right corner of window(s). Each tuple in the list containing the end row, col, ... index i.e <code>[(row_win1, col_win1, ...), (row_win2, col_win2, ...), ...]</code>.</p>  <p><strong>args: optional</strong></p>  <p>For backward compatibility with versions prior to 0.12. The earlier function signature was <code>integrate(ii, r0, c0, r1, c1)</code>, where <code>r0</code>, <code>c0</code> are int(lists) specifying start coordinates of window(s) to be integrated and <code>r1</code>, <code>c1</code> the end coordinates.</p>  </td> </tr> <tr class="field-even field">
<th class="field-name">Returns:</th>
<td class="field-body">
<p class="first"><strong>S</strong> : scalar or ndarray</p>  <p>Integral (sum) over the given window(s).</p>  </td> </tr>  </table> <h4 class="rubric">Examples</h4> <pre data-language="python">&gt;&gt;&gt; arr = np.ones((5, 6), dtype=np.float)
&gt;&gt;&gt; ii = integral_image(arr)
&gt;&gt;&gt; integrate(ii, (1, 0), (1, 2))  # sum from (1, 0) to (1, 2)
array([ 3.])
&gt;&gt;&gt; integrate(ii, [(3, 3)], [(4, 5)])  # sum from (3, 3) to (4, 5)
array([ 6.])
&gt;&gt;&gt; # sum from (1, 0) to (1, 2) and from (3, 3) to (4, 5)
&gt;&gt;&gt; integrate(ii, [(1, 0), (3, 3)], [(1, 2), (4, 5)])
array([ 3.,  6.])
</pre> </dd>
</dl>   <h2 id="iradon">iradon</h2> <dl class="function"> <dt id="skimage.transform.iradon">
<code>skimage.transform.iradon(radon_image, theta=None, output_size=None, filter='ramp', interpolation='linear', circle=False)</code> <a class="reference external" href="http://github.com/scikit-image/scikit-image/blob/v0.12.2/skimage/transform/radon_transform.py#L124" target="_blank"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Inverse radon transform.</p> <p>Reconstruct an image from the radon transform, using the filtered back projection algorithm.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr class="field-odd field">
<th class="field-name">Parameters:</th>
<td class="field-body">
<p class="first"><strong>radon_image</strong> : array_like, dtype=float</p>  <p>Image containing radon transform (sinogram). Each column of the image corresponds to a projection along a different angle. The tomography rotation axis should lie at the pixel index <code>radon_image.shape[0] // 2</code> along the 0th dimension of <code>radon_image</code>.</p>  <p><strong>theta</strong> : array_like, dtype=float, optional</p>  <p>Reconstruction angles (in degrees). Default: m angles evenly spaced between 0 and 180 (if the shape of <code>radon_image</code> is (N, M)).</p>  <p><strong>output_size</strong> : int</p>  <p>Number of rows and columns in the reconstruction.</p>  <p><strong>filter</strong> : str, optional (default ramp)</p>  <p>Filter used in frequency domain filtering. Ramp filter used by default. Filters available: ramp, shepp-logan, cosine, hamming, hann. Assign None to use no filter.</p>  <p><strong>interpolation</strong> : str, optional (default ‘linear’)</p>  <p>Interpolation method used in reconstruction. Methods available: ‘linear’, ‘nearest’, and ‘cubic’ (‘cubic’ is slow).</p>  <p><strong>circle</strong> : boolean, optional</p>  <p>Assume the reconstructed image is zero outside the inscribed circle. Also changes the default output_size to match the behaviour of <code>radon</code> called with <code>circle=True</code>.</p>  </td> </tr> <tr class="field-even field">
<th class="field-name">Returns:</th>
<td class="field-body">
<p class="first"><strong>reconstructed</strong> : ndarray</p>  <p>Reconstructed image. The rotation axis will be located in the pixel with indices <code>(reconstructed.shape[0] // 2, reconstructed.shape[1] // 2)</code>.</p>  </td> </tr>  </table> <h4 class="rubric">Notes</h4> <p>It applies the Fourier slice theorem to reconstruct an image by multiplying the frequency domain of the filter with the FFT of the projection data. This algorithm is called filtered back projection.</p> </dd>
</dl>   <h2 id="iradon-sart">iradon_sart</h2> <dl class="function"> <dt id="skimage.transform.iradon_sart">
<code>skimage.transform.iradon_sart(radon_image, theta=None, image=None, projection_shifts=None, clip=None, relaxation=0.15)</code> <a class="reference external" href="http://github.com/scikit-image/scikit-image/blob/v0.12.2/skimage/transform/radon_transform.py#L313" target="_blank"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Inverse radon transform</p> <p>Reconstruct an image from the radon transform, using a single iteration of the Simultaneous Algebraic Reconstruction Technique (SART) algorithm.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr class="field-odd field">
<th class="field-name">Parameters:</th>
<td class="field-body">
<p class="first"><strong>radon_image</strong> : 2D array, dtype=float</p>  <p>Image containing radon transform (sinogram). Each column of the image corresponds to a projection along a different angle. The tomography rotation axis should lie at the pixel index <code>radon_image.shape[0] // 2</code> along the 0th dimension of <code>radon_image</code>.</p>  <p><strong>theta</strong> : 1D array, dtype=float, optional</p>  <p>Reconstruction angles (in degrees). Default: m angles evenly spaced between 0 and 180 (if the shape of <code>radon_image</code> is (N, M)).</p>  <p><strong>image</strong> : 2D array, dtype=float, optional</p>  <p>Image containing an initial reconstruction estimate. Shape of this array should be <code>(radon_image.shape[0], radon_image.shape[0])</code>. The default is an array of zeros.</p>  <p><strong>projection_shifts</strong> : 1D array, dtype=float</p>  <p>Shift the projections contained in <code>radon_image</code> (the sinogram) by this many pixels before reconstructing the image. The i’th value defines the shift of the i’th column of <code>radon_image</code>.</p>  <p><strong>clip</strong> : length-2 sequence of floats</p>  <p>Force all values in the reconstructed tomogram to lie in the range <code>[clip[0], clip[1]]</code></p>  <p><strong>relaxation</strong> : float</p>  <p>Relaxation parameter for the update step. A higher value can improve the convergence rate, but one runs the risk of instabilities. Values close to or higher than 1 are not recommended.</p>  </td> </tr> <tr class="field-even field">
<th class="field-name">Returns:</th>
<td class="field-body">
<p class="first"><strong>reconstructed</strong> : ndarray</p>  <p>Reconstructed image. The rotation axis will be located in the pixel with indices <code>(reconstructed.shape[0] // 2, reconstructed.shape[1] // 2)</code>.</p>  </td> </tr>  </table> <h4 class="rubric">Notes</h4> <p>Algebraic Reconstruction Techniques are based on formulating the tomography reconstruction problem as a set of linear equations. Along each ray, the projected value is the sum of all the values of the cross section along the ray. A typical feature of SART (and a few other variants of algebraic techniques) is that it samples the cross section at equidistant points along the ray, using linear interpolation between the pixel values of the cross section. The resulting set of linear equations are then solved using a slightly modified Kaczmarz method.</p> <p>When using SART, a single iteration is usually sufficient to obtain a good reconstruction. Further iterations will tend to enhance high-frequency information, but will also often increase the noise.</p> <h4 class="rubric">References</h4> <table class="docutils citation" frame="void" id="r370" rules="none">   <tr>
<td class="label"><a class="fn-backref" href="#id6">[R370]</a></td>
<td>AC Kak, M Slaney, “Principles of Computerized Tomographic Imaging”, IEEE Press 1988.</td>
</tr>  </table> <table class="docutils citation" frame="void" id="r371" rules="none">   <tr>
<td class="label"><a class="fn-backref" href="#id7">[R371]</a></td>
<td>AH Andersen, AC Kak, “Simultaneous algebraic reconstruction technique (SART): a superior implementation of the ART algorithm”, Ultrasonic Imaging 6 pp 81–94 (1984)</td>
</tr>  </table> <table class="docutils citation" frame="void" id="r372" rules="none">   <tr>
<td class="label"><a class="fn-backref" href="#id8">[R372]</a></td>
<td>S Kaczmarz, “Angenäherte auflösung von systemen linearer gleichungen”, Bulletin International de l’Academie Polonaise des Sciences et des Lettres 35 pp 355–357 (1937)</td>
</tr>  </table> <table class="docutils citation" frame="void" id="r373" rules="none">   <tr>
<td class="label"><a class="fn-backref" href="#id9">[R373]</a></td>
<td>Kohler, T. “A projection access scheme for iterative reconstruction based on the golden section.” Nuclear Science Symposium Conference Record, 2004 IEEE. Vol. 6. IEEE, 2004.</td>
</tr>  </table> <table class="docutils citation" frame="void" id="r374" rules="none">   <tr>
<td class="label"><a class="fn-backref" href="#id10">[R374]</a></td>
<td>Kaczmarz’ method, Wikipedia, <a class="reference external" href="http://en.wikipedia.org/wiki/Kaczmarz_method" target="_blank">http://en.wikipedia.org/wiki/Kaczmarz_method</a>
</td>
</tr>  </table> </dd>
</dl>   <h2 id="matrix-transform">matrix_transform</h2> <dl class="function"> <dt id="skimage.transform.matrix_transform">
<code>skimage.transform.matrix_transform(coords, matrix)</code> <a class="reference external" href="http://github.com/scikit-image/scikit-image/blob/v0.12.2/skimage/transform/_geometric.py#L983" target="_blank"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Apply 2D matrix transform.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr class="field-odd field">
<th class="field-name">Parameters:</th>
<td class="field-body">
<p class="first"><strong>coords</strong> : (N, 2) array</p>  <p>x, y coordinates to transform</p>  <p><strong>matrix</strong> : (3, 3) array</p>  <p>Homogeneous transformation matrix.</p>  </td> </tr> <tr class="field-even field">
<th class="field-name">Returns:</th>
<td class="field-body">
<p class="first"><strong>coords</strong> : (N, 2) array</p>  <p>Transformed coordinates.</p>  </td> </tr>  </table> </dd>
</dl>   <h2 id="probabilistic-hough-line">probabilistic_hough_line</h2> <dl class="function"> <dt id="skimage.transform.probabilistic_hough_line">
<code>skimage.transform.probabilistic_hough_line(img, threshold=10, line_length=50, line_gap=10, theta=None)</code> <a class="reference external" href="http://github.com/scikit-image/scikit-image/blob/v0.12.2/skimage/transform/hough_transform.py#L193" target="_blank"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Return lines from a progressive probabilistic line Hough transform.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr class="field-odd field">
<th class="field-name">Parameters:</th>
<td class="field-body">
<p class="first"><strong>img</strong> : (M, N) ndarray</p>  <p>Input image with nonzero values representing edges.</p>  <p><strong>threshold</strong> : int, optional (default 10)</p>  <p>Threshold</p>  <p><strong>line_length</strong> : int, optional (default 50)</p>  <p>Minimum accepted length of detected lines. Increase the parameter to extract longer lines.</p>  <p><strong>line_gap</strong> : int, optional, (default 10)</p>  <p>Maximum gap between pixels to still form a line. Increase the parameter to merge broken lines more aggresively.</p>  <p><strong>theta</strong> : 1D ndarray, dtype=double, optional, default (-pi/2 .. pi/2)</p>  <p>Angles at which to compute the transform, in radians.</p>  </td> </tr> <tr class="field-even field">
<th class="field-name">Returns:</th>
<td class="field-body">
<p class="first"><strong>lines</strong> : list</p>  <p>List of lines identified, lines in format ((x0, y0), (x1, y0)), indicating line start and end.</p>  </td> </tr>  </table> <h4 class="rubric">References</h4> <table class="docutils citation" frame="void" id="r375" rules="none">   <tr>
<td class="label"><a class="fn-backref" href="#id11">[R375]</a></td>
<td>C. Galamhos, J. Matas and J. Kittler, “Progressive probabilistic Hough transform for line detection”, in IEEE Computer Society Conference on Computer Vision and Pattern Recognition, 1999.</td>
</tr>  </table> </dd>
</dl>   <h2 id="pyramid-expand">pyramid_expand</h2> <dl class="function"> <dt id="skimage.transform.pyramid_expand">
<code>skimage.transform.pyramid_expand(image, upscale=2, sigma=None, order=1, mode='reflect', cval=0)</code> <a class="reference external" href="http://github.com/scikit-image/scikit-image/blob/v0.12.2/skimage/transform/pyramids.py#L85" target="_blank"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Upsample and then smooth image.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr class="field-odd field">
<th class="field-name">Parameters:</th>
<td class="field-body">
<p class="first"><strong>image</strong> : array</p>  <p>Input image.</p>  <p><strong>upscale</strong> : float, optional</p>  <p>Upscale factor.</p>  <p><strong>sigma</strong> : float, optional</p>  <p>Sigma for Gaussian filter. Default is <code>2 * upscale / 6.0</code> which corresponds to a filter mask twice the size of the scale factor that covers more than 99% of the Gaussian distribution.</p>  <p><strong>order</strong> : int, optional</p>  <p>Order of splines used in interpolation of upsampling. See <code>skimage.transform.warp</code> for detail.</p>  <p><strong>mode</strong> : {‘reflect’, ‘constant’, ‘edge’, ‘symmetric’, ‘wrap’}, optional</p>  <p>The mode parameter determines how the array borders are handled, where cval is the value when mode is equal to ‘constant’.</p>  <p><strong>cval</strong> : float, optional</p>  <p>Value to fill past edges of input if mode is ‘constant’.</p>  </td> </tr> <tr class="field-even field">
<th class="field-name">Returns:</th>
<td class="field-body">
<p class="first"><strong>out</strong> : array</p>  <p>Upsampled and smoothed float image.</p>  </td> </tr>  </table> <h4 class="rubric">References</h4> <table class="docutils citation" frame="void" id="r376" rules="none">   <tr>
<td class="label"><a class="fn-backref" href="#id12">[R376]</a></td>
<td><a class="reference external" href="http://web.mit.edu/persci/people/adelson/pub_pdfs/pyramid83.pdf" target="_blank">http://web.mit.edu/persci/people/adelson/pub_pdfs/pyramid83.pdf</a></td>
</tr>  </table> </dd>
</dl>   <h2 id="pyramid-gaussian">pyramid_gaussian</h2> <dl class="function"> <dt id="skimage.transform.pyramid_gaussian">
<code>skimage.transform.pyramid_gaussian(image, max_layer=-1, downscale=2, sigma=None, order=1, mode='reflect', cval=0)</code> <a class="reference external" href="http://github.com/scikit-image/scikit-image/blob/v0.12.2/skimage/transform/pyramids.py#L139" target="_blank"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Yield images of the Gaussian pyramid formed by the input image.</p> <p>Recursively applies the <code>pyramid_reduce</code> function to the image, and yields the downscaled images.</p> <p>Note that the first image of the pyramid will be the original, unscaled image. The total number of images is <code>max_layer + 1</code>. In case all layers are computed, the last image is either a one-pixel image or the image where the reduction does not change its shape.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr class="field-odd field">
<th class="field-name">Parameters:</th>
<td class="field-body">
<p class="first"><strong>image</strong> : array</p>  <p>Input image.</p>  <p><strong>max_layer</strong> : int</p>  <p>Number of layers for the pyramid. 0th layer is the original image. Default is -1 which builds all possible layers.</p>  <p><strong>downscale</strong> : float, optional</p>  <p>Downscale factor.</p>  <p><strong>sigma</strong> : float, optional</p>  <p>Sigma for Gaussian filter. Default is <code>2 * downscale / 6.0</code> which corresponds to a filter mask twice the size of the scale factor that covers more than 99% of the Gaussian distribution.</p>  <p><strong>order</strong> : int, optional</p>  <p>Order of splines used in interpolation of downsampling. See <code>skimage.transform.warp</code> for detail.</p>  <p><strong>mode</strong> : {‘reflect’, ‘constant’, ‘edge’, ‘symmetric’, ‘wrap’}, optional</p>  <p>The mode parameter determines how the array borders are handled, where cval is the value when mode is equal to ‘constant’.</p>  <p><strong>cval</strong> : float, optional</p>  <p>Value to fill past edges of input if mode is ‘constant’.</p>  </td> </tr> <tr class="field-even field">
<th class="field-name">Returns:</th>
<td class="field-body">
<p class="first"><strong>pyramid</strong> : generator</p>  <p>Generator yielding pyramid layers as float images.</p>  </td> </tr>  </table> <h4 class="rubric">References</h4> <table class="docutils citation" frame="void" id="r377" rules="none">   <tr>
<td class="label"><a class="fn-backref" href="#id13">[R377]</a></td>
<td><a class="reference external" href="http://web.mit.edu/persci/people/adelson/pub_pdfs/pyramid83.pdf" target="_blank">http://web.mit.edu/persci/people/adelson/pub_pdfs/pyramid83.pdf</a></td>
</tr>  </table> </dd>
</dl>   <h2 id="pyramid-laplacian">pyramid_laplacian</h2> <dl class="function"> <dt id="skimage.transform.pyramid_laplacian">
<code>skimage.transform.pyramid_laplacian(image, max_layer=-1, downscale=2, sigma=None, order=1, mode='reflect', cval=0)</code> <a class="reference external" href="http://github.com/scikit-image/scikit-image/blob/v0.12.2/skimage/transform/pyramids.py#L217" target="_blank"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Yield images of the laplacian pyramid formed by the input image.</p> <p>Each layer contains the difference between the downsampled and the downsampled, smoothed image:</p> <pre data-language="python">layer = resize(prev_layer) - smooth(resize(prev_layer))
</pre> <p>Note that the first image of the pyramid will be the difference between the original, unscaled image and its smoothed version. The total number of images is <code>max_layer + 1</code>. In case all layers are computed, the last image is either a one-pixel image or the image where the reduction does not change its shape.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr class="field-odd field">
<th class="field-name">Parameters:</th>
<td class="field-body">
<p class="first"><strong>image</strong> : array</p>  <p>Input image.</p>  <p><strong>max_layer</strong> : int</p>  <p>Number of layers for the pyramid. 0th layer is the original image. Default is -1 which builds all possible layers.</p>  <p><strong>downscale</strong> : float, optional</p>  <p>Downscale factor.</p>  <p><strong>sigma</strong> : float, optional</p>  <p>Sigma for Gaussian filter. Default is <code>2 * downscale / 6.0</code> which corresponds to a filter mask twice the size of the scale factor that covers more than 99% of the Gaussian distribution.</p>  <p><strong>order</strong> : int, optional</p>  <p>Order of splines used in interpolation of downsampling. See <code>skimage.transform.warp</code> for detail.</p>  <p><strong>mode</strong> : {‘reflect’, ‘constant’, ‘edge’, ‘symmetric’, ‘wrap’}, optional</p>  <p>The mode parameter determines how the array borders are handled, where cval is the value when mode is equal to ‘constant’.</p>  <p><strong>cval</strong> : float, optional</p>  <p>Value to fill past edges of input if mode is ‘constant’.</p>  </td> </tr> <tr class="field-even field">
<th class="field-name">Returns:</th>
<td class="field-body">
<p class="first"><strong>pyramid</strong> : generator</p>  <p>Generator yielding pyramid layers as float images.</p>  </td> </tr>  </table> <h4 class="rubric">References</h4> <table class="docutils citation" frame="void" id="r378" rules="none">   <tr>
<td class="label"><a class="fn-backref" href="#id14">[R378]</a></td>
<td><a class="reference external" href="http://web.mit.edu/persci/people/adelson/pub_pdfs/pyramid83.pdf" target="_blank">http://web.mit.edu/persci/people/adelson/pub_pdfs/pyramid83.pdf</a></td>
</tr>  </table> <table class="docutils citation" frame="void" id="r379" rules="none">   <tr>
<td class="label"><a class="fn-backref" href="#id15">[R379]</a></td>
<td><a class="reference external" href="http://sepwww.stanford.edu/~morgan/texturematch/paper_html/node3.html" target="_blank">http://sepwww.stanford.edu/~morgan/texturematch/paper_html/node3.html</a></td>
</tr>  </table> </dd>
</dl>   <h2 id="pyramid-reduce">pyramid_reduce</h2> <dl class="function"> <dt id="skimage.transform.pyramid_reduce">
<code>skimage.transform.pyramid_reduce(image, downscale=2, sigma=None, order=1, mode='reflect', cval=0)</code> <a class="reference external" href="http://github.com/scikit-image/scikit-image/blob/v0.12.2/skimage/transform/pyramids.py#L31" target="_blank"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Smooth and then downsample image.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr class="field-odd field">
<th class="field-name">Parameters:</th>
<td class="field-body">
<p class="first"><strong>image</strong> : array</p>  <p>Input image.</p>  <p><strong>downscale</strong> : float, optional</p>  <p>Downscale factor.</p>  <p><strong>sigma</strong> : float, optional</p>  <p>Sigma for Gaussian filter. Default is <code>2 * downscale / 6.0</code> which corresponds to a filter mask twice the size of the scale factor that covers more than 99% of the Gaussian distribution.</p>  <p><strong>order</strong> : int, optional</p>  <p>Order of splines used in interpolation of downsampling. See <code>skimage.transform.warp</code> for detail.</p>  <p><strong>mode</strong> : {‘reflect’, ‘constant’, ‘edge’, ‘symmetric’, ‘wrap’}, optional</p>  <p>The mode parameter determines how the array borders are handled, where cval is the value when mode is equal to ‘constant’.</p>  <p><strong>cval</strong> : float, optional</p>  <p>Value to fill past edges of input if mode is ‘constant’.</p>  </td> </tr> <tr class="field-even field">
<th class="field-name">Returns:</th>
<td class="field-body">
<p class="first"><strong>out</strong> : array</p>  <p>Smoothed and downsampled float image.</p>  </td> </tr>  </table> <h4 class="rubric">References</h4> <table class="docutils citation" frame="void" id="r380" rules="none">   <tr>
<td class="label"><a class="fn-backref" href="#id16">[R380]</a></td>
<td><a class="reference external" href="http://web.mit.edu/persci/people/adelson/pub_pdfs/pyramid83.pdf" target="_blank">http://web.mit.edu/persci/people/adelson/pub_pdfs/pyramid83.pdf</a></td>
</tr>  </table> </dd>
</dl>   <h2 id="radon">radon</h2> <dl class="function"> <dt id="skimage.transform.radon">
<code>skimage.transform.radon(image, theta=None, circle=False)</code> <a class="reference external" href="http://github.com/scikit-image/scikit-image/blob/v0.12.2/skimage/transform/radon_transform.py#L29" target="_blank"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Calculates the radon transform of an image given specified projection angles.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr class="field-odd field">
<th class="field-name">Parameters:</th>
<td class="field-body">
<p class="first"><strong>image</strong> : array_like, dtype=float</p>  <p>Input image. The rotation axis will be located in the pixel with indices <code>(image.shape[0] // 2, image.shape[1] // 2)</code>.</p>  <p><strong>theta</strong> : array_like, dtype=float, optional (default np.arange(180))</p>  <p>Projection angles (in degrees).</p>  <p><strong>circle</strong> : boolean, optional</p>  <p>Assume image is zero outside the inscribed circle, making the width of each projection (the first dimension of the sinogram) equal to <code>min(image.shape)</code>.</p>  </td> </tr> <tr class="field-even field">
<th class="field-name">Returns:</th>
<td class="field-body">
<p class="first"><strong>radon_image</strong> : ndarray</p>  <p>Radon transform (sinogram). The tomography rotation axis will lie at the pixel index <code>radon_image.shape[0] // 2</code> along the 0th dimension of <code>radon_image</code>.</p>  </td> </tr>  </table> </dd>
</dl>   <h2 id="rescale">rescale</h2> <dl class="function"> <dt id="skimage.transform.rescale">
<code>skimage.transform.rescale(image, scale, order=1, mode='constant', cval=0, clip=True, preserve_range=False)</code> <a class="reference external" href="http://github.com/scikit-image/scikit-image/blob/v0.12.2/skimage/transform/_warps.py#L124" target="_blank"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Scale image by a certain factor.</p> <p>Performs interpolation to upscale or down-scale images. For down-sampling N-dimensional images with integer factors by applying the arithmetic sum or mean, see <code>skimage.measure.local_sum</code> and <code>skimage.transform.downscale_local_mean</code>, respectively.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr class="field-odd field">
<th class="field-name">Parameters:</th>
<td class="field-body">
<p class="first"><strong>image</strong> : ndarray</p>  <p>Input image.</p>  <p><strong>scale</strong> : {float, tuple of floats}</p>  <p>Scale factors. Separate scale factors can be defined as <code>(row_scale, col_scale)</code>.</p>  </td> </tr> <tr class="field-even field">
<th class="field-name">Returns:</th>
<td class="field-body">
<p class="first"><strong>scaled</strong> : ndarray</p>  <p>Scaled version of the input.</p>  </td> </tr> <tr class="field-odd field"><th class="field-name" colspan="2">Other Parameters:</th></tr> <tr class="field-odd field">
<td> </td>
<td class="field-body">
<p class="first"><strong>order</strong> : int, optional</p>  <p>The order of the spline interpolation, default is 1. The order has to be in the range 0-5. See <code>skimage.transform.warp</code> for detail.</p>  <p><strong>mode</strong> : {‘constant’, ‘edge’, ‘symmetric’, ‘reflect’, ‘wrap’}, optional</p>  <p>Points outside the boundaries of the input are filled according to the given mode. Modes match the behaviour of <code>numpy.pad</code>.</p>  <p><strong>cval</strong> : float, optional</p>  <p>Used in conjunction with mode ‘constant’, the value outside the image boundaries.</p>  <p><strong>clip</strong> : bool, optional</p>  <p>Whether to clip the output to the range of values of the input image. This is enabled by default, since higher order interpolation may produce values outside the given input range.</p>  <p><strong>preserve_range</strong> : bool, optional</p>  <p>Whether to keep the original range of values. Otherwise, the input image is converted according to the conventions of <code>img_as_float</code>.</p>  </td> </tr>  </table> <h4 class="rubric">Examples</h4> <pre data-language="python">&gt;&gt;&gt; from skimage import data
&gt;&gt;&gt; from skimage.transform import rescale
&gt;&gt;&gt; image = data.camera()
&gt;&gt;&gt; rescale(image, 0.1).shape
(51, 51)
&gt;&gt;&gt; rescale(image, 0.5).shape
(256, 256)
</pre> </dd>
</dl>   <h2 id="resize">resize</h2> <dl class="function"> <dt id="skimage.transform.resize">
<code>skimage.transform.resize(image, output_shape, order=1, mode='constant', cval=0, clip=True, preserve_range=False)</code> <a class="reference external" href="http://github.com/scikit-image/scikit-image/blob/v0.12.2/skimage/transform/_warps.py#L10" target="_blank"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Resize image to match a certain size.</p> <p>Performs interpolation to up-size or down-size images. For down-sampling N-dimensional images by applying the arithmetic sum or mean, see <code>skimage.measure.local_sum</code> and <code>skimage.transform.downscale_local_mean</code>, respectively.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr class="field-odd field">
<th class="field-name">Parameters:</th>
<td class="field-body">
<p class="first"><strong>image</strong> : ndarray</p>  <p>Input image.</p>  <p><strong>output_shape</strong> : tuple or ndarray</p>  <p>Size of the generated output image <code>(rows, cols[, dim])</code>. If <code>dim</code> is not provided, the number of channels is preserved. In case the number of input channels does not equal the number of output channels a 3-dimensional interpolation is applied.</p>  </td> </tr> <tr class="field-even field">
<th class="field-name">Returns:</th>
<td class="field-body">
<p class="first"><strong>resized</strong> : ndarray</p>  <p>Resized version of the input.</p>  </td> </tr> <tr class="field-odd field"><th class="field-name" colspan="2">Other Parameters:</th></tr> <tr class="field-odd field">
<td> </td>
<td class="field-body">
<p class="first"><strong>order</strong> : int, optional</p>  <p>The order of the spline interpolation, default is 1. The order has to be in the range 0-5. See <code>skimage.transform.warp</code> for detail.</p>  <p><strong>mode</strong> : {‘constant’, ‘edge’, ‘symmetric’, ‘reflect’, ‘wrap’}, optional</p>  <p>Points outside the boundaries of the input are filled according to the given mode. Modes match the behaviour of <code>numpy.pad</code>.</p>  <p><strong>cval</strong> : float, optional</p>  <p>Used in conjunction with mode ‘constant’, the value outside the image boundaries.</p>  <p><strong>clip</strong> : bool, optional</p>  <p>Whether to clip the output to the range of values of the input image. This is enabled by default, since higher order interpolation may produce values outside the given input range.</p>  <p><strong>preserve_range</strong> : bool, optional</p>  <p>Whether to keep the original range of values. Otherwise, the input image is converted according to the conventions of <code>img_as_float</code>.</p>  </td> </tr>  </table> <h4 class="rubric">Notes</h4> <p>Modes ‘reflect’ and ‘symmetric’ are similar, but differ in whether the edge pixels are duplicated during the reflection. As an example, if an array has values [0, 1, 2] and was padded to the right by four values using symmetric, the result would be [0, 1, 2, 2, 1, 0, 0], while for reflect it would be [0, 1, 2, 1, 0, 1, 2].</p> <h4 class="rubric">Examples</h4> <pre data-language="python">&gt;&gt;&gt; from skimage import data
&gt;&gt;&gt; from skimage.transform import resize
&gt;&gt;&gt; image = data.camera()
&gt;&gt;&gt; resize(image, (100, 100)).shape
(100, 100)
</pre> </dd>
</dl>   <h2 id="rotate">rotate</h2> <dl class="function"> <dt id="skimage.transform.rotate">
<code>skimage.transform.rotate(image, angle, resize=False, center=None, order=1, mode='constant', cval=0, clip=True, preserve_range=False)</code> <a class="reference external" href="http://github.com/scikit-image/scikit-image/blob/v0.12.2/skimage/transform/_warps.py#L191" target="_blank"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Rotate image by a certain angle around its center.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr class="field-odd field">
<th class="field-name">Parameters:</th>
<td class="field-body">
<p class="first"><strong>image</strong> : ndarray</p>  <p>Input image.</p>  <p><strong>angle</strong> : float</p>  <p>Rotation angle in degrees in counter-clockwise direction.</p>  <p><strong>resize</strong> : bool, optional</p>  <p>Determine whether the shape of the output image will be automatically calculated, so the complete rotated image exactly fits. Default is False.</p>  <p><strong>center</strong> : iterable of length 2</p>  <p>The rotation center. If <code>center=None</code>, the image is rotated around its center, i.e. <code>center=(rows / 2 - 0.5, cols / 2 - 0.5)</code>.</p>  </td> </tr> <tr class="field-even field">
<th class="field-name">Returns:</th>
<td class="field-body">
<p class="first"><strong>rotated</strong> : ndarray</p>  <p>Rotated version of the input.</p>  </td> </tr> <tr class="field-odd field"><th class="field-name" colspan="2">Other Parameters:</th></tr> <tr class="field-odd field">
<td> </td>
<td class="field-body">
<p class="first"><strong>order</strong> : int, optional</p>  <p>The order of the spline interpolation, default is 1. The order has to be in the range 0-5. See <code>skimage.transform.warp</code> for detail.</p>  <p><strong>mode</strong> : {‘constant’, ‘edge’, ‘symmetric’, ‘reflect’, ‘wrap’}, optional</p>  <p>Points outside the boundaries of the input are filled according to the given mode. Modes match the behaviour of <code>numpy.pad</code>.</p>  <p><strong>cval</strong> : float, optional</p>  <p>Used in conjunction with mode ‘constant’, the value outside the image boundaries.</p>  <p><strong>clip</strong> : bool, optional</p>  <p>Whether to clip the output to the range of values of the input image. This is enabled by default, since higher order interpolation may produce values outside the given input range.</p>  <p><strong>preserve_range</strong> : bool, optional</p>  <p>Whether to keep the original range of values. Otherwise, the input image is converted according to the conventions of <code>img_as_float</code>.</p>  </td> </tr>  </table> <h4 class="rubric">Examples</h4> <pre data-language="python">&gt;&gt;&gt; from skimage import data
&gt;&gt;&gt; from skimage.transform import rotate
&gt;&gt;&gt; image = data.camera()
&gt;&gt;&gt; rotate(image, 2).shape
(512, 512)
&gt;&gt;&gt; rotate(image, 2, resize=True).shape
(530, 530)
&gt;&gt;&gt; rotate(image, 90, resize=True).shape
(512, 512)
</pre> </dd>
</dl>   <h2 id="seam-carve">seam_carve</h2> <dl class="function"> <dt id="skimage.transform.seam_carve">
<code>skimage.transform.seam_carve(img, energy_map, mode, num, border=1, force_copy=True)</code> <a class="reference external" href="http://github.com/scikit-image/scikit-image/blob/v0.12.2/skimage/transform/seam_carving.py#L7" target="_blank"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Carve vertical or horizontal seams off an image.</p> <p>Carves out vertical/horizontal seams from an image while using the given energy map to decide the importance of each pixel.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr class="field-odd field">
<th class="field-name">Parameters:</th>
<td class="field-body">
<p class="first"><strong>image</strong> : (M, N) or (M, N, 3) ndarray</p>  <p>Input image whose seams are to be removed.</p>  <p><strong>energy_map</strong> : (M, N) ndarray</p>  <p>The array to decide the importance of each pixel. The higher the value corresponding to a pixel, the more the algorithm will try to keep it in the image.</p>  <p><strong>mode</strong> : str {‘horizontal’, ‘vertical’}</p>  <p>Indicates whether seams are to be removed vertically or horizontally. Removing seams horizontally will decrease the height whereas removing vertically will decrease the width.</p>  <p><strong>num</strong> : int</p>  <p>Number of seams are to be removed.</p>  <p><strong>border</strong> : int, optional</p>  <p>The number of pixels in the right, left and bottom end of the image to be excluded from being considered for a seam. This is important as certain filters just ignore image boundaries and set them to <code>0</code>. By default border is set to <code>1</code>.</p>  <p><strong>force_copy</strong> : bool, optional</p>  <p>If set, the <code>image</code> and <code>energy_map</code> are copied before being used by the method which modifies it in place. Set this to <code>False</code> if the original image and the energy map are no longer needed after this opetration.</p>  </td> </tr> <tr class="field-even field">
<th class="field-name">Returns:</th>
<td class="field-body">
<p class="first"><strong>out</strong> : ndarray</p>  <p>The cropped image with the seams removed.</p>  </td> </tr>  </table> <h4 class="rubric">References</h4> <table class="docutils citation" frame="void" id="r381" rules="none">   <tr>
<td class="label"><a class="fn-backref" href="#id17">[R381]</a></td>
<td>Shai Avidan and Ariel Shamir “Seam Carving for Content-Aware Image Resizing” <a class="reference external" href="http://www.cs.jhu.edu/~misha/ReadingSeminar/Papers/Avidan07.pdf" target="_blank">http://www.cs.jhu.edu/~misha/ReadingSeminar/Papers/Avidan07.pdf</a>
</td>
</tr>  </table> </dd>
</dl>   <h2 id="swirl">swirl</h2> <dl class="function"> <dt id="skimage.transform.swirl">
<code>skimage.transform.swirl(image, center=None, strength=1, radius=100, rotation=0, output_shape=None, order=1, mode='constant', cval=0, clip=True, preserve_range=False)</code> <a class="reference external" href="http://github.com/scikit-image/scikit-image/blob/v0.12.2/skimage/transform/_warps.py#L346" target="_blank"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Perform a swirl transformation.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr class="field-odd field">
<th class="field-name">Parameters:</th>
<td class="field-body">
<p class="first"><strong>image</strong> : ndarray</p>  <p>Input image.</p>  <p><strong>center</strong> : (row, column) tuple or (2,) ndarray, optional</p>  <p>Center coordinate of transformation.</p>  <p><strong>strength</strong> : float, optional</p>  <p>The amount of swirling applied.</p>  <p><strong>radius</strong> : float, optional</p>  <p>The extent of the swirl in pixels. The effect dies out rapidly beyond <code>radius</code>.</p>  <p><strong>rotation</strong> : float, optional</p>  <p>Additional rotation applied to the image.</p>  </td> </tr> <tr class="field-even field">
<th class="field-name">Returns:</th>
<td class="field-body">
<p class="first"><strong>swirled</strong> : ndarray</p>  <p>Swirled version of the input.</p>  </td> </tr> <tr class="field-odd field"><th class="field-name" colspan="2">Other Parameters:</th></tr> <tr class="field-odd field">
<td> </td>
<td class="field-body">
<p class="first"><strong>output_shape</strong> : tuple (rows, cols), optional</p>  <p>Shape of the output image generated. By default the shape of the input image is preserved.</p>  <p><strong>order</strong> : int, optional</p>  <p>The order of the spline interpolation, default is 1. The order has to be in the range 0-5. See <code>skimage.transform.warp</code> for detail.</p>  <p><strong>mode</strong> : {‘constant’, ‘edge’, ‘symmetric’, ‘reflect’, ‘wrap’}, optional</p>  <p>Points outside the boundaries of the input are filled according to the given mode. Modes match the behaviour of <code>numpy.pad</code>.</p>  <p><strong>cval</strong> : float, optional</p>  <p>Used in conjunction with mode ‘constant’, the value outside the image boundaries.</p>  <p><strong>clip</strong> : bool, optional</p>  <p>Whether to clip the output to the range of values of the input image. This is enabled by default, since higher order interpolation may produce values outside the given input range.</p>  <p><strong>preserve_range</strong> : bool, optional</p>  <p>Whether to keep the original range of values. Otherwise, the input image is converted according to the conventions of <code>img_as_float</code>.</p>  </td> </tr>  </table> </dd>
</dl>   <h2 id="warp">warp</h2> <dl class="function"> <dt id="skimage.transform.warp">
<code>skimage.transform.warp(image, inverse_map=None, map_args={}, output_shape=None, order=1, mode='constant', cval=0.0, clip=True, preserve_range=False)</code> <a class="reference external" href="http://github.com/scikit-image/scikit-image/blob/v0.12.2/skimage/transform/_geometric.py#L1158" target="_blank"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Warp an image according to a given coordinate transformation.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr class="field-odd field">
<th class="field-name">Parameters:</th>
<td class="field-body">
<p class="first"><strong>image</strong> : ndarray</p>  <p>Input image.</p>  <p><strong>inverse_map</strong> : transformation object, callable <code>cr = f(cr, **kwargs)</code>, or ndarray</p>  <p>Inverse coordinate map, which transforms coordinates in the output images into their corresponding coordinates in the input image.</p> <p>There are a number of different options to define this map, depending on the dimensionality of the input image. A 2-D image can have 2 dimensions for gray-scale images, or 3 dimensions with color information.</p>  <ul class="simple"> <li>For 2-D images, you can directly pass a transformation object, e.g. <code>skimage.transform.SimilarityTransform</code>, or its inverse.</li> <li>For 2-D images, you can pass a <code>(3, 3)</code> homogeneous transformation matrix, e.g. <code>skimage.transform.SimilarityTransform.params</code>.</li> <li>For 2-D images, a function that transforms a <code>(M, 2)</code> array of <code>(col, row)</code> coordinates in the output image to their corresponding coordinates in the input image. Extra parameters to the function can be specified through <code>map_args</code>.</li> <li>For N-D images, you can directly pass an array of coordinates. The first dimension specifies the coordinates in the input image, while the subsequent dimensions determine the position in the output image. E.g. in case of 2-D images, you need to pass an array of shape <code>(2, rows, cols)</code>, where <code>rows</code> and <code>cols</code> determine the shape of the output image, and the first dimension contains the <code>(row, col)</code> coordinate in the input image. See <code>scipy.ndimage.map_coordinates</code> for further documentation.</li> </ul>  <p>Note, that a <code>(3, 3)</code> matrix is interpreted as a homogeneous transformation matrix, so you cannot interpolate values from a 3-D input, if the output is of shape <code>(3,)</code>.</p> <p>See example section for usage.</p>  <p><strong>map_args</strong> : dict, optional</p>  <p>Keyword arguments passed to <code>inverse_map</code>.</p>  <p><strong>output_shape</strong> : tuple (rows, cols), optional</p>  <p>Shape of the output image generated. By default the shape of the input image is preserved. Note that, even for multi-band images, only rows and columns need to be specified.</p>  <p><strong>order</strong> : int, optional</p>  <dl class="docutils"> <dt>The order of interpolation. The order has to be in the range 0-5:</dt> <dd>
<ul class="first last simple"> <li>0: Nearest-neighbor</li> <li>1: Bi-linear (default)</li> <li>2: Bi-quadratic</li> <li>3: Bi-cubic</li> <li>4: Bi-quartic</li> <li>5: Bi-quintic</li> </ul> </dd> </dl>  <p><strong>mode</strong> : {‘constant’, ‘edge’, ‘symmetric’, ‘reflect’, ‘wrap’}, optional</p>  <p>Points outside the boundaries of the input are filled according to the given mode. Modes match the behaviour of <code>numpy.pad</code>.</p>  <p><strong>cval</strong> : float, optional</p>  <p>Used in conjunction with mode ‘constant’, the value outside the image boundaries.</p>  <p><strong>clip</strong> : bool, optional</p>  <p>Whether to clip the output to the range of values of the input image. This is enabled by default, since higher order interpolation may produce values outside the given input range.</p>  <p><strong>preserve_range</strong> : bool, optional</p>  <p>Whether to keep the original range of values. Otherwise, the input image is converted according to the conventions of <code>img_as_float</code>.</p>  </td> </tr> <tr class="field-even field">
<th class="field-name">Returns:</th>
<td class="field-body">
<p class="first"><strong>warped</strong> : double ndarray</p>  <p>The warped input image.</p>  </td> </tr>  </table> <h4 class="rubric">Notes</h4> <ul class="simple"> <li>The input image is converted to a <code>double</code> image.</li> <li>In case of a <code>SimilarityTransform</code>, <code>AffineTransform</code> and <code>ProjectiveTransform</code> and <code>order</code> in [0, 3] this function uses the underlying transformation matrix to warp the image with a much faster routine.</li> </ul> <h4 class="rubric">Examples</h4> <pre data-language="python">&gt;&gt;&gt; from skimage.transform import warp
&gt;&gt;&gt; from skimage import data
&gt;&gt;&gt; image = data.camera()
</pre> <p>The following image warps are all equal but differ substantially in execution time. The image is shifted to the bottom.</p> <p>Use a geometric transform to warp an image (fast):</p> <pre data-language="python">&gt;&gt;&gt; from skimage.transform import SimilarityTransform
&gt;&gt;&gt; tform = SimilarityTransform(translation=(0, -10))
&gt;&gt;&gt; warped = warp(image, tform)
</pre> <p>Use a callable (slow):</p> <pre data-language="python">&gt;&gt;&gt; def shift_down(xy):
...     xy[:, 1] -= 10
...     return xy
&gt;&gt;&gt; warped = warp(image, shift_down)
</pre> <p>Use a transformation matrix to warp an image (fast):</p> <pre data-language="python">&gt;&gt;&gt; matrix = np.array([[1, 0, 0], [0, 1, -10], [0, 0, 1]])
&gt;&gt;&gt; warped = warp(image, matrix)
&gt;&gt;&gt; from skimage.transform import ProjectiveTransform
&gt;&gt;&gt; warped = warp(image, ProjectiveTransform(matrix=matrix))
</pre> <p>You can also use the inverse of a geometric transformation (fast):</p> <pre data-language="python">&gt;&gt;&gt; warped = warp(image, tform.inverse)
</pre> <p>For N-D images you can pass a coordinate array, that specifies the coordinates in the input image for every element in the output image. E.g. if you want to rescale a 3-D cube, you can do:</p> <pre data-language="python">&gt;&gt;&gt; cube_shape = np.array([30, 30, 30])
&gt;&gt;&gt; cube = np.random.rand(*cube_shape)
</pre> <p>Setup the coordinate array, that defines the scaling:</p> <pre data-language="python">&gt;&gt;&gt; scale = 0.1
&gt;&gt;&gt; output_shape = (scale * cube_shape).astype(int)
&gt;&gt;&gt; coords0, coords1, coords2 = np.mgrid[:output_shape[0],
...                    :output_shape[1], :output_shape[2]]
&gt;&gt;&gt; coords = np.array([coords0, coords1, coords2])
</pre> <p>Assume that the cube contains spatial data, where the first array element center is at coordinate (0.5, 0.5, 0.5) in real space, i.e. we have to account for this extra offset when scaling the image:</p> <pre data-language="python">&gt;&gt;&gt; coords = (coords + 0.5) / scale - 0.5
&gt;&gt;&gt; warped = warp(cube, coords)
</pre> </dd>
</dl>   <h2 id="warp-coords">warp_coords</h2> <dl class="function"> <dt id="skimage.transform.warp_coords">
<code>skimage.transform.warp_coords(coord_map, shape, dtype=&lt;type 'numpy.float64'&gt;)</code> <a class="reference external" href="http://github.com/scikit-image/scikit-image/blob/v0.12.2/skimage/transform/_geometric.py#L1025" target="_blank"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Build the source coordinates for the output of a 2-D image warp.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr class="field-odd field">
<th class="field-name">Parameters:</th>
<td class="field-body">
<p class="first"><strong>coord_map</strong> : callable like GeometricTransform.inverse</p>  <p>Return input coordinates for given output coordinates. Coordinates are in the shape (P, 2), where P is the number of coordinates and each element is a <code>(row, col)</code> pair.</p>  <p><strong>shape</strong> : tuple</p>  <p>Shape of output image <code>(rows, cols[, bands])</code>.</p>  <p><strong>dtype</strong> : np.dtype or string</p>  <p>dtype for return value (sane choices: float32 or float64).</p>  </td> </tr> <tr class="field-even field">
<th class="field-name">Returns:</th>
<td class="field-body">
<p class="first"><strong>coords</strong> : (ndim, rows, cols[, bands]) array of dtype <code>dtype</code></p>  <p>Coordinates for <code>scipy.ndimage.map_coordinates</code>, that will yield an image of shape (orows, ocols, bands) by drawing from source points according to the <code>coord_transform_fn</code>.</p>  </td> </tr>  </table> <h4 class="rubric">Notes</h4> <p>This is a lower-level routine that produces the source coordinates for 2-D images used by <code>warp()</code>.</p> <p>It is provided separately from <code>warp</code> to give additional flexibility to users who would like, for example, to re-use a particular coordinate mapping, to use specific dtypes at various points along the the image-warping process, or to implement different post-processing logic than <code>warp</code> performs after the call to <code>ndi.map_coordinates</code>.</p> <h4 class="rubric">Examples</h4> <p>Produce a coordinate map that shifts an image up and to the right:</p> <pre data-language="python">&gt;&gt;&gt; from skimage import data
&gt;&gt;&gt; from scipy.ndimage import map_coordinates
&gt;&gt;&gt;
&gt;&gt;&gt; def shift_up10_left20(xy):
...     return xy - np.array([-20, 10])[None, :]
&gt;&gt;&gt;
&gt;&gt;&gt; image = data.astronaut().astype(np.float32)
&gt;&gt;&gt; coords = warp_coords(shift_up10_left20, image.shape)
&gt;&gt;&gt; warped_image = map_coordinates(image, coords)
</pre> </dd>
</dl>   <h2 id="affinetransform">AffineTransform</h2> <dl class="class"> <dt id="skimage.transform.AffineTransform">
<code>class skimage.transform.AffineTransform(matrix=None, scale=None, rotation=None, shear=None, translation=None)</code> <a class="reference external" href="http://github.com/scikit-image/scikit-image/blob/v0.12.2/skimage/transform/_geometric.py#L345" target="_blank"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Bases: <code>skimage.transform._geometric.ProjectiveTransform</code></p> <p>2D affine transformation of the form:</p> <p>..:math:</p>  <dl class="docutils"> <dt>X = a0*x + a1*y + a2 =</dt> <dd>= sx*x*cos(rotation) - sy*y*sin(rotation + shear) + a2</dd> <dt>Y = b0*x + b1*y + b2 =</dt> <dd>= sx*x*sin(rotation) + sy*y*cos(rotation + shear) + b2</dd> </dl>  <p>where <code>sx</code> and <code>sy</code> are zoom factors in the x and y directions, and the homogeneous transformation matrix is:</p> <pre data-language="python">[[a0  a1  a2]
 [b0  b1  b2]
 [0   0    1]]
</pre> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr class="field-odd field">
<th class="field-name">Parameters:</th>
<td class="field-body">
<p class="first"><strong>matrix</strong> : (3, 3) array, optional</p>  <p>Homogeneous transformation matrix.</p>  <p><strong>scale</strong> : (sx, sy) as array, list or tuple, optional</p>  <p>Scale factors.</p>  <p><strong>rotation</strong> : float, optional</p>  <p>Rotation angle in counter-clockwise direction as radians.</p>  <p><strong>shear</strong> : float, optional</p>  <p>Shear angle in counter-clockwise direction as radians.</p>  <p><strong>translation</strong> : (tx, ty) as array, list or tuple, optional</p>  <p>Translation parameters.</p>  </td> </tr>  </table> <h4 class="rubric">Attributes</h4> <table class="docutils">   <tr class="row-odd">
<td>params</td> <td>((3, 3) array) Homogeneous transformation matrix.</td> </tr>  </table> <dl class="method"> <dt id="skimage.transform.AffineTransform.__init__">
<code>__init__(matrix=None, scale=None, rotation=None, shear=None, translation=None)</code> <a class="reference external" href="http://github.com/scikit-image/scikit-image/blob/v0.12.2/skimage/transform/_geometric.py#L386" target="_blank"><span class="viewcode-link">[source]</span></a>
</dt> 
</dl> <dl class="attribute"> <dt id="skimage.transform.AffineTransform.rotation">
<code>rotation</code> </dt> 
</dl> <dl class="attribute"> <dt id="skimage.transform.AffineTransform.scale">
<code>scale</code> </dt> 
</dl> <dl class="attribute"> <dt id="skimage.transform.AffineTransform.shear">
<code>shear</code> </dt> 
</dl> <dl class="attribute"> <dt id="skimage.transform.AffineTransform.translation">
<code>translation</code> </dt> 
</dl> </dd>
</dl>   <h2 id="piecewiseaffinetransform">PiecewiseAffineTransform</h2> <dl class="class"> <dt id="skimage.transform.PiecewiseAffineTransform">
<code>class skimage.transform.PiecewiseAffineTransform</code> <a class="reference external" href="http://github.com/scikit-image/scikit-image/blob/v0.12.2/skimage/transform/_geometric.py#L439" target="_blank"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Bases: <code>skimage.transform._geometric.GeometricTransform</code></p> <p>2D piecewise affine transformation.</p> <p>Control points are used to define the mapping. The transform is based on a Delaunay triangulation of the points to form a mesh. Each triangle is used to find a local affine transform.</p> <h4 class="rubric">Attributes</h4> <table class="docutils">   <tr class="row-odd">
<td>affines</td> <td>(list of AffineTransform objects) Affine transformations for each triangle in the mesh.</td> </tr> <tr class="row-even">
<td>inverse_affines</td> <td>(list of AffineTransform objects) Inverse affine transformations for each triangle in the mesh.</td> </tr>  </table> <dl class="method"> <dt id="skimage.transform.PiecewiseAffineTransform.__init__">
<code>__init__()</code> <a class="reference external" href="http://github.com/scikit-image/scikit-image/blob/v0.12.2/skimage/transform/_geometric.py#L456" target="_blank"><span class="viewcode-link">[source]</span></a>
</dt> 
</dl> <dl class="method"> <dt id="skimage.transform.PiecewiseAffineTransform.estimate">
<code>estimate(src, dst)</code> <a class="reference external" href="http://github.com/scikit-image/scikit-image/blob/v0.12.2/skimage/transform/_geometric.py#L462" target="_blank"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Set the control points with which to perform the piecewise mapping.</p> <p>Number of source and destination coordinates must match.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr class="field-odd field">
<th class="field-name">Parameters:</th>
<td class="field-body">
<p class="first"><strong>src</strong> : (N, 2) array</p>  <p>Source coordinates.</p>  <p><strong>dst</strong> : (N, 2) array</p>  <p>Destination coordinates.</p>  </td> </tr> <tr class="field-even field">
<th class="field-name">Returns:</th>
<td class="field-body">
<p class="first"><strong>success</strong> : bool</p>  <p>True, if model estimation succeeds.</p>  </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="skimage.transform.PiecewiseAffineTransform.inverse">
<code>inverse(coords)</code> <a class="reference external" href="http://github.com/scikit-image/scikit-image/blob/v0.12.2/skimage/transform/_geometric.py#L538" target="_blank"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Apply inverse transformation.</p> <p>Coordinates outside of the mesh will be set to <code>- 1</code>.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr class="field-odd field">
<th class="field-name">Parameters:</th>
<td class="field-body">
<p class="first"><strong>coords</strong> : (N, 2) array</p>  <p>Source coordinates.</p>  </td> </tr> <tr class="field-even field">
<th class="field-name">Returns:</th>
<td class="field-body">
<p class="first"><strong>coords</strong> : (N, 2) array</p>  <p>Transformed coordinates.</p>  </td> </tr>  </table> </dd>
</dl> </dd>
</dl>   <h2 id="polynomialtransform">PolynomialTransform</h2> <dl class="class"> <dt id="skimage.transform.PolynomialTransform">
<code>class skimage.transform.PolynomialTransform(params=None)</code> <a class="reference external" href="http://github.com/scikit-image/scikit-image/blob/v0.12.2/skimage/transform/_geometric.py#L746" target="_blank"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Bases: <code>skimage.transform._geometric.GeometricTransform</code></p> <p>2D transformation of the form:</p> <p>..:math:</p>  X = sum[j=0:order]( sum[i=0:j]( a_ji * x**(j - i) * y**i )) Y = sum[j=0:order]( sum[i=0:j]( b_ji * x**(j - i) * y**i )) <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr class="field-odd field">
<th class="field-name">Parameters:</th>
<td class="field-body">
<p class="first"><strong>params</strong> : (2, N) array, optional</p>  <p>Polynomial coefficients where <code>N * 2 = (order + 1) * (order + 2)</code>. So, a_ji is defined in <code>params[0, :]</code> and b_ji in <code>params[1, :]</code>.</p>  </td> </tr>  </table> <h4 class="rubric">Attributes</h4> <table class="docutils">   <tr class="row-odd">
<td>params</td> <td>((2, N) array) Polynomial coefficients where <code>N * 2 = (order + 1) * (order + 2)</code>. So, a_ji is defined in <code>params[0, :]</code> and b_ji in <code>params[1, :]</code>.</td> </tr>  </table> <dl class="method"> <dt id="skimage.transform.PolynomialTransform.__init__">
<code>__init__(params=None)</code> <a class="reference external" href="http://github.com/scikit-image/scikit-image/blob/v0.12.2/skimage/transform/_geometric.py#L768" target="_blank"><span class="viewcode-link">[source]</span></a>
</dt> 
</dl> <dl class="method"> <dt id="skimage.transform.PolynomialTransform.estimate">
<code>estimate(src, dst, order=2)</code> <a class="reference external" href="http://github.com/scikit-image/scikit-image/blob/v0.12.2/skimage/transform/_geometric.py#L776" target="_blank"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Set the transformation matrix with the explicit transformation parameters.</p> <p>You can determine the over-, well- and under-determined parameters with the total least-squares method.</p> <p>Number of source and destination coordinates must match.</p> <p>The transformation is defined as:</p> <pre data-language="python">X = sum[j=0:order]( sum[i=0:j]( a_ji * x**(j - i) * y**i ))
Y = sum[j=0:order]( sum[i=0:j]( b_ji * x**(j - i) * y**i ))
</pre> <p>These equations can be transformed to the following form:</p> <pre data-language="python">0 = sum[j=0:order]( sum[i=0:j]( a_ji * x**(j - i) * y**i )) - X
0 = sum[j=0:order]( sum[i=0:j]( b_ji * x**(j - i) * y**i )) - Y
</pre> <p>which exist for each set of corresponding points, so we have a set of N * 2 equations. The coefficients appear linearly so we can write A x = 0, where:</p> <pre data-language="python">A   = [[1 x y x**2 x*y y**2 ... 0 ...             0 -X]
       [0 ...                 0 1 x y x**2 x*y y**2 -Y]
        ...
        ...
      ]
x.T = [a00 a10 a11 a20 a21 a22 ... ann
       b00 b10 b11 b20 b21 b22 ... bnn c3]
</pre> <p>In case of total least-squares the solution of this homogeneous system of equations is the right singular vector of A which corresponds to the smallest singular value normed by the coefficient c3.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr class="field-odd field">
<th class="field-name">Parameters:</th>
<td class="field-body">
<p class="first"><strong>src</strong> : (N, 2) array</p>  <p>Source coordinates.</p>  <p><strong>dst</strong> : (N, 2) array</p>  <p>Destination coordinates.</p>  <p><strong>order</strong> : int, optional</p>  <p>Polynomial order (number of coefficients is order + 1).</p>  </td> </tr> <tr class="field-even field">
<th class="field-name">Returns:</th>
<td class="field-body">
<p class="first"><strong>success</strong> : bool</p>  <p>True, if model estimation succeeds.</p>  </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="skimage.transform.PolynomialTransform.inverse">
<code>inverse(coords)</code> <a class="reference external" href="http://github.com/scikit-image/scikit-image/blob/v0.12.2/skimage/transform/_geometric.py#L887" target="_blank"><span class="viewcode-link">[source]</span></a>
</dt> 
</dl> </dd>
</dl>   <h2 id="projectivetransform">ProjectiveTransform</h2> <dl class="class"> <dt id="skimage.transform.ProjectiveTransform">
<code>class skimage.transform.ProjectiveTransform(matrix=None)</code> <a class="reference external" href="http://github.com/scikit-image/scikit-image/blob/v0.12.2/skimage/transform/_geometric.py#L137" target="_blank"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Bases: <code>skimage.transform._geometric.GeometricTransform</code></p> <p>Matrix transformation.</p> <p>Apply a projective transformation (homography) on coordinates.</p> <p>For each homogeneous coordinate <img class="math" src="http://scikit-image.org/docs/0.12.x/_images/math/e17eed3b373034f601fd8282af816ad9a5a2c3ae.png" alt="\mathbf{x} = [x, y, 1]^T">, its target position is calculated by multiplying with the given matrix, <img class="math" src="http://scikit-image.org/docs/0.12.x/_images/math/48f75e0b463f2fdb7fca9566cffdc439cae6967f.png" alt="H">, to give <img class="math" src="http://scikit-image.org/docs/0.12.x/_images/math/f9ed235ba4b6a90483667ccc43734ff051fc323b.png" alt="H \mathbf{x}">:</p> <pre data-language="python">[[a0 a1 a2]
 [b0 b1 b2]
 [c0 c1 1 ]].
</pre> <p>E.g., to rotate by theta degrees clockwise, the matrix should be:</p> <pre data-language="python">[[cos(theta) -sin(theta) 0]
 [sin(theta)  cos(theta) 0]
 [0            0         1]]
</pre> <p>or, to translate x by 10 and y by 20:</p> <pre data-language="python">[[1 0 10]
 [0 1 20]
 [0 0 1 ]].
</pre> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr class="field-odd field">
<th class="field-name">Parameters:</th>
<td class="field-body">
<p class="first"><strong>matrix</strong> : (3, 3) array, optional</p>  <p>Homogeneous transformation matrix.</p>  </td> </tr>  </table> <h4 class="rubric">Attributes</h4> <table class="docutils">   <tr class="row-odd">
<td>params</td> <td>((3, 3) array) Homogeneous transformation matrix.</td> </tr>  </table> <dl class="method"> <dt id="skimage.transform.ProjectiveTransform.__init__">
<code>__init__(matrix=None)</code> <a class="reference external" href="http://github.com/scikit-image/scikit-image/blob/v0.12.2/skimage/transform/_geometric.py#L176" target="_blank"><span class="viewcode-link">[source]</span></a>
</dt> 
</dl> <dl class="method"> <dt id="skimage.transform.ProjectiveTransform.estimate">
<code>estimate(src, dst)</code> <a class="reference external" href="http://github.com/scikit-image/scikit-image/blob/v0.12.2/skimage/transform/_geometric.py#L220" target="_blank"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Set the transformation matrix with the explicit transformation parameters.</p> <p>You can determine the over-, well- and under-determined parameters with the total least-squares method.</p> <p>Number of source and destination coordinates must match.</p> <p>The transformation is defined as:</p> <pre data-language="python">X = (a0*x + a1*y + a2) / (c0*x + c1*y + 1)
Y = (b0*x + b1*y + b2) / (c0*x + c1*y + 1)
</pre> <p>These equations can be transformed to the following form:</p> <pre data-language="python">0 = a0*x + a1*y + a2 - c0*x*X - c1*y*X - X
0 = b0*x + b1*y + b2 - c0*x*Y - c1*y*Y - Y
</pre> <p>which exist for each set of corresponding points, so we have a set of N * 2 equations. The coefficients appear linearly so we can write A x = 0, where:</p> <pre data-language="python">A   = [[x y 1 0 0 0 -x*X -y*X -X]
       [0 0 0 x y 1 -x*Y -y*Y -Y]
        ...
        ...
      ]
x.T = [a0 a1 a2 b0 b1 b2 c0 c1 c3]
</pre> <p>In case of total least-squares the solution of this homogeneous system of equations is the right singular vector of A which corresponds to the smallest singular value normed by the coefficient c3.</p> <p>In case of the affine transformation the coefficients c0 and c1 are 0. Thus the system of equations is:</p> <pre data-language="python">A   = [[x y 1 0 0 0 -X]
       [0 0 0 x y 1 -Y]
        ...
        ...
      ]
x.T = [a0 a1 a2 b0 b1 b2 c3]
</pre> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr class="field-odd field">
<th class="field-name">Parameters:</th>
<td class="field-body">
<p class="first"><strong>src</strong> : (N, 2) array</p>  <p>Source coordinates.</p>  <p><strong>dst</strong> : (N, 2) array</p>  <p>Destination coordinates.</p>  </td> </tr> <tr class="field-even field">
<th class="field-name">Returns:</th>
<td class="field-body">
<p class="first"><strong>success</strong> : bool</p>  <p>True, if model estimation succeeds.</p>  </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="skimage.transform.ProjectiveTransform.inverse">
<code>inverse(coords)</code> <a class="reference external" href="http://github.com/scikit-image/scikit-image/blob/v0.12.2/skimage/transform/_geometric.py#L204" target="_blank"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Apply inverse transformation.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr class="field-odd field">
<th class="field-name">Parameters:</th>
<td class="field-body">
<p class="first"><strong>coords</strong> : (N, 2) array</p>  <p>Source coordinates.</p>  </td> </tr> <tr class="field-even field">
<th class="field-name">Returns:</th>
<td class="field-body">
<p class="first"><strong>coords</strong> : (N, 2) array</p>  <p>Transformed coordinates.</p>  </td> </tr>  </table> </dd>
</dl> </dd>
</dl>   <h2 id="similaritytransform">SimilarityTransform</h2> <dl class="class"> <dt id="skimage.transform.SimilarityTransform">
<code>class skimage.transform.SimilarityTransform(matrix=None, scale=None, rotation=None, translation=None)</code> <a class="reference external" href="http://github.com/scikit-image/scikit-image/blob/v0.12.2/skimage/transform/_geometric.py#L574" target="_blank"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Bases: <code>skimage.transform._geometric.ProjectiveTransform</code></p> <p>2D similarity transformation of the form:</p> <p>..:math:</p>  <dl class="docutils"> <dt>X = a0 * x - b0 * y + a1 =</dt> <dd>= m * x * cos(rotation) - m * y * sin(rotation) + a1</dd> <dt>Y = b0 * x + a0 * y + b1 =</dt> <dd>= m * x * sin(rotation) + m * y * cos(rotation) + b1</dd> </dl>  <p>where <code>m</code> is a zoom factor and the homogeneous transformation matrix is:</p> <pre data-language="python">[[a0  b0  a1]
 [b0  a0  b1]
 [0   0    1]]
</pre> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr class="field-odd field">
<th class="field-name">Parameters:</th>
<td class="field-body">
<p class="first"><strong>matrix</strong> : (3, 3) array, optional</p>  <p>Homogeneous transformation matrix.</p>  <p><strong>scale</strong> : float, optional</p>  <p>Scale factor.</p>  <p><strong>rotation</strong> : float, optional</p>  <p>Rotation angle in counter-clockwise direction as radians.</p>  <p><strong>translation</strong> : (tx, ty) as array, list or tuple, optional</p>  <p>x, y translation parameters.</p>  </td> </tr>  </table> <h4 class="rubric">Attributes</h4> <table class="docutils">   <tr class="row-odd">
<td>params</td> <td>((3, 3) array) Homogeneous transformation matrix.</td> </tr>  </table> <dl class="method"> <dt id="skimage.transform.SimilarityTransform.__init__">
<code>__init__(matrix=None, scale=None, rotation=None, translation=None)</code> <a class="reference external" href="http://github.com/scikit-image/scikit-image/blob/v0.12.2/skimage/transform/_geometric.py#L609" target="_blank"><span class="viewcode-link">[source]</span></a>
</dt> 
</dl> <dl class="method"> <dt id="skimage.transform.SimilarityTransform.estimate">
<code>estimate(src, dst)</code> <a class="reference external" href="http://github.com/scikit-image/scikit-image/blob/v0.12.2/skimage/transform/_geometric.py#L640" target="_blank"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Set the transformation matrix with the explicit parameters.</p> <p>You can determine the over-, well- and under-determined parameters with the total least-squares method.</p> <p>Number of source and destination coordinates must match.</p> <p>The transformation is defined as:</p> <pre data-language="python">X = a0 * x - b0 * y + a1
Y = b0 * x + a0 * y + b1
</pre> <p>These equations can be transformed to the following form:</p> <pre data-language="python">0 = a0 * x - b0 * y + a1 - X
0 = b0 * x + a0 * y + b1 - Y
</pre> <p>which exist for each set of corresponding points, so we have a set of N * 2 equations. The coefficients appear linearly so we can write A x = 0, where:</p> <pre data-language="python">A   = [[x 1 -y 0 -X]
       [y 0  x 1 -Y]
        ...
        ...
      ]
x.T = [a0 a1 b0 b1 c3]
</pre> <p>In case of total least-squares the solution of this homogeneous system of equations is the right singular vector of A which corresponds to the smallest singular value normed by the coefficient c3.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr class="field-odd field">
<th class="field-name">Parameters:</th>
<td class="field-body">
<p class="first"><strong>src</strong> : (N, 2) array</p>  <p>Source coordinates.</p>  <p><strong>dst</strong> : (N, 2) array</p>  <p>Destination coordinates.</p>  </td> </tr> <tr class="field-even field">
<th class="field-name">Returns:</th>
<td class="field-body">
<p class="first"><strong>success</strong> : bool</p>  <p>True, if model estimation succeeds.</p>  </td> </tr>  </table> </dd>
</dl> <dl class="attribute"> <dt id="skimage.transform.SimilarityTransform.rotation">
<code>rotation</code> </dt> 
</dl> <dl class="attribute"> <dt id="skimage.transform.SimilarityTransform.scale">
<code>scale</code> </dt> 
</dl> <dl class="attribute"> <dt id="skimage.transform.SimilarityTransform.translation">
<code>translation</code> </dt> 
</dl> </dd>
</dl>
<div class="_attribution">
  <p class="_attribution-p">
    © 2011 the scikit-image team<br>Licensed under the BSD 3-clause License.<br>
    <a href="http://scikit-image.org/docs/0.12.x/api/skimage.transform.html" class="_attribution-link" target="_blank">http://scikit-image.org/docs/0.12.x/api/skimage.transform.html</a>
  </p>
</div>

			</div>
		</div>
	</section>

	</div>
</body>
</html>
