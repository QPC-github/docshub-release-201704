
<!DOCTYPE HTML>

<html lang="en">

<head>
  <meta charset="utf-8">
  <title>Morphology - Scikit-image - W3cubDocs</title>
  
  <meta name="description" content=" Generates a ball-shaped structuring element. ">
  <meta name="keywords" content="module, morphology, -, scikit-image, scikit_image">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="http://docs.w3cub.com/scikit_image/api/skimage.morphology/">
  <link href="/favicon.png" rel="icon">
  <link type="text/css" rel="stylesheet" href="/assets/application-50364fff564ce3b6327021805f3f00e2957b441cf27f576a7dd4ff63bbc47047.css">
  <script type="text/javascript" src="/assets/application-db64bfd54ceb42be11af7995804cf4902548419ceb79d509b0b7d62c22d98e6f.js"></script>
  <script src="/json/scikit_image.js"></script>
  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-71174418-1']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>


</head>

<body>
	<div class="_app">
	<header class="_header">
  
  <form class="_search">
    <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
    <a class="_search-clear"></a>
    <div class="_search-tag"></div>
  </form>
  
  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/scikit_image/" class="_nav-link" title="" style="margin-left:0;">scikit-image</a></span>
  
  <nav class="_nav">
    <a href="/app/" class="_nav-link ">App</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		<div class="_list">
			
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<div class="_page _sphinx">
				
<h1 id="module-morphology">Module: morphology</h1> <table class="longtable docutils" id="module-skimage.morphology">   <tr class="row-odd">
<td>
<a class="reference internal" href="#skimage.morphology.ball" title="skimage.morphology.ball"><code>skimage.morphology.ball</code></a>(radius[, dtype])</td> <td>Generates a ball-shaped structuring element.</td> </tr> <tr class="row-even">
<td>
<a class="reference internal" href="#skimage.morphology.binary_closing" title="skimage.morphology.binary_closing"><code>skimage.morphology.binary_closing</code></a>(image[, selem])</td> <td>Return fast binary morphological closing of an image.</td> </tr> <tr class="row-odd">
<td>
<a class="reference internal" href="#skimage.morphology.binary_dilation" title="skimage.morphology.binary_dilation"><code>skimage.morphology.binary_dilation</code></a>(image[, ...])</td> <td>Return fast binary morphological dilation of an image.</td> </tr> <tr class="row-even">
<td>
<a class="reference internal" href="#skimage.morphology.binary_erosion" title="skimage.morphology.binary_erosion"><code>skimage.morphology.binary_erosion</code></a>(image[, selem])</td> <td>Return fast binary morphological erosion of an image.</td> </tr> <tr class="row-odd">
<td>
<a class="reference internal" href="#skimage.morphology.binary_opening" title="skimage.morphology.binary_opening"><code>skimage.morphology.binary_opening</code></a>(image[, selem])</td> <td>Return fast binary morphological opening of an image.</td> </tr> <tr class="row-even">
<td>
<a class="reference internal" href="#skimage.morphology.black_tophat" title="skimage.morphology.black_tophat"><code>skimage.morphology.black_tophat</code></a>(image[, selem])</td> <td>Return black top hat of an image.</td> </tr> <tr class="row-odd">
<td>
<a class="reference internal" href="#skimage.morphology.closing" title="skimage.morphology.closing"><code>skimage.morphology.closing</code></a>(image[, selem])</td> <td>Return greyscale morphological closing of an image.</td> </tr> <tr class="row-even">
<td>
<a class="reference internal" href="#skimage.morphology.convex_hull_image" title="skimage.morphology.convex_hull_image"><code>skimage.morphology.convex_hull_image</code></a>(image)</td> <td>Compute the convex hull image of a binary image.</td> </tr> <tr class="row-odd">
<td>
<a class="reference internal" href="#skimage.morphology.convex_hull_object" title="skimage.morphology.convex_hull_object"><code>skimage.morphology.convex_hull_object</code></a>(image)</td> <td>Compute the convex hull image of individual objects in a binary image.</td> </tr> <tr class="row-even">
<td>
<a class="reference internal" href="#skimage.morphology.cube" title="skimage.morphology.cube"><code>skimage.morphology.cube</code></a>(width[, dtype])</td> <td>Generates a cube-shaped structuring element.</td> </tr> <tr class="row-odd">
<td>
<a class="reference internal" href="#skimage.morphology.diamond" title="skimage.morphology.diamond"><code>skimage.morphology.diamond</code></a>(radius[, dtype])</td> <td>Generates a flat, diamond-shaped structuring element.</td> </tr> <tr class="row-even">
<td>
<a class="reference internal" href="#skimage.morphology.dilation" title="skimage.morphology.dilation"><code>skimage.morphology.dilation</code></a>(image[, selem])</td> <td>Return greyscale morphological dilation of an image.</td> </tr> <tr class="row-odd">
<td>
<a class="reference internal" href="#skimage.morphology.disk" title="skimage.morphology.disk"><code>skimage.morphology.disk</code></a>(radius[, dtype])</td> <td>Generates a flat, disk-shaped structuring element.</td> </tr> <tr class="row-even">
<td>
<a class="reference internal" href="#skimage.morphology.erosion" title="skimage.morphology.erosion"><code>skimage.morphology.erosion</code></a>(image[, selem])</td> <td>Return greyscale morphological erosion of an image.</td> </tr> <tr class="row-odd">
<td>
<a class="reference internal" href="#skimage.morphology.label" title="skimage.morphology.label"><code>skimage.morphology.label</code></a>(input[, neighbors, ...])</td> <td>Label connected regions of an integer array.</td> </tr> <tr class="row-even">
<td>
<a class="reference internal" href="#skimage.morphology.medial_axis" title="skimage.morphology.medial_axis"><code>skimage.morphology.medial_axis</code></a>(image[, ...])</td> <td>Compute the medial axis transform of a binary image</td> </tr> <tr class="row-odd">
<td>
<a class="reference internal" href="#skimage.morphology.octagon" title="skimage.morphology.octagon"><code>skimage.morphology.octagon</code></a>(m, n[, dtype])</td> <td>Generates an octagon shaped structuring element.</td> </tr> <tr class="row-even">
<td>
<a class="reference internal" href="#skimage.morphology.octahedron" title="skimage.morphology.octahedron"><code>skimage.morphology.octahedron</code></a>(radius[, dtype])</td> <td>Generates a octahedron-shaped structuring element.</td> </tr> <tr class="row-odd">
<td>
<a class="reference internal" href="#skimage.morphology.opening" title="skimage.morphology.opening"><code>skimage.morphology.opening</code></a>(image[, selem])</td> <td>Return greyscale morphological opening of an image.</td> </tr> <tr class="row-even">
<td>
<a class="reference internal" href="#skimage.morphology.reconstruction" title="skimage.morphology.reconstruction"><code>skimage.morphology.reconstruction</code></a>(seed, mask)</td> <td>Perform a morphological reconstruction of an image.</td> </tr> <tr class="row-odd">
<td>
<a class="reference internal" href="#skimage.morphology.rectangle" title="skimage.morphology.rectangle"><code>skimage.morphology.rectangle</code></a>(width, height)</td> <td>Generates a flat, rectangular-shaped structuring element.</td> </tr> <tr class="row-even">
<td>
<a class="reference internal" href="#skimage.morphology.remove_small_holes" title="skimage.morphology.remove_small_holes"><code>skimage.morphology.remove_small_holes</code></a>(ar[, ...])</td> <td>Remove continguous holes smaller than the specified size.</td> </tr> <tr class="row-odd">
<td>
<a class="reference internal" href="#skimage.morphology.remove_small_objects" title="skimage.morphology.remove_small_objects"><code>skimage.morphology.remove_small_objects</code></a>(ar)</td> <td>Remove connected components smaller than the specified size.</td> </tr> <tr class="row-even">
<td>
<a class="reference internal" href="#skimage.morphology.skeletonize" title="skimage.morphology.skeletonize"><code>skimage.morphology.skeletonize</code></a>(image)</td> <td>Return the skeleton of a binary image.</td> </tr> <tr class="row-odd">
<td>
<a class="reference internal" href="#skimage.morphology.skeletonize_3d" title="skimage.morphology.skeletonize_3d"><code>skimage.morphology.skeletonize_3d</code></a>(img)</td> <td>Compute the skeleton of a binary image.</td> </tr> <tr class="row-even">
<td>
<a class="reference internal" href="#skimage.morphology.square" title="skimage.morphology.square"><code>skimage.morphology.square</code></a>(width[, dtype])</td> <td>Generates a flat, square-shaped structuring element.</td> </tr> <tr class="row-odd">
<td>
<a class="reference internal" href="#skimage.morphology.star" title="skimage.morphology.star"><code>skimage.morphology.star</code></a>(a[, dtype])</td> <td>Generates a star shaped structuring element.</td> </tr> <tr class="row-even">
<td>
<a class="reference internal" href="#skimage.morphology.watershed" title="skimage.morphology.watershed"><code>skimage.morphology.watershed</code></a>(image, markers)</td> <td>Return a matrix labeled using the watershed segmentation algorithm</td> </tr> <tr class="row-odd">
<td>
<a class="reference internal" href="#skimage.morphology.white_tophat" title="skimage.morphology.white_tophat"><code>skimage.morphology.white_tophat</code></a>(image[, selem])</td> <td>Return white top hat of an image.</td> </tr>  </table>  <h2 id="ball">ball</h2> <dl class="function"> <dt id="skimage.morphology.ball">
<code>skimage.morphology.ball(radius, dtype=&lt;type 'numpy.uint8'&gt;)</code> <a class="reference external" href="http://github.com/scikit-image/scikit-image/blob/v0.12.2/skimage/morphology/selem.py#L221" target="_blank"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Generates a ball-shaped structuring element.</p> <p>This is the 3D equivalent of a disk. A pixel is within the neighborhood if the euclidean distance between it and the origin is no greater than radius.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr class="field-odd field">
<th class="field-name">Parameters:</th>
<td class="field-body">
<p class="first"><strong>radius</strong> : int</p>  <p>The radius of the ball-shaped structuring element.</p>  </td> </tr> <tr class="field-even field">
<th class="field-name">Returns:</th>
<td class="field-body">
<p class="first"><strong>selem</strong> : ndarray</p>  <p>The structuring element where elements of the neighborhood are 1 and 0 otherwise.</p>  </td> </tr> <tr class="field-odd field"><th class="field-name" colspan="2">Other Parameters:</th></tr> <tr class="field-odd field">
<td> </td>
<td class="field-body">
<p class="first"><strong>dtype</strong> : data-type</p>  <p>The data type of the structuring element.</p>  </td> </tr>  </table> </dd>
</dl>   <h2 id="binary-closing">binary_closing</h2> <dl class="function"> <dt id="skimage.morphology.binary_closing">
<code>skimage.morphology.binary_closing(image, selem=None, *args, **kwargs)</code> <a class="reference external" href="http://github.com/scikit-image/scikit-image/blob/v0.12.2/skimage/morphology/misc.py#L33" target="_blank"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Return fast binary morphological closing of an image.</p> <p>This function returns the same result as greyscale closing but performs faster for binary images.</p> <p>The morphological closing on an image is defined as a dilation followed by an erosion. Closing can remove small dark spots (i.e. “pepper”) and connect small bright cracks. This tends to “close” up (dark) gaps between (bright) features.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr class="field-odd field">
<th class="field-name">Parameters:</th>
<td class="field-body">
<p class="first"><strong>image</strong> : ndarray</p>  <p>Binary input image.</p>  <p><strong>selem</strong> : ndarray, optional</p>  <p>The neighborhood expressed as a 2-D array of 1’s and 0’s. If None, use cross-shaped structuring element (connectivity=1).</p>  <p><strong>out</strong> : ndarray of bool, optional</p>  <p>The array to store the result of the morphology. If None, is passed, a new array will be allocated.</p>  </td> </tr> <tr class="field-even field">
<th class="field-name">Returns:</th>
<td class="field-body">
<p class="first"><strong>closing</strong> : ndarray of bool</p>  <p>The result of the morphological closing.</p>  </td> </tr>  </table> </dd>
</dl>   <h2 id="binary-dilation">binary_dilation</h2> <dl class="function"> <dt id="skimage.morphology.binary_dilation">
<code>skimage.morphology.binary_dilation(image, selem=None, *args, **kwargs)</code> <a class="reference external" href="http://github.com/scikit-image/scikit-image/blob/v0.12.2/skimage/morphology/misc.py#L33" target="_blank"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Return fast binary morphological dilation of an image.</p> <p>This function returns the same result as greyscale dilation but performs faster for binary images.</p> <p>Morphological dilation sets a pixel at <code>(i,j)</code> to the maximum over all pixels in the neighborhood centered at <code>(i,j)</code>. Dilation enlarges bright regions and shrinks dark regions.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr class="field-odd field">
<th class="field-name">Parameters:</th>
<td class="field-body">
<p class="first"><strong>image</strong> : ndarray</p>  <p>Binary input image.</p>  <p><strong>selem</strong> : ndarray, optional</p>  <p>The neighborhood expressed as a 2-D array of 1’s and 0’s. If None, use cross-shaped structuring element (connectivity=1).</p>  <p><strong>out</strong> : ndarray of bool, optional</p>  <p>The array to store the result of the morphology. If None, is passed, a new array will be allocated.</p>  </td> </tr> <tr class="field-even field">
<th class="field-name">Returns:</th>
<td class="field-body">
<p class="first"><strong>dilated</strong> : ndarray of bool or uint</p>  <p>The result of the morphological dilation with values in <code>[False, True]</code>.</p>  </td> </tr>  </table> </dd>
</dl>   <h2 id="binary-erosion">binary_erosion</h2> <dl class="function"> <dt id="skimage.morphology.binary_erosion">
<code>skimage.morphology.binary_erosion(image, selem=None, *args, **kwargs)</code> <a class="reference external" href="http://github.com/scikit-image/scikit-image/blob/v0.12.2/skimage/morphology/misc.py#L33" target="_blank"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Return fast binary morphological erosion of an image.</p> <p>This function returns the same result as greyscale erosion but performs faster for binary images.</p> <p>Morphological erosion sets a pixel at <code>(i,j)</code> to the minimum over all pixels in the neighborhood centered at <code>(i,j)</code>. Erosion shrinks bright regions and enlarges dark regions.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr class="field-odd field">
<th class="field-name">Parameters:</th>
<td class="field-body">
<p class="first"><strong>image</strong> : ndarray</p>  <p>Binary input image.</p>  <p><strong>selem</strong> : ndarray, optional</p>  <p>The neighborhood expressed as a 2-D array of 1’s and 0’s. If None, use cross-shaped structuring element (connectivity=1).</p>  <p><strong>out</strong> : ndarray of bool, optional</p>  <p>The array to store the result of the morphology. If None is passed, a new array will be allocated.</p>  </td> </tr> <tr class="field-even field">
<th class="field-name">Returns:</th>
<td class="field-body">
<p class="first"><strong>eroded</strong> : ndarray of bool or uint</p>  <p>The result of the morphological erosion taking values in <code>[False, True]</code>.</p>  </td> </tr>  </table> </dd>
</dl>   <h2 id="binary-opening">binary_opening</h2> <dl class="function"> <dt id="skimage.morphology.binary_opening">
<code>skimage.morphology.binary_opening(image, selem=None, *args, **kwargs)</code> <a class="reference external" href="http://github.com/scikit-image/scikit-image/blob/v0.12.2/skimage/morphology/misc.py#L33" target="_blank"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Return fast binary morphological opening of an image.</p> <p>This function returns the same result as greyscale opening but performs faster for binary images.</p> <p>The morphological opening on an image is defined as an erosion followed by a dilation. Opening can remove small bright spots (i.e. “salt”) and connect small dark cracks. This tends to “open” up (dark) gaps between (bright) features.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr class="field-odd field">
<th class="field-name">Parameters:</th>
<td class="field-body">
<p class="first"><strong>image</strong> : ndarray</p>  <p>Binary input image.</p>  <p><strong>selem</strong> : ndarray, optional</p>  <p>The neighborhood expressed as a 2-D array of 1’s and 0’s. If None, use cross-shaped structuring element (connectivity=1).</p>  <p><strong>out</strong> : ndarray of bool, optional</p>  <p>The array to store the result of the morphology. If None is passed, a new array will be allocated.</p>  </td> </tr> <tr class="field-even field">
<th class="field-name">Returns:</th>
<td class="field-body">
<p class="first"><strong>opening</strong> : ndarray of bool</p>  <p>The result of the morphological opening.</p>  </td> </tr>  </table> </dd>
</dl>   <h2 id="black-tophat">black_tophat</h2> <dl class="function"> <dt id="skimage.morphology.black_tophat">
<code>skimage.morphology.black_tophat(image, selem=None, *args, **kwargs)</code> <a class="reference external" href="http://github.com/scikit-image/scikit-image/blob/v0.12.2/skimage/morphology/misc.py#L33" target="_blank"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Return black top hat of an image.</p> <p>The black top hat of an image is defined as its morphological closing minus the original image. This operation returns the dark spots of the image that are smaller than the structuring element. Note that dark spots in the original image are bright spots after the black top hat.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr class="field-odd field">
<th class="field-name">Parameters:</th>
<td class="field-body">
<p class="first"><strong>image</strong> : ndarray</p>  <p>Image array.</p>  <p><strong>selem</strong> : ndarray, optional</p>  <p>The neighborhood expressed as a 2-D array of 1’s and 0’s. If None, use cross-shaped structuring element (connectivity=1).</p>  <p><strong>out</strong> : ndarray, optional</p>  <p>The array to store the result of the morphology. If None is passed, a new array will be allocated.</p>  </td> </tr> <tr class="field-even field">
<th class="field-name">Returns:</th>
<td class="field-body">
<p class="first"><strong>opening</strong> : array, same shape and type as <code>image</code></p>  <p>The result of the black top filter.</p>  </td> </tr>  </table> <h4 class="rubric">Examples</h4> <pre data-language="python">&gt;&gt;&gt; # Change dark peak to bright peak and subtract background
&gt;&gt;&gt; import numpy as np
&gt;&gt;&gt; from skimage.morphology import square
&gt;&gt;&gt; dark_on_grey = np.array([[7, 6, 6, 6, 7],
...                          [6, 5, 4, 5, 6],
...                          [6, 4, 0, 4, 6],
...                          [6, 5, 4, 5, 6],
...                          [7, 6, 6, 6, 7]], dtype=np.uint8)
&gt;&gt;&gt; black_tophat(dark_on_grey, square(3))
array([[0, 0, 0, 0, 0],
       [0, 0, 1, 0, 0],
       [0, 1, 5, 1, 0],
       [0, 0, 1, 0, 0],
       [0, 0, 0, 0, 0]], dtype=uint8)
</pre> </dd>
</dl>   <h2 id="closing">closing</h2> <dl class="function"> <dt id="skimage.morphology.closing">
<code>skimage.morphology.closing(image, selem=None, *args, **kwargs)</code> <a class="reference external" href="http://github.com/scikit-image/scikit-image/blob/v0.12.2/skimage/morphology/misc.py#L33" target="_blank"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Return greyscale morphological closing of an image.</p> <p>The morphological closing on an image is defined as a dilation followed by an erosion. Closing can remove small dark spots (i.e. “pepper”) and connect small bright cracks. This tends to “close” up (dark) gaps between (bright) features.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr class="field-odd field">
<th class="field-name">Parameters:</th>
<td class="field-body">
<p class="first"><strong>image</strong> : ndarray</p>  <p>Image array.</p>  <p><strong>selem</strong> : ndarray, optional</p>  <p>The neighborhood expressed as an array of 1’s and 0’s. If None, use cross-shaped structuring element (connectivity=1).</p>  <p><strong>out</strong> : ndarray, optional</p>  <p>The array to store the result of the morphology. If None, is passed, a new array will be allocated.</p>  </td> </tr> <tr class="field-even field">
<th class="field-name">Returns:</th>
<td class="field-body">
<p class="first"><strong>closing</strong> : array, same shape and type as <code>image</code></p>  <p>The result of the morphological closing.</p>  </td> </tr>  </table> <h4 class="rubric">Examples</h4> <pre data-language="python">&gt;&gt;&gt; # Close a gap between two bright lines
&gt;&gt;&gt; import numpy as np
&gt;&gt;&gt; from skimage.morphology import square
&gt;&gt;&gt; broken_line = np.array([[0, 0, 0, 0, 0],
...                         [0, 0, 0, 0, 0],
...                         [1, 1, 0, 1, 1],
...                         [0, 0, 0, 0, 0],
...                         [0, 0, 0, 0, 0]], dtype=np.uint8)
&gt;&gt;&gt; closing(broken_line, square(3))
array([[0, 0, 0, 0, 0],
       [0, 0, 0, 0, 0],
       [1, 1, 1, 1, 1],
       [0, 0, 0, 0, 0],
       [0, 0, 0, 0, 0]], dtype=uint8)
</pre> </dd>
</dl>   <h2 id="convex-hull-image">convex_hull_image</h2> <dl class="function"> <dt id="skimage.morphology.convex_hull_image">
<code>skimage.morphology.convex_hull_image(image)</code> <a class="reference external" href="http://github.com/scikit-image/scikit-image/blob/v0.12.2/skimage/morphology/convex_hull.py#L16" target="_blank"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Compute the convex hull image of a binary image.</p> <p>The convex hull is the set of pixels included in the smallest convex polygon that surround all white pixels in the input image.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr class="field-odd field">
<th class="field-name">Parameters:</th>
<td class="field-body">
<p class="first"><strong>image</strong> : (M, N) array</p>  <p>Binary input image. This array is cast to bool before processing.</p>  </td> </tr> <tr class="field-even field">
<th class="field-name">Returns:</th>
<td class="field-body">
<p class="first"><strong>hull</strong> : (M, N) array of bool</p>  <p>Binary image with pixels in convex hull set to True.</p>  </td> </tr>  </table> <h4 class="rubric">References</h4> <table class="docutils citation" frame="void" id="r296" rules="none">   <tr>
<td class="label"><a class="fn-backref" href="#id1">[R296]</a></td>
<td><a class="reference external" href="http://blogs.mathworks.com/steve/2011/10/04/binary-image-convex-hull-algorithm-notes/" target="_blank">http://blogs.mathworks.com/steve/2011/10/04/binary-image-convex-hull-algorithm-notes/</a></td>
</tr>  </table> </dd>
</dl>   <h2 id="convex-hull-object">convex_hull_object</h2> <dl class="function"> <dt id="skimage.morphology.convex_hull_object">
<code>skimage.morphology.convex_hull_object(image, neighbors=8)</code> <a class="reference external" href="http://github.com/scikit-image/scikit-image/blob/v0.12.2/skimage/morphology/convex_hull.py#L83" target="_blank"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Compute the convex hull image of individual objects in a binary image.</p> <p>The convex hull is the set of pixels included in the smallest convex polygon that surround all white pixels in the input image.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr class="field-odd field">
<th class="field-name">Parameters:</th>
<td class="field-body">
<p class="first"><strong>image</strong> : (M, N) array</p>  <p>Binary input image.</p>  <p><strong>neighbors</strong> : {4, 8}, int</p>  <p>Whether to use 4- or 8-connectivity.</p>  </td> </tr> <tr class="field-even field">
<th class="field-name">Returns:</th>
<td class="field-body">
<p class="first"><strong>hull</strong> : ndarray of bool</p>  <p>Binary image with pixels in convex hull set to True.</p>  </td> </tr>  </table> <h4 class="rubric">Notes</h4> <p>This function uses skimage.morphology.label to define unique objects, finds the convex hull of each using convex_hull_image, and combines these regions with logical OR. Be aware the convex hulls of unconnected objects may overlap in the result. If this is suspected, consider using convex_hull_image separately on each object.</p> </dd>
</dl>   <h2 id="cube">cube</h2> <dl class="function"> <dt id="skimage.morphology.cube">
<code>skimage.morphology.cube(width, dtype=&lt;type 'numpy.uint8'&gt;)</code> <a class="reference external" href="http://github.com/scikit-image/scikit-image/blob/v0.12.2/skimage/morphology/selem.py#L160" target="_blank"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Generates a cube-shaped structuring element.</p> <p>This is the 3D equivalent of a square. Every pixel along the perimeter has a chessboard distance no greater than radius (radius=floor(width/2)) pixels.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr class="field-odd field">
<th class="field-name">Parameters:</th>
<td class="field-body">
<p class="first"><strong>width</strong> : int</p>  <p>The width, height and depth of the cube.</p>  </td> </tr> <tr class="field-even field">
<th class="field-name">Returns:</th>
<td class="field-body">
<p class="first"><strong>selem</strong> : ndarray</p>  <p>A structuring element consisting only of ones, i.e. every pixel belongs to the neighborhood.</p>  </td> </tr> <tr class="field-odd field"><th class="field-name" colspan="2">Other Parameters:</th></tr> <tr class="field-odd field">
<td> </td>
<td class="field-body">
<p class="first"><strong>dtype</strong> : data-type</p>  <p>The data type of the structuring element.</p>  </td> </tr>  </table> </dd>
</dl>   <h2 id="diamond">diamond</h2> <dl class="function"> <dt id="skimage.morphology.diamond">
<code>skimage.morphology.diamond(radius, dtype=&lt;type 'numpy.uint8'&gt;)</code> <a class="reference external" href="http://github.com/scikit-image/scikit-image/blob/v0.12.2/skimage/morphology/selem.py#L60" target="_blank"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Generates a flat, diamond-shaped structuring element.</p> <p>A pixel is part of the neighborhood (i.e. labeled 1) if the city block/Manhattan distance between it and the center of the neighborhood is no greater than radius.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr class="field-odd field">
<th class="field-name">Parameters:</th>
<td class="field-body">
<p class="first"><strong>radius</strong> : int</p>  <p>The radius of the diamond-shaped structuring element.</p>  </td> </tr> <tr class="field-even field">
<th class="field-name">Returns:</th>
<td class="field-body">
<p class="first"><strong>selem</strong> : ndarray</p>  <p>The structuring element where elements of the neighborhood are 1 and 0 otherwise.</p>  </td> </tr> <tr class="field-odd field"><th class="field-name" colspan="2">Other Parameters:</th></tr> <tr class="field-odd field">
<td> </td>
<td class="field-body">
<p class="first"><strong>dtype</strong> : data-type</p>  <p>The data type of the structuring element.</p>  </td> </tr>  </table> </dd>
</dl>   <h2 id="dilation">dilation</h2> <dl class="function"> <dt id="skimage.morphology.dilation">
<code>skimage.morphology.dilation(image, selem=None, *args, **kwargs)</code> <a class="reference external" href="http://github.com/scikit-image/scikit-image/blob/v0.12.2/skimage/morphology/misc.py#L33" target="_blank"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Return greyscale morphological dilation of an image.</p> <p>Morphological dilation sets a pixel at (i,j) to the maximum over all pixels in the neighborhood centered at (i,j). Dilation enlarges bright regions and shrinks dark regions.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr class="field-odd field">
<th class="field-name">Parameters:</th>
<td class="field-body">
<p class="first"><strong>image</strong> : ndarray</p>  <p>Image array.</p>  <p><strong>selem</strong> : ndarray, optional</p>  <p>The neighborhood expressed as a 2-D array of 1’s and 0’s. If None, use cross-shaped structuring element (connectivity=1).</p>  <p><strong>out</strong> : ndarray, optional</p>  <p>The array to store the result of the morphology. If None, is passed, a new array will be allocated.</p>  <p><strong>shift_x, shift_y</strong> : bool, optional</p>  <p>shift structuring element about center point. This only affects eccentric structuring elements (i.e. selem with even numbered sides).</p>  </td> </tr> <tr class="field-even field">
<th class="field-name">Returns:</th>
<td class="field-body">
<p class="first"><strong>dilated</strong> : uint8 array, same shape and type as <code>image</code></p>  <p>The result of the morphological dilation.</p>  </td> </tr>  </table> <h4 class="rubric">Notes</h4> <p>For <code>uint8</code> (and <code>uint16</code> up to a certain bit-depth) data, the lower algorithm complexity makes the <code>skimage.filter.rank.maximum</code> function more efficient for larger images and structuring elements.</p> <h4 class="rubric">Examples</h4> <pre data-language="python">&gt;&gt;&gt; # Dilation enlarges bright regions
&gt;&gt;&gt; import numpy as np
&gt;&gt;&gt; from skimage.morphology import square
&gt;&gt;&gt; bright_pixel = np.array([[0, 0, 0, 0, 0],
...                          [0, 0, 0, 0, 0],
...                          [0, 0, 1, 0, 0],
...                          [0, 0, 0, 0, 0],
...                          [0, 0, 0, 0, 0]], dtype=np.uint8)
&gt;&gt;&gt; dilation(bright_pixel, square(3))
array([[0, 0, 0, 0, 0],
       [0, 1, 1, 1, 0],
       [0, 1, 1, 1, 0],
       [0, 1, 1, 1, 0],
       [0, 0, 0, 0, 0]], dtype=uint8)
</pre> </dd>
</dl>   <h2 id="disk">disk</h2> <dl class="function"> <dt id="skimage.morphology.disk">
<code>skimage.morphology.disk(radius, dtype=&lt;type 'numpy.uint8'&gt;)</code> <a class="reference external" href="http://github.com/scikit-image/scikit-image/blob/v0.12.2/skimage/morphology/selem.py#L90" target="_blank"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Generates a flat, disk-shaped structuring element.</p> <p>A pixel is within the neighborhood if the euclidean distance between it and the origin is no greater than radius.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr class="field-odd field">
<th class="field-name">Parameters:</th>
<td class="field-body">
<p class="first"><strong>radius</strong> : int</p>  <p>The radius of the disk-shaped structuring element.</p>  </td> </tr> <tr class="field-even field">
<th class="field-name">Returns:</th>
<td class="field-body">
<p class="first"><strong>selem</strong> : ndarray</p>  <p>The structuring element where elements of the neighborhood are 1 and 0 otherwise.</p>  </td> </tr> <tr class="field-odd field"><th class="field-name" colspan="2">Other Parameters:</th></tr> <tr class="field-odd field">
<td> </td>
<td class="field-body">
<p class="first"><strong>dtype</strong> : data-type</p>  <p>The data type of the structuring element.</p>  </td> </tr>  </table> </dd>
</dl>   <h2 id="erosion">erosion</h2> <dl class="function"> <dt id="skimage.morphology.erosion">
<code>skimage.morphology.erosion(image, selem=None, *args, **kwargs)</code> <a class="reference external" href="http://github.com/scikit-image/scikit-image/blob/v0.12.2/skimage/morphology/misc.py#L33" target="_blank"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Return greyscale morphological erosion of an image.</p> <p>Morphological erosion sets a pixel at (i,j) to the minimum over all pixels in the neighborhood centered at (i,j). Erosion shrinks bright regions and enlarges dark regions.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr class="field-odd field">
<th class="field-name">Parameters:</th>
<td class="field-body">
<p class="first"><strong>image</strong> : ndarray</p>  <p>Image array.</p>  <p><strong>selem</strong> : ndarray, optional</p>  <p>The neighborhood expressed as an array of 1’s and 0’s. If None, use cross-shaped structuring element (connectivity=1).</p>  <p><strong>out</strong> : ndarrays, optional</p>  <p>The array to store the result of the morphology. If None is passed, a new array will be allocated.</p>  <p><strong>shift_x, shift_y</strong> : bool, optional</p>  <p>shift structuring element about center point. This only affects eccentric structuring elements (i.e. selem with even numbered sides).</p>  </td> </tr> <tr class="field-even field">
<th class="field-name">Returns:</th>
<td class="field-body">
<p class="first"><strong>eroded</strong> : array, same shape as <code>image</code></p>  <p>The result of the morphological erosion.</p>  </td> </tr>  </table> <h4 class="rubric">Notes</h4> <p>For <code>uint8</code> (and <code>uint16</code> up to a certain bit-depth) data, the lower algorithm complexity makes the <code>skimage.filter.rank.minimum</code> function more efficient for larger images and structuring elements.</p> <h4 class="rubric">Examples</h4> <pre data-language="python">&gt;&gt;&gt; # Erosion shrinks bright regions
&gt;&gt;&gt; import numpy as np
&gt;&gt;&gt; from skimage.morphology import square
&gt;&gt;&gt; bright_square = np.array([[0, 0, 0, 0, 0],
...                           [0, 1, 1, 1, 0],
...                           [0, 1, 1, 1, 0],
...                           [0, 1, 1, 1, 0],
...                           [0, 0, 0, 0, 0]], dtype=np.uint8)
&gt;&gt;&gt; erosion(bright_square, square(3))
array([[0, 0, 0, 0, 0],
       [0, 0, 0, 0, 0],
       [0, 0, 1, 0, 0],
       [0, 0, 0, 0, 0],
       [0, 0, 0, 0, 0]], dtype=uint8)
</pre> </dd>
</dl>   <h2 id="label">label</h2> <dl class="function"> <dt id="skimage.morphology.label">
<code>skimage.morphology.label(input, neighbors=None, background=None, return_num=False, connectivity=None)</code> <a class="reference external" href="http://github.com/scikit-image/scikit-image/blob/v0.12.2/skimage/measure/_label.py#L3" target="_blank"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Label connected regions of an integer array.</p> <p>Two pixels are connected when they are neighbors and have the same value. In 2D, they can be neighbors either in a 1- or 2-connected sense. The value refers to the maximum number of orthogonal hops to consider a pixel/voxel a neighbor:</p> <pre data-language="python">1-connectivity      2-connectivity     diagonal connection close-up

     [ ]           [ ]  [ ]  [ ]         [ ]
      |               \  |  /             |  &lt;- hop 2
[ ]--[x]--[ ]      [ ]--[x]--[ ]    [x]--[ ]
      |               /  |  \         hop 1
     [ ]           [ ]  [ ]  [ ]
</pre> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr class="field-odd field">
<th class="field-name">Parameters:</th>
<td class="field-body">
<p class="first"><strong>input</strong> : ndarray of dtype int</p>  <p>Image to label.</p>  <p><strong>neighbors</strong> : {4, 8}, int, optional</p>  <p>Whether to use 4- or 8-“connectivity”. In 3D, 4-“connectivity” means connected pixels have to share face, whereas with 8-“connectivity”, they have to share only edge or vertex. <strong>Deprecated, use ``connectivity`` instead.</strong></p>  <p><strong>background</strong> : int, optional</p>  <p>Consider all pixels with this value as background pixels, and label them as 0. By default, 0-valued pixels are considered as background pixels.</p>  <p><strong>return_num</strong> : bool, optional</p>  <p>Whether to return the number of assigned labels.</p>  <p><strong>connectivity</strong> : int, optional</p>  <p>Maximum number of orthogonal hops to consider a pixel/voxel as a neighbor. Accepted values are ranging from 1 to input.ndim. If <code>None</code>, a full connectivity of <code>input.ndim</code> is used.</p>  </td> </tr> <tr class="field-even field">
<th class="field-name">Returns:</th>
<td class="field-body">
<p class="first"><strong>labels</strong> : ndarray of dtype int</p>  <p>Labeled array, where all connected regions are assigned the same integer value.</p>  <p><strong>num</strong> : int, optional</p>  <p>Number of labels, which equals the maximum label index and is only returned if return_num is <code>True</code>.</p>  </td> </tr>  </table> <h4 class="rubric">Examples</h4> <pre data-language="python">&gt;&gt;&gt; import numpy as np
&gt;&gt;&gt; x = np.eye(3).astype(int)
&gt;&gt;&gt; print(x)
[[1 0 0]
 [0 1 0]
 [0 0 1]]
&gt;&gt;&gt; from skimage.measure import label
&gt;&gt;&gt; print(label(x, connectivity=1))
[[1 0 0]
 [0 2 0]
 [0 0 3]]
</pre> <pre data-language="python">&gt;&gt;&gt; print(label(x, connectivity=2))
[[1 0 0]
 [0 1 0]
 [0 0 1]]
</pre> <pre data-language="python">&gt;&gt;&gt; print(label(x, background=-1))
[[1 2 2]
 [2 1 2]
 [2 2 1]]
</pre> <pre data-language="python">&gt;&gt;&gt; x = np.array([[1, 0, 0],
...               [1, 1, 5],
...               [0, 0, 0]])
</pre> <pre data-language="python">&gt;&gt;&gt; print(label(x))
[[1 0 0]
 [1 1 2]
 [0 0 0]]
</pre> </dd>
</dl>   <h2 id="medial-axis">medial_axis</h2> <dl class="function"> <dt id="skimage.morphology.medial_axis">
<code>skimage.morphology.medial_axis(image, mask=None, return_distance=False)</code> <a class="reference external" href="http://github.com/scikit-image/scikit-image/blob/v0.12.2/skimage/morphology/_skeletonize.py#L103" target="_blank"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Compute the medial axis transform of a binary image</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr class="field-odd field">
<th class="field-name">Parameters:</th>
<td class="field-body">
<p class="first"><strong>image</strong> : binary ndarray, shape (M, N)</p>  <p>The image of the shape to be skeletonized.</p>  <p><strong>mask</strong> : binary ndarray, shape (M, N), optional</p>  <p>If a mask is given, only those elements in <code>image</code> with a true value in <code>mask</code> are used for computing the medial axis.</p>  <p><strong>return_distance</strong> : bool, optional</p>  <p>If true, the distance transform is returned as well as the skeleton.</p>  </td> </tr> <tr class="field-even field">
<th class="field-name">Returns:</th>
<td class="field-body">
<p class="first"><strong>out</strong> : ndarray of bools</p>  <p>Medial axis transform of the image</p>  <p><strong>dist</strong> : ndarray of ints, optional</p>  <p>Distance transform of the image (only returned if <code>return_distance</code> is True)</p>  </td> </tr>  </table> <div class="admonition seealso"> <p class="first admonition-title">See also</p> <p class="last"><a class="reference internal" href="#skimage.morphology.skeletonize" title="skimage.morphology.skeletonize"><code>skeletonize</code></a></p> </div> <h4 class="rubric">Notes</h4> <p>This algorithm computes the medial axis transform of an image as the ridges of its distance transform.</p> <dl class="docutils"> <dt>The different steps of the algorithm are as follows</dt> <dd>
<ul class="first last simple"> <li>A lookup table is used, that assigns 0 or 1 to each configuration of the 3x3 binary square, whether the central pixel should be removed or kept. We want a point to be removed if it has more than one neighbor and if removing it does not change the number of connected components.</li> <li>The distance transform to the background is computed, as well as the cornerness of the pixel.</li> <li>The foreground (value of 1) points are ordered by the distance transform, then the cornerness.</li> <li>A cython function is called to reduce the image to its skeleton. It processes pixels in the order determined at the previous step, and removes or maintains a pixel according to the lookup table. Because of the ordering, it is possible to process all pixels in only one pass.</li> </ul> </dd> </dl> <h4 class="rubric">Examples</h4> <pre data-language="python">&gt;&gt;&gt; square = np.zeros((7, 7), dtype=np.uint8)
&gt;&gt;&gt; square[1:-1, 2:-2] = 1
&gt;&gt;&gt; square
array([[0, 0, 0, 0, 0, 0, 0],
       [0, 0, 1, 1, 1, 0, 0],
       [0, 0, 1, 1, 1, 0, 0],
       [0, 0, 1, 1, 1, 0, 0],
       [0, 0, 1, 1, 1, 0, 0],
       [0, 0, 1, 1, 1, 0, 0],
       [0, 0, 0, 0, 0, 0, 0]], dtype=uint8)
&gt;&gt;&gt; medial_axis(square).astype(np.uint8)
array([[0, 0, 0, 0, 0, 0, 0],
       [0, 0, 1, 0, 1, 0, 0],
       [0, 0, 0, 1, 0, 0, 0],
       [0, 0, 0, 1, 0, 0, 0],
       [0, 0, 0, 1, 0, 0, 0],
       [0, 0, 1, 0, 1, 0, 0],
       [0, 0, 0, 0, 0, 0, 0]], dtype=uint8)
</pre> </dd>
</dl>   <h2 id="octagon">octagon</h2> <dl class="function"> <dt id="skimage.morphology.octagon">
<code>skimage.morphology.octagon(m, n, dtype=&lt;type 'numpy.uint8'&gt;)</code> <a class="reference external" href="http://github.com/scikit-image/scikit-image/blob/v0.12.2/skimage/morphology/selem.py#L252" target="_blank"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Generates an octagon shaped structuring element.</p> <p>For a given size of (m) horizontal and vertical sides and a given (n) height or width of slanted sides octagon is generated. The slanted sides are 45 or 135 degrees to the horizontal axis and hence the widths and heights are equal.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr class="field-odd field">
<th class="field-name">Parameters:</th>
<td class="field-body">
<p class="first"><strong>m</strong> : int</p>  <p>The size of the horizontal and vertical sides.</p>  <p><strong>n</strong> : int</p>  <p>The height or width of the slanted sides.</p>  </td> </tr> <tr class="field-even field">
<th class="field-name">Returns:</th>
<td class="field-body">
<p class="first"><strong>selem</strong> : ndarray</p>  <p>The structuring element where elements of the neighborhood are 1 and 0 otherwise.</p>  </td> </tr> <tr class="field-odd field"><th class="field-name" colspan="2">Other Parameters:</th></tr> <tr class="field-odd field">
<td> </td>
<td class="field-body">
<p class="first"><strong>dtype</strong> : data-type</p>  <p>The data type of the structuring element.</p>  </td> </tr>  </table> </dd>
</dl>   <h2 id="octahedron">octahedron</h2> <dl class="function"> <dt id="skimage.morphology.octahedron">
<code>skimage.morphology.octahedron(radius, dtype=&lt;type 'numpy.uint8'&gt;)</code> <a class="reference external" href="http://github.com/scikit-image/scikit-image/blob/v0.12.2/skimage/morphology/selem.py#L187" target="_blank"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Generates a octahedron-shaped structuring element.</p> <p>This is the 3D equivalent of a diamond. A pixel is part of the neighborhood (i.e. labeled 1) if the city block/Manhattan distance between it and the center of the neighborhood is no greater than radius.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr class="field-odd field">
<th class="field-name">Parameters:</th>
<td class="field-body">
<p class="first"><strong>radius</strong> : int</p>  <p>The radius of the octahedron-shaped structuring element.</p>  </td> </tr> <tr class="field-even field">
<th class="field-name">Returns:</th>
<td class="field-body">
<p class="first"><strong>selem</strong> : ndarray</p>  <p>The structuring element where elements of the neighborhood are 1 and 0 otherwise.</p>  </td> </tr> <tr class="field-odd field"><th class="field-name" colspan="2">Other Parameters:</th></tr> <tr class="field-odd field">
<td> </td>
<td class="field-body">
<p class="first"><strong>dtype</strong> : data-type</p>  <p>The data type of the structuring element.</p>  </td> </tr>  </table> </dd>
</dl>   <h2 id="opening">opening</h2> <dl class="function"> <dt id="skimage.morphology.opening">
<code>skimage.morphology.opening(image, selem=None, *args, **kwargs)</code> <a class="reference external" href="http://github.com/scikit-image/scikit-image/blob/v0.12.2/skimage/morphology/misc.py#L33" target="_blank"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Return greyscale morphological opening of an image.</p> <p>The morphological opening on an image is defined as an erosion followed by a dilation. Opening can remove small bright spots (i.e. “salt”) and connect small dark cracks. This tends to “open” up (dark) gaps between (bright) features.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr class="field-odd field">
<th class="field-name">Parameters:</th>
<td class="field-body">
<p class="first"><strong>image</strong> : ndarray</p>  <p>Image array.</p>  <p><strong>selem</strong> : ndarray, optional</p>  <p>The neighborhood expressed as an array of 1’s and 0’s. If None, use cross-shaped structuring element (connectivity=1).</p>  <p><strong>out</strong> : ndarray, optional</p>  <p>The array to store the result of the morphology. If None is passed, a new array will be allocated.</p>  </td> </tr> <tr class="field-even field">
<th class="field-name">Returns:</th>
<td class="field-body">
<p class="first"><strong>opening</strong> : array, same shape and type as <code>image</code></p>  <p>The result of the morphological opening.</p>  </td> </tr>  </table> <h4 class="rubric">Examples</h4> <pre data-language="python">&gt;&gt;&gt; # Open up gap between two bright regions (but also shrink regions)
&gt;&gt;&gt; import numpy as np
&gt;&gt;&gt; from skimage.morphology import square
&gt;&gt;&gt; bad_connection = np.array([[1, 0, 0, 0, 1],
...                            [1, 1, 0, 1, 1],
...                            [1, 1, 1, 1, 1],
...                            [1, 1, 0, 1, 1],
...                            [1, 0, 0, 0, 1]], dtype=np.uint8)
&gt;&gt;&gt; opening(bad_connection, square(3))
array([[0, 0, 0, 0, 0],
       [1, 1, 0, 1, 1],
       [1, 1, 0, 1, 1],
       [1, 1, 0, 1, 1],
       [0, 0, 0, 0, 0]], dtype=uint8)
</pre> </dd>
</dl>   <h2 id="reconstruction">reconstruction</h2> <dl class="function"> <dt id="skimage.morphology.reconstruction">
<code>skimage.morphology.reconstruction(seed, mask, method='dilation', selem=None, offset=None)</code> <a class="reference external" href="http://github.com/scikit-image/scikit-image/blob/v0.12.2/skimage/morphology/greyreconstruct.py#L17" target="_blank"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Perform a morphological reconstruction of an image.</p> <p>Morphological reconstruction by dilation is similar to basic morphological dilation: high-intensity values will replace nearby low-intensity values. The basic dilation operator, however, uses a structuring element to determine how far a value in the input image can spread. In contrast, reconstruction uses two images: a “seed” image, which specifies the values that spread, and a “mask” image, which gives the maximum allowed value at each pixel. The mask image, like the structuring element, limits the spread of high-intensity values. Reconstruction by erosion is simply the inverse: low-intensity values spread from the seed image and are limited by the mask image, which represents the minimum allowed value.</p> <p>Alternatively, you can think of reconstruction as a way to isolate the connected regions of an image. For dilation, reconstruction connects regions marked by local maxima in the seed image: neighboring pixels less-than-or-equal-to those seeds are connected to the seeded region. Local maxima with values larger than the seed image will get truncated to the seed value.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr class="field-odd field">
<th class="field-name">Parameters:</th>
<td class="field-body">
<p class="first"><strong>seed</strong> : ndarray</p>  <p>The seed image (a.k.a. marker image), which specifies the values that are dilated or eroded.</p>  <p><strong>mask</strong> : ndarray</p>  <p>The maximum (dilation) / minimum (erosion) allowed value at each pixel.</p>  <p><strong>method</strong> : {‘dilation’|’erosion’}</p>  <p>Perform reconstruction by dilation or erosion. In dilation (or erosion), the seed image is dilated (or eroded) until limited by the mask image. For dilation, each seed value must be less than or equal to the corresponding mask value; for erosion, the reverse is true.</p>  <p><strong>selem</strong> : ndarray</p>  <p>The neighborhood expressed as a 2-D array of 1’s and 0’s.</p>  </td> </tr> <tr class="field-even field">
<th class="field-name">Returns:</th>
<td class="field-body">
<p class="first"><strong>reconstructed</strong> : ndarray</p>  <p>The result of morphological reconstruction.</p>  </td> </tr>  </table> <h4 class="rubric">Notes</h4> <p>The algorithm is taken from <a class="reference internal" href="#r297" id="id2">[R297]</a>. Applications for greyscale reconstruction are discussed in <a class="reference internal" href="#r298" id="id3">[R298]</a> and <a class="reference internal" href="#r299" id="id4">[R299]</a>.</p> <h4 class="rubric">References</h4> <table class="docutils citation" frame="void" id="r297" rules="none">   <tr>
<td class="label">[R297]</td>
<td>
<em>(<a class="fn-backref" href="#id2">1</a>, <a class="fn-backref" href="#id5">2</a>)</em> Robinson, “Efficient morphological reconstruction: a downhill filter”, Pattern Recognition Letters 25 (2004) 1759-1767.</td>
</tr>  </table> <table class="docutils citation" frame="void" id="r298" rules="none">   <tr>
<td class="label">[R298]</td>
<td>
<em>(<a class="fn-backref" href="#id3">1</a>, <a class="fn-backref" href="#id6">2</a>)</em> Vincent, L., “Morphological Grayscale Reconstruction in Image Analysis: Applications and Efficient Algorithms”, IEEE Transactions on Image Processing (1993)</td>
</tr>  </table> <table class="docutils citation" frame="void" id="r299" rules="none">   <tr>
<td class="label">[R299]</td>
<td>
<em>(<a class="fn-backref" href="#id4">1</a>, <a class="fn-backref" href="#id7">2</a>)</em> Soille, P., “Morphological Image Analysis: Principles and Applications”, Chapter 6, 2nd edition (2003), ISBN 3540429883.</td>
</tr>  </table> <h4 class="rubric">Examples</h4> <pre data-language="python">&gt;&gt;&gt; import numpy as np
&gt;&gt;&gt; from skimage.morphology import reconstruction
</pre> <p>First, we create a sinusoidal mask image with peaks at middle and ends.</p> <pre data-language="python">&gt;&gt;&gt; x = np.linspace(0, 4 * np.pi)
&gt;&gt;&gt; y_mask = np.cos(x)
</pre> <p>Then, we create a seed image initialized to the minimum mask value (for reconstruction by dilation, min-intensity values don’t spread) and add “seeds” to the left and right peak, but at a fraction of peak value (1).</p> <pre data-language="python">&gt;&gt;&gt; y_seed = y_mask.min() * np.ones_like(x)
&gt;&gt;&gt; y_seed[0] = 0.5
&gt;&gt;&gt; y_seed[-1] = 0
&gt;&gt;&gt; y_rec = reconstruction(y_seed, y_mask)
</pre> <p>The reconstructed image (or curve, in this case) is exactly the same as the mask image, except that the peaks are truncated to 0.5 and 0. The middle peak disappears completely: Since there were no seed values in this peak region, its reconstructed value is truncated to the surrounding value (-1).</p> <p>As a more practical example, we try to extract the bright features of an image by subtracting a background image created by reconstruction.</p> <pre data-language="python">&gt;&gt;&gt; y, x = np.mgrid[:20:0.5, :20:0.5]
&gt;&gt;&gt; bumps = np.sin(x) + np.sin(y)
</pre> <p>To create the background image, set the mask image to the original image, and the seed image to the original image with an intensity offset, <code>h</code>.</p> <pre data-language="python">&gt;&gt;&gt; h = 0.3
&gt;&gt;&gt; seed = bumps - h
&gt;&gt;&gt; background = reconstruction(seed, bumps)
</pre> <p>The resulting reconstructed image looks exactly like the original image, but with the peaks of the bumps cut off. Subtracting this reconstructed image from the original image leaves just the peaks of the bumps</p> <pre data-language="python">&gt;&gt;&gt; hdome = bumps - background
</pre> <p>This operation is known as the h-dome of the image and leaves features of height <code>h</code> in the subtracted image.</p> </dd>
</dl>   <h2 id="rectangle">rectangle</h2> <dl class="function"> <dt id="skimage.morphology.rectangle">
<code>skimage.morphology.rectangle(width, height, dtype=&lt;type 'numpy.uint8'&gt;)</code> <a class="reference external" href="http://github.com/scikit-image/scikit-image/blob/v0.12.2/skimage/morphology/selem.py#L32" target="_blank"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Generates a flat, rectangular-shaped structuring element.</p> <p>Every pixel in the rectangle generated for a given width and given height belongs to the neighborhood.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr class="field-odd field">
<th class="field-name">Parameters:</th>
<td class="field-body">
<p class="first"><strong>width</strong> : int</p>  <p>The width of the rectangle.</p>  <p><strong>height</strong> : int</p>  <p>The height of the rectangle.</p>  </td> </tr> <tr class="field-even field">
<th class="field-name">Returns:</th>
<td class="field-body">
<p class="first"><strong>selem</strong> : ndarray</p>  <p>A structuring element consisting only of ones, i.e. every pixel belongs to the neighborhood.</p>  </td> </tr> <tr class="field-odd field"><th class="field-name" colspan="2">Other Parameters:</th></tr> <tr class="field-odd field">
<td> </td>
<td class="field-body">
<p class="first"><strong>dtype</strong> : data-type</p>  <p>The data type of the structuring element.</p>  </td> </tr>  </table> </dd>
</dl>   <h2 id="remove-small-holes">remove_small_holes</h2> <dl class="function"> <dt id="skimage.morphology.remove_small_holes">
<code>skimage.morphology.remove_small_holes(ar, min_size=64, connectivity=1, in_place=False)</code> <a class="reference external" href="http://github.com/scikit-image/scikit-image/blob/v0.12.2/skimage/morphology/misc.py#L131" target="_blank"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Remove continguous holes smaller than the specified size.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr class="field-odd field">
<th class="field-name">Parameters:</th>
<td class="field-body">
<p class="first"><strong>ar</strong> : ndarray (arbitrary shape, int or bool type)</p>  <p>The array containing the connected components of interest.</p>  <p><strong>min_size</strong> : int, optional (default: 64)</p>  <p>The hole component size.</p>  <p><strong>connectivity</strong> : int, {1, 2, ..., ar.ndim}, optional (default: 1)</p>  <p>The connectivity defining the neighborhood of a pixel.</p>  <p><strong>in_place</strong> : bool, optional (default: False)</p>  <p>If <code>True</code>, remove the connected components in the input array itself. Otherwise, make a copy.</p>  </td> </tr> <tr class="field-even field">
<th class="field-name">Returns:</th>
<td class="field-body">
<p class="first"><strong>out</strong> : ndarray, same shape and type as input <code>ar</code></p>  <p>The input array with small holes within connected components removed.</p>  </td> </tr> <tr class="field-odd field">
<th class="field-name">Raises:</th>
<td class="field-body">
<p class="first"><strong>TypeError</strong></p>  <p>If the input array is of an invalid type, such as float or string.</p>  <p><strong>ValueError</strong></p>  <p>If the input array contains negative values.</p>  </td> </tr>  </table> <h4 class="rubric">Notes</h4> <p>If the array type is int, it is assumed that it contains already-labeled objects. The labels are not kept in the output image (this function always outputs a bool image). It is suggested that labeling is completed after using this function.</p> <h4 class="rubric">Examples</h4> <pre data-language="python">&gt;&gt;&gt; from skimage import morphology
&gt;&gt;&gt; a = np.array([[1, 1, 1, 1, 1, 0],
...               [1, 1, 1, 0, 1, 0],
...               [1, 0, 0, 1, 1, 0],
...               [1, 1, 1, 1, 1, 0]], bool)
&gt;&gt;&gt; b = morphology.remove_small_holes(a, 2)
&gt;&gt;&gt; b
array([[ True,  True,  True,  True,  True, False],
       [ True,  True,  True,  True,  True, False],
       [ True, False, False,  True,  True, False],
       [ True,  True,  True,  True,  True, False]], dtype=bool)
&gt;&gt;&gt; c = morphology.remove_small_holes(a, 2, connectivity=2)
&gt;&gt;&gt; c
array([[ True,  True,  True,  True,  True, False],
       [ True,  True,  True, False,  True, False],
       [ True, False, False,  True,  True, False],
       [ True,  True,  True,  True,  True, False]], dtype=bool)
&gt;&gt;&gt; d = morphology.remove_small_holes(a, 2, in_place=True)
&gt;&gt;&gt; d is a
True
</pre> </dd>
</dl>   <h2 id="remove-small-objects">remove_small_objects</h2> <dl class="function"> <dt id="skimage.morphology.remove_small_objects">
<code>skimage.morphology.remove_small_objects(ar, min_size=64, connectivity=1, in_place=False)</code> <a class="reference external" href="http://github.com/scikit-image/scikit-image/blob/v0.12.2/skimage/morphology/misc.py#L47" target="_blank"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Remove connected components smaller than the specified size.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr class="field-odd field">
<th class="field-name">Parameters:</th>
<td class="field-body">
<p class="first"><strong>ar</strong> : ndarray (arbitrary shape, int or bool type)</p>  <p>The array containing the connected components of interest. If the array type is int, it is assumed that it contains already-labeled objects. The ints must be non-negative.</p>  <p><strong>min_size</strong> : int, optional (default: 64)</p>  <p>The smallest allowable connected component size.</p>  <p><strong>connectivity</strong> : int, {1, 2, ..., ar.ndim}, optional (default: 1)</p>  <p>The connectivity defining the neighborhood of a pixel.</p>  <p><strong>in_place</strong> : bool, optional (default: False)</p>  <p>If <code>True</code>, remove the connected components in the input array itself. Otherwise, make a copy.</p>  </td> </tr> <tr class="field-even field">
<th class="field-name">Returns:</th>
<td class="field-body">
<p class="first"><strong>out</strong> : ndarray, same shape and type as input <code>ar</code></p>  <p>The input array with small connected components removed.</p>  </td> </tr> <tr class="field-odd field">
<th class="field-name">Raises:</th>
<td class="field-body">
<p class="first"><strong>TypeError</strong></p>  <p>If the input array is of an invalid type, such as float or string.</p>  <p><strong>ValueError</strong></p>  <p>If the input array contains negative values.</p>  </td> </tr>  </table> <h4 class="rubric">Examples</h4> <pre data-language="python">&gt;&gt;&gt; from skimage import morphology
&gt;&gt;&gt; a = np.array([[0, 0, 0, 1, 0],
...               [1, 1, 1, 0, 0],
...               [1, 1, 1, 0, 1]], bool)
&gt;&gt;&gt; b = morphology.remove_small_objects(a, 6)
&gt;&gt;&gt; b
array([[False, False, False, False, False],
       [ True,  True,  True, False, False],
       [ True,  True,  True, False, False]], dtype=bool)
&gt;&gt;&gt; c = morphology.remove_small_objects(a, 7, connectivity=2)
&gt;&gt;&gt; c
array([[False, False, False,  True, False],
       [ True,  True,  True, False, False],
       [ True,  True,  True, False, False]], dtype=bool)
&gt;&gt;&gt; d = morphology.remove_small_objects(a, 6, in_place=True)
&gt;&gt;&gt; d is a
True
</pre> </dd>
</dl>   <h2 id="skeletonize">skeletonize</h2> <dl class="function"> <dt id="skimage.morphology.skeletonize">
<code>skimage.morphology.skeletonize(image)</code> <a class="reference external" href="http://github.com/scikit-image/scikit-image/blob/v0.12.2/skimage/morphology/_skeletonize.py#L12" target="_blank"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Return the skeleton of a binary image.</p> <p>Thinning is used to reduce each connected component in a binary image to a single-pixel wide skeleton.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr class="field-odd field">
<th class="field-name">Parameters:</th>
<td class="field-body">
<p class="first"><strong>image</strong> : numpy.ndarray</p>  <p>A binary image containing the objects to be skeletonized. ‘1’ represents foreground, and ‘0’ represents background. It also accepts arrays of boolean values where True is foreground.</p>  </td> </tr> <tr class="field-even field">
<th class="field-name">Returns:</th>
<td class="field-body">
<p class="first"><strong>skeleton</strong> : ndarray</p>  <p>A matrix containing the thinned image.</p>  </td> </tr>  </table> <div class="admonition seealso"> <p class="first admonition-title">See also</p> <p class="last"><a class="reference internal" href="#skimage.morphology.medial_axis" title="skimage.morphology.medial_axis"><code>medial_axis</code></a></p> </div> <h4 class="rubric">Notes</h4> <p>The algorithm <a class="reference internal" href="#r300" id="id8">[R300]</a> works by making successive passes of the image, removing pixels on object borders. This continues until no more pixels can be removed. The image is correlated with a mask that assigns each pixel a number in the range [0...255] corresponding to each possible pattern of its 8 neighbouring pixels. A look up table is then used to assign the pixels a value of 0, 1, 2 or 3, which are selectively removed during the iterations.</p> <p>Note that this algorithm will give different results than a medial axis transform, which is also often referred to as “skeletonization”.</p> <h4 class="rubric">References</h4> <table class="docutils citation" frame="void" id="r300" rules="none">   <tr>
<td class="label">[R300]</td>
<td>
<em>(<a class="fn-backref" href="#id8">1</a>, <a class="fn-backref" href="#id9">2</a>)</em> A fast parallel algorithm for thinning digital patterns, T. Y. Zhang and C. Y. Suen, Communications of the ACM, March 1984, Volume 27, Number 3.</td>
</tr>  </table> <h4 class="rubric">Examples</h4> <pre data-language="python">&gt;&gt;&gt; X, Y = np.ogrid[0:9, 0:9]
&gt;&gt;&gt; ellipse = (1./3 * (X - 4)**2 + (Y - 4)**2 &lt; 3**2).astype(np.uint8)
&gt;&gt;&gt; ellipse
array([[0, 0, 0, 1, 1, 1, 0, 0, 0],
       [0, 0, 1, 1, 1, 1, 1, 0, 0],
       [0, 0, 1, 1, 1, 1, 1, 0, 0],
       [0, 0, 1, 1, 1, 1, 1, 0, 0],
       [0, 0, 1, 1, 1, 1, 1, 0, 0],
       [0, 0, 1, 1, 1, 1, 1, 0, 0],
       [0, 0, 1, 1, 1, 1, 1, 0, 0],
       [0, 0, 1, 1, 1, 1, 1, 0, 0],
       [0, 0, 0, 1, 1, 1, 0, 0, 0]], dtype=uint8)
&gt;&gt;&gt; skel = skeletonize(ellipse)
&gt;&gt;&gt; skel.astype(np.uint8)
array([[0, 0, 0, 0, 0, 0, 0, 0, 0],
       [0, 0, 0, 0, 0, 0, 0, 0, 0],
       [0, 0, 0, 0, 0, 0, 0, 0, 0],
       [0, 0, 0, 0, 1, 0, 0, 0, 0],
       [0, 0, 0, 0, 1, 0, 0, 0, 0],
       [0, 0, 0, 0, 1, 0, 0, 0, 0],
       [0, 0, 0, 0, 1, 0, 0, 0, 0],
       [0, 0, 0, 0, 0, 0, 0, 0, 0],
       [0, 0, 0, 0, 0, 0, 0, 0, 0]], dtype=uint8)
</pre> </dd>
</dl>   <h2 id="skeletonize-3d">skeletonize_3d</h2> <dl class="function"> <dt id="skimage.morphology.skeletonize_3d">
<code>skimage.morphology.skeletonize_3d(img)</code> <a class="reference external" href="http://github.com/scikit-image/scikit-image/blob/v0.12.2/skimage/morphology/_skeletonize_3d.py#L8" target="_blank"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Compute the skeleton of a binary image.</p> <p>Thinning is used to reduce each connected component in a binary image to a single-pixel wide skeleton.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr class="field-odd field">
<th class="field-name">Parameters:</th>
<td class="field-body">
<p class="first"><strong>img</strong> : ndarray, 2D or 3D</p>  <p>A binary image containing the objects to be skeletonized. Zeros represent background, nonzero values are foreground.</p>  </td> </tr> <tr class="field-even field">
<th class="field-name">Returns:</th>
<td class="field-body">
<p class="first"><strong>skeleton</strong> : ndarray</p>  <p>The thinned image.</p>  </td> </tr>  </table> <div class="admonition seealso"> <p class="first admonition-title">See also</p> <p class="last"><a class="reference internal" href="#skimage.morphology.skeletonize" title="skimage.morphology.skeletonize"><code>skeletonize</code></a>, <a class="reference internal" href="#skimage.morphology.medial_axis" title="skimage.morphology.medial_axis"><code>medial_axis</code></a></p> </div> <h4 class="rubric">Notes</h4> <p>The method of <a class="reference internal" href="#lee94" id="id10">[Lee94]</a> uses an octree data structure to examine a 3x3x3 neighborhood of a pixel. The algorithm proceeds by iteratively sweeping over the image, and removing pixels at each iteration until the image stops changing. Each iteration consists of two steps: first, a list of candidates for removal is assembled; then pixels from this list are rechecked sequentially, to better preserve connectivity of the image.</p> <p>The algorithm this function implements is different from the algorithms used by either <code>skeletonize</code> or <code>medial_axis</code>, thus for 2D images the results produced by this function are generally different.</p> <h4 class="rubric">References</h4> <table class="docutils citation" frame="void" id="lee94" rules="none">   <tr>
<td class="label">[Lee94]</td>
<td>
<em>(<a class="fn-backref" href="#id10">1</a>, <a class="fn-backref" href="#id11">2</a>)</em> T.-C. Lee, R.L. Kashyap and C.-N. Chu, Building skeleton models via 3-D medial surface/axis thinning algorithms. Computer Vision, Graphics, and Image Processing, 56(6):462-478, 1994.</td>
</tr>  </table> </dd>
</dl>   <h2 id="square">square</h2> <dl class="function"> <dt id="skimage.morphology.square">
<code>skimage.morphology.square(width, dtype=&lt;type 'numpy.uint8'&gt;)</code> <a class="reference external" href="http://github.com/scikit-image/scikit-image/blob/v0.12.2/skimage/morphology/selem.py#L6" target="_blank"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Generates a flat, square-shaped structuring element.</p> <p>Every pixel along the perimeter has a chessboard distance no greater than radius (radius=floor(width/2)) pixels.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr class="field-odd field">
<th class="field-name">Parameters:</th>
<td class="field-body">
<p class="first"><strong>width</strong> : int</p>  <p>The width and height of the square.</p>  </td> </tr> <tr class="field-even field">
<th class="field-name">Returns:</th>
<td class="field-body">
<p class="first"><strong>selem</strong> : ndarray</p>  <p>A structuring element consisting only of ones, i.e. every pixel belongs to the neighborhood.</p>  </td> </tr> <tr class="field-odd field"><th class="field-name" colspan="2">Other Parameters:</th></tr> <tr class="field-odd field">
<td> </td>
<td class="field-body">
<p class="first"><strong>dtype</strong> : data-type</p>  <p>The data type of the structuring element.</p>  </td> </tr>  </table> </dd>
</dl>   <h2 id="star">star</h2> <dl class="function"> <dt id="skimage.morphology.star">
<code>skimage.morphology.star(a, dtype=&lt;type 'numpy.uint8'&gt;)</code> <a class="reference external" href="http://github.com/scikit-image/scikit-image/blob/v0.12.2/skimage/morphology/selem.py#L293" target="_blank"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Generates a star shaped structuring element.</p> <p>Start has 8 vertices and is an overlap of square of size <code>2*a + 1</code> with its 45 degree rotated version. The slanted sides are 45 or 135 degrees to the horizontal axis.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr class="field-odd field">
<th class="field-name">Parameters:</th>
<td class="field-body">
<p class="first"><strong>a</strong> : int</p>  <p>Parameter deciding the size of the star structural element. The side of the square array returned is <code>2*a + 1 + 2*floor(a / 2)</code>.</p>  </td> </tr> <tr class="field-even field">
<th class="field-name">Returns:</th>
<td class="field-body">
<p class="first"><strong>selem</strong> : ndarray</p>  <p>The structuring element where elements of the neighborhood are 1 and 0 otherwise.</p>  </td> </tr> <tr class="field-odd field"><th class="field-name" colspan="2">Other Parameters:</th></tr> <tr class="field-odd field">
<td> </td>
<td class="field-body">
<p class="first"><strong>dtype</strong> : data-type</p>  <p>The data type of the structuring element.</p>  </td> </tr>  </table> </dd>
</dl>   <h2 id="watershed">watershed</h2> <dl class="function"> <dt id="skimage.morphology.watershed">
<code>skimage.morphology.watershed(image, markers, connectivity=None, offset=None, mask=None)</code> <a class="reference external" href="http://github.com/scikit-image/scikit-image/blob/v0.12.2/skimage/morphology/watershed.py#L35" target="_blank"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Return a matrix labeled using the watershed segmentation algorithm</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr class="field-odd field">
<th class="field-name">Parameters:</th>
<td class="field-body">
<p class="first"><strong>image: ndarray (2-D, 3-D, ...) of integers</strong></p>  <p>Data array where the lowest value points are labeled first.</p>  <p><strong>markers: ndarray of the same shape as `image`</strong></p>  <p>An array marking the basins with the values to be assigned in the label matrix. Zero means not a marker. This array should be of an integer type.</p>  <p><strong>connectivity: ndarray, optional</strong></p>  <p>An array with the same number of dimensions as <code>image</code> whose non-zero elements indicate neighbors for connection. Following the scipy convention, default is a one-connected array of the dimension of the image.</p>  <p><strong>offset: array_like of shape image.ndim, optional</strong></p>  <p>offset of the connectivity (one offset per dimension)</p>  <p><strong>mask: ndarray of bools or 0s and 1s, optional</strong></p>  <p>Array of same shape as <code>image</code>. Only points at which mask == True will be labeled.</p>  </td> </tr> <tr class="field-even field">
<th class="field-name">Returns:</th>
<td class="field-body">
<p class="first">out: ndarray</p>  <p>A labeled matrix of the same type and shape as markers</p>  </td> </tr>  </table> <div class="admonition seealso"> <p class="first admonition-title">See also</p> <dl class="last docutils"> <dt>
 <a class="reference internal" href="../skimage.segmentation/#skimage.segmentation.random_walker" title="skimage.segmentation.random_walker"><code>skimage.segmentation.random_walker</code></a>
</dt> <dd>random walker segmentation A segmentation algorithm based on anisotropic diffusion, usually slower than the watershed but with good results on noisy data and boundaries with holes.</dd> </dl> </div> <h4 class="rubric">Notes</h4> <p>This function implements a watershed algorithm [R301]_that apportions pixels into marked basins. The algorithm uses a priority queue to hold the pixels with the metric for the priority queue being pixel value, then the time of entry into the queue - this settles ties in favor of the closest marker.</p> <p>Some ideas taken from Soille, “Automated Basin Delineation from Digital Elevation Models Using Mathematical Morphology”, Signal Processing 20 (1990) 171-182</p> <p>The most important insight in the paper is that entry time onto the queue solves two problems: a pixel should be assigned to the neighbor with the largest gradient or, if there is no gradient, pixels on a plateau should be split between markers on opposite sides.</p> <p>This implementation converts all arguments to specific, lowest common denominator types, then passes these to a C algorithm.</p> <p>Markers can be determined manually, or automatically using for example the local minima of the gradient of the image, or the local maxima of the distance function to the background for separating overlapping objects (see example).</p> <h4 class="rubric">References</h4> <table class="docutils citation" frame="void" id="r301" rules="none">   <tr>
<td class="label"><a class="fn-backref" href="#id12">[R301]</a></td>
<td><a class="reference external" href="http://en.wikipedia.org/wiki/Watershed_%28image_processing%29" target="_blank">http://en.wikipedia.org/wiki/Watershed_%28image_processing%29</a></td>
</tr>  </table> <table class="docutils citation" frame="void" id="r302" rules="none">   <tr>
<td class="label"><a class="fn-backref" href="#id13">[R302]</a></td>
<td><a class="reference external" href="http://cmm.ensmp.fr/~beucher/wtshed.html" target="_blank">http://cmm.ensmp.fr/~beucher/wtshed.html</a></td>
</tr>  </table> <h4 class="rubric">Examples</h4> <p>The watershed algorithm is very useful to separate overlapping objects</p> <pre data-language="python">&gt;&gt;&gt; # Generate an initial image with two overlapping circles
&gt;&gt;&gt; x, y = np.indices((80, 80))
&gt;&gt;&gt; x1, y1, x2, y2 = 28, 28, 44, 52
&gt;&gt;&gt; r1, r2 = 16, 20
&gt;&gt;&gt; mask_circle1 = (x - x1)**2 + (y - y1)**2 &lt; r1**2
&gt;&gt;&gt; mask_circle2 = (x - x2)**2 + (y - y2)**2 &lt; r2**2
&gt;&gt;&gt; image = np.logical_or(mask_circle1, mask_circle2)
&gt;&gt;&gt; # Now we want to separate the two objects in image
&gt;&gt;&gt; # Generate the markers as local maxima of the distance
&gt;&gt;&gt; # to the background
&gt;&gt;&gt; from scipy import ndimage as ndi
&gt;&gt;&gt; distance = ndi.distance_transform_edt(image)
&gt;&gt;&gt; from skimage.feature import peak_local_max
&gt;&gt;&gt; local_maxi = peak_local_max(distance, labels=image,
...                             footprint=np.ones((3, 3)),
...                             indices=False)
&gt;&gt;&gt; markers = ndi.label(local_maxi)[0]
&gt;&gt;&gt; labels = watershed(-distance, markers, mask=image)
</pre> <p>The algorithm works also for 3-D images, and can be used for example to separate overlapping spheres.</p> </dd>
</dl>   <h2 id="white-tophat">white_tophat</h2> <dl class="function"> <dt id="skimage.morphology.white_tophat">
<code>skimage.morphology.white_tophat(image, selem=None, *args, **kwargs)</code> <a class="reference external" href="http://github.com/scikit-image/scikit-image/blob/v0.12.2/skimage/morphology/misc.py#L33" target="_blank"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Return white top hat of an image.</p> <p>The white top hat of an image is defined as the image minus its morphological opening. This operation returns the bright spots of the image that are smaller than the structuring element.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr class="field-odd field">
<th class="field-name">Parameters:</th>
<td class="field-body">
<p class="first"><strong>image</strong> : ndarray</p>  <p>Image array.</p>  <p><strong>selem</strong> : ndarray, optional</p>  <p>The neighborhood expressed as an array of 1’s and 0’s. If None, use cross-shaped structuring element (connectivity=1).</p>  <p><strong>out</strong> : ndarray, optional</p>  <p>The array to store the result of the morphology. If None is passed, a new array will be allocated.</p>  </td> </tr> <tr class="field-even field">
<th class="field-name">Returns:</th>
<td class="field-body">
<p class="first"><strong>out</strong> : array, same shape and type as <code>image</code></p>  <p>The result of the morphological white top hat.</p>  </td> </tr>  </table> <h4 class="rubric">Examples</h4> <pre data-language="python">&gt;&gt;&gt; # Subtract grey background from bright peak
&gt;&gt;&gt; import numpy as np
&gt;&gt;&gt; from skimage.morphology import square
&gt;&gt;&gt; bright_on_grey = np.array([[2, 3, 3, 3, 2],
...                            [3, 4, 5, 4, 3],
...                            [3, 5, 9, 5, 3],
...                            [3, 4, 5, 4, 3],
...                            [2, 3, 3, 3, 2]], dtype=np.uint8)
&gt;&gt;&gt; white_tophat(bright_on_grey, square(3))
array([[0, 0, 0, 0, 0],
       [0, 0, 1, 0, 0],
       [0, 1, 5, 1, 0],
       [0, 0, 1, 0, 0],
       [0, 0, 0, 0, 0]], dtype=uint8)
</pre> </dd>
</dl>
<div class="_attribution">
  <p class="_attribution-p">
    © 2011 the scikit-image team<br>Licensed under the BSD 3-clause License.<br>
    <a href="http://scikit-image.org/docs/0.12.x/api/skimage.morphology.html" class="_attribution-link" target="_blank">http://scikit-image.org/docs/0.12.x/api/skimage.morphology.html</a>
  </p>
</div>

			</div>
		</div>
	</section>

	</div>
</body>
</html>
