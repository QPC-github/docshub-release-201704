
<!DOCTYPE HTML>

<html lang="en">

<head>
  <meta charset="utf-8">
  <title>Compose File Reference - Docker 1.12 - W3cubDocs</title>
  
  <meta name="description" content=" The Compose file is a YAML file defining services, networks and volumes. The default path for a Compose file is .&#47;docker-compose.yml. ">
  <meta name="keywords" content="compose, file, reference, -, docker, docker~1.12">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="http://docs.w3cub.com/docker~1.12/compose/compose-file/">
  <link href="/favicon.png" rel="icon">
  <link type="text/css" rel="stylesheet" href="/assets/application-50364fff564ce3b6327021805f3f00e2957b441cf27f576a7dd4ff63bbc47047.css">
  <script type="text/javascript" src="/assets/application-db64bfd54ceb42be11af7995804cf4902548419ceb79d509b0b7d62c22d98e6f.js"></script>
  <script src="/json/docker~1.12.js"></script>
  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-71174418-1']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>


</head>

<body>
	<div class="_app">
	<header class="_header">
  
  <form class="_search">
    <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
    <a class="_search-clear"></a>
    <div class="_search-tag"></div>
  </form>
  
  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/docker~1.12/" class="_nav-link" title="" style="margin-left:0;">Docker 1.12</a></span>
  
  <nav class="_nav">
    <a href="/app/" class="_nav-link ">App</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		<div class="_list">
			
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<div class="_page _docker">
				
<h1 id="compose-file-reference">Compose file reference</h1> <p>The Compose file is a <a href="http://yaml.org/" target="_blank">YAML</a> file defining <a href="#service-configuration-reference">services</a>, <a href="#network-configuration-reference">networks</a> and <a href="#volume-configuration-reference">volumes</a>. The default path for a Compose file is <code>./docker-compose.yml</code>.</p> <p>A service definition contains configuration which will be applied to each container started for that service, much like passing command-line parameters to <code>docker run</code>. Likewise, network and volume definitions are analogous to <code>docker network create</code> and <code>docker volume create</code>.</p> <p>As with <code>docker run</code>, options specified in the Dockerfile (e.g., <code>CMD</code>, <code>EXPOSE</code>, <code>VOLUME</code>, <code>ENV</code>) are respected by default - you don’t need to specify them again in <code>docker-compose.yml</code>.</p> <p>You can use environment variables in configuration values with a Bash-like <code>${VARIABLE}</code> syntax - see <a href="#variable-substitution">variable substitution</a> for full details.</p> <h2 id="service-configuration-reference">Service configuration reference</h2> <blockquote> <p><strong>Note:</strong> There are two versions of the Compose file format – version 1 (the legacy format, which does not support volumes or networks) and version 2 (the most up-to-date). For more information, see the <a href="#versioning">Versioning</a> section.</p> </blockquote> <p>This section contains a list of all configuration options supported by a service definition.</p> <h3 id="build">build</h3> <p>Configuration options that are applied at build time.</p> <p><code>build</code> can be specified either as a string containing a path to the build context, or an object with the path specified under <a href="#context">context</a> and optionally <a href="#dockerfile">dockerfile</a> and <a href="#args">args</a>.</p> <pre>build: ./dir

build:
  context: ./dir
  dockerfile: Dockerfile-alternate
  args:
    buildno: 1
</pre> <p>If you specify <code>image</code> as well as <code>build</code>, then Compose names the built image with the <code>webapp</code> and optional <code>tag</code> specified in <code>image</code>:</p> <pre>build: ./dir
image: webapp:tag
</pre> <p>This will result in an image named <code>webapp</code> and tagged <code>tag</code>, built from <code>./dir</code>.</p> <blockquote> <p><strong>Note</strong>: In the <a href="#version-1">version 1 file format</a>, <code>build</code> is different in two ways:</p> <ul> <li>Only the string form (<code>build: .</code>) is allowed - not the object form.</li> <li>Using <code>build</code> together with <code>image</code> is not allowed. Attempting to do so results in an error.</li> </ul> </blockquote> <h4 id="context">context</h4> <blockquote> <p><a href="#version-2">Version 2 file format</a> only. In version 1, just use <a href="#build">build</a>.</p> </blockquote> <p>Either a path to a directory containing a Dockerfile, or a url to a git repository.</p> <p>When the value supplied is a relative path, it is interpreted as relative to the location of the Compose file. This directory is also the build context that is sent to the Docker daemon.</p> <p>Compose will build and tag it with a generated name, and use that image thereafter.</p> <pre>build:
  context: ./dir
</pre> <h4 id="dockerfile">dockerfile</h4> <p>Alternate Dockerfile.</p> <p>Compose will use an alternate file to build with. A build path must also be specified.</p> <pre>build:
  context: .
  dockerfile: Dockerfile-alternate
</pre> <blockquote> <p><strong>Note</strong>: In the <a href="#version-1">version 1 file format</a>, <code>dockerfile</code> is different in two ways:</p> </blockquote> <ul> <li>
<p>It appears alongside <code>build</code>, not as a sub-option:</p> <pre>build: .
dockerfile: Dockerfile-alternate
</pre>
</li> <li><p>Using <code>dockerfile</code> together with <code>image</code> is not allowed. Attempting to do so results in an error.</p></li> </ul> <h4 id="args">args</h4> <blockquote> <p><a href="#version-2">Version 2 file format</a> only.</p> </blockquote> <p>Add build arguments, which are environment variables accessible only during the build process.</p> <p>First, specify the arguments in your Dockerfile:</p> <pre>ARG buildno
ARG password

RUN echo "Build number: $buildno"
RUN script-requiring-password.sh "$password"
</pre> <p>Then specify the arguments under the <code>build</code> key. You can pass either a mapping or a list:</p> <pre>build:
  context: .
  args:
    buildno: 1
    password: secret

build:
  context: .
  args:
    - buildno=1
    - password=secret
</pre> <p>You can omit the value when specifying a build argument, in which case its value at build time is the value in the environment where Compose is running.</p> <pre>args:
  - buildno
  - password
</pre> <blockquote> <p><strong>Note</strong>: YAML boolean values (<code>true</code>, <code>false</code>, <code>yes</code>, <code>no</code>, <code>on</code>, <code>off</code>) must be enclosed in quotes, so that the parser interprets them as strings.</p> </blockquote> <h3 id="cap-add-cap-drop">cap_add, cap_drop</h3> <p>Add or drop container capabilities. See <code>man 7 capabilities</code> for a full list.</p> <pre>cap_add:
  - ALL

cap_drop:
  - NET_ADMIN
  - SYS_ADMIN
</pre> <h3 id="command">command</h3> <p>Override the default command.</p> <pre>command: bundle exec thin -p 3000
</pre> <p>The command can also be a list, in a manner similar to <a href="../../engine/reference/builder/#cmd">dockerfile</a>:</p> <pre>command: [bundle, exec, thin, -p, 3000]
</pre> <h3 id="cgroup-parent">cgroup_parent</h3> <p>Specify an optional parent cgroup for the container.</p> <pre>cgroup_parent: m-executor-abcd
</pre> <h3 id="container-name">container_name</h3> <p>Specify a custom container name, rather than a generated default name.</p> <pre>container_name: my-web-container
</pre> <p>Because Docker container names must be unique, you cannot scale a service beyond 1 container if you have specified a custom name. Attempting to do so results in an error.</p> <h3 id="devices">devices</h3> <p>List of device mappings. Uses the same format as the <code>--device</code> docker client create option.</p> <pre>devices:
  - "/dev/ttyUSB0:/dev/ttyUSB0"
</pre> <h3 id="depends-on">depends_on</h3> <p>Express dependency between services, which has two effects:</p> <ul> <li><p><code>docker-compose up</code> will start services in dependency order. In the following example, <code>db</code> and <code>redis</code> will be started before <code>web</code>.</p></li> <li><p><code>docker-compose up SERVICE</code> will automatically include <code>SERVICE</code>’s dependencies. In the following example, <code>docker-compose up web</code> will also create and start <code>db</code> and <code>redis</code>.</p></li> </ul> <p>Simple example:</p> <pre>version: '2'
services:
  web:
    build: .
    depends_on:
      - db
      - redis
  redis:
    image: redis
  db:
    image: postgres
</pre> <blockquote> <p><strong>Note:</strong> <code>depends_on</code> will not wait for <code>db</code> and <code>redis</code> to be “ready” before starting <code>web</code> - only until they have been started. If you need to wait for a service to be ready, see <a href="../startup-order/">Controlling startup order</a> for more on this problem and strategies for solving it.</p> </blockquote> <h3 id="dns">dns</h3> <p>Custom DNS servers. Can be a single value or a list.</p> <pre>dns: 8.8.8.8
dns:
  - 8.8.8.8
  - 9.9.9.9
</pre> <h3 id="dns-search">dns_search</h3> <p>Custom DNS search domains. Can be a single value or a list.</p> <pre>dns_search: example.com
dns_search:
  - dc1.example.com
  - dc2.example.com
</pre> <h3 id="tmpfs">tmpfs</h3> <blockquote> <p><a href="#version-2">Version 2 file format</a> only.</p> </blockquote> <p>Mount a temporary file system inside the container. Can be a single value or a list.</p> <pre>tmpfs: /run
tmpfs:
  - /run
  - /tmp
</pre> <h3 id="entrypoint">entrypoint</h3> <p>Override the default entrypoint.</p> <pre>entrypoint: /code/entrypoint.sh
</pre> <p>The entrypoint can also be a list, in a manner similar to <a href="../../engine/reference/builder/#entrypoint">dockerfile</a>:</p> <pre>entrypoint:
    - php
    - -d
    - zend_extension=/usr/local/lib/php/extensions/no-debug-non-zts-20100525/xdebug.so
    - -d
    - memory_limit=-1
    - vendor/bin/phpunit
</pre> <h3 id="env-file">env_file</h3> <p>Add environment variables from a file. Can be a single value or a list.</p> <p>If you have specified a Compose file with <code>docker-compose -f FILE</code>, paths in <code>env_file</code> are relative to the directory that file is in.</p> <p>Environment variables specified in <code>environment</code> override these values.</p> <pre>env_file: .env

env_file:
  - ./common.env
  - ./apps/web.env
  - /opt/secrets.env
</pre> <p>Compose expects each line in an env file to be in <code>VAR=VAL</code> format. Lines beginning with <code>#</code> (i.e. comments) are ignored, as are blank lines.</p> <pre># Set Rails/Rack environment
RACK_ENV=development
</pre> <blockquote> <p><strong>Note:</strong> If your service specifies a <a href="#build">build</a> option, variables defined in environment files will <em>not</em> be automatically visible during the build. Use the <a href="#args">args</a> sub-option of <code>build</code> to define build-time environment variables.</p> </blockquote> <h3 id="environment">environment</h3> <p>Add environment variables. You can use either an array or a dictionary. Any boolean values; true, false, yes no, need to be enclosed in quotes to ensure they are not converted to True or False by the YML parser.</p> <p>Environment variables with only a key are resolved to their values on the machine Compose is running on, which can be helpful for secret or host-specific values.</p> <pre>environment:
  RACK_ENV: development
  SHOW: 'true'
  SESSION_SECRET:

environment:
  - RACK_ENV=development
  - SHOW=true
  - SESSION_SECRET
</pre> <blockquote> <p><strong>Note:</strong> If your service specifies a <a href="#build">build</a> option, variables defined in <code>environment</code> will <em>not</em> be automatically visible during the build. Use the <a href="#args">args</a> sub-option of <code>build</code> to define build-time environment variables.</p> </blockquote> <h3 id="expose">expose</h3> <p>Expose ports without publishing them to the host machine - they’ll only be accessible to linked services. Only the internal port can be specified.</p> <pre>expose:
 - "3000"
 - "8000"
</pre> <h3 id="extends">extends</h3> <p>Extend another service, in the current file or another, optionally overriding configuration.</p> <p>You can use <code>extends</code> on any service together with other configuration keys. The <code>extends</code> value must be a dictionary defined with a required <code>service</code> and an optional <code>file</code> key.</p> <pre>extends:
  file: common.yml
  service: webapp
</pre> <p>The <code>service</code> the name of the service being extended, for example <code>web</code> or <code>database</code>. The <code>file</code> is the location of a Compose configuration file defining that service.</p> <p>If you omit the <code>file</code> Compose looks for the service configuration in the current file. The <code>file</code> value can be an absolute or relative path. If you specify a relative path, Compose treats it as relative to the location of the current file.</p> <p>You can extend a service that itself extends another. You can extend indefinitely. Compose does not support circular references and <code>docker-compose</code> returns an error if it encounters one.</p> <p>For more on <code>extends</code>, see the <a href="../extends/#extending-services">the extends documentation</a>.</p> <h3 id="external-links">external_links</h3> <p>Link to containers started outside this <code>docker-compose.yml</code> or even outside of Compose, especially for containers that provide shared or common services. <code>external_links</code> follow semantics similar to <code>links</code> when specifying both the container name and the link alias (<code>CONTAINER:ALIAS</code>).</p> <pre>external_links:
 - redis_1
 - project_db_1:mysql
 - project_db_1:postgresql
</pre> <blockquote> <p><strong>Note:</strong> If you’re using the <a href="#version-2">version 2 file format</a>, the externally-created containers must be connected to at least one of the same networks as the service which is linking to them.</p> </blockquote> <h3 id="extra-hosts">extra_hosts</h3> <p>Add hostname mappings. Use the same values as the docker client <code>--add-host</code> parameter.</p> <pre>extra_hosts:
 - "somehost:162.242.195.82"
 - "otherhost:50.31.209.229"
</pre> <p>An entry with the ip address and hostname will be created in <code>/etc/hosts</code> inside containers for this service, e.g:</p> <pre>162.242.195.82  somehost
50.31.209.229   otherhost
</pre> <h3 id="image">image</h3> <p>Specify the image to start the container from. Can either be a repository/tag or a partial image ID.</p> <pre>image: redis
image: ubuntu:14.04
image: tutum/influxdb
image: example-registry.com:4000/postgresql
image: a4bc65fd
</pre> <p>If the image does not exist, Compose attempts to pull it, unless you have also specified <a href="#build">build</a>, in which case it builds it using the specified options and tags it with the specified tag.</p> <blockquote> <p><strong>Note</strong>: In the <a href="#version-1">version 1 file format</a>, using <code>build</code> together with <code>image</code> is not allowed. Attempting to do so results in an error.</p> </blockquote> <h3 id="labels">labels</h3> <p>Add metadata to containers using <a href="../../engine/userguide/labels-custom-metadata/">Docker labels</a>. You can use either an array or a dictionary.</p> <p>It’s recommended that you use reverse-DNS notation to prevent your labels from conflicting with those used by other software.</p> <pre>labels:
  com.example.description: "Accounting webapp"
  com.example.department: "Finance"
  com.example.label-with-empty-value: ""

labels:
  - "com.example.description=Accounting webapp"
  - "com.example.department=Finance"
  - "com.example.label-with-empty-value"
</pre> <h3 id="links">links</h3> <p>Link to containers in another service. Either specify both the service name and a link alias (<code>SERVICE:ALIAS</code>), or just the service name.</p> <pre>web:
  links:
   - db
   - db:database
   - redis
</pre> <p>Containers for the linked service will be reachable at a hostname identical to the alias, or the service name if no alias was specified.</p> <p>Links also express dependency between services in the same way as <a href="#depends-on">depends_on</a>, so they determine the order of service startup.</p> <blockquote> <p><strong>Note:</strong> If you define both links and <a href="#networks">networks</a>, services with links between them must share at least one network in common in order to communicate.</p> </blockquote> <h3 id="logging">logging</h3> <blockquote> <p><a href="#version-2">Version 2 file format</a> only. In version 1, use <a href="#log_driver">log_driver</a> and <a href="#log_opt">log_opt</a>.</p> </blockquote> <p>Logging configuration for the service.</p> <pre>logging:
  driver: syslog
  options:
    syslog-address: "tcp://192.168.0.42:123"
</pre> <p>The <code>driver</code> name specifies a logging driver for the service’s containers, as with the <code>--log-driver</code> option for docker run (<a href="../../engine/admin/logging/overview/">documented here</a>).</p> <p>The default value is json-file.</p> <pre>driver: "json-file"
driver: "syslog"
driver: "none"
</pre> <blockquote> <p><strong>Note:</strong> Only the <code>json-file</code> driver makes the logs available directly from <code>docker-compose up</code> and <code>docker-compose logs</code>. Using any other driver will not print any logs.</p> </blockquote> <p>Specify logging options for the logging driver with the <code>options</code> key, as with the <code>--log-opt</code> option for <code>docker run</code>.</p> <p>Logging options are key-value pairs. An example of <code>syslog</code> options:</p> <pre>driver: "syslog"
options:
  syslog-address: "tcp://192.168.0.42:123"
</pre> <h3 id="log-driver">log_driver</h3> <blockquote> <p><a href="#version-1">Version 1 file format</a> only. In version 2, use <a href="#logging">logging</a>.</p> </blockquote> <p>Specify a log driver. The default is <code>json-file</code>.</p> <pre>log_driver: syslog
</pre> <h3 id="log-opt">log_opt</h3> <blockquote> <p><a href="#version-1">Version 1 file format</a> only. In version 2, use <a href="#logging">logging</a>.</p> </blockquote> <p>Specify logging options as key-value pairs. An example of <code>syslog</code> options:</p> <pre>log_opt:
  syslog-address: "tcp://192.168.0.42:123"
</pre> <h3 id="net">net</h3> <blockquote> <p><a href="#version-1">Version 1 file format</a> only. In version 2, use <a href="#network_mode">network_mode</a>.</p> </blockquote> <p>Network mode. Use the same values as the docker client <code>--net</code> parameter. The <code>container:...</code> form can take a service name instead of a container name or id.</p> <pre>net: "bridge"
net: "host"
net: "none"
net: "container:[service name or container name/id]"
</pre> <h3 id="network-mode">network_mode</h3> <blockquote> <p><a href="#version-2">Version 2 file format</a> only. In version 1, use <a href="#net">net</a>.</p> </blockquote> <p>Network mode. Use the same values as the docker client <code>--net</code> parameter, plus the special form <code>service:[service name]</code>.</p> <pre>network_mode: "bridge"
network_mode: "host"
network_mode: "none"
network_mode: "service:[service name]"
network_mode: "container:[container name/id]"
</pre> <h3 id="networks">networks</h3> <blockquote> <p><a href="#version-2">Version 2 file format</a> only. In version 1, use <a href="#net">net</a>.</p> </blockquote> <p>Networks to join, referencing entries under the <a href="#network-configuration-reference">top-level <code>networks</code> key</a>.</p> <pre>services:
  some-service:
    networks:
     - some-network
     - other-network
</pre> <h4 id="aliases">aliases</h4> <p>Aliases (alternative hostnames) for this service on the network. Other containers on the same network can use either the service name or this alias to connect to one of the service’s containers.</p> <p>Since <code>aliases</code> is network-scoped, the same service can have different aliases on different networks.</p> <blockquote> <p><strong>Note</strong>: A network-wide alias can be shared by multiple containers, and even by multiple services. If it is, then exactly which container the name will resolve to is not guaranteed.</p> </blockquote> <p>The general format is shown here.</p> <pre>services:
  some-service:
    networks:
      some-network:
        aliases:
         - alias1
         - alias3
      other-network:
        aliases:
         - alias2
</pre> <p>In the example below, three services are provided (<code>web</code>, <code>worker</code>, and <code>db</code>), along with two networks (<code>new</code> and <code>legacy</code>). The <code>db</code> service is reachable at the hostname <code>db</code> or <code>database</code> on the <code>new</code> network, and at <code>db</code> or <code>mysql</code> on the <code>legacy</code> network.</p> <pre>version: '2'

services:
  web:
    build: ./web
    networks:
      - new

  worker:
    build: ./worker
    networks:
    - legacy

  db:
    image: mysql
    networks:
      new:
        aliases:
          - database
      legacy:
        aliases:
          - mysql

networks:
  new:
  legacy:
</pre> <h4 id="ipv4-address-ipv6-address">ipv4_address, ipv6_address</h4> <p>Specify a static IP address for containers for this service when joining the network.</p> <p>The corresponding network configuration in the <a href="#network-configuration-reference">top-level networks section</a> must have an <code>ipam</code> block with subnet and gateway configurations covering each static address. If IPv6 addressing is desired, the <code>com.docker.network.enable_ipv6</code> driver option must be set to <code>true</code>.</p> <p>An example:</p> <pre>version: '2'

services:
  app:
    image: busybox
    command: ifconfig
    networks:
      app_net:
        ipv4_address: 172.16.238.10
        ipv6_address: 2001:3984:3989::10

networks:
  app_net:
    driver: bridge
    driver_opts:
      com.docker.network.enable_ipv6: "true"
    ipam:
      driver: default
      config:
      - subnet: 172.16.238.0/24
        gateway: 172.16.238.1
      - subnet: 2001:3984:3989::/64
        gateway: 2001:3984:3989::1
</pre> <h3 id="pid">pid</h3> <pre>pid: "host"
</pre> <p>Sets the PID mode to the host PID mode. This turns on sharing between container and the host operating system the PID address space. Containers launched with this flag will be able to access and manipulate other containers in the bare-metal machine’s namespace and vise-versa.</p> <h3 id="ports">ports</h3> <p>Expose ports. Either specify both ports (<code>HOST:CONTAINER</code>), or just the container port (a random host port will be chosen).</p> <blockquote> <p><strong>Note:</strong> When mapping ports in the <code>HOST:CONTAINER</code> format, you may experience erroneous results when using a container port lower than 60, because YAML will parse numbers in the format <code>xx:yy</code> as sexagesimal (base 60). For this reason, we recommend always explicitly specifying your port mappings as strings.</p> </blockquote> <pre>ports:
 - "3000"
 - "3000-3005"
 - "8000:8000"
 - "9090-9091:8080-8081"
 - "49100:22"
 - "127.0.0.1:8001:8001"
 - "127.0.0.1:5000-5010:5000-5010"
</pre> <h3 id="security-opt">security_opt</h3> <p>Override the default labeling scheme for each container.</p> <pre>security_opt:
  - label:user:USER
  - label:role:ROLE
</pre> <h3 id="stop-signal">stop_signal</h3> <p>Sets an alternative signal to stop the container. By default <code>stop</code> uses SIGTERM. Setting an alternative signal using <code>stop_signal</code> will cause <code>stop</code> to send that signal instead.</p> <pre>stop_signal: SIGUSR1
</pre> <h3 id="ulimits">ulimits</h3> <p>Override the default ulimits for a container. You can either specify a single limit as an integer or soft/hard limits as a mapping.</p> <pre>ulimits:
  nproc: 65535
  nofile:
    soft: 20000
    hard: 40000
</pre> <h3 id="volumes-volume-driver">volumes, volume_driver</h3> <p>Mount paths or named volumes, optionally specifying a path on the host machine (<code>HOST:CONTAINER</code>), or an access mode (<code>HOST:CONTAINER:ro</code>). For <a href="#version-2">version 2 files</a>, named volumes need to be specified with the <a href="#volume-configuration-reference">top-level <code>volumes</code> key</a>. When using <a href="#version-1">version 1</a>, the Docker Engine will create the named volume automatically if it doesn’t exist.</p> <p>You can mount a relative path on the host, which will expand relative to the directory of the Compose configuration file being used. Relative paths should always begin with <code>.</code> or <code>..</code>.</p> <pre>volumes:
  # Just specify a path and let the Engine create a volume
  - /var/lib/mysql

  # Specify an absolute path mapping
  - /opt/data:/var/lib/mysql

  # Path on the host, relative to the Compose file
  - ./cache:/tmp/cache

  # User-relative path
  - ~/configs:/etc/configs/:ro

  # Named volume
  - datavolume:/var/lib/mysql
</pre> <p>If you do not use a host path, you may specify a <code>volume_driver</code>.</p> <pre>volume_driver: mydriver
</pre> <p>Note that for <a href="#version-2">version 2 files</a>, this driver will not apply to named volumes (you should use the <code>driver</code> option when <a href="#volume-configuration-reference">declaring the volume</a> instead). For <a href="#version-1">version 1</a>, both named volumes and container volumes will use the specified driver.</p> <blockquote> <p>Note: No path expansion will be done if you have also specified a <code>volume_driver</code>.</p> </blockquote> <p>See <a href="../../engine/tutorials/dockervolumes/">Docker Volumes</a> and <a href="../../engine/extend/plugins_volume/">Volume Plugins</a> for more information.</p> <h3 id="volumes-from">volumes_from</h3> <p>Mount all of the volumes from another service or container, optionally specifying read-only access (<code>ro</code>) or read-write (<code>rw</code>). If no access level is specified, then read-write will be used.</p> <pre>volumes_from:
 - service_name
 - service_name:ro
 - container:container_name
 - container:container_name:rw
</pre> <blockquote> <p><strong>Note:</strong> The <code>container:...</code> formats are only supported in the <a href="#version-2">version 2 file format</a>. In <a href="#version-1">version 1</a>, you can use container names without marking them as such:</p> <pre>- service_name
- service_name:ro
- container_name
- container_name:rw
</pre> </blockquote> <h3 id="cpu-shares-cpu-quota-cpuset-domainname-hostname-ipc-mac-address-mem-limit-memswap-limit-privileged-read-only-restart-shm-size-stdin-open-tty-user-working-dir">cpu_shares, cpu_quota, cpuset, domainname, hostname, ipc, mac_address, mem_limit, memswap_limit, privileged, read_only, restart, shm_size, stdin_open, tty, user, working_dir</h3> <p>Each of these is a single value, analogous to its <a href="../../engine/reference/run/">docker run</a> counterpart.</p> <pre>cpu_shares: 73
cpu_quota: 50000
cpuset: 0,1

user: postgresql
working_dir: /code

domainname: foo.com
hostname: foo
ipc: host
mac_address: 02:42:ac:11:65:43

mem_limit: 1000000000
memswap_limit: 2000000000
privileged: true

restart: always

read_only: true
shm_size: 64M
stdin_open: true
tty: true
</pre> <h2 id="volume-configuration-reference">Volume configuration reference</h2> <p>While it is possible to declare volumes on the fly as part of the service declaration, this section allows you to create named volumes that can be reused across multiple services (without relying on <code>volumes_from</code>), and are easily retrieved and inspected using the docker command line or API. See the <a href="../../engine/reference/commandline/volume_create/">docker volume</a> subcommand documentation for more information.</p> <h3 id="driver">driver</h3> <p>Specify which volume driver should be used for this volume. Defaults to <code>local</code>. The Docker Engine will return an error if the driver is not available.</p> <pre> driver: foobar
</pre> <h3 id="driver-opts">driver_opts</h3> <p>Specify a list of options as key-value pairs to pass to the driver for this volume. Those options are driver-dependent - consult the driver’s documentation for more information. Optional.</p> <pre> driver_opts:
   foo: "bar"
   baz: 1
</pre> <h3 id="external">external</h3> <p>If set to <code>true</code>, specifies that this volume has been created outside of Compose. <code>docker-compose up</code> will not attempt to create it, and will raise an error if it doesn’t exist.</p> <p><code>external</code> cannot be used in conjunction with other volume configuration keys (<code>driver</code>, <code>driver_opts</code>).</p> <p>In the example below, instead of attemping to create a volume called <code>[projectname]_data</code>, Compose will look for an existing volume simply called <code>data</code> and mount it into the <code>db</code> service’s containers.</p> <pre>version: '2'

services:
  db:
    image: postgres
    volumes:
      - data:/var/lib/postgresql/data

volumes:
  data:
    external: true
</pre> <p>You can also specify the name of the volume separately from the name used to refer to it within the Compose file:</p> <pre>volumes:
  data:
    external:
      name: actual-name-of-volume
</pre> <h2 id="network-configuration-reference">Network configuration reference</h2> <p>The top-level <code>networks</code> key lets you specify networks to be created. For a full explanation of Compose’s use of Docker networking features, see the <a href="../networking/">Networking guide</a>.</p> <h3 id="driver-1">driver</h3> <p>Specify which driver should be used for this network.</p> <p>The default driver depends on how the Docker Engine you’re using is configured, but in most instances it will be <code>bridge</code> on a single host and <code>overlay</code> on a Swarm.</p> <p>The Docker Engine will return an error if the driver is not available.</p> <pre>driver: overlay
</pre> <h3 id="driver-opts-1">driver_opts</h3> <p>Specify a list of options as key-value pairs to pass to the driver for this network. Those options are driver-dependent - consult the driver’s documentation for more information. Optional.</p> <pre>  driver_opts:
    foo: "bar"
    baz: 1
</pre> <h3 id="ipam">ipam</h3> <p>Specify custom IPAM config. This is an object with several properties, each of which is optional:</p> <ul> <li>
<code>driver</code>: Custom IPAM driver, instead of the default.</li> <li>
<code>config</code>: A list with zero or more config blocks, each containing any of the following keys: <ul> <li>
<code>subnet</code>: Subnet in CIDR format that represents a network segment</li> <li>
<code>ip_range</code>: Range of IPs from which to allocate container IPs</li> <li>
<code>gateway</code>: IPv4 or IPv6 gateway for the master subnet</li> <li>
<code>aux_addresses</code>: Auxiliary IPv4 or IPv6 addresses used by Network driver, as a mapping from hostname to IP</li> </ul>
</li> </ul> <p>A full example:</p> <pre>ipam:
  driver: default
  config:
    - subnet: 172.28.0.0/16
      ip_range: 172.28.5.0/24
      gateway: 172.28.5.254
      aux_addresses:
        host1: 172.28.1.5
        host2: 172.28.1.6
        host3: 172.28.1.7
</pre> <h3 id="external-1">external</h3> <p>If set to <code>true</code>, specifies that this network has been created outside of Compose. <code>docker-compose up</code> will not attempt to create it, and will raise an error if it doesn’t exist.</p> <p><code>external</code> cannot be used in conjunction with other network configuration keys (<code>driver</code>, <code>driver_opts</code>, <code>ipam</code>).</p> <p>In the example below, <code>proxy</code> is the gateway to the outside world. Instead of attemping to create a network called <code>[projectname]_outside</code>, Compose will look for an existing network simply called <code>outside</code> and connect the <code>proxy</code> service’s containers to it.</p> <pre>version: '2'

services:
  proxy:
    build: ./proxy
    networks:
      - outside
      - default
  app:
    build: ./app
    networks:
      - default

networks:
  outside:
    external: true
</pre> <p>You can also specify the name of the network separately from the name used to refer to it within the Compose file:</p> <pre>networks:
  outside:
    external:
      name: actual-name-of-network
</pre> <h2 id="versioning">Versioning</h2> <p>There are two versions of the Compose file format:</p> <ul> <li>Version 1, the legacy format. This is specified by omitting a <code>version</code> key at the root of the YAML.</li> <li>Version 2, the recommended format. This is specified with a <code>version: '2'</code> entry at the root of the YAML.</li> </ul> <p>To move your project from version 1 to 2, see the <a href="#upgrading">Upgrading</a> section.</p> <blockquote> <p><strong>Note:</strong> If you’re using <a href="../extends/#different-environments">multiple Compose files</a> or <a href="../extends/#extending-services">extending services</a>, each file must be of the same version - you cannot mix version 1 and 2 in a single project.</p> </blockquote> <p>Several things differ depending on which version you use:</p> <ul> <li>The structure and permitted configuration keys</li> <li>The minimum Docker Engine version you must be running</li> <li>Compose’s behaviour with regards to networking</li> </ul> <p>These differences are explained below.</p> <h3 id="version-1">Version 1</h3> <p>Compose files that do not declare a version are considered “version 1”. In those files, all the <a href="#service-configuration-reference">services</a> are declared at the root of the document.</p> <p>Version 1 is supported by <strong>Compose up to 1.6.x</strong>. It will be deprecated in a future Compose release.</p> <p>Version 1 files cannot declare named <a href="#volume-configuration-reference">volumes</a>, <a href="../networking/">networks</a> or <a href="#args">build arguments</a>.</p> <p>Example:</p> <pre>web:
  build: .
  ports:
   - "5000:5000"
  volumes:
   - .:/code
  links:
   - redis
redis:
  image: redis
</pre> <h3 id="version-2">Version 2</h3> <p>Compose files using the version 2 syntax must indicate the version number at the root of the document. All <a href="#service-configuration-reference">services</a> must be declared under the <code>services</code> key.</p> <p>Version 2 files are supported by <strong>Compose 1.6.0+</strong> and require a Docker Engine of version <strong>1.10.0+</strong>.</p> <p>Named <a href="#volume-configuration-reference">volumes</a> can be declared under the <code>volumes</code> key, and <a href="#network-configuration-reference">networks</a> can be declared under the <code>networks</code> key.</p> <p>Simple example:</p> <pre>version: '2'
services:
  web:
    build: .
    ports:
     - "5000:5000"
    volumes:
     - .:/code
  redis:
    image: redis
</pre> <p>A more extended example, defining volumes and networks:</p> <pre>version: '2'
services:
  web:
    build: .
    ports:
     - "5000:5000"
    volumes:
     - .:/code
    networks:
      - front-tier
      - back-tier
  redis:
    image: redis
    volumes:
      - redis-data:/var/lib/redis
    networks:
      - back-tier
volumes:
  redis-data:
    driver: local
networks:
  front-tier:
    driver: bridge
  back-tier:
    driver: bridge
</pre> <h3 id="upgrading">Upgrading</h3> <p>In the majority of cases, moving from version 1 to 2 is a very simple process:</p> <ol> <li>Indent the whole file by one level and put a <code>services:</code> key at the top.</li> <li>Add a <code>version: '2'</code> line at the top of the file.</li> </ol> <p>It’s more complicated if you’re using particular configuration features:</p> <ul> <li>
<p><code>dockerfile</code>: This now lives under the <code>build</code> key:</p> <pre>build:
  context: .
  dockerfile: Dockerfile-alternate
</pre>
</li> <li>
<p><code>log_driver</code>, <code>log_opt</code>: These now live under the <code>logging</code> key:</p> <pre>logging:
  driver: syslog
  options:
    syslog-address: "tcp://192.168.0.42:123"
</pre>
</li> <li>
<p><code>links</code> with environment variables: As documented in the <a href="../link-env-deprecated/">environment variables reference</a>, environment variables created by links have been deprecated for some time. In the new Docker network system, they have been removed. You should either connect directly to the appropriate hostname or set the relevant environment variable yourself, using the link hostname:</p> <pre>web:
  links:
    - db
  environment:
    - DB_PORT=tcp://db:5432
</pre>
</li> <li>
<p><code>external_links</code>: Compose uses Docker networks when running version 2 projects, so links behave slightly differently. In particular, two containers must be connected to at least one network in common in order to communicate, even if explicitly linked together.</p> <p>Either connect the external container to your app’s <a href="../networking/">default network</a>, or connect both the external container and your service’s containers to an <a href="../networking/#using-a-pre-existing-network">external network</a>.</p>
</li> <li>
<p><code>net</code>: This is now replaced by <a href="#network_mode">network_mode</a>:</p> <pre>net: host    -&gt;  network_mode: host
net: bridge  -&gt;  network_mode: bridge
net: none    -&gt;  network_mode: none
</pre> <p>If you’re using <code>net: "container:[service name]"</code>, you must now use <code>network_mode: "service:[service name]"</code> instead.</p> <pre>net: "container:web"  -&gt;  network_mode: "service:web"
</pre> <p>If you’re using <code>net: "container:[container name/id]"</code>, the value does not need to change.</p> <pre>net: "container:cont-name"  -&gt;  network_mode: "container:cont-name"
net: "container:abc12345"   -&gt;  network_mode: "container:abc12345"
</pre>
</li> <li>
<p><code>volumes</code> with named volumes: these must now be explicitly declared in a top-level <code>volumes</code> section of your Compose file. If a service mounts a named volume called <code>data</code>, you must declare a <code>data</code> volume in your top-level <code>volumes</code> section. The whole file might look like this:</p> <pre>version: '2'
services:
  db:
    image: postgres
    volumes:
      - data:/var/lib/postgresql/data
volumes:
  data: {}
</pre> <p>By default, Compose creates a volume whose name is prefixed with your project name. If you want it to just be called <code>data</code>, declare it as external:</p> <pre>volumes:
  data:
    external: true
</pre>
</li> </ul> <h2 id="variable-substitution">Variable substitution</h2> <p>Your configuration options can contain environment variables. Compose uses the variable values from the shell environment in which <code>docker-compose</code> is run. For example, suppose the shell contains <code>EXTERNAL_PORT=8000</code> and you supply this configuration:</p> <pre>web:
  build: .
  ports:
    - "${EXTERNAL_PORT}:5000"
</pre> <p>When you run <code>docker-compose up</code> with this configuration, Compose looks for the <code>EXTERNAL_PORT</code> environment variable in the shell and substitutes its value in. In this example, Compose resolves the port mapping to <code>"8000:5000"</code> before creating the <code>web</code> container.</p> <p>If an environment variable is not set, Compose substitutes with an empty string. In the example above, if <code>EXTERNAL_PORT</code> is not set, the value for the port mapping is <code>:5000</code> (which is of course an invalid port mapping, and will result in an error when attempting to create the container).</p> <p>Both <code>$VARIABLE</code> and <code>${VARIABLE}</code> syntax are supported. Extended shell-style features, such as <code>${VARIABLE-default}</code> and <code>${VARIABLE/foo/bar}</code>, are not supported.</p> <p>You can use a <code>$$</code> (double-dollar sign) when your configuration needs a literal dollar sign. This also prevents Compose from interpolating a value, so a <code>$$</code> allows you to refer to environment variables that you don’t want processed by Compose.</p> <pre>web:
  build: .
  command: "$$VAR_NOT_INTERPOLATED_BY_COMPOSE"
</pre> <p>If you forget and use a single dollar sign (<code>$</code>), Compose interprets the value as an environment variable and will warn you:</p> <p>The VAR_NOT_INTERPOLATED_BY_COMPOSE is not set. Substituting an empty string.</p> <h2 id="compose-documentation">Compose documentation</h2> <ul> <li><a href="../">User guide</a></li> <li><a href="../install/">Installing Compose</a></li> <li><a href="../django/">Get started with Django</a></li> <li><a href="../rails/">Get started with Rails</a></li> <li><a href="../wordpress/">Get started with WordPress</a></li> <li><a href="https://docs.docker.com/compose/reference/" target="_blank">Command line reference</a></li> </ul>
<div class="_attribution">
  <p class="_attribution-p">
    © 2013–2016 Docker, Inc.<br>Licensed under the Apache License, Version 2.0.<br>Docker and the Docker logo are trademarks or registered trademarks of Docker, Inc. in the United States and/or other countries.<br>Docker, Inc. and other parties may also have trademark rights in other terms used herein.<br>
    <a href="https://docs.docker.com/compose/compose-file/" class="_attribution-link" target="_blank">https://docs.docker.com/compose/compose-file/</a>
  </p>
</div>

			</div>
		</div>
	</section>

	</div>
</body>
</html>
