
<!DOCTYPE HTML>

<html lang="en">

<head>
  <meta charset="utf-8">
  <title>Remote API v1.14 (Engine) - Docker 1.10 - W3cubDocs</title>
  
  <meta name="description" content=" GET &#47;containers&#47;json ">
  <meta name="keywords" content="docker, remote, api, endpoints, going, further, engine, -, docker~1.10">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="http://docs.w3cub.com/docker~1.10/engine/reference/api/docker_remote_api_v1.14/">
  <link href="/favicon.png" rel="icon">
  <link type="text/css" rel="stylesheet" href="/assets/application-50364fff564ce3b6327021805f3f00e2957b441cf27f576a7dd4ff63bbc47047.css">
  <script type="text/javascript" src="/assets/application-db64bfd54ceb42be11af7995804cf4902548419ceb79d509b0b7d62c22d98e6f.js"></script>
  <script src="/json/docker~1.10.js"></script>
  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-71174418-1']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>


</head>

<body>
	<div class="_app">
	<header class="_header">
  
  <form class="_search">
    <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
    <a class="_search-clear"></a>
    <div class="_search-tag"></div>
  </form>
  
  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/docker~1.10/" class="_nav-link" title="" style="margin-left:0;">Docker 1.10</a></span>
  
  <nav class="_nav">
    <a href="/app/" class="_nav-link ">App</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		<div class="_list">
			
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<div class="_page _docker">
				
<h1 id="docker-remote-api-v1-14">Docker Remote API v1.14</h1> <h2 id="1-brief-introduction">1. Brief introduction</h2> <ul> <li>The Remote API has replaced <code>rcli</code>.</li> <li>The daemon listens on <code>unix:///var/run/docker.sock</code> but you can <a href="../../../quickstart/#bind-docker-to-another-host-port-or-a-unix-socket">Bind Docker to another host/port or a Unix socket</a>.</li> <li>The API tends to be REST, but for some complex commands, like <code>attach</code> or <code>pull</code>, the HTTP connection is hijacked to transport <code>STDOUT</code>, <code>STDIN</code> and <code>STDERR</code>.</li> </ul> <h1 id="2-endpoints">2. Endpoints</h1> <h2 id="2-1-containers">2.1 Containers</h2> <h3 id="list-containers">List containers</h3> <p><code>GET /containers/json</code></p> <p>List containers</p> <p><strong>Example request</strong>:</p> <pre>    GET /containers/json?all=1&amp;before=8dfafdbc3a40&amp;size=1 HTTP/1.1
</pre> <p><strong>Example response</strong>:</p> <pre>    HTTP/1.1 200 OK
    Content-Type: application/json

    [
         {
                 "Id": "8dfafdbc3a40",
                 "Image": "ubuntu:latest",
                 "Command": "echo 1",
                 "Created": 1367854155,
                 "Status": "Exit 0",
                 "Ports": [{"PrivatePort": 2222, "PublicPort": 3333, "Type": "tcp"}],
                 "SizeRw": 12288,
                 "SizeRootFs": 0
         },
         {
                 "Id": "9cd87474be90",
                 "Image": "ubuntu:latest",
                 "Command": "echo 222222",
                 "Created": 1367854155,
                 "Status": "Exit 0",
                 "Ports": [],
                 "SizeRw": 12288,
                 "SizeRootFs": 0
         },
         {
                 "Id": "3176a2479c92",
                 "Image": "ubuntu:latest",
                 "Command": "echo 3333333333333333",
                 "Created": 1367854154,
                 "Status": "Exit 0",
                 "Ports":[],
                 "SizeRw":12288,
                 "SizeRootFs":0
         },
         {
                 "Id": "4cb07b47f9fb",
                 "Image": "ubuntu:latest",
                 "Command": "echo 444444444444444444444444444444444",
                 "Created": 1367854152,
                 "Status": "Exit 0",
                 "Ports": [],
                 "SizeRw": 12288,
                 "SizeRootFs": 0
         }
    ]
</pre> <p>Query Parameters:</p> <ul> <li>
<strong>all</strong> – 1/True/true or 0/False/false, Show all containers. Only running containers are shown by default (i.e., this defaults to false)</li> <li>
<strong>limit</strong> – Show <code>limit</code> last created containers, include non-running ones.</li> <li>
<strong>since</strong> – Show only containers created since Id, include non-running ones.</li> <li>
<strong>before</strong> – Show only containers created before Id, include non-running ones.</li> <li>
<strong>size</strong> – 1/True/true or 0/False/false, Show the containers sizes</li> <li>
<strong>filters</strong> - a json encoded value of the filters (a map[string][]string) to process on the containers list. Available filters: <ul> <li>exited=&lt;int&gt; -- containers with exit code of &lt;int&gt;</li> <li>status=(restarting|running|paused|exited)</li> </ul>
</li> </ul> <p>Status Codes:</p> <ul> <li>
<strong>200</strong> – no error</li> <li>
<strong>400</strong> – bad parameter</li> <li>
<strong>500</strong> – server error</li> </ul> <h3 id="create-a-container">Create a container</h3> <p><code>POST /containers/create</code></p> <p>Create a container</p> <p><strong>Example request</strong>:</p> <pre>    POST /containers/create HTTP/1.1
    Content-Type: application/json

    {
         "Hostname":"",
         "Domainname": "",
         "User":"",
         "Memory":0,
         "MemorySwap":0,
         "CpuShares": 512,
         "Cpuset": "0,1",
         "AttachStdin":false,
         "AttachStdout":true,
         "AttachStderr":true,
         "PortSpecs":null,
         "Tty":false,
         "OpenStdin":false,
         "StdinOnce":false,
         "Env": [
                 "FOO=bar",
                 "BAZ=quux"
         ],
         "Cmd":[
                 "date"
         ],
         "Image":"ubuntu",
         "Volumes":{
                 "/tmp": {}
         },
         "WorkingDir":"",
         "NetworkDisabled": false,
         "ExposedPorts":{
                 "22/tcp": {}
         },
         "RestartPolicy": { "Name": "always" }
    }
</pre> <p><strong>Example response</strong>:</p> <pre>    HTTP/1.1 201 Created
    Content-Type: application/json

    {
         "Id":"e90e34656806"
         "Warnings":[]
    }
</pre> <p>Json Parameters:</p> <ul> <li>
<strong>RestartPolicy</strong> – The behavior to apply when the container exits. The value is an object with a <code>Name</code> property of either <code>"always"</code> to always restart or <code>"on-failure"</code> to restart only when the container exit code is non-zero. If <code>on-failure</code> is used, <code>MaximumRetryCount</code> controls the number of times to retry before giving up. The default is not to restart. (optional) An ever increasing delay (double the previous delay, starting at 100mS) is added before each restart to prevent flooding the server.</li> <li>
<strong>config</strong> – the container’s configuration</li> </ul> <p>Query Parameters:</p> <ul> <li>
<strong>name</strong> – Assign the specified name to the container. Must match <code>/?[a-zA-Z0-9_-]+</code>.</li> </ul> <p>Status Codes:</p> <ul> <li>
<strong>201</strong> – no error</li> <li>
<strong>404</strong> – no such container</li> <li>
<strong>406</strong> – impossible to attach (container not running)</li> <li>
<strong>500</strong> – server error</li> </ul> <h3 id="inspect-a-container">Inspect a container</h3> <p><code>GET /containers/(id or name)/json</code></p> <p>Return low-level information on the container <code>id</code></p> <p><strong>Example request</strong>:</p> <pre>    GET /containers/4fa6e0f0c678/json HTTP/1.1
</pre> <p><strong>Example response</strong>:</p> <pre>    HTTP/1.1 200 OK
    Content-Type: application/json

    {
                 "Id": "4fa6e0f0c6786287e131c3852c58a2e01cc697a68231826813597e4994f1d6e2",
                 "Created": "2013-05-07T14:51:42.041847+02:00",
                 "Path": "date",
                 "Args": [],
                 "Config": {
                         "Hostname": "4fa6e0f0c678",
                         "User": "",
                         "Memory": 0,
                         "MemorySwap": 0,
                         "AttachStdin": false,
                         "AttachStdout": true,
                         "AttachStderr": true,
                         "PortSpecs": null,
                         "Tty": false,
                         "OpenStdin": false,
                         "StdinOnce": false,
                         "Env": null,
                         "Cmd": [
                                 "date"
                         ],
                         "Dns": null,
                         "Image": "ubuntu",
                         "Volumes": {},
                         "VolumesFrom": "",
                         "WorkingDir": ""
                 },
                 "State": {
                         "Running": false,
                         "Pid": 0,
                         "ExitCode": 0,
                         "StartedAt": "2013-05-07T14:51:42.087658+02:01360",
                         "Ghost": false
                 },
                 "Image": "b750fe79269d2ec9a3c593ef05b4332b1d1a02a62b4accb2c21d589ff2f5f2dc",
                 "NetworkSettings": {
                         "IpAddress": "",
                         "IpPrefixLen": 0,
                         "Gateway": "",
                         "Bridge": "",
                         "PortMapping": null
                 },
                 "SysInitPath": "/home/kitty/go/src/github.com/docker/docker/bin/docker",
                 "ResolvConfPath": "/etc/resolv.conf",
                 "Volumes": {},
                 "HostConfig": {
                     "Binds": null,
                     "ContainerIDFile": "",
                     "LxcConf": [],
                     "Privileged": false,
                     "PortBindings": {
                        "80/tcp": [
                            {
                                "HostIp": "0.0.0.0",
                                "HostPort": "49153"
                            }
                        ]
                     },
                     "Links": ["/name:alias"],
                     "PublishAllPorts": false,
                     "CapAdd": ["NET_ADMIN"],
                     "CapDrop": ["MKNOD"]
                 }
    }
</pre> <p>Status Codes:</p> <ul> <li>
<strong>200</strong> – no error</li> <li>
<strong>404</strong> – no such container</li> <li>
<strong>500</strong> – server error</li> </ul> <h3 id="list-processes-running-inside-a-container">List processes running inside a container</h3> <p><code>GET /containers/(id or name)/top</code></p> <p>List processes running inside the container <code>id</code>. On Unix systems this is done by running the <code>ps</code> command. This endpoint is not supported on Windows.</p> <p><strong>Example request</strong>:</p> <pre>GET /containers/4fa6e0f0c678/top HTTP/1.1
</pre> <p><strong>Example response</strong>:</p> <pre>HTTP/1.1 200 OK
Content-Type: application/json

{
   "Titles" : [
     "UID", "PID", "PPID", "C", "STIME", "TTY", "TIME", "CMD"
   ],
   "Processes" : [
     [
       "root", "13642", "882", "0", "17:03", "pts/0", "00:00:00", "/bin/bash"
     ],
     [
       "root", "13735", "13642", "0", "17:06", "pts/0", "00:00:00", "sleep 10"
     ]
   ]
}
</pre> <p><strong>Example request</strong>:</p> <pre>GET /containers/4fa6e0f0c678/top?ps_args=aux HTTP/1.1
</pre> <p><strong>Example response</strong>:</p> <pre>HTTP/1.1 200 OK
Content-Type: application/json

{
  "Titles" : [
    "USER","PID","%CPU","%MEM","VSZ","RSS","TTY","STAT","START","TIME","COMMAND"
  ]
  "Processes" : [
    [
      "root","13642","0.0","0.1","18172","3184","pts/0","Ss","17:03","0:00","/bin/bash"
    ],
    [
      "root","13895","0.0","0.0","4348","692","pts/0","S+","17:15","0:00","sleep 10"
    ]
  ],
}
</pre> <p>Query Parameters:</p> <ul> <li>
<strong>ps_args</strong> – <code>ps</code> arguments to use (e.g., <code>aux</code>), defaults to <code>-ef</code>
</li> </ul> <p>Status Codes:</p> <ul> <li>
<strong>200</strong> – no error</li> <li>
<strong>404</strong> – no such container</li> <li>
<strong>500</strong> – server error</li> </ul> <h3 id="get-container-logs">Get container logs</h3> <p><code>GET /containers/(id or name)/logs</code></p> <p>Get stdout and stderr logs from the container <code>id</code></p> <p><strong>Example request</strong>:</p> <pre>   GET /containers/4fa6e0f0c678/logs?stderr=1&amp;stdout=1&amp;timestamps=1&amp;follow=1&amp;tail=10 HTTP/1.1
</pre> <p><strong>Example response</strong>:</p> <pre>   HTTP/1.1 200 OK
   Content-Type: application/vnd.docker.raw-stream

   {{ STREAM }}
</pre> <p>Query Parameters:</p> <ul> <li>
<strong>follow</strong> – 1/True/true or 0/False/false, return stream. Default false</li> <li>
<strong>stdout</strong> – 1/True/true or 0/False/false, show stdout log. Default false</li> <li>
<strong>stderr</strong> – 1/True/true or 0/False/false, show stderr log. Default false</li> <li>
<strong>timestamps</strong> – 1/True/true or 0/False/false, print timestamps for every log line. Default false</li> <li>
<strong>tail</strong> – Output specified number of lines at the end of logs: <code>all</code> or <code>&lt;number&gt;</code>. Default all</li> </ul> <p>Status Codes:</p> <ul> <li>
<strong>200</strong> – no error</li> <li>
<strong>404</strong> – no such container</li> <li>
<strong>500</strong> – server error</li> </ul> <h3 id="inspect-changes-on-a-container-s-filesystem">Inspect changes on a container’s filesystem</h3> <p><code>GET /containers/(id or name)/changes</code></p> <p>Inspect changes on container <code>id</code>’s filesystem</p> <p><strong>Example request</strong>:</p> <pre>    GET /containers/4fa6e0f0c678/changes HTTP/1.1
</pre> <p><strong>Example response</strong>:</p> <pre>    HTTP/1.1 200 OK
    Content-Type: application/json

    [
         {
                 "Path": "/dev",
                 "Kind": 0
         },
         {
                 "Path": "/dev/kmsg",
                 "Kind": 1
         },
         {
                 "Path": "/test",
                 "Kind": 1
         }
    ]
</pre> <p>Status Codes:</p> <ul> <li>
<strong>200</strong> – no error</li> <li>
<strong>404</strong> – no such container</li> <li>
<strong>500</strong> – server error</li> </ul> <h3 id="export-a-container">Export a container</h3> <p><code>GET /containers/(id or name)/export</code></p> <p>Export the contents of container <code>id</code></p> <p><strong>Example request</strong>:</p> <pre>    GET /containers/4fa6e0f0c678/export HTTP/1.1
</pre> <p><strong>Example response</strong>:</p> <pre>    HTTP/1.1 200 OK
    Content-Type: application/octet-stream

    {{ TAR STREAM }}
</pre> <p>Status Codes:</p> <ul> <li>
<strong>200</strong> – no error</li> <li>
<strong>404</strong> – no such container</li> <li>
<strong>500</strong> – server error</li> </ul> <h3 id="start-a-container">Start a container</h3> <p><code>POST /containers/(id or name)/start</code></p> <p>Start the container <code>id</code></p> <p><strong>Example request</strong>:</p> <pre>    POST /containers/(id or name)/start HTTP/1.1
    Content-Type: application/json

    {
         "Binds":["/tmp:/tmp"],
         "Links":["redis3:redis"],
         "LxcConf":[{"Key":"lxc.utsname","Value":"docker"}],
         "PortBindings":{ "22/tcp": [{ "HostPort": "11022" }] },
         "PublishAllPorts":false,
         "Privileged":false,
         "Dns": ["8.8.8.8"],
         "VolumesFrom": ["parent", "other:ro"],
         "CapAdd": ["NET_ADMIN"],
         "CapDrop": ["MKNOD"]
    }
</pre> <p><strong>Example response</strong>:</p> <pre>    HTTP/1.1 204 No Content
</pre> <p>Json Parameters:</p> <ul> <li>
<strong>hostConfig</strong> – the container’s host configuration (optional)</li> </ul> <p>Status Codes:</p> <ul> <li>
<strong>204</strong> – no error</li> <li>
<strong>304</strong> – container already started</li> <li>
<strong>404</strong> – no such container</li> <li>
<strong>500</strong> – server error</li> </ul> <h3 id="stop-a-container">Stop a container</h3> <p><code>POST /containers/(id or name)/stop</code></p> <p>Stop the container <code>id</code></p> <p><strong>Example request</strong>:</p> <pre>    POST /containers/e90e34656806/stop?t=5 HTTP/1.1
</pre> <p><strong>Example response</strong>:</p> <pre>    HTTP/1.1 204 No Content
</pre> <p>Query Parameters:</p> <ul> <li>
<strong>t</strong> – number of seconds to wait before killing the container</li> </ul> <p>Status Codes:</p> <ul> <li>
<strong>204</strong> – no error</li> <li>
<strong>304</strong> – container already stopped</li> <li>
<strong>404</strong> – no such container</li> <li>
<strong>500</strong> – server error</li> </ul> <h3 id="restart-a-container">Restart a container</h3> <p><code>POST /containers/(id or name)/restart</code></p> <p>Restart the container <code>id</code></p> <p><strong>Example request</strong>:</p> <pre>    POST /containers/e90e34656806/restart?t=5 HTTP/1.1
</pre> <p><strong>Example response</strong>:</p> <pre>    HTTP/1.1 204 No Content
</pre> <p>Query Parameters:</p> <ul> <li>
<strong>t</strong> – number of seconds to wait before killing the container</li> </ul> <p>Status Codes:</p> <ul> <li>
<strong>204</strong> – no error</li> <li>
<strong>404</strong> – no such container</li> <li>
<strong>500</strong> – server error</li> </ul> <h3 id="kill-a-container">Kill a container</h3> <p><code>POST /containers/(id or name)/kill</code></p> <p>Kill the container <code>id</code></p> <p><strong>Example request</strong>:</p> <pre>    POST /containers/e90e34656806/kill HTTP/1.1
</pre> <p><strong>Example response</strong>:</p> <pre>    HTTP/1.1 204 No Content
</pre> <p>Query Parameters</p> <ul> <li>
<strong>signal</strong> - Signal to send to the container: integer or string like “SIGINT”. When not set, SIGKILL is assumed and the call will wait for the container to exit.</li> </ul> <p>Status Codes:</p> <ul> <li>
<strong>204</strong> – no error</li> <li>
<strong>404</strong> – no such container</li> <li>
<strong>500</strong> – server error</li> </ul> <h3 id="pause-a-container">Pause a container</h3> <p><code>POST /containers/(id or name)/pause</code></p> <p>Pause the container <code>id</code></p> <p><strong>Example request</strong>:</p> <pre>    POST /containers/e90e34656806/pause HTTP/1.1
</pre> <p><strong>Example response</strong>:</p> <pre>    HTTP/1.1 204 No Content
</pre> <p>Status Codes:</p> <ul> <li>
<strong>204</strong> – no error</li> <li>
<strong>404</strong> – no such container</li> <li>
<strong>500</strong> – server error</li> </ul> <h3 id="unpause-a-container">Unpause a container</h3> <p><code>POST /containers/(id or name)/unpause</code></p> <p>Unpause the container <code>id</code></p> <p><strong>Example request</strong>:</p> <pre>    POST /containers/e90e34656806/unpause HTTP/1.1
</pre> <p><strong>Example response</strong>:</p> <pre>    HTTP/1.1 204 No Content
</pre> <p>Status Codes:</p> <ul> <li>
<strong>204</strong> – no error</li> <li>
<strong>404</strong> – no such container</li> <li>
<strong>500</strong> – server error</li> </ul> <h3 id="attach-to-a-container">Attach to a container</h3> <p><code>POST /containers/(id or name)/attach</code></p> <p>Attach to the container <code>id</code></p> <p><strong>Example request</strong>:</p> <pre>    POST /containers/16253994b7c4/attach?logs=1&amp;stream=0&amp;stdout=1 HTTP/1.1
</pre> <p><strong>Example response</strong>:</p> <pre>    HTTP/1.1 200 OK
    Content-Type: application/vnd.docker.raw-stream

    {{ STREAM }}
</pre> <p>Query Parameters:</p> <ul> <li>
<strong>logs</strong> – 1/True/true or 0/False/false, return logs. Default false</li> <li>
<strong>stream</strong> – 1/True/true or 0/False/false, return stream. Default false</li> <li>
<strong>stdin</strong> – 1/True/true or 0/False/false, if stream=true, attach to stdin. Default false</li> <li>
<strong>stdout</strong> – 1/True/true or 0/False/false, if logs=true, return stdout log, if stream=true, attach to stdout. Default false</li> <li>
<strong>stderr</strong> – 1/True/true or 0/False/false, if logs=true, return stderr log, if stream=true, attach to stderr. Default false</li> </ul> <p>Status Codes:</p> <ul> <li>
<strong>200</strong> – no error</li> <li>
<strong>400</strong> – bad parameter</li> <li>
<strong>404</strong> – no such container</li> <li>
<p><strong>500</strong> – server error</p> <p><strong>Stream details</strong>:</p> <p>When using the TTY setting is enabled in <a href="#create-a-container"><code>POST /containers/create</code></a>, the stream is the raw data from the process PTY and client’s stdin. When the TTY is disabled, then the stream is multiplexed to separate stdout and stderr.</p> <p>The format is a <strong>Header</strong> and a <strong>Payload</strong> (frame).</p> <p><strong>HEADER</strong></p> <p>The header will contain the information on which stream write the stream (stdout or stderr). It also contain the size of the associated frame encoded on the last 4 bytes (uint32).</p> <p>It is encoded on the first 8 bytes like this:</p> <pre>header := [8]byte{STREAM_TYPE, 0, 0, 0, SIZE1, SIZE2, SIZE3, SIZE4}
</pre> <p><code>STREAM_TYPE</code> can be:</p>
</li> <li><p>0: stdin (will be written on stdout)</p></li> <li><p>1: stdout</p></li> <li>
<p>2: stderr</p> <p><code>SIZE1, SIZE2, SIZE3, SIZE4</code> are the 4 bytes of the uint32 size encoded as big endian.</p> <p><strong>PAYLOAD</strong></p> <p>The payload is the raw stream.</p> <p><strong>IMPLEMENTATION</strong></p> <p>The simplest way to implement the Attach protocol is the following:</p> <ol> <li>Read 8 bytes</li> <li>chose stdout or stderr depending on the first byte</li> <li>Extract the frame size from the last 4 bytes</li> <li>Read the extracted size and output it on the correct output</li> <li>Goto 1</li> </ol>
</li> </ul> <h3 id="attach-to-a-container-websocket">Attach to a container (websocket)</h3> <p><code>GET /containers/(id or name)/attach/ws</code></p> <p>Attach to the container <code>id</code> via websocket</p> <p>Implements websocket protocol handshake according to <a href="http://tools.ietf.org/html/rfc6455" target="_blank">RFC 6455</a></p> <p><strong>Example request</strong></p> <pre>    GET /containers/e90e34656806/attach/ws?logs=0&amp;stream=1&amp;stdin=1&amp;stdout=1&amp;stderr=1 HTTP/1.1
</pre> <p><strong>Example response</strong></p> <pre>    {{ STREAM }}
</pre> <p>Query Parameters:</p> <ul> <li>
<strong>logs</strong> – 1/True/true or 0/False/false, return logs. Default false</li> <li>
<strong>stream</strong> – 1/True/true or 0/False/false, return stream. Default false</li> <li>
<strong>stdin</strong> – 1/True/true or 0/False/false, if stream=true, attach to stdin. Default false</li> <li>
<strong>stdout</strong> – 1/True/true or 0/False/false, if logs=true, return stdout log, if stream=true, attach to stdout. Default false</li> <li>
<strong>stderr</strong> – 1/True/true or 0/False/false, if logs=true, return stderr log, if stream=true, attach to stderr. Default false</li> </ul> <p>Status Codes:</p> <ul> <li>
<strong>200</strong> – no error</li> <li>
<strong>400</strong> – bad parameter</li> <li>
<strong>404</strong> – no such container</li> <li>
<strong>500</strong> – server error</li> </ul> <h3 id="wait-a-container">Wait a container</h3> <p><code>POST /containers/(id or name)/wait</code></p> <p>Block until container <code>id</code> stops, then returns the exit code</p> <p><strong>Example request</strong>:</p> <pre>    POST /containers/16253994b7c4/wait HTTP/1.1
</pre> <p><strong>Example response</strong>:</p> <pre>    HTTP/1.1 200 OK
    Content-Type: application/json

    {"StatusCode": 0}
</pre> <p>Status Codes:</p> <ul> <li>
<strong>200</strong> – no error</li> <li>
<strong>404</strong> – no such container</li> <li>
<strong>500</strong> – server error</li> </ul> <h3 id="remove-a-container">Remove a container</h3> <p><code>DELETE /containers/(id or name)</code></p> <p>Remove the container <code>id</code> from the filesystem</p> <p><strong>Example request</strong>:</p> <pre>    DELETE /containers/16253994b7c4?v=1 HTTP/1.1
</pre> <p><strong>Example response</strong>:</p> <pre>    HTTP/1.1 204 No Content
</pre> <p>Query Parameters:</p> <ul> <li>
<strong>v</strong> – 1/True/true or 0/False/false, Remove the volumes associated to the container. Default false</li> <li>
<strong>force</strong> - 1/True/true or 0/False/false, Kill then remove the container. Default false</li> </ul> <p>Status Codes:</p> <ul> <li>
<strong>204</strong> – no error</li> <li>
<strong>400</strong> – bad parameter</li> <li>
<strong>404</strong> – no such container</li> <li>
<strong>500</strong> – server error</li> </ul> <h3 id="copy-files-or-folders-from-a-container">Copy files or folders from a container</h3> <p><code>POST /containers/(id or name)/copy</code></p> <p>Copy files or folders of container <code>id</code></p> <p><strong>Example request</strong>:</p> <pre>    POST /containers/4fa6e0f0c678/copy HTTP/1.1
    Content-Type: application/json

    {
         "Resource": "test.txt"
    }
</pre> <p><strong>Example response</strong>:</p> <pre>    HTTP/1.1 200 OK
    Content-Type: application/octet-stream

    {{ TAR STREAM }}
</pre> <p>Status Codes:</p> <ul> <li>
<strong>200</strong> – no error</li> <li>
<strong>404</strong> – no such container</li> <li>
<strong>500</strong> – server error</li> </ul> <h2 id="2-2-images">2.2 Images</h2> <h3 id="list-images">List Images</h3> <p><code>GET /images/json</code></p> <p><strong>Example request</strong>:</p> <pre>    GET /images/json?all=0 HTTP/1.1
</pre> <p><strong>Example response</strong>:</p> <pre>    HTTP/1.1 200 OK
    Content-Type: application/json

    [
      {
         "RepoTags": [
           "ubuntu:12.04",
           "ubuntu:precise",
           "ubuntu:latest"
         ],
         "Id": "8dbd9e392a964056420e5d58ca5cc376ef18e2de93b5cc90e868a1bbc8318c1c",
         "Created": 1365714795,
         "Size": 131506275,
         "VirtualSize": 131506275
      },
      {
         "RepoTags": [
           "ubuntu:12.10",
           "ubuntu:quantal"
         ],
         "ParentId": "27cf784147099545",
         "Id": "b750fe79269d2ec9a3c593ef05b4332b1d1a02a62b4accb2c21d589ff2f5f2dc",
         "Created": 1364102658,
         "Size": 24653,
         "VirtualSize": 180116135
      }
    ]
</pre> <p>Query Parameters:</p> <ul> <li>
<strong>all</strong> – 1/True/true or 0/False/false, default false</li> <li>
<strong>filters</strong> – a json encoded value of the filters (a map[string][]string) to process on the images list. Available filters: <ul> <li>dangling=true</li> </ul>
</li> <li>
<strong>filter</strong> - only return images with the specified name</li> </ul> <h3 id="create-an-image">Create an image</h3> <p><code>POST /images/create</code></p> <p>Create an image, either by pulling it from the registry or by importing it</p> <p><strong>Example request</strong>:</p> <pre>    POST /images/create?fromImage=ubuntu HTTP/1.1
</pre> <p><strong>Example response</strong>:</p> <pre>    HTTP/1.1 200 OK
    Content-Type: application/json

    {"status": "Pulling..."}
    {"status": "Pulling", "progress": "1 B/ 100 B", "progressDetail": {"current": 1, "total": 100}}
    {"error": "Invalid..."}
    ...

When using this endpoint to pull an image from the registry, the
`X-Registry-Auth` header can be used to include
a base64-encoded AuthConfig object.
</pre> <p>Query Parameters:</p> <ul> <li>
<strong>fromImage</strong> – name of the image to pull</li> <li>
<strong>fromSrc</strong> – source to import, - means stdin</li> <li>
<strong>repo</strong> – repository</li> <li>
<strong>tag</strong> – tag</li> <li>
<strong>registry</strong> – the registry to pull from</li> </ul> <p>Request Headers:</p> <ul> <li>
<strong>X-Registry-Auth</strong> – base64-encoded AuthConfig object</li> </ul> <p>Status Codes:</p> <ul> <li>
<strong>200</strong> – no error</li> <li>
<strong>500</strong> – server error</li> </ul> <h3 id="inspect-an-image">Inspect an image</h3> <p><code>GET /images/(name)/json</code></p> <p>Return low-level information on the image <code>name</code></p> <p><strong>Example request</strong>:</p> <pre>    GET /images/ubuntu/json HTTP/1.1
</pre> <p><strong>Example response</strong>:</p> <pre>    HTTP/1.1 200 OK
    Content-Type: application/json

    {
         "Created": "2013-03-23T22:24:18.818426-07:00",
         "Container": "3d67245a8d72ecf13f33dffac9f79dcdf70f75acb84d308770391510e0c23ad0",
         "ContainerConfig":
                 {
                         "Hostname": "",
                         "User": "",
                         "Memory": 0,
                         "MemorySwap": 0,
                         "AttachStdin": false,
                         "AttachStdout": false,
                         "AttachStderr": false,
                         "PortSpecs": null,
                         "Tty": true,
                         "OpenStdin": true,
                         "StdinOnce": false,
                         "Env": null,
                         "Cmd": ["/bin/bash"],
                         "Dns": null,
                         "Image": "ubuntu",
                         "Volumes": null,
                         "VolumesFrom": "",
                         "WorkingDir": ""
                 },
         "Id": "b750fe79269d2ec9a3c593ef05b4332b1d1a02a62b4accb2c21d589ff2f5f2dc",
         "Parent": "27cf784147099545",
         "Size": 6824592
    }
</pre> <p>Status Codes:</p> <ul> <li>
<strong>200</strong> – no error</li> <li>
<strong>404</strong> – no such image</li> <li>
<strong>500</strong> – server error</li> </ul> <h3 id="get-the-history-of-an-image">Get the history of an image</h3> <p><code>GET /images/(name)/history</code></p> <p>Return the history of the image <code>name</code></p> <p><strong>Example request</strong>:</p> <pre>    GET /images/ubuntu/history HTTP/1.1
</pre> <p><strong>Example response</strong>:</p> <pre>    HTTP/1.1 200 OK
    Content-Type: application/json

    [
         {
                 "Id": "b750fe79269d",
                 "Created": 1364102658,
                 "CreatedBy": "/bin/bash"
         },
         {
                 "Id": "27cf78414709",
                 "Created": 1364068391,
                 "CreatedBy": ""
         }
    ]
</pre> <p>Status Codes:</p> <ul> <li>
<strong>200</strong> – no error</li> <li>
<strong>404</strong> – no such image</li> <li>
<strong>500</strong> – server error</li> </ul> <h3 id="push-an-image-on-the-registry">Push an image on the registry</h3> <p><code>POST /images/(name)/push</code></p> <p>Push the image <code>name</code> on the registry</p> <p><strong>Example request</strong>:</p> <pre>    POST /images/test/push HTTP/1.1
</pre> <p><strong>Example response</strong>:</p> <pre>    HTTP/1.1 200 OK
    Content-Type: application/json

    {"status": "Pushing..."}
    {"status": "Pushing", "progress": "1/? (n/a)", "progressDetail": {"current": 1}}}
    {"error": "Invalid..."}
    ...

If you wish to push an image on to a private registry, that image must already have been tagged
into a repository which references that registry host name and port.  This repository name should
then be used in the URL. This mirrors the flow of the CLI.
</pre> <p><strong>Example request</strong>:</p> <pre>    POST /images/registry.acme.com:5000/test/push HTTP/1.1
</pre> <p>Query Parameters:</p> <ul> <li>
<strong>tag</strong> – the tag to associate with the image on the registry, optional</li> </ul> <p>Request Headers:</p> <ul> <li>
<strong>X-Registry-Auth</strong> – include a base64-encoded AuthConfig object.</li> </ul> <p>Status Codes:</p> <ul> <li>
<strong>200</strong> – no error</li> <li>
<strong>404</strong> – no such image</li> <li>
<strong>500</strong> – server error</li> </ul> <h3 id="tag-an-image-into-a-repository">Tag an image into a repository</h3> <p><code>POST /images/(name)/tag</code></p> <p>Tag the image <code>name</code> into a repository</p> <p><strong>Example request</strong>:</p> <pre>    POST /images/test/tag?repo=myrepo&amp;force=0&amp;tag=v42 HTTP/1.1
</pre> <p><strong>Example response</strong>:</p> <pre>    HTTP/1.1 201 OK
</pre> <p>Query Parameters:</p> <ul> <li>
<strong>repo</strong> – The repository to tag in</li> <li>
<strong>force</strong> – 1/True/true or 0/False/false, default false</li> <li>
<strong>tag</strong> - The new tag name</li> </ul> <p>Status Codes:</p> <ul> <li>
<strong>201</strong> – no error</li> <li>
<strong>400</strong> – bad parameter</li> <li>
<strong>404</strong> – no such image</li> <li>
<strong>409</strong> – conflict</li> <li>
<strong>500</strong> – server error</li> </ul> <h3 id="remove-an-image">Remove an image</h3> <p><code>DELETE /images/(name)</code></p> <p>Remove the image <code>name</code> from the filesystem</p> <p><strong>Example request</strong>:</p> <pre>    DELETE /images/test HTTP/1.1
</pre> <p><strong>Example response</strong>:</p> <pre>    HTTP/1.1 200 OK
    Content-type: application/json

    [
     {"Untagged": "3e2f21a89f"},
     {"Deleted": "3e2f21a89f"},
     {"Deleted": "53b4f83ac9"}
    ]
</pre> <p>Query Parameters:</p> <ul> <li>
<strong>force</strong> – 1/True/true or 0/False/false, default false</li> <li>
<strong>noprune</strong> – 1/True/true or 0/False/false, default false</li> </ul> <p>Status Codes:</p> <ul> <li>
<strong>200</strong> – no error</li> <li>
<strong>404</strong> – no such image</li> <li>
<strong>409</strong> – conflict</li> <li>
<strong>500</strong> – server error</li> </ul> <h3 id="search-images">Search images</h3> <p><code>GET /images/search</code></p> <p>Search for an image on <a href="https://hub.docker.com" target="_blank">Docker Hub</a>.</p> <blockquote> <p><strong>Note</strong>: The response keys have changed from API v1.6 to reflect the JSON sent by the registry server to the docker daemon’s request.</p> </blockquote> <p><strong>Example request</strong>:</p> <pre>    GET /images/search?term=sshd HTTP/1.1
</pre> <p><strong>Example response</strong>:</p> <pre>    HTTP/1.1 200 OK
    Content-Type: application/json

    [
            {
                "description": "",
                "is_official": false,
                "is_automated": false,
                "name": "wma55/u1210sshd",
                "star_count": 0
            },
            {
                "description": "",
                "is_official": false,
                "is_automated": false,
                "name": "jdswinbank/sshd",
                "star_count": 0
            },
            {
                "description": "",
                "is_official": false,
                "is_automated": false,
                "name": "vgauthier/sshd",
                "star_count": 0
            }
    ...
    ]
</pre> <p>Query Parameters:</p> <ul> <li>
<strong>term</strong> – term to search</li> </ul> <p>Status Codes:</p> <ul> <li>
<strong>200</strong> – no error</li> <li>
<strong>500</strong> – server error</li> </ul> <h2 id="2-3-misc">2.3 Misc</h2> <h3 id="build-an-image-from-dockerfile-via-stdin">Build an image from Dockerfile via stdin</h3> <p><code>POST /build</code></p> <p>Build an image from Dockerfile via stdin</p> <p><strong>Example request</strong>:</p> <pre>    POST /build HTTP/1.1

    {{ TAR STREAM }}
</pre> <p><strong>Example response</strong>:</p> <pre>    HTTP/1.1 200 OK
    Content-Type: application/json

    {"stream": "Step 1..."}
    {"stream": "..."}
    {"error": "Error...", "errorDetail": {"code": 123, "message": "Error..."}}

The stream must be a tar archive compressed with one of the
following algorithms: identity (no compression), gzip, bzip2, xz.

The archive must include a file called `Dockerfile`
at its root. It may include any number of other files,
which will be accessible in the build context (See the [*ADD build
command*](../../reference/builder.md#dockerbuilder)).
</pre> <p>Query Parameters:</p> <ul> <li>
<strong>t</strong> – repository name (and optionally a tag) to be applied to the resulting image in case of success</li> <li>
<strong>remote</strong> – git or HTTP/HTTPS URI build source</li> <li>
<strong>q</strong> – suppress verbose build output</li> <li>
<strong>nocache</strong> – do not use the cache when building the image</li> <li>
<strong>rm</strong> - remove intermediate containers after a successful build (default behavior)</li> <li>
<p><strong>forcerm</strong> - always remove intermediate containers (includes rm)</p> <p>Request Headers:</p>
</li> <li><p><strong>Content-type</strong> – should be set to <code>"application/tar"</code>.</p></li> <li><p><strong>X-Registry-Config</strong> – base64-encoded ConfigFile object</p></li> </ul> <p>Status Codes:</p> <ul> <li>
<strong>200</strong> – no error</li> <li>
<strong>500</strong> – server error</li> </ul> <h3 id="check-auth-configuration">Check auth configuration</h3> <p><code>POST /auth</code></p> <p>Get the default username and email</p> <p><strong>Example request</strong>:</p> <pre>    POST /auth HTTP/1.1
    Content-Type: application/json

    {
         "username":" hannibal",
         "password: "xxxx",
         "email": "hannibal@a-team.com",
         "serveraddress": "https://index.docker.io/v1/"
    }
</pre> <p><strong>Example response</strong>:</p> <pre>    HTTP/1.1 200 OK
</pre> <p>Status Codes:</p> <ul> <li>
<strong>200</strong> – no error</li> <li>
<strong>204</strong> – no error</li> <li>
<strong>500</strong> – server error</li> </ul> <h3 id="display-system-wide-information">Display system-wide information</h3> <p><code>GET /info</code></p> <p>Display system-wide information</p> <p><strong>Example request</strong>:</p> <pre>    GET /info HTTP/1.1
</pre> <p><strong>Example response</strong>:</p> <pre>    HTTP/1.1 200 OK
    Content-Type: application/json

    {
         "Containers": 11,
         "Images": 16,
         "Driver": "btrfs",
         "ExecutionDriver": "native-0.1",
         "KernelVersion": "3.12.0-1-amd64"
         "Debug": false,
         "NFd": 11,
         "NGoroutines": 21,
         "NEventsListener": 0,
         "InitPath": "/usr/bin/docker",
         "IndexServerAddress": ["https://index.docker.io/v1/"],
         "MemoryLimit": true,
         "SwapLimit": false,
         "IPv4Forwarding": true
    }
</pre> <p>Status Codes:</p> <ul> <li>
<strong>200</strong> – no error</li> <li>
<strong>500</strong> – server error</li> </ul> <h3 id="show-the-docker-version-information">Show the docker version information</h3> <p><code>GET /version</code></p> <p>Show the docker version information</p> <p><strong>Example request</strong>:</p> <pre>    GET /version HTTP/1.1
</pre> <p><strong>Example response</strong>:</p> <pre>    HTTP/1.1 200 OK
    Content-Type: application/json

    {
         "ApiVersion": "1.12",
         "Version": "0.2.2",
         "GitCommit": "5a2a5cc+CHANGES",
         "GoVersion": "go1.0.3"
    }
</pre> <p>Status Codes:</p> <ul> <li>
<strong>200</strong> – no error</li> <li>
<strong>500</strong> – server error</li> </ul> <h3 id="ping-the-docker-server">Ping the docker server</h3> <p><code>GET /_ping</code></p> <p>Ping the docker server</p> <p><strong>Example request</strong>:</p> <pre>    GET /_ping HTTP/1.1
</pre> <p><strong>Example response</strong>:</p> <pre>    HTTP/1.1 200 OK
    Content-Type: text/plain

    OK
</pre> <p>Status Codes:</p> <ul> <li>
<strong>200</strong> - no error</li> <li>
<strong>500</strong> - server error</li> </ul> <h3 id="create-a-new-image-from-a-container-s-changes">Create a new image from a container’s changes</h3> <p><code>POST /commit</code></p> <p>Create a new image from a container’s changes</p> <p><strong>Example request</strong>:</p> <pre>    POST /commit?container=44c004db4b17&amp;comment=message&amp;repo=myrepo HTTP/1.1
    Content-Type: application/json

    {
         "Hostname": "",
         "Domainname": "",
         "User": "",
         "Memory": 0,
         "MemorySwap": 0,
         "CpuShares": 512,
         "Cpuset": "0,1",
         "AttachStdin": false,
         "AttachStdout": true,
         "AttachStderr": true,
         "PortSpecs": null,
         "Tty": false,
         "OpenStdin": false,
         "StdinOnce": false,
         "Env": null,
         "Cmd": [
                 "date"
         ],
         "Volumes": {
                 "/tmp": {}
         },
         "WorkingDir": "",
         "NetworkDisabled": false,
         "ExposedPorts": {
                 "22/tcp": {}
         }
    }
</pre> <p><strong>Example response</strong>:</p> <pre>    HTTP/1.1 201 Created
    Content-Type: application/json

    {"Id": "596069db4bf5"}
</pre> <p>Json Parameters:</p> <ul> <li>
<strong>config</strong> - the container’s configuration</li> </ul> <p>Query Parameters:</p> <ul> <li>
<strong>container</strong> – source container</li> <li>
<strong>repo</strong> – repository</li> <li>
<strong>tag</strong> – tag</li> <li>
<strong>comment</strong> – commit message</li> <li>
<strong>author</strong> – author (e.g., “John Hannibal Smith &lt;<a href="mailto:hannibal%40a-team.com/">hannibal@a-team.com</a>&gt;“)</li> </ul> <p>Status Codes:</p> <ul> <li>
<strong>201</strong> – no error</li> <li>
<strong>404</strong> – no such container</li> <li>
<strong>500</strong> – server error</li> </ul> <h3 id="monitor-docker-s-events">Monitor Docker’s events</h3> <p><code>GET /events</code></p> <p>Get container events from docker, either in real time via streaming, or via polling (using since).</p> <p>Docker containers will report the following events:</p> <pre>create, destroy, die, export, kill, pause, restart, start, stop, unpause
</pre> <p>and Docker images will report:</p> <pre>untag, delete
</pre> <p><strong>Example request</strong>:</p> <pre>    GET /events?since=1374067924
</pre> <p><strong>Example response</strong>:</p> <pre>    HTTP/1.1 200 OK
    Content-Type: application/json

    {"status": "create", "id": "dfdf82bd3881","from": "ubuntu:latest", "time":1374067924}
    {"status": "start", "id": "dfdf82bd3881","from": "ubuntu:latest", "time":1374067924}
    {"status": "stop", "id": "dfdf82bd3881","from": "ubuntu:latest", "time":1374067966}
    {"status": "destroy", "id": "dfdf82bd3881","from": "ubuntu:latest", "time":1374067970}
</pre> <p>Query Parameters:</p> <ul> <li>
<strong>since</strong> – timestamp used for polling</li> <li>
<strong>until</strong> – timestamp used for polling</li> </ul> <p>Status Codes:</p> <ul> <li>
<strong>200</strong> – no error</li> <li>
<strong>500</strong> – server error</li> </ul> <h3 id="get-a-tarball-containing-all-images-and-tags-in-a-repository">Get a tarball containing all images and tags in a repository</h3> <p><code>GET /images/(name)/get</code></p> <p>Get a tarball containing all images and metadata for the repository specified by <code>name</code>.</p> <p>See the <a href="#image-tarball-format">image tarball format</a> for more details.</p> <p><strong>Example request</strong></p> <pre>    GET /images/ubuntu/get
</pre> <p><strong>Example response</strong>:</p> <pre>    HTTP/1.1 200 OK
    Content-Type: application/x-tar

    Binary data stream
</pre> <p>Status Codes:</p> <ul> <li>
<strong>200</strong> – no error</li> <li>
<strong>500</strong> – server error</li> </ul> <h3 id="load-a-tarball-with-a-set-of-images-and-tags-into-docker">Load a tarball with a set of images and tags into docker</h3> <p><code>POST /images/load</code></p> <p>Load a set of images and tags into the docker repository. See the <a href="#image-tarball-format">image tarball format</a> for more details.</p> <p><strong>Example request</strong></p> <pre>    POST /images/load

    Tarball in body
</pre> <p><strong>Example response</strong>:</p> <pre>    HTTP/1.1 200 OK
</pre> <p>Status Codes:</p> <ul> <li>
<strong>200</strong> – no error</li> <li>
<strong>500</strong> – server error</li> </ul> <h3 id="image-tarball-format">Image tarball format</h3> <p>An image tarball contains one directory per image layer (named using its long ID), each containing three files:</p> <ol> <li>
<code>VERSION</code>: currently <code>1.0</code> - the file format version</li> <li>
<code>json</code>: detailed layer information, similar to <code>docker inspect layer_id</code>
</li> <li>
<code>layer.tar</code>: A tarfile containing the filesystem changes in this layer</li> </ol> <p>The <code>layer.tar</code> file will contain <code>aufs</code> style <code>.wh..wh.aufs</code> files and directories for storing attribute changes and deletions.</p> <p>If the tarball defines a repository, there will also be a <code>repositories</code> file at the root that contains a list of repository and tag names mapped to layer IDs.</p> <pre>{"hello-world":
    {"latest": "565a9d68a73f6706862bfe8409a7f659776d4d60a8d096eb4a3cbce6999cc2a1"}
}
</pre> <h1 id="3-going-further">3. Going further</h1> <h2 id="3-1-inside-docker-run">3.1 Inside <code>docker run</code>
</h2> <p>As an example, the <code>docker run</code> command line makes the following API calls:</p> <ul> <li><p>Create the container</p></li> <li>
<p>If the status code is 404, it means the image doesn’t exist:</p> <ul> <li>Try to pull it</li> <li>Then retry to create the container</li> </ul>
</li> <li><p>Start the container</p></li> <li>
<p>If you are not in detached mode:</p> <ul> <li>Attach to the container, using logs=1 (to have stdout and stderr from the container’s start) and stream=1</li> </ul>
</li> <li>
<p>If in detached mode or only stdin is attached:</p> <ul> <li>Display the container’s id</li> </ul>
</li> </ul> <h2 id="3-2-hijacking">3.2 Hijacking</h2> <p>In this version of the API, /attach, uses hijacking to transport stdin, stdout and stderr on the same socket. This might change in the future.</p> <h2 id="3-3-cors-requests">3.3 CORS Requests</h2> <p>To enable cross origin requests to the remote api add the flag “--api-enable-cors” when running docker in daemon mode.</p> <pre>$ docker -d -H="192.168.1.9:2375" --api-enable-cors
</pre>
<div class="_attribution">
  <p class="_attribution-p">
    © 2013–2016 Docker, Inc.<br>Licensed under the Apache License, Version 2.0.<br>Docker and the Docker logo are trademarks or registered trademarks of Docker, Inc. in the United States and/or other countries.<br>Docker, Inc. and other parties may also have trademark rights in other terms used herein.<br>
    <a href="https://docs.docker.com/v1.10/engine/reference/api/docker_remote_api_v1.14/" class="_attribution-link" target="_blank">https://docs.docker.com/v1.10/engine/reference/api/docker_remote_api_v1.14/</a>
  </p>
</div>

			</div>
		</div>
	</section>

	</div>
</body>
</html>
