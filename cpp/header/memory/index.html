
<!DOCTYPE HTML>

<html lang="en">

<head>
  <meta charset="utf-8">
  <title>Memory - C++ - W3cubDocs</title>
  
  <meta name="description" content=" This header is part of the dynamic memory management library. ">
  <meta name="keywords" content="standard, library, header, memory, -, c++, cpp">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="http://docs.w3cub.com/cpp/header/memory/">
  <link href="/favicon.png" rel="icon">
  <link type="text/css" rel="stylesheet" href="/assets/application-50364fff564ce3b6327021805f3f00e2957b441cf27f576a7dd4ff63bbc47047.css">
  <script type="text/javascript" src="/assets/application-db64bfd54ceb42be11af7995804cf4902548419ceb79d509b0b7d62c22d98e6f.js"></script>
  <script src="/json/cpp.js"></script>
  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-71174418-1']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>


</head>

<body>
	<div class="_app">
	<header class="_header">
  
  <form class="_search">
    <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
    <a class="_search-clear"></a>
    <div class="_search-tag"></div>
  </form>
  
  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/cpp/" class="_nav-link" title="" style="margin-left:0;">C++</a></span>
  
  <nav class="_nav">
    <a href="/app/" class="_nav-link ">App</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		<div class="_list">
			
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<div class="_page _c">
				
<h1 id="firstHeading" class="firstHeading">Standard library header &lt;memory&gt;</h1>            <p>This header is part of the <a href="../../memory/" title="cpp/memory">dynamic memory management</a> library.</p>
<h3 id="Classes"> Classes</h3> <table class="t-dsc-begin"> <tr> <td colspan="2"> <h5 id="Smart_pointers_categories">  Smart pointers categories </h5> </td>
</tr> <tr class="t-dsc"> <td> <div class="t-dsc-member-div">
<div><a href="../../memory/unique_ptr/" title="cpp/memory/unique ptr"> <span class="t-lines"><span>unique_ptr</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx11">(C++11)</span></span></span></div>
</div> </td> <td> smart pointer with unique object ownership semantics <br> <span class="t-mark">(class template)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div class="t-dsc-member-div">
<div><a href="../../memory/shared_ptr/" title="cpp/memory/shared ptr"> <span class="t-lines"><span>shared_ptr</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx11">(C++11)</span></span></span></div>
</div> </td> <td> smart pointer with shared object ownership semantics <br> <span class="t-mark">(class template)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div class="t-dsc-member-div">
<div><a href="../../memory/weak_ptr/" title="cpp/memory/weak ptr"> <span class="t-lines"><span>weak_ptr</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx11">(C++11)</span></span></span></div>
</div> </td> <td> weak reference to an object managed by <code><a href="../../memory/shared_ptr/" title="cpp/memory/shared ptr">std::shared_ptr</a></code> <br> <span class="t-mark">(class template)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div class="t-dsc-member-div">
<div><a href="../../memory/auto_ptr/" title="cpp/memory/auto ptr"> <span class="t-lines"><span>auto_ptr</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-until-cxx17">(until C++17)</span></span></span></div>
</div> </td> <td> smart pointer with strict object ownership semantics <br> <span class="t-mark">(class template)</span>  </td>
</tr> <tr> <td colspan="2"> <h5 id="Smart_pointers_helper_classes">  Smart pointers helper classes </h5> </td>
</tr> <tr class="t-dsc"> <td> <div class="t-dsc-member-div">
<div><a href="../../memory/owner_less/" title="cpp/memory/owner less"> <span class="t-lines"><span>owner_less</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx11">(C++11)</span></span></span></div>
</div> </td> <td> provides mixed-type owner-based ordering of shared and weak pointers <br> <span class="t-mark">(class template)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div class="t-dsc-member-div">
<div><a href="../../memory/enable_shared_from_this/" title="cpp/memory/enable shared from this"> <span class="t-lines"><span>enable_shared_from_this</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx11">(C++11)</span></span></span></div>
</div> </td> <td> allows an object to create a <code>shared_ptr</code> referring to itself <br> <span class="t-mark">(class template)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div class="t-dsc-member-div">
<div><a href="../../memory/bad_weak_ptr/" title="cpp/memory/bad weak ptr"> <span class="t-lines"><span>bad_weak_ptr</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx11">(C++11)</span></span></span></div>
</div> </td> <td> exception thrown when accessing a <code>weak_ptr</code> which refers to already destroyed object <br> <span class="t-mark">(class)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div class="t-dsc-member-div">
<div><a href="../../memory/default_delete/" title="cpp/memory/default delete"> <span class="t-lines"><span>default_delete</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx11">(C++11)</span></span></span></div>
</div> </td> <td> default deleter for <code>unique_ptr</code> <br> <span class="t-mark">(class template)</span>  </td>
</tr> <tr> <td colspan="2"> <h5 id="Allocators">  Allocators </h5> </td>
</tr> <tr class="t-dsc"> <td> <div class="t-dsc-member-div"><div><a href="../../memory/allocator/" title="cpp/memory/allocator"> <span class="t-lines"><span>allocator</span></span></a></div></div> </td> <td> the default allocator <br> <span class="t-mark">(class template)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div class="t-dsc-member-div">
<div><a href="../../memory/allocator_traits/" title="cpp/memory/allocator traits"> <span class="t-lines"><span>allocator_traits</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx11">(C++11)</span></span></span></div>
</div> </td> <td> provides information about allocator types <br> <span class="t-mark">(class template)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div class="t-dsc-member-div">
<div><a href="../../memory/allocator_arg_t/" title="cpp/memory/allocator arg t"> <span class="t-lines"><span>allocator_arg_t</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx11">(C++11)</span></span></span></div>
</div> </td> <td> tag type used to select allocator-aware constructor overloads <br> <span class="t-mark">(class)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div class="t-dsc-member-div">
<div><a href="../../memory/allocator_arg/" title="cpp/memory/allocator arg"> <span class="t-lines"><span>allocator_arg</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx11">(C++11)</span></span></span></div>
</div> </td> <td> an object of type <code><a href="../../memory/allocator_arg_t/" title="cpp/memory/allocator arg t">std::allocator_arg_t</a></code> used to select allocator-aware constructors <br> <span class="t-mark">(constant)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div class="t-dsc-member-div">
<div><a href="../../memory/uses_allocator/" title="cpp/memory/uses allocator"> <span class="t-lines"><span>uses_allocator</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx11">(C++11)</span></span></span></div>
</div> </td> <td> checks if the specified type supports uses-allocator construction <br> <span class="t-mark">(class template)</span>  </td>
</tr> <tr> <td colspan="2"> <h5 id="Other">  Other </h5> </td>
</tr> <tr class="t-dsc"> <td> <div class="t-dsc-member-div">
<div><a href="../../memory/gc/pointer_safety/" title="cpp/memory/gc/pointer safety"> <span class="t-lines"><span>pointer_safety</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx11">(C++11)</span></span></span></div>
</div> </td> <td> lists pointer safety models <br> <span class="t-mark">(class)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div class="t-dsc-member-div">
<div><a href="../../memory/pointer_traits/" title="cpp/memory/pointer traits"> <span class="t-lines"><span>pointer_traits</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx11">(C++11)</span></span></span></div>
</div> </td> <td> provides information about pointer-like types <br> <span class="t-mark">(class template)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div class="t-dsc-member-div">
<div><a href="../../memory/shared_ptr/hash/" title="cpp/memory/shared ptr/hash"> <span class="t-lines"><span>std::hash<span class="t-dsc-small">&lt;std::shared_ptr&gt;</span></span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx11">(C++11)</span></span></span></div>
</div> </td> <td> hash support for <code><a href="../../memory/shared_ptr/" title="cpp/memory/shared ptr">std::shared_ptr</a></code> <br> <span class="t-mark">(class template specialization)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div class="t-dsc-member-div">
<div><a href="../../memory/unique_ptr/hash/" title="cpp/memory/unique ptr/hash"> <span class="t-lines"><span>std::hash<span class="t-dsc-small">&lt;std::unique_ptr&gt;</span></span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx11">(C++11)</span></span></span></div>
</div> </td> <td> hash support for <code><a href="../../memory/unique_ptr/" title="cpp/memory/unique ptr">std::unique_ptr</a></code> <br> <span class="t-mark">(class template specialization)</span>  </td>
</tr> <tr> <td colspan="2"> <h5 id="Forward_declaration">  Forward declaration </h5> </td>
</tr> <tr class="t-dsc-header"> <th colspan="2"> <div>Defined in header <code>&lt;functional&gt;</code> </div> </th>
</tr> <tr class="t-dsc"> <td> <div class="t-dsc-member-div">
<div><a href="../../utility/hash/" title="cpp/utility/hash"> <span class="t-lines"><span>hash</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx11">(C++11)</span></span></span></div>
</div> </td> <td> hash function object <br> <span class="t-mark">(class template)</span>  </td>
</tr> <tr> <td colspan="2"> <h3 id="Constants"> Constants</h3> </td>
</tr> <tr class="t-dsc"> <td> <div class="t-dsc-member-div">
<div><a href="../../memory/allocator_arg/" title="cpp/memory/allocator arg"> <span class="t-lines"><span>allocator_arg</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx11">(C++11)</span></span></span></div>
</div> </td> <td> an object of type <code><a href="../../memory/allocator_arg_t/" title="cpp/memory/allocator arg t">std::allocator_arg_t</a></code> used to select allocator-aware constructors <br> <span class="t-mark">(constant)</span>  </td>
</tr> </table> <h3 id="Functions"> Functions</h3> <table class="t-dsc-begin"> <tr> <td colspan="2"> <h5 id="Uninitialized_storage">  Uninitialized storage </h5> </td>
</tr> <tr class="t-dsc"> <td> <div class="t-dsc-member-div"><div><a href="../../memory/uninitialized_copy/" title="cpp/memory/uninitialized copy"> <span class="t-lines"><span>uninitialized_copy</span></span></a></div></div> </td> <td> copies a range of objects to an uninitialized area of memory <br> <span class="t-mark">(function template)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div class="t-dsc-member-div">
<div><a href="../../memory/uninitialized_copy_n/" title="cpp/memory/uninitialized copy n"> <span class="t-lines"><span>uninitialized_copy_n</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx11">(C++11)</span></span></span></div>
</div> </td> <td> copies a number of objects to an uninitialized area of memory <br> <span class="t-mark">(function template)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div class="t-dsc-member-div"><div><a href="../../memory/uninitialized_fill/" title="cpp/memory/uninitialized fill"> <span class="t-lines"><span>uninitialized_fill</span></span></a></div></div> </td> <td> copies an object to an uninitialized area of memory, defined by a range <br> <span class="t-mark">(function template)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div class="t-dsc-member-div"><div><a href="../../memory/uninitialized_fill_n/" title="cpp/memory/uninitialized fill n"> <span class="t-lines"><span>uninitialized_fill_n</span></span></a></div></div> </td> <td> copies an object to an uninitialized area of memory, defined by a start and a count <br> <span class="t-mark">(function template)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div class="t-dsc-member-div">
<div><a href="../../memory/raw_storage_iterator/" title="cpp/memory/raw storage iterator"> <span class="t-lines"><span>raw_storage_iterator</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark">(deprecated in C++17)</span></span></span></div>
</div> </td> <td> an iterator that allows standard algorithms to store results in uninitialized memory <br> <span class="t-mark">(class template)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div class="t-dsc-member-div">
<div><a href="../../memory/get_temporary_buffer/" title="cpp/memory/get temporary buffer"> <span class="t-lines"><span>get_temporary_buffer</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark">(deprecated in C++17)</span></span></span></div>
</div> </td> <td> obtains uninitialized storage <br> <span class="t-mark">(function template)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div class="t-dsc-member-div">
<div><a href="../../memory/return_temporary_buffer/" title="cpp/memory/return temporary buffer"> <span class="t-lines"><span>return_temporary_buffer</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark">(deprecated in C++17)</span></span></span></div>
</div> </td> <td> frees uninitialized storage <br> <span class="t-mark">(function template)</span>  </td>
</tr> <tr> <td colspan="2"> <h5 id="Garbage_collector_support">  Garbage collector support </h5> </td>
</tr> <tr class="t-dsc"> <td> <div class="t-dsc-member-div">
<div><a href="../../memory/gc/declare_reachable/" title="cpp/memory/gc/declare reachable"> <span class="t-lines"><span>declare_reachable</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx11">(C++11)</span></span></span></div>
</div> </td> <td> declares that an object can not be recycled <br> <span class="t-mark">(function)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div class="t-dsc-member-div">
<div><a href="../../memory/gc/undeclare_reachable/" title="cpp/memory/gc/undeclare reachable"> <span class="t-lines"><span>undeclare_reachable</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx11">(C++11)</span></span></span></div>
</div> </td> <td> declares that an object can be recycled <br> <span class="t-mark">(function template)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div class="t-dsc-member-div">
<div><a href="../../memory/gc/declare_no_pointers/" title="cpp/memory/gc/declare no pointers"> <span class="t-lines"><span>declare_no_pointers</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx11">(C++11)</span></span></span></div>
</div> </td> <td> declares that a memory area does not contain traceable pointers <br> <span class="t-mark">(function)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div class="t-dsc-member-div">
<div><a href="../../memory/gc/undeclare_no_pointers/" title="cpp/memory/gc/undeclare no pointers"> <span class="t-lines"><span>undeclare_no_pointers</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx11">(C++11)</span></span></span></div>
</div> </td> <td> cancels the effect of <code><a href="../../memory/gc/declare_no_pointers/" title="cpp/memory/gc/declare no pointers">std::declare_no_pointers</a></code> <br> <span class="t-mark">(function)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div class="t-dsc-member-div">
<div><a href="../../memory/gc/get_pointer_safety/" title="cpp/memory/gc/get pointer safety"> <span class="t-lines"><span>get_pointer_safety</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx11">(C++11)</span></span></span></div>
</div> </td> <td> returns the current pointer safety model <br> <span class="t-mark">(function)</span>  </td>
</tr> <tr> <td colspan="2"> <h5 id="Miscellaneous">  Miscellaneous </h5> </td>
</tr> <tr class="t-dsc"> <td> <div class="t-dsc-member-div">
<div><a href="../../memory/addressof/" title="cpp/memory/addressof"> <span class="t-lines"><span>addressof</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx11">(C++11)</span></span></span></div>
</div> </td> <td> obtains actual address of an object, even if the <i>&amp;</i> operator is overloaded <br> <span class="t-mark">(function template)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div class="t-dsc-member-div">
<div><a href="../../memory/align/" title="cpp/memory/align"> <span class="t-lines"><span>align</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx11">(C++11)</span></span></span></div>
</div> </td> <td> aligns a pointer in a buffer <br> <span class="t-mark">(function)</span>  </td>
</tr> <tr> <td colspan="2"> <h5 id="Smart_pointer_non-member_operations">  Smart pointer non-member operations </h5> </td>
</tr> <tr class="t-dsc"> <td> <div class="t-dsc-member-div">
<div><a href="../../memory/unique_ptr/make_unique/" title="cpp/memory/unique ptr/make unique"> <span class="t-lines"><span>make_unique</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx14">(C++14)</span></span></span></div>
</div> </td> <td> creates a unique pointer that manages a new object <br> <span class="t-mark">(function template)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div class="t-dsc-member-div"><div><a href="../../memory/shared_ptr/make_shared/" title="cpp/memory/shared ptr/make shared"> <span class="t-lines"><span>make_shared</span></span></a></div></div> </td> <td> creates a shared pointer that manages a new object <br> <span class="t-mark">(function template)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div class="t-dsc-member-div"><div><a href="../../memory/shared_ptr/allocate_shared/" title="cpp/memory/shared ptr/allocate shared"> <span class="t-lines"><span>allocate_shared</span></span></a></div></div> </td> <td> creates a shared pointer that manages a new object allocated using an allocator <br> <span class="t-mark">(function template)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div class="t-dsc-member-div">
<div><a href="../../memory/shared_ptr/pointer_cast/" title="cpp/memory/shared ptr/pointer cast"> <span class="t-lines"><span>static_pointer_cast</span><span>dynamic_pointer_cast</span><span>const_pointer_cast</span><span>reinterpret_pointer_cast</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx17">(C++17)</span></span></span></div>
</div> </td> <td> applies <a href="../../language/static_cast/" title="cpp/language/static cast"><code>static_cast</code></a>, <a href="../../language/dynamic_cast/" title="cpp/language/dynamic cast"><code>dynamic_cast</code></a>, <a href="../../language/const_cast/" title="cpp/language/const cast"><code>const_cast</code></a>, or <a href="../../language/reinterpret_cast/" title="cpp/language/reinterpret cast"><code>reinterpret_cast</code></a> to the stored pointer <br> <span class="t-mark">(function template)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div class="t-dsc-member-div"><div><a href="../../memory/shared_ptr/get_deleter/" title="cpp/memory/shared ptr/get deleter"> <span class="t-lines"><span>get_deleter</span></span></a></div></div> </td> <td> returns the deleter of specified type, if owned <br> <span class="t-mark">(function template)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div class="t-dsc-member-div"><div><a href="../../memory/shared_ptr/operator_cmp/" title="cpp/memory/shared ptr/operator cmp"> <span class="t-lines"><span>operator==</span><span>operator!=</span><span>operator&lt;</span><span>operator&lt;=</span><span>operator&gt;</span><span>operator&gt;=</span></span></a></div></div> </td> <td> compares with another <code>shared_ptr</code> or with <code>nullptr</code> <br> <span class="t-mark">(function template)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div class="t-dsc-member-div"><div><a href="../../memory/shared_ptr/operator_ltlt/" title="cpp/memory/shared ptr/operator ltlt"> <span class="t-lines"><span>operator&lt;&lt;</span></span></a></div></div> </td> <td> outputs the value of the stored pointer to an output stream <br> <span class="t-mark">(function template)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div class="t-dsc-member-div">
<div><a href="../../memory/shared_ptr/swap2/" title="cpp/memory/shared ptr/swap2"> <span class="t-lines"><span>std::swap<span class="t-dsc-small">(std::shared_ptr)</span></span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx11">(C++11)</span></span></span></div>
</div> </td> <td> specializes the <code><a href="../../algorithm/swap/" title="cpp/algorithm/swap">std::swap</a></code> algorithm <br> <span class="t-mark">(function template)</span>  </td>
</tr> </table> <table class="t-dsc-begin"> <tr class="t-dsc"> <td> <div class="t-dsc-member-div"><div><a href="../../memory/shared_ptr/atomic/" title="cpp/memory/shared ptr/atomic"> <span class="t-lines"><span>std::atomic_is_lock_free<span class="t-dsc-small">(std::shared_ptr)</span></span><span>std::atomic_load<span class="t-dsc-small">(std::shared_ptr)</span></span><span>std::atomic_load_explicit<span class="t-dsc-small">(std::shared_ptr)</span></span><span>std::atomic_store<span class="t-dsc-small">(std::shared_ptr)</span></span><span>std::atomic_store_explicit<span class="t-dsc-small">(std::shared_ptr)</span></span><span>std::atomic_exchange<span class="t-dsc-small">(std::shared_ptr)</span></span><span>std::atomic_exchange_explicit<span class="t-dsc-small">(std::shared_ptr)</span></span><span>std::atomic_compare_exchange_weak<span class="t-dsc-small">(std::shared_ptr)</span></span><span>std::atomic_compare_exchange_strong<span class="t-dsc-small">(std::shared_ptr)</span></span><span>std::atomic_compare_exchange_weak_explicit<span class="t-dsc-small">(std::shared_ptr)</span></span><span>std::atomic_compare_exchange_strong_explicit<span class="t-dsc-small">(std::shared_ptr)</span></span></span></a></div></div> </td> <td> specializes atomic operations for <code><a href="../../memory/shared_ptr/" title="cpp/memory/shared ptr">std::shared_ptr</a></code> <br> <span class="t-mark">(function template)</span>  </td>
</tr> </table> <table class="t-dsc-begin"> <tr class="t-dsc"> <td> <div class="t-dsc-member-div"><div><a href="../../memory/unique_ptr/operator_cmp/" title="cpp/memory/unique ptr/operator cmp"> <span class="t-lines"><span>operator==</span><span>operator!=</span><span>operator&lt;</span><span>operator&lt;=</span><span>operator&gt;</span><span>operator&gt;=</span></span></a></div></div> </td> <td> compares to another <code>unique_ptr</code> or with <code>nullptr</code> <br> <span class="t-mark">(function template)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div class="t-dsc-member-div">
<div><a href="../../memory/unique_ptr/swap2/" title="cpp/memory/unique ptr/swap2"> <span class="t-lines"><span>std::swap<span class="t-dsc-small">(std::unique_ptr)</span></span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx11">(C++11)</span></span></span></div>
</div> </td> <td> specializes the <code><a href="../../algorithm/swap/" title="cpp/algorithm/swap">std::swap</a></code> algorithm <br> <span class="t-mark">(function template)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div class="t-dsc-member-div">
<div><a href="../../memory/weak_ptr/swap2/" title="cpp/memory/weak ptr/swap2"> <span class="t-lines"><span>std::swap<span class="t-dsc-small">(std::weak_ptr)</span></span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx11">(C++11)</span></span></span></div>
</div> </td> <td> specializes the <code><a href="../../algorithm/swap/" title="cpp/algorithm/swap">std::swap</a></code> algorithm <br> <span class="t-mark">(function template)</span>  </td>
</tr> <tr> <td colspan="2"> <h5 id="Allocator_non-member_operations">  Allocator non-member operations </h5> </td>
</tr> <tr class="t-dsc"> <td> <div class="t-dsc-member-div"><div><a href="../../memory/allocator/operator_cmp/" title="cpp/memory/allocator/operator cmp"> <span class="t-lines"><span>operator==</span><span>operator!=</span></span></a></div></div> </td> <td> compares two allocator instances <br> <span class="t-mark">(public member function of <code>std::allocator</code>)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div class="t-dsc-member-div"><div><a href="../../memory/scoped_allocator_adaptor/operator_cmp/" title="cpp/memory/scoped allocator adaptor/operator cmp"> <span class="t-lines"><span>operator==</span><span>operator!=</span></span></a></div></div> </td> <td> compares two scoped_allocator_adaptor instances <br> <span class="t-mark">(public member function of <code>std::scoped_allocator_adaptor</code>)</span>  </td>
</tr> </table> <h3 id="Synopsis"> Synopsis</h3> <div class="cpp source-cpp"><pre data-language="cpp">namespace std {
    // pointer traits
    template &lt;class Ptr&gt; struct pointer_traits;
    template &lt;class T&gt; struct pointer_traits&lt;T*&gt;;
 
    // pointer safety
    enum class pointer_safety { relaxed, preferred, strict };
    void declare_reachable(void *p);
    template &lt;class T&gt; T *undeclare_reachable(T *p);
    void declare_no_pointers(char *p, size_t n);
    void undeclare_no_pointers(char *p, size_t n);
    pointer_safety get_pointer_safety() noexcept;
 
    // pointer alignment function
    void *align(std::size_t alignment, std::size_t size,
                void *&amp;ptr, std::size_t&amp; space);
 
    // allocator argument tag
    struct allocator_arg_t { };
    constexpr allocator_arg_t allocator_arg = allocator_arg_t();
 
    // uses_allocator
    template &lt;class T, class Alloc&gt; struct uses_allocator;
 
    // allocator traits
    template &lt;class Alloc&gt; struct allocator_traits;
 
    // the default allocator:
    template &lt;class T&gt; class allocator;
    template &lt;&gt; class allocator&lt;void&gt;;
    template &lt;class T, class U&gt;
        bool operator==(const allocator&lt;T&gt;&amp;, const allocator&lt;U&gt;&amp;) noexcept;
    template &lt;class T, class U&gt;
        bool operator!=(const allocator&lt;T&gt;&amp;, const allocator&lt;U&gt;&amp;) noexcept;
 
    // raw storage iterator:
    template &lt;class OutputIterator, class T&gt; class raw_storage_iterator;
 
    // temporary buffers:
    template &lt;class T&gt;
        pair&lt;T*,ptrdiff_t&gt; get_temporary_buffer(ptrdiff_t n) noexcept;
    template &lt;class T&gt;
        void return_temporary_buffer(T* p);
 
    // specialized algorithms:
    template &lt;class T&gt; T* addressof(T&amp; r) noexcept;
    template &lt;class InputIterator, class ForwardIterator&gt;
        ForwardIterator uninitialized_copy(InputIterator first, InputIterator last,
                                           ForwardIterator result);
    template &lt;class InputIterator, class Size, class ForwardIterator&gt;
        ForwardIterator uninitialized_copy_n(InputIterator first, Size n,
                                             ForwardIterator result);
    template &lt;class ForwardIterator, class T&gt;
        void uninitialized_fill(ForwardIterator first, ForwardIterator last,
                                const T&amp; x);
    template &lt;class ForwardIterator, class Size, class T&gt;
        ForwardIterator uninitialized_fill_n(ForwardIterator first, Size n, const T&amp; x);
    // class template unique_ptr:
    template &lt;class T&gt; class default_delete;
    template &lt;class T&gt; class default_delete&lt;T[]&gt;;
    template &lt;class T, class D = default_delete&lt;T&gt;&gt; class unique_ptr;
    template &lt;class T, class D&gt; class unique_ptr&lt;T[], D&gt;;
 
    template &lt;class T1, class D1, class T2, class D2&gt;
        bool operator==(const unique_ptr&lt;T1, D1&gt;&amp; x, const unique_ptr&lt;T2, D2&gt;&amp; y);
    template &lt;class T1, class D1, class T2, class D2&gt;
        bool operator!=(const unique_ptr&lt;T1, D1&gt;&amp; x, const unique_ptr&lt;T2, D2&gt;&amp; y);
    template &lt;class T1, class D1, class T2, class D2&gt;
        bool operator&lt;(const unique_ptr&lt;T1, D1&gt;&amp; x, const unique_ptr&lt;T2, D2&gt;&amp; y);
    template &lt;class T1, class D1, class T2, class D2&gt;
        bool operator&lt;=(const unique_ptr&lt;T1, D1&gt;&amp; x, const unique_ptr&lt;T2, D2&gt;&amp; y);
    template &lt;class T1, class D1, class T2, class D2&gt;
        bool operator&gt;(const unique_ptr&lt;T1, D1&gt;&amp; x, const unique_ptr&lt;T2, D2&gt;&amp; y);
    template &lt;class T1, class D1, class T2, class D2&gt;
        bool operator&gt;=(const unique_ptr&lt;T1, D1&gt;&amp; x, const unique_ptr&lt;T2, D2&gt;&amp; y);
 
    template &lt;class T, class D&gt;
        bool operator==(const unique_ptr&lt;T, D&gt;&amp; x, nullptr_t) noexcept;
    template &lt;class T, class D&gt;
        bool operator==(nullptr_t, const unique_ptr&lt;T, D&gt;&amp; y) noexcept;
    template &lt;class T, class D&gt;
        bool operator!=(const unique_ptr&lt;T, D&gt;&amp; x, nullptr_t) noexcept;
    template &lt;class T, class D&gt;
        bool operator!=(nullptr_t, const unique_ptr&lt;T, D&gt;&amp; y) noexcept;
 
    template &lt;class T, class D&gt;
        bool operator&lt;(const unique_ptr&lt;T, D&gt;&amp; x, nullptr_t);
    template &lt;class T, class D&gt;
        bool operator&lt;(nullptr_t, const unique_ptr&lt;T, D&gt;&amp; y);
    template &lt;class T, class D&gt;
        bool operator&lt;=(const unique_ptr&lt;T, D&gt;&amp; x, nullptr_t);
    template &lt;class T, class D&gt;
        bool operator&lt;=(nullptr_t, const unique_ptr&lt;T, D&gt;&amp; y);
    template &lt;class T, class D&gt;
        bool operator&gt;(const unique_ptr&lt;T, D&gt;&amp; x, nullptr_t);
    template &lt;class T, class D&gt;
        bool operator&gt;(nullptr_t, const unique_ptr&lt;T, D&gt;&amp; y);
    template &lt;class T, class D&gt;
        bool operator&gt;=(const unique_ptr&lt;T, D&gt;&amp; x, nullptr_t);
    template &lt;class T, class D&gt;
        bool operator&gt;=(nullptr_t, const unique_ptr&lt;T, D&gt;&amp; y);
 
    // class bad_weak_ptr:
    class bad_weak_ptr;
 
    // class template shared_ptr:
    template&lt;class T&gt; class shared_ptr;
 
    // shared_ptr comparisons:
    template&lt;class T, class U&gt;
        bool operator==(shared_ptr&lt;T&gt; const&amp; a, shared_ptr&lt;U&gt; const&amp; b) noexcept;
    template&lt;class T, class U&gt;
        bool operator!=(shared_ptr&lt;T&gt; const&amp; a, shared_ptr&lt;U&gt; const&amp; b) noexcept;
    template&lt;class T, class U&gt;
        bool operator&lt;(shared_ptr&lt;T&gt; const&amp; a, shared_ptr&lt;U&gt; const&amp; b) noexcept;
    template&lt;class T, class U&gt;
        bool operator&gt;(shared_ptr&lt;T&gt; const&amp; a, shared_ptr&lt;U&gt; const&amp; b) noexcept;
    template&lt;class T, class U&gt;
        bool operator&lt;=(shared_ptr&lt;T&gt; const&amp; a, shared_ptr&lt;U&gt; const&amp; b) noexcept;
    template&lt;class T, class U&gt;
        bool operator&gt;=(shared_ptr&lt;T&gt; const&amp; a, shared_ptr&lt;U&gt; const&amp; b) noexcept;
 
    template &lt;class T&gt;
        bool operator==(const shared_ptr&lt;T&gt;&amp; x, nullptr_t) noexcept;
    template &lt;class T&gt;
        bool operator==(nullptr_t, const shared_ptr&lt;T&gt;&amp; y) noexcept;
    template &lt;class T&gt;
        bool operator!=(const shared_ptr&lt;T&gt;&amp; x, nullptr_t) noexcept;
    template &lt;class T&gt;
        bool operator!=(nullptr_t, const shared_ptr&lt;T&gt;&amp; y) noexcept;
    template &lt;class T&gt;
        bool operator&lt;(const shared_ptr&lt;T&gt;&amp; x, nullptr_t) noexcept;
    template &lt;class T&gt;
        bool operator&lt;(nullptr_t, const shared_ptr&lt;T&gt;&amp; y) noexcept;
    template &lt;class T&gt;
        bool operator&lt;=(const shared_ptr&lt;T&gt;&amp; x, nullptr_t) noexcept;
    template &lt;class T&gt;
        bool operator&lt;=(nullptr_t, const shared_ptr&lt;T&gt;&amp; y) noexcept;
    template &lt;class T&gt;
        bool operator&gt;(const shared_ptr&lt;T&gt;&amp; x, nullptr_t) noexcept;
    template &lt;class T&gt;
    bool operator&gt;(nullptr_t, const shared_ptr&lt;T&gt;&amp; y) noexcept;
    template &lt;class T&gt;
        bool operator&gt;=(const shared_ptr&lt;T&gt;&amp; x, nullptr_t) noexcept;
    template &lt;class T&gt;
        bool operator&gt;=(nullptr_t, const shared_ptr&lt;T&gt;&amp; y) noexcept;
 
    // shared_ptr specialized algorithms:
    template&lt;class T&gt; void swap(shared_ptr&lt;T&gt;&amp; a, shared_ptr&lt;T&gt;&amp; b) noexcept;
 
    // shared_ptr casts:
    template&lt;class T, class U&gt;
        shared_ptr&lt;T&gt; static_pointer_cast(shared_ptr&lt;U&gt; const&amp; r) noexcept;
    template&lt;class T, class U&gt;
        shared_ptr&lt;T&gt; dynamic_pointer_cast(shared_ptr&lt;U&gt; const&amp; r) noexcept;
    template&lt;class T, class U&gt;
        shared_ptr&lt;T&gt; const_pointer_cast(shared_ptr&lt;U&gt; const&amp; r) noexcept;
 
    // shared_ptr get_deleter:
    template&lt;class D, class T&gt; D* get_deleter(shared_ptr&lt;T&gt; const&amp; p) noexcept;
 
    // shared_ptr I/O:
    template&lt;class E, class T, class Y&gt;
        basic_ostream&lt;E, T&gt;&amp; operator&lt;&lt; (basic_ostream&lt;E, T&gt;&amp; os, shared_ptr&lt;Y&gt; const&amp; p);
 
    // class template weak_ptr:
    template&lt;class T&gt; class weak_ptr;
 
    // weak_ptr specialized algorithms:
    template&lt;class T&gt; void swap(weak_ptr&lt;T&gt;&amp; a, weak_ptr&lt;T&gt;&amp; b) noexcept;
 
    // class template owner_less:
    template&lt;class T&gt; class owner_less;
 
    // class template enable_shared_from_this:
    template&lt;class T&gt; class enable_shared_from_this;
 
    // shared_ptr atomic access:
    template&lt;class T&gt;
        bool atomic_is_lock_free(const shared_ptr&lt;T&gt;* p);
    template&lt;class T&gt;
        shared_ptr&lt;T&gt; atomic_load(const shared_ptr&lt;T&gt;* p);
    template&lt;class T&gt;
        shared_ptr&lt;T&gt; atomic_load_explicit(const shared_ptr&lt;T&gt;* p, memory_order mo);
    template&lt;class T&gt;
        void atomic_store(shared_ptr&lt;T&gt;* p, shared_ptr&lt;T&gt; r);
    template&lt;class T&gt;
        void atomic_store_explicit(shared_ptr&lt;T&gt;* p, shared_ptr&lt;T&gt; r, memory_order mo);
    template&lt;class T&gt;
        shared_ptr&lt;T&gt; atomic_exchange(shared_ptr&lt;T&gt;* p, shared_ptr&lt;T&gt; r);
    template&lt;class T&gt;
        shared_ptr&lt;T&gt; atomic_exchange_explicit(shared_ptr&lt;T&gt;* p, shared_ptr&lt;T&gt; r,
                                                memory_order mo);
    template&lt;class T&gt;
        bool atomic_compare_exchange_weak(
            shared_ptr&lt;T&gt;* p, shared_ptr&lt;T&gt;* v, shared_ptr&lt;T&gt;  w);
    template&lt;class T&gt;
        bool atomic_compare_exchange_strong(
            shared_ptr&lt;T&gt;* p, shared_ptr&lt;T&gt;* v, shared_ptr&lt;T&gt;  w);
    template&lt;class T&gt;
        bool atomic_compare_exchange_weak_explicit(
            shared_ptr&lt;T&gt;* p, shared_ptr&lt;T&gt;* v, shared_ptr&lt;T&gt; w,
            memory_order success, memory_order failure);
    template&lt;class T&gt;
        bool atomic_compare_exchange_strong_explicit(
            shared_ptr&lt;T&gt;* p, shared_ptr&lt;T&gt;* v, shared_ptr&lt;T&gt; w,
            memory_order success, memory_order failure);
 
    //  hash support
    template &lt;class T&gt; struct hash;
    template &lt;class T, class D&gt; struct hash&lt;unique_ptr&lt;T, D&gt; &gt;;
    template &lt;class T&gt; struct hash&lt;shared_ptr&lt;T&gt; &gt;;
 
    // auto_ptr (deprecated)
    template &lt;class X&gt; class auto_ptr;
}</pre></div> <h4 id="std::pointer_traits"> <code><a href="../../memory/pointer_traits/"><span class="kw710">std::<span class="me2">pointer_traits</span></span></a></code>
</h4> <div class="cpp source-cpp"><pre data-language="cpp">namespace std {
    template &lt;class Ptr&gt; struct pointer_traits {
        typedef Ptr         pointer;
        typedef /*depends*/ element_type;
        typedef /*depends*/ difference_type;
 
        template &lt;class U&gt; using rebind = /*depends*/;
 
        static pointer pointer_to(element_type&amp; r);
    };
    template &lt;class T&gt; struct pointer_traits&lt;T*&gt; {
        typedef T*          pointer;
        typedef T           element_type;
        typedef ptrdiff_t   difference_type;
 
        template &lt;class U&gt; using rebind = U*;
 
        static pointer pointer_to(element_type&amp; r) noexcept;
    };
}</pre></div> <h4 id="std::allocator_traits"> <code><a href="../../memory/allocator_traits/"><span class="kw674">std::<span class="me2">allocator_traits</span></span></a></code>
</h4> <div class="cpp source-cpp"><pre data-language="cpp">namespace std {
    template &lt;class Alloc&gt; struct allocator_traits {
        typedef Alloc allocator_type;
 
        typedef typename Alloc::value_type value_type;
 
        typedef /*depends*/ pointer;
        typedef /*depends*/ const_pointer;
        typedef /*depends*/ void_pointer;
        typedef /*depends*/ const_void_pointer;
 
        typedef /*depends*/ difference_type;
        typedef /*depends*/ size_type;
 
        typedef /*depends*/ propagate_on_container_copy_assignment;
        typedef /*depends*/ propagate_on_container_move_assignment;
        typedef /*depends*/ propagate_on_container_swap;
        typedef /*depends*/ is_always_equal;
 
        template &lt;class T&gt; using rebind_alloc = /*depends*/ ;
        template &lt;class T&gt; using rebind_traits = allocator_traits&lt;rebind_alloc&lt;T&gt; &gt;;
 
        static pointer allocate(Alloc&amp; a, size_type n);
        static pointer allocate(Alloc&amp; a, size_type n, const_void_pointer hint);
 
        static void deallocate(Alloc&amp; a, pointer p, size_type n);
 
        template &lt;class T, class... Args&gt;
            static void construct(Alloc&amp; a, T* p, Args&amp;&amp;... args);
 
        template &lt;class T&gt;
            static void destroy(Alloc&amp; a, T* p);
 
        static size_type max_size(const Alloc&amp; a) noexcept;
 
        static Alloc select_on_container_copy_construction(const Alloc&amp; rhs);
    };
}</pre></div> <h4 id="std::allocator"> <code><a href="../../memory/allocator/"><span class="kw673">std::<span class="me2">allocator</span></span></a></code>
</h4> <div class="cpp source-cpp"><pre data-language="cpp">namespace std {
    template &lt;class T&gt; class allocator;
    // specialize for void:
    template &lt;&gt; class allocator&lt;void&gt; {
    public:
        typedef void*           pointer;
        typedef const void*     const_pointer;
        // reference-to-void members are impossible.
        typedef void            value_type;
        template &lt;class U&gt; struct rebind { typedef allocator&lt;U&gt; other; };
    };
    template &lt;class T&gt; class allocator {
    public:
        typedef size_t          size_type;
        typedef ptrdiff_t       difference_type;
        typedef T*              pointer;
        typedef const T*        const_pointer;
        typedef T&amp;              reference;
        typedef const T&amp;        const_reference;
        typedef T               value_type;
        template &lt;class U&gt; struct rebind { typedef allocator&lt;U&gt; other; };
        typedef true_type       propagate_on_container_move_assignment;
        typedef true_type       is_always_equal;
 
        allocator() noexcept;
        allocator(const allocator&amp;) noexcept;
        template &lt;class U&gt; allocator(const allocator&lt;U&gt;&amp;) noexcept;
        ~allocator();
 
        pointer address(reference x) const noexcept;
        const_pointer address(const_reference x) const noexcept;
 
        pointer allocate(
            size_type, allocator&lt;void&gt;::const_pointer hint = 0);
        void deallocate(pointer p, size_type n);
        size_type max_size() const noexcept;
 
        template&lt;class U, class... Args&gt;
            void construct(U* p, Args&amp;&amp;... args);
        template &lt;class U&gt;
            void destroy(U* p);
    };
}</pre></div> <h4 id="std::raw_storage_iterator"> <code><a href="../../memory/raw_storage_iterator/"><span class="kw684">std::<span class="me2">raw_storage_iterator</span></span></a></code>
</h4> <div class="cpp source-cpp"><pre data-language="cpp">namespace std {
    template &lt;class OutputIterator, class T&gt;
    class raw_storage_iterator
        : public iterator&lt;output_iterator_tag,void,void,void,void&gt; {
    public:
        explicit raw_storage_iterator(OutputIterator x);
 
        raw_storage_iterator&amp;    operator*();
        raw_storage_iterator&amp;    operator=(const T&amp; element);
        raw_storage_iterator&amp;    operator++();
        raw_storage_iterator    operator++(int);
    };
}</pre></div> <h4 id="std::default_delete"> <code><a href="../../memory/default_delete/"><span class="kw700">std::<span class="me2">default_delete</span></span></a></code>
</h4> <div class="cpp source-cpp"><pre data-language="cpp">namespace std {
    template &lt;class T&gt; struct default_delete {
        constexpr default_delete() noexcept = default;
        template &lt;class U&gt; default_delete(const default_delete&lt;U&gt;&amp;) noexcept;
        void operator()(T*) const;
    };
 
    template &lt;class T&gt; struct default_delete&lt;T[]&gt; {
        constexpr default_delete() noexcept = default;
        template &lt;class U&gt; default_delete(const default_delete&lt;U[]&gt;&amp;) noexcept;
        template &lt;class U&gt; void operator()(U* ptr) const;
    };
}</pre></div> <h4 id="std::unique_ptr"> <code><a href="../../memory/unique_ptr/"><span class="kw687">std::<span class="me2">unique_ptr</span></span></a></code>
</h4> <div class="cpp source-cpp"><pre data-language="cpp">namespace std {
    //  unique_ptr for single objects
    template &lt;class T, class D = default_delete&lt;T&gt;&gt; class unique_ptr {
    public:
        typedef /*depends*/ pointer;
        typedef T element_type;
        typedef D deleter_type;
 
        // 20.8.1.2.1, constructors
        constexpr unique_ptr() noexcept;
        explicit unique_ptr(pointer p) noexcept;
        unique_ptr(pointer p, /*depends*/ d1) noexcept;
        unique_ptr(pointer p, /*depends*/ d2) noexcept;
        unique_ptr(unique_ptr&amp;&amp; u) noexcept;
        constexpr unique_ptr(nullptr_t) noexcept
            : unique_ptr() { }
        template &lt;class U, class E&gt;
            unique_ptr(unique_ptr&lt;U, E&gt;&amp;&amp; u) noexcept;
 
        // 20.8.1.2.2, destructor
        ~unique_ptr();
 
        // 20.8.1.2.3, assignment
        unique_ptr&amp; operator=(unique_ptr&amp;&amp; u) noexcept;
        template &lt;class U, class E&gt; unique_ptr&amp; operator=(unique_ptr&lt;U, E&gt;&amp;&amp; u) noexcept;
        unique_ptr&amp; operator=(nullptr_t) noexcept;
 
        // 20.8.1.2.4, observers
        add_lvalue_reference_t&lt;T&gt; operator*() const;
        pointer operator-&gt;() const noexcept;
        pointer get() const noexcept;
        deleter_type&amp; get_deleter() noexcept;
        const deleter_type&amp; get_deleter() const noexcept;
        explicit operator bool() const noexcept;
 
        // 20.8.1.2.5 modifiers
        pointer release() noexcept;
        void reset(pointer p = pointer()) noexcept;
        void swap(unique_ptr&amp; u) noexcept;
 
        // disable copy from lvalue
        unique_ptr(const unique_ptr&amp;) = delete;
        unique_ptr&amp; operator=(const unique_ptr&amp;) = delete;
    };
 
    // unique_ptr for array objects with a runtime length
    template &lt;class T, class D&gt; class unique_ptr&lt;T[], D&gt; {
    public:
        typedef see below pointer;
        typedef T element_type;
        typedef D deleter_type;
 
        // 20.8.1.3.1, constructors
        constexpr unique_ptr() noexcept;
        template &lt;class U&gt; explicit unique_ptr(U p) noexcept;
        template &lt;class U&gt; unique_ptr(U p, see below d) noexcept;
        template &lt;class U&gt; unique_ptr(U p, see below d) noexcept;
        unique_ptr(unique_ptr&amp;&amp; u) noexcept;
        template &lt;class U, class E&gt;
            unique_ptr(unique_ptr&lt;U, E&gt;&amp;&amp; u) noexcept;
        constexpr unique_ptr(nullptr_t) noexcept : unique_ptr() { }
 
        // destructor
        ~unique_ptr();
 
        // assignment
        unique_ptr&amp; operator=(unique_ptr&amp;&amp; u) noexcept;
        template &lt;class U, class E&gt;
            unique_ptr&amp; operator=(unique_ptr&lt;U, E&gt;&amp;&amp; u) noexcept;
        unique_ptr&amp; operator=(nullptr_t) noexcept;
 
        // 20.8.1.3.3, observers
        T&amp; operator[](size_t i) const;
        pointer get() const noexcept;
        deleter_type&amp; get_deleter() noexcept;
        const deleter_type&amp; get_deleter() const noexcept;
        explicit operator bool() const noexcept;
 
        // 20.8.1.3.4 modifiers
        pointer release() noexcept;
        template &lt;class U&gt; void reset(U p) noexcept;
        void reset(nullptr_t = nullptr) noexcept;
        void swap(unique_ptr&amp; u) noexcept;
 
        // disable copy from lvalue
        unique_ptr(const unique_ptr&amp;) = delete;
        unique_ptr&amp; operator=(const unique_ptr&amp;) = delete;
    };
 
}</pre></div> <h4 id="std::bad_weak_ptr"> <code><a href="../../memory/bad_weak_ptr/"><span class="kw699">std::<span class="me2">bad_weak_ptr</span></span></a></code>
</h4> <div class="cpp source-cpp"><pre data-language="cpp">namespace std {
    class bad_weak_ptr: public std::exception {
    public:
        bad_weak_ptr() noexcept;
    };
} // namespace std</pre></div> <h4 id="std::shared_ptr"> <code><a href="../../memory/shared_ptr/"><span class="kw688">std::<span class="me2">shared_ptr</span></span></a></code>
</h4> <div class="cpp source-cpp"><pre data-language="cpp">namespace std {
    template&lt;class T&gt; class shared_ptr {
    public:
        typedef T element_type;
 
        // 20.8.2.2.1, constructors:
        constexpr shared_ptr() noexcept;
        template&lt;class Y&gt; explicit shared_ptr(Y* p);
        template&lt;class Y, class D&gt; shared_ptr(Y* p, D d);
        template&lt;class Y, class D, class A&gt; shared_ptr(Y* p, D d, A a);
        template &lt;class D&gt; shared_ptr(nullptr_t p, D d);
        template &lt;class D, class A&gt; shared_ptr(nullptr_t p, D d, A a);
        template&lt;class Y&gt; shared_ptr(const shared_ptr&lt;Y&gt;&amp; r, T* p) noexcept;
        shared_ptr(const shared_ptr&amp; r) noexcept;
        template&lt;class Y&gt; shared_ptr(const shared_ptr&lt;Y&gt;&amp; r) noexcept;
        shared_ptr(shared_ptr&amp;&amp; r) noexcept;
        template&lt;class Y&gt; shared_ptr(shared_ptr&lt;Y&gt;&amp;&amp; r) noexcept;
        template&lt;class Y&gt; explicit shared_ptr(const weak_ptr&lt;Y&gt;&amp; r);
        template &lt;class Y, class D&gt; shared_ptr(unique_ptr&lt;Y, D&gt;&amp;&amp; r);
        constexpr shared_ptr(nullptr_t) noexcept : shared_ptr() { }
 
        // 20.8.2.2.2, destructor:
        ~shared_ptr();
 
        // 20.8.2.2.3, assignment:
        shared_ptr&amp; operator=(const shared_ptr&amp; r) noexcept;
        template&lt;class Y&gt; shared_ptr&amp; operator=(const shared_ptr&lt;Y&gt;&amp; r) noexcept;
        shared_ptr&amp; operator=(shared_ptr&amp;&amp; r) noexcept;
        template&lt;class Y&gt; shared_ptr&amp; operator=(shared_ptr&lt;Y&gt;&amp;&amp; r) noexcept;
        template &lt;class Y, class D&gt; shared_ptr&amp; operator=(unique_ptr&lt;Y, D&gt;&amp;&amp; r);
 
        // 20.8.2.2.4, modifiers:
        void swap(shared_ptr&amp; r) noexcept;
        void reset() noexcept;
        template&lt;class Y&gt; void reset(Y* p);
        template&lt;class Y, class D&gt; void reset(Y* p, D d);
        template&lt;class Y, class D, class A&gt; void reset(Y* p, D d, A a);
 
        // 20.8.2.2.5, observers:
        T* get() const noexcept;
        T&amp; operator*() const noexcept;
        T* operator-&gt;() const noexcept;
        long use_count() const noexcept;
        bool unique() const noexcept;
        explicit operator bool() const noexcept;
        template&lt;class U&gt; bool owner_before(shared_ptr&lt;U&gt; const&amp; b) const;
        template&lt;class U&gt; bool owner_before(weak_ptr&lt;U&gt; const&amp; b) const;
    };
}</pre></div> <h4 id="std::weak_ptr"> <code><a href="../../memory/weak_ptr/"><span class="kw695">std::<span class="me2">weak_ptr</span></span></a></code>
</h4> <div class="cpp source-cpp"><pre data-language="cpp">namespace std {
    template&lt;class T&gt; class weak_ptr {
    public:
        typedef T element_type;
 
        // 20.8.2.3.1, constructors
        constexpr weak_ptr() noexcept;
        template&lt;class Y&gt; weak_ptr(shared_ptr&lt;Y&gt; const&amp; r) noexcept;
        weak_ptr(weak_ptr const&amp; r) noexcept;
        template&lt;class Y&gt; weak_ptr(weak_ptr&lt;Y&gt; const&amp; r) noexcept;
        weak_ptr(weak_ptr&amp;&amp; r) noexcept;
        template&lt;class Y&gt; weak_ptr(weak_ptr&lt;Y&gt;&amp;&amp; r) noexcept;
 
        // 20.8.2.3.2, destructor
        ~weak_ptr();
 
        // 20.8.2.3.3, assignment
        weak_ptr&amp; operator=(weak_ptr const&amp; r) noexcept;
        template&lt;class Y&gt; weak_ptr&amp; operator=(weak_ptr&lt;Y&gt; const&amp; r) noexcept;
        template&lt;class Y&gt; weak_ptr&amp; operator=(shared_ptr&lt;Y&gt; const&amp; r) noexcept;
        weak_ptr&amp; operator=(weak_ptr&amp;&amp; r) noexcept;
        template&lt;class Y&gt; weak_ptr&amp; operator=(weak_ptr&lt;Y&gt;&amp;&amp; r) noexcept;
 
        // 20.8.2.3.4, modifiers
        void swap(weak_ptr&amp; r) noexcept;
        void reset() noexcept;
 
        // 20.8.2.3.5, observers
        long use_count() const noexcept;
        bool expired() const noexcept;
        shared_ptr&lt;T&gt; lock() const noexcept;
        template&lt;class U&gt; bool owner_before(shared_ptr&lt;U&gt; const&amp; b) const;
        template&lt;class U&gt; bool owner_before(weak_ptr&lt;U&gt; const&amp; b) const;
    };
} // namespace std</pre></div> <h4 id="std::enable_shared_from_this"> <code><a href="../../memory/enable_shared_from_this/"><span class="kw698">std::<span class="me2">enable_shared_from_this</span></span></a></code>
</h4> <div class="cpp source-cpp"><pre data-language="cpp">namespace std {
    template&lt;class T&gt; class enable_shared_from_this {
    protected:
        constexpr enable_shared_from_this() noexcept;
        enable_shared_from_this(enable_shared_from_this const&amp;) noexcept;
        enable_shared_from_this&amp; operator=(enable_shared_from_this const&amp;) noexcept;
        ~enable_shared_from_this();
    public:
        shared_ptr&lt;T&gt; shared_from_this();
        shared_ptr&lt;T const&gt; shared_from_this() const;
    };
} // namespace std</pre></div>           <div class="_attribution">
  <p class="_attribution-p">
    © cppreference.com<br>Licensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.<br>
    <a href="http://en.cppreference.com/w/cpp/header/memory" class="_attribution-link" target="_blank">http://en.cppreference.com/w/cpp/header/memory</a>
  </p>
</div>

			</div>
		</div>
	</section>

	</div>
</body>
</html>
