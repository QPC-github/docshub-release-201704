
<!DOCTYPE HTML>

<html lang="en">

<head>
  <meta charset="utf-8">
  <title>Task.Supervisor - Elixir 1.4 - W3cubDocs</title>
  
  <meta name="description" content=" A task supervisor. ">
  <meta name="keywords" content="task, supervisor, summary, functions, -, elixir, elixir~1.4">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="http://docs.w3cub.com/elixir~1.4/task.supervisor/">
  <link href="/favicon.png" rel="icon">
  <link type="text/css" rel="stylesheet" href="/assets/application-50364fff564ce3b6327021805f3f00e2957b441cf27f576a7dd4ff63bbc47047.css">
  <script type="text/javascript" src="/assets/application-db64bfd54ceb42be11af7995804cf4902548419ceb79d509b0b7d62c22d98e6f.js"></script>
  <script src="/json/elixir~1.4.js"></script>
  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-71174418-1']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>


</head>

<body>
	<div class="_app">
	<header class="_header">
  
  <form class="_search">
    <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
    <a class="_search-clear"></a>
    <div class="_search-tag"></div>
  </form>
  
  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/elixir~1.4/" class="_nav-link" title="" style="margin-left:0;">Elixir 1.4</a></span>
  
  <nav class="_nav">
    <a href="/app/" class="_nav-link ">App</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		<div class="_list">
			
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<div class="_page _elixir">
				
<h1>  Task.Supervisor  </h1>  <p>A task supervisor.</p> <p>This module defines a supervisor which can be used to dynamically supervise tasks. Behind the scenes, this module is implemented as a <code class="inline">:simple_one_for_one</code> supervisor where the workers are temporary by default (that is, they are not restarted after they die; read the docs for <a href="#start_link/1"><code class="inline">start_link/1</code></a> for more information on choosing the restart strategy).</p> <p>See the <a href="../task/"><code class="inline">Task</code></a> module for more information.</p> <h2 id="module-name-registration" class="section-heading">  Name registration </h2> <p>A <a href="../task.supervisor/#content"><code class="inline">Task.Supervisor</code></a> is bound to the same name registration rules as a <a href="../genserver/"><code class="inline">GenServer</code></a>. Read more about them in the <a href="../genserver/"><code class="inline">GenServer</code></a> docs.</p>   <h1 class="section-heading" id="summary">  Summary </h1> <h2> Functions </h2>
<dl class="summary-functions summary">   <dt class="summary-signature"> <a href="#async/2">async(supervisor, fun)</a> </dt> <dd class="summary-synopsis">
<p>Starts a task that can be awaited on</p> </dd>   <dt class="summary-signature"> <a href="#async/4">async(supervisor, module, fun, args)</a> </dt> <dd class="summary-synopsis">
<p>Starts a task that can be awaited on</p> </dd>   <dt class="summary-signature"> <a href="#async_nolink/2">async_nolink(supervisor, fun)</a> </dt> <dd class="summary-synopsis">
<p>Starts a task that can be awaited on</p> </dd>   <dt class="summary-signature"> <a href="#async_nolink/4">async_nolink(supervisor, module, fun, args)</a> </dt> <dd class="summary-synopsis">
<p>Starts a task that can be awaited on</p> </dd>   <dt class="summary-signature"> <a href="#async_stream/4">async_stream(supervisor, enumerable, fun, options \\ [])</a> </dt> <dd class="summary-synopsis">
<p>Returns a stream that runs the given <code class="inline">function</code> concurrently on each item in <code class="inline">enumerable</code></p> </dd>   <dt class="summary-signature"> <a href="#async_stream/6">async_stream(supervisor, enumerable, module, function, args, options \\ [])</a> </dt> <dd class="summary-synopsis">
<p>Returns a stream that runs the given <code class="inline">module</code>, <code class="inline">function</code> and <code class="inline">args</code> concurrently on each item in <code class="inline">enumerable</code></p> </dd>   <dt class="summary-signature"> <a href="#async_stream_nolink/4">async_stream_nolink(supervisor, enumerable, fun, options \\ [])</a> </dt> <dd class="summary-synopsis">
<p>Returns a stream that runs the given <code class="inline">function</code> concurrently on each item in <code class="inline">enumerable</code></p> </dd>   <dt class="summary-signature"> <a href="#async_stream_nolink/6">async_stream_nolink(supervisor, enumerable, module, function, args, options \\ [])</a> </dt> <dd class="summary-synopsis">
<p>Returns a stream that runs the given <code class="inline">module</code>, <code class="inline">function</code> and <code class="inline">args</code> concurrently on each item in <code class="inline">enumerable</code></p> </dd>   <dt class="summary-signature"> <a href="#children/1">children(supervisor)</a> </dt> <dd class="summary-synopsis">
<p>Returns all children PIDs</p> </dd>   <dt class="summary-signature"> <a href="#start_child/2">start_child(supervisor, fun)</a> </dt> <dd class="summary-synopsis">
<p>Starts a task as a child of the given <code class="inline">supervisor</code></p> </dd>   <dt class="summary-signature"> <a href="#start_child/4">start_child(supervisor, module, fun, args)</a> </dt> <dd class="summary-synopsis">
<p>Starts a task as a child of the given <code class="inline">supervisor</code></p> </dd>   <dt class="summary-signature"> <a href="#start_link/1">start_link(opts \\ [])</a> </dt> <dd class="summary-synopsis">
<p>Starts a new supervisor</p> </dd>   <dt class="summary-signature"> <a href="#terminate_child/2">terminate_child(supervisor, pid)</a> </dt> <dd class="summary-synopsis">
<p>Terminates the child with the given <code class="inline">pid</code></p> </dd>  </dl>   <h1 class="section-heading" id="functions">  Functions </h1>  <h3 class="detail-header function" id="async/2">  <span class="signature">async(supervisor, fun)</span>     </h3>
<pre data-language="elixir">async(<a href="../supervisor/#t:supervisor/0">Supervisor.supervisor</a>, (... -&gt; any)) :: <a href="../task/#t:t/0">Task.t</a></pre>  <p>Starts a task that can be awaited on.</p> <p>The <code class="inline">supervisor</code> must be a reference as defined in <a href="../task.supervisor/#content"><code class="inline">Task.Supervisor</code></a>. The task will still be linked to the caller, see <a href="../task/#async/3"><code class="inline">Task.async/3</code></a> for more information and <a href="#async_nolink/2"><code class="inline">async_nolink/2</code></a> for a non-linked variant.</p>    <h3 class="detail-header function" id="async/4">  <span class="signature">async(supervisor, module, fun, args)</span>     </h3>
<pre data-language="elixir">async(<a href="../supervisor/#t:supervisor/0">Supervisor.supervisor</a>, module, atom, [term]) :: <a href="../task/#t:t/0">Task.t</a></pre>  <p>Starts a task that can be awaited on.</p> <p>The <code class="inline">supervisor</code> must be a reference as defined in <a href="../task.supervisor/#content"><code class="inline">Task.Supervisor</code></a>. The task will still be linked to the caller, see <a href="../task/#async/3"><code class="inline">Task.async/3</code></a> for more information and <a href="#async_nolink/2"><code class="inline">async_nolink/2</code></a> for a non-linked variant.</p>    <h3 class="detail-header function" id="async_nolink/2">  <span class="signature">async_nolink(supervisor, fun)</span>     </h3>
<pre data-language="elixir">async_nolink(<a href="../supervisor/#t:supervisor/0">Supervisor.supervisor</a>, (... -&gt; any)) :: <a href="../task/#t:t/0">Task.t</a></pre>  <p>Starts a task that can be awaited on.</p> <p>The <code class="inline">supervisor</code> must be a reference as defined in <a href="../task.supervisor/#content"><code class="inline">Task.Supervisor</code></a>. The task won’t be linked to the caller, see <a href="../task/#async/3"><code class="inline">Task.async/3</code></a> for more information.</p> <h4 id="async_nolink/2-compatibility-with-otp-behaviours" class="section-heading">  Compatibility with OTP behaviours </h4> <p>If you create a task using <code class="inline">async_nolink</code> inside an OTP behaviour like <a href="../genserver/"><code class="inline">GenServer</code></a>, you should match on the message coming from the task inside your <a href="https://hexdocs.pm/elixir/GenServer.html#handle_info/2" target="_blank"><code class="inline">GenServer.handle_info/2</code></a> callback.</p> <p>The reply sent by the task will be in the format <code class="inline">{ref, result}</code>, where <code class="inline">ref</code> is the monitor reference held by the task struct and <code class="inline">result</code> is the return value of the task function.</p> <p>Keep in mind that, regardless of how the task created with <code class="inline">async_nolink</code> terminates, the caller’s process will always receive a <code class="inline">:DOWN</code> message with the same <code class="inline">ref</code> value that is held by the task struct. If the task terminates normally, the reason in the <code class="inline">:DOWN</code> message will be <code class="inline">:normal</code>.</p>    <h3 class="detail-header function" id="async_nolink/4">  <span class="signature">async_nolink(supervisor, module, fun, args)</span>     </h3>
<pre data-language="elixir">async_nolink(<a href="../supervisor/#t:supervisor/0">Supervisor.supervisor</a>, module, atom, [term]) :: <a href="../task/#t:t/0">Task.t</a></pre>  <p>Starts a task that can be awaited on.</p> <p>The <code class="inline">supervisor</code> must be a reference as defined in <a href="../task.supervisor/#content"><code class="inline">Task.Supervisor</code></a>. The task won’t be linked to the caller, see <a href="../task/#async/3"><code class="inline">Task.async/3</code></a> for more information.</p>     <h3 class="detail-header function" id="async_stream/4">  <span class="signature">async_stream(supervisor, enumerable, fun, options \\ [])</span>     </h3>
<pre data-language="elixir">async_stream(<a href="../supervisor/#t:supervisor/0">Supervisor.supervisor</a>, <a href="../enumerable/#t:t/0">Enumerable.t</a>, (term -&gt; term), <a href="../keyword/#t:t/0">Keyword.t</a>) :: <a href="../enumerable/#t:t/0">Enumerable.t</a></pre>  <p>Returns a stream that runs the given <code class="inline">function</code> concurrently on each item in <code class="inline">enumerable</code>.</p> <p>Each item will be appended to the given <code class="inline">args</code> and processed by its own task. The tasks will be spawned under the given <code class="inline">supervisor</code> and are linked to the current process, similar to <a href="#async/2"><code class="inline">async/2</code></a>.</p> <p>See <a href="#async_stream/6"><code class="inline">async_stream/6</code></a> for discussion and examples.</p>     <h3 class="detail-header function" id="async_stream/6">  <span class="signature">async_stream(supervisor, enumerable, module, function, args, options \\ [])</span>     </h3>
<pre data-language="elixir">async_stream(<a href="../supervisor/#t:supervisor/0">Supervisor.supervisor</a>, <a href="../enumerable/#t:t/0">Enumerable.t</a>, module, atom, [term], <a href="../keyword/#t:t/0">Keyword.t</a>) :: <a href="../enumerable/#t:t/0">Enumerable.t</a></pre>  <p>Returns a stream that runs the given <code class="inline">module</code>, <code class="inline">function</code> and <code class="inline">args</code> concurrently on each item in <code class="inline">enumerable</code>.</p> <p>Each item will be appended to the given <code class="inline">args</code> and processed by its own task. The tasks will be spawned under the given <code class="inline">supervisor</code> and linked to the current process, similar to <a href="#async/4"><code class="inline">async/4</code></a>.</p> <p>When streamed, each task will emit <code class="inline">{:ok, val}</code> upon successful completion or <code class="inline">{:exit, val}</code> if the caller is trapping exits. Results are emitted in the same order as the original <code class="inline">enumerable</code>.</p> <p>The level of concurrency can be controlled via the <code class="inline">:max_concurrency</code> option and defaults to <a href="../system/#schedulers_online/0"><code class="inline">System.schedulers_online/0</code></a>. The timeout can also be given as option and defaults to 5000 and it defaults to the maximum amount of time to wait without a task reply.</p> <p>Finally, if you find yourself trapping exits to handle exits inside the async stream, consider using <a href="#async_stream_nolink/6"><code class="inline">async_stream_nolink/6</code></a> to start tasks that are not linked to the current process.</p> <h4 id="async_stream/6-options" class="section-heading">  Options </h4> <ul> <li>
<code class="inline">:max_concurrency</code> - sets the maximum number of tasks to run at the same time. Defaults to <a href="../system/#schedulers_online/0"><code class="inline">System.schedulers_online/0</code></a>. </li> <li>
<code class="inline">:timeout</code> - the maximum amount of time to wait without receiving a task reply (across all running tasks). Defaults to <code class="inline">5000</code>. </li> </ul> <h4 id="async_stream/6-examples" class="section-heading">  Examples </h4> <p>Let’s build a stream and then enumerate it:</p> <pre data-language="elixir"><code class="elixir">stream = Task.Supervisor.async_stream(MySupervisor, collection, Mod, :expensive_fun, [])
Enum.to_list(stream)</code></pre>     <h3 class="detail-header function" id="async_stream_nolink/4">  <span class="signature">async_stream_nolink(supervisor, enumerable, fun, options \\ [])</span>     </h3>
<pre data-language="elixir">async_stream_nolink(<a href="../supervisor/#t:supervisor/0">Supervisor.supervisor</a>, <a href="../enumerable/#t:t/0">Enumerable.t</a>, (term -&gt; term), <a href="../keyword/#t:t/0">Keyword.t</a>) :: <a href="../enumerable/#t:t/0">Enumerable.t</a></pre>  <p>Returns a stream that runs the given <code class="inline">function</code> concurrently on each item in <code class="inline">enumerable</code>.</p> <p>Each item will be appended to the given <code class="inline">args</code> and processed by its own task. The tasks will be spawned under the given <code class="inline">supervisor</code> and are not linked to the current process, similar to <a href="#async_nolink/2"><code class="inline">async_nolink/2</code></a>.</p> <p>See <a href="#async_stream/6"><code class="inline">async_stream/6</code></a> for discussion and examples.</p>     <h3 class="detail-header function" id="async_stream_nolink/6">  <span class="signature">async_stream_nolink(supervisor, enumerable, module, function, args, options \\ [])</span>     </h3>
<pre data-language="elixir">async_stream_nolink(<a href="../supervisor/#t:supervisor/0">Supervisor.supervisor</a>, <a href="../enumerable/#t:t/0">Enumerable.t</a>, module, atom, [term], <a href="../keyword/#t:t/0">Keyword.t</a>) :: <a href="../enumerable/#t:t/0">Enumerable.t</a></pre>  <p>Returns a stream that runs the given <code class="inline">module</code>, <code class="inline">function</code> and <code class="inline">args</code> concurrently on each item in <code class="inline">enumerable</code>.</p> <p>Each item will be appended to the given <code class="inline">args</code> and processed by its own task. The tasks will be spawned under the given <code class="inline">supervisor</code> and are not linked to the current process, similar to <a href="#async_nolink/4"><code class="inline">async_nolink/4</code></a>.</p> <p>See <a href="#async_stream/6"><code class="inline">async_stream/6</code></a> for discussion and examples.</p>    <h3 class="detail-header function" id="children/1">  <span class="signature">children(supervisor)</span>     </h3>
<pre data-language="elixir">children(<a href="../supervisor/#t:supervisor/0">Supervisor.supervisor</a>) :: [pid]</pre>  <p>Returns all children PIDs.</p>    <h3 class="detail-header function" id="start_child/2">  <span class="signature">start_child(supervisor, fun)</span>     </h3>
<pre data-language="elixir">start_child(<a href="../supervisor/#t:supervisor/0">Supervisor.supervisor</a>, (... -&gt; any)) :: {:ok, pid}</pre>  <p>Starts a task as a child of the given <code class="inline">supervisor</code>.</p> <p>Note that the spawned process is not linked to the caller, but only to the supervisor. This command is useful in case the task needs to perform side-effects (like I/O) and does not need to report back to the caller.</p>    <h3 class="detail-header function" id="start_child/4">  <span class="signature">start_child(supervisor, module, fun, args)</span>     </h3>
<pre data-language="elixir">start_child(<a href="../supervisor/#t:supervisor/0">Supervisor.supervisor</a>, module, atom, [term]) :: {:ok, pid}</pre>  <p>Starts a task as a child of the given <code class="inline">supervisor</code>.</p> <p>Similar to <a href="#start_child/2"><code class="inline">start_child/2</code></a> except the task is specified by the given <code class="inline">module</code>, <code class="inline">fun</code> and <code class="inline">args</code>.</p>     <h3 class="detail-header function" id="start_link/1">  <span class="signature">start_link(opts \\ [])</span>     </h3>
<pre data-language="elixir">start_link(<a href="../supervisor/#t:options/0">Supervisor.options</a>) :: <a href="../supervisor/#t:on_start/0">Supervisor.on_start</a></pre>  <p>Starts a new supervisor.</p> <p>The supported options are:</p> <ul> <li>
<p><code class="inline">:name</code> - used to register a supervisor name, the supported values are described under the <code class="inline">Name Registration</code> section in the <a href="../genserver/"><code class="inline">GenServer</code></a> module docs;</p> </li> <li>
<p><code class="inline">:restart</code> - the restart strategy, may be <code class="inline">:temporary</code> (the default), <code class="inline">:transient</code> or <code class="inline">:permanent</code>. Check <a href="../supervisor.spec/"><code class="inline">Supervisor.Spec</code></a> for more info. Defaults to <code class="inline">:temporary</code> so tasks aren’t automatically restarted when they complete nor in case of crashes;</p> </li> <li>
<p><code class="inline">:shutdown</code> - <code class="inline">:brutal_kill</code> if the tasks must be killed directly on shutdown or an integer indicating the timeout value, defaults to 5000 milliseconds;</p> </li> <li>
<code class="inline">:max_restarts</code> and <code class="inline">:max_seconds</code> - as specified in <a href="../supervisor.spec/#supervise/2"><code class="inline">Supervisor.Spec.supervise/2</code></a>; </li> </ul>    <h3 class="detail-header function" id="terminate_child/2">  <span class="signature">terminate_child(supervisor, pid)</span>     </h3>
<pre data-language="elixir">terminate_child(<a href="../supervisor/#t:supervisor/0">Supervisor.supervisor</a>, pid) :: :ok</pre>  <p>Terminates the child with the given <code class="inline">pid</code>.</p>
<div class="_attribution">
  <p class="_attribution-p">
    © 2012–2017 Plataformatec<br>Licensed under the Apache License, Version 2.0.<br>
    <a href="https://hexdocs.pm/elixir/1.4.1/Task.Supervisor.html" class="_attribution-link" target="_blank">https://hexdocs.pm/elixir/1.4.1/Task.Supervisor.html</a>
  </p>
</div>

			</div>
		</div>
	</section>

	</div>
</body>
</html>
