
<!DOCTYPE HTML>

<html lang="en">

<head>
  <meta charset="utf-8">
  <title>IEx.Helpers - Elixir 1.4 - W3cubDocs</title>
  
  <meta name="description" content="Welcome to Interactive Elixir. You are currently seeing the documentation for the module IEx.Helpers which provides many helpers to make Elixir’s &hellip;">
  <meta name="keywords" content="iex, helpers, summary, functions, macros, -, elixir, elixir~1.4">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="http://docs.w3cub.com/elixir~1.4/iex.helpers/">
  <link href="/favicon.png" rel="icon">
  <link type="text/css" rel="stylesheet" href="/assets/application-50364fff564ce3b6327021805f3f00e2957b441cf27f576a7dd4ff63bbc47047.css">
  <script type="text/javascript" src="/assets/application-db64bfd54ceb42be11af7995804cf4902548419ceb79d509b0b7d62c22d98e6f.js"></script>
  <script src="/json/elixir~1.4.js"></script>
  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-71174418-1']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>


</head>

<body>
	<div class="_app">
	<header class="_header">
  
  <form class="_search">
    <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
    <a class="_search-clear"></a>
    <div class="_search-tag"></div>
  </form>
  
  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/elixir~1.4/" class="_nav-link" title="" style="margin-left:0;">Elixir 1.4</a></span>
  
  <nav class="_nav">
    <a href="/app/" class="_nav-link ">App</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		<div class="_list">
			
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<div class="_page _elixir">
				
<h1>  IEx.Helpers  </h1>  <p>Welcome to Interactive Elixir. You are currently seeing the documentation for the module <a href="../iex.helpers/#content"><code class="inline">IEx.Helpers</code></a> which provides many helpers to make Elixir’s shell more joyful to work with.</p> <p>This message was triggered by invoking the helper <code class="inline">h()</code>, usually referred to as <a href="#h/0"><code class="inline">h/0</code></a> (since it expects 0 arguments).</p> <p>You can use the <a href="#h/1"><code class="inline">h/1</code></a> function to invoke the documentation for any Elixir module or function:</p> <pre data-language="elixir"><code class="iex elixir">iex&gt; h Enum
iex&gt; h Enum.map
iex&gt; h Enum.reverse/1</code></pre> <p>You can also use the <a href="#i/1"><code class="inline">i/1</code></a> function to introspect any value you have in the shell:</p> <pre data-language="elixir"><code class="iex elixir">iex&gt; i "hello"</code></pre> <p>There are many other helpers available:</p> <ul> <li>
<a href="#b/1"><code class="inline">b/1</code></a> - prints callbacks info and docs for a given module </li> <li>
<a href="#c/1"><code class="inline">c/1</code></a> - compiles a file into the current directory </li> <li>
<a href="#c/2"><code class="inline">c/2</code></a> - compiles a file to the given path </li> <li>
<a href="#cd/1"><code class="inline">cd/1</code></a> - changes the current directory </li> <li>
<a href="#clear/0"><code class="inline">clear/0</code></a> - clears the screen </li> <li>
<a href="#flush/0"><code class="inline">flush/0</code></a> - flushes all messages sent to the shell </li> <li>
<a href="#h/0"><code class="inline">h/0</code></a> - prints this help message </li> <li>
<a href="#h/1"><code class="inline">h/1</code></a> - prints help for the given module, function or macro </li> <li>
<a href="#i/1"><code class="inline">i/1</code></a> - prints information about the data type of any given term </li> <li>
<a href="#import_file/1"><code class="inline">import_file/1</code></a> - evaluates the given file in the shell’s context </li> <li>
<a href="#l/1"><code class="inline">l/1</code></a> - loads the given module’s BEAM code </li> <li>
<a href="#ls/0"><code class="inline">ls/0</code></a> - lists the contents of the current directory </li> <li>
<a href="#ls/1"><code class="inline">ls/1</code></a> - lists the contents of the specified directory </li> <li>
<a href="#nl/2"><code class="inline">nl/2</code></a> - deploys local BEAM code to a list of nodes </li> <li>
<a href="#pid/1"><code class="inline">pid/1</code></a> - creates a PID from a string </li> <li>
<a href="#pid/3"><code class="inline">pid/3</code></a> - creates a PID with the 3 integer arguments passed </li> <li>
<a href="#pwd/0"><code class="inline">pwd/0</code></a> - prints the current working directory </li> <li>
<a href="#r/1"><code class="inline">r/1</code></a> - recompiles the given module’s source file </li> <li>
<a href="#recompile/0"><code class="inline">recompile/0</code></a> - recompiles the current project </li> <li>
<a href="#respawn/0"><code class="inline">respawn/0</code></a> - respawns the current shell </li> <li>
<a href="#s/1"><code class="inline">s/1</code></a> - prints spec information </li> <li>
<a href="#t/1"><code class="inline">t/1</code></a> - prints type information </li> <li>
<a href="#v/0"><code class="inline">v/0</code></a> - retrieves the last value from the history </li> <li>
<a href="#v/1"><code class="inline">v/1</code></a> - retrieves the nth value from the history </li> </ul> <p>Help for all of those functions can be consulted directly from the command line using the <a href="#h/1"><code class="inline">h/1</code></a> helper itself. Try:</p> <pre data-language="elixir"><code class="iex elixir">iex&gt; h(v/0)</code></pre> <p>To learn more about IEx as a whole, type <code class="inline">h(IEx)</code>.</p>   <h1 class="section-heading" id="summary">  Summary </h1> <h2> Functions </h2>
<dl class="summary-functions summary">   <dt class="summary-signature"> <a href="#c/2">c(files, path \\ :in_memory)</a> </dt> <dd class="summary-synopsis">
<p>Compiles the given files</p> </dd>   <dt class="summary-signature"> <a href="#cd/1">cd(directory)</a> </dt> <dd class="summary-synopsis">
<p>Changes the current working directory to the given path</p> </dd>   <dt class="summary-signature"> <a href="#clear/0">clear()</a> </dt> <dd class="summary-synopsis">
<p>Clears the console screen</p> </dd>   <dt class="summary-signature"> <a href="#flush/0">flush()</a> </dt> <dd class="summary-synopsis">
<p>Flushes all messages sent to the shell and prints them out</p> </dd>   <dt class="summary-signature"> <a href="#h/0">h()</a> </dt> <dd class="summary-synopsis">
<p>Prints the documentation for <a href="../iex.helpers/#content"><code class="inline">IEx.Helpers</code></a></p> </dd>   <dt class="summary-signature"> <a href="#i/1">i(term)</a> </dt> <dd class="summary-synopsis">
<p>Prints information about the data type of any given term</p> </dd>   <dt class="summary-signature"> <a href="#l/1">l(module)</a> </dt> <dd class="summary-synopsis">
<p>Loads the given module’s BEAM code (and ensures any previous old version was properly purged before)</p> </dd>   <dt class="summary-signature"> <a href="#ls/1">ls(path \\ ".")</a> </dt> <dd class="summary-synopsis">
<p>Produces a simple list of a directory’s contents</p> </dd>   <dt class="summary-signature"> <a href="#nl/2">nl(nodes \\ Node.list(), module)</a> </dt> <dd class="summary-synopsis">
<p>Deploys a given module’s BEAM code to a list of nodes</p> </dd>   <dt class="summary-signature"> <a href="#pid/1">pid(string)</a> </dt> <dd class="summary-synopsis">
<p>Creates a PID from <code class="inline">string</code></p> </dd>   <dt class="summary-signature"> <a href="#pid/3">pid(x, y, z)</a> </dt> <dd class="summary-synopsis">
<p>Creates a PID with 3 non negative integers passed as arguments to the function</p> </dd>   <dt class="summary-signature"> <a href="#pwd/0">pwd()</a> </dt> <dd class="summary-synopsis">
<p>Prints the current working directory</p> </dd>   <dt class="summary-signature"> <a href="#r/1">r(module)</a> </dt> <dd class="summary-synopsis">
<p>Recompiles and reloads the given <code class="inline">module</code></p> </dd>   <dt class="summary-signature"> <a href="#recompile/0">recompile()</a> </dt> <dd class="summary-synopsis">
<p>Recompiles the current Mix application</p> </dd>   <dt class="summary-signature"> <a href="#respawn/0">respawn()</a> </dt> <dd class="summary-synopsis">
<p>Respawns the current shell by starting a new shell process</p> </dd>   <dt class="summary-signature"> <a href="#v/1">v(n \\ -1)</a> </dt> <dd class="summary-synopsis">
<p>Returns the value of the <code class="inline">n</code>th expression in the history</p> </dd>  </dl> <h2> Macros </h2>
<dl class="summary-macros summary">   <dt class="summary-signature"> <a href="#b/1">b(term)</a> </dt> <dd class="summary-synopsis">
<p>Prints the documentation for the given callback function</p> </dd>   <dt class="summary-signature"> <a href="#h/1">h(term)</a> </dt> <dd class="summary-synopsis">
<p>Prints the documentation for the given module or for the given function/arity pair</p> </dd>   <dt class="summary-signature"> <a href="#import_file/1">import_file(path)</a> </dt> <dd class="summary-synopsis">
<p>Evaluates the contents of the file at <code class="inline">path</code> as if it were directly typed into the shell</p> </dd>   <dt class="summary-signature"> <a href="#import_file/2">import_file(path, opts)</a> </dt>   <dt class="summary-signature"> <a href="#import_file_if_available/1">import_file_if_available(path)</a> </dt> <dd class="summary-synopsis">
<p>Similar to <code class="inline">import_file</code> but only imports the file it if it is available</p> </dd>   <dt class="summary-signature"> <a href="#import_if_available/2">import_if_available(quoted_module, opts \\ [])</a> </dt> <dd class="summary-synopsis">
<p>Calls <code class="inline">import/2</code> with the given arguments, but only if the module is available</p> </dd>   <dt class="summary-signature"> <a href="#s/1">s(term)</a> </dt> <dd class="summary-synopsis">
<p>Prints the specs for the given module or for the given function/arity pair</p> </dd>   <dt class="summary-signature"> <a href="#t/1">t(term)</a> </dt> <dd class="summary-synopsis">
<p>Prints the types for the given module or for the given function/arity pair</p> </dd>  </dl>   <h1 class="section-heading" id="functions">  Functions </h1>   <h3 class="detail-header function" id="c/2">  <span class="signature">c(files, path \\ :in_memory)</span>  </h3>  <p>Compiles the given files.</p> <p>It expects a list of files to compile and an optional path to write the compiled code to (defaults to the current directory). When compiling one file, there is no need to wrap it in a list.</p> <p>It returns the names of the compiled modules.</p> <p>If you want to recompile an existing module, check <a href="#r/1"><code class="inline">r/1</code></a> instead.</p> <h4 id="c/2-examples" class="section-heading">  Examples </h4> <pre data-language="elixir"><code class="iex elixir">iex&gt; c ["foo.ex", "bar.ex"], "ebin"
[Foo, Bar]

iex&gt; c "baz.ex"
[Baz]</code></pre>    <h3 class="detail-header function" id="cd/1">  <span class="signature">cd(directory)</span>  </h3>  <p>Changes the current working directory to the given path.</p>    <h3 class="detail-header function" id="clear/0">  <span class="signature">clear()</span>  </h3>  <p>Clears the console screen.</p> <p>This function only works if ANSI escape codes are enabled on the shell, which means this function is by default unavailable on Windows machines.</p>    <h3 class="detail-header function" id="flush/0">  <span class="signature">flush()</span>  </h3>  <p>Flushes all messages sent to the shell and prints them out.</p>    <h3 class="detail-header function" id="h/0">  <span class="signature">h()</span>  </h3>  <p>Prints the documentation for <a href="../iex.helpers/#content"><code class="inline">IEx.Helpers</code></a>.</p>    <h3 class="detail-header function" id="i/1">  <span class="signature">i(term)</span>  </h3>  <p>Prints information about the data type of any given term.</p> <h4 id="i/1-examples" class="section-heading">  Examples </h4> <pre data-language="elixir"><code class="iex elixir">iex&gt; i(1..5)</code></pre> <p>Will print:</p> <pre data-language="elixir"><code class="elixir">Term
  1..5
Data type
  Range
Description
  This is a struct. Structs are maps with a __struct__ key.
Reference modules
  Range, Map</code></pre>    <h3 class="detail-header function" id="l/1">  <span class="signature">l(module)</span>  </h3>  <p>Loads the given module’s BEAM code (and ensures any previous old version was properly purged before).</p> <p>This function is useful when you know the bytecode for module has been updated in the filesystem and you want to tell the VM to load it.</p>     <h3 class="detail-header function" id="ls/1">  <span class="signature">ls(path \\ ".")</span>  </h3>  <p>Produces a simple list of a directory’s contents.</p> <p>If <code class="inline">path</code> points to a file, prints its full path.</p>     <h3 class="detail-header function" id="nl/2">  <span class="signature">nl(nodes \\ Node.list(), module)</span>  </h3>  <p>Deploys a given module’s BEAM code to a list of nodes.</p> <p>This function is useful for development and debugging when you have code that has been compiled or updated locally that you want to run on other nodes.</p> <p>The node list defaults to a list of all connected nodes.</p> <p>Returns <code class="inline">{:error, :nofile}</code> if the object code (i.e. “.beam” file) for the module could not be found locally.</p> <h4 id="nl/2-examples" class="section-heading">  Examples </h4> <pre data-language="elixir"><code class="iex elixir">iex&gt; nl(HelloWorld)
{:ok, [{:node1@easthost, :loaded, HelloWorld},
       {:node1@westhost, :loaded, HelloWorld}]}

iex&gt; nl(NoSuchModuleExists)
{:error, :nofile}</code></pre>    <h3 class="detail-header function" id="pid/1">  <span class="signature">pid(string)</span>  </h3>  <p>Creates a PID from <code class="inline">string</code>.</p> <h4 id="pid/1-examples" class="section-heading">  Examples </h4> <pre data-language="elixir"><code class="iex elixir">iex&gt; pid("0.21.32")
#PID&lt;0.21.32&gt;</code></pre>    <h3 class="detail-header function" id="pid/3">  <span class="signature">pid(x, y, z)</span>  </h3>  <p>Creates a PID with 3 non negative integers passed as arguments to the function.</p> <h4 id="pid/3-examples" class="section-heading">  Examples </h4> <pre data-language="elixir"><code class="iex elixir">iex&gt; pid(0, 21, 32)
#PID&lt;0.21.32&gt;
iex&gt; pid(0, 64, 2048)
#PID&lt;0.64.2048&gt;</code></pre>    <h3 class="detail-header function" id="pwd/0">  <span class="signature">pwd()</span>  </h3>  <p>Prints the current working directory.</p>    <h3 class="detail-header function" id="r/1">  <span class="signature">r(module)</span>  </h3>  <p>Recompiles and reloads the given <code class="inline">module</code>.</p> <p>Please note that all the modules defined in the same file as <code class="inline">module</code> are recompiled and reloaded.</p> <p>This function is meant to be used for development and debugging purposes. Do not depend on it in production code.</p> <h4 id="r/1-in-memory-reloading" class="section-heading">  In-memory reloading </h4> <p>When we reload the module in IEx, we recompile the module source code, updating its contents in memory. The original <code class="inline">.beam</code> file in disk, probably the one where the first definition of the module came from, does not change at all.</p> <p>Since typespecs and docs are loaded from the .beam file (they are not loaded in memory with the module because there is no need for them to be in memory), they are not reloaded when you reload the module.</p>    <h3 class="detail-header function" id="recompile/0">  <span class="signature">recompile()</span>  </h3>  <p>Recompiles the current Mix application.</p> <p>This helper only works when IEx is started with a Mix project, for example, <code class="inline">iex -S mix</code>. The application is not restarted after compilation, which means any long running process may crash as the code is updated but the state does not go through the proper code changes callback. In any case, the supervision tree should notice the failure and restart such servers.</p> <p>If you want to reload a single module, consider using <code class="inline">r ModuleName</code> instead.</p> <p>This function is meant to be used for development and debugging purposes. Do not depend on it in production code.</p>    <h3 class="detail-header function" id="respawn/0">  <span class="signature">respawn()</span>  </h3>  <p>Respawns the current shell by starting a new shell process.</p> <p>Returns <code class="inline">true</code> if it worked.</p>     <h3 class="detail-header function" id="v/1">  <span class="signature">v(n \\ -1)</span>  </h3>  <p>Returns the value of the <code class="inline">n</code>th expression in the history.</p> <p><code class="inline">n</code> can be a negative value: if it is, the corresponding expression value relative to the current one is returned. For example, <code class="inline">v(-2)</code> returns the value of the expression evaluated before the last evaluated expression. In particular, <code class="inline">v(-1)</code> returns the result of the last evaluated expression and <code class="inline">v()</code> does the same.</p> <h4 id="v/1-examples" class="section-heading">  Examples </h4> <pre data-language="elixir"><code class="elixir">iex(1)&gt; "hello" &lt;&gt; " world"
"hello world"
iex(2)&gt; 40 + 2
42
iex(3)&gt; v(-2)
"hello world"
iex(4)&gt; v(2)
42
iex(5)&gt; v()
42</code></pre>     <h1 class="section-heading" id="macros">  Macros </h1>  <h3 class="detail-header macro" id="b/1">  <span class="signature">b(term)</span>  </h3>  <p>Prints the documentation for the given callback function.</p> <p>It also accepts single module argument to list all available behaviour callbacks.</p> <h4 id="b/1-examples" class="section-heading">  Examples </h4> <pre data-language="elixir"><code class="iex elixir">iex&gt; b(Mix.Task.run/1)
iex&gt; b(Mix.Task.run)
iex&gt; b(GenServer)</code></pre>    <h3 class="detail-header macro" id="h/1">  <span class="signature">h(term)</span>  </h3>  <p>Prints the documentation for the given module or for the given function/arity pair.</p> <h4 id="h/1-examples" class="section-heading">  Examples </h4> <pre data-language="elixir"><code class="iex elixir">iex&gt; h(Enum)</code></pre> <p>It also accepts functions in the format <code class="inline">fun/arity</code> and <code class="inline">module.fun/arity</code>, for example:</p> <pre data-language="elixir"><code class="iex elixir">iex&gt; h receive/1
iex&gt; h Enum.all?/2
iex&gt; h Enum.all?</code></pre>    <h3 class="detail-header macro" id="import_file/1">  <span class="signature">import_file(path)</span>  </h3>  <p>Evaluates the contents of the file at <code class="inline">path</code> as if it were directly typed into the shell.</p> <p><code class="inline">path</code> has to be a literal string. <code class="inline">path</code> is automatically expanded via <a href="https://hexdocs.pm/elixir/Path.html#expand/1" target="_blank"><code class="inline">Path.expand/1</code></a>.</p> <h4 id="import_file/1-examples" class="section-heading">  Examples </h4> <pre data-language="elixir"><code class="elixir"># ~/file.exs
value = 13

# in the shell
iex(1)&gt; import_file "~/file.exs"
13
iex(2)&gt; value
13</code></pre>    <h3 class="detail-header macro" id="import_file/2">  <span class="signature">import_file(path, opts)</span>  </h3>     <h3 class="detail-header macro" id="import_file_if_available/1">  <span class="signature">import_file_if_available(path)</span>  </h3>  <p>Similar to <code class="inline">import_file</code> but only imports the file it if it is available.</p> <p>By default, <a href="#import_file/1"><code class="inline">import_file/1</code></a> fails when the given file does not exist. However, since <a href="#import_file/1"><code class="inline">import_file/1</code></a> is expanded at compile-time, it’s not possible to conditionally import a file since the macro is always expanded:</p> <pre data-language="elixir"><code class="elixir"># This raises a File.Error if ~/.iex.exs doesn't exist.
if ("~/.iex.exs" |&gt; Path.expand |&gt; File.exists?) do
  import_file "~/.iex.exs"
end</code></pre> <p>This macro addresses this issue by checking if the file exists or not in behalf of the user.</p>     <h3 class="detail-header macro" id="import_if_available/2">  <span class="signature">import_if_available(quoted_module, opts \\ [])</span>  </h3>  <p>Calls <code class="inline">import/2</code> with the given arguments, but only if the module is available.</p> <p>This lets you put imports in <code class="inline">.iex.exs</code> files (including <code class="inline">~/.iex.exs</code>) without getting compile errors if you open a console where the module is not available.</p> <h4 id="import_if_available/2-example" class="section-heading">  Example </h4> <pre data-language="elixir"><code class="elixir"># In ~/.iex.exs
import_if_available Ecto.Query</code></pre>    <h3 class="detail-header macro" id="s/1">  <span class="signature">s(term)</span>  </h3>  <p>Prints the specs for the given module or for the given function/arity pair.</p> <h4 id="s/1-examples" class="section-heading">  Examples </h4> <pre data-language="elixir"><code class="iex elixir">iex&gt; s(Enum)
iex&gt; s(Enum.all?)
iex&gt; s(Enum.all?/2)
iex&gt; s(is_atom)
iex&gt; s(is_atom/1)</code></pre>    <h3 class="detail-header macro" id="t/1">  <span class="signature">t(term)</span>  </h3>  <p>Prints the types for the given module or for the given function/arity pair.</p> <h4 id="t/1-examples" class="section-heading">  Examples </h4> <pre data-language="elixir"><code class="iex elixir">iex&gt; t(Enum)
@type t() :: Enumerable.t()
@type element() :: any()
@type index() :: integer()
@type default() :: any()

iex&gt; t(Enum.t/0)
@type t() :: Enumerable.t()

iex&gt; t(Enum.t)
@type t() :: Enumerable.t()</code></pre>
<div class="_attribution">
  <p class="_attribution-p">
    © 2012–2017 Plataformatec<br>Licensed under the Apache License, Version 2.0.<br>
    <a href="https://hexdocs.pm/iex/1.4.1/IEx.Helpers.html" class="_attribution-link" target="_blank">https://hexdocs.pm/iex/1.4.1/IEx.Helpers.html</a>
  </p>
</div>

			</div>
		</div>
	</section>

	</div>
</body>
</html>
