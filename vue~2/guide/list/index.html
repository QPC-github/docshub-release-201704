
<!DOCTYPE HTML>

<html lang="en">

<head>
  <meta charset="utf-8">
  <title>List Rendering - Vue.js 2 - W3cubDocs</title>
  
  <meta name="description" content="We can use the v-for directive to render a list of items based on an array. The v-for directive requires a special syntax in the form of item in &hellip;">
  <meta name="keywords" content="list, rendering, -, vue, js, vue~2">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="http://docs.w3cub.com/vue~2/guide/list/">
  <link href="/favicon.png" rel="icon">
  <link type="text/css" rel="stylesheet" href="/assets/application-50364fff564ce3b6327021805f3f00e2957b441cf27f576a7dd4ff63bbc47047.css">
  <script type="text/javascript" src="/assets/application-db64bfd54ceb42be11af7995804cf4902548419ceb79d509b0b7d62c22d98e6f.js"></script>
  <script src="/json/vue~2.js"></script>
  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-71174418-1']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>


</head>

<body>
	<div class="_app">
	<header class="_header">
  
  <form class="_search">
    <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
    <a class="_search-clear"></a>
    <div class="_search-tag"></div>
  </form>
  
  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/vue~2/" class="_nav-link" title="" style="margin-left:0;">Vue.js 2</a></span>
  
  <nav class="_nav">
    <a href="/app/" class="_nav-link ">App</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		<div class="_list">
			
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<div class="_page _vue">
				
<h1>List Rendering</h1> <h2 id="v-for">
<code>v-for</code>
</h2>
<p>We can use the <code>v-for</code> directive to render a list of items based on an array. The <code>v-for</code> directive requires a special syntax in the form of <code>item in items</code>, where <code>items</code> is the source data array and <code>item</code> is an <strong>alias</strong> for the array element being iterated on:</p> <h3 id="Basic-Usage">
Basic Usage</h3>
<pre class="highlight html" data-language="html">&lt;ul id="example-1"&gt;
  &lt;li v-for="item in items"&gt;
    {{ item.message }}
  &lt;/li&gt;
&lt;/ul&gt;</pre> <pre class="highlight js" data-language="js">var example1 = new Vue({
  el: '#example-1',
  data: {
    items: [
      { message: 'Foo' },
      { message: 'Bar' }
    ]
  }
})</pre> <p>Result:</p> <ul id="example-1" class="demo">Live examples are not available on DevDocs, sorry.</ul>  <p>Inside <code>v-for</code> blocks we have full access to parent scope properties. <code>v-for</code> also supports an optional second argument for the index of the current item.</p> <pre class="highlight html" data-language="html">&lt;ul id="example-2"&gt;
  &lt;li v-for="(item, index) in items"&gt;
    {{ parentMessage }} - {{ index }} - {{ item.message }}
  &lt;/li&gt;
&lt;/ul&gt;</pre> <pre class="highlight js" data-language="js">var example2 = new Vue({
  el: '#example-2',
  data: {
    parentMessage: 'Parent',
    items: [
      { message: 'Foo' },
      { message: 'Bar' }
    ]
  }
})</pre> <p>Result:</p> <ul id="example-2" class="demo">Live examples are not available on DevDocs, sorry.</ul>  <p>You can also use <code>of</code> as the delimiter instead of <code>in</code>, so that it is closer to JavaScript’s syntax for iterators:</p> <pre class="highlight html" data-language="html">&lt;div v-for="item of items"&gt;&lt;/div&gt;</pre> <h3 id="Template-v-for">
Template <code>v-for</code>
</h3>
<p>Similar to template <code>v-if</code>, you can also use a <code>&lt;template&gt;</code> tag with <code>v-for</code> to render a block of multiple elements. For example:</p> <pre class="highlight html" data-language="html">&lt;ul&gt;
  &lt;template v-for="item in items"&gt;
    &lt;li&gt;{{ item.msg }}&lt;/li&gt;
    &lt;li class="divider"&gt;&lt;/li&gt;
  &lt;/template&gt;
&lt;/ul&gt;</pre> <h3 id="Object-v-for">
Object <code>v-for</code>
</h3>
<p>You can also use <code>v-for</code> to iterate through the properties of an object.</p> <pre class="highlight html" data-language="html">&lt;ul id="repeat-object" class="demo"&gt;
  &lt;li v-for="value in object"&gt;
    {{ value }}
  &lt;/li&gt;
&lt;/ul&gt;</pre> <pre class="highlight js" data-language="js">new Vue({
  el: '#repeat-object',
  data: {
    object: {
      firstName: 'John',
      lastName: 'Doe',
      age: 30
    }
  }
})</pre> <p>Result:</p> <ul id="repeat-object" class="demo">Live examples are not available on DevDocs, sorry.</ul>  <p>You can also provide a second argument for the key:</p> <pre class="highlight html" data-language="html">&lt;div v-for="(value, key) in object"&gt;
  {{ key }} : {{ value }}
&lt;/div&gt;</pre> <p>And another for the index:</p> <pre class="highlight html" data-language="html">&lt;div v-for="(value, key, index) in object"&gt;
  {{ index }}. {{ key }} : {{ value }}
&lt;/div&gt;</pre> <p class="tip">When iterating over an object, the order is based on the key enumeration order of <code>Object.keys()</code>, which is <strong>not</strong> guaranteed to be consistent across JavaScript engine implementations.</p> <h3 id="Range-v-for">
Range <code>v-for</code>
</h3>
<p><code>v-for</code> can also take an integer. In this case it will repeat the template that many times.</p> <pre class="highlight html" data-language="html">&lt;div&gt;
  &lt;span v-for="n in 10"&gt;{{ n }}&lt;/span&gt;
&lt;/div&gt;</pre> <p>Result:</p> <div id="range" class="demo">Live examples are not available on DevDocs, sorry.</div>  <h3 id="Components-and-v-for">
Components and <code>v-for</code>
</h3>
<blockquote> <p>This section assumes knowledge of <a href="../components/">Components</a>. Feel free to skip it and come back later.</p> </blockquote> <p>You can directly use <code>v-for</code> on a custom component, like any normal element:</p> <pre class="highlight html" data-language="html">&lt;my-component v-for="item in items" :key="item.id"&gt;&lt;/my-component&gt;</pre> <blockquote> <p>In 2.2.0+, when using <code>v-for</code> with a component, a <a href="../list/#key"><code>key</code></a> is now required.</p> </blockquote> <p>However, this won’t automatically pass any data to the component, because components have isolated scopes of their own. In order to pass the iterated data into the component, we should also use props:</p> <pre class="highlight html" data-language="html">&lt;my-component
  v-for="(item, index) in items"
  v-bind:item="item"
  v-bind:index="index"
  v-bind:key="item.id"&gt;
&lt;/my-component&gt;</pre> <p>The reason for not automatically injecting <code>item</code> into the component is because that makes the component tightly coupled to how <code>v-for</code> works. Being explicit about where its data comes from makes the component reusable in other situations.</p> <p>Here’s a complete example of a simple todo list:</p> <pre class="highlight html" data-language="html">&lt;div id="todo-list-example"&gt;
  &lt;input
    v-model="newTodoText"
    v-on:keyup.enter="addNewTodo"
    placeholder="Add a todo"
  &gt;
  &lt;ul&gt;
    &lt;li
      is="todo-item"
      v-for="(todo, index) in todos"
      v-bind:key="todo"
      v-bind:title="todo"
      v-on:remove="todos.splice(index, 1)"
    &gt;&lt;/li&gt;
  &lt;/ul&gt;
&lt;/div&gt;</pre> <pre class="highlight js" data-language="js">Vue.component('todo-item', {
  template: `
    &lt;li&gt;
      {{ title }}
      &lt;button v-on:click="$emit('remove')"&gt;X&lt;/button&gt;
    &lt;/li&gt;
  `,
  props: ['title']
})

new Vue({
  el: '#todo-list-example',
  data: {
    newTodoText: '',
    todos: [
      'Do the dishes',
      'Take out the trash',
      'Mow the lawn'
    ]
  },
  methods: {
    addNewTodo: function () {
      this.todos.push(this.newTodoText)
      this.newTodoText = ''
    }
  }
})</pre> <div id="todo-list-example" class="demo">Live examples are not available on DevDocs, sorry.</div>  <h3 id="v-for-with-v-if">
<code>v-for</code> with <code>v-if</code>
</h3>
<p>When they exist on the same node, <code>v-for</code> has a higher priority than <code>v-if</code>. That means the <code>v-if</code> will be run on each iteration of the loop separately. This is very useful when you want to render nodes for only <em>some</em> items, like below:</p> <pre class="highlight html" data-language="html">&lt;li v-for="todo in todos" v-if="!todo.isComplete"&gt;
  {{ todo }}
&lt;/li&gt;</pre> <p>The above only renders the todos that are not complete.</p> <p>If instead, your intent is to conditionally skip execution of the loop, you can place the <code>v-if</code> on a wrapper element (or <a href="../conditional/#Conditional-Groups-with-v-if-on-lt-template-gt"><code>&lt;template&gt;</code></a>). For example:</p> <pre class="highlight html" data-language="html">&lt;ul v-if="shouldRenderTodos"&gt;
  &lt;li v-for="todo in todos"&gt;
    {{ todo }}
  &lt;/li&gt;
&lt;/ul&gt;</pre> <h2 id="key">
<code>key</code>
</h2>
<p>When Vue is updating a list of elements rendered with <code>v-for</code>, it by default uses an “in-place patch” strategy. If the order of the data items has changed, instead of moving the DOM elements to match the order of the items, Vue will simply patch each element in-place and make sure it reflects what should be rendered at that particular index. This is similar to the behavior of <code>track-by="$index"</code> in Vue 1.x.</p> <p>This default mode is efficient, but only suitable <strong>when your list render output does not rely on child component state or temporary DOM state (e.g. form input values)</strong>.</p> <p>To give Vue a hint so that it can track each node’s identity, and thus reuse and reorder existing elements, you need to provide a unique <code>key</code> attribute for each item. An ideal value for <code>key</code> would be the unique id of each item. This special attribute is a rough equivalent to <code>track-by</code> in 1.x, but it works like an attribute, so you need to use <code>v-bind</code> to bind it to dynamic values (using shorthand here):</p> <pre class="highlight html" data-language="html">&lt;div v-for="item in items" :key="item.id"&gt;
  &lt;!-- content --&gt;
&lt;/div&gt;</pre> <p>It is recommended to provide a <code>key</code> with <code>v-for</code> whenever possible, unless the iterated DOM content is simple, or you are intentionally relying on the default behavior for performance gains.</p> <p>Since it’s a generic mechanism for Vue to identify nodes, the <code>key</code> also has other uses that are not specifically tied to <code>v-for</code>, as we will see later in the guide.</p> <h2 id="Array-Change-Detection">
Array Change Detection</h2>
<h3 id="Mutation-Methods">
Mutation Methods</h3>
<p>Vue wraps an observed array’s mutation methods so they will also trigger view updates. The wrapped methods are:</p> <ul> <li><code>push()</code></li> <li><code>pop()</code></li> <li><code>shift()</code></li> <li><code>unshift()</code></li> <li><code>splice()</code></li> <li><code>sort()</code></li> <li><code>reverse()</code></li> </ul> <p>You can open the console and play with the previous examples’ <code>items</code> array by calling their mutation methods. For example: <code>example1.items.push({ message: 'Baz' })</code>.</p> <h3 id="Replacing-an-Array">
Replacing an Array</h3>
<p>Mutation methods, as the name suggests, mutate the original array they are called on. In comparison, there are also non-mutating methods, e.g. <code>filter()</code>, <code>concat()</code> and <code>slice()</code>, which do not mutate the original array but <strong>always return a new array</strong>. When working with non-mutating methods, you can just replace the old array with the new one:</p> <pre class="highlight js" data-language="js">example1.items = example1.items.filter(function (item) {
  return item.message.match(/Foo/)
})</pre> <p>You might think this will cause Vue to throw away the existing DOM and re-render the entire list - luckily, that is not the case. Vue implements some smart heuristics to maximize DOM element reuse, so replacing an array with another array containing overlapping objects is a very efficient operation.</p> <h3 id="Caveats">
Caveats</h3>
<p>Due to limitations in JavaScript, Vue <strong>cannot</strong> detect the following changes to an array:</p> <ol> <li>When you directly set an item with the index, e.g. <code>vm.items[indexOfItem] = newValue</code>
</li> <li>When you modify the length of the array, e.g. <code>vm.items.length = newLength</code>
</li> </ol> <p>To overcome caveat 1, both of the following will accomplish the same as <code>vm.items[indexOfItem] = newValue</code>, but will also trigger state updates in the reactivity system:</p> <pre class="highlight js" data-language="js">// Vue.set
Vue.set(example1.items, indexOfItem, newValue)</pre> <pre class="highlight js" data-language="js">// Array.prototype.splice
example1.items.splice(indexOfItem, 1, newValue)</pre> <p>To deal with caveat 2, you can also use <code>splice</code>:</p> <pre class="highlight js" data-language="js">example1.items.splice(newLength)</pre> <h2 id="Displaying-Filtered-Sorted-Results">
Displaying Filtered/Sorted Results</h2>
<p>Sometimes we want to display a filtered or sorted version of an array without actually mutating or resetting the original data. In this case, you can create a computed property that returns the filtered or sorted array.</p> <p>For example:</p> <pre class="highlight html" data-language="html">&lt;li v-for="n in evenNumbers"&gt;{{ n }}&lt;/li&gt;</pre> <pre class="highlight js" data-language="js">data: {
  numbers: [ 1, 2, 3, 4, 5 ]
},
computed: {
  evenNumbers: function () {
    return this.numbers.filter(function (number) {
      return number % 2 === 0
    })
  }
}</pre> <p>In situations where computed properties are not feasible (e.g. inside nested <code>v-for</code> loops), you can just use a method:</p> <pre class="highlight html" data-language="html">&lt;li v-for="n in even(numbers)"&gt;{{ n }}&lt;/li&gt;</pre> <pre class="highlight js" data-language="js">data: {
  numbers: [ 1, 2, 3, 4, 5 ]
},
methods: {
  even: function (numbers) {
    return numbers.filter(function (number) {
      return number % 2 === 0
    })
  }
}</pre>
<div class="_attribution">
  <p class="_attribution-p">
    © 2013–2017 Evan You, Vue.js contributors<br>Licensed under the MIT License.<br>
    <a href="https://vuejs.org/v2/guide/list.html" class="_attribution-link" target="_blank">https://vuejs.org/v2/guide/list.html</a>
  </p>
</div>

			</div>
		</div>
	</section>

	</div>
</body>
</html>
