
<!DOCTYPE HTML>

<html lang="en">

<head>
  <meta charset="utf-8">
  <title>Components - Vue.js 2 - W3cubDocs</title>
  
  <meta name="description" content="Components are one of the most powerful features of Vue. They help you extend basic HTML elements to encapsulate reusable code. At a high level, &hellip;">
  <meta name="keywords" content="components, -, vue, js, vue~2">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="http://docs.w3cub.com/vue~2/guide/components/">
  <link href="/favicon.png" rel="icon">
  <link type="text/css" rel="stylesheet" href="/assets/application-50364fff564ce3b6327021805f3f00e2957b441cf27f576a7dd4ff63bbc47047.css">
  <script type="text/javascript" src="/assets/application-db64bfd54ceb42be11af7995804cf4902548419ceb79d509b0b7d62c22d98e6f.js"></script>
  <script src="/json/vue~2.js"></script>
  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-71174418-1']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>


</head>

<body>
	<div class="_app">
	<header class="_header">
  
  <form class="_search">
    <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
    <a class="_search-clear"></a>
    <div class="_search-tag"></div>
  </form>
  
  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/vue~2/" class="_nav-link" title="" style="margin-left:0;">Vue.js 2</a></span>
  
  <nav class="_nav">
    <a href="/app/" class="_nav-link ">App</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		<div class="_list">
			
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<div class="_page _vue">
				
<h1>Components</h1> <h2 id="What-are-Components">
What are Components?</h2>
<p>Components are one of the most powerful features of Vue. They help you extend basic HTML elements to encapsulate reusable code. At a high level, components are custom elements that Vue’s compiler attaches behavior to. In some cases, they may also appear as a native HTML element extended with the special <code>is</code> attribute.</p> <h2 id="Using-Components">
Using Components</h2>
<h3 id="Registration">
Registration</h3>
<p>We’ve learned in the previous sections that we can create a new Vue instance with:</p> <pre class="highlight js" data-language="js">new Vue({
  el: '#some-element',
  // options
})</pre> <p>To register a global component, you can use <code>Vue.component(tagName, options)</code>. For example:</p> <pre class="highlight js" data-language="js">Vue.component('my-component', {
  // options
})</pre> <p class="tip">Note that Vue does not enforce the <a href="http://www.w3.org/TR/custom-elements/#concepts" target="_blank" rel="external">W3C rules</a> for custom tag names (all-lowercase, must contain a hyphen) though following this convention is considered good practice.</p> <p>Once registered, a component can be used in an instance’s template as a custom element, <code>&lt;my-component&gt;&lt;/my-component&gt;</code>. Make sure the component is registered <strong>before</strong> you instantiate the root Vue instance. Here’s the full example:</p> <pre class="highlight html" data-language="html">&lt;div id="example"&gt;
  &lt;my-component&gt;&lt;/my-component&gt;
&lt;/div&gt;</pre> <pre class="highlight js" data-language="js">// register
Vue.component('my-component', {
  template: '&lt;div&gt;A custom component!&lt;/div&gt;'
})

// create a root instance
new Vue({
  el: '#example'
})</pre> <p>Which will render:</p> <pre class="highlight html" data-language="html">&lt;div id="example"&gt;
  &lt;div&gt;A custom component!&lt;/div&gt;
&lt;/div&gt;</pre> <div id="example" class="demo">Live examples are not available on DevDocs, sorry.</div>  <h3 id="Local-Registration">
Local Registration</h3>
<p>You don’t have to register every component globally. You can make a component available only in the scope of another instance/component by registering it with the <code>components</code> instance option:</p> <pre class="highlight js" data-language="js">var Child = {
  template: '&lt;div&gt;A custom component!&lt;/div&gt;'
}

new Vue({
  // ...
  components: {
    // &lt;my-component&gt; will only be available in parent's template
    'my-component': Child
  }
})</pre> <p>The same encapsulation applies for other registerable Vue features, such as directives.</p> <h3 id="DOM-Template-Parsing-Caveats">
DOM Template Parsing Caveats</h3>
<p>When using the DOM as your template (e.g. using the <code>el</code> option to mount an element with existing content), you will be subject to some restrictions that are inherent to how HTML works, because Vue can only retrieve the template content <strong>after</strong> the browser has parsed and normalized it. Most notably, some elements such as <code>&lt;ul&gt;</code>, <code>&lt;ol&gt;</code>, <code>&lt;table&gt;</code> and <code>&lt;select&gt;</code> have restrictions on what elements can appear inside them, and some elements such as <code>&lt;option&gt;</code> can only appear inside certain other elements.</p> <p>This will lead to issues when using custom components with elements that have such restrictions, for example:</p> <pre class="highlight html" data-language="html">&lt;table&gt;
  &lt;my-row&gt;...&lt;/my-row&gt;
&lt;/table&gt;</pre> <p>The custom component <code>&lt;my-row&gt;</code> will be hoisted out as invalid content, thus causing errors in the eventual rendered output. A workaround is to use the <code>is</code> special attribute:</p> <pre class="highlight html" data-language="html">&lt;table&gt;
  &lt;tr is="my-row"&gt;&lt;/tr&gt;
&lt;/table&gt;</pre> <p><strong>It should be noted that these limitations do not apply if you are using string templates from one of the following sources</strong>:</p> <ul> <li><code>&lt;script type="text/x-template"&gt;</code></li> <li>JavaScript inline template strings</li> <li>
<code>.vue</code> components</li> </ul> <p>Therefore, prefer using string templates whenever possible.</p> <h3 id="data-Must-Be-a-Function">
<code>data</code> Must Be a Function</h3>
<p>Most of the options that can be passed into the Vue constructor can be used in a component, with one special case: <code>data</code> must be function. In fact, if you try this:</p> <pre class="highlight js" data-language="js">Vue.component('my-component', {
  template: '&lt;span&gt;{{ message }}&lt;/span&gt;',
  data: {
    message: 'hello'
  }
})</pre> <p>Then Vue will halt and emit warnings in the console, telling you that <code>data</code> must be a function for component instances. It’s good to understand why the rules exist though, so let’s cheat.</p> <pre class="highlight html" data-language="html">&lt;div id="example-2"&gt;
  &lt;simple-counter&gt;&lt;/simple-counter&gt;
  &lt;simple-counter&gt;&lt;/simple-counter&gt;
  &lt;simple-counter&gt;&lt;/simple-counter&gt;
&lt;/div&gt;</pre> <pre class="highlight js" data-language="js">var data = { counter: 0 }

Vue.component('simple-counter', {
  template: '&lt;button v-on:click="counter += 1"&gt;{{ counter }}&lt;/button&gt;',
  // data is technically a function, so Vue won't
  // complain, but we return the same object
  // reference for each component instance
  data: function () {
    return data
  }
})

new Vue({
  el: '#example-2'
})</pre> <div id="example-2" class="demo">Live examples are not available on DevDocs, sorry.</div>  <p>Since all three component instances share the same <code>data</code> object, incrementing one counter increments them all! Ouch. Let’s fix this by instead returning a fresh data object:</p> <pre class="highlight js" data-language="js">data: function () {
  return {
    counter: 0
  }
}</pre> <p>Now all our counters each have their own internal state:</p> <div id="example-2-5" class="demo">Live examples are not available on DevDocs, sorry.</div>  <h3 id="Composing-Components">
Composing Components</h3>
<p>Components are meant to be used together, most commonly in parent-child relationships: component A may use component B in its own template. They inevitably need to communicate to one another: the parent may need to pass data down to the child, and the child may need to inform the parent of something that happened in the child. However, it is also very important to keep the parent and the child as decoupled as possible via a clearly-defined interface. This ensures each component’s code can be written and reasoned about in relative isolation, thus making them more maintainable and potentially easier to reuse.</p> <p>In Vue.js, the parent-child component relationship can be summarized as <strong>props down, events up</strong>. The parent passes data down to the child via <strong>props</strong>, and the child sends messages to the parent via <strong>events</strong>. Let’s see how they work next.</p> <p style="text-align: center"><br> <img style="width:300px" src="https://vuejs.org/images/props-events.png" alt="props down, events up"><br></p> <h2 id="Props">
Props</h2>
<h3 id="Passing-Data-with-Props">
Passing Data with Props</h3>
<p>Every component instance has its own <strong>isolated scope</strong>. This means you cannot (and should not) directly reference parent data in a child component’s template. Data can be passed down to child components using <strong>props</strong>.</p> <p>A prop is a custom attribute for passing information from parent components. A child component needs to explicitly declare the props it expects to receive using the <a href="../../api/#props"><code>props</code> option</a>:</p> <pre class="highlight js" data-language="js">Vue.component('child', {
  // declare the props
  props: ['message'],
  // just like data, the prop can be used inside templates
  // and is also made available in the vm as this.message
  template: '&lt;span&gt;{{ message }}&lt;/span&gt;'
})</pre> <p>Then we can pass a plain string to it like so:</p> <pre class="highlight html" data-language="html">&lt;child message="hello!"&gt;&lt;/child&gt;</pre> <p>Result:</p> <div id="prop-example-1" class="demo">Live examples are not available on DevDocs, sorry.</div>  <h3 id="camelCase-vs-kebab-case">
camelCase vs. kebab-case</h3>
<p>HTML attributes are case-insensitive, so when using non-string templates, camelCased prop names need to use their kebab-case (hyphen-delimited) equivalents:</p> <pre class="highlight js" data-language="js">Vue.component('child', {
  // camelCase in JavaScript
  props: ['myMessage'],
  template: '&lt;span&gt;{{ myMessage }}&lt;/span&gt;'
})</pre> <pre class="highlight html" data-language="html">&lt;!-- kebab-case in HTML --&gt;
&lt;child my-message="hello!"&gt;&lt;/child&gt;</pre> <p>Again, if you’re using string templates, then this limitation does not apply.</p> <h3 id="Dynamic-Props">
Dynamic Props</h3>
<p>Similar to binding a normal attribute to an expression, we can also use <code>v-bind</code> for dynamically binding props to data on the parent. Whenever the data is updated in the parent, it will also flow down to the child:</p> <pre class="highlight html" data-language="html">&lt;div&gt;
  &lt;input v-model="parentMsg"&gt;
  &lt;br&gt;
  &lt;child v-bind:my-message="parentMsg"&gt;&lt;/child&gt;
&lt;/div&gt;</pre> <p>It’s often simpler to use the shorthand syntax for <code>v-bind</code>:</p> <pre class="highlight html" data-language="html">&lt;child :my-message="parentMsg"&gt;&lt;/child&gt;</pre> <p>Result:</p> <div id="demo-2" class="demo">Live examples are not available on DevDocs, sorry.</div>  <h3 id="Literal-vs-Dynamic">
Literal vs. Dynamic</h3>
<p>A common mistake beginners tend to make is attempting to pass down a number using the literal syntax:</p> <pre class="highlight html" data-language="html">&lt;!-- this passes down a plain string "1" --&gt;
&lt;comp some-prop="1"&gt;&lt;/comp&gt;</pre> <p>However, since this is a literal prop, its value is passed down as a plain string <code>"1"</code> instead of an actual number. If we want to pass down an actual JavaScript number, we need to use <code>v-bind</code> so that its value is evaluated as a JavaScript expression:</p> <pre class="highlight html" data-language="html">&lt;!-- this passes down an actual number --&gt;
&lt;comp v-bind:some-prop="1"&gt;&lt;/comp&gt;</pre> <h3 id="One-Way-Data-Flow">
One-Way Data Flow</h3>
<p>All props form a <strong>one-way-down</strong> binding between the child property and the parent one: when the parent property updates, it will flow down to the child, but not the other way around. This prevents child components from accidentally mutating the parent’s state, which can make your app’s data flow harder to reason about.</p> <p>In addition, every time the parent component is updated, all props in the child component will be refreshed with the latest value. This means you should <strong>not</strong> attempt to mutate a prop inside a child component. If you do, Vue will warn you in the console.</p> <p>There are usually two cases where it’s tempting to mutate a prop:</p> <ol> <li>
<p>The prop is used to only pass in an initial value, the child component simply wants to use it as a local data property afterwards;</p> </li> <li>
<p>The prop is passed in as a raw value that needs to be transformed.</p> </li> </ol> <p>The proper answer to these use cases are:</p> <ol> <li>
<p>Define a local data property that uses the prop’s initial value as its initial value:</p> <pre class="highlight js" data-language="js">props: ['initialCounter'],
data: function () {
  return { counter: this.initialCounter }
}</pre> </li> <li>
<p>Define a computed property that is computed from the prop’s value:</p> <pre class="highlight js" data-language="js">props: ['size'],
computed: {
  normalizedSize: function () {
    return this.size.trim().toLowerCase()
  }
}</pre> </li> </ol> <p class="tip">Note that objects and arrays in JavaScript are passed by reference, so if the prop is an array or object, mutating the object or array itself inside the child <strong>will</strong> affect parent state.</p> <h3 id="Prop-Validation">
Prop Validation</h3>
<p>It is possible for a component to specify requirements for the props it is receiving. If a requirement is not met, Vue will emit warnings. This is especially useful when you are authoring a component that is intended to be used by others.</p> <p>Instead of defining the props as an array of strings, you can use an object with validation requirements:</p> <pre class="highlight js" data-language="js">Vue.component('example', {
  props: {
    // basic type check (`null` means accept any type)
    propA: Number,
    // multiple possible types
    propB: [String, Number],
    // a required string
    propC: {
      type: String,
      required: true
    },
    // a number with default value
    propD: {
      type: Number,
      default: 100
    },
    // object/array defaults should be returned from a
    // factory function
    propE: {
      type: Object,
      default: function () {
        return { message: 'hello' }
      }
    },
    // custom validator function
    propF: {
      validator: function (value) {
        return value &gt; 10
      }
    }
  }
})</pre> <p>The <code>type</code> can be one of the following native constructors:</p> <ul> <li>String</li> <li>Number</li> <li>Boolean</li> <li>Function</li> <li>Object</li> <li>Array</li> </ul> <p>In addition, <code>type</code> can also be a custom constructor function and the assertion will be made with an <code>instanceof</code> check.</p> <p>When a prop validation fails, Vue will produce a console warning (if using the development build).</p> <h2 id="Custom-Events">
Custom Events</h2>
<p>We have learned that the parent can pass data down to the child using props, but how do we communicate back to the parent when something happens? This is where Vue’s custom event system comes in.</p> <h3 id="Using-v-on-with-Custom-Events">
Using <code>v-on</code> with Custom Events</h3>
<p>Every Vue instance implements an <a href="../../api/#Instance-Methods-Events">events interface</a>, which means it can:</p> <ul> <li>Listen to an event using <code>$on(eventName)</code>
</li> <li>Trigger an event using <code>$emit(eventName)</code>
</li> </ul> <p class="tip">Note that Vue’s event system is separate from the browser’s <a href="https://developer.mozilla.org/en-US/docs/Web/API/EventTarget" target="_blank" rel="external">EventTarget API</a>. Though they work similarly, <code>$on</code> and <code>$emit</code> are <strong>not</strong> aliases for <code>addEventListener</code> and <code>dispatchEvent</code>.</p> <p>In addition, a parent component can listen to the events emitted from a child component using <code>v-on</code> directly in the template where the child component is used.</p> <p class="tip">You cannot use <code>$on</code> to listen to events emitted by children. You must use <code>v-on</code> directly in the template, as in the example below.</p> <p>Here’s an example:</p> <pre class="highlight html" data-language="html">&lt;div id="counter-event-example"&gt;
  &lt;p&gt;{{ total }}&lt;/p&gt;
  &lt;button-counter v-on:increment="incrementTotal"&gt;&lt;/button-counter&gt;
  &lt;button-counter v-on:increment="incrementTotal"&gt;&lt;/button-counter&gt;
&lt;/div&gt;</pre> <pre class="highlight js" data-language="js">Vue.component('button-counter', {
  template: '&lt;button v-on:click="increment"&gt;{{ counter }}&lt;/button&gt;',
  data: function () {
    return {
      counter: 0
    }
  },
  methods: {
    increment: function () {
      this.counter += 1
      this.$emit('increment')
    }
  },
})

new Vue({
  el: '#counter-event-example',
  data: {
    total: 0
  },
  methods: {
    incrementTotal: function () {
      this.total += 1
    }
  }
})</pre> <div id="counter-event-example" class="demo">Live examples are not available on DevDocs, sorry.</div>  <p>In this example, it’s important to note that the child component is still completely decoupled from what happens outside of it. All it does is report information about its own activity, just in case a parent component might care.</p> <h4 id="Binding-Native-Events-to-Components">
Binding Native Events to Components</h4>
<p>There may be times when you want to listen for a native event on the root element of a component. In these cases, you can use the <code>.native</code> modifier for <code>v-on</code>. For example:</p> <pre class="highlight html" data-language="html">&lt;my-component v-on:click.native="doTheThing"&gt;&lt;/my-component&gt;</pre> <h3 id="Form-Input-Components-using-Custom-Events">
Form Input Components using Custom Events</h3>
<p>Custom events can also be used to create custom inputs that work with <code>v-model</code>. Remember:</p> <pre class="highlight html" data-language="html">&lt;input v-model="something"&gt;</pre> <p>is just syntactic sugar for:</p> <pre class="highlight html" data-language="html">&lt;input
  v-bind:value="something"
  v-on:input="something = $event.target.value"&gt;</pre> <p>When used with a component, this simplifies to:</p> <pre class="highlight html" data-language="html">&lt;custom-input
  :value="something"
  @input="value =&gt; { something = value }"&gt;
&lt;/custom-input&gt;</pre> <p>So for a component to work with <code>v-model</code>, it should (these can be configured in 2.2.0+):</p> <ul> <li>accept a <code>value</code> prop</li> <li>emit an <code>input</code> event with the new value</li> </ul> <p>Let’s see it in action with a very simple currency input:</p> <pre class="highlight html" data-language="html">&lt;currency-input v-model="price"&gt;&lt;/currency-input&gt;</pre> <pre class="highlight js" data-language="js">Vue.component('currency-input', {
  template: `
    &lt;span&gt;
      $
      &lt;input
        ref="input"
        v-bind:value="value"
        v-on:input="updateValue($event.target.value)"&gt;
    &lt;/span&gt;
  `,
  props: ['value'],
  methods: {
    // Instead of updating the value directly, this
    // method is used to format and place constraints
    // on the input's value
    updateValue: function (value) {
      var formattedValue = value
        // Remove whitespace on either side
        .trim()
        // Shorten to 2 decimal places
        .slice(0, value.indexOf('.') + 3)
      // If the value was not already normalized,
      // manually override it to conform
      if (formattedValue !== value) {
        this.$refs.input.value = formattedValue
      }
      // Emit the number value through the input event
      this.$emit('input', Number(formattedValue))
    }
  }
})</pre> <div id="currency-input-example" class="demo">Live examples are not available on DevDocs, sorry.</div>  <p>The implementation above is pretty naive though. For example, users are allowed to enter multiple periods and even letters sometimes - yuck! So for those that want to see a non-trivial example, here’s a more robust currency filter:</p> <iframe width="100%" height="300" src="https://jsfiddle.net/chrisvfritz/1oqjojjx/embedded/result,html,js" allowfullscreen="allowfullscreen" frameborder="0" sandbox="allow-forms allow-scripts allow-same-origin"></iframe> <h3 id="Customizing-Component-v-model">
Customizing Component <code>v-model</code>
</h3>
<blockquote> <p>New in 2.2.0</p> </blockquote> <p>By default, <code>v-model</code> on a component uses <code>value</code> as the prop and <code>input</code> as the event, but some input types such as checkboxes and radio buttons may want to use the <code>value</code> prop for a different purpose. Using the <code>model</code> option can avoid the conflict in such cases:</p> <pre class="highlight js" data-language="js">Vue.component('my-checkbox', {
  model: {
    prop: 'checked',
    event: 'change'
  },
  props: {
    // this allows using the `value` prop for a different purpose
    value: String
  },
  // ...
})</pre> <pre class="highlight html" data-language="html">&lt;my-checkbox v-model="foo" value="some value"&gt;&lt;/my-checkbox&gt;</pre> <p>The above will be equivalent to:</p> <pre class="highlight html" data-language="html">&lt;my-checkbox
  :checked="foo"
  @change="val =&gt; { foo = val }"
  value="some value"&gt;
&lt;/my-checkbox&gt;</pre> <h3 id="Non-Parent-Child-Communication">
Non Parent-Child Communication</h3>
<p>Sometimes two components may need to communicate with one-another but they are not parent/child to each other. In simple scenarios, you can use an empty Vue instance as a central event bus:</p> <pre class="highlight js" data-language="js">var bus = new Vue()</pre> <pre class="highlight js" data-language="js">// in component A's method
bus.$emit('id-selected', 1)</pre> <pre class="highlight js" data-language="js">// in component B's created hook
bus.$on('id-selected', function (id) {
  // ...
})</pre> <p>In more complex cases, you should consider employing a dedicated <a href="../state-management/">state-management pattern</a>.</p> <h2 id="Content-Distribution-with-Slots">
Content Distribution with Slots</h2>
<p>When using components, it is often desired to compose them like this:</p> <pre class="highlight html" data-language="html">&lt;app&gt;
  &lt;app-header&gt;&lt;/app-header&gt;
  &lt;app-footer&gt;&lt;/app-footer&gt;
&lt;/app&gt;</pre> <p>There are two things to note here:</p> <ol> <li>
<p>The <code>&lt;app&gt;</code> component does not know what content may be present inside its mount target. It is decided by whatever parent component that is using <code>&lt;app&gt;</code>.</p> </li> <li>
<p>The <code>&lt;app&gt;</code> component very likely has its own template.</p> </li> </ol> <p>To make the composition work, we need a way to interweave the parent “content” and the component’s own template. This is a process called <strong>content distribution</strong> (or “transclusion” if you are familiar with Angular). Vue.js implements a content distribution API that is modeled after the current <a href="https://github.com/w3c/webcomponents/blob/gh-pages/proposals/Slots-Proposal.md" target="_blank" rel="external">Web Components spec draft</a>, using the special <code>&lt;slot&gt;</code> element to serve as distribution outlets for the original content.</p> <h3 id="Compilation-Scope">
Compilation Scope</h3>
<p>Before we dig into the API, let’s first clarify which scope the contents are compiled in. Imagine a template like this:</p> <pre class="highlight html" data-language="html">&lt;child-component&gt;
  {{ message }}
&lt;/child-component&gt;</pre> <p>Should the <code>message</code> be bound to the parent’s data or the child data? The answer is the parent. A simple rule of thumb for component scope is:</p> <blockquote> <p>Everything in the parent template is compiled in parent scope; everything in the child template is compiled in child scope.</p> </blockquote> <p>A common mistake is trying to bind a directive to a child property/method in the parent template:</p> <pre class="highlight html" data-language="html">&lt;!-- does NOT work --&gt;
&lt;child-component v-show="someChildProperty"&gt;&lt;/child-component&gt;</pre> <p>Assuming <code>someChildProperty</code> is a property on the child component, the example above would not work. The parent’s template is not aware of the state of a child component.</p> <p>If you need to bind child-scope directives on a component root node, you should do so in the child component’s own template:</p> <pre class="highlight js" data-language="js">Vue.component('child-component', {
  // this does work, because we are in the right scope
  template: '&lt;div v-show="someChildProperty"&gt;Child&lt;/div&gt;',
  data: function () {
    return {
      someChildProperty: true
    }
  }
})</pre> <p>Similarly, distributed content will be compiled in the parent scope.</p> <h3 id="Single-Slot">
Single Slot</h3>
<p>Parent content will be <strong>discarded</strong> unless the child component template contains at least one <code>&lt;slot&gt;</code> outlet. When there is only one slot with no attributes, the entire content fragment will be inserted at its position in the DOM, replacing the slot itself.</p> <p>Anything originally inside the <code>&lt;slot&gt;</code> tags is considered <strong>fallback content</strong>. Fallback content is compiled in the child scope and will only be displayed if the hosting element is empty and has no content to be inserted.</p> <p>Suppose we have a component called <code>my-component</code> with the following template:</p> <pre class="highlight html" data-language="html">&lt;div&gt;
  &lt;h2&gt;I'm the child title&lt;/h2&gt;
  &lt;slot&gt;
    This will only be displayed if there is no content
    to be distributed.
  &lt;/slot&gt;
&lt;/div&gt;</pre> <p>And a parent that uses the component:</p> <pre class="highlight html" data-language="html">&lt;div&gt;
  &lt;h1&gt;I'm the parent title&lt;/h1&gt;
  &lt;my-component&gt;
    &lt;p&gt;This is some original content&lt;/p&gt;
    &lt;p&gt;This is some more original content&lt;/p&gt;
  &lt;/my-component&gt;
&lt;/div&gt;</pre> <p>The rendered result will be:</p> <pre class="highlight html" data-language="html">&lt;div&gt;
  &lt;h1&gt;I'm the parent title&lt;/h1&gt;
  &lt;div&gt;
    &lt;h2&gt;I'm the child title&lt;/h2&gt;
    &lt;p&gt;This is some original content&lt;/p&gt;
    &lt;p&gt;This is some more original content&lt;/p&gt;
  &lt;/div&gt;
&lt;/div&gt;</pre> <h3 id="Named-Slots">
Named Slots</h3>
<p><code>&lt;slot&gt;</code> elements have a special attribute, <code>name</code>, which can be used to further customize how content should be distributed. You can have multiple slots with different names. A named slot will match any element that has a corresponding <code>slot</code> attribute in the content fragment.</p> <p>There can still be one unnamed slot, which is the <strong>default slot</strong> that serves as a catch-all outlet for any unmatched content. If there is no default slot, unmatched content will be discarded.</p> <p>For example, suppose we have an <code>app-layout</code> component with the following template:</p> <pre class="highlight html" data-language="html">&lt;div class="container"&gt;
  &lt;header&gt;
    &lt;slot name="header"&gt;&lt;/slot&gt;
  &lt;/header&gt;
  &lt;main&gt;
    &lt;slot&gt;&lt;/slot&gt;
  &lt;/main&gt;
  &lt;footer&gt;
    &lt;slot name="footer"&gt;&lt;/slot&gt;
  &lt;/footer&gt;
&lt;/div&gt;</pre> <p>Parent markup:</p> <pre class="highlight html" data-language="html">&lt;app-layout&gt;
  &lt;h1 slot="header"&gt;Here might be a page title&lt;/h1&gt;

  &lt;p&gt;A paragraph for the main content.&lt;/p&gt;
  &lt;p&gt;And another one.&lt;/p&gt;

  &lt;p slot="footer"&gt;Here's some contact info&lt;/p&gt;
&lt;/app-layout&gt;</pre> <p>The rendered result will be:</p> <pre class="highlight html" data-language="html">&lt;div class="container"&gt;
  &lt;header&gt;
    &lt;h1&gt;Here might be a page title&lt;/h1&gt;
  &lt;/header&gt;
  &lt;main&gt;
    &lt;p&gt;A paragraph for the main content.&lt;/p&gt;
    &lt;p&gt;And another one.&lt;/p&gt;
  &lt;/main&gt;
  &lt;footer&gt;
    &lt;p&gt;Here's some contact info&lt;/p&gt;
  &lt;/footer&gt;
&lt;/div&gt;</pre> <p>The content distribution API is a very useful mechanism when designing components that are meant to be composed together.</p> <h3 id="Scoped-Slots">
Scoped Slots</h3>
<blockquote> <p>New in 2.1.0</p> </blockquote> <p>A scoped slot is a special type of slot that functions as a reusable template (that can be passed data to) instead of already-rendered-elements.</p> <p>In a child component, simply pass data into a slot as if you are passing props to a component:</p> <pre class="highlight html" data-language="html">&lt;div class="child"&gt;
  &lt;slot text="hello from child"&gt;&lt;/slot&gt;
&lt;/div&gt;</pre> <p>In the parent, a <code>&lt;template&gt;</code> element with a special attribute <code>scope</code> indicates that it is a template for a scoped slot. The value of <code>scope</code> is the name of a temporary variable that holds the props object passed from the child:</p> <pre class="highlight html" data-language="html">&lt;div class="parent"&gt;
  &lt;child&gt;
    &lt;template scope="props"&gt;
      &lt;span&gt;hello from parent&lt;/span&gt;
      &lt;span&gt;{{ props.text }}&lt;/span&gt;
    &lt;/template&gt;
  &lt;/child&gt;
&lt;/div&gt;</pre> <p>If we render the above, the output will be:</p> <pre class="highlight html" data-language="html">&lt;div class="parent"&gt;
  &lt;div class="child"&gt;
    &lt;span&gt;hello from parent&lt;/span&gt;
    &lt;span&gt;hello from child&lt;/span&gt;
  &lt;/div&gt;
&lt;/div&gt;</pre> <p>A more typical use case for scoped slots would be a list component that allows the component consumer to customize how each item in the list should be rendered:</p> <pre class="highlight html" data-language="html">&lt;my-awesome-list :items="items"&gt;
  &lt;!-- scoped slot can be named too --&gt;
  &lt;template slot="item" scope="props"&gt;
    &lt;li class="my-fancy-item"&gt;{{ props.text }}&lt;/li&gt;
  &lt;/template&gt;
&lt;/my-awesome-list&gt;</pre> <p>And the template for the list component:</p> <pre class="highlight html" data-language="html">&lt;ul&gt;
  &lt;slot name="item"
    v-for="item in items"
    :text="item.text"&gt;
    &lt;!-- fallback content here --&gt;
  &lt;/slot&gt;
&lt;/ul&gt;</pre> <h2 id="Dynamic-Components">
Dynamic Components</h2>
<p>You can use the same mount point and dynamically switch between multiple components using the reserved <code>&lt;component&gt;</code> element and dynamically bind to its <code>is</code> attribute:</p> <pre class="highlight js" data-language="js">var vm = new Vue({
  el: '#example',
  data: {
    currentView: 'home'
  },
  components: {
    home: { /* ... */ },
    posts: { /* ... */ },
    archive: { /* ... */ }
  }
})</pre> <pre class="highlight html" data-language="html">&lt;component v-bind:is="currentView"&gt;
  &lt;!-- component changes when vm.currentView changes! --&gt;
&lt;/component&gt;</pre> <p>If you prefer, you can also bind directly to component objects:</p> <pre class="highlight js" data-language="js">var Home = {
  template: '&lt;p&gt;Welcome home!&lt;/p&gt;'
}

var vm = new Vue({
  el: '#example',
  data: {
    currentView: Home
  }
})</pre> <h3 id="keep-alive">
<code>keep-alive</code>
</h3>
<p>If you want to keep the switched-out components in memory so that you can preserve their state or avoid re-rendering, you can wrap a dynamic component in a <code>&lt;keep-alive&gt;</code> element:</p> <pre class="highlight html" data-language="html">&lt;keep-alive&gt;
  &lt;component :is="currentView"&gt;
    &lt;!-- inactive components will be cached! --&gt;
  &lt;/component&gt;
&lt;/keep-alive&gt;</pre> <p>Check out more details on <code>&lt;keep-alive&gt;</code> in the <a href="../../api/#keep-alive">API reference</a>.</p> <h2 id="Misc">
Misc</h2>
<h3 id="Authoring-Reusable-Components">
Authoring Reusable Components</h3>
<p>When authoring components, it’s good to keep in mind whether you intend to reuse it somewhere else later. It’s OK for one-off components to be tightly coupled, but reusable components should define a clean public interface and make no assumptions about the context it’s used in.</p> <p>The API for a Vue component comes in three parts - props, events, and slots:</p> <ul> <li>
<p><strong>Props</strong> allow the external environment to pass data into the component</p> </li> <li>
<p><strong>Events</strong> allow the component to trigger side effects in the external environment</p> </li> <li>
<p><strong>Slots</strong> allow the external environment to compose the component with extra content.</p> </li> </ul> <p>With the dedicated shorthand syntaxes for <code>v-bind</code> and <code>v-on</code>, the intents can be clearly and succinctly conveyed in the template:</p> <pre class="highlight html" data-language="html">&lt;my-component
  :foo="baz"
  :bar="qux"
  @event-a="doThis"
  @event-b="doThat"
&gt;
  &lt;img slot="icon" src="..."&gt;
  &lt;p slot="main-text"&gt;Hello!&lt;/p&gt;
&lt;/my-component&gt;</pre> <h3 id="Child-Component-Refs">
Child Component Refs</h3>
<p>Despite the existence of props and events, sometimes you might still need to directly access a child component in JavaScript. To achieve this you have to assign a reference ID to the child component using <code>ref</code>. For example:</p> <pre class="highlight html" data-language="html">&lt;div id="parent"&gt;
  &lt;user-profile ref="profile"&gt;&lt;/user-profile&gt;
&lt;/div&gt;</pre> <pre class="highlight js" data-language="js">var parent = new Vue({ el: '#parent' })
// access child component instance
var child = parent.$refs.profile</pre> <p>When <code>ref</code> is used together with <code>v-for</code>, the ref you get will be an array or an object containing the child components mirroring the data source.</p> <p class="tip"><code>$refs</code> are only populated after the component has been rendered, and it is not reactive. It is only meant as an escape hatch for direct child manipulation - you should avoid using <code>$refs</code> in templates or computed properties.</p> <h3 id="Async-Components">
Async Components</h3>
<p>In large applications, we may need to divide the app into smaller chunks and only load a component from the server when it’s actually needed. To make that easier, Vue allows you to define your component as a factory function that asynchronously resolves your component definition. Vue will only trigger the factory function when the component actually needs to be rendered and will cache the result for future re-renders. For example:</p> <pre class="highlight js" data-language="js">Vue.component('async-example', function (resolve, reject) {
  setTimeout(function () {
    // Pass the component definition to the resolve callback
    resolve({
      template: '&lt;div&gt;I am async!&lt;/div&gt;'
    })
  }, 1000)
})</pre> <p>The factory function receives a <code>resolve</code> callback, which should be called when you have retrieved your component definition from the server. You can also call <code>reject(reason)</code> to indicate the load has failed. The <code>setTimeout</code> here is simply for demonstration; How to retrieve the component is entirely up to you. One recommended approach is to use async components together with <a href="https://webpack.js.org/guides/code-splitting-require/" target="_blank" rel="external">Webpack’s code-splitting feature</a>:</p> <pre class="highlight js" data-language="js">Vue.component('async-webpack-example', function (resolve) {
  // This special require syntax will instruct Webpack to
  // automatically split your built code into bundles which
  // are loaded over Ajax requests.
  require(['./my-async-component'], resolve)
})</pre> <p>You can also return a <code>Promise</code> in the factory function, so with Webpack 2 + ES2015 syntax you can do:</p> <pre class="highlight js" data-language="js">Vue.component(
  'async-webpack-example',
  () =&gt; import('./my-async-component')
)</pre> <p>When using <a href="../components/#Local-Registration">local registration</a>, you can also directly provide a function that returns a <code>Promise</code>:</p> <pre class="highlight js" data-language="js">new Vue({
  // ...
  components: {
    'my-component': () =&gt; import('./my-async-component')
  }
})</pre> <p class="tip">If you’re a <strong>Browserify</strong> user that would like to use async components, its creator has unfortunately <a href="https://github.com/substack/node-browserify/issues/58#issuecomment-21978224" target="_blank" rel="external">made it clear</a> that async loading “is not something that Browserify will ever support.” Officially, at least. The Browserify community has found <a href="https://github.com/vuejs/vuejs.org/issues/620" target="_blank" rel="external">some workarounds</a>, which may be helpful for existing and complex applications. For all other scenarios, we recommend simply using Webpack for built-in, first-class async support.</p> <h3 id="Component-Naming-Conventions">
Component Naming Conventions</h3>
<p>When registering components (or props), you can use kebab-case, camelCase, or TitleCase. Vue doesn’t care.</p> <pre class="highlight js" data-language="js">// in a component definition
components: {
  // register using kebab-case
  'kebab-cased-component': { /* ... */ },
  // register using camelCase
  'camelCasedComponent': { /* ... */ },
  // register using TitleCase
  'TitleCasedComponent': { /* ... */ }
}</pre> <p>Within HTML templates though, you have to use the kebab-case equivalents:</p> <pre class="highlight html" data-language="html">&lt;!-- always use kebab-case in HTML templates --&gt;
&lt;kebab-cased-component&gt;&lt;/kebab-cased-component&gt;
&lt;camel-cased-component&gt;&lt;/camel-cased-component&gt;
&lt;title-cased-component&gt;&lt;/title-cased-component&gt;</pre> <p>When using <em>string</em> templates however, we’re not bound by HTML’s case-insensitive restrictions. That means even in the template, you can reference your components and props using camelCase, TitleCase, or kebab-case:</p> <pre class="highlight html" data-language="html">&lt;!-- use whatever you want in string templates! --&gt;
&lt;my-component&gt;&lt;/my-component&gt;
&lt;myComponent&gt;&lt;/myComponent&gt;
&lt;MyComponent&gt;&lt;/MyComponent&gt;</pre> <p>If your component isn’t passed content via <code>slot</code> elements, you can even make it self-closing with a <code>/</code> after the name:</p> <pre class="highlight html" data-language="html">&lt;my-component/&gt;</pre> <p>Again, this <em>only</em> works within string templates, as self-closing custom elements are not valid HTML and your browser’s native parser will not understand them.</p> <h3 id="Recursive-Components">
Recursive Components</h3>
<p>Components can recursively invoke themselves in their own template. However, they can only do so with the <code>name</code> option:</p> <pre class="highlight js" data-language="js">name: 'unique-name-of-my-component'</pre> <p>When you register a component globally using <code>Vue.component</code>, the global ID is automatically set as the component’s <code>name</code> option.</p> <pre class="highlight js" data-language="js">Vue.component('unique-name-of-my-component', {
  // ...
})</pre> <p>If you’re not careful, recursive components can also lead to infinite loops:</p> <pre class="highlight js" data-language="js">name: 'stack-overflow',
template: '&lt;div&gt;&lt;stack-overflow&gt;&lt;/stack-overflow&gt;&lt;/div&gt;'</pre> <p>A component like the above will result in a “max stack size exceeded” error, so make sure recursive invocation is conditional (i.e. uses a <code>v-if</code> that will eventually be <code>false</code>).</p> <h3 id="Circular-References-Between-Components">
Circular References Between Components</h3>
<p>Let’s say you’re building a file directory tree, like in Finder or File Explorer. You might have a <code>tree-folder</code> component with this template:</p> <pre class="highlight html" data-language="html">&lt;p&gt;
  &lt;span&gt;{{ folder.name }}&lt;/span&gt;
  &lt;tree-folder-contents :children="folder.children"/&gt;
&lt;/p&gt;</pre> <p>Then a <code>tree-folder-contents</code> component with this template:</p> <pre class="highlight html" data-language="html">&lt;ul&gt;
  &lt;li v-for="child in children"&gt;
    &lt;tree-folder v-if="child.children" :folder="child"/&gt;
    &lt;span v-else&gt;{{ child.name }}&lt;/span&gt;
  &lt;/li&gt;
&lt;/ul&gt;</pre> <p>When you look closely, you’ll see that these components will actually be each other’s descendent <em>and</em> ancestor in the render tree - a paradox! When registering components globally with <code>Vue.component</code>, this paradox is resolved for you automatically. If that’s you, you can stop reading here.</p> <p>However, if you’re requiring/importing components using a <strong>module system</strong>, e.g. via Webpack or Browserify, you’ll get an error:</p> <pre class="highlight plain" data-language="plain">Failed to mount component: template or render function not defined.</pre> <p>To explain what’s happening, I’ll call our components A and B. The module system sees that it needs A, but first A needs B, but B needs A, but A needs B, etc, etc. It’s stuck in a loop, not knowing how to fully resolve either component without first resolving the other. To fix this, we need to give the module system a point at which it can say, “A needs B <em>eventually</em>, but there’s no need to resolve B first.”</p> <p>In our case, I’ll make that point the <code>tree-folder</code> component. We know the child that creates the paradox is the <code>tree-folder-contents</code> component, so we’ll wait until the <code>beforeCreate</code> lifecycle hook to register it:</p> <pre class="highlight js" data-language="js">beforeCreate: function () {
  this.$options.components.TreeFolderContents = require('./tree-folder-contents.vue')
}</pre> <p>Problem solved!</p> <h3 id="Inline-Templates">
Inline Templates</h3>
<p>When the <code>inline-template</code> special attribute is present on a child component, the component will use its inner content as its template, rather than treating it as distributed content. This allows more flexible template-authoring.</p> <pre class="highlight html" data-language="html">&lt;my-component inline-template&gt;
  &lt;div&gt;
    &lt;p&gt;These are compiled as the component's own template.&lt;/p&gt;
    &lt;p&gt;Not parent's transclusion content.&lt;/p&gt;
  &lt;/div&gt;
&lt;/my-component&gt;</pre> <p>However, <code>inline-template</code> makes the scope of your templates harder to reason about. As a best practice, prefer defining templates inside the component using the <code>template</code> option or in a <code>template</code> element in a <code>.vue</code> file.</p> <h3 id="X-Templates">
X-Templates</h3>
<p>Another way to define templates is inside of a script element with the type <code>text/x-template</code>, then referencing the template by an id. For example:</p> <pre class="highlight html" data-language="html">&lt;script type="text/x-template" id="hello-world-template"&gt;
  &lt;p&gt;Hello hello hello&lt;/p&gt;
&lt;/script&gt;</pre> <pre class="highlight js" data-language="js">Vue.component('hello-world', {
  template: '#hello-world-template'
})</pre> <p>These can be useful for demos with large templates or in extremely small applications, but should otherwise be avoided, because they separate templates from the rest of the component definition.</p> <h3 id="Cheap-Static-Components-with-v-once">
Cheap Static Components with <code>v-once</code>
</h3>
<p>Rendering plain HTML elements is very fast in Vue, but sometimes you might have a component that contains <strong>a lot</strong> of static content. In these cases, you can ensure that it’s only evaluated once and then cached by adding the <code>v-once</code> directive to the root element, like this:</p> <pre class="highlight js" data-language="js">Vue.component('terms-of-service', {
  template: '\
    &lt;div v-once&gt;\
      &lt;h1&gt;Terms of Service&lt;/h1&gt;\
      ... a lot of static content ...\
    &lt;/div&gt;\
  '
})</pre>
<div class="_attribution">
  <p class="_attribution-p">
    © 2013–2017 Evan You, Vue.js contributors<br>Licensed under the MIT License.<br>
    <a href="https://vuejs.org/v2/guide/components.html" class="_attribution-link" target="_blank">https://vuejs.org/v2/guide/components.html</a>
  </p>
</div>

			</div>
		</div>
	</section>

	</div>
</body>
</html>
