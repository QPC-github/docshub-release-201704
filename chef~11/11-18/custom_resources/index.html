
<!DOCTYPE HTML>

<html lang="en">

<head>
  <meta charset="utf-8">
  <title>Custom Resources - Chef 11 - W3cubDocs</title>
  
  <meta name="description" content=" Note ">
  <meta name="keywords" content="about, custom, resources, -, chef, chef~11">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="http://docs.w3cub.com/chef~11/11-18/custom_resources/">
  <link href="/favicon.png" rel="icon">
  <link type="text/css" rel="stylesheet" href="/assets/application-50364fff564ce3b6327021805f3f00e2957b441cf27f576a7dd4ff63bbc47047.css">
  <script type="text/javascript" src="/assets/application-db64bfd54ceb42be11af7995804cf4902548419ceb79d509b0b7d62c22d98e6f.js"></script>
  <script src="/json/chef~11.js"></script>
  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-71174418-1']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>


</head>

<body>
	<div class="_app">
	<header class="_header">
  
  <form class="_search">
    <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
    <a class="_search-clear"></a>
    <div class="_search-tag"></div>
  </form>
  
  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/chef~11/" class="_nav-link" title="" style="margin-left:0;">Chef 11</a></span>
  
  <nav class="_nav">
    <a href="/app/" class="_nav-link ">App</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		<div class="_list">
			
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<div class="_page _sphinx_simple">
				
<h1 id="about-custom-resources">About Custom Resources</h1> <div class="admonition note"> <p class="first admonition-title">Note</p> <p class="last">A “custom resource” is the new way to refer to any style of custom resources, including lightweight resources (LWRPs), heavyweight resources (HWRPs), definitions, or any other implementation of a custom resource. This change was made in the chef-client 12.5 release, but applied retroactively. A new and improved approach for building custom resources was added in chef-client 12.5 and the term “custom resource” now refers to any method of building a custom resource for releases of Chef prior to 12.5, and then only the new method starting with 12.5.</p> </div> <p>A LWRP is a part of a cookbook that is used to extend the chef-client in a way that allows custom actions to be defined, and then used in recipes in much the same way as any platform resource. In other words: a LWRP is a custom resource. A custom resource has two principal components:</p> <ul class="simple"> <li>A custom resource that defines a set of actions and attributes that is located in a cookbook’s <code class="docutils literal">/resources</code> directory</li> <li>A custom provider that tells the chef-client how to handle each action, what to do if certain conditions are met, and so on that is located in a cookbook’s <code class="docutils literal">/providers</code> directory</li> </ul> <p>A custom provider is typically built in a way that leverages the core resources that are built into Chef, but they may also be built using Ruby.</p> <p>Once created, a custom resource becomes a Ruby class. During each chef-client run, the chef-client will read the custom resource from a recipe and will process it alongside all other resources. When it is time to configure the node, the chef-client will use the custom provider to determine the steps required to bring the system into the desired state.</p>  <h2 id="file-locations">File Locations</h2> <p>Custom resources and providers are loaded from files that are saved in the following cookbook sub-directories:</p> <table class="docutils"> <colgroup> <col width="13%"> <col width="88%"> </colgroup> <thead valign="bottom"> <tr class="row-odd">
<th class="head">Directory</th> <th class="head">Description</th> </tr> </thead> <tbody valign="top"> <tr class="row-even">
<td><code class="docutils literal">providers/</code></td> <td>The sub-directory in which custom providers are located.</td> </tr> <tr class="row-odd">
<td><code class="docutils literal">resources/</code></td> <td>The sub-directory in which custom resources are located.</td> </tr> </tbody> </table>   <h2 id="resource-names">Resource Names</h2> <p>The naming patterns of custom resources and providers are determined by the name of the cookbook and by the name of the files in the <code class="docutils literal">resources/</code> and <code class="docutils literal">providers/</code> sub-directories. For example, if a cookbook named <code class="docutils literal">example</code> was downloaded to the chef-repo, it would be located at <code class="docutils literal">/cookbooks/example/</code>. If that cookbook contained two resources and two providers, the following files would be part of the <code class="docutils literal">resources/</code> directory:</p> <table class="docutils"> <colgroup> <col width="33%"> <col width="33%"> <col width="33%"> </colgroup> <thead valign="bottom"> <tr class="row-odd">
<th class="head">Files</th> <th class="head">Resource Name</th> <th class="head">Generated Class</th> </tr> </thead> <tbody valign="top"> <tr class="row-even">
<td><code class="docutils literal">default.rb</code></td> <td>example</td> <td>Chef::Resource::Example</td> </tr> <tr class="row-odd">
<td><code class="docutils literal">custom.rb</code></td> <td>example_custom</td> <td>Chef::Resource::ExampleCustom</td> </tr> </tbody> </table> <p>And the following files would be part of the <code class="docutils literal">providers/</code> directory:</p> <table class="docutils"> <colgroup> <col width="33%"> <col width="33%"> <col width="33%"> </colgroup> <thead valign="bottom"> <tr class="row-odd">
<th class="head">Files</th> <th class="head">Provider Name</th> <th class="head">Generated Class</th> </tr> </thead> <tbody valign="top"> <tr class="row-even">
<td><code class="docutils literal">default.rb</code></td> <td>example</td> <td>Chef::Provider::Example</td> </tr> <tr class="row-odd">
<td><code class="docutils literal">custom.rb</code></td> <td>example_custom</td> <td>Chef::Provider::ExampleCustom</td> </tr> </tbody> </table>   <h2 id="platform-vs-lightweight">Platform vs. Lightweight</h2> <p>The following example uses the <strong>file</strong> resource to show the difference between it and what it would look like if it were a custom resource.</p> <pre class="highlight-ruby" data-language="ruby">require 'chef/resource'

class Chef
  class Resource
    class File &lt; Chef::Resource

      def initialize(name, collection=nil, node=nil)
        super(name, collection, node)
        @resource_name = :file
        @path = name
        @backup = 5
        @action = 'create'
        @allowed_actions.push(:create, :delete, :touch, :create_if_missing)
      end

      def backup(arg=nil)
        set_or_return(
          :backup,
          arg,
          :kind_of =&gt; [ Integer, FalseClass ]
        )
      end

      def checksum(arg=nil)
        set_or_return(
          :checksum,
          arg,
          :regex =&gt; /^[a-zA-Z0-9]{64}$/
        )
      end

      def group(arg=nil)
        set_or_return(
          :group,
          arg,
          :regex =&gt; [ /^([a-z]|[A-Z]|[0-9]|_|-)+$/, /^\d+$/ ]
        )
      end

      def mode(arg=nil)
        set_or_return(
          :mode,
          arg,
          :regex =&gt; /^0?\d{3,4}$/
        )
      end

      def owner(arg=nil)
        set_or_return(
          :owner,
          arg,
          :regex =&gt; [ /^([a-z]|[A-Z]|[0-9]|_|-)+$/, /^\d+$/ ]
        )
      end

      def path(arg=nil)
        set_or_return(
          :path,
          arg,
          :kind_of =&gt; String
        )
      end

    end
  end
end</pre> <p>The preceding code is simple, traditional Ruby. A number of getter/setter methods are created and inputs are validated against criteria, like regular expressions, strings, true/false, and so on. The custom resource looks like this:</p> <pre class="highlight-ruby" data-language="ruby">actions :create, :delete, :touch, :create_if_missing

attribute :backup,   :kind_of =&gt; [ Integer, FalseClass ]
attribute :group,    :regex =&gt; [ /^([a-z]|[A-Z]|[0-9]|_|-)+$/, /^\d+$/ ]
attribute :mode,     :regex =&gt; /^0?\d{3,4}$/
attribute :owner,    :regex =&gt; [ /^([a-z]|[A-Z]|[0-9]|_|-)+$/, /^\d+$/ ]
attribute :path,     :kind_of =&gt; String
attribute :checksum, :regex =&gt; /^[a-zA-Z0-9]{64}$/</pre> <p>What this shows are the similarities and differences between resources and custom resources. The custom resources are easier to write and understand, plus they can offer much the same (if not identical) functionality as the more complex platform resources.</p>   <h2 id="company-name-maintained">Chef-maintained</h2> <p>Chef maintains a collection of cookbooks that define some common scenarios and provides resources to support them. These cookbooks are located at <a class="reference external" href="https://github.com/chef-cookbooks" target="_blank">https://github.com/chef-cookbooks</a>. To use these resources within recipes, first download the cookbook. Then add those resources to recipes.</p> <p>Some of the most popular Chef-maintained cookbooks are listed below:</p> <table class="docutils"> <colgroup> <col width="25%"> <col width="75%"> </colgroup> <thead valign="bottom"> <tr class="row-odd">
<th class="head">Cookbook</th> <th class="head">Description</th> </tr> </thead> <tbody valign="top"> <tr class="row-even">
<td><a class="reference external" href="https://github.com/chef-cookbooks/apt" target="_blank">apt</a></td> <td>The <code class="docutils literal">apt</code> cookbook is used to configure Apt and Apt services, for managing Apt repositories and preferences.</td> </tr> <tr class="row-odd">
<td><a class="reference external" href="https://github.com/chef-cookbooks/aws" target="_blank">aws</a></td> <td>The <code class="docutils literal">aws</code> cookbook is used to manage resources that are running in Amazon Web Services (AWS).</td> </tr> <tr class="row-even">
<td><a class="reference external" href="https://github.com/chef-cookbooks/bluepill" target="_blank">bluepill</a></td> <td>The <code class="docutils literal">bluepill</code> cookbook is used to install Blue Pill, and then use it to manage services.</td> </tr> <tr class="row-odd">
<td><a class="reference external" href="https://docs.chef.io/resource_chef_handler.html" target="_blank">chef_handler</a></td> <td>The <strong>chef_handler</strong> cookbook is used to distribute and enable exception and report handlers. This cookbook also exposes the <strong>chef_handler</strong> resource, which allows exception and report handlers to be exposed from within recipes, as opposed to having them hard-coded within the client.rb file.</td> </tr> <tr class="row-even">
<td><a class="reference external" href="https://github.com/chef-cookbooks/cron" target="_blank">cron</a></td> <td>Use to install cron and start the crond service.</td> </tr> <tr class="row-odd">
<td><a class="reference external" href="https://github.com/chef-cookbooks/dmg" target="_blank">dmg</a></td> <td>The <code class="docutils literal">dmg</code> cookbook is used to create a DMG package for use with Mac OS X.</td> </tr> <tr class="row-even">
<td><a class="reference external" href="https://github.com/chef-cookbooks/dynect" target="_blank">dynect</a></td> <td>The <code class="docutils literal">dynect</code> cookbook is used to manage DNS records using the DynECT REST API.</td> </tr> <tr class="row-odd">
<td><a class="reference external" href="https://github.com/chef-cookbooks/firewall" target="_blank">firewall</a></td> <td>The <code class="docutils literal">firewall</code> cookbook is used to manage firewalls and their associated firewall rulesets.</td> </tr> <tr class="row-even">
<td><a class="reference external" href="https://github.com/chef-cookbooks/freebsd" target="_blank">freebsd</a></td> <td>The <code class="docutils literal">freebsd</code> cookbook is used to manage port options for FreeBSD.</td> </tr> <tr class="row-odd">
<td><a class="reference external" href="https://github.com/chef-cookbooks/gunicorn" target="_blank">gunicorn</a></td> <td>Gunicorn is a web service gateway interface server for UNIX that is a pre-fork worker model from the Ruby Unicorn project. The <code class="docutils literal">gunicorn</code> cookbook is used to install and configure Gunicorn.</td> </tr> <tr class="row-even">
<td><a class="reference external" href="https://github.com/chef-cookbooks/homebrew" target="_blank">homebrew</a></td> <td>The <code class="docutils literal">homebrew</code> cookbook is used to install and configure Homebrew for use as the package manager for Mac OS X.</td> </tr> <tr class="row-odd">
<td><a class="reference external" href="https://github.com/chef-cookbooks/iis" target="_blank">iis</a></td> <td>The <code class="docutils literal">iis</code> cookbook is used to install and configure Internet Information Services (IIS).</td> </tr> <tr class="row-even">
<td><a class="reference external" href="https://github.com/chef-cookbooks/lvm" target="_blank">lvm</a></td> <td>Use to install the <code class="docutils literal">lvm2</code> package, and then manage logical volume manager (LVM).</td> </tr> <tr class="row-odd">
<td><a class="reference external" href="https://github.com/chef-cookbooks/maven" target="_blank">maven</a></td> <td>The <code class="docutils literal">maven</code> cookbook is used to install and configure Apache Maven.</td> </tr> <tr class="row-even">
<td><a class="reference external" href="https://github.com/chef-cookbooks/openssh" target="_blank">openssh</a></td> <td>The <code class="docutils literal">openssh</code> cookbook is used to install OpenSSH.</td> </tr> <tr class="row-odd">
<td><a class="reference external" href="https://github.com/chef-cookbooks/omnibus" target="_blank">omnibus</a></td> <td>Use to prepare a machine to be an Omnibus builder.</td> </tr> <tr class="row-even">
<td><a class="reference external" href="https://github.com/chef-cookbooks/php" target="_blank">php</a></td> <td>The <code class="docutils literal">php</code> cookbook is used to install and configure PHP and PHP modules.</td> </tr> <tr class="row-odd">
<td><a class="reference external" href="https://github.com/chef-cookbooks/postfix" target="_blank">postfix</a></td> <td>Use to install and configure postfix for client or outbound relayhost.</td> </tr> <tr class="row-even">
<td><a class="reference external" href="https://github.com/chef-cookbooks/powershell" target="_blank">powershell</a></td> <td>Use to run Windows PowerShell. See the <a class="reference external" href="https://docs.chef.io/resource_powershell_script.html" target="_blank">powershell_script resource</a> (built into the chef-client) for more information about improved ways to run Windows PowerShell when using Chef.</td> </tr> <tr class="row-odd">
<td><a class="reference external" href="https://github.com/chef-cookbooks/squid" target="_blank">squid</a></td> <td>Use to configure squid as a caching proxy.</td> </tr> <tr class="row-even">
<td><a class="reference external" href="https://github.com/chef-cookbooks/sudo" target="_blank">sudo</a></td> <td>The <code class="docutils literal">sudo</code> cookbook is used to install sudo and configure <code class="docutils literal">/etc/sudoers</code>.</td> </tr> <tr class="row-odd">
<td><a class="reference external" href="https://github.com/chef-cookbooks/transmission" target="_blank">transmission</a></td> <td>The <code class="docutils literal">transmission</code> cookbook is used to install and configure the Transmission BitTorrent client.</td> </tr> <tr class="row-even">
<td><a class="reference external" href="https://github.com/chef-cookbooks/webpi" target="_blank">webpi</a></td> <td>The <code class="docutils literal">webpi</code> cookbook is used to run the Microsoft Web Platform Installer (WebPI).</td> </tr> <tr class="row-odd">
<td><a class="reference external" href="https://github.com/chef-cookbooks/windows" target="_blank">windows</a></td> <td>The <code class="docutils literal">windows</code> cookbook is used to configure auto run, batch, reboot, enable built-in operating system packages, configure Microsoft Windows packages, reboot machines, and more.</td> </tr> <tr class="row-even">
<td><a class="reference external" href="https://github.com/chef-cookbooks/yum" target="_blank">yum</a></td> <td>The <code class="docutils literal">yum</code> cookbook is used to manage the contents of the <code class="docutils literal">yum.conf</code> configuration file for global Yum configurations and for individual Yum repositories.</td> </tr> </tbody> </table>   <h2 id="custom-resources">Custom Resources</h2> <p>A resource is a statement of configuration policy that:</p> <ul class="simple"> <li>Describes the desired state for a configuration item</li> <li>Declares the steps needed to bring that item to the desired state</li> <li>Specifies a resource type—such as <code class="docutils literal">package</code>, <code class="docutils literal">template</code>, or <code class="docutils literal">service</code>
</li> <li>Lists additional details (also known as resource properties), as necessary</li> <li>Are grouped into recipes, which describe working configurations</li> </ul> <p>A custom resource is a custom resource that defines an action to be completed, which are then processed by a custom provider during the chef-client run. A custom provider and custom resource work together, each being defined in the same cookbook (the <code class="docutils literal">/providers</code> and <code class="docutils literal">/resources</code> subdirectories, respectively); together, they are referred as a LWRP (or “custom resource/provider”). A custom resource is always authored using Ruby. Anything that can be done using Ruby can be done in a custom resource. In addition to using Ruby, the Resource DSL provides additional methods that are specific to the chef-client.</p>  <h3 id="syntax">Syntax</h3> <p>The syntax for a custom resource is as follows:</p> <pre class="highlight-ruby" data-language="ruby">require 'required_item'

actions :action_name1, :action_name2, :action_name...
default_action :action_name1

attribute :attribute_name, :kind_of =&gt; 'value', :name_attribute =&gt; true
attribute :attribute_name, :kind_of =&gt; 'value', :validation_parameter =&gt; 'value'
...
attribute :attribute_name, :kind_of =&gt; 'value', :validation_parameter =&gt; 'value'

attr_accessor :attribute, :attribute</pre> <p>where</p> <ul class="simple"> <li>
<code class="docutils literal">require</code> lists any external entities that may be required by the custom resources, such as a library; a custom resource is Ruby and anything that can be done in Ruby can be done in a custom resource</li> <li>
<code class="docutils literal">:action_name1</code>, <code class="docutils literal">:action_name2</code>, and <code class="docutils literal">:action_name...</code> represents a comma-delimited list of <code class="docutils literal">actions</code> that are available to this custom resource; there must be at least one action</li> <li>
<code class="docutils literal">action_name1</code> is set to be the <code class="docutils literal">default_action</code>
</li> <li>
<code class="docutils literal">:attribute_name</code> is the name of the property; a custom resource may define as many properties as necessary</li> <li>
<code class="docutils literal">:kind_of =&gt; value</code> specifies the Ruby class (or an array of Ruby classes) that are used to define this property’s value</li> <li>
<code class="docutils literal">:name_attribute</code> is associated with one <code class="docutils literal">attribute</code> to indicate which property’s value will be defined by the name of the resource as it is defined in the recipe (i.e. the string that appears in front of the <code class="docutils literal">do</code> block in the recipe and after the resource: <code class="docutils literal">resource_name "name_attribute" do</code>)</li> <li>
<code class="docutils literal">:validation_parameter</code> represents a comma-delimited list of validation parameters for each property</li> <li>
<code class="docutils literal">attr_accessor</code> allows the custom resource to use the <code class="docutils literal">Module</code> Ruby class to check for one (or more) named properties, such as <code class="docutils literal">:exists</code> or <code class="docutils literal">:running</code>
</li> </ul> <p>For example, the <code class="docutils literal">cron_d</code> custom resource (found in the <code class="docutils literal">cron</code> cookbook) can be used to manage files located in <code class="docutils literal">/etc/cron.d</code>:</p> <pre class="highlight-ruby" data-language="ruby">actions :create, :delete
default_action :create

attribute :name, :kind_of =&gt; String, :name_attribute =&gt; true
attribute :cookbook, :kind_of =&gt; String, :default =&gt; 'cron'
attribute :minute, :kind_of =&gt; [Integer, String], :default =&gt; '*'
attribute :hour, :kind_of =&gt; [Integer, String], :default =&gt; '*'
attribute :day, :kind_of =&gt; [Integer, String], :default =&gt; '*'
attribute :month, :kind_of =&gt; [Integer, String], :default =&gt; '*'
attribute :weekday, :kind_of =&gt; [Integer, String], :default =&gt; '*'
attribute :command, :kind_of =&gt; String, :required =&gt; true
attribute :user, :kind_of =&gt; String, :default =&gt; 'root'
attribute :mailto, :kind_of =&gt; [String, NilClass]
attribute :path, :kind_of =&gt; [String, NilClass]
attribute :home, :kind_of =&gt; [String, NilClass]
attribute :shell, :kind_of =&gt; [String, NilClass]</pre> <p>where</p> <ul class="simple"> <li>the <code class="docutils literal">actions</code> allow a recipe to manage entries in a crontab file (create entry, delete entry)</li> <li>
<code class="docutils literal">:create</code> is the default action</li> <li>
<code class="docutils literal">:minute</code>, <code class="docutils literal">:hour</code>, <code class="docutils literal">:day</code>, <code class="docutils literal">:month</code>, and <code class="docutils literal">:weekday</code> are the collection of properties used to schedule a cron job, assigned a default value of <code class="docutils literal">'*'</code>
</li> <li>
<code class="docutils literal">:command</code> is the command that will be run (and also required)</li> <li>
<code class="docutils literal">:user</code> is the user by which the command is run</li> <li>
<code class="docutils literal">:mailto</code>, <code class="docutils literal">:path</code>, <code class="docutils literal">:home</code>, and <code class="docutils literal">:shell</code> are optional environment variables that do not have default value, which each being defined as an array that supports the <code class="docutils literal">String</code> and <code class="docutils literal">NilClass</code> Ruby classes</li> </ul>   <h3 id="dsl-resource-methods">Resource DSL Methods</h3> <p>The Resource DSL is a Ruby DSL that is used to help define a lightweight resource and to ensure that a lightweight resource provides the correct information to a lightweight provider. The Resource DSL is a small DSL with just three methods. Because the Resource DSL is a Ruby DSL, anything that can be done using Ruby can also be done as part of defining a lightweight resource.</p>  <h4 id="actions">actions</h4> <p>The <code class="docutils literal">actions</code> method is used to define a list of actions that are available to be used in a recipe. Each action must have a corresponding section in a lightweight provider that tells the chef-client what to do when this action is specified in a recipe. The syntax for the <code class="docutils literal">actions</code> method is as follows:</p> <pre class="highlight-ruby" data-language="ruby">actions :action_name, :action_name</pre> <p>where <code class="docutils literal">actions</code> is a comma-delimited list of individual actions.</p>   <h4 id="attribute">attribute</h4> <p>The <code class="docutils literal">attribute</code> method is used to define a list of properties and any of those property’s associated validation parameters. The syntax for the <code class="docutils literal">attribute</code> method is as follows:</p> <pre class="highlight-ruby" data-language="ruby">attribute :property_name :validation_parameter =&gt; value, :validation_parameter =&gt; value</pre> <p>where <code class="docutils literal">attribute</code> must have an property name and zero (or more) validation parameters.</p>   <h4 id="attr-accessor">attr_accessor</h4> <p>The <code class="docutils literal">attr_accessor</code> method is used to define custom properties for a lightweight resource that can be accessed by a lightweight provider. The syntax for the <code class="docutils literal">attr_accessor</code> method is as follows:</p> <pre class="highlight-ruby" data-language="ruby">attr_accessor :accessor_name, :accessor_name</pre> <p>where <code class="docutils literal">accessor_name</code> is a comma-delimited list of custom properties.</p>   <h4 id="default-action">default_action</h4> <p>The <code class="docutils literal">default_action</code> method is used to set the default action for a lightweight resource. The syntax for the <code class="docutils literal">default_action</code> method is as follows:</p> <pre class="highlight-ruby" data-language="ruby">default_action :action_name</pre> <p>where <code class="docutils literal">action_name</code> is the default action.</p>   <h4 id="provides">provides</h4> <p>Use the <code class="docutils literal">provides</code> method to map a custom resource/provider to an existing resource/provider, and then to also specify the platform(s) on which the behavior of the custom resource/provider will be applied. This method enables scenarios like:</p> <ul class="simple"> <li>Building a custom resource that is based on an existing resource</li> <li>Defining platform mapping specific to a custom resource</li> <li>Handling situations where a resource on a particular platform may have more than one provider, such as the behavior on the Ubuntu platform where both SysVInit and systemd are present</li> <li>Allowing the custom resource to declare what platforms are supported, enabling the creator of the custom resource to use arbitrary criteria if desired</li> <li>Not using the previous naming convention—<code class="docutils literal">#{cookbook_name}_#{provider_filename}</code>
</li> </ul> <div class="admonition warning"> <p class="first admonition-title">Warning</p> <p class="last">The <code class="docutils literal">provides</code> method must be defined in both the custom resource and custom provider files and both files must have identical <code class="docutils literal">provides</code> statement(s).</p> </div> <p>The syntax for the <code class="docutils literal">provides</code> method is as follows:</p> <pre class="highlight-ruby" data-language="ruby">provides :resource_name, os: [ 'platform', 'platform', ...], platform_family: 'family'</pre> <p>where:</p> <ul class="simple"> <li>
<code class="docutils literal">:resource_name</code> is a chef-client resource: <code class="docutils literal">:cookbook_file</code>, <code class="docutils literal">:package</code>, <code class="docutils literal">:rpm_package</code>, and so on</li> <li>
<code class="docutils literal">'platform'</code> is a comma-separated list of platforms: <code class="docutils literal">'windows'</code>, <code class="docutils literal">'solaris2'</code>, <code class="docutils literal">'linux'</code>, and so on</li> <li>
<code class="docutils literal">platform_family</code> is optional and may specify the same parameters as the <code class="docutils literal">platform_family?</code> method in the Recipe DSL; <code class="docutils literal">platform</code> is optional and also supported (and is the same as the <code class="docutils literal">platform?</code> method in the Recipe DSL)</li> </ul> <p>A custom resource/provider may be mapped to more than one existing resource/provider. Multiple platform associations may be made. For example, to completely map a custom resource/provider to an existing custom resource/provider, only specificy the resource name:</p> <pre class="highlight-ruby" data-language="ruby">provides :cookbook_file</pre> <p>The same mapping, but only for the Linux platform:</p> <pre class="highlight-ruby" data-language="ruby">provides :cookbook_file, os: 'linux'</pre> <p>A similar mapping, but also for packages on the Microsoft Windows platform:</p> <pre class="highlight-ruby" data-language="ruby">provides :cookbook_file
provides :package, os: 'windows'</pre> <p>Use multiple <code class="docutils literal">provides</code> statements to define multiple conditions: Use an array to match any of the platforms within the array:</p> <pre class="highlight-ruby" data-language="ruby">provides :cookbook_file
provides :package, os: 'windows'
provides :rpm_package, os: [ 'linux', 'aix' ]</pre> <p>Use an array to match any of the platforms within the array:</p> <pre class="highlight-ruby" data-language="ruby">provides :package, os: 'solaris2', platform_family: 'solaris2' do |node|
  node[:platform_version].to_f &lt;= 5.10
end</pre>   <h4 id="state-attrs">state_attrs</h4> <p>The <code class="docutils literal">state_attrs</code> method is used to define the properties that will be tracked by the Reporting server. In general, this should be a list of properties that describe the desired state of the system, such as file permissions, cloud provider data (like snapshots, volumes, identifiers, sizes, and access keys), and so on.</p> <p>The syntax for the <code class="docutils literal">state_attrs</code> method is as follows:</p> <pre class="highlight-ruby" data-language="ruby">state_attrs :property,
            :property,
            :property</pre> <p>where <code class="docutils literal">:property</code> is a comma-delimited list of properties. For example, the <code class="docutils literal">ebs_volume</code> resource (available from the <a class="reference external" href="https://github.com/chef-cookbooks/aws" target="_blank">aws</a> cookbook) uses the <code class="docutils literal">state_attrs</code> method to tell the Reporting server to track the following properties:</p> <pre class="highlight-ruby" data-language="ruby">state_attrs :availability_zone,
            :aws_access_key,
            :description,
            :device,
            :most_recent_snapshot,
            :piops,
            :size,
            :snapshot_id,
            :snapshots_to_keep,
            :timeout,
            :volume_id,
            :volume_type</pre>   <h4 id="validation-parameters">Validation Parameters</h4> <p>A validation parameter is used to add zero (or more) validation parameters to an property.</p> <table class="docutils"> <colgroup> <col width="25%"> <col width="75%"> </colgroup> <thead valign="bottom"> <tr class="row-odd">
<th class="head">Parameter</th> <th class="head">Description</th> </tr> </thead> <tbody valign="top"> <tr class="row-even">
<td><code class="docutils literal">:callbacks</code></td> <td>
<p class="first">Use to define a collection of unique keys and values (a Hash) for which the key is the error message and the value is a lambda to validate the parameter. For example: <code class="docutils literal">"Option #{key}'s value #{value} #{message}!"</code>, which will insert a key into an error message if the Proc object does not return true. For example:</p> <pre class="last highlight-ruby" data-language="ruby">:callbacks =&gt; {
          'should be a valid non-system port' =&gt; lambda {
            |p| p &gt; 1024 &amp;&amp; p &lt; 65535
            }
          }</pre> </td> </tr> <tr class="row-odd">
<td><code class="docutils literal">:default</code></td> <td>
<p class="first">Use to specify the default value for an property. For example:</p> <pre class="highlight-ruby" data-language="ruby">:default =&gt; 'a_string_value'</pre> <pre class="highlight-ruby" data-language="ruby">:default =&gt; 123456789</pre> <pre class="highlight-ruby" data-language="ruby">:default =&gt; []</pre> <pre class="highlight-ruby" data-language="ruby">:default =&gt; ()</pre> <pre class="last highlight-ruby" data-language="ruby">:default =&gt; {}</pre> </td> </tr> <tr class="row-even">
<td><code class="docutils literal">:equal_to</code></td> <td>
<p class="first">Use to match a value with <code class="docutils literal">==</code>. Use an array of values to match any of those values with <code class="docutils literal">==</code>. For example: .. code-block:: ruby</p> <blockquote> <div>:equal_to =&gt; [true, false]</div>
</blockquote> <pre class="last highlight-ruby" data-language="ruby">:equal_to =&gt; ['php', 'perl']</pre> </td> </tr> <tr class="row-odd">
<td><code class="docutils literal">:kind_of</code></td> <td>
<p class="first">Use to ensure a value is of a particular Ruby class, such as <code class="docutils literal">TrueClass</code>, <code class="docutils literal">FalseClass</code>, <code class="docutils literal">NilClass</code>, <code class="docutils literal">String</code>, <code class="docutils literal">Array</code>, <code class="docutils literal">Hash</code>, and so on. Use an array of Ruby classes to allow a value to be of more than one type. For example: <code class="docutils literal">:kind_of =&gt; String</code>, <code class="docutils literal">:kind_of =&gt; Array</code>, <code class="docutils literal">:kind_of =&gt; [TrueClass, FalseClass]</code> and <code class="docutils literal">:kind_of =&gt; [Array, Hash]</code>. For example:</p> <pre class="highlight-ruby" data-language="ruby">:kind_of =&gt; String</pre> <pre class="highlight-ruby" data-language="ruby">:kind_of =&gt; Fixnum</pre> <pre class="highlight-ruby" data-language="ruby">:kind_of =&gt; Hash</pre> <pre class="highlight-ruby" data-language="ruby">:kind_of =&gt; [TrueClass, FalseClass]</pre> <pre class="highlight-ruby" data-language="ruby">:kind_of =&gt; [String, NilClass]</pre> <pre class="highlight-ruby" data-language="ruby">:kind_of =&gt; [Class, String, Symbol]</pre> <pre class="last highlight-ruby" data-language="ruby">:kind_of =&gt; [Array, Hash]</pre> </td> </tr> <tr class="row-even">
<td><code class="docutils literal">:name_attribute</code></td> <td>
<p class="first">Use to set the default name of a lightweight resource. If the name isn’t specified in the recipe, this is the value that will be used. For example:</p> <pre class="last highlight-ruby" data-language="ruby">:name_attribute =&gt; true</pre> </td> </tr> <tr class="row-odd">
<td><code class="docutils literal">:regex</code></td> <td>
<p class="first">Use to match a value to a regular expression. For example:</p> <pre class="last highlight-ruby" data-language="ruby">:regex =&gt; [ /^([a-z]|[A-Z]|[0-9]|_|-)+$/, /^\d+$/ ]</pre> </td> </tr> <tr class="row-even">
<td><code class="docutils literal">:required</code></td> <td>
<p class="first">Indicates that an property is required. For example:</p> <pre class="last highlight-ruby" data-language="ruby">:required =&gt; true</pre> </td> </tr> <tr class="row-odd">
<td><code class="docutils literal">:respond_to</code></td> <td>
<p class="first">Use to ensure that a value has a given method. This can be a single method name or an array of method names. For example:</p> <pre class="last highlight-ruby" data-language="ruby">:respond_to =&gt; valid_encoding?</pre> </td> </tr> </tbody> </table> <p>Some examples of combining validation parameters:</p> <pre class="highlight-ruby" data-language="ruby">attribute :spool_name, :kind_of =&gt; String, :name_attribute =&gt; true</pre> <pre class="highlight-ruby" data-language="ruby">attribute :enabled, :equal_to =&gt; [true, false, 'true', 'false'], :default =&gt; true</pre>   <h4 id="guards">Guards</h4> <p>A guard property can be used to evaluate the state of a node during the execution phase of the chef-client run. Based on the results of this evaluation, a guard property is then used to tell the chef-client if it should continue executing a resource. A guard property accepts either a string value or a Ruby block value:</p> <ul class="simple"> <li>A string is executed as a shell command. If the command returns <code class="docutils literal">0</code>, the guard is applied. If the command returns any other value, then the guard property is not applied. String guards in a <strong>powershell_script</strong> run Windows PowerShell commands and may return <code class="docutils literal">true</code> in addition to <code class="docutils literal">0</code>.</li> <li>A block is executed as Ruby code that must return either <code class="docutils literal">true</code> or <code class="docutils literal">false</code>. If the block returns <code class="docutils literal">true</code>, the guard property is applied. If the block returns <code class="docutils literal">false</code>, the guard property is not applied.</li> </ul> <p>A guard property is useful for ensuring that a resource is idempotent by allowing that resource to test for the desired state as it is being executed, and then if the desired state is present, for the chef-client to do nothing.</p>  <h5 id="guard-attributes">Guard Attributes</h5> <p>The following properties can be used to define a guard that is evaluated during the execution phase of the chef-client run:</p> <dl class="docutils"> <dt><code class="docutils literal">not_if</code></dt> <dd>Prevent a resource from executing when the condition returns <code class="docutils literal">true</code>.</dd> <dt><code class="docutils literal">only_if</code></dt> <dd>Allow a resource to execute only if the condition returns <code class="docutils literal">true</code>.</dd> </dl>   <h5 id="guard-arguments">Guard Arguments</h5> <p>The following arguments can be used with the <code class="docutils literal">not_if</code> or <code class="docutils literal">only_if</code> guard properties:</p> <dl class="docutils"> <dt><code class="docutils literal">:user</code></dt> <dd>
<p class="first">Specify the user that a command will run as. For example:</p> <pre class="last highlight-ruby" data-language="ruby">not_if 'grep adam /etc/passwd', :user =&gt; 'adam'</pre> </dd> <dt><code class="docutils literal">:group</code></dt> <dd>
<p class="first">Specify the group that a command will run as. For example:</p> <pre class="last highlight-ruby" data-language="ruby">not_if 'grep adam /etc/passwd', :group =&gt; 'adam'</pre> </dd> <dt><code class="docutils literal">:environment</code></dt> <dd>
<p class="first">Specify a Hash of environment variables to be set. For example:</p> <pre class="last highlight-ruby" data-language="ruby">not_if 'grep adam /etc/passwd', :environment =&gt; {
  'HOME' =&gt; '/home/adam'
}</pre> </dd> <dt><code class="docutils literal">:cwd</code></dt> <dd>
<p class="first">Set the current working directory before running a command. For example:</p> <pre class="last highlight-ruby" data-language="ruby">not_if 'grep adam passwd', :cwd =&gt; '/etc'</pre> </dd> <dt><code class="docutils literal">:timeout</code></dt> <dd>
<p class="first">Set a timeout for a command. For example:</p> <pre class="last highlight-ruby" data-language="ruby">not_if 'sleep 10000', :timeout =&gt; 10</pre> </dd> </dl>    <h4 id="notifications">Notifications</h4> <p>A notification is a property on a resource that listens to other resources in the resource collection and then takes actions based on the notification type (<code class="docutils literal">notifies</code> or <code class="docutils literal">subscribes</code>).</p> <p>A timer specifies the point during the chef-client run at which a notification is run. The following timers are available:</p> <dl class="docutils"> <dt><code class="docutils literal">:delayed</code></dt> <dd>Default. Specifies that a notification should be queued up, and then executed at the very end of the chef-client run.</dd> <dt>
<code class="docutils literal">:immediate</code>, <code class="docutils literal">:immediately</code>
</dt> <dd>Specifies that a notification should be run immediately, per resource notified.</dd> </dl>  <h5 id="notifies">notifies</h5> <p>A resource may notify another resource to take action when its state changes. Specify a <code class="docutils literal">'resource[name]'</code>, the <code class="docutils literal">:action</code> that resource should take, and then the <code class="docutils literal">:timer</code> for that action. A resource may notifiy more than one resource; use a <code class="docutils literal">notifies</code> statement for each resource to be notified.</p> <p>The syntax for <code class="docutils literal">notifies</code> is:</p> <pre class="highlight-ruby" data-language="ruby">notifies :action, 'resource[name]', :timer</pre>   <h5 id="subscribes">subscribes</h5> <p>A resource may listen to another resource, and then take action if the state of the resource being listened to changes. Specify a <code class="docutils literal">'resource[name]'</code>, the <code class="docutils literal">:action</code> to be taken, and then the <code class="docutils literal">:timer</code> for that action.</p> <p>The syntax for <code class="docutils literal">subscribes</code> is:</p> <pre class="highlight-ruby" data-language="ruby">subscribes :action, 'resource[name]', :timer</pre>     <h3 id="examples">Examples</h3> <p>The following examples show various lightweight providers that use platform resources or how to use certain parts of the Resource DSL.</p>  <h4 id="callbacks">:callbacks</h4> <p>An example of using the <code class="docutils literal">:callbacks</code> validation parameter from the <code class="docutils literal">gunicorn</code> cookbook (formatted for better readability):</p> <pre class="highlight-ruby" data-language="ruby">attribute :server_hooks, :kind_of =&gt; Hash, :default =&gt; {}, \
  :callbacks =&gt;
    {'should contain a valid gunicorn server hook name' =&gt; lambda
        {
          |hooks| Chef::Resource::GunicornConfig.validate_server_hook_hash_keys(hooks)
        }
      }
...

VALID_SERVER_HOOK_NAMES =
  [
    :on_starting,
    :on_reload,
    :when_ready,
    :pre_fork,
    :post_fork,
    :pre_exec,
    :pre_request,
    :post_request,
    :worker_exit
  ]

private
  def self.validate_server_hook_hash_keys(server_hooks)
    server_hooks.keys.reject{|key| VALID_SERVER_HOOK_NAMES.include?(key.to_sym)}.empty?
  end</pre> <p>where</p> <ul class="simple"> <li>the <code class="docutils literal">:server_hooks</code> attribute requires the value to be a valid Gunicorn server hook name</li> <li>the <code class="docutils literal">VALID_SERVER_HOOK_NAMES</code> array defines the list of valid server hooks</li> <li>the <code class="docutils literal">private def</code> block ensures the <code class="docutils literal">:callback</code> validation parameter has the list of valid server hooks</li> </ul>     <h2 id="custom-providers-w-platform-resources">Custom Providers w/Platform Resources</h2> <p>Where a resource represents a piece of the system (and its desired state), a provider defines the steps that are needed to bring that piece of the system from its current state into the desired state.</p> <p>A custom provider is a custom provider that defines the steps that are required to complete one (or more) actions defined by a custom resource. A custom provider and custom resource work together, each being defined in the same cookbook (the <code class="docutils literal">/providers</code> and <code class="docutils literal">/resources</code> subdirectories, respectively); together, they are referred as a LWRP (or “custom resource/provider”). A custom provider is always authored using Ruby. Anything that can be done using Ruby can be done in a custom provider. In addition to using Ruby, the Provider DSL provides additional methods that are specific to the chef-client.</p>  <h3 id="id2">Syntax</h3> <p>This section shows some of the common structural elements that appear in a custom provider that is built in a way that leverages platform resources (such as <strong>file</strong>, <strong>template</strong>, or <strong>package</strong>). Remember:</p> <ul class="simple"> <li>A custom provider tells the chef-client how to complete a task</li> <li>The structure of a custom provider will vary, depending on the complexity of the tasks required to complete an action</li> <li>At its platform, a custom provider is just Ruby code, which means that anything that can be done in Ruby can be done in a custom provider</li> </ul> <p>The basic syntax for a custom provider that is built to leverage platform resources is as follows:</p> <pre class="highlight-ruby" data-language="ruby">def whyrun_supported?
  true
end

use_inline_resources

action :action_name do
  condition test
    resource 'resource_name' do
      Chef::Log.log_type 'log_message'
      # a Chef recipe
    end
  end
end

def test()
  # some Ruby code
end</pre> <p>where:</p> <ul class="simple"> <li>
<code class="docutils literal">whyrun_supported?</code> indicates whether a custom provider can be run in why-run mode</li> <li>
<code class="docutils literal">use_inline_resources</code> is used to tell the chef-client to execute <code class="docutils literal">action</code> blocks as part of a self-contained chef-client run. Using this method ensures that the chef-client can notify parent custom resources after embedded resources have finished processing</li> <li>
<code class="docutils literal">action</code> is the code block that tells the chef-client what to do when the <code class="docutils literal">:action_name</code> is used in a recipe</li> <li>
<code class="docutils literal">condition</code> is a Ruby condition statement (<code class="docutils literal">if</code>, <code class="docutils literal">else</code>, <code class="docutils literal">elseif</code>, <code class="docutils literal">unless</code>, <code class="docutils literal">while</code>, <code class="docutils literal">until</code>, <code class="docutils literal">case</code>, or <code class="docutils literal">for</code>)</li> <li>
<code class="docutils literal">test</code> is used to test for idempotence; <code class="docutils literal">test</code> can be defined inline (within the <code class="docutils literal">action</code> block), defined as a method using a definition block elsewhere in the custom provider (shown as <code class="docutils literal">def test()</code>), or defined using any other pattern that is available in Ruby</li> <li>
<code class="docutils literal">resource</code> is a resource written as a recipe</li> <li>
<code class="docutils literal">Chef::Log.log_type</code> is used to tell the chef-client to create a log entry, where <code class="docutils literal">log_type</code> is one of the following types: <code class="docutils literal">debug</code>, <code class="docutils literal">info</code>, <code class="docutils literal">warn</code>, <code class="docutils literal">error</code>, or <code class="docutils literal">fatal</code>
</li> </ul> <p>For example:</p> <pre class="highlight-ruby" data-language="ruby">def whyrun_supported?
  true
end

use_inline_resources

action :delete do
  if user_exists?(new_resource.user)
    cmdStr = 'rabbitmqctl delete_user #{new_resource.user}'
    execute cmdStr do
      Chef::Log.debug 'rabbitmq_user_delete: #{cmdStr}'
      Chef::Log.info "Deleting RabbitMQ user '#{new_resource.user}'."
      new_resource.updated_by_last_action(true)
    end
  end
end

def user_exists?(name)
  cmdStr = "rabbitmqctl -q list_users |grep '^#{name}\\b'"
  cmd = Mixlib::ShellOut.new(cmdStr)
  cmd.environment['HOME'] = ENV.fetch('HOME', '/root')
  cmd.run_command
  Chef::Log.debug 'rabbitmq_user_exists?: #{cmdStr}'
  Chef::Log.debug 'rabbitmq_user_exists?: #{cmd.stdout}'
  begin
    cmd.error!
    true
  rescue
    false
  end
end</pre>   <h3 id="dsl-provider-methods">Provider DSL Methods</h3> <p>The Provider DSL is a Ruby DSL that is used to help define a custom provider and to ensure that a custom provider takes the correct actions when it is called from a recipe. The Provider DSL is a small DSL with just a few methods that are specific to the chef-client. Because the Provider DSL is a Ruby DSL, anything that can be done using Ruby can also be done when defining a custom provider.</p>  <h4 id="action">action</h4> <p>The <code class="docutils literal">action</code> method is used to define the steps that will be taken for each of the possible actions defined by the custom resource. Each action must be defined in separate <code class="docutils literal">action</code> blocks within the same file. The syntax for the <code class="docutils literal">action</code> method is as follows:</p> <pre class="highlight-ruby" data-language="ruby">action :action_name do
  if @current_resource.exists
    Chef::Log.info '#{ @new_resource } already exists - nothing to do.'
  else
    resource 'resource_name' do
      Chef::Log.info '#{ @new_resource } created.'
    end
  end
  new_resource.updated_by_last_action(true)
end</pre> <p>where:</p> <ul class="simple"> <li>
<code class="docutils literal">:action_name</code> corresponds to an action defined by a custom resource</li> <li>
<code class="docutils literal">if @current_resource.exists</code> is a condition test that is using an instance variable to see if the object already exists on the node; this is an example of a test for idempotence</li> <li>If the object already exists, a <code class="docutils literal">#{ @new_resource } already exists - nothing to do.</code> log entry is created</li> <li>If the object does not already exists, the <code class="docutils literal">resource</code> block is run. This block is a recipe that tells the chef-client what to do. A <code class="docutils literal">#{ @new_resource } created.</code> log entry is created</li> </ul> <div class="admonition note"> <p class="first admonition-title">Note</p> <p class="last">The <code class="docutils literal">converge_by</code> method is not included in the previous syntax example because when why-run mode is enabled in a lightweight provider that leverages platform resources, the <code class="docutils literal">converge_by</code> blocks are already defined by the platform resources.</p> </div>   <h4 id="current-resource">current_resource</h4> <p>The <code class="docutils literal">current_resource</code> method is used to represent a resource as it exists on the node at the beginning of the chef-client run. In other words: what the resource is currently. The custom provider should compare the resource as it exists on the node to the <code class="docutils literal">new_resource</code> that is created during the chef-client run, and then determine what steps should be taken to bring the resource into the desired state.</p> <p>For example:</p> <pre class="highlight-ruby" data-language="ruby">action :add do
  unless current_resource.exists
    cmd = "#{appcmd} add app /site.name:\'#{new_resource.app_name}\'"
    cmd &lt;&lt; " /path:\'#{new_resource.path}\'"
    cmd &lt;&lt; " /applicationPool:\'#{new_resource.application_pool}\'" if new_resource.application_pool
    cmd &lt;&lt; " /physicalPath:\'#{new_resource.physical_path}\'" if new_resource.physical_path
    converge_by("creating App") do
      Chef::Log.debug(cmd)
      shell_out!(cmd)
      Chef::Log.debug('App created')
    end
  else
    Chef::Log.debug('#{new_resource} app already exists - nothing to do')
  end
end</pre> <p>where the <code class="docutils literal">unless</code> conditional statement checks to make sure the resource doesn’t already exist on a node, and then runs a series of commands when it doesn’t. If the resource already exists, the log entry would be <code class="docutils literal">Foo app already exists - nothing to do</code>.</p>   <h4 id="load-current-resource">load_current_resource</h4> <p>The <code class="docutils literal">load_current_resource</code> method is used to construct the curent state of the resource on the node. This is in contrast to the <code class="docutils literal">new_resource</code> method which represents the desired state of the resource on the node. Both methods are constructed the same way. Properties should be loaded from the node’s state.</p> <p>For example:</p> <pre class="highlight-ruby" data-language="ruby">def load_current_resource

  @current_resource = Chef::Resource::MyResource.new(new_resource.name)

  current_resource.path(new_resource.path)
  # Most other current_resource properites will be found by inspecting the system (e.g. Wwhat is
  # the current version of the installed package?  What are the existing file modes?)
  current_resource.mode(File.stat(new_resource.path).mode)
  current_resource
end</pre> <p>where:</p> <ul class="simple"> <li>
<code class="docutils literal">load_current_resource</code> returns the <code class="docutils literal">current_resource</code> (and builds the instance variable)</li> <li>
<code class="docutils literal">@current_resource</code> is an instance variable that creates a <code class="docutils literal">current_resource</code> with the same name as <code class="docutils literal">new_resource</code>
</li> <li>
<code class="docutils literal">current_resource.path(new_resource.path)</code> sets the new resource paths to be the same as the current resource paths</li> <li>
<code class="docutils literal">current_resource.mode(File.stat(new_resource.path).mode)</code> inspects the system for properties of the current resource</li> <li>
<code class="docutils literal">current_resource</code> returns the current resource and allows the <code class="docutils literal">new_resource</code> to be compared to check for idempotentcy</li> </ul>   <h4 id="new-resource">new_resource</h4> <p>The <code class="docutils literal">new_resource</code> method is used to represent a resource as loaded by the chef-client during the chef-client run. In other words: what the resource should be. The custom provider should compare the resource as it exists on the node to the resource that is created during the chef-client run to determine what steps need to be taken to bring the resource into the desired state.</p> <p>For example:</p> <pre class="highlight-ruby" data-language="ruby">action :delete do
  if ::File.exists?(new_resource.path)
    converge_by("deleting #{new_resource.path}) do
      if ::File.writable?(new_resource.path)
        Chef::Log.info("Deleting #{new_resource} at #{new_resource.path}")
        ::File.delete(new_resource.path)
      else
        raise "Cannot delete #{new_resource} at #{new_resource.path}!"
      end
    end
  end
end</pre> <p>where</p> <ul class="simple"> <li>The chef-client checks to see if the file exists, then if the file is writable, and then attempts to delete the resource</li> <li>
<code class="docutils literal">path</code> is an attribute of the new resource that is defined by the custom resource</li> </ul>   <h4 id="id3">provides</h4> <p>Use the <code class="docutils literal">provides</code> method to map a custom resource/provider to an existing resource/provider, and then to also specify the platform(s) on which the behavior of the custom resource/provider will be applied. This method enables scenarios like:</p> <ul class="simple"> <li>Building a custom resource that is based on an existing resource</li> <li>Defining platform mapping specific to a custom resource</li> <li>Handling situations where a resource on a particular platform may have more than one provider, such as the behavior on the Ubuntu platform where both SysVInit and systemd are present</li> <li>Allowing the custom resource to declare what platforms are supported, enabling the creator of the custom resource to use arbitrary criteria if desired</li> <li>Not using the previous naming convention—<code class="docutils literal">#{cookbook_name}_#{provider_filename}</code>
</li> </ul> <div class="admonition warning"> <p class="first admonition-title">Warning</p> <p class="last">The <code class="docutils literal">provides</code> method must be defined in both the custom resource and custom provider files and both files must have identical <code class="docutils literal">provides</code> statement(s).</p> </div> <p>The syntax for the <code class="docutils literal">provides</code> method is as follows:</p> <pre class="highlight-ruby" data-language="ruby">provides :resource_name, os: [ 'platform', 'platform', ...], platform_family: 'family'</pre> <p>where:</p> <ul class="simple"> <li>
<code class="docutils literal">:resource_name</code> is a chef-client resource: <code class="docutils literal">:cookbook_file</code>, <code class="docutils literal">:package</code>, <code class="docutils literal">:rpm_package</code>, and so on</li> <li>
<code class="docutils literal">'platform'</code> is a comma-separated list of platforms: <code class="docutils literal">'windows'</code>, <code class="docutils literal">'solaris2'</code>, <code class="docutils literal">'linux'</code>, and so on</li> <li>
<code class="docutils literal">platform_family</code> is optional and may specify the same parameters as the <code class="docutils literal">platform_family?</code> method in the Recipe DSL; <code class="docutils literal">platform</code> is optional and also supported (and is the same as the <code class="docutils literal">platform?</code> method in the Recipe DSL)</li> </ul> <p>A custom resource/provider may be mapped to more than one existing resource/provider. Multiple platform associations may be made. For example, to completely map a custom resource/provider to an existing custom resource/provider, only specificy the resource name:</p> <pre class="highlight-ruby" data-language="ruby">provides :cookbook_file</pre> <p>The same mapping, but only for the Linux platform:</p> <pre class="highlight-ruby" data-language="ruby">provides :cookbook_file, os: 'linux'</pre> <p>A similar mapping, but also for packages on the Microsoft Windows platform:</p> <pre class="highlight-ruby" data-language="ruby">provides :cookbook_file
provides :package, os: 'windows'</pre> <p>Use multiple <code class="docutils literal">provides</code> statements to define multiple conditions: Use an array to match any of the platforms within the array:</p> <pre class="highlight-ruby" data-language="ruby">provides :cookbook_file
provides :package, os: 'windows'
provides :rpm_package, os: [ 'linux', 'aix' ]</pre> <p>Use an array to match any of the platforms within the array:</p> <pre class="highlight-ruby" data-language="ruby">provides :package, os: 'solaris2', platform_family: 'solaris2' do |node|
  node[:platform_version].to_f &lt;= 5.10
end</pre>   <h4 id="updated-by-last-action">updated_by_last_action</h4> <p>The <code class="docutils literal">updated_by_last_action</code> method is used to notify a custom resource that a node was updated successfully. For example, the <code class="docutils literal">cron_d</code> custom resource in the <code class="docutils literal">cron</code> cookbook:</p> <pre class="highlight-ruby" data-language="ruby">action :create do
  t = template '/etc/cron.d/#{new_resource.name}' do
    cookbook new_resource.cookbook
    source 'cron.d.erb'
    mode '0644'
    variables({
        :name =&gt; 'new_resource.name',
        :minute =&gt; 'new_resource.minute',
        :hour =&gt; 'new_resource.hour',
        :day =&gt; 'new_resource.day',
        :month =&gt; 'new_resource.month',
        :weekday =&gt; 'new_resource.weekday',
        :command =&gt; 'new_resource.command',
        :user =&gt; 'new_resource.user',
        :mailto =&gt; 'new_resource.mailto',
        :path =&gt; 'new_resource.path',
        :home =&gt; 'new_resource.home',
        :shell =&gt; 'new_resource.shell'
      })
    action :create
  end
  new_resource.updated_by_last_action(t.updated_by_last_action?)
end</pre> <p>where <code class="docutils literal">t.updated_by_last_action?</code> uses a variable to check whether a new crontab entry was created.</p> <p>Cookbooks that contain custom resources in the <code class="docutils literal">/libraries</code> directory of a cookbook should:</p> <ul class="simple"> <li>Be inspected for instances of a) the <code class="docutils literal">Chef::Provider</code> base class, and then b) for the presence of any core resources from the chef-client</li> <li>Be updated to use the <code class="docutils literal">LWRPBase</code> base class</li> </ul> <p>For example:</p> <pre class="highlight-ruby" data-language="ruby">class Chef
  class Provider
    class LvmLogicalVolume &lt; Chef::Provider::LWRPBase
      include Chef::Mixin::ShellOut

      ...
      if new_resource.mount_point
        if new_resource.mount_point.is_a?(String)
          mount_spec = { :location =&gt; new_resource.mount_point }
        else
          mount_spec = new_resource.mount_point
        end

        dir_resource = directory mount_spec[:location] do
          mode 0755
          owner 'root'
          group 'root'
          recursive true
          action :nothing
          not_if { Pathname.new(mount_spec[:location]).mountpoint? }
        end
        dir_resource.run_action(:create)
        updates &lt;&lt; dir_resource.updated?

        mount_resource = mount mount_spec[:location] do
          options mount_spec[:options]
          dump mount_spec[:dump]
          pass mount_spec[:pass]
          device device_name
          fstype fs_type
          action :nothing
        end
        mount_resource.run_action(:mount)
        mount_resource.run_action(:enable)
        updates &lt;&lt; mount_resource.updated?
      end
      new_resource.updated_by_last_action(updates.any?)
    end</pre>   <h4 id="use-inline-resources">use_inline_resources</h4> <p>A custom resource is created by the <code class="docutils literal">action</code> block of a custom provider. When the resource collection is compiled, a custom resource is inserted into the top-level resource collection after the point at which the custom provider is associated. For example, if a resource collection looks like:</p> <pre class="highlight-python" data-language="python">top_level_resource_one
  lwrp_resource
top_level_resource_two</pre> <p>then when <code class="docutils literal">lwrp_resource</code> is executed, the resource collection will be modified as follows:</p> <pre class="highlight-python" data-language="python">top_level_resource_one           # already processed
  lwrp_resource                  # already processed
    embedded_resource_one        # created by the custom provider
    embedded_resource_two        # created by the custom provider
top_level_resource_two</pre> <p>In this situation, embedded custom resources cannot notify the top-level resource because the top-level resource has finished processing. This has the same effect as if the top-level resource collection were invisible to the embedded custom resources.</p> <p>To ensure that an embedded custom resource can notify the top-level resource add <code class="docutils literal">use_inline_resources</code> to the top of the file that defines the custom provider that is associated with that custom resource. When <code class="docutils literal">use_inline_resources</code> is added to the file, the code in the custom provider’s <code class="docutils literal">action</code> block will execute as part of a self-contained chef-client run. If any embedded custom resources are updated, the top-level custom resource is marked as updated and notifications set for the top-level resource will be triggered normally. This ensures that notifications work properly across the resource collection.</p> <p>For example:</p> <pre class="highlight-ruby" data-language="ruby">use_inline_resources

action :run do
  # Ruby code that implements the provider
end</pre> <div class="admonition warning"> <p class="first admonition-title">Warning</p> <p class="last">The <code class="docutils literal">use_inline_resources</code> method was added to the chef-client starting in version 11.0 to address the behavior described below. The <code class="docutils literal">use_inline_resources</code> method should be considered a requirement for any custom resource authored against the 11.0+ versions of the chef-client. This behavior will become the default behavior in an upcoming version of the chef-client.</p> </div>  <h5 id="background">Background</h5> <p>The reason why the <code class="docutils literal">use_inline_resources</code> method exists at all is due to how the chef-client processes resources. Currently, the default behavior of the chef-client processes a single collection of resources, converged on the node in order.</p> <p>A custom resource is often implemented using the core chef-client resources—<strong>file</strong>, <strong>template</strong>, <strong>package</strong>, and so on—as building blocks. A custom resource is then added to a recipe using the short name of the custom resource in the recipe (and not by using any of the building block resource components).</p> <p>This situation can create problems with notifications because the chef-client includes embedded resources in the “single collection of resources” after the parent resource has been fully evaluated.</p> <p>For example:</p> <pre class="highlight-ruby" data-language="ruby">custom_resource 'something' do
  action :run
  notifies :restart, 'service[whatever]', :immediately
end

service 'whatever' do
  action :nothing
end</pre> <p>If the <code class="docutils literal">custom_resource</code> is built using the <strong>file</strong> resource, what happens during the chef-client run is:</p> <pre class="highlight-python" data-language="python">custom_resource (not updated)
  file (updated)
service (skipped, due to ``:nothing``)</pre> <p>The <code class="docutils literal">custom_resource</code> is converged completely, its state set to not updated before the <strong>file</strong> resource is evaluated. The <code class="docutils literal">notifies :restart</code> is ignored and the service is not restarted.</p> <p>If the author of the custom resource knows in advance what notification is required, then the <strong>file</strong> resource can be configured for the notification in the provider. For example:</p> <pre class="highlight-ruby" data-language="ruby">action :run do
  file '/tmp/foo' do
    owner 'root'
    group 'root'
    mode '0644'
    notifies :restart, 'service[whatever]', :immediately
  end
end</pre> <p>And then in the recipe:</p> <pre class="highlight-ruby" data-language="ruby">service 'whatever' do
  action :nothing
end</pre> <p>This approach works, but only when the author of the custom resource knows what should be notified in advance of the chef-client run. Consequently, this is less-than-ideal for most situations.</p> <p>Using the <code class="docutils literal">use_inline_resources</code> method will ensure that the chef-client processes a custom resource as if it were its own resource collection—a “mini chef-client run”, effectively—that is converged before the chef-client finishes evaluating the parent custom resource. This ensures that any notifications that may exist in the embedded resources are processed as if they were notifications on the parent custom resource. For example:</p> <pre class="highlight-ruby" data-language="ruby">custom_resource 'something' do
  action :run
  notifies :restart, 'service[whatever]', :immediately
end

service 'whatever' do
  action :nothing
end</pre> <p>If the <code class="docutils literal">custom_resource</code> is built using the <strong>file</strong> resource, what happens during the chef-client run is:</p> <pre class="highlight-python" data-language="python">custom_resource (starts converging)
  file (updated)
custom_resource (updated, because ``file`` updated)
service (updates, because ``:immediately`` is set in the custom resource)</pre>   <h5 id="disable">Disable</h5> <p>The <code class="docutils literal">use_inline_resources</code> method should be considered a default method for any provider that defines a custom resource. It’s the correct behavior. And it will soon become the default behavior in a future version of the chef-client.</p> <p>Because inline compile mode makes it impossible for embedded resources to notify resources in the parent resource collection, inline compile mode may cause issues with some provider implementations. In these cases, use a definition to work around inline compile mode. See <a class="reference external" href="https://docs.chef.io/essentials_cookbook_definitions.html#many-recipes-one-definition" target="_blank">this example</a> for how to use a definition in this situation.</p>    <h4 id="whyrun-supported">whyrun_supported?</h4> <p>why-run mode is a way to see what the chef-client would have configured, had an actual chef-client run occurred. This approach is similar to the concept of “no-operation” (or “no-op”): decide what should be done, but then don’t actually do anything until it’s done right. This approach to configuration management can help identify where complexity exists in the system, where inter-dependencies may be located, and to verify that everything will be configured in the desired manner.</p> <p>When why-run mode is enabled, a chef-client run will occur that does everything up to the point at which configuration would normally occur. This includes getting the configuration data, authenticating to the Chef server, rebuilding the node object, expanding the run-list, getting the necessary cookbook files, resetting node attributes, identifying the resources, and building the resource collection and does not include mapping each resource to a provider or configuring any part of the system.</p> <div class="admonition note"> <p class="first admonition-title">Note</p> <p class="last">why-run mode is not a replacement for running cookbooks in a test environment that mirrors the production environment. Chef uses why-run mode to learn more about what is going on, but also Kitchen on developer systems, along with an internal OpenStack cloud and external cloud providers to test more thoroughly.</p> </div> <p>When the chef-client is run in why-run mode, certain assumptions are made:</p> <ul class="simple"> <li>If the <strong>service</strong> resource cannot find the appropriate command to verify the status of a service, why-run mode will assume that the command would have been installed by a previous resource and that the service would not be running</li> <li>For <code class="docutils literal">not_if</code> and <code class="docutils literal">only_if</code> attribute, why-run mode will assume these are commands or blocks that are safe to run. These conditions are not designed to be used to change the state of the system, but rather to help facilitate idempotency for the resource itself. That said, it may be possible that these attributes are being used in a way that modifies the system state</li> <li>The closer the current state of the system is to the desired state, the more useful why-run mode will be. For example, if a full run-list is run against a fresh system, that run-list may not be completely correct on the first try, but also that run-list will produce more output than a smaller run-list</li> </ul> <p>The <code class="docutils literal">whyrun_supported?</code> method is used to set a custom provider to support why-run mode. The syntax for the <code class="docutils literal">whyrun_supported?</code> method is as follows:</p> <pre class="highlight-ruby" data-language="ruby">def whyrun_supported?
  true
end</pre> <p>where <code class="docutils literal">whyrun_supported?</code> is set to <code class="docutils literal">true</code> for any custom provider that supports using why-run mode. When why-run mode is supported by the a custom provider, the <code class="docutils literal">converge_by</code> method is used to define the strings that are logged by the chef-client when it is run in why-run mode.</p> <div class="admonition note"> <p class="first admonition-title">Note</p> <p class="last">When a lightweight provider contains only platform resources, the <code class="docutils literal">converge_by</code> method is not required because it is already built into all of the platform <a class="reference external" href="https://docs.chef.io/resource.html" target="_blank">resources</a>.</p> </div>    <h3 id="id4">Examples</h3> <p>The following examples show various lightweight providers that use platform resources.</p>  <h4 id="aws-ebs-volume">aws_ebs_volume</h4> <p>The <code class="docutils literal">aws_ebs_volume</code> custom provider (found in the <a class="reference external" href="https://github.com/chef-cookbooks/aws" target="_blank">aws</a> cookbook) defines how the chef-client would handle a recipe that uses the <code class="docutils literal">ebs_volume</code> custom resource and the <code class="docutils literal">:detach</code> action. The following <code class="docutils literal">action</code> block tells the chef-client what to do with the <code class="docutils literal">:detach</code> action:</p> <pre class="highlight-ruby" data-language="ruby">action :detach do
  vol = determine_volume
  return if vol[:aws_instance_id] != instance_id
  converge_by('detach volume with id: #{vol[:aws_id]}') do
    detach_volume(vol[:aws_id], new_resource.timeout)
  end
end</pre> <p>and the following <code class="docutils literal">def</code> block defines the <code class="docutils literal">vol</code> variable called by the <code class="docutils literal">determine_volume</code> method:</p> <pre class="highlight-ruby" data-language="ruby">def determine_volume
  vol = currently_attached_volume(instance_id, new_resource.device)
  vol_id = new_resource.volume_id || volume_id_in_node_data || ( vol ? vol[:aws_id] : nil )
  raise 'volume_id attribute not set ... no volume is attached at the device' unless vol_id

  vol = volume_by_id(vol_id)
  raise 'No volume with id #{vol_id} exists' unless vol

  vol
end</pre>   <h4 id="cron-d">cron_d</h4> <p>The <code class="docutils literal">cron_d</code> custom provider (found in the <a class="reference external" href="https://github.com/chef-cookbooks/cron" target="_blank">cron</a> cookbook) is used to tell the chef-client what to do whenever the <code class="docutils literal">cron_d</code> custom resource is used in a recipe:</p> <pre class="highlight-ruby" data-language="ruby">action :delete do
  file '/etc/cron.d/#{new_resource.name}' do
    action :delete
  end
end

action :create do
  t = template '/etc/cron.d/#{new_resource.name}' do
    cookbook new_resource.cookbook
    source 'cron.d.erb'
    mode '0644'
    variables({
        :name =&gt; new_resource.name,
        :minute =&gt; new_resource.minute,
        :hour =&gt; new_resource.hour,
        :day =&gt; new_resource.day,
        :month =&gt; new_resource.month,
        :weekday =&gt; new_resource.weekday,
        :command =&gt; new_resource.command,
        :user =&gt; new_resource.user,
        :mailto =&gt; new_resource.mailto,
        :path =&gt; new_resource.path,
        :home =&gt; new_resource.home,
        :shell =&gt; new_resource.shell
      })
    action :create
  end
  new_resource.updated_by_last_action(t.updated_by_last_action?)
end</pre> <p>where:</p> <ul class="simple"> <li>two <code class="docutils literal">action</code> blocks are defined, one for the <code class="docutils literal">:create</code> action and one for the <code class="docutils literal">:delete</code> action</li> <li>the <code class="docutils literal">:delete</code> action block calls the <strong>file</strong> resource (and it’s <code class="docutils literal">:delete</code> action) to delete a file in the <code class="docutils literal">/etc/cron.d</code> folder</li> <li>the <code class="docutils literal">:create</code> action block creates a new entry in the <code class="docutils literal">/etc/cron.d</code> folder.</li> </ul> <p>For example, if a recipe used the <code class="docutils literal">cron_d</code> custom resource similar to the following:</p> <pre class="highlight-ruby" data-language="ruby">cron_d 'daily-usage-report' do
  minute '0'
  hour '23'
  command '/srv/app/scripts/daily_report'
  user 'appuser'
end</pre> <p>this tells the chef-client to use the <code class="docutils literal">cron_d</code> custom provider and the credentials for a user named <code class="docutils literal">appuser</code> to create a crontab entry named “daily-usage-report”. This crontab entry executes a command located in the <code class="docutils literal">/srv/app/scripts/daily_report</code> directory at a specified interval (defined by the <code class="docutils literal">minute</code> and <code class="docutils literal">hour</code> attributes). Any of the attributes that are not specified in the recipe (such as <code class="docutils literal">mailto</code>, <code class="docutils literal">weekday</code>, and <code class="docutils literal">day</code>) just use the default attribute values defined by the custom resource.</p>   <h4 id="rabbitmq-plugin">rabbitmq_plugin</h4> <p>The <code class="docutils literal">rabbitmq_plugin</code> custom provider (found in the <a class="reference external" href="https://supermarket.chef.io/cookbooks/rabbitmq" target="_blank">rabbitmq</a> cookbook) is used to tell the chef-client how to handle two actions (<code class="docutils literal">:disable</code> and <code class="docutils literal">:enable</code>) that are used to manage RabbitMQ plugins. Using this custom resource in a recipe is simple:</p> <pre class="highlight-ruby" data-language="ruby">rabbitmq_plugin 'my_plugin' do
  action :enable
end</pre> <p>The custom provider then does most of the work:</p> <pre class="highlight-ruby" data-language="ruby">action :enable do
  unless plugin_enabled?(new_resource.plugin)
    execute 'rabbitmq-plugins enable #{new_resource.plugin}' do
      Chef::Log.info 'Enabling RabbitMQ plugin '#{new_resource.plugin}'.'
      path plugins_bin_path(true)
      new_resource.updated_by_last_action(true)
    end
  end
end

def plugins_bin_path(return_array=false)
  path = ENV.fetch('PATH') + ':/usr/lib/rabbitmq/bin'
  return_array ? path.split(':') : path
end

def plugin_enabled?(name)
  cmdStr = "rabbitmq-plugins list -e '#{name}\\b'"
  cmd = Mixlib::ShellOut.new(cmdStr)
  cmd.environment['HOME'] = ENV.fetch('HOME', '/root')
  cmd.environment['PATH'] = plugins_bin_path
  cmd.run_command
  Chef::Log.debug 'rabbitmq_plugin_enabled?: #{cmdStr}'
  Chef::Log.debug 'rabbitmq_plugin_enabled?: #{cmd.stdout}'
  cmd.error!
  cmd.stdout =~ /\b#{name}\b/
end</pre>   <h4 id="ssh-known-hosts-entry">ssh_known_hosts_entry</h4> <p>The <code class="docutils literal">ssh_known_hosts_entry</code> custom provider (found in the <a class="reference external" href="https://github.com/chef-cookbooks/ssh_known_hosts" target="_blank">ssh_known_hosts</a> cookbook) is used to add hosts and keys to the <code class="docutils literal">/etc/ssh_known_hosts</code> file.</p> <pre class="highlight-ruby" data-language="ruby">action :create do
  key = (new_resource.key || `ssh-keyscan -H #{new_resource.host} 2&gt;&amp;1`)
  comment = key.split('\n').first

  Chef::Application.fatal! 'Could not resolve #{new_resource.host}' if key =~ /getaddrinfo/

  file node['ssh_known_hosts']['file'] do
    action        :create
    backup        false
    content
    only_if do
      !::File.exists?(node['ssh_known_hosts']['file']) || ::File.new(node['ssh_known_hosts']['file']).readlines.length == 0
    end
  end

  ruby_block "add #{new_resource.host} to #{node['ssh_known_hosts']['file']}" do
    block do
      file = ::Chef::Util::FileEdit.new(node['ssh_known_hosts']['file'])
      file.insert_line_if_no_match(/#{Regexp.escape(comment)}|#{Regexp.escape(key)}/, key)
      file.write_file
    end
  end
  new_resource.updated_by_last_action(true)
end</pre>     <h2 id="custom-providers-w-ruby">Custom Providers w/Ruby</h2> <p>Where a resource represents a piece of the system (and its desired state), a provider defines the steps that are needed to bring that piece of the system from its current state into the desired state.</p> <p>A custom provider is a custom provider that defines the steps that are required to complete one (or more) actions defined by a custom resource. A custom provider and custom resource work together, each being defined in the same cookbook (the <code class="docutils literal">/providers</code> and <code class="docutils literal">/resources</code> subdirectories, respectively); together, they are referred as a LWRP (or “custom resource/provider”). A custom provider is always authored using Ruby. Anything that can be done using Ruby can be done in a custom provider. In addition to using Ruby, the Provider DSL provides additional methods that are specific to the chef-client.</p>  <h3 id="id7">Syntax</h3> <p>This section shows some of the common structural elements that appear in a custom provider that is built using custom Ruby code. Remember:</p> <ul class="simple"> <li>A custom provider tells the chef-client how to complete a task</li> <li>The structure of a custom provider will vary, depending on the complexity of the tasks required to complete an action</li> <li>At its platform, a custom provider is just Ruby code, which means that anything that can be done in Ruby can be done in a custom provider</li> </ul> <p>The basic syntax for a custom provider that is built using custom Ruby code is as follows:</p> <pre class="highlight-ruby" data-language="ruby">use_inline_resources

def whyrun_supported?
  true
end

action :action_name do
  if updates_required?
    converge_by('message') do
      # some Ruby code
    end
  end
end

...

def updates_required?()
  # some Ruby code
  true
end</pre> <p>where:</p> <ul class="simple"> <li>
<code class="docutils literal">use_inline_resources</code> allows the custom provider to notify and be notified during the chef-client run</li> <li>
<code class="docutils literal">whyrun_supported?</code> indicates that a custom provider can be run in why-run mode</li> <li>
<code class="docutils literal">action</code> is the code block that tells the chef-client what to do when the <code class="docutils literal">:action_name</code> is used in a recipe</li> <li>
<code class="docutils literal">converge_by()</code> is used to provide a <code class="docutils literal">'message'</code> to be logged when a resource is updated during the chef-client run or to disable the code block when the chef-client is run in why-run mode</li> </ul> <p>Other commonly used methods (that are not shown in the previous example) are <code class="docutils literal">current_resource</code>, <code class="docutils literal">load_current_resource</code>, and <code class="docutils literal">new_resource</code>.</p> <p>The following example shows a custom provider:</p> <pre class="highlight-ruby" data-language="ruby">require 'chef/mixin/shell_out'
include Chef::Mixin::ShellOut

use_inline_resources

def whyrun_supported?
  true
end

action :fix do
  if modes_differ?
    converge_by("fix #{new_resource.path} mode to #{new_resource.mode}, was #{current_resource.mode}") do
      Chef::Log.debug "updating #{new_resource.path} to #{new_resource.mode} via shell_out!"
      shell_out!("chown #{new_resource.mode} #{new_resource.path}")

    end
  end
end

def modes_differ?
  current_resource.mode != new_resource.mode
end

def load_current_resource
  @current_resource = Chef::Resource::MyResource.new(new_resource.name)
  current_resource.path(new_resource.path)
  current_resource.mode(File.stat(new_resource.path).mode)
  current_resource
end</pre> <p>where:</p> <ul class="simple"> <li>
<code class="docutils literal">converge_by</code> uses the <code class="docutils literal">shell_out!</code> method; <code class="docutils literal">FileUtils.chown</code> is probably a better approach in most situations</li> <li>
<code class="docutils literal">load_current_resource</code> creates a <code class="docutils literal">current_resource</code> with the same name as <code class="docutils literal">new_resource</code>, sets the new resource paths to be the same as the current resource paths, and then inspects the system for properties of the current resource</li> </ul>   <h3 id="id8">Provider DSL Methods</h3> <p>The Provider DSL is a Ruby DSL that is used to help define a custom provider and to ensure that a custom provider takes the correct actions when it is called from a recipe. The Provider DSL is a small DSL with just a few methods that are specific to the chef-client. Because the Provider DSL is a Ruby DSL, anything that can be done using Ruby can also be done when defining a custom provider.</p>  <h4 id="id9">action</h4> <p>The <code class="docutils literal">action</code> method is used to define the steps that will be taken for each of the possible actions defined by the custom resource. Each action must be defined in separate <code class="docutils literal">action</code> blocks within the same file. The syntax for the <code class="docutils literal">action</code> method is as follows:</p> <pre class="highlight-ruby" data-language="ruby">action :action_name do
  # Chef resources or Ruby converge_by blocks
end</pre> <p>where:</p> <ul class="simple"> <li>
<code class="docutils literal">:action_name</code> corresponds to an action defined by a custom resource</li> <li>
<code class="docutils literal">converge_by</code> tells the chef-client which message to provide when the chef-client is run in why-run mode</li> </ul>   <h4 id="converge-by">converge_by</h4> <p>The <code class="docutils literal">converge_by</code> method is a wrapper that is used to support why-run mode and must wrap any Ruby calls that updates system state. All core Chef resources internally use <code class="docutils literal">converge_by</code> and support why-run mode by default. To ensure that a custom provider is idempotent, <code class="docutils literal">converge_by</code> blocks must be checked for idempotency.</p> <p>The syntax of a <code class="docutils literal">converge_by</code> block is:</p> <pre class="highlight-ruby" data-language="ruby">converge_by('message')</pre> <p>where:</p> <ul class="simple"> <li>
<code class="docutils literal">converge_by()</code> is added to an <code class="docutils literal">action</code> block as a wrapper</li> <li>
<code class="docutils literal">'message'</code> is the message returned by the chef-client when the resource runs</li> </ul> <p>Some examples:</p> <pre class="highlight-ruby" data-language="ruby">unless Dir.exist?(new_resource.path)
  converge_by("Create directory #{ new_resource.path }") do
    FileUtils.mkdir new_resource.path
  end
end</pre> <pre class="highlight-ruby" data-language="ruby">if should_create_user?
  converge_by("Create user #{ new_resource.user }") do
    shell_out!("adduser #{ new_resource.user }")
  end
end</pre> <pre class="highlight-ruby" data-language="ruby">if should_update_stuff?
  description = 'create dir #{app_root} and change owner to #{new_resource.owner}'
  converge_by(description) do
    FileUtils.mkdir app_root, :mode =&gt; new_resource.app_home_mode
    FileUtils.chown new_resource.owner, new_resource.owner, app_root
  end
end</pre> <p>where the last example shows using a variable (<code class="docutils literal">description</code>) as the <code class="docutils literal">'message'</code> in the <code class="docutils literal">converge_by</code> block.</p> <p>An example of the <code class="docutils literal">converge_by</code> method exists in the provider for <a class="reference external" href="https://github.com/chef/chef/blob/master/lib/chef/provider/directory.rb" target="_blank">directory</a> resource, which is a core Chef resource:</p> <pre class="highlight-ruby" data-language="ruby">def whyrun_supported?
  true
end

...

def action_create
  unless File.exist?(@new_resource.path)
    converge_by('create new directory #{@new_resource.path}') do
      if @new_resource.recursive == true
        ::FileUtils.mkdir_p(@new_resource.path)
      else
        ::Dir.mkdir(@new_resource.path)
      end
      Chef::Log.info('#{@new_resource} created directory #{@new_resource.path}')
    end
  end
  set_all_access_controls
  update_new_file_state
end</pre> <div class="admonition note"> <p class="first admonition-title">Note</p> <p class="last">why-run mode is already enabled for platform resources. When platform resources are used as part of the <code class="docutils literal">action</code> block in a custom provider, only the <code class="docutils literal">whyrun_supported?</code> is required to allow the chef-client to run in why-run mode.</p> </div>   <h4 id="id10">current_resource</h4> <p>The <code class="docutils literal">current_resource</code> method is used to represent a resource as it exists on the node at the beginning of the chef-client run. In other words: what the resource is currently. The custom provider should compare the resource as it exists on the node to the <code class="docutils literal">new_resource</code> that is created during the chef-client run, and then determine what steps should be taken to bring the resource into the desired state.</p> <p>For example:</p> <pre class="highlight-ruby" data-language="ruby">action :add do
  unless current_resource.exists
    cmd = "#{appcmd} add app /site.name:\'#{new_resource.app_name}\'"
    cmd &lt;&lt; " /path:\'#{new_resource.path}\'"
    cmd &lt;&lt; " /applicationPool:\'#{new_resource.application_pool}\'" if new_resource.application_pool
    cmd &lt;&lt; " /physicalPath:\'#{new_resource.physical_path}\'" if new_resource.physical_path
    converge_by("creating App") do
      Chef::Log.debug(cmd)
      shell_out!(cmd)
      Chef::Log.debug('App created')
    end
  else
    Chef::Log.debug('#{new_resource} app already exists - nothing to do')
  end
end</pre> <p>where the <code class="docutils literal">unless</code> conditional statement checks to make sure the resource doesn’t already exist on a node, and then runs a series of commands when it doesn’t. If the resource already exists, the log entry would be <code class="docutils literal">Foo app already exists - nothing to do</code>.</p>   <h4 id="id11">load_current_resource</h4> <p>The <code class="docutils literal">load_current_resource</code> method is used to construct the curent state of the resource on the node. This is in contrast to the <code class="docutils literal">new_resource</code> method which represents the desired state of the resource on the node. Both methods are constructed the same way. Properties should be loaded from the node’s state.</p> <p>For example:</p> <pre class="highlight-ruby" data-language="ruby">def load_current_resource

  @current_resource = Chef::Resource::MyResource.new(new_resource.name)

  current_resource.path(new_resource.path)
  # Most other current_resource properites will be found by inspecting the system (e.g. Wwhat is
  # the current version of the installed package?  What are the existing file modes?)
  current_resource.mode(File.stat(new_resource.path).mode)
  current_resource
end</pre> <p>where:</p> <ul class="simple"> <li>
<code class="docutils literal">load_current_resource</code> returns the <code class="docutils literal">current_resource</code> (and builds the instance variable)</li> <li>
<code class="docutils literal">@current_resource</code> is an instance variable that creates a <code class="docutils literal">current_resource</code> with the same name as <code class="docutils literal">new_resource</code>
</li> <li>
<code class="docutils literal">current_resource.path(new_resource.path)</code> sets the new resource paths to be the same as the current resource paths</li> <li>
<code class="docutils literal">current_resource.mode(File.stat(new_resource.path).mode)</code> inspects the system for properties of the current resource</li> <li>
<code class="docutils literal">current_resource</code> returns the current resource and allows the <code class="docutils literal">new_resource</code> to be compared to check for idempotentcy</li> </ul>   <h4 id="id12">new_resource</h4> <p>The <code class="docutils literal">new_resource</code> method is used to represent a resource as loaded by the chef-client during the chef-client run. In other words: what the resource should be. The custom provider should compare the resource as it exists on the node to the resource that is created during the chef-client run to determine what steps need to be taken to bring the resource into the desired state.</p> <p>For example:</p> <pre class="highlight-ruby" data-language="ruby">action :delete do
  if ::File.exists?(new_resource.path)
    converge_by("deleting #{new_resource.path}) do
      if ::File.writable?(new_resource.path)
        Chef::Log.info("Deleting #{new_resource} at #{new_resource.path}")
        ::File.delete(new_resource.path)
      else
        raise "Cannot delete #{new_resource} at #{new_resource.path}!"
      end
    end
  end
end</pre> <p>where</p> <ul class="simple"> <li>The chef-client checks to see if the file exists, then if the file is writable, and then attempts to delete the resource</li> <li>
<code class="docutils literal">path</code> is an attribute of the new resource that is defined by the custom resource</li> </ul>   <h4 id="require">require</h4> <p>The <code class="docutils literal">require</code> method is used point the chef-client to the location of an external class library.</p> <p>For example:</p> <pre class="highlight-ruby" data-language="ruby">require 'path/to/external/library'</pre>   <h4 id="id13">updated_by_last_action</h4> <div class="admonition warning"> <p class="first admonition-title">Warning</p> <p class="last">The direct use of <code class="docutils literal">updated_by_last_action</code> is deprecated; any provider that is using this method must be updated to use the <code class="docutils literal">use_inline_resources</code> method instead. For actions that modify the system state, define them with core Chef resources or group them within <code class="docutils literal">converge_by</code> blocks.</p> </div>   <h4 id="id14">whyrun_supported?</h4> <p>why-run mode is a way to see what the chef-client would have configured, had an actual chef-client run occurred. This approach is similar to the concept of “no-operation” (or “no-op”): decide what should be done, but then don’t actually do anything until it’s done right. This approach to configuration management can help identify where complexity exists in the system, where inter-dependencies may be located, and to verify that everything will be configured in the desired manner.</p> <p>When why-run mode is enabled, a chef-client run will occur that does everything up to the point at which configuration would normally occur. This includes getting the configuration data, authenticating to the Chef server, rebuilding the node object, expanding the run-list, getting the necessary cookbook files, resetting node attributes, identifying the resources, and building the resource collection and does not include mapping each resource to a provider or configuring any part of the system.</p> <div class="admonition note"> <p class="first admonition-title">Note</p> <p class="last">why-run mode is not a replacement for running cookbooks in a test environment that mirrors the production environment. Chef uses why-run mode to learn more about what is going on, but also Kitchen on developer systems, along with an internal OpenStack cloud and external cloud providers to test more thoroughly.</p> </div> <p>When the chef-client is run in why-run mode, certain assumptions are made:</p> <ul class="simple"> <li>If the <strong>service</strong> resource cannot find the appropriate command to verify the status of a service, why-run mode will assume that the command would have been installed by a previous resource and that the service would not be running</li> <li>For <code class="docutils literal">not_if</code> and <code class="docutils literal">only_if</code> attribute, why-run mode will assume these are commands or blocks that are safe to run. These conditions are not designed to be used to change the state of the system, but rather to help facilitate idempotency for the resource itself. That said, it may be possible that these attributes are being used in a way that modifies the system state</li> <li>The closer the current state of the system is to the desired state, the more useful why-run mode will be. For example, if a full run-list is run against a fresh system, that run-list may not be completely correct on the first try, but also that run-list will produce more output than a smaller run-list</li> </ul> <p>The <code class="docutils literal">whyrun_supported?</code> method is used to set a custom provider to support why-run mode. The syntax for the <code class="docutils literal">whyrun_supported?</code> method is as follows:</p> <pre class="highlight-ruby" data-language="ruby">def whyrun_supported?
  true
end</pre> <p>where <code class="docutils literal">whyrun_supported?</code> is set to <code class="docutils literal">true</code> for any custom provider that supports using why-run mode. When why-run mode is supported by the a custom provider, the <code class="docutils literal">converge_by</code> method is used to define the strings that are logged by the chef-client when it is run in why-run mode.</p>    <h3 id="libraries">Libraries</h3> <p>A custom provider can extend another provider class. This can be done as a <code class="docutils literal">mixin</code>, which is then placed in a library under the <code class="docutils literal">library/</code> directory of any cookbook that will use the extended provider class. The custom provider is then written to include that library in its implementation so that it has access to the extended platform resource. Use the <code class="docutils literal">include</code> method in the custom provider to ensure that a custom provider has access to an external library.</p> <p>For example:</p> <pre class="highlight-ruby" data-language="ruby">include Chef::Mixin::ShellOut</pre>    <h2 id="library-resources">Library Resources</h2> <p>A resource can also be defined in <code class="docutils literal">/libraries</code> directory. Some advantages of this approach include more control over how resources behave in the provider, the ability to control the name of the resource directly, and more options available for writing tests. The resources and providers for a library resource, similar to lightweight resources (defined in the <code class="docutils literal">/resources</code> and <code class="docutils literal">/providers</code> folders) typically have a separate file for the resource and the provider, but this is not requirement. The main disadvantage of this approach is that resources defined in the <code class="docutils literal">/libraries</code> directory may not use the Recipe DSL.</p> <p>A resource that is defined in the <code class="docutils literal">/libraries</code> directory may leverage core chef-client resources by using the following syntax:</p> <pre class="highlight-ruby" data-language="ruby">Chef::Resource::name_of_resource.new('name', run_context)</pre> <p>or:</p> <pre class="highlight-ruby" data-language="ruby">Chef::Resource::name_of_resource.new(:action)</pre> <p>For example, the following definition leverages the <strong>directory</strong> resource to create a new directory, and then evaluate that within the context of the custom resource:</p> <pre class="highlight-ruby" data-language="ruby">def env_dir
  return @env_dir unless @env_dir.nil?
  @env_dir = Chef::Resource::Directory.new(::File.join(sv_dir_name, 'env'), run_context)
  @env_dir.owner(new_resource.owner)
  @env_dir.group(new_resource.group)
  @env_dir.mode(00755)
  @env_dir
end</pre> <p>The following definition uses the <strong>template</strong> resource for Debian-specific cases, but then the <strong>link</strong> resource for everything else:</p> <pre class="highlight-ruby" data-language="ruby">def lsb_init
  return @lsb_init unless @lsb_init.nil?
  initfile = ::File.join(new_resource.lsb_init_dir, new_resource.service_name)
  if node['platform'] == 'debian'
    ::File.unlink(initfile) if ::File.symlink?(initfile)
    @lsb_init = Chef::Resource::Template.new(initfile, run_context)
    @lsb_init.owner('root')
    @lsb_init.group('root')
    @lsb_init.mode(00755)
    @lsb_init.cookbook('runit')
    @lsb_init.source('init.d.erb')
    @lsb_init.variables(:name =&gt; new_resource.service_name)
  else
    @lsb_init = Chef::Resource::Link.new(initfile, run_context)
    @lsb_init.to(new_resource.sv_bin)
  end
  @lsb_init
end</pre> <p>Otherwise, a resource defined in the <code class="docutils literal">/libraries</code> directory is done using Ruby, is added to recipes as if it were any other resource, and is processed by the chef-client in the same way as any other resource. See the <code class="docutils literal">/libraries</code> directory in the <a class="reference external" href="https://github.com/chef-cookbooks/database" target="_blank">database</a> and <a class="reference external" href="https://github.com/hw-cookbooks/runit" target="_blank">runit</a> cookbooks for complete examples of how to use this approach when defining a resource.</p>   <h2 id="more-reading">More Reading</h2> <p>Doug Ireton (a community member) has a blog with a nice series on LWRPs:</p> <ul class="simple"> <li>Part 1: <a class="reference external" href="http://dougireton.com/blog/2012/12/31/creating-an-lwrp/" target="_blank">http://dougireton.com/blog/2012/12/31/creating-an-lwrp/</a>
</li> <li>Part 2: <a class="reference external" href="http://dougireton.com/blog/2013/01/07/creating-an-lwrp-part-2/" target="_blank">http://dougireton.com/blog/2013/01/07/creating-an-lwrp-part-2/</a>
</li> <li>Part 3: <a class="reference external" href="http://dougireton.com/blog/2013/01/13/creating-an-lwrp-part-3/" target="_blank">http://dougireton.com/blog/2013/01/13/creating-an-lwrp-part-3/</a>
</li> </ul>
<div class="_attribution">
  <p class="_attribution-p">
    © Chef Software, Inc.<br>Licensed under the Creative Commons Attribution 3.0 Unported License.<br>The Chef™ Mark and Chef Logo are either registered trademarks/service marks or trademarks/servicemarks of Chef, in the United States and other countries and are used with Chef Inc's permission.<br>We are not affiliated with, endorsed or sponsored by Chef Inc.<br>
    <a href="https://docs.chef.io/release/11-18/custom_resources.html" class="_attribution-link" target="_blank">https://docs.chef.io/release/11-18/custom_resources.html</a>
  </p>
</div>

			</div>
		</div>
	</section>

	</div>
</body>
</html>
