
<!DOCTYPE HTML>

<html lang="en">

<head>
  <meta charset="utf-8">
  <title>Hash - Ruby on Rails 4.1 - W3cubDocs</title>
  
  <meta name="description" content=" Builds a Hash from XML just like Hash.from_xml, but also allows Symbol and YAML. ">
  <meta name="keywords" content="class, hash, -, ruby, on, rails, rails~4.1">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="http://docs.w3cub.com/rails~4.1/hash/">
  <link href="/favicon.png" rel="icon">
  <link type="text/css" rel="stylesheet" href="/assets/application-50364fff564ce3b6327021805f3f00e2957b441cf27f576a7dd4ff63bbc47047.css">
  <script type="text/javascript" src="/assets/application-db64bfd54ceb42be11af7995804cf4902548419ceb79d509b0b7d62c22d98e6f.js"></script>
  <script src="/json/rails~4.1.js"></script>
  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-71174418-1']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>


</head>

<body>
	<div class="_app">
	<header class="_header">
  
  <form class="_search">
    <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
    <a class="_search-clear"></a>
    <div class="_search-tag"></div>
  </form>
  
  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/rails~4.1/" class="_nav-link" title="" style="margin-left:0;">Ruby on Rails 4.1</a></span>
  
  <nav class="_nav">
    <a href="/app/" class="_nav-link ">App</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		<div class="_list">
			
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<div class="_page _rdoc">
				
<h1 id="class-Hash" class="class"> class Hash </h1>
<dl class="meta">
<dt>Parent:</dt>
<dd class="meta-parent"><a href="../object/">Object</a></dd>
</dl>  <section id="5Buntitled-5D" class="documentation-section"> <section id="public-class-5Buntitled-5D-method-details" class="method-section"> <header> <h3>Public Class Methods</h3> </header> <div class="method-detail "> <div class="method-heading" id="method-c-from_trusted_xml"> <span class="method-name">from_trusted_xml</span><span class="method-args">(xml)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description"> <p>Builds a <a href="../hash/">Hash</a> from XML just like <code>Hash.from_xml</code>, but also allows <a href="../symbol/">Symbol</a> and YAML.</p> <div class="method-source-code" id="from_trusted_xml-source"> <pre class="ruby" data-language="ruby"># File activesupport/lib/active_support/core_ext/hash/conversions.rb, line 115
def from_trusted_xml(xml)
  from_xml xml, []
end</pre> </div> </div> </div> <div class="method-detail "> <div class="method-heading" id="method-c-from_xml"> <span class="method-name">from_xml</span><span class="method-args">(xml, disallowed_types = nil)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description"> <p>Returns a <a href="../hash/">Hash</a> containing a collection of pairs when the key is the node name and the value is its content</p> <pre class="ruby" data-language="ruby">xml = &lt;&lt;-XML
  &lt;?xml version="1.0" encoding="UTF-8"?&gt;
    &lt;hash&gt;
      &lt;foo type="integer"&gt;1&lt;/foo&gt;
      &lt;bar type="integer"&gt;2&lt;/bar&gt;
    &lt;/hash&gt;
XML

hash = Hash.from_xml(xml)
# =&gt; {"hash"=&gt;{"foo"=&gt;1, "bar"=&gt;2}}
</pre> <p>DisallowedType is raised if the XML contains attributes with <code>type="yaml"</code> or <code>type="symbol"</code>. Use <code>Hash.from_trusted_xml</code> to parse this XML.</p> <div class="method-source-code" id="from_xml-source"> <pre class="ruby" data-language="ruby"># File activesupport/lib/active_support/core_ext/hash/conversions.rb, line 110
def from_xml(xml, disallowed_types = nil)
  ActiveSupport::XMLConverter.new(xml, disallowed_types).to_h
end</pre> </div> </div> </div> </section> <section id="public-instance-5Buntitled-5D-method-details" class="method-section"> <header> <h3>Public Instance Methods</h3> </header> <div class="method-detail "> <div class="method-heading" id="method-i-assert_valid_keys"> <span class="method-name">assert_valid_keys</span><span class="method-args">(*valid_keys)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description"> <p>Validate all keys in a hash match <code>*valid_keys</code>, raising ArgumentError on a mismatch. Note that keys are NOT treated indifferently, meaning if you use strings for keys but assert symbols as keys, this will fail.</p> <pre class="ruby" data-language="ruby">{ name: 'Rob', years: '28' }.assert_valid_keys(:name, :age) # =&gt; raises "ArgumentError: Unknown key: :years. Valid keys are: :name, :age"
{ name: 'Rob', age: '28' }.assert_valid_keys('name', 'age') # =&gt; raises "ArgumentError: Unknown key: :name. Valid keys are: 'name', 'age'"
{ name: 'Rob', age: '28' }.assert_valid_keys(:name, :age)   # =&gt; passes, raises nothing
</pre> <div class="method-source-code" id="assert_valid_keys-source"> <pre class="ruby" data-language="ruby"># File activesupport/lib/active_support/core_ext/hash/keys.rb, line 67
def assert_valid_keys(*valid_keys)
  valid_keys.flatten!
  each_key do |k|
    unless valid_keys.include?(k)
      raise ArgumentError.new("Unknown key: #{k.inspect}. Valid keys are: #{valid_keys.map(&amp;:inspect).join(', ')}")
    end
  end
end</pre> </div> </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-compact"> <span class="method-name">compact</span><span class="method-args">()</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description"> <p>Returns a hash with non <code>nil</code> values.</p> <pre class="ruby" data-language="ruby">hash = { a: true, b: false, c: nil}
hash.compact # =&gt; { a: true, b: false}
hash # =&gt; { a: true, b: false, c: nil}
{ c: nil }.compact # =&gt; {}
</pre> <div class="method-source-code" id="compact-source"> <pre class="ruby" data-language="ruby"># File activesupport/lib/active_support/core_ext/hash/compact.rb, line 8
def compact
  self.select { |_, value| !value.nil? }
end</pre> </div> </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-compact-21"> <span class="method-name">compact!</span><span class="method-args">()</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description"> <p>Replaces current hash with non <code>nil</code> values.</p> <pre class="ruby" data-language="ruby">hash = { a: true, b: false, c: nil}
hash.compact! # =&gt; { a: true, b: false}
hash # =&gt; { a: true, b: false}
</pre> <div class="method-source-code" id="compact-21-source"> <pre class="ruby" data-language="ruby"># File activesupport/lib/active_support/core_ext/hash/compact.rb, line 17
def compact!
  self.reject! { |_, value| value.nil? }
end</pre> </div> </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-deep_dup"> <span class="method-name">deep_dup</span><span class="method-args">()</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description"> <p>Returns a deep copy of hash.</p> <pre class="ruby" data-language="ruby">hash = { a: { b: 'b' } }
dup  = hash.deep_dup
dup[:a][:c] = 'c'

hash[:a][:c] # =&gt; nil
dup[:a][:c]  # =&gt; "c"
</pre> <div class="method-source-code" id="deep_dup-source"> <pre class="ruby" data-language="ruby"># File activesupport/lib/active_support/core_ext/object/deep_dup.rb, line 41
def deep_dup
  each_with_object(dup) do |(key, value), hash|
    hash[key.deep_dup] = value.deep_dup
  end
end</pre> </div> </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-deep_merge"> <span class="method-name">deep_merge</span><span class="method-args">(other_hash, &amp;block)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description"> <p>Returns a new hash with <code>self</code> and <code>other_hash</code> merged recursively.</p> <pre class="ruby" data-language="ruby">h1 = { a: true, b: { c: [1, 2, 3] } }
h2 = { a: false, b: { x: [3, 4, 5] } }

h1.deep_merge(h2) #=&gt; { a: false, b: { c: [1, 2, 3], x: [3, 4, 5] } }
</pre> <p>Like with Hash#merge in the standard library, a block can be provided to merge values:</p> <pre class="ruby" data-language="ruby">h1 = { a: 100, b: 200, c: { c1: 100 } }
h2 = { b: 250, c: { c1: 200 } }
h1.deep_merge(h2) { |key, this_val, other_val| this_val + other_val }
# =&gt; { a: 100, b: 450, c: { c1: 300 } }
</pre> <div class="method-source-code" id="deep_merge-source"> <pre class="ruby" data-language="ruby"># File activesupport/lib/active_support/core_ext/hash/deep_merge.rb, line 16
def deep_merge(other_hash, &amp;block)
  dup.deep_merge!(other_hash, &amp;block)
end</pre> </div> </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-deep_merge-21"> <span class="method-name">deep_merge!</span><span class="method-args">(other_hash, &amp;block)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description"> <p>Same as <code>deep_merge</code>, but modifies <code>self</code>.</p> <div class="method-source-code" id="deep_merge-21-source"> <pre class="ruby" data-language="ruby"># File activesupport/lib/active_support/core_ext/hash/deep_merge.rb, line 21
def deep_merge!(other_hash, &amp;block)
  other_hash.each_pair do |current_key, other_value|
    this_value = self[current_key]

    self[current_key] = if this_value.is_a?(Hash) &amp;&amp; other_value.is_a?(Hash)
      this_value.deep_merge(other_value, &amp;block)
    else
      if block_given? &amp;&amp; key?(current_key)
        block.call(current_key, this_value, other_value)
      else
        other_value
      end
    end
  end

  self
end</pre> </div> </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-deep_stringify_keys"> <span class="method-name">deep_stringify_keys</span><span class="method-args">()</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description"> <p>Returns a new hash with all keys converted to strings. This includes the keys from the root hash and from all nested hashes and arrays.</p> <pre class="ruby" data-language="ruby">hash = { person: { name: 'Rob', age: '28' } }

hash.deep_stringify_keys
# =&gt; {"person"=&gt;{"name"=&gt;"Rob", "age"=&gt;"28"}}
</pre> <div class="method-source-code" id="deep_stringify_keys-source"> <pre class="ruby" data-language="ruby"># File activesupport/lib/active_support/core_ext/hash/keys.rb, line 103
def deep_stringify_keys
  deep_transform_keys{ |key| key.to_s }
end</pre> </div> </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-deep_stringify_keys-21"> <span class="method-name">deep_stringify_keys!</span><span class="method-args">()</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description"> <p>Destructively convert all keys to strings. This includes the keys from the root hash and from all nested hashes and arrays.</p> <div class="method-source-code" id="deep_stringify_keys-21-source"> <pre class="ruby" data-language="ruby"># File activesupport/lib/active_support/core_ext/hash/keys.rb, line 110
def deep_stringify_keys!
  deep_transform_keys!{ |key| key.to_s }
end</pre> </div> </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-deep_symbolize_keys"> <span class="method-name">deep_symbolize_keys</span><span class="method-args">()</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description"> <p>Returns a new hash with all keys converted to symbols, as long as they respond to <code>to_sym</code>. This includes the keys from the root hash and from all nested hashes and arrays.</p> <pre class="ruby" data-language="ruby">hash = { 'person' =&gt; { 'name' =&gt; 'Rob', 'age' =&gt; '28' } }

hash.deep_symbolize_keys
# =&gt; {:person=&gt;{:name=&gt;"Rob", :age=&gt;"28"}}
</pre> <div class="method-source-code" id="deep_symbolize_keys-source"> <pre class="ruby" data-language="ruby"># File activesupport/lib/active_support/core_ext/hash/keys.rb, line 122
def deep_symbolize_keys
  deep_transform_keys{ |key| key.to_sym rescue key }
end</pre> </div> </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-deep_symbolize_keys-21"> <span class="method-name">deep_symbolize_keys!</span><span class="method-args">()</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description"> <p>Destructively convert all keys to symbols, as long as they respond to <code>to_sym</code>. This includes the keys from the root hash and from all nested hashes and arrays.</p> <div class="method-source-code" id="deep_symbolize_keys-21-source"> <pre class="ruby" data-language="ruby"># File activesupport/lib/active_support/core_ext/hash/keys.rb, line 129
def deep_symbolize_keys!
  deep_transform_keys!{ |key| key.to_sym rescue key }
end</pre> </div> </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-deep_transform_keys"> <span class="method-name">deep_transform_keys</span><span class="method-args">(&amp;block)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description"> <p>Returns a new hash with all keys converted by the block operation. This includes the keys from the root hash and from all nested hashes and arrays.</p> <pre class="ruby" data-language="ruby">hash = { person: { name: 'Rob', age: '28' } }

hash.deep_transform_keys{ |key| key.to_s.upcase }
# =&gt; {"PERSON"=&gt;{"NAME"=&gt;"Rob", "AGE"=&gt;"28"}}
</pre> <div class="method-source-code" id="deep_transform_keys-source"> <pre class="ruby" data-language="ruby"># File activesupport/lib/active_support/core_ext/hash/keys.rb, line 84
def deep_transform_keys(&amp;block)
  _deep_transform_keys_in_object(self, &amp;block)
end</pre> </div> </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-deep_transform_keys-21"> <span class="method-name">deep_transform_keys!</span><span class="method-args">(&amp;block)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description"> <p>Destructively convert all keys by using the block operation. This includes the keys from the root hash and from all nested hashes and arrays.</p> <div class="method-source-code" id="deep_transform_keys-21-source"> <pre class="ruby" data-language="ruby"># File activesupport/lib/active_support/core_ext/hash/keys.rb, line 91
def deep_transform_keys!(&amp;block)
  _deep_transform_keys_in_object!(self, &amp;block)
end</pre> </div> </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-except"> <span class="method-name">except</span><span class="method-args">(*keys)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description"> <p>Returns a hash that includes everything but the given keys. This is useful for limiting a set of parameters to everything but a few known toggles:</p> <pre class="ruby" data-language="ruby">@person.update(params[:person].except(:admin))
</pre> <div class="method-source-code" id="except-source"> <pre class="ruby" data-language="ruby"># File activesupport/lib/active_support/core_ext/hash/except.rb, line 6
def except(*keys)
  dup.except!(*keys)
end</pre> </div> </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-except-21"> <span class="method-name">except!</span><span class="method-args">(*keys)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description"> <p>Replaces the hash without the given keys.</p> <div class="method-source-code" id="except-21-source"> <pre class="ruby" data-language="ruby"># File activesupport/lib/active_support/core_ext/hash/except.rb, line 11
def except!(*keys)
  keys.each { |key| delete(key) }
  self
end</pre> </div> </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-extract-21"> <span class="method-name">extract!</span><span class="method-args">(*keys)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description"> <p>Removes and returns the key/value pairs matching the given keys.</p> <pre class="ruby" data-language="ruby">{ a: 1, b: 2, c: 3, d: 4 }.extract!(:a, :b) # =&gt; {:a=&gt;1, :b=&gt;2}
{ a: 1, b: 2 }.extract!(:a, :x)             # =&gt; {:a=&gt;1}
</pre> <div class="method-source-code" id="extract-21-source"> <pre class="ruby" data-language="ruby"># File activesupport/lib/active_support/core_ext/hash/slice.rb, line 39
def extract!(*keys)
  keys.each_with_object(self.class.new) { |key, result| result[key] = delete(key) if has_key?(key) }
end</pre> </div> </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-extractable_options-3F"> <span class="method-name">extractable_options?</span><span class="method-args">()</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description"> <p>By default, only instances of <a href="../hash/">Hash</a> itself are extractable. Subclasses of <a href="../hash/">Hash</a> may implement this method and return true to declare themselves as extractable. If a <a href="../hash/">Hash</a> is extractable, <a href="../array/#method-i-extract_options-21">Array#extract_options!</a> pops it from the <a href="../array/">Array</a> when it is the last element of the <a href="../array/">Array</a>.</p> <div class="method-source-code" id="extractable_options-3F-source"> <pre class="ruby" data-language="ruby"># File activesupport/lib/active_support/core_ext/array/extract_options.rb, line 7
def extractable_options?
  instance_of?(Hash)
end</pre> </div> </div> </div> <div class="method-detail method-alias"> <div class="method-heading" id="method-i-nested_under_indifferent_access"> <span class="method-name">nested_under_indifferent_access</span><span class="method-args">()</span> </div> <div class="method-description"> <p>Called when object is nested under an object that receives <a href="../hash/#method-i-with_indifferent_access">with_indifferent_access</a>. This method will be called on the current object by the enclosing object and is aliased to <a href="../hash/#method-i-with_indifferent_access">with_indifferent_access</a> by default. Subclasses of <a href="../hash/">Hash</a> may overwrite this method to return <code>self</code> if converting to an <code>ActiveSupport::HashWithIndifferentAccess</code> would not be desirable.</p> <pre class="ruby" data-language="ruby">b = { b: 1 }
{ a: b }.with_indifferent_access['a'] # calls b.nested_under_indifferent_access
# =&gt; {"b"=&gt;32}
</pre> </div> <div class="aliases"> Alias for: <a href="../hash/#method-i-with_indifferent_access">with_indifferent_access</a> </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-reverse_merge"> <span class="method-name">reverse_merge</span><span class="method-args">(other_hash)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description"> <p>Merges the caller into <code>other_hash</code>. For example,</p> <pre class="ruby" data-language="ruby">options = options.reverse_merge(size: 25, velocity: 10)
</pre> <p>is equivalent to</p> <pre class="ruby" data-language="ruby">options = { size: 25, velocity: 10 }.merge(options)
</pre> <p>This is particularly useful for initializing an options hash with default values.</p> <div class="method-source-code" id="reverse_merge-source"> <pre class="ruby" data-language="ruby"># File activesupport/lib/active_support/core_ext/hash/reverse_merge.rb, line 12
def reverse_merge(other_hash)
  other_hash.merge(self)
end</pre> </div> </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-reverse_merge-21"> <span class="method-name">reverse_merge!</span><span class="method-args">(other_hash)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description"> <p>Destructive <code>reverse_merge</code>.</p> <div class="method-source-code" id="reverse_merge-21-source"> <pre class="ruby" data-language="ruby"># File activesupport/lib/active_support/core_ext/hash/reverse_merge.rb, line 17
def reverse_merge!(other_hash)
  # right wins if there is no left
  merge!( other_hash ){|key,left,right| left }
end</pre> </div> </div> <div class="aliases"> Also aliased as: <a href="../hash/#method-i-reverse_update">reverse_update</a> </div> </div> <div class="method-detail method-alias"> <div class="method-heading" id="method-i-reverse_update"> <span class="method-name">reverse_update</span><span class="method-args">(other_hash)</span> </div>  <div class="aliases"> Alias for: <a href="../hash/#method-i-reverse_merge-21">reverse_merge!</a> </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-slice"> <span class="method-name">slice</span><span class="method-args">(*keys)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description"> <p>Slice a hash to include only the given keys. This is useful for limiting an options hash to valid keys before passing to a method:</p> <pre class="ruby" data-language="ruby">def search(criteria = {})
  criteria.assert_valid_keys(:mass, :velocity, :time)
end

search(options.slice(:mass, :velocity, :time))
</pre> <p>If you have an array of keys you want to limit to, you should splat them:</p> <pre class="ruby" data-language="ruby">valid_keys = [:mass, :velocity, :time]
search(options.slice(*valid_keys))
</pre> <div class="method-source-code" id="slice-source"> <pre class="ruby" data-language="ruby"># File activesupport/lib/active_support/core_ext/hash/slice.rb, line 15
def slice(*keys)
  keys.map! { |key| convert_key(key) } if respond_to?(:convert_key, true)
  keys.each_with_object(self.class.new) { |k, hash| hash[k] = self[k] if has_key?(k) }
end</pre> </div> </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-slice-21"> <span class="method-name">slice!</span><span class="method-args">(*keys)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description"> <p>Replaces the hash with only the given keys. Returns a hash containing the removed key/value pairs.</p> <pre class="ruby" data-language="ruby">{ a: 1, b: 2, c: 3, d: 4 }.slice!(:a, :b)
# =&gt; {:c=&gt;3, :d=&gt;4}
</pre> <div class="method-source-code" id="slice-21-source"> <pre class="ruby" data-language="ruby"># File activesupport/lib/active_support/core_ext/hash/slice.rb, line 25
def slice!(*keys)
  keys.map! { |key| convert_key(key) } if respond_to?(:convert_key, true)
  omit = slice(*self.keys - keys)
  hash = slice(*keys)
  hash.default      = default
  hash.default_proc = default_proc if default_proc
  replace(hash)
  omit
end</pre> </div> </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-stringify_keys"> <span class="method-name">stringify_keys</span><span class="method-args">()</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description"> <p>Returns a new hash with all keys converted to strings.</p> <pre class="ruby" data-language="ruby">hash = { name: 'Rob', age: '28' }

hash.stringify_keys
# =&gt; { "name" =&gt; "Rob", "age" =&gt; "28" }
</pre> <div class="method-source-code" id="stringify_keys-source"> <pre class="ruby" data-language="ruby"># File activesupport/lib/active_support/core_ext/hash/keys.rb, line 31
def stringify_keys
  transform_keys{ |key| key.to_s }
end</pre> </div> </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-stringify_keys-21"> <span class="method-name">stringify_keys!</span><span class="method-args">()</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description"> <p>Destructively convert all keys to strings. Same as <code>stringify_keys</code>, but modifies <code>self</code>.</p> <div class="method-source-code" id="stringify_keys-21-source"> <pre class="ruby" data-language="ruby"># File activesupport/lib/active_support/core_ext/hash/keys.rb, line 37
def stringify_keys!
  transform_keys!{ |key| key.to_s }
end</pre> </div> </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-symbolize_keys"> <span class="method-name">symbolize_keys</span><span class="method-args">()</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description"> <p>Returns a new hash with all keys converted to symbols, as long as they respond to <code>to_sym</code>.</p> <pre class="ruby" data-language="ruby">hash = { 'name' =&gt; 'Rob', 'age' =&gt; '28' }

hash.symbolize_keys
# =&gt; { name: "Rob", age: "28" }
</pre> <div class="method-source-code" id="symbolize_keys-source"> <pre class="ruby" data-language="ruby"># File activesupport/lib/active_support/core_ext/hash/keys.rb, line 48
def symbolize_keys
  transform_keys{ |key| key.to_sym rescue key }
end</pre> </div> </div> <div class="aliases"> Also aliased as: <a href="../hash/#method-i-to_options">to_options</a> </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-symbolize_keys-21"> <span class="method-name">symbolize_keys!</span><span class="method-args">()</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description"> <p>Destructively convert all keys to symbols, as long as they respond to <code>to_sym</code>. Same as <code>symbolize_keys</code>, but modifies <code>self</code>.</p> <div class="method-source-code" id="symbolize_keys-21-source"> <pre class="ruby" data-language="ruby"># File activesupport/lib/active_support/core_ext/hash/keys.rb, line 55
def symbolize_keys!
  transform_keys!{ |key| key.to_sym rescue key }
end</pre> </div> </div> <div class="aliases"> Also aliased as: <a href="../hash/#method-i-to_options-21">to_options!</a> </div> </div> <div class="method-detail method-alias"> <div class="method-heading" id="method-i-to_options"> <span class="method-name">to_options</span><span class="method-args">()</span> </div>  <div class="aliases"> Alias for: <a href="../hash/#method-i-symbolize_keys">symbolize_keys</a> </div> </div> <div class="method-detail method-alias"> <div class="method-heading" id="method-i-to_options-21"> <span class="method-name">to_options!</span><span class="method-args">()</span> </div>  <div class="aliases"> Alias for: <a href="../hash/#method-i-symbolize_keys-21">symbolize_keys!</a> </div> </div> <div class="method-detail method-alias"> <div class="method-heading" id="method-i-to_param"> <span class="method-name">to_param</span><span class="method-args">(namespace = nil)</span> </div>  <div class="aliases"> Alias for: <a href="../hash/#method-i-to_query">to_query</a> </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-to_query"> <span class="method-name">to_query</span><span class="method-args">(namespace = nil)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description"> <p>Returns a string representation of the receiver suitable for use as a URL query string:</p> <pre class="ruby" data-language="ruby">{name: 'David', nationality: 'Danish'}.to_query
# =&gt; "name=David&amp;nationality=Danish"
</pre> <p>An optional namespace can be passed to enclose key names:</p> <pre class="ruby" data-language="ruby">{name: 'David', nationality: 'Danish'}.to_query('user')
# =&gt; "user%5Bname%5D=David&amp;user%5Bnationality%5D=Danish"
</pre> <p>The string pairs “key=value” that conform the query string are sorted lexicographically in ascending order.</p> <p>This method is also aliased as <code>to_param</code>.</p> <div class="method-source-code" id="to_query-source"> <pre class="ruby" data-language="ruby"># File activesupport/lib/active_support/core_ext/object/to_query.rb, line 74
def to_query(namespace = nil)
  collect do |key, value|
    unless (value.is_a?(Hash) || value.is_a?(Array)) &amp;&amp; value.empty?
      value.to_query(namespace ? "#{namespace}[#{key}]" : key)
    end
  end.compact.sort! * '&amp;'
end</pre> </div> </div> <div class="aliases"> Also aliased as: <a href="../hash/#method-i-to_param">to_param</a> </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-to_xml"> <span class="method-name">to_xml</span><span class="method-args">(options = {}) { |builder| ... }</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description"> <p>Returns a string containing an XML representation of its receiver:</p> <pre class="ruby" data-language="ruby">{ foo: 1, bar: 2 }.to_xml
# =&gt;
# &lt;?xml version="1.0" encoding="UTF-8"?&gt;
# &lt;hash&gt;
#   &lt;foo type="integer"&gt;1&lt;/foo&gt;
#   &lt;bar type="integer"&gt;2&lt;/bar&gt;
# &lt;/hash&gt;
</pre> <p>To do so, the method loops over the pairs and builds nodes that depend on the <em>values</em>. Given a pair <code>key</code>, <code>value</code>:</p> <ul>
<li> <p>If <code>value</code> is a hash there's a recursive call with <code>key</code> as <code>:root</code>.</p> </li>
<li> <p>If <code>value</code> is an array there's a recursive call with <code>key</code> as <code>:root</code>, and <code>key</code> singularized as <code>:children</code>.</p> </li>
<li> <p>If <code>value</code> is a callable object it must expect one or two arguments. Depending on the arity, the callable is invoked with the <code>options</code> hash as first argument with <code>key</code> as <code>:root</code>, and <code>key</code> singularized as second argument. The callable can add nodes by using <code>options[:builder]</code>.</p> <pre class="ruby" data-language="ruby">'foo'.to_xml(lambda { |options, key| options[:builder].b(key) })
# =&gt; "&lt;b&gt;foo&lt;/b&gt;"
</pre> </li>
<li> <p>If <code>value</code> responds to <code>to_xml</code> the method is invoked with <code>key</code> as <code>:root</code>.</p> <pre class="ruby" data-language="ruby">class Foo
  def to_xml(options)
    options[:builder].bar 'fooing!'
  end
end

{ foo: Foo.new }.to_xml(skip_instruct: true)
# =&gt;
# &lt;hash&gt;
#   &lt;bar&gt;fooing!&lt;/bar&gt;
# &lt;/hash&gt;
</pre> </li>
<li> <p>Otherwise, a node with <code>key</code> as tag is created with a string representation of <code>value</code> as text node. If <code>value</code> is <code>nil</code> an attribute “nil” set to “true” is added. Unless the option <code>:skip_types</code> exists and is true, an attribute “type” is added as well according to the following mapping:</p> <pre class="ruby" data-language="ruby">XML_TYPE_NAMES = {
  "Symbol"     =&gt; "symbol",
  "Fixnum"     =&gt; "integer",
  "Bignum"     =&gt; "integer",
  "BigDecimal" =&gt; "decimal",
  "Float"      =&gt; "float",
  "TrueClass"  =&gt; "boolean",
  "FalseClass" =&gt; "boolean",
  "Date"       =&gt; "date",
  "DateTime"   =&gt; "dateTime",
  "Time"       =&gt; "dateTime"
}
</pre> </li>
</ul> <p>By default the root node is “hash”, but that's configurable via the <code>:root</code> option.</p> <p>The default XML builder is a fresh instance of <code>Builder::XmlMarkup</code>. You can configure your own builder with the <code>:builder</code> option. The method also accepts options like <code>:dasherize</code> and friends, they are forwarded to the builder.</p> <div class="method-source-code" id="to_xml-source"> <pre class="ruby" data-language="ruby"># File activesupport/lib/active_support/core_ext/hash/conversions.rb, line 74
def to_xml(options = {})
  require 'active_support/builder' unless defined?(Builder)

  options = options.dup
  options[:indent]  ||= 2
  options[:root]    ||= 'hash'
  options[:builder] ||= Builder::XmlMarkup.new(indent: options[:indent])

  builder = options[:builder]
  builder.instruct! unless options.delete(:skip_instruct)

  root = ActiveSupport::XmlMini.rename_key(options[:root].to_s, options)

  builder.tag!(root) do
    each { |key, value| ActiveSupport::XmlMini.to_tag(key, value, options) }
    yield builder if block_given?
  end
end</pre> </div> </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-transform_keys"> <span class="method-name">transform_keys</span><span class="method-args">() { |key| ... }</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description"> <p>Returns a new hash with all keys converted using the block operation.</p> <pre class="ruby" data-language="ruby">hash = { name: 'Rob', age: '28' }

hash.transform_keys{ |key| key.to_s.upcase }
# =&gt; {"NAME"=&gt;"Rob", "AGE"=&gt;"28"}
</pre> <div class="method-source-code" id="transform_keys-source"> <pre class="ruby" data-language="ruby"># File activesupport/lib/active_support/core_ext/hash/keys.rb, line 8
def transform_keys
  result = {}
  each_key do |key|
    result[yield(key)] = self[key]
  end
  result
end</pre> </div> </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-transform_keys-21"> <span class="method-name">transform_keys!</span><span class="method-args">() { |key| ... }</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description"> <p>Destructively convert all keys using the block operations. Same as <a href="../hash/#method-i-transform_keys">#transform_keys</a> but modifies <code>self</code>.</p> <div class="method-source-code" id="transform_keys-21-source"> <pre class="ruby" data-language="ruby"># File activesupport/lib/active_support/core_ext/hash/keys.rb, line 18
def transform_keys!
  keys.each do |key|
    self[yield(key)] = delete(key)
  end
  self
end</pre> </div> </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-with_indifferent_access"> <span class="method-name">with_indifferent_access</span><span class="method-args">()</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description"> <p>Returns an <code>ActiveSupport::HashWithIndifferentAccess</code> out of its receiver:</p> <pre class="ruby" data-language="ruby">{ a: 1 }.with_indifferent_access['a'] # =&gt; 1
</pre> <div class="method-source-code" id="with_indifferent_access-source"> <pre class="ruby" data-language="ruby"># File activesupport/lib/active_support/core_ext/hash/indifferent_access.rb, line 8
def with_indifferent_access
  ActiveSupport::HashWithIndifferentAccess.new_from_hash_copying_default(self)
end</pre> </div> </div> <div class="aliases"> Also aliased as: <a href="../hash/#method-i-nested_under_indifferent_access">nested_under_indifferent_access</a> </div> </div> </section> </section><div class="_attribution">
  <p class="_attribution-p">
    © 2004–2016 David Heinemeier Hansson<br>Licensed under the MIT License.<br>
    
  </p>
</div>

			</div>
		</div>
	</section>

	</div>
</body>
</html>
