
<!DOCTYPE HTML>

<html lang="en">

<head>
  <meta charset="utf-8">
  <title>ActiveRecord&#58;&#58;Relation - Ruby on Rails 4.1 - W3cubDocs</title>
  
  <meta name="description" content=" Compares two relations for equality. ">
  <meta name="keywords" content="class, activerecord, relation, active, record, -, ruby, on, rails, rails~4.1">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="http://docs.w3cub.com/rails~4.1/activerecord/relation/">
  <link href="/favicon.png" rel="icon">
  <link type="text/css" rel="stylesheet" href="/assets/application-50364fff564ce3b6327021805f3f00e2957b441cf27f576a7dd4ff63bbc47047.css">
  <script type="text/javascript" src="/assets/application-db64bfd54ceb42be11af7995804cf4902548419ceb79d509b0b7d62c22d98e6f.js"></script>
  <script src="/json/rails~4.1.js"></script>
  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-71174418-1']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>


</head>

<body>
	<div class="_app">
	<header class="_header">
  
  <form class="_search">
    <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
    <a class="_search-clear"></a>
    <div class="_search-tag"></div>
  </form>
  
  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/rails~4.1/" class="_nav-link" title="" style="margin-left:0;">Ruby on Rails 4.1</a></span>
  
  <nav class="_nav">
    <a href="/app/" class="_nav-link ">App</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		<div class="_list">
			
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<div class="_page _rdoc">
				
<h1 id="class-ActiveRecord::Relation" class="class"> class ActiveRecord::Relation </h1>
<dl class="meta">
<dt>Parent:</dt>
<dd class="meta-parent"><a href="../../object/">Object</a></dd>
<dt>Included modules:</dt>
<dd class="meta-includes">
<a class="include" href="../findermethods/">ActiveRecord::FinderMethods</a>, <a class="include" href="../calculations/">ActiveRecord::Calculations</a>, <a class="include" href="../spawnmethods/">ActiveRecord::SpawnMethods</a>, <a class="include" href="../querymethods/">ActiveRecord::QueryMethods</a>, <a class="include" href="../batches/">ActiveRecord::Batches</a>, <span class="include">ActiveRecord::Explain</span>, <span class="include">ActiveRecord::Delegation</span>
</dd>
</dl> <section class="description"> <h1 id="class-ActiveRecord::Relation-label-Active+Record+Relation">Active Record <a href="../relation/">Relation</a>
</h1> </section> <section id="5Buntitled-5D" class="documentation-section"> <section class="constants-list"> <header> <h3>Constants</h3> </header> <dl> <dt id="JoinOperation">JoinOperation </dt>

<dt id="MULTI_VALUE_METHODS">MULTI_VALUE_METHODS </dt>

<dt id="SINGLE_VALUE_METHODS">SINGLE_VALUE_METHODS </dt>

<dt id="VALUE_METHODS">VALUE_METHODS </dt>

</dl> </section> <section class="attribute-method-details"> <header> <h3>Attributes</h3> </header> <div class="method-detail"> <div class="method-heading attribute-method-heading" id="attribute-i-klass"> <span class="method-name">klass</span><span class="attribute-access-type">[R]</span> </div>  </div> <div class="method-detail"> <div class="method-heading attribute-method-heading" id="attribute-i-loaded"> <span class="method-name">loaded</span><span class="attribute-access-type">[R]</span> </div>  </div> <div class="method-detail"> <div class="method-heading attribute-method-heading" id="attribute-i-loaded-3F"> <span class="method-name">loaded?</span><span class="attribute-access-type">[R]</span> </div>  </div> <div class="method-detail"> <div class="method-heading attribute-method-heading" id="attribute-i-model"> <span class="method-name">model</span><span class="attribute-access-type">[R]</span> </div>  </div> <div class="method-detail"> <div class="method-heading attribute-method-heading" id="attribute-i-table"> <span class="method-name">table</span><span class="attribute-access-type">[R]</span> </div>  </div> </section> <section id="public-class-5Buntitled-5D-method-details" class="method-section"> <header> <h3>Public Class Methods</h3> </header> <div class="method-detail "> <div class="method-heading" id="method-c-new"> <span class="method-name">new</span><span class="method-args">(klass, table, values = {})</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description"> <div class="method-source-code" id="new-source"> <pre class="ruby" data-language="ruby"># File activerecord/lib/active_record/relation.rb, line 22
def initialize(klass, table, values = {})
  @klass  = klass
  @table  = table
  @values = values
  @offsets = {}
  @loaded = false
end</pre> </div> </div> </div> </section> <section id="public-instance-5Buntitled-5D-method-details" class="method-section"> <header> <h3>Public Instance Methods</h3> </header> <div class="method-detail "> <div class="method-heading" id="method-i-3D-3D"> <span class="method-name">==</span><span class="method-args">(other)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description"> <p>Compares two relations for equality.</p> <div class="method-source-code" id="3D-3D-source"> <pre class="ruby" data-language="ruby"># File activerecord/lib/active_record/relation.rb, line 576
def ==(other)
  case other
  when Associations::CollectionProxy, AssociationRelation
    self == other.to_a
  when Relation
    other.to_sql == to_sql
  when Array
    to_a == other
  end
end</pre> </div> </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-any-3F"> <span class="method-name">any?</span><span class="method-args">() { |*block_args| ... }</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description"> <p>Returns true if there are any records.</p> <div class="method-source-code" id="any-3F-source"> <pre class="ruby" data-language="ruby"># File activerecord/lib/active_record/relation.rb, line 263
def any?
  if block_given?
    to_a.any? { |*block_args| yield(*block_args) }
  else
    !empty?
  end
end</pre> </div> </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-blank-3F"> <span class="method-name">blank?</span><span class="method-args">()</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description"> <p>Returns true if relation is blank.</p> <div class="method-source-code" id="blank-3F-source"> <pre class="ruby" data-language="ruby"># File activerecord/lib/active_record/relation.rb, line 592
def blank?
  to_a.blank?
end</pre> </div> </div> </div> <div class="method-detail method-alias"> <div class="method-heading" id="method-i-build"> <span class="method-name">build</span><span class="method-args">(*args, &amp;block)</span> </div>  <div class="aliases"> Alias for: <a href="../relation/#method-i-new">new</a> </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-create"> <span class="method-name">create</span><span class="method-args">(*args, &amp;block)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description"> <p>Tries to create a new record with the same scoped attributes defined in the relation. Returns the initialized object if validation fails.</p> <p>Expects arguments in the same format as <code>Base.create</code>.</p> <h4 id="method-i-create-label-Examples">Examples</h4> <pre class="ruby" data-language="ruby">users = User.where(name: 'Oscar')
users.create # #&lt;User id: 3, name: "oscar", ...&gt;

users.create(name: 'fxn')
users.create # #&lt;User id: 4, name: "fxn", ...&gt;

users.create { |user| user.name = 'tenderlove' }
# #&lt;User id: 5, name: "tenderlove", ...&gt;

users.create(name: nil) # validation on name
# #&lt;User id: nil, name: nil, ...&gt;
</pre> <div class="method-source-code" id="create-source"> <pre class="ruby" data-language="ruby"># File activerecord/lib/active_record/relation.rb, line 137
def create(*args, &amp;block)
  scoping { @klass.create(*args, &amp;block) }
end</pre> </div> </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-create-21"> <span class="method-name">create!</span><span class="method-args">(*args, &amp;block)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description"> <p>Similar to <a href="../relation/#method-i-create">create</a>, but calls <code>create!</code> on the base class. Raises an exception if a validation error occurs.</p> <p>Expects arguments in the same format as <code>Base.create!</code>.</p> <div class="method-source-code" id="create-21-source"> <pre class="ruby" data-language="ruby"># File activerecord/lib/active_record/relation.rb, line 145
def create!(*args, &amp;block)
  scoping { @klass.create!(*args, &amp;block) }
end</pre> </div> </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-delete"> <span class="method-name">delete</span><span class="method-args">(id_or_array)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description"> <p>Deletes the row with a primary key matching the <code>id</code> argument, using a SQL <code>DELETE</code> statement, and returns the number of rows deleted. Active Record objects are not instantiated, so the object's callbacks are not executed, including any <code>:dependent</code> association options.</p> <p>You can delete multiple rows at once by passing an <a href="../../array/">Array</a> of <code>id</code>s.</p> <p>Note: Although it is often much faster than the alternative, <code>#destroy</code>, skipping callbacks might bypass business logic in your application that ensures referential integrity or performs other essential jobs.</p> <h4 id="method-i-delete-label-Examples">Examples</h4> <pre class="ruby" data-language="ruby"># Delete a single row
Todo.delete(1)

# Delete multiple rows
Todo.delete([2,3,4])
</pre> <div class="method-source-code" id="delete-source"> <pre class="ruby" data-language="ruby"># File activerecord/lib/active_record/relation.rb, line 481
def delete(id_or_array)
  where(primary_key =&gt; id_or_array).delete_all
end</pre> </div> </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-delete_all"> <span class="method-name">delete_all</span><span class="method-args">(conditions = nil)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description"> <p>Deletes the records matching <code>conditions</code> without instantiating the records first, and hence not calling the <code>destroy</code> method nor invoking callbacks. This is a single SQL DELETE statement that goes straight to the database, much more efficient than <code>destroy_all</code>. Be careful with relations though, in particular <code>:dependent</code> rules defined on associations are not honored. Returns the number of rows affected.</p> <pre class="ruby" data-language="ruby">Post.delete_all("person_id = 5 AND (category = 'Something' OR category = 'Else')")
Post.delete_all(["person_id = ? AND (category = ? OR category = ?)", 5, 'Something', 'Else'])
Post.where(person_id: 5).where(category: ['Something', 'Else']).delete_all
</pre> <p>Both calls delete the affected posts all at once with a single DELETE statement. If you need to destroy dependent associations or call your <code>before_*</code> or <code>after_destroy</code> callbacks, use the <code>destroy_all</code> method instead.</p> <p>If a limit scope is supplied, <code>delete_all</code> raises an <a href="../../activerecord/">ActiveRecord</a> error:</p> <pre class="ruby" data-language="ruby">Post.limit(100).delete_all
# =&gt; ActiveRecord::ActiveRecordError: delete_all doesn't support limit scope
</pre> <div class="method-source-code" id="delete_all-source"> <pre class="ruby" data-language="ruby"># File activerecord/lib/active_record/relation.rb, line 440
def delete_all(conditions = nil)
  raise ActiveRecordError.new("delete_all doesn't support limit scope") if self.limit_value

  if conditions
    where(conditions).delete_all
  else
    stmt = Arel::DeleteManager.new(arel.engine)
    stmt.from(table)

    if joins_values.any?
      @klass.connection.join_to_delete(stmt, arel, table[primary_key])
    else
      stmt.wheres = arel.constraints
    end

    affected = @klass.connection.delete(stmt, 'SQL', bind_values)

    reset
    affected
  end
end</pre> </div> </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-destroy"> <span class="method-name">destroy</span><span class="method-args">(id)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description"> <p>Destroy an object (or multiple objects) that has the given id. The object is instantiated first, therefore all callbacks and filters are fired off before the object is deleted. This method is less efficient than ActiveRecord#delete but allows cleanup methods and other actions to be run.</p> <p>This essentially finds the object (or multiple objects) with the given id, creates a new object from the attributes, and then calls destroy on it.</p> <h4 id="method-i-destroy-label-Parameters">Parameters</h4> <ul><li> <p><code>id</code> - Can be either an <a href="../../integer/">Integer</a> or an <a href="../../array/">Array</a> of Integers.</p> </li></ul> <h4 id="method-i-destroy-label-Examples">Examples</h4> <pre class="ruby" data-language="ruby"># Destroy a single object
Todo.destroy(1)

# Destroy multiple objects
todos = [1,2,3]
Todo.destroy(todos)
</pre> <div class="method-source-code" id="destroy-source"> <pre class="ruby" data-language="ruby"># File activerecord/lib/active_record/relation.rb, line 413
def destroy(id)
  if id.is_a?(Array)
    id.map { |one_id| destroy(one_id) }
  else
    find(id).destroy
  end
end</pre> </div> </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-destroy_all"> <span class="method-name">destroy_all</span><span class="method-args">(conditions = nil)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description"> <p>Destroys the records matching <code>conditions</code> by instantiating each record and calling its <code>destroy</code> method. Each object's callbacks are executed (including <code>:dependent</code> association options). Returns the collection of objects that were destroyed; each will be frozen, to reflect that no changes should be made (since they can't be persisted).</p> <p>Note: Instantiation, callback execution, and deletion of each record can be time consuming when you're removing many records at once. It generates at least one SQL <code>DELETE</code> query per record (or possibly more, to enforce your callbacks). If you want to delete many rows quickly, without concern for their associations or callbacks, use <code>delete_all</code> instead.</p> <h4 id="method-i-destroy_all-label-Parameters">Parameters</h4> <ul><li> <p><code>conditions</code> - A string, array, or hash that specifies which records to destroy. If omitted, all records are destroyed. See the Conditions section in the introduction to <a href="../base/">ActiveRecord::Base</a> for more information.</p> </li></ul> <h4 id="method-i-destroy_all-label-Examples">Examples</h4> <pre class="ruby" data-language="ruby">Person.destroy_all("last_login &lt; '2004-04-04'")
Person.destroy_all(status: "inactive")
Person.where(age: 0..18).destroy_all
</pre> <div class="method-source-code" id="destroy_all-source"> <pre class="ruby" data-language="ruby"># File activerecord/lib/active_record/relation.rb, line 386
def destroy_all(conditions = nil)
  if conditions
    where(conditions).destroy_all
  else
    to_a.each {|object| object.destroy }.tap { reset }
  end
end</pre> </div> </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-eager_loading-3F"> <span class="method-name">eager_loading?</span><span class="method-args">()</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description"> <p>Returns true if relation needs eager loading.</p> <div class="method-source-code" id="eager_loading-3F-source"> <pre class="ruby" data-language="ruby"># File activerecord/lib/active_record/relation.rb, line 555
def eager_loading?
  @should_eager_load ||=
    eager_load_values.any? ||
    includes_values.any? &amp;&amp; (joined_includes_values.any? || references_eager_loaded_tables?)
end</pre> </div> </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-empty-3F"> <span class="method-name">empty?</span><span class="method-args">()</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description"> <p>Returns true if there are no records.</p> <div class="method-source-code" id="empty-3F-source"> <pre class="ruby" data-language="ruby"># File activerecord/lib/active_record/relation.rb, line 251
def empty?
  return @records.empty? if loaded?

  if limit_value == 0
    true
  else
    c = count(:all)
    c.respond_to?(:zero?) ? c.zero? : c.empty?
  end
end</pre> </div> </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-explain"> <span class="method-name">explain</span><span class="method-args">()</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description"> <p>Runs EXPLAIN on the query or queries triggered by this relation and returns the result as a string. The string is formatted imitating the ones printed by the database shell.</p> <p>Note that this method actually runs the queries, since the results of some are needed by the next ones when eager loading is going on.</p> <p>Please see further details in the <a href="http://guides.rubyonrails.org/active_record_querying.html#running-explain" target="_blank">Active Record Query Interface guide</a>.</p> <div class="method-source-code" id="explain-source"> <pre class="ruby" data-language="ruby"># File activerecord/lib/active_record/relation.rb, line 231
def explain
  exec_explain(collecting_queries_for_explain { exec_queries })
end</pre> </div> </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-find_or_create_by"> <span class="method-name">find_or_create_by</span><span class="method-args">(attributes, &amp;block)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description"> <p>Finds the first record with the given attributes, or creates a record with the attributes if one is not found:</p> <pre class="ruby" data-language="ruby"># Find the first user named "Penélope" or create a new one.
User.find_or_create_by(first_name: 'Penélope')
# =&gt; #&lt;User id: 1, first_name: "Penélope", last_name: nil&gt;

# Find the first user named "Penélope" or create a new one.
# We already have one so the existing record will be returned.
User.find_or_create_by(first_name: 'Penélope')
# =&gt; #&lt;User id: 1, first_name: "Penélope", last_name: nil&gt;

# Find the first user named "Scarlett" or create a new one with
# a particular last name.
User.create_with(last_name: 'Johansson').find_or_create_by(first_name: 'Scarlett')
# =&gt; #&lt;User id: 2, first_name: "Scarlett", last_name: "Johansson"&gt;
</pre> <p>This method accepts a block, which is passed down to <code>create</code>. The last example above can be alternatively written this way:</p> <pre class="ruby" data-language="ruby"># Find the first user named "Scarlett" or create a new one with a
# different last name.
User.find_or_create_by(first_name: 'Scarlett') do |user|
  user.last_name = 'Johansson'
end
# =&gt; #&lt;User id: 2, first_name: "Scarlett", last_name: "Johansson"&gt;
</pre> <p>This method always returns a record, but if creation was attempted and failed due to validation errors it won't be persisted, you get what <code>create</code> returns in such situation.</p> <p>Please note *this method is not atomic*, it runs first a SELECT, and if there are no results an INSERT is attempted. If there are other threads or processes there is a race condition between both calls and it could be the case that you end up with two similar records.</p> <p>Whether that is a problem or not depends on the logic of the application, but in the particular case in which rows have a UNIQUE constraint an exception may be raised, just retry:</p> <pre class="ruby" data-language="ruby">begin
  CreditAccount.find_or_create_by(user_id: user.id)
rescue ActiveRecord::RecordNotUnique
  retry
end
</pre> <div class="method-source-code" id="find_or_create_by-source"> <pre class="ruby" data-language="ruby"># File activerecord/lib/active_record/relation.rb, line 207
def find_or_create_by(attributes, &amp;block)
  find_by(attributes) || create(attributes, &amp;block)
end</pre> </div> </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-find_or_create_by-21"> <span class="method-name">find_or_create_by!</span><span class="method-args">(attributes, &amp;block)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description"> <p>Like <code>find_or_create_by</code>, but calls <code>create!</code> so an exception is raised if the created record is invalid.</p> <div class="method-source-code" id="find_or_create_by-21-source"> <pre class="ruby" data-language="ruby"># File activerecord/lib/active_record/relation.rb, line 213
def find_or_create_by!(attributes, &amp;block)
  find_by(attributes) || create!(attributes, &amp;block)
end</pre> </div> </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-find_or_initialize_by"> <span class="method-name">find_or_initialize_by</span><span class="method-args">(attributes, &amp;block)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description"> <p>Like <code>find_or_create_by</code>, but calls <code>new</code> instead of <code>create</code>.</p> <div class="method-source-code" id="find_or_initialize_by-source"> <pre class="ruby" data-language="ruby"># File activerecord/lib/active_record/relation.rb, line 218
def find_or_initialize_by(attributes, &amp;block)
  find_by(attributes) || new(attributes, &amp;block)
end</pre> </div> </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-initialize_copy"> <span class="method-name">initialize_copy</span><span class="method-args">(other)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description"> <div class="method-source-code" id="initialize_copy-source"> <pre class="ruby" data-language="ruby"># File activerecord/lib/active_record/relation.rb, line 30
def initialize_copy(other)
  # This method is a hot spot, so for now, use Hash[] to dup the hash.
  #   https://bugs.ruby-lang.org/issues/7166
  @values        = Hash[@values]
  @values[:bind] = @values[:bind].dup if @values.key? :bind
  reset
end</pre> </div> </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-inspect"> <span class="method-name">inspect</span><span class="method-args">()</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description"> <div class="method-source-code" id="inspect-source"> <pre class="ruby" data-language="ruby"># File activerecord/lib/active_record/relation.rb, line 600
def inspect
  entries = to_a.take([limit_value, 11].compact.min).map!(&amp;:inspect)
  entries[10] = '...' if entries.size == 11

  "#&lt;#{self.class.name} [#{entries.join(', ')}]&gt;"
end</pre> </div> </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-joined_includes_values"> <span class="method-name">joined_includes_values</span><span class="method-args">()</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description"> <p>Joins that are also marked for preloading. In which case we should just eager load them. Note that this is a naive implementation because we could have strings and symbols which represent the same association, but that aren't matched by this. Also, we could have nested hashes which partially match, e.g. { a: :b } &amp; { a: [:b, :c] }</p> <div class="method-source-code" id="joined_includes_values-source"> <pre class="ruby" data-language="ruby"># File activerecord/lib/active_record/relation.rb, line 565
def joined_includes_values
  includes_values &amp; joins_values
end</pre> </div> </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-load"> <span class="method-name">load</span><span class="method-args">()</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description"> <p>Causes the records to be loaded from the database if they have not been loaded already. You can use this if for some reason you need to explicitly load some records before actually using them. The return value is the relation itself, not the records.</p> <pre class="ruby" data-language="ruby">Post.where(published: true).load # =&gt; #&lt;ActiveRecord::Relation&gt;
</pre> <div class="method-source-code" id="load-source"> <pre class="ruby" data-language="ruby"># File activerecord/lib/active_record/relation.rb, line 491
def load
  exec_queries unless loaded?

  self
end</pre> </div> </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-many-3F"> <span class="method-name">many?</span><span class="method-args">() { |*block_args| ... }</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description"> <p>Returns true if there is more than one record.</p> <div class="method-source-code" id="many-3F-source"> <pre class="ruby" data-language="ruby"># File activerecord/lib/active_record/relation.rb, line 272
def many?
  if block_given?
    to_a.many? { |*block_args| yield(*block_args) }
  else
    limit_value ? to_a.many? : size &gt; 1
  end
end</pre> </div> </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-new"> <span class="method-name">new</span><span class="method-args">(*args, &amp;block)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description"> <p>Initializes new record from relation while maintaining the current scope.</p> <p>Expects arguments in the same format as <code>Base.new</code>.</p> <pre class="ruby" data-language="ruby">users = User.where(name: 'DHH')
user = users.new # =&gt; #&lt;User id: nil, name: "DHH", created_at: nil, updated_at: nil&gt;
</pre> <p>You can also pass a block to new with the new record as argument:</p> <pre class="ruby" data-language="ruby">user = users.new { |user| user.name = 'Oscar' }
user.name # =&gt; Oscar
</pre> <div class="method-source-code" id="new-source"> <pre class="ruby" data-language="ruby"># File activerecord/lib/active_record/relation.rb, line 114
def new(*args, &amp;block)
  scoping { @klass.new(*args, &amp;block) }
end</pre> </div> </div> <div class="aliases"> Also aliased as: <a href="../relation/#method-i-build">build</a> </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-pretty_print"> <span class="method-name">pretty_print</span><span class="method-args">(q)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description"> <div class="method-source-code" id="pretty_print-source"> <pre class="ruby" data-language="ruby"># File activerecord/lib/active_record/relation.rb, line 587
def pretty_print(q)
  q.pp(self.to_a)
end</pre> </div> </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-reload"> <span class="method-name">reload</span><span class="method-args">()</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description"> <p>Forces reloading of relation.</p> <div class="method-source-code" id="reload-source"> <pre class="ruby" data-language="ruby"># File activerecord/lib/active_record/relation.rb, line 498
def reload
  reset
  load
end</pre> </div> </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-reset"> <span class="method-name">reset</span><span class="method-args">()</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description"> <div class="method-source-code" id="reset-source"> <pre class="ruby" data-language="ruby"># File activerecord/lib/active_record/relation.rb, line 503
def reset
  @last = @to_sql = @order_clause = @scope_for_create = @arel = @loaded = nil
  @should_eager_load = @join_dependency = nil
  @records = []
  @offsets = {}
  self
end</pre> </div> </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-scope_for_create"> <span class="method-name">scope_for_create</span><span class="method-args">()</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description"> <div class="method-source-code" id="scope_for_create-source"> <pre class="ruby" data-language="ruby"># File activerecord/lib/active_record/relation.rb, line 550
def scope_for_create
  @scope_for_create ||= where_values_hash.merge(create_with_value)
end</pre> </div> </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-scoping"> <span class="method-name">scoping</span><span class="method-args">() { || ... }</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description"> <p>Scope all queries to the current scope.</p> <pre class="ruby" data-language="ruby">Comment.where(post_id: 1).scoping do
  Comment.first
end
# =&gt; SELECT "comments".* FROM "comments" WHERE "comments"."post_id" = 1 ORDER BY "comments"."id" ASC LIMIT 1
</pre> <p>Please check unscoped if you want to remove all previous scopes (including the default_scope) during the execution of a block.</p> <div class="method-source-code" id="scoping-source"> <pre class="ruby" data-language="ruby"># File activerecord/lib/active_record/relation.rb, line 289
def scoping
  previous, klass.current_scope = klass.current_scope, self
  yield
ensure
  klass.current_scope = previous
end</pre> </div> </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-size"> <span class="method-name">size</span><span class="method-args">()</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description"> <p>Returns size of the records.</p> <div class="method-source-code" id="size-source"> <pre class="ruby" data-language="ruby"># File activerecord/lib/active_record/relation.rb, line 246
def size
  loaded? ? @records.length : count(:all)
end</pre> </div> </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-to_a"> <span class="method-name">to_a</span><span class="method-args">()</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description"> <p>Converts relation objects to <a href="../../array/">Array</a>.</p> <div class="method-source-code" id="to_a-source"> <pre class="ruby" data-language="ruby"># File activerecord/lib/active_record/relation.rb, line 236
def to_a
  load
  @records
end</pre> </div> </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-to_sql"> <span class="method-name">to_sql</span><span class="method-args">()</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description"> <p>Returns sql statement for the relation.</p> <pre class="ruby" data-language="ruby">User.where(name: 'Oscar').to_sql
# =&gt; SELECT "users".* FROM "users"  WHERE "users"."name" = 'Oscar'
</pre> <div class="method-source-code" id="to_sql-source"> <pre class="ruby" data-language="ruby"># File activerecord/lib/active_record/relation.rb, line 515
def to_sql
  @to_sql ||= begin
                relation   = self
                connection = klass.connection
                visitor    = connection.visitor

                if eager_loading?
                  find_with_associations { |rel| relation = rel }
                end

                ast   = relation.arel.ast
                binds = relation.bind_values.dup
                visitor.accept(ast) do
                  connection.quote(*binds.shift.reverse)
                end
              end
end</pre> </div> </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-uniq_value"> <span class="method-name">uniq_value</span><span class="method-args">()</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description"> <p><code>uniq</code> and <code>uniq!</code> are silently deprecated. <code>uniq_value</code> delegates to <code>distinct_value</code> to maintain backwards compatibility. Use <code>distinct_value</code> instead.</p> <div class="method-source-code" id="uniq_value-source"> <pre class="ruby" data-language="ruby"># File activerecord/lib/active_record/relation.rb, line 571
def uniq_value
  distinct_value
end</pre> </div> </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-update"> <span class="method-name">update</span><span class="method-args">(id, attributes)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description"> <p>Updates an object (or multiple objects) and saves it to the database, if validations pass. The resulting object is returned whether the object was saved successfully to the database or not.</p> <h4 id="method-i-update-label-Parameters">Parameters</h4> <ul>
<li> <p><code>id</code> - This should be the id or an array of ids to be updated.</p> </li>
<li> <p><code>attributes</code> - This should be a hash of attributes or an array of hashes.</p> </li>
</ul> <h4 id="method-i-update-label-Examples">Examples</h4> <pre class="ruby" data-language="ruby"># Updates one record
Person.update(15, user_name: 'Samuel', group: 'expert')

# Updates multiple records
people = { 1 =&gt; { "first_name" =&gt; "David" }, 2 =&gt; { "first_name" =&gt; "Jeremy" } }
Person.update(people.keys, people.values)
</pre> <div class="method-source-code" id="update-source"> <pre class="ruby" data-language="ruby"># File activerecord/lib/active_record/relation.rb, line 351
def update(id, attributes)
  if id.is_a?(Array)
    id.map.with_index { |one_id, idx| update(one_id, attributes[idx]) }
  else
    object = find(id)
    object.update(attributes)
    object
  end
end</pre> </div> </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-update_all"> <span class="method-name">update_all</span><span class="method-args">(updates)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description"> <p>Updates all records with details given if they match a set of conditions supplied, limits and order can also be supplied. This method constructs a single SQL UPDATE statement and sends it straight to the database. It does not instantiate the involved models and it does not trigger Active Record callbacks or validations.</p> <h4 id="method-i-update_all-label-Parameters">Parameters</h4> <ul><li> <p><code>updates</code> - A string, array, or hash representing the SET part of an SQL statement.</p> </li></ul> <h4 id="method-i-update_all-label-Examples">Examples</h4> <pre class="ruby" data-language="ruby"># Update all customers with the given attributes
Customer.update_all wants_email: true

# Update all books with 'Rails' in their title
Book.where('title LIKE ?', '%Rails%').update_all(author: 'David')

# Update all books that match conditions, but limit it to 5 ordered by date
Book.where('title LIKE ?', '%Rails%').order(:created_at).limit(5).update_all(author: 'David')
</pre> <div class="method-source-code" id="update_all-source"> <pre class="ruby" data-language="ruby"># File activerecord/lib/active_record/relation.rb, line 315
def update_all(updates)
  raise ArgumentError, "Empty list of attributes to change" if updates.blank?

  stmt = Arel::UpdateManager.new(arel.engine)

  stmt.set Arel.sql(@klass.send(:sanitize_sql_for_assignment, updates))
  stmt.table(table)
  stmt.key = table[primary_key]

  if joins_values.any?
    @klass.connection.join_to_update(stmt, arel)
  else
    stmt.take(arel.limit)
    stmt.order(*arel.orders)
    stmt.wheres = arel.constraints
  end

  @klass.connection.update stmt, 'SQL', bind_values
end</pre> </div> </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-values"> <span class="method-name">values</span><span class="method-args">()</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description"> <div class="method-source-code" id="values-source"> <pre class="ruby" data-language="ruby"># File activerecord/lib/active_record/relation.rb, line 596
def values
  Hash[@values]
end</pre> </div> </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-where_values_hash"> <span class="method-name">where_values_hash</span><span class="method-args">(relation_table_name = table_name)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description"> <p>Returns a hash of where conditions.</p> <pre class="ruby" data-language="ruby">User.where(name: 'Oscar').where_values_hash
# =&gt; {name: "Oscar"}
</pre> <div class="method-source-code" id="where_values_hash-source"> <pre class="ruby" data-language="ruby"># File activerecord/lib/active_record/relation.rb, line 537
def where_values_hash(relation_table_name = table_name)
  equalities = where_values.grep(Arel::Nodes::Equality).find_all { |node|
    node.left.relation.name == relation_table_name
  }

  binds = Hash[bind_values.find_all(&amp;:first).map { |column, v| [column.name, v] }]

  Hash[equalities.map { |where|
    name = where.left.name
    [name, binds.fetch(name.to_s) { where.right }]
  }]
end</pre> </div> </div> </div> </section> </section><div class="_attribution">
  <p class="_attribution-p">
    © 2004–2016 David Heinemeier Hansson<br>Licensed under the MIT License.<br>
    
  </p>
</div>

			</div>
		</div>
	</section>

	</div>
</body>
</html>
