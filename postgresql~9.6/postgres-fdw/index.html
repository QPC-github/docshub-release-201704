
<!DOCTYPE HTML>

<html lang="en">

<head>
  <meta charset="utf-8">
  <title>Postgres_fdw - PostgreSQL 9.6 - W3cubDocs</title>
  
  <meta name="description" content=" The postgres_fdw module provides the foreign-data wrapper postgres_fdw, which can be used to access data stored in external PostgreSQL servers. ">
  <meta name="keywords" content="f, postgres, fdw, -, postgresql, postgresql~9.6">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="http://docs.w3cub.com/postgresql~9.6/postgres-fdw/">
  <link href="/favicon.png" rel="icon">
  <link type="text/css" rel="stylesheet" href="/assets/application-50364fff564ce3b6327021805f3f00e2957b441cf27f576a7dd4ff63bbc47047.css">
  <script type="text/javascript" src="/assets/application-db64bfd54ceb42be11af7995804cf4902548419ceb79d509b0b7d62c22d98e6f.js"></script>
  <script src="/json/postgresql~9.6.js"></script>
  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-71174418-1']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>


</head>

<body>
	<div class="_app">
	<header class="_header">
  
  <form class="_search">
    <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
    <a class="_search-clear"></a>
    <div class="_search-tag"></div>
  </form>
  
  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/postgresql~9.6/" class="_nav-link" title="" style="margin-left:0;">PostgreSQL 9.6</a></span>
  
  <nav class="_nav">
    <a href="/app/" class="_nav-link ">App</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		<div class="_list">
			
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<div class="_page _postgres">
				
<h1 class="SECT1" id="POSTGRES-FDW">F.33. postgres_fdw</h1> <p>The <code class="FILENAME">postgres_fdw</code> module provides the foreign-data wrapper <code class="LITERAL">postgres_fdw</code>, which can be used to access data stored in external <span class="PRODUCTNAME">PostgreSQL</span> servers.</p> <p>The functionality provided by this module overlaps substantially with the functionality of the older <a href="https://www.postgresql.org/docs/9.6/static/dblink.html" target="_blank">dblink</a> module. But <code class="FILENAME">postgres_fdw</code> provides more transparent and standards-compliant syntax for accessing remote tables, and can give better performance in many cases.</p> <p>To prepare for remote access using <code class="FILENAME">postgres_fdw</code>:</p> <ol compact type="1"> <li> <p>Install the <code class="FILENAME">postgres_fdw</code> extension using <a href="../sql-createextension/">CREATE EXTENSION</a>.</p> </li> <li> <p>Create a foreign server object, using <a href="../sql-createserver/">CREATE SERVER</a>, to represent each remote database you want to connect to. Specify connection information, except <code class="LITERAL">user</code> and <code class="LITERAL">password</code>, as options of the server object.</p> </li> <li> <p>Create a user mapping, using <a href="../sql-createusermapping/">CREATE USER MAPPING</a>, for each database user you want to allow to access each foreign server. Specify the remote user name and password to use as <code class="LITERAL">user</code> and <code class="LITERAL">password</code> options of the user mapping.</p> </li> <li> <p>Create a foreign table, using <a href="../sql-createforeigntable/">CREATE FOREIGN TABLE</a> or <a href="../sql-importforeignschema/">IMPORT FOREIGN SCHEMA</a>, for each remote table you want to access. The columns of the foreign table must match the referenced remote table. You can, however, use table and/or column names different from the remote table's, if you specify the correct remote names as options of the foreign table object.</p> </li> </ol> <p>Now you need only <code class="COMMAND">SELECT</code> from a foreign table to access the data stored in its underlying remote table. You can also modify the remote table using <code class="COMMAND">INSERT</code>, <code class="COMMAND">UPDATE</code>, or <code class="COMMAND">DELETE</code>. (Of course, the remote user you have specified in your user mapping must have privileges to do these things.)</p> <p>Note that <code class="FILENAME">postgres_fdw</code> currently lacks support for <code class="COMMAND">INSERT</code> statements with an <code class="LITERAL">ON CONFLICT DO UPDATE</code> clause. However, the <code class="LITERAL">ON CONFLICT DO NOTHING</code> clause is supported, provided a unique index inference specification is omitted.</p> <p>It is generally recommended that the columns of a foreign table be declared with exactly the same data types, and collations if applicable, as the referenced columns of the remote table. Although <code class="FILENAME">postgres_fdw</code> is currently rather forgiving about performing data type conversions at need, surprising semantic anomalies may arise when types or collations do not match, due to the remote server interpreting <code class="LITERAL">WHERE</code> clauses slightly differently from the local server.</p> <p>Note that a foreign table can be declared with fewer columns, or with a different column order, than its underlying remote table has. Matching of columns to the remote table is by name, not position.</p> <div class="SECT2"> <h2 class="SECT2" id="AEN182898">F.33.1. FDW Options of postgres_fdw</h2> <div class="SECT3"> <h3 class="SECT3" id="AEN182900">F.33.1.1. Connection Options</h3> <p>A foreign server using the <code class="FILENAME">postgres_fdw</code> foreign data wrapper can have the same options that <span class="APPLICATION">libpq</span> accepts in connection strings, as described in <a href="https://www.postgresql.org/docs/9.6/static/libpq-connect.html#LIBPQ-PARAMKEYWORDS" target="_blank">Section 32.1.2</a>, except that these options are not allowed:</p> <ul compact> <li> <p><code class="LITERAL">user</code> and <code class="LITERAL">password</code> (specify these in a user mapping, instead)</p> </li> <li> <p><code class="LITERAL">client_encoding</code> (this is automatically set from the local server encoding)</p> </li> <li> <p><code class="LITERAL">fallback_application_name</code> (always set to <code class="LITERAL">postgres_fdw</code>)</p> </li> </ul> <p>Only superusers may connect to foreign servers without password authentication, so always specify the <code class="LITERAL">password</code> option for user mappings belonging to non-superusers.</p> </div> <div class="SECT3"> <h3 class="SECT3" id="AEN182920">F.33.1.2. Object Name Options</h3> <p>These options can be used to control the names used in SQL statements sent to the remote <span class="PRODUCTNAME">PostgreSQL</span> server. These options are needed when a foreign table is created with names different from the underlying remote table's names.</p> <div class="VARIABLELIST"> <dl> <dt><code class="LITERAL">schema_name</code></dt> <dd> <p>This option, which can be specified for a foreign table, gives the schema name to use for the foreign table on the remote server. If this option is omitted, the name of the foreign table's schema is used.</p> </dd> <dt><code class="LITERAL">table_name</code></dt> <dd> <p>This option, which can be specified for a foreign table, gives the table name to use for the foreign table on the remote server. If this option is omitted, the foreign table's name is used.</p> </dd> <dt><code class="LITERAL">column_name</code></dt> <dd> <p>This option, which can be specified for a column of a foreign table, gives the column name to use for the column on the remote server. If this option is omitted, the column's name is used.</p> </dd> </dl> </div> </div> <div class="SECT3"> <h3 class="SECT3" id="AEN182940">F.33.1.3. Cost Estimation Options</h3> <p><code class="FILENAME">postgres_fdw</code> retrieves remote data by executing queries against remote servers, so ideally the estimated cost of scanning a foreign table should be whatever it costs to be done on the remote server, plus some overhead for communication. The most reliable way to get such an estimate is to ask the remote server and then add something for overhead â€” but for simple queries, it may not be worth the cost of an additional remote query to get a cost estimate. So <code class="FILENAME">postgres_fdw</code> provides the following options to control how cost estimation is done:</p> <div class="VARIABLELIST"> <dl> <dt><code class="LITERAL">use_remote_estimate</code></dt> <dd> <p>This option, which can be specified for a foreign table or a foreign server, controls whether <code class="FILENAME">postgres_fdw</code> issues remote <code class="COMMAND">EXPLAIN</code> commands to obtain cost estimates. A setting for a foreign table overrides any setting for its server, but only for that table. The default is <code class="LITERAL">false</code>.</p> </dd> <dt><code class="LITERAL">fdw_startup_cost</code></dt> <dd> <p>This option, which can be specified for a foreign server, is a numeric value that is added to the estimated startup cost of any foreign-table scan on that server. This represents the additional overhead of establishing a connection, parsing and planning the query on the remote side, etc. The default value is <code class="LITERAL">100</code>.</p> </dd> <dt><code class="LITERAL">fdw_tuple_cost</code></dt> <dd> <p>This option, which can be specified for a foreign server, is a numeric value that is used as extra cost per-tuple for foreign-table scans on that server. This represents the additional overhead of data transfer between servers. You might increase or decrease this number to reflect higher or lower network delay to the remote server. The default value is <code class="LITERAL">0.01</code>.</p> </dd> </dl> </div> <p>When <code class="LITERAL">use_remote_estimate</code> is true, <code class="FILENAME">postgres_fdw</code> obtains row count and cost estimates from the remote server and then adds <code class="LITERAL">fdw_startup_cost</code> and <code class="LITERAL">fdw_tuple_cost</code> to the cost estimates. When <code class="LITERAL">use_remote_estimate</code> is false, <code class="FILENAME">postgres_fdw</code> performs local row count and cost estimation and then adds <code class="LITERAL">fdw_startup_cost</code> and <code class="LITERAL">fdw_tuple_cost</code> to the cost estimates. This local estimation is unlikely to be very accurate unless local copies of the remote table's statistics are available. Running <a href="../sql-analyze/">ANALYZE</a> on the foreign table is the way to update the local statistics; this will perform a scan of the remote table and then calculate and store statistics just as though the table were local. Keeping local statistics can be a useful way to reduce per-query planning overhead for a remote table â€” but if the remote table is frequently updated, the local statistics will soon be obsolete.</p> </div> <div class="SECT3"> <h3 class="SECT3" id="AEN182976">F.33.1.4. Remote Execution Options</h3> <p>By default, only <code class="LITERAL">WHERE</code> clauses using built-in operators and functions will be considered for execution on the remote server. Clauses involving non-built-in functions are checked locally after rows are fetched. If such functions are available on the remote server and can be relied on to produce the same results as they do locally, performance can be improved by sending such <code class="LITERAL">WHERE</code> clauses for remote execution. This behavior can be controlled using the following option:</p> <div class="VARIABLELIST"> <dl> <dt><code class="LITERAL">extensions</code></dt> <dd> <p>This option is a comma-separated list of names of <span class="PRODUCTNAME">PostgreSQL</span> extensions that are installed, in compatible versions, on both the local and remote servers. Functions and operators that are immutable and belong to a listed extension will be considered shippable to the remote server. This option can only be specified for foreign servers, not per-table.</p> <p>When using the <code class="LITERAL">extensions</code> option, <span class="emphasis EMPHASIS c2">it is the user's responsibility</span> that the listed extensions exist and behave identically on both the local and remote servers. Otherwise, remote queries may fail or behave unexpectedly.</p> </dd> <dt><code class="LITERAL">fetch_size</code></dt> <dd> <p>This option specifies the number of rows <code class="FILENAME">postgres_fdw</code> should get in each fetch operation. It can be specified for a foreign table or a foreign server. The option specified on a table overrides an option specified for the server. The default is <code class="LITERAL">100</code>.</p> </dd> </dl> </div> </div> <div class="SECT3"> <h3 class="SECT3" id="AEN182998">F.33.1.5. Updatability Options</h3> <p>By default all foreign tables using <code class="FILENAME">postgres_fdw</code> are assumed to be updatable. This may be overridden using the following option:</p> <div class="VARIABLELIST"> <dl> <dt><code class="LITERAL">updatable</code></dt> <dd> <p>This option controls whether <code class="FILENAME">postgres_fdw</code> allows foreign tables to be modified using <code class="COMMAND">INSERT</code>, <code class="COMMAND">UPDATE</code> and <code class="COMMAND">DELETE</code> commands. It can be specified for a foreign table or a foreign server. A table-level option overrides a server-level option. The default is <code class="LITERAL">true</code>.</p> <p>Of course, if the remote table is not in fact updatable, an error would occur anyway. Use of this option primarily allows the error to be thrown locally without querying the remote server. Note however that the <code class="LITERAL">information_schema</code> views will report a <code class="FILENAME">postgres_fdw</code> foreign table to be updatable (or not) according to the setting of this option, without any check of the remote server.</p> </dd> </dl> </div> </div> <div class="SECT3"> <h3 class="SECT3" id="AEN183016">F.33.1.6. Importing Options</h3> <p><code class="FILENAME">postgres_fdw</code> is able to import foreign table definitions using <a href="../sql-importforeignschema/">IMPORT FOREIGN SCHEMA</a>. This command creates foreign table definitions on the local server that match tables or views present on the remote server. If the remote tables to be imported have columns of user-defined data types, the local server must have compatible types of the same names.</p> <p>Importing behavior can be customized with the following options (given in the <code class="COMMAND">IMPORT FOREIGN SCHEMA</code> command):</p> <div class="VARIABLELIST"> <dl> <dt><code class="LITERAL">import_collate</code></dt> <dd> <p>This option controls whether column <code class="LITERAL">COLLATE</code> options are included in the definitions of foreign tables imported from a foreign server. The default is <code class="LITERAL">true</code>. You might need to turn this off if the remote server has a different set of collation names than the local server does, which is likely to be the case if it's running on a different operating system.</p> </dd> <dt><code class="LITERAL">import_default</code></dt> <dd> <p>This option controls whether column <code class="LITERAL">DEFAULT</code> expressions are included in the definitions of foreign tables imported from a foreign server. The default is <code class="LITERAL">false</code>. If you enable this option, be wary of defaults that might get computed differently on the local server than they would be on the remote server; <code class="FUNCTION">nextval()</code> is a common source of problems. The <code class="COMMAND">IMPORT</code> will fail altogether if an imported default expression uses a function or operator that does not exist locally.</p> </dd> <dt><code class="LITERAL">import_not_null</code></dt> <dd> <p>This option controls whether column <code class="LITERAL">NOT NULL</code> constraints are included in the definitions of foreign tables imported from a foreign server. The default is <code class="LITERAL">true</code>.</p> </dd> </dl> </div> <p>Note that constraints other than <code class="LITERAL">NOT NULL</code> will never be imported from the remote tables. Although <span class="PRODUCTNAME">PostgreSQL</span> does support <code class="LITERAL">CHECK</code> constraints on foreign tables, there is no provision for importing them automatically, because of the risk that a constraint expression could evaluate differently on the local and remote servers. Any such inconsistency in the behavior of a <code class="LITERAL">CHECK</code> constraint could lead to hard-to-detect errors in query optimization. So if you wish to import <code class="LITERAL">CHECK</code> constraints, you must do so manually, and you should verify the semantics of each one carefully. For more detail about the treatment of <code class="LITERAL">CHECK</code> constraints on foreign tables, see <a href="../sql-createforeigntable/">CREATE FOREIGN TABLE</a>.</p> </div> </div> <div class="SECT2"> <h2 class="SECT2" id="AEN183055">F.33.2. Connection Management</h2> <p><code class="FILENAME">postgres_fdw</code> establishes a connection to a foreign server during the first query that uses a foreign table associated with the foreign server. This connection is kept and re-used for subsequent queries in the same session. However, if multiple user identities (user mappings) are used to access the foreign server, a connection is established for each user mapping.</p> </div> <div class="SECT2"> <h2 class="SECT2" id="AEN183059">F.33.3. Transaction Management</h2> <p>During a query that references any remote tables on a foreign server, <code class="FILENAME">postgres_fdw</code> opens a transaction on the remote server if one is not already open corresponding to the current local transaction. The remote transaction is committed or aborted when the local transaction commits or aborts. Savepoints are similarly managed by creating corresponding remote savepoints.</p> <p>The remote transaction uses <code class="LITERAL">SERIALIZABLE</code> isolation level when the local transaction has <code class="LITERAL">SERIALIZABLE</code> isolation level; otherwise it uses <code class="LITERAL">REPEATABLE READ</code> isolation level. This choice ensures that if a query performs multiple table scans on the remote server, it will get snapshot-consistent results for all the scans. A consequence is that successive queries within a single transaction will see the same data from the remote server, even if concurrent updates are occurring on the remote server due to other activities. That behavior would be expected anyway if the local transaction uses <code class="LITERAL">SERIALIZABLE</code> or <code class="LITERAL">REPEATABLE READ</code> isolation level, but it might be surprising for a <code class="LITERAL">READ COMMITTED</code> local transaction. A future <span class="PRODUCTNAME">PostgreSQL</span> release might modify these rules.</p> </div> <div class="SECT2"> <h2 class="SECT2" id="AEN183071">F.33.4. Remote Query Optimization</h2> <p><code class="FILENAME">postgres_fdw</code> attempts to optimize remote queries to reduce the amount of data transferred from foreign servers. This is done by sending query <code class="LITERAL">WHERE</code> clauses to the remote server for execution, and by not retrieving table columns that are not needed for the current query. To reduce the risk of misexecution of queries, <code class="LITERAL">WHERE</code> clauses are not sent to the remote server unless they use only data types, operators, and functions that are built-in or belong to an extension that's listed in the foreign server's <code class="LITERAL">extensions</code> option. Operators and functions in such clauses must be <code class="LITERAL">IMMUTABLE</code> as well. For an <code class="COMMAND">UPDATE</code> or <code class="COMMAND">DELETE</code> query, <code class="FILENAME">postgres_fdw</code> attempts to optimize the query execution by sending the whole query to the remote server if there are no query <code class="LITERAL">WHERE</code> clauses that cannot be sent to the remote server, no local joins for the query, and no row-level local <code class="LITERAL">BEFORE</code> or <code class="LITERAL">AFTER</code> triggers on the target table. In <code class="COMMAND">UPDATE</code>, expressions to assign to target columns must use only built-in data types, <code class="LITERAL">IMMUTABLE</code> operators, or <code class="LITERAL">IMMUTABLE</code> functions, to reduce the risk of misexecution of the query.</p> <p>When <code class="FILENAME">postgres_fdw</code> encounters a join between foreign tables on the same foreign server, it sends the entire join to the foreign server, unless for some reason it believes that it will be more efficient to fetch rows from each table individually, or unless the table references involved are subject to different user mappings. While sending the <code class="LITERAL">JOIN</code> clauses, it takes the same precautions as mentioned above for the <code class="LITERAL">WHERE</code> clauses.</p> <p>The query that is actually sent to the remote server for execution can be examined using <code class="COMMAND">EXPLAIN VERBOSE</code>.</p> </div> <div class="SECT2"> <h2 class="SECT2" id="AEN183094">F.33.5. Remote Query Execution Environment</h2> <p>In the remote sessions opened by <code class="FILENAME">postgres_fdw</code>, the <a href="../runtime-config-client/#GUC-SEARCH-PATH">search_path</a> parameter is set to just <code class="LITERAL">pg_catalog</code>, so that only built-in objects are visible without schema qualification. This is not an issue for queries generated by <code class="FILENAME">postgres_fdw</code> itself, because it always supplies such qualification. However, this can pose a hazard for functions that are executed on the remote server via triggers or rules on remote tables. For example, if a remote table is actually a view, any functions used in that view will be executed with the restricted search path. It is recommended to schema-qualify all names in such functions, or else attach <code class="LITERAL">SET search_path</code> options (see <a href="../sql-createfunction/">CREATE FUNCTION</a>) to such functions to establish their expected search path environment.</p> <p><code class="FILENAME">postgres_fdw</code> likewise establishes remote session settings for the parameters <a href="../runtime-config-client/#GUC-TIMEZONE">TimeZone</a>, <a href="../runtime-config-client/#GUC-DATESTYLE">DateStyle</a>, <a href="../runtime-config-client/#GUC-INTERVALSTYLE">IntervalStyle</a>, and <a href="../runtime-config-client/#GUC-EXTRA-FLOAT-DIGITS">extra_float_digits</a>. These are less likely to be problematic than <code class="VARNAME">search_path</code>, but can be handled with function <code class="LITERAL">SET</code> options if the need arises.</p> <p>It is <span class="emphasis EMPHASIS c2">not</span> recommended that you override this behavior by changing the session-level settings of these parameters; that is likely to cause <code class="FILENAME">postgres_fdw</code> to malfunction.</p> </div> <div class="SECT2"> <h2 class="SECT2" id="AEN183114">F.33.6. Cross-Version Compatibility</h2> <p><code class="FILENAME">postgres_fdw</code> can be used with remote servers dating back to <span class="PRODUCTNAME">PostgreSQL</span> 8.3. Read-only capability is available back to 8.1. A limitation however is that <code class="FILENAME">postgres_fdw</code> generally assumes that immutable built-in functions and operators are safe to send to the remote server for execution, if they appear in a <code class="LITERAL">WHERE</code> clause for a foreign table. Thus, a built-in function that was added since the remote server's release might be sent to it for execution, resulting in <span class="QUOTE">"function does not exist"</span> or a similar error. This type of failure can be worked around by rewriting the query, for example by embedding the foreign table reference in a sub-<code class="LITERAL">SELECT</code> with <code class="LITERAL">OFFSET 0</code> as an optimization fence, and placing the problematic function or operator outside the sub-<code class="LITERAL">SELECT</code>.</p> </div> <div class="SECT2"> <h2 class="SECT2" id="AEN183125">F.33.7. Examples</h2> <p>Here is an example of creating a foreign table with <code class="LITERAL">postgres_fdw</code>. First install the extension:</p> <pre class="PROGRAMLISTING" data-language="sql">
CREATE EXTENSION postgres_fdw;
</pre> <p>Then create a foreign server using <a href="../sql-createserver/">CREATE SERVER</a>. In this example we wish to connect to a <span class="PRODUCTNAME">PostgreSQL</span> server on host <code class="LITERAL">192.83.123.89</code> listening on port <code class="LITERAL">5432</code>. The database to which the connection is made is named <code class="LITERAL">foreign_db</code> on the remote server:</p> <pre class="PROGRAMLISTING" data-language="sql">
CREATE SERVER foreign_server
        FOREIGN DATA WRAPPER postgres_fdw
        OPTIONS (host '192.83.123.89', port '5432', dbname 'foreign_db');
</pre> <p>A user mapping, defined with <a href="../sql-createusermapping/">CREATE USER MAPPING</a>, is needed as well to identify the role that will be used on the remote server:</p> <pre class="PROGRAMLISTING" data-language="sql">
CREATE USER MAPPING FOR local_user
        SERVER foreign_server
        OPTIONS (user 'foreign_user', password 'password');
</pre> <p>Now it is possible to create a foreign table with <a href="../sql-createforeigntable/">CREATE FOREIGN TABLE</a>. In this example we wish to access the table named <code class="STRUCTNAME">some_schema.some_table</code> on the remote server. The local name for it will be <code class="STRUCTNAME">foreign_table</code>:</p> <pre class="PROGRAMLISTING" data-language="sql">
CREATE FOREIGN TABLE foreign_table (
        id integer NOT NULL,
        data text
)
        SERVER foreign_server
        OPTIONS (schema_name 'some_schema', table_name 'some_table');
</pre> <p>It's essential that the data types and other properties of the columns declared in <code class="COMMAND">CREATE FOREIGN TABLE</code> match the actual remote table. Column names must match as well, unless you attach <code class="LITERAL">column_name</code> options to the individual columns to show how they are named in the remote table. In many cases, use of <a href="../sql-importforeignschema/">IMPORT FOREIGN SCHEMA</a> is preferable to constructing foreign table definitions manually.</p> </div> <div class="SECT2"> <h2 class="SECT2" id="AEN183148">F.33.8. Author</h2> <p>Shigeru Hanada <code class="EMAIL">&lt;<a href="../mailto:shigeru.hanada@gmail.com/">shigeru.hanada@gmail.com</a>&gt;</code></p> </div>  <div class="NAVFOOTER">  <table summary="Footer navigation table"> <tr> <td width="33%" align="left"><a href="../pgvisibility/" accesskey="P">Prev</a></td> <td width="34%" align="center"></td> <td width="33%" align="right"><a href="../seg/" accesskey="N">Next</a></td> </tr> <tr> <td width="33%" align="left">pg_visibility</td> <td width="34%" align="center"><a href="https://www.postgresql.org/docs/9.6/static/contrib.html" accesskey="U" target="_blank">Up</a></td> <td width="33%" align="right">seg</td> </tr> </table> </div>
<div class="_attribution">
  <p class="_attribution-p">
    Â© 1996â€“2017 The PostgreSQL Global Development Group<br>Licensed under the PostgreSQL License.<br>
    <a href="https://www.postgresql.org/docs/9.6/static/postgres-fdw.html" class="_attribution-link" target="_blank">https://www.postgresql.org/docs/9.6/static/postgres-fdw.html</a>
  </p>
</div>

			</div>
		</div>
	</section>

	</div>
</body>
</html>
