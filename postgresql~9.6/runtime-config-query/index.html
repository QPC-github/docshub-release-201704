
<!DOCTYPE HTML>

<html lang="en">

<head>
  <meta charset="utf-8">
  <title>Server Configuration&#58; Query Planning - PostgreSQL 9.6 - W3cubDocs</title>
  
  <meta name="description" content="These configuration parameters provide a crude method of influencing the query plans chosen by the query optimizer. If the default plan chosen by &hellip;">
  <meta name="keywords" content="query, planning, server, configuration, -, postgresql, postgresql~9.6">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="http://docs.w3cub.com/postgresql~9.6/runtime-config-query/">
  <link href="/favicon.png" rel="icon">
  <link type="text/css" rel="stylesheet" href="/assets/application-50364fff564ce3b6327021805f3f00e2957b441cf27f576a7dd4ff63bbc47047.css">
  <script type="text/javascript" src="/assets/application-db64bfd54ceb42be11af7995804cf4902548419ceb79d509b0b7d62c22d98e6f.js"></script>
  <script src="/json/postgresql~9.6.js"></script>
  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-71174418-1']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>


</head>

<body>
	<div class="_app">
	<header class="_header">
  
  <form class="_search">
    <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
    <a class="_search-clear"></a>
    <div class="_search-tag"></div>
  </form>
  
  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/postgresql~9.6/" class="_nav-link" title="" style="margin-left:0;">PostgreSQL 9.6</a></span>
  
  <nav class="_nav">
    <a href="/app/" class="_nav-link ">App</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		<div class="_list">
			
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<div class="_page _postgres">
				
<h1 class="SECT1" id="RUNTIME-CONFIG-QUERY">19.7. Query Planning</h1> <div class="SECT2"> <h2 class="SECT2" id="RUNTIME-CONFIG-QUERY-ENABLE">19.7.1. Planner Method Configuration</h2> <p>These configuration parameters provide a crude method of influencing the query plans chosen by the query optimizer. If the default plan chosen by the optimizer for a particular query is not optimal, a <span class="emphasis EMPHASIS c2">temporary</span> solution is to use one of these configuration parameters to force the optimizer to choose a different plan. Better ways to improve the quality of the plans chosen by the optimizer include adjusting the planer cost constants (see <a href="../runtime-config-query/#RUNTIME-CONFIG-QUERY-CONSTANTS">Section 19.7.2</a>), running <a href="../sql-analyze/">ANALYZE</a> manually, increasing the value of the <a href="../runtime-config-query/#GUC-DEFAULT-STATISTICS-TARGET">default_statistics_target</a> configuration parameter, and increasing the amount of statistics collected for specific columns using <code class="COMMAND">ALTER TABLE SET STATISTICS</code>.</p> <div class="VARIABLELIST"> <dl> <dt id="GUC-ENABLE-BITMAPSCAN">
<code class="VARNAME">enable_bitmapscan</code> (<code class="TYPE">boolean</code>)</dt> <dd> <p>Enables or disables the query planner's use of bitmap-scan plan types. The default is <code class="LITERAL">on</code>.</p> </dd> <dt id="GUC-ENABLE-HASHAGG">
<code class="VARNAME">enable_hashagg</code> (<code class="TYPE">boolean</code>)</dt> <dd> <p>Enables or disables the query planner's use of hashed aggregation plan types. The default is <code class="LITERAL">on</code>.</p> </dd> <dt id="GUC-ENABLE-HASHJOIN">
<code class="VARNAME">enable_hashjoin</code> (<code class="TYPE">boolean</code>)</dt> <dd> <p>Enables or disables the query planner's use of hash-join plan types. The default is <code class="LITERAL">on</code>.</p> </dd> <dt id="GUC-ENABLE-INDEXSCAN">
<code class="VARNAME">enable_indexscan</code> (<code class="TYPE">boolean</code>)</dt> <dd> <p>Enables or disables the query planner's use of index-scan plan types. The default is <code class="LITERAL">on</code>.</p> </dd> <dt id="GUC-ENABLE-INDEXONLYSCAN">
<code class="VARNAME">enable_indexonlyscan</code> (<code class="TYPE">boolean</code>)</dt> <dd> <p>Enables or disables the query planner's use of index-only-scan plan types (see <a href="../indexes-index-only-scans/">Section 11.11</a>). The default is <code class="LITERAL">on</code>.</p> </dd> <dt id="GUC-ENABLE-MATERIAL">
<code class="VARNAME">enable_material</code> (<code class="TYPE">boolean</code>)</dt> <dd> <p>Enables or disables the query planner's use of materialization. It is impossible to suppress materialization entirely, but turning this variable off prevents the planner from inserting materialize nodes except in cases where it is required for correctness. The default is <code class="LITERAL">on</code>.</p> </dd> <dt id="GUC-ENABLE-MERGEJOIN">
<code class="VARNAME">enable_mergejoin</code> (<code class="TYPE">boolean</code>)</dt> <dd> <p>Enables or disables the query planner's use of merge-join plan types. The default is <code class="LITERAL">on</code>.</p> </dd> <dt id="GUC-ENABLE-NESTLOOP">
<code class="VARNAME">enable_nestloop</code> (<code class="TYPE">boolean</code>)</dt> <dd> <p>Enables or disables the query planner's use of nested-loop join plans. It is impossible to suppress nested-loop joins entirely, but turning this variable off discourages the planner from using one if there are other methods available. The default is <code class="LITERAL">on</code>.</p> </dd> <dt id="GUC-ENABLE-SEQSCAN">
<code class="VARNAME">enable_seqscan</code> (<code class="TYPE">boolean</code>)</dt> <dd> <p>Enables or disables the query planner's use of sequential scan plan types. It is impossible to suppress sequential scans entirely, but turning this variable off discourages the planner from using one if there are other methods available. The default is <code class="LITERAL">on</code>.</p> </dd> <dt id="GUC-ENABLE-SORT">
<code class="VARNAME">enable_sort</code> (<code class="TYPE">boolean</code>)</dt> <dd> <p>Enables or disables the query planner's use of explicit sort steps. It is impossible to suppress explicit sorts entirely, but turning this variable off discourages the planner from using one if there are other methods available. The default is <code class="LITERAL">on</code>.</p> </dd> <dt id="GUC-ENABLE-TIDSCAN">
<code class="VARNAME">enable_tidscan</code> (<code class="TYPE">boolean</code>)</dt> <dd> <p>Enables or disables the query planner's use of <acronym class="ACRONYM">TID</acronym> scan plan types. The default is <code class="LITERAL">on</code>.</p> </dd> </dl> </div> </div> <div class="SECT2"> <h2 class="SECT2" id="RUNTIME-CONFIG-QUERY-CONSTANTS">19.7.2. Planner Cost Constants</h2> <p>The <i class="FIRSTTERM">cost</i> variables described in this section are measured on an arbitrary scale. Only their relative values matter, hence scaling them all up or down by the same factor will result in no change in the planner's choices. By default, these cost variables are based on the cost of sequential page fetches; that is, <code class="VARNAME">seq_page_cost</code> is conventionally set to <code class="LITERAL">1.0</code> and the other cost variables are set with reference to that. But you can use a different scale if you prefer, such as actual execution times in milliseconds on a particular machine.</p>  <blockquote class="NOTE"> <p><b>Note:</b> Unfortunately, there is no well-defined method for determining ideal values for the cost variables. They are best treated as averages over the entire mix of queries that a particular installation will receive. This means that changing them on the basis of just a few experiments is very risky.</p> </blockquote>  <div class="VARIABLELIST"> <dl> <dt id="GUC-SEQ-PAGE-COST">
<code class="VARNAME">seq_page_cost</code> (<code class="TYPE">floating point</code>)</dt> <dd> <p>Sets the planner's estimate of the cost of a disk page fetch that is part of a series of sequential fetches. The default is 1.0. This value can be overridden for tables and indexes in a particular tablespace by setting the tablespace parameter of the same name (see <a href="../sql-altertablespace/">ALTER TABLESPACE</a>).</p> </dd> <dt id="GUC-RANDOM-PAGE-COST">
<code class="VARNAME">random_page_cost</code> (<code class="TYPE">floating point</code>)</dt> <dd> <p>Sets the planner's estimate of the cost of a non-sequentially-fetched disk page. The default is 4.0. This value can be overridden for tables and indexes in a particular tablespace by setting the tablespace parameter of the same name (see <a href="../sql-altertablespace/">ALTER TABLESPACE</a>).</p> <p>Reducing this value relative to <code class="VARNAME">seq_page_cost</code> will cause the system to prefer index scans; raising it will make index scans look relatively more expensive. You can raise or lower both values together to change the importance of disk I/O costs relative to CPU costs, which are described by the following parameters.</p> <p>Random access to mechanical disk storage is normally much more expensive than four times sequential access. However, a lower default is used (4.0) because the majority of random accesses to disk, such as indexed reads, are assumed to be in cache. The default value can be thought of as modeling random access as 40 times slower than sequential, while expecting 90% of random reads to be cached.</p> <p>If you believe a 90% cache rate is an incorrect assumption for your workload, you can increase random_page_cost to better reflect the true cost of random storage reads. Correspondingly, if your data is likely to be completely in cache, such as when the database is smaller than the total server memory, decreasing random_page_cost can be appropriate. Storage that has a low random read cost relative to sequential, e.g. solid-state drives, might also be better modeled with a lower value for random_page_cost.</p> <div class="TIP"> <blockquote class="TIP"> <p><b>Tip:</b> Although the system will let you set <code class="VARNAME">random_page_cost</code> to less than <code class="VARNAME">seq_page_cost</code>, it is not physically sensible to do so. However, setting them equal makes sense if the database is entirely cached in RAM, since in that case there is no penalty for touching pages out of sequence. Also, in a heavily-cached database you should lower both values relative to the CPU parameters, since the cost of fetching a page already in RAM is much smaller than it would normally be.</p> </blockquote> </div> </dd> <dt id="GUC-CPU-TUPLE-COST">
<code class="VARNAME">cpu_tuple_cost</code> (<code class="TYPE">floating point</code>)</dt> <dd> <p>Sets the planner's estimate of the cost of processing each row during a query. The default is 0.01.</p> </dd> <dt id="GUC-CPU-INDEX-TUPLE-COST">
<code class="VARNAME">cpu_index_tuple_cost</code> (<code class="TYPE">floating point</code>)</dt> <dd> <p>Sets the planner's estimate of the cost of processing each index entry during an index scan. The default is 0.005.</p> </dd> <dt id="GUC-CPU-OPERATOR-COST">
<code class="VARNAME">cpu_operator_cost</code> (<code class="TYPE">floating point</code>)</dt> <dd> <p>Sets the planner's estimate of the cost of processing each operator or function executed during a query. The default is 0.0025.</p> </dd> <dt id="GUC-PARALLEL-SETUP-COST">
<code class="VARNAME">parallel_setup_cost</code> (<code class="TYPE">floating point</code>)</dt> <dd> <p>Sets the planner's estimate of the cost of launching parallel worker processes. The default is 1000.</p> </dd> <dt id="GUC-PARALLEL-TUPLE-COST">
<code class="VARNAME">parallel_tuple_cost</code> (<code class="TYPE">floating point</code>)</dt> <dd> <p>Sets the planner's estimate of the cost of transferring one tuple from a parallel worker process to another process. The default is 0.1.</p> </dd> <dt id="GUC-MIN-PARALLEL-RELATION-SIZE">
<code class="VARNAME">min_parallel_relation_size</code> (<code class="TYPE">integer</code>)</dt> <dd> <p>Sets the minimum size of relations to be considered for parallel scan. The default is 8 megabytes (<code class="LITERAL">8MB</code>).</p> </dd> <dt id="GUC-EFFECTIVE-CACHE-SIZE">
<code class="VARNAME">effective_cache_size</code> (<code class="TYPE">integer</code>)</dt> <dd> <p>Sets the planner's assumption about the effective size of the disk cache that is available to a single query. This is factored into estimates of the cost of using an index; a higher value makes it more likely index scans will be used, a lower value makes it more likely sequential scans will be used. When setting this parameter you should consider both <span class="PRODUCTNAME">PostgreSQL</span>'s shared buffers and the portion of the kernel's disk cache that will be used for <span class="PRODUCTNAME">PostgreSQL</span> data files. Also, take into account the expected number of concurrent queries on different tables, since they will have to share the available space. This parameter has no effect on the size of shared memory allocated by <span class="PRODUCTNAME">PostgreSQL</span>, nor does it reserve kernel disk cache; it is used only for estimation purposes. The system also does not assume data remains in the disk cache between queries. The default is 4 gigabytes (<code class="LITERAL">4GB</code>).</p> </dd> </dl> </div> </div> <div class="SECT2"> <h2 class="SECT2" id="RUNTIME-CONFIG-QUERY-GEQO">19.7.3. Genetic Query Optimizer</h2> <p>The genetic query optimizer (GEQO) is an algorithm that does query planning using heuristic searching. This reduces planning time for complex queries (those joining many relations), at the cost of producing plans that are sometimes inferior to those found by the normal exhaustive-search algorithm. For more information see <a href="https://www.postgresql.org/docs/9.6/static/geqo.html" target="_blank">Chapter 58</a>.</p> <div class="VARIABLELIST"> <dl> <dt id="GUC-GEQO">
<code class="VARNAME">geqo</code> (<code class="TYPE">boolean</code>)</dt> <dd> <p>Enables or disables genetic query optimization. This is on by default. It is usually best not to turn it off in production; the <code class="VARNAME">geqo_threshold</code> variable provides more granular control of GEQO.</p> </dd> <dt id="GUC-GEQO-THRESHOLD">
<code class="VARNAME">geqo_threshold</code> (<code class="TYPE">integer</code>)</dt> <dd> <p>Use genetic query optimization to plan queries with at least this many <code class="LITERAL">FROM</code> items involved. (Note that a <code class="LITERAL">FULL OUTER JOIN</code> construct counts as only one <code class="LITERAL">FROM</code> item.) The default is 12. For simpler queries it is usually best to use the regular, exhaustive-search planner, but for queries with many tables the exhaustive search takes too long, often longer than the penalty of executing a suboptimal plan. Thus, a threshold on the size of the query is a convenient way to manage use of GEQO.</p> </dd> <dt id="GUC-GEQO-EFFORT">
<code class="VARNAME">geqo_effort</code> (<code class="TYPE">integer</code>)</dt> <dd> <p>Controls the trade-off between planning time and query plan quality in GEQO. This variable must be an integer in the range from 1 to 10. The default value is five. Larger values increase the time spent doing query planning, but also increase the likelihood that an efficient query plan will be chosen.</p> <p><code class="VARNAME">geqo_effort</code> doesn't actually do anything directly; it is only used to compute the default values for the other variables that influence GEQO behavior (described below). If you prefer, you can set the other parameters by hand instead.</p> </dd> <dt id="GUC-GEQO-POOL-SIZE">
<code class="VARNAME">geqo_pool_size</code> (<code class="TYPE">integer</code>)</dt> <dd> <p>Controls the pool size used by GEQO, that is the number of individuals in the genetic population. It must be at least two, and useful values are typically 100 to 1000. If it is set to zero (the default setting) then a suitable value is chosen based on <code class="VARNAME">geqo_effort</code> and the number of tables in the query.</p> </dd> <dt id="GUC-GEQO-GENERATIONS">
<code class="VARNAME">geqo_generations</code> (<code class="TYPE">integer</code>)</dt> <dd> <p>Controls the number of generations used by GEQO, that is the number of iterations of the algorithm. It must be at least one, and useful values are in the same range as the pool size. If it is set to zero (the default setting) then a suitable value is chosen based on <code class="VARNAME">geqo_pool_size</code>.</p> </dd> <dt id="GUC-GEQO-SELECTION-BIAS">
<code class="VARNAME">geqo_selection_bias</code> (<code class="TYPE">floating point</code>)</dt> <dd> <p>Controls the selection bias used by GEQO. The selection bias is the selective pressure within the population. Values can be from 1.50 to 2.00; the latter is the default.</p> </dd> <dt id="GUC-GEQO-SEED">
<code class="VARNAME">geqo_seed</code> (<code class="TYPE">floating point</code>)</dt> <dd> <p>Controls the initial value of the random number generator used by GEQO to select random paths through the join order search space. The value can range from zero (the default) to one. Varying the value changes the set of join paths explored, and may result in a better or worse best path being found.</p> </dd> </dl> </div> </div> <div class="SECT2"> <h2 class="SECT2" id="RUNTIME-CONFIG-QUERY-OTHER">19.7.4. Other Planner Options</h2> <div class="VARIABLELIST"> <dl> <dt id="GUC-DEFAULT-STATISTICS-TARGET">
<code class="VARNAME">default_statistics_target</code> (<code class="TYPE">integer</code>)</dt> <dd> <p>Sets the default statistics target for table columns without a column-specific target set via <code class="COMMAND">ALTER TABLE SET STATISTICS</code>. Larger values increase the time needed to do <code class="COMMAND">ANALYZE</code>, but might improve the quality of the planner's estimates. The default is 100. For more information on the use of statistics by the <span class="PRODUCTNAME">PostgreSQL</span> query planner, refer to <a href="../planner-stats/">Section 14.2</a>.</p> </dd> <dt id="GUC-CONSTRAINT-EXCLUSION">
<code class="VARNAME">constraint_exclusion</code> (<code class="TYPE">enum</code>)</dt> <dd> <p>Controls the query planner's use of table constraints to optimize queries. The allowed values of <code class="VARNAME">constraint_exclusion</code> are <code class="LITERAL">on</code> (examine constraints for all tables), <code class="LITERAL">off</code> (never examine constraints), and <code class="LITERAL">partition</code> (examine constraints only for inheritance child tables and <code class="LITERAL">UNION ALL</code> subqueries). <code class="LITERAL">partition</code> is the default setting. It is often used with inheritance and partitioned tables to improve performance.</p> <p>When this parameter allows it for a particular table, the planner compares query conditions with the table's <code class="LITERAL">CHECK</code> constraints, and omits scanning tables for which the conditions contradict the constraints. For example:</p> <pre class="PROGRAMLISTING" data-language="sql">
CREATE TABLE parent(key integer, ...);
CREATE TABLE child1000(check (key between 1000 and 1999)) INHERITS(parent);
CREATE TABLE child2000(check (key between 2000 and 2999)) INHERITS(parent);
...
SELECT * FROM parent WHERE key = 2400;
</pre> <p>With constraint exclusion enabled, this <code class="COMMAND">SELECT</code> will not scan <code class="STRUCTNAME">child1000</code> at all, improving performance.</p> <p>Currently, constraint exclusion is enabled by default only for cases that are often used to implement table partitioning. Turning it on for all tables imposes extra planning overhead that is quite noticeable on simple queries, and most often will yield no benefit for simple queries. If you have no partitioned tables you might prefer to turn it off entirely.</p> <p>Refer to <a href="../ddl-partitioning/#DDL-PARTITIONING-CONSTRAINT-EXCLUSION"> Section 5.10.4</a> for more information on using constraint exclusion and partitioning.</p> </dd> <dt id="GUC-CURSOR-TUPLE-FRACTION">
<code class="VARNAME">cursor_tuple_fraction</code> (<code class="TYPE">floating point</code>)</dt> <dd> <p>Sets the planner's estimate of the fraction of a cursor's rows that will be retrieved. The default is 0.1. Smaller values of this setting bias the planner towards using <span class="QUOTE">"fast start"</span> plans for cursors, which will retrieve the first few rows quickly while perhaps taking a long time to fetch all rows. Larger values put more emphasis on the total estimated time. At the maximum setting of 1.0, cursors are planned exactly like regular queries, considering only the total estimated time and not how soon the first rows might be delivered.</p> </dd> <dt id="GUC-FROM-COLLAPSE-LIMIT">
<code class="VARNAME">from_collapse_limit</code> (<code class="TYPE">integer</code>)</dt> <dd> <p>The planner will merge sub-queries into upper queries if the resulting <code class="LITERAL">FROM</code> list would have no more than this many items. Smaller values reduce planning time but might yield inferior query plans. The default is eight. For more information see <a href="../explicit-joins/">Section 14.3</a>.</p> <p>Setting this value to <a href="../runtime-config-query/#GUC-GEQO-THRESHOLD">geqo_threshold</a> or more may trigger use of the GEQO planner, resulting in non-optimal plans. See <a href="../runtime-config-query/#RUNTIME-CONFIG-QUERY-GEQO">Section 19.7.3</a>.</p> </dd> <dt id="GUC-JOIN-COLLAPSE-LIMIT">
<code class="VARNAME">join_collapse_limit</code> (<code class="TYPE">integer</code>)</dt> <dd> <p>The planner will rewrite explicit <code class="LITERAL">JOIN</code> constructs (except <code class="LITERAL">FULL JOIN</code>s) into lists of <code class="LITERAL">FROM</code> items whenever a list of no more than this many items would result. Smaller values reduce planning time but might yield inferior query plans.</p> <p>By default, this variable is set the same as <code class="VARNAME">from_collapse_limit</code>, which is appropriate for most uses. Setting it to 1 prevents any reordering of explicit <code class="LITERAL">JOIN</code>s. Thus, the explicit join order specified in the query will be the actual order in which the relations are joined. Because the query planner does not always choose the optimal join order, advanced users can elect to temporarily set this variable to 1, and then specify the join order they desire explicitly. For more information see <a href="../explicit-joins/">Section 14.3</a>.</p> <p>Setting this value to <a href="../runtime-config-query/#GUC-GEQO-THRESHOLD">geqo_threshold</a> or more may trigger use of the GEQO planner, resulting in non-optimal plans. See <a href="../runtime-config-query/#RUNTIME-CONFIG-QUERY-GEQO">Section 19.7.3</a>.</p> </dd> <dt id="GUC-FORCE-PARALLEL-MODE">
<code class="VARNAME">force_parallel_mode</code> (<code class="TYPE">enum</code>)</dt> <dd> <p>Allows the use of parallel queries for testing purposes even in cases where no performance benefit is expected. The allowed values of <code class="VARNAME">force_parallel_mode</code> are <code class="LITERAL">off</code> (use parallel mode only when it is expected to improve performance), <code class="LITERAL">on</code> (force parallel query for all queries for which it is thought to be safe), and <code class="LITERAL">regress</code> (like <code class="LITERAL">on</code>, but with additional behavior changes as explained below).</p> <p>More specifically, setting this value to <code class="LITERAL">on</code> will add a <code class="LITERAL">Gather</code> node to the top of any query plan for which this appears to be safe, so that the query runs inside of a parallel worker. Even when a parallel worker is not available or cannot be used, operations such as starting a subtransaction that would be prohibited in a parallel query context will be prohibited unless the planner believes that this will cause the query to fail. If failures or unexpected results occur when this option is set, some functions used by the query may need to be marked <code class="LITERAL">PARALLEL UNSAFE</code> (or, possibly, <code class="LITERAL">PARALLEL RESTRICTED</code>).</p> <p>Setting this value to <code class="LITERAL">regress</code> has all of the same effects as setting it to <code class="LITERAL">on</code> plus some additional effects that are intended to facilitate automated regression testing. Normally, messages from a parallel worker include a context line indicating that, but a setting of <code class="LITERAL">regress</code> suppresses this line so that the output is the same as in non-parallel execution. Also, the <code class="LITERAL">Gather</code> nodes added to plans by this setting are hidden in <code class="LITERAL">EXPLAIN</code> output so that the output matches what would be obtained if this setting were turned <code class="LITERAL">off</code>.</p> </dd> </dl> </div> </div>  <div class="NAVFOOTER">  <table summary="Footer navigation table"> <tr> <td width="33%" align="left"><a href="../runtime-config-replication/" accesskey="P">Prev</a></td> <td width="34%" align="center"></td> <td width="33%" align="right"><a href="../runtime-config-logging/" accesskey="N">Next</a></td> </tr> <tr> <td width="33%" align="left">Replication</td> <td width="34%" align="center"><a href="https://www.postgresql.org/docs/9.6/static/runtime-config.html" accesskey="U" target="_blank">Up</a></td> <td width="33%" align="right">Error Reporting and Logging</td> </tr> </table> </div>
<div class="_attribution">
  <p class="_attribution-p">
    © 1996–2017 The PostgreSQL Global Development Group<br>Licensed under the PostgreSQL License.<br>
    <a href="https://www.postgresql.org/docs/9.6/static/runtime-config-query.html" class="_attribution-link" target="_blank">https://www.postgresql.org/docs/9.6/static/runtime-config-query.html</a>
  </p>
</div>

			</div>
		</div>
	</section>

	</div>
</body>
</html>
