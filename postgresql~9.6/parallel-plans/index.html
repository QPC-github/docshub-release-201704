
<!DOCTYPE HTML>

<html lang="en">

<head>
  <meta charset="utf-8">
  <title>Parallel Plans - PostgreSQL 9.6 - W3cubDocs</title>
  
  <meta name="description" content="Because each worker executes the parallel portion of the plan to completion, it is not possible to simply take an ordinary query plan and run it &hellip;">
  <meta name="keywords" content="parallel, plans, -, postgresql, postgresql~9.6">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="http://docs.w3cub.com/postgresql~9.6/parallel-plans/">
  <link href="/favicon.png" rel="icon">
  <link type="text/css" rel="stylesheet" href="/assets/application-50364fff564ce3b6327021805f3f00e2957b441cf27f576a7dd4ff63bbc47047.css">
  <script type="text/javascript" src="/assets/application-db64bfd54ceb42be11af7995804cf4902548419ceb79d509b0b7d62c22d98e6f.js"></script>
  <script src="/json/postgresql~9.6.js"></script>
  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-71174418-1']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>


</head>

<body>
	<div class="_app">
	<header class="_header">
  
  <form class="_search">
    <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
    <a class="_search-clear"></a>
    <div class="_search-tag"></div>
  </form>
  
  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/postgresql~9.6/" class="_nav-link" title="" style="margin-left:0;">PostgreSQL 9.6</a></span>
  
  <nav class="_nav">
    <a href="/app/" class="_nav-link ">App</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		<div class="_list">
			
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<div class="_page _postgres">
				
<h1 class="SECT1" id="PARALLEL-PLANS">15.3. Parallel Plans</h1> <p>Because each worker executes the parallel portion of the plan to completion, it is not possible to simply take an ordinary query plan and run it using multiple workers. Each worker would produce a full copy of the output result set, so the query would not run any faster than normal but would produce incorrect results. Instead, the parallel portion of the plan must be what is known internally to the query optimizer as a <i class="FIRSTTERM">partial plan</i>; that is, it must be constructed so that each process which executes the plan will generate only a subset of the output rows in such a way that each required output row is guaranteed to be generated by exactly one of the cooperating processes.</p> <div class="SECT2"> <h2 class="SECT2" id="PARALLEL-SCANS">15.3.1. Parallel Scans</h2> <p>Currently, the only type of scan which has been modified to work with parallel query is a sequential scan. Therefore, the driving table in a parallel plan will always be scanned using a <code class="LITERAL">Parallel Seq Scan</code>. The relation's blocks will be divided among the cooperating processes. Blocks are handed out one at a time, so that access to the relation remains sequential. Each process will visit every tuple on the page assigned to it before requesting a new page.</p> </div> <div class="SECT2"> <h2 class="SECT2" id="PARALLEL-JOINS">15.3.2. Parallel Joins</h2> <p>The driving table may be joined to one or more other tables using nested loops or hash joins. The outer side of the join may be any kind of non-parallel plan that is otherwise supported by the planner provided that it is safe to run within a parallel worker. For example, it may be an index scan which looks up a value based on a column taken from the inner table. Each worker will execute the outer side of the plan in full, which is why merge joins are not supported here. The outer side of a merge join will often involve sorting the entire inner table; even if it involves an index, it is unlikely to be productive to have multiple processes each conduct a full index scan of the inner table.</p> </div> <div class="SECT2"> <h2 class="SECT2" id="PARALLEL-AGGREGATION">15.3.3. Parallel Aggregation</h2> <p>It is not possible to perform the aggregation portion of a query entirely in parallel. For example, if a query involves selecting <code class="LITERAL">COUNT(*)</code>, each worker could compute a total, but those totals would need to combined in order to produce a final answer. If the query involved a <code class="LITERAL">GROUP BY</code> clause, a separate total would need to be computed for each group. Even though aggregation can't be done entirely in parallel, queries involving aggregation are often excellent candidates for parallel query, because they typically read many rows but return only a few rows to the client. Queries that return many rows to the client are often limited by the speed at which the client can read the data, in which case parallel query cannot help very much.</p> <p><span class="PRODUCTNAME">PostgreSQL</span> supports parallel aggregation by aggregating twice. First, each process participating in the parallel portion of the query performs an aggregation step, producing a partial result for each group of which that process is aware. This is reflected in the plan as a <code class="LITERAL">PartialAggregate</code> node. Second, the partial results are transferred to the leader via the <code class="LITERAL">Gather</code> node. Finally, the leader re-aggregates the results across all workers in order to produce the final result. This is reflected in the plan as a <code class="LITERAL">FinalizeAggregate</code> node.</p> <p>Parallel aggregation is not supported in all situations. Each aggregate must be <a href="../parallel-safety/">safe</a> for parallelism and must have a combine function. If the aggregate has a transition state of type <code class="LITERAL">internal</code>, it must have serialization and deserialization functions. See <a href="../sql-createaggregate/">CREATE AGGREGATE</a> for more details. Parallel aggregation is not supported for ordered set aggregates or when the query involves <code class="LITERAL">GROUPING SETS</code>. It can only be used when all joins involved in the query are also part of the parallel portion of the plan.</p> </div> <div class="SECT2"> <h2 class="SECT2" id="PARALLEL-PLAN-TIPS">15.3.4. Parallel Plan Tips</h2> <p>If a query that is expected to do so does not produce a parallel plan, you can try reducing <a href="../runtime-config-query/#GUC-PARALLEL-SETUP-COST">parallel_setup_cost</a> or <a href="../runtime-config-query/#GUC-PARALLEL-TUPLE-COST">parallel_tuple_cost</a>. Of course, this plan may turn out to be slower than the serial plan which the planner preferred, but this will not always be the case. If you don't get a parallel plan even with very small values of these settings (e.g. after setting them both to zero), there may be some reason why the query planner is unable to generate a parallel plan for your query. See <a href="../when-can-parallel-query-be-used/">Section 15.2</a> and <a href="../parallel-safety/">Section 15.4</a> for information on why this may be the case.</p> <p>When executing a parallel plan, you can use <code class="LITERAL">EXPLAIN (ANALYZE, VERBOSE)</code> to display per-worker statistics for each plan node. This may be useful in determining whether the work is being evenly distributed between all plan nodes and more generally in understanding the performance characteristics of the plan.</p> </div>  <div class="NAVFOOTER">  <table summary="Footer navigation table"> <tr> <td width="33%" align="left"><a href="../when-can-parallel-query-be-used/" accesskey="P">Prev</a></td> <td width="34%" align="center"></td> <td width="33%" align="right"><a href="../parallel-safety/" accesskey="N">Next</a></td> </tr> <tr> <td width="33%" align="left">When Can Parallel Query Be Used?</td> <td width="34%" align="center"><a href="https://www.postgresql.org/docs/9.6/static/parallel-query.html" accesskey="U" target="_blank">Up</a></td> <td width="33%" align="right">Parallel Safety</td> </tr> </table> </div>
<div class="_attribution">
  <p class="_attribution-p">
    © 1996–2017 The PostgreSQL Global Development Group<br>Licensed under the PostgreSQL License.<br>
    <a href="https://www.postgresql.org/docs/9.6/static/parallel-plans.html" class="_attribution-link" target="_blank">https://www.postgresql.org/docs/9.6/static/parallel-plans.html</a>
  </p>
</div>

			</div>
		</div>
	</section>

	</div>
</body>
</html>
