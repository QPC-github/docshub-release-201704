
<!DOCTYPE HTML>

<html lang="en">

<head>
  <meta charset="utf-8">
  <title>Server Configuration&#58; Write Ahead Log - PostgreSQL 9.6 - W3cubDocs</title>
  
  <meta name="description" content=" For additional information on tuning these settings, see Section 30.4. ">
  <meta name="keywords" content="write, ahead, log, server, configuration, -, postgresql, postgresql~9.6">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="http://docs.w3cub.com/postgresql~9.6/runtime-config-wal/">
  <link href="/favicon.png" rel="icon">
  <link type="text/css" rel="stylesheet" href="/assets/application-50364fff564ce3b6327021805f3f00e2957b441cf27f576a7dd4ff63bbc47047.css">
  <script type="text/javascript" src="/assets/application-db64bfd54ceb42be11af7995804cf4902548419ceb79d509b0b7d62c22d98e6f.js"></script>
  <script src="/json/postgresql~9.6.js"></script>
  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-71174418-1']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>


</head>

<body>
	<div class="_app">
	<header class="_header">
  
  <form class="_search">
    <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
    <a class="_search-clear"></a>
    <div class="_search-tag"></div>
  </form>
  
  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/postgresql~9.6/" class="_nav-link" title="" style="margin-left:0;">PostgreSQL 9.6</a></span>
  
  <nav class="_nav">
    <a href="/app/" class="_nav-link ">App</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		<div class="_list">
			
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<div class="_page _postgres">
				
<h1 class="SECT1" id="RUNTIME-CONFIG-WAL">19.5. Write Ahead Log</h1> <p>For additional information on tuning these settings, see <a href="../wal-configuration/">Section 30.4</a>.</p> <div class="SECT2"> <h2 class="SECT2" id="RUNTIME-CONFIG-WAL-SETTINGS">19.5.1. Settings</h2> <div class="VARIABLELIST"> <dl> <dt id="GUC-WAL-LEVEL">
<code class="VARNAME">wal_level</code> (<code class="TYPE">enum</code>)</dt> <dd> <p><code class="VARNAME">wal_level</code> determines how much information is written to the WAL. The default value is <code class="LITERAL">minimal</code>, which writes only the information needed to recover from a crash or immediate shutdown. <code class="LITERAL">replica</code> adds logging required for WAL archiving as well as information required to run read-only queries on a standby server. Finally, <code class="LITERAL">logical</code> adds information necessary to support logical decoding. Each level includes the information logged at all lower levels. This parameter can only be set at server start.</p> <p>In <code class="LITERAL">minimal</code> level, WAL-logging of some bulk operations can be safely skipped, which can make those operations much faster (see <a href="../populate/#POPULATE-PITR">Section 14.4.7</a>). Operations in which this optimization can be applied include:</p> <table> <tbody> <tr> <td><code class="COMMAND">CREATE TABLE AS</code></td> </tr> <tr> <td><code class="COMMAND">CREATE INDEX</code></td> </tr> <tr> <td><code class="COMMAND">CLUSTER</code></td> </tr> <tr> <td>
<code class="COMMAND">COPY</code> into tables that were created or truncated in the same transaction</td> </tr> </tbody> </table>But minimal WAL does not contain enough information to reconstruct the data from a base backup and the WAL logs, so <code class="LITERAL">replica</code> or higher must be used to enable WAL archiving (<a href="../runtime-config-wal/#GUC-ARCHIVE-MODE">archive_mode</a>) and streaming replication. <p>In <code class="LITERAL">logical</code> level, the same information is logged as with <code class="LITERAL">replica</code>, plus information needed to allow extracting logical change sets from the WAL. Using a level of <code class="LITERAL">logical</code> will increase the WAL volume, particularly if many tables are configured for <code class="LITERAL">REPLICA IDENTITY FULL</code> and many <code class="COMMAND">UPDATE</code> and <code class="COMMAND">DELETE</code> statements are executed.</p> <p>In releases prior to 9.6, this parameter also allowed the values <code class="LITERAL">archive</code> and <code class="LITERAL">hot_standby</code>. These are still accepted but mapped to <code class="LITERAL">replica</code>.</p> </dd> <dt id="GUC-FSYNC">
<code class="VARNAME">fsync</code> (<code class="TYPE">boolean</code>)</dt> <dd> <p>If this parameter is on, the <span class="PRODUCTNAME">PostgreSQL</span> server will try to make sure that updates are physically written to disk, by issuing <code class="FUNCTION">fsync()</code> system calls or various equivalent methods (see <a href="../runtime-config-wal/#GUC-WAL-SYNC-METHOD">wal_sync_method</a>). This ensures that the database cluster can recover to a consistent state after an operating system or hardware crash.</p> <p>While turning off <code class="VARNAME">fsync</code> is often a performance benefit, this can result in unrecoverable data corruption in the event of a power failure or system crash. Thus it is only advisable to turn off <code class="VARNAME">fsync</code> if you can easily recreate your entire database from external data.</p> <p>Examples of safe circumstances for turning off <code class="VARNAME">fsync</code> include the initial loading of a new database cluster from a backup file, using a database cluster for processing a batch of data after which the database will be thrown away and recreated, or for a read-only database clone which gets recreated frequently and is not used for failover. High quality hardware alone is not a sufficient justification for turning off <code class="VARNAME">fsync</code>.</p> <p>For reliable recovery when changing <code class="VARNAME">fsync</code> off to on, it is necessary to force all modified buffers in the kernel to durable storage. This can be done while the cluster is shutdown or while fsync is on by running <code class="COMMAND">initdb --sync-only</code>, running <code class="COMMAND">sync</code>, unmounting the file system, or rebooting the server.</p> <p>In many situations, turning off <a href="../runtime-config-wal/#GUC-SYNCHRONOUS-COMMIT">synchronous_commit</a> for noncritical transactions can provide much of the potential performance benefit of turning off <code class="VARNAME">fsync</code>, without the attendant risks of data corruption.</p> <p><code class="VARNAME">fsync</code> can only be set in the <code class="FILENAME">postgresql.conf</code> file or on the server command line. If you turn this parameter off, also consider turning off <a href="../runtime-config-wal/#GUC-FULL-PAGE-WRITES">full_page_writes</a>.</p> </dd> <dt id="GUC-SYNCHRONOUS-COMMIT">
<code class="VARNAME">synchronous_commit</code> (<code class="TYPE">enum</code>)</dt> <dd> <p>Specifies whether transaction commit will wait for WAL records to be written to disk before the command returns a <span class="QUOTE">"success"</span> indication to the client. Valid values are <code class="LITERAL">on</code>, <code class="LITERAL">remote_apply</code>, <code class="LITERAL">remote_write</code>, <code class="LITERAL">local</code>, and <code class="LITERAL">off</code>. The default, and safe, setting is <code class="LITERAL">on</code>. When <code class="LITERAL">off</code>, there can be a delay between when success is reported to the client and when the transaction is really guaranteed to be safe against a server crash. (The maximum delay is three times <a href="../runtime-config-wal/#GUC-WAL-WRITER-DELAY">wal_writer_delay</a>.) Unlike <a href="../runtime-config-wal/#GUC-FSYNC">fsync</a>, setting this parameter to <code class="LITERAL">off</code> does not create any risk of database inconsistency: an operating system or database crash might result in some recent allegedly-committed transactions being lost, but the database state will be just the same as if those transactions had been aborted cleanly. So, turning <code class="VARNAME">synchronous_commit</code> off can be a useful alternative when performance is more important than exact certainty about the durability of a transaction. For more discussion see <a href="../wal-async-commit/">Section 30.3</a>.</p> <p>If <a href="../runtime-config-replication/#GUC-SYNCHRONOUS-STANDBY-NAMES"> synchronous_standby_names</a> is non-empty, this parameter also controls whether or not transaction commits will wait for their WAL records to be replicated to the standby server(s). When set to <code class="LITERAL">on</code>, commits will wait until replies from the current synchronous standby(s) indicate they have received the commit record of the transaction and flushed it to disk. This ensures the transaction will not be lost unless both the primary and all synchronous standbys suffer corruption of their database storage. When set to <code class="LITERAL">remote_apply</code>, commits will wait until replies from the current synchronous standby(s) indicate they have received the commit record of the transaction and applied it, so that it has become visible to queries on the standby(s). When set to <code class="LITERAL">remote_write</code>, commits will wait until replies from the current synchronous standby(s) indicate they have received the commit record of the transaction and written it out to their operating system. This setting is sufficient to ensure data preservation even if a standby instance of <span class="PRODUCTNAME">PostgreSQL</span> were to crash, but not if the standby suffers an operating-system-level crash, since the data has not necessarily reached stable storage on the standby. Finally, the setting <code class="LITERAL">local</code> causes commits to wait for local flush to disk, but not for replication. This is not usually desirable when synchronous replication is in use, but is provided for completeness.</p> <p>If <code class="VARNAME">synchronous_standby_names</code> is empty, the settings <code class="LITERAL">on</code>, <code class="LITERAL">remote_apply</code>, <code class="LITERAL">remote_write</code> and <code class="LITERAL">local</code> all provide the same synchronization level: transaction commits only wait for local flush to disk.</p> <p>This parameter can be changed at any time; the behavior for any one transaction is determined by the setting in effect when it commits. It is therefore possible, and useful, to have some transactions commit synchronously and others asynchronously. For example, to make a single multistatement transaction commit asynchronously when the default is the opposite, issue <code class="COMMAND">SET LOCAL synchronous_commit TO OFF</code> within the transaction.</p> </dd> <dt id="GUC-WAL-SYNC-METHOD">
<code class="VARNAME">wal_sync_method</code> (<code class="TYPE">enum</code>)</dt> <dd> <p>Method used for forcing WAL updates out to disk. If <code class="VARNAME">fsync</code> is off then this setting is irrelevant, since WAL file updates will not be forced out at all. Possible values are:</p> <ul> <li> <p><code class="LITERAL">open_datasync</code> (write WAL files with <code class="FUNCTION">open()</code> option <code class="SYMBOL">O_DSYNC</code>)</p> </li> <li> <p><code class="LITERAL">fdatasync</code> (call <code class="FUNCTION">fdatasync()</code> at each commit)</p> </li> <li> <p><code class="LITERAL">fsync</code> (call <code class="FUNCTION">fsync()</code> at each commit)</p> </li> <li> <p><code class="LITERAL">fsync_writethrough</code> (call <code class="FUNCTION">fsync()</code> at each commit, forcing write-through of any disk write cache)</p> </li> <li> <p><code class="LITERAL">open_sync</code> (write WAL files with <code class="FUNCTION">open()</code> option <code class="SYMBOL">O_SYNC</code>)</p> </li> </ul> <p>The <code class="LITERAL">open_</code>* options also use <code class="LITERAL">O_DIRECT</code> if available. Not all of these choices are available on all platforms. The default is the first method in the above list that is supported by the platform, except that <code class="LITERAL">fdatasync</code> is the default on Linux. The default is not necessarily ideal; it might be necessary to change this setting or other aspects of your system configuration in order to create a crash-safe configuration or achieve optimal performance. These aspects are discussed in <a href="../wal-reliability/">Section 30.1</a>. This parameter can only be set in the <code class="FILENAME">postgresql.conf</code> file or on the server command line.</p> </dd> <dt id="GUC-FULL-PAGE-WRITES">
<code class="VARNAME">full_page_writes</code> (<code class="TYPE">boolean</code>)</dt> <dd> <p>When this parameter is on, the <span class="PRODUCTNAME">PostgreSQL</span> server writes the entire content of each disk page to WAL during the first modification of that page after a checkpoint. This is needed because a page write that is in process during an operating system crash might be only partially completed, leading to an on-disk page that contains a mix of old and new data. The row-level change data normally stored in WAL will not be enough to completely restore such a page during post-crash recovery. Storing the full page image guarantees that the page can be correctly restored, but at the price of increasing the amount of data that must be written to WAL. (Because WAL replay always starts from a checkpoint, it is sufficient to do this during the first change of each page after a checkpoint. Therefore, one way to reduce the cost of full-page writes is to increase the checkpoint interval parameters.)</p> <p>Turning this parameter off speeds normal operation, but might lead to either unrecoverable data corruption, or silent data corruption, after a system failure. The risks are similar to turning off <code class="VARNAME">fsync</code>, though smaller, and it should be turned off only based on the same circumstances recommended for that parameter.</p> <p>Turning off this parameter does not affect use of WAL archiving for point-in-time recovery (PITR) (see <a href="../continuous-archiving/">Section 25.3</a>).</p> <p>This parameter can only be set in the <code class="FILENAME">postgresql.conf</code> file or on the server command line. The default is <code class="LITERAL">on</code>.</p> </dd> <dt id="GUC-WAL-LOG-HINTS">
<code class="VARNAME">wal_log_hints</code> (<code class="TYPE">boolean</code>)</dt> <dd> <p>When this parameter is <code class="LITERAL">on</code>, the <span class="PRODUCTNAME">PostgreSQL</span> server writes the entire content of each disk page to WAL during the first modification of that page after a checkpoint, even for non-critical modifications of so-called hint bits.</p> <p>If data checksums are enabled, hint bit updates are always WAL-logged and this setting is ignored. You can use this setting to test how much extra WAL-logging would occur if your database had data checksums enabled.</p> <p>This parameter can only be set at server start. The default value is <code class="LITERAL">off</code>.</p> </dd> <dt id="GUC-WAL-COMPRESSION">
<code class="VARNAME">wal_compression</code> (<code class="TYPE">boolean</code>)</dt> <dd> <p>When this parameter is <code class="LITERAL">on</code>, the <span class="PRODUCTNAME">PostgreSQL</span> server compresses a full page image written to WAL when <a href="../runtime-config-wal/#GUC-FULL-PAGE-WRITES">full_page_writes</a> is on or during a base backup. A compressed page image will be decompressed during WAL replay. The default value is <code class="LITERAL">off</code>. Only superusers can change this setting.</p> <p>Turning this parameter on can reduce the WAL volume without increasing the risk of unrecoverable data corruption, but at the cost of some extra CPU spent on the compression during WAL logging and on the decompression during WAL replay.</p> </dd> <dt id="GUC-WAL-BUFFERS">
<code class="VARNAME">wal_buffers</code> (<code class="TYPE">integer</code>)</dt> <dd> <p>The amount of shared memory used for WAL data that has not yet been written to disk. The default setting of -1 selects a size equal to 1/32nd (about 3%) of <a href="../runtime-config-resource/#GUC-SHARED-BUFFERS">shared_buffers</a>, but not less than <code class="LITERAL">64kB</code> nor more than the size of one WAL segment, typically <code class="LITERAL">16MB</code>. This value can be set manually if the automatic choice is too large or too small, but any positive value less than <code class="LITERAL">32kB</code> will be treated as <code class="LITERAL">32kB</code>. This parameter can only be set at server start.</p> <p>The contents of the WAL buffers are written out to disk at every transaction commit, so extremely large values are unlikely to provide a significant benefit. However, setting this value to at least a few megabytes can improve write performance on a busy server where many clients are committing at once. The auto-tuning selected by the default setting of -1 should give reasonable results in most cases.</p> </dd> <dt id="GUC-WAL-WRITER-DELAY">
<code class="VARNAME">wal_writer_delay</code> (<code class="TYPE">integer</code>)</dt> <dd> <p>Specifies how often the WAL writer flushes WAL. After flushing WAL it sleeps for <code class="VARNAME">wal_writer_delay</code> milliseconds, unless woken up by an asynchronously committing transaction. If the last flush happened less than <code class="VARNAME">wal_writer_delay</code> milliseconds ago and less than <code class="VARNAME">wal_writer_flush_after</code> bytes of WAL have been produced since, then WAL is only written to the operating system, not flushed to disk. The default value is 200 milliseconds (<code class="LITERAL">200ms</code>). Note that on many systems, the effective resolution of sleep delays is 10 milliseconds; setting <code class="VARNAME">wal_writer_delay</code> to a value that is not a multiple of 10 might have the same results as setting it to the next higher multiple of 10. This parameter can only be set in the <code class="FILENAME">postgresql.conf</code> file or on the server command line.</p> </dd> <dt id="GUC-WAL-WRITER-FLUSH-AFTER">
<code class="VARNAME">wal_writer_flush_after</code> (<code class="TYPE">integer</code>)</dt> <dd> <p>Specifies how often the WAL writer flushes WAL. If the last flush happened less than <code class="VARNAME">wal_writer_delay</code> milliseconds ago and less than <code class="VARNAME">wal_writer_flush_after</code> bytes of WAL have been produced since, then WAL is only written to the operating system, not flushed to disk. If <code class="VARNAME">wal_writer_flush_after</code> is set to <code class="LITERAL">0</code> then WAL data is flushed immediately. The default is <code class="LITERAL">1MB</code>. This parameter can only be set in the <code class="FILENAME">postgresql.conf</code> file or on the server command line.</p> </dd> <dt id="GUC-COMMIT-DELAY">
<code class="VARNAME">commit_delay</code> (<code class="TYPE">integer</code>)</dt> <dd> <p><code class="VARNAME">commit_delay</code> adds a time delay, measured in microseconds, before a WAL flush is initiated. This can improve group commit throughput by allowing a larger number of transactions to commit via a single WAL flush, if system load is high enough that additional transactions become ready to commit within the given interval. However, it also increases latency by up to <code class="VARNAME">commit_delay</code> microseconds for each WAL flush. Because the delay is just wasted if no other transactions become ready to commit, a delay is only performed if at least <code class="VARNAME">commit_siblings</code> other transactions are active when a flush is about to be initiated. Also, no delays are performed if <code class="VARNAME">fsync</code> is disabled. The default <code class="VARNAME">commit_delay</code> is zero (no delay). Only superusers can change this setting.</p> <p>In <span class="PRODUCTNAME">PostgreSQL</span> releases prior to 9.3, <code class="VARNAME">commit_delay</code> behaved differently and was much less effective: it affected only commits, rather than all WAL flushes, and waited for the entire configured delay even if the WAL flush was completed sooner. Beginning in <span class="PRODUCTNAME">PostgreSQL</span> 9.3, the first process that becomes ready to flush waits for the configured interval, while subsequent processes wait only until the leader completes the flush operation.</p> </dd> <dt id="GUC-COMMIT-SIBLINGS">
<code class="VARNAME">commit_siblings</code> (<code class="TYPE">integer</code>)</dt> <dd> <p>Minimum number of concurrent open transactions to require before performing the <code class="VARNAME">commit_delay</code> delay. A larger value makes it more probable that at least one other transaction will become ready to commit during the delay interval. The default is five transactions.</p> </dd> </dl> </div> </div> <div class="SECT2"> <h2 class="SECT2" id="RUNTIME-CONFIG-WAL-CHECKPOINTS">19.5.2. Checkpoints</h2> <div class="VARIABLELIST"> <dl> <dt id="GUC-CHECKPOINT-TIMEOUT">
<code class="VARNAME">checkpoint_timeout</code> (<code class="TYPE">integer</code>)</dt> <dd> <p>Maximum time between automatic WAL checkpoints, in seconds. The valid range is between 30 seconds and one day. The default is five minutes (<code class="LITERAL">5min</code>). Increasing this parameter can increase the amount of time needed for crash recovery. This parameter can only be set in the <code class="FILENAME">postgresql.conf</code> file or on the server command line.</p> </dd> <dt id="GUC-CHECKPOINT-COMPLETION-TARGET">
<code class="VARNAME">checkpoint_completion_target</code> (<code class="TYPE">floating point</code>)</dt> <dd> <p>Specifies the target of checkpoint completion, as a fraction of total time between checkpoints. The default is 0.5. This parameter can only be set in the <code class="FILENAME">postgresql.conf</code> file or on the server command line.</p> </dd> <dt id="GUC-CHECKPOINT-FLUSH-AFTER">
<code class="VARNAME">checkpoint_flush_after</code> (<code class="TYPE">integer</code>)</dt> <dd> <p>Whenever more than <code class="VARNAME">checkpoint_flush_after</code> bytes have been written while performing a checkpoint, attempt to force the OS to issue these writes to the underlying storage. Doing so will limit the amount of dirty data in the kernel's page cache, reducing the likelihood of stalls when an fsync is issued at the end of the checkpoint, or when the OS writes data back in larger batches in the background. Often that will result in greatly reduced transaction latency, but there also are some cases, especially with workloads that are bigger than <a href="../runtime-config-resource/#GUC-SHARED-BUFFERS">shared_buffers</a>, but smaller than the OS's page cache, where performance might degrade. This setting may have no effect on some platforms. The valid range is between <code class="LITERAL">0</code>, which disables forced writeback, and <code class="LITERAL">2MB</code>. The default is <code class="LITERAL">256kB</code> on Linux, <code class="LITERAL">0</code> elsewhere. (If <code class="SYMBOL">BLCKSZ</code> is not 8kB, the default and maximum values scale proportionally to it.) This parameter can only be set in the <code class="FILENAME">postgresql.conf</code> file or on the server command line.</p> </dd> <dt id="GUC-CHECKPOINT-WARNING">
<code class="VARNAME">checkpoint_warning</code> (<code class="TYPE">integer</code>)</dt> <dd> <p>Write a message to the server log if checkpoints caused by the filling of checkpoint segment files happen closer together than this many seconds (which suggests that <code class="VARNAME">max_wal_size</code> ought to be raised). The default is 30 seconds (<code class="LITERAL">30s</code>). Zero disables the warning. No warnings will be generated if <code class="VARNAME">checkpoint_timeout</code> is less than <code class="VARNAME">checkpoint_warning</code>. This parameter can only be set in the <code class="FILENAME">postgresql.conf</code> file or on the server command line.</p> </dd> <dt id="GUC-MAX-WAL-SIZE">
<code class="VARNAME">max_wal_size</code> (<code class="TYPE">integer</code>)</dt> <dd> <p>Maximum size to let the WAL grow to between automatic WAL checkpoints. This is a soft limit; WAL size can exceed <code class="VARNAME">max_wal_size</code> under special circumstances, like under heavy load, a failing <code class="VARNAME">archive_command</code>, or a high <code class="VARNAME">wal_keep_segments</code> setting. The default is 1 GB. Increasing this parameter can increase the amount of time needed for crash recovery. This parameter can only be set in the <code class="FILENAME">postgresql.conf</code> file or on the server command line.</p> </dd> <dt id="GUC-MIN-WAL-SIZE">
<code class="VARNAME">min_wal_size</code> (<code class="TYPE">integer</code>)</dt> <dd> <p>As long as WAL disk usage stays below this setting, old WAL files are always recycled for future use at a checkpoint, rather than removed. This can be used to ensure that enough WAL space is reserved to handle spikes in WAL usage, for example when running large batch jobs. The default is 80 MB. This parameter can only be set in the <code class="FILENAME">postgresql.conf</code> file or on the server command line.</p> </dd> </dl> </div> </div> <div class="SECT2"> <h2 class="SECT2" id="RUNTIME-CONFIG-WAL-ARCHIVING">19.5.3. Archiving</h2> <div class="VARIABLELIST"> <dl> <dt id="GUC-ARCHIVE-MODE">
<code class="VARNAME">archive_mode</code> (<code class="TYPE">enum</code>)</dt> <dd> <p>When <code class="VARNAME">archive_mode</code> is enabled, completed WAL segments are sent to archive storage by setting <a href="../runtime-config-wal/#GUC-ARCHIVE-COMMAND">archive_command</a>. In addition to <code class="LITERAL">off</code>, to disable, there are two modes: <code class="LITERAL">on</code>, and <code class="LITERAL">always</code>. During normal operation, there is no difference between the two modes, but when set to <code class="LITERAL">always</code> the WAL archiver is enabled also during archive recovery or standby mode. In <code class="LITERAL">always</code> mode, all files restored from the archive or streamed with streaming replication will be archived (again). See <a href="../warm-standby/#CONTINUOUS-ARCHIVING-IN-STANDBY">Section 26.2.9</a> for details.</p> <p><code class="VARNAME">archive_mode</code> and <code class="VARNAME">archive_command</code> are separate variables so that <code class="VARNAME">archive_command</code> can be changed without leaving archiving mode. This parameter can only be set at server start. <code class="VARNAME">archive_mode</code> cannot be enabled when <code class="VARNAME">wal_level</code> is set to <code class="LITERAL">minimal</code>.</p> </dd> <dt id="GUC-ARCHIVE-COMMAND">
<code class="VARNAME">archive_command</code> (<code class="TYPE">string</code>)</dt> <dd> <p>The local shell command to execute to archive a completed WAL file segment. Any <code class="LITERAL">%p</code> in the string is replaced by the path name of the file to archive, and any <code class="LITERAL">%f</code> is replaced by only the file name. (The path name is relative to the working directory of the server, i.e., the cluster's data directory.) Use <code class="LITERAL">%%</code> to embed an actual <code class="LITERAL">%</code> character in the command. It is important for the command to return a zero exit status only if it succeeds. For more information see <a href="../continuous-archiving/#BACKUP-ARCHIVING-WAL">Section 25.3.1</a>.</p> <p>This parameter can only be set in the <code class="FILENAME">postgresql.conf</code> file or on the server command line. It is ignored unless <code class="VARNAME">archive_mode</code> was enabled at server start. If <code class="VARNAME">archive_command</code> is an empty string (the default) while <code class="VARNAME">archive_mode</code> is enabled, WAL archiving is temporarily disabled, but the server continues to accumulate WAL segment files in the expectation that a command will soon be provided. Setting <code class="VARNAME">archive_command</code> to a command that does nothing but return true, e.g. <code class="LITERAL">/bin/true</code> (<code class="LITERAL">REM</code> on Windows), effectively disables archiving, but also breaks the chain of WAL files needed for archive recovery, so it should only be used in unusual circumstances.</p> </dd> <dt id="GUC-ARCHIVE-TIMEOUT">
<code class="VARNAME">archive_timeout</code> (<code class="TYPE">integer</code>)</dt> <dd> <p>The <a href="../runtime-config-wal/#GUC-ARCHIVE-COMMAND">archive_command</a> is only invoked for completed WAL segments. Hence, if your server generates little WAL traffic (or has slack periods where it does so), there could be a long delay between the completion of a transaction and its safe recording in archive storage. To limit how old unarchived data can be, you can set <code class="VARNAME">archive_timeout</code> to force the server to switch to a new WAL segment file periodically. When this parameter is greater than zero, the server will switch to a new segment file whenever this many seconds have elapsed since the last segment file switch, and there has been any database activity, including a single checkpoint. (Increasing <code class="VARNAME">checkpoint_timeout</code> will reduce unnecessary checkpoints on an idle system.) Note that archived files that are closed early due to a forced switch are still the same length as completely full files. Therefore, it is unwise to use a very short <code class="VARNAME">archive_timeout</code> — it will bloat your archive storage. <code class="VARNAME">archive_timeout</code> settings of a minute or so are usually reasonable. You should consider using streaming replication, instead of archiving, if you want data to be copied off the master server more quickly than that. This parameter can only be set in the <code class="FILENAME">postgresql.conf</code> file or on the server command line.</p> </dd> </dl> </div> </div>  <div class="NAVFOOTER">  <table summary="Footer navigation table"> <tr> <td width="33%" align="left"><a href="../runtime-config-resource/" accesskey="P">Prev</a></td> <td width="34%" align="center"></td> <td width="33%" align="right"><a href="../runtime-config-replication/" accesskey="N">Next</a></td> </tr> <tr> <td width="33%" align="left">Resource Consumption</td> <td width="34%" align="center"><a href="https://www.postgresql.org/docs/9.6/static/runtime-config.html" accesskey="U" target="_blank">Up</a></td> <td width="33%" align="right">Replication</td> </tr> </table> </div>
<div class="_attribution">
  <p class="_attribution-p">
    © 1996–2017 The PostgreSQL Global Development Group<br>Licensed under the PostgreSQL License.<br>
    <a href="https://www.postgresql.org/docs/9.6/static/runtime-config-wal.html" class="_attribution-link" target="_blank">https://www.postgresql.org/docs/9.6/static/runtime-config-wal.html</a>
  </p>
</div>

			</div>
		</div>
	</section>

	</div>
</body>
</html>
