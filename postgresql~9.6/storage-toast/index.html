
<!DOCTYPE HTML>

<html lang="en">

<head>
  <meta charset="utf-8">
  <title>Physical Storage&#58; TOAST - PostgreSQL 9.6 - W3cubDocs</title>
  
  <meta name="description" content=" This section provides an overview of TOAST (The Oversized-Attribute Storage Technique). ">
  <meta name="keywords" content="toast, physical, storage, -, postgresql, postgresql~9.6">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="http://docs.w3cub.com/postgresql~9.6/storage-toast/">
  <link href="/favicon.png" rel="icon">
  <link type="text/css" rel="stylesheet" href="/assets/application-50364fff564ce3b6327021805f3f00e2957b441cf27f576a7dd4ff63bbc47047.css">
  <script type="text/javascript" src="/assets/application-db64bfd54ceb42be11af7995804cf4902548419ceb79d509b0b7d62c22d98e6f.js"></script>
  <script src="/json/postgresql~9.6.js"></script>
  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-71174418-1']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>


</head>

<body>
	<div class="_app">
	<header class="_header">
  
  <form class="_search">
    <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
    <a class="_search-clear"></a>
    <div class="_search-tag"></div>
  </form>
  
  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/postgresql~9.6/" class="_nav-link" title="" style="margin-left:0;">PostgreSQL 9.6</a></span>
  
  <nav class="_nav">
    <a href="/app/" class="_nav-link ">App</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		<div class="_list">
			
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<div class="_page _postgres">
				
<h1 class="SECT1" id="STORAGE-TOAST">65.2. TOAST</h1> <p>This section provides an overview of <acronym class="ACRONYM">TOAST</acronym> (The Oversized-Attribute Storage Technique).</p> <p><span class="PRODUCTNAME">PostgreSQL</span> uses a fixed page size (commonly 8 kB), and does not allow tuples to span multiple pages. Therefore, it is not possible to store very large field values directly. To overcome this limitation, large field values are compressed and/or broken up into multiple physical rows. This happens transparently to the user, with only small impact on most of the backend code. The technique is affectionately known as <acronym class="ACRONYM">TOAST</acronym> (or <span class="QUOTE">"the best thing since sliced bread"</span>). The <acronym class="ACRONYM">TOAST</acronym> infrastructure is also used to improve handling of large data values in-memory.</p> <p>Only certain data types support <acronym class="ACRONYM">TOAST</acronym> — there is no need to impose the overhead on data types that cannot produce large field values. To support <acronym class="ACRONYM">TOAST</acronym>, a data type must have a variable-length (<i class="FIRSTTERM">varlena</i>) representation, in which, ordinarily, the first four-byte word of any stored value contains the total length of the value in bytes (including itself). <acronym class="ACRONYM">TOAST</acronym> does not constrain the rest of the data type's representation. The special representations collectively called <i class="FIRSTTERM"><acronym class="ACRONYM">TOAST</acronym>ed values</i> work by modifying or reinterpreting this initial length word. Therefore, the C-level functions supporting a <acronym class="ACRONYM">TOAST</acronym>-able data type must be careful about how they handle potentially <acronym class="ACRONYM">TOAST</acronym>ed input values: an input might not actually consist of a four-byte length word and contents until after it's been <i class="FIRSTTERM">detoasted</i>. (This is normally done by invoking <code class="FUNCTION">PG_DETOAST_DATUM</code> before doing anything with an input value, but in some cases more efficient approaches are possible. See <a href="https://www.postgresql.org/docs/9.6/static/xtypes.html#XTYPES-TOAST" target="_blank">Section 36.11.1</a> for more detail.)</p> <p><acronym class="ACRONYM">TOAST</acronym> usurps two bits of the varlena length word (the high-order bits on big-endian machines, the low-order bits on little-endian machines), thereby limiting the logical size of any value of a <acronym class="ACRONYM">TOAST</acronym>-able data type to 1 GB (2<sup>30</sup> - 1 bytes). When both bits are zero, the value is an ordinary un-<acronym class="ACRONYM">TOAST</acronym>ed value of the data type, and the remaining bits of the length word give the total datum size (including length word) in bytes. When the highest-order or lowest-order bit is set, the value has only a single-byte header instead of the normal four-byte header, and the remaining bits of that byte give the total datum size (including length byte) in bytes. This alternative supports space-efficient storage of values shorter than 127 bytes, while still allowing the data type to grow to 1 GB at need. Values with single-byte headers aren't aligned on any particular boundary, whereas values with four-byte headers are aligned on at least a four-byte boundary; this omission of alignment padding provides additional space savings that is significant compared to short values. As a special case, if the remaining bits of a single-byte header are all zero (which would be impossible for a self-inclusive length), the value is a pointer to out-of-line data, with several possible alternatives as described below. The type and size of such a <i class="FIRSTTERM">TOAST pointer</i> are determined by a code stored in the second byte of the datum. Lastly, when the highest-order or lowest-order bit is clear but the adjacent bit is set, the content of the datum has been compressed and must be decompressed before use. In this case the remaining bits of the four-byte length word give the total size of the compressed datum, not the original data. Note that compression is also possible for out-of-line data but the varlena header does not tell whether it has occurred — the content of the <acronym class="ACRONYM">TOAST</acronym> pointer tells that, instead.</p> <p>As mentioned, there are multiple types of <acronym class="ACRONYM">TOAST</acronym> pointer datums. The oldest and most common type is a pointer to out-of-line data stored in a <i class="FIRSTTERM"><acronym class="ACRONYM">TOAST</acronym> table</i> that is separate from, but associated with, the table containing the <acronym class="ACRONYM">TOAST</acronym> pointer datum itself. These <i class="FIRSTTERM">on-disk</i> pointer datums are created by the <acronym class="ACRONYM">TOAST</acronym> management code (in <code class="FILENAME">access/heap/tuptoaster.c</code>) when a tuple to be stored on disk is too large to be stored as-is. Further details appear in <a href="../storage-toast/#STORAGE-TOAST-ONDISK">Section 65.2.1</a>. Alternatively, a <acronym class="ACRONYM">TOAST</acronym> pointer datum can contain a pointer to out-of-line data that appears elsewhere in memory. Such datums are necessarily short-lived, and will never appear on-disk, but they are very useful for avoiding copying and redundant processing of large data values. Further details appear in <a href="../storage-toast/#STORAGE-TOAST-INMEMORY">Section 65.2.2</a>.</p> <p>The compression technique used for either in-line or out-of-line compressed data is a fairly simple and very fast member of the LZ family of compression techniques. See <code class="FILENAME">src/common/pg_lzcompress.c</code> for the details.</p> <div class="SECT2"> <h2 class="SECT2" id="STORAGE-TOAST-ONDISK">65.2.1. Out-of-line, on-disk TOAST storage</h2> <p>If any of the columns of a table are <acronym class="ACRONYM">TOAST</acronym>-able, the table will have an associated <acronym class="ACRONYM">TOAST</acronym> table, whose OID is stored in the table's <code class="STRUCTNAME">pg_class</code>.<code class="STRUCTFIELD">reltoastrelid</code> entry. On-disk <acronym class="ACRONYM">TOAST</acronym>ed values are kept in the <acronym class="ACRONYM">TOAST</acronym> table, as described in more detail below.</p> <p>Out-of-line values are divided (after compression if used) into chunks of at most <code class="SYMBOL">TOAST_MAX_CHUNK_SIZE</code> bytes (by default this value is chosen so that four chunk rows will fit on a page, making it about 2000 bytes). Each chunk is stored as a separate row in the <acronym class="ACRONYM">TOAST</acronym> table belonging to the owning table. Every <acronym class="ACRONYM">TOAST</acronym> table has the columns <code class="STRUCTFIELD">chunk_id</code> (an OID identifying the particular <acronym class="ACRONYM">TOAST</acronym>ed value), <code class="STRUCTFIELD">chunk_seq</code> (a sequence number for the chunk within its value), and <code class="STRUCTFIELD">chunk_data</code> (the actual data of the chunk). A unique index on <code class="STRUCTFIELD">chunk_id</code> and <code class="STRUCTFIELD">chunk_seq</code> provides fast retrieval of the values. A pointer datum representing an out-of-line on-disk <acronym class="ACRONYM">TOAST</acronym>ed value therefore needs to store the OID of the <acronym class="ACRONYM">TOAST</acronym> table in which to look and the OID of the specific value (its <code class="STRUCTFIELD">chunk_id</code>). For convenience, pointer datums also store the logical datum size (original uncompressed data length) and physical stored size (different if compression was applied). Allowing for the varlena header bytes, the total size of an on-disk <acronym class="ACRONYM">TOAST</acronym> pointer datum is therefore 18 bytes regardless of the actual size of the represented value.</p> <p>The <acronym class="ACRONYM">TOAST</acronym> management code is triggered only when a row value to be stored in a table is wider than <code class="SYMBOL">TOAST_TUPLE_THRESHOLD</code> bytes (normally 2 kB). The <acronym class="ACRONYM">TOAST</acronym> code will compress and/or move field values out-of-line until the row value is shorter than <code class="SYMBOL">TOAST_TUPLE_TARGET</code> bytes (also normally 2 kB) or no more gains can be had. During an UPDATE operation, values of unchanged fields are normally preserved as-is; so an UPDATE of a row with out-of-line values incurs no <acronym class="ACRONYM">TOAST</acronym> costs if none of the out-of-line values change.</p> <p>The <acronym class="ACRONYM">TOAST</acronym> management code recognizes four different strategies for storing <acronym class="ACRONYM">TOAST</acronym>-able columns on disk:</p> <ul> <li> <p><code class="LITERAL">PLAIN</code> prevents either compression or out-of-line storage; furthermore it disables use of single-byte headers for varlena types. This is the only possible strategy for columns of non-<acronym class="ACRONYM">TOAST</acronym>-able data types.</p> </li> <li> <p><code class="LITERAL">EXTENDED</code> allows both compression and out-of-line storage. This is the default for most <acronym class="ACRONYM">TOAST</acronym>-able data types. Compression will be attempted first, then out-of-line storage if the row is still too big.</p> </li> <li> <p><code class="LITERAL">EXTERNAL</code> allows out-of-line storage but not compression. Use of <code class="LITERAL">EXTERNAL</code> will make substring operations on wide <code class="TYPE">text</code> and <code class="TYPE">bytea</code> columns faster (at the penalty of increased storage space) because these operations are optimized to fetch only the required parts of the out-of-line value when it is not compressed.</p> </li> <li> <p><code class="LITERAL">MAIN</code> allows compression but not out-of-line storage. (Actually, out-of-line storage will still be performed for such columns, but only as a last resort when there is no other way to make the row small enough to fit on a page.)</p> </li> </ul> <p>Each <acronym class="ACRONYM">TOAST</acronym>-able data type specifies a default strategy for columns of that data type, but the strategy for a given table column can be altered with <code class="COMMAND">ALTER TABLE SET STORAGE</code>.</p> <p>This scheme has a number of advantages compared to a more straightforward approach such as allowing row values to span pages. Assuming that queries are usually qualified by comparisons against relatively small key values, most of the work of the executor will be done using the main row entry. The big values of <acronym class="ACRONYM">TOAST</acronym>ed attributes will only be pulled out (if selected at all) at the time the result set is sent to the client. Thus, the main table is much smaller and more of its rows fit in the shared buffer cache than would be the case without any out-of-line storage. Sort sets shrink also, and sorts will more often be done entirely in memory. A little test showed that a table containing typical HTML pages and their URLs was stored in about half of the raw data size including the <acronym class="ACRONYM">TOAST</acronym> table, and that the main table contained only about 10% of the entire data (the URLs and some small HTML pages). There was no run time difference compared to an un-<acronym class="ACRONYM">TOAST</acronym>ed comparison table, in which all the HTML pages were cut down to 7 kB to fit.</p> </div> <div class="SECT2"> <h2 class="SECT2" id="STORAGE-TOAST-INMEMORY">65.2.2. Out-of-line, in-memory TOAST storage</h2> <p><acronym class="ACRONYM">TOAST</acronym> pointers can point to data that is not on disk, but is elsewhere in the memory of the current server process. Such pointers obviously cannot be long-lived, but they are nonetheless useful. There are currently two sub-cases: pointers to <i class="FIRSTTERM">indirect</i> data and pointers to <i class="FIRSTTERM">expanded</i> data.</p> <p>Indirect <acronym class="ACRONYM">TOAST</acronym> pointers simply point at a non-indirect varlena value stored somewhere in memory. This case was originally created merely as a proof of concept, but it is currently used during logical decoding to avoid possibly having to create physical tuples exceeding 1 GB (as pulling all out-of-line field values into the tuple might do). The case is of limited use since the creator of the pointer datum is entirely responsible that the referenced data survives for as long as the pointer could exist, and there is no infrastructure to help with this.</p> <p>Expanded <acronym class="ACRONYM">TOAST</acronym> pointers are useful for complex data types whose on-disk representation is not especially suited for computational purposes. As an example, the standard varlena representation of a <span class="PRODUCTNAME">PostgreSQL</span> array includes dimensionality information, a nulls bitmap if there are any null elements, then the values of all the elements in order. When the element type itself is variable-length, the only way to find the <code class="REPLACEABLE c2">N</code>'th element is to scan through all the preceding elements. This representation is appropriate for on-disk storage because of its compactness, but for computations with the array it's much nicer to have an <span class="QUOTE">"expanded"</span> or <span class="QUOTE">"deconstructed"</span> representation in which all the element starting locations have been identified. The <acronym class="ACRONYM">TOAST</acronym> pointer mechanism supports this need by allowing a pass-by-reference Datum to point to either a standard varlena value (the on-disk representation) or a <acronym class="ACRONYM">TOAST</acronym> pointer that points to an expanded representation somewhere in memory. The details of this expanded representation are up to the data type, though it must have a standard header and meet the other API requirements given in <code class="FILENAME">src/include/utils/expandeddatum.h</code>. C-level functions working with the data type can choose to handle either representation. Functions that do not know about the expanded representation, but simply apply <code class="FUNCTION">PG_DETOAST_DATUM</code> to their inputs, will automatically receive the traditional varlena representation; so support for an expanded representation can be introduced incrementally, one function at a time.</p> <p><acronym class="ACRONYM">TOAST</acronym> pointers to expanded values are further broken down into <i class="FIRSTTERM">read-write</i> and <i class="FIRSTTERM">read-only</i> pointers. The pointed-to representation is the same either way, but a function that receives a read-write pointer is allowed to modify the referenced value in-place, whereas one that receives a read-only pointer must not; it must first create a copy if it wants to make a modified version of the value. This distinction and some associated conventions make it possible to avoid unnecessary copying of expanded values during query execution.</p> <p>For all types of in-memory <acronym class="ACRONYM">TOAST</acronym> pointer, the <acronym class="ACRONYM">TOAST</acronym> management code ensures that no such pointer datum can accidentally get stored on disk. In-memory <acronym class="ACRONYM">TOAST</acronym> pointers are automatically expanded to normal in-line varlena values before storage — and then possibly converted to on-disk <acronym class="ACRONYM">TOAST</acronym> pointers, if the containing tuple would otherwise be too big.</p> </div>  <div class="NAVFOOTER">  <table summary="Footer navigation table"> <tr> <td width="33%" align="left"><a href="../storage-file-layout/" accesskey="P">Prev</a></td> <td width="34%" align="center"></td> <td width="33%" align="right"><a href="../storage-fsm/" accesskey="N">Next</a></td> </tr> <tr> <td width="33%" align="left">Database File Layout</td> <td width="34%" align="center"><a href="https://www.postgresql.org/docs/9.6/static/storage.html" accesskey="U" target="_blank">Up</a></td> <td width="33%" align="right">Free Space Map</td> </tr> </table> </div>
<div class="_attribution">
  <p class="_attribution-p">
    © 1996–2017 The PostgreSQL Global Development Group<br>Licensed under the PostgreSQL License.<br>
    <a href="https://www.postgresql.org/docs/9.6/static/storage-toast.html" class="_attribution-link" target="_blank">https://www.postgresql.org/docs/9.6/static/storage-toast.html</a>
  </p>
</div>

			</div>
		</div>
	</section>

	</div>
</body>
</html>
