
<!DOCTYPE HTML>

<html lang="en">

<head>
  <meta charset="utf-8">
  <title>3.1. Cross-validation - Scikit-learn - W3cubDocs</title>
  
  <meta name="description" content="Learning the parameters of a prediction function and testing it on the same data is a methodological mistake&#58; a model that would just repeat the &hellip;">
  <meta name="keywords" content="cross-validation, evaluating, estimator, performance, -, scikit-learn, scikit_learn">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="http://docs.w3cub.com/scikit_learn/modules/cross_validation/">
  <link href="/favicon.png" rel="icon">
  <link type="text/css" rel="stylesheet" href="/assets/application-50364fff564ce3b6327021805f3f00e2957b441cf27f576a7dd4ff63bbc47047.css">
  <script type="text/javascript" src="/assets/application-db64bfd54ceb42be11af7995804cf4902548419ceb79d509b0b7d62c22d98e6f.js"></script>
  <script src="/json/scikit_learn.js"></script>
  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-71174418-1']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>


</head>

<body>
	<div class="_app">
	<header class="_header">
  
  <form class="_search">
    <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
    <a class="_search-clear"></a>
    <div class="_search-tag"></div>
  </form>
  
  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/scikit_learn/" class="_nav-link" title="" style="margin-left:0;">scikit-learn</a></span>
  
  <nav class="_nav">
    <a href="/app/" class="_nav-link ">App</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		<div class="_list">
			
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<div class="_page _sphinx">
				
<h1 id="cross-validation">3.1. Cross-validation: evaluating estimator performance</h1> <p id="cross-validation-evaluating-estimator-performance">Learning the parameters of a prediction function and testing it on the same data is a methodological mistake: a model that would just repeat the labels of the samples that it has just seen would have a perfect score but would fail to predict anything useful on yet-unseen data. This situation is called <strong>overfitting</strong>. To avoid it, it is common practice when performing a (supervised) machine learning experiment to hold out part of the available data as a <strong>test set</strong> <code>X_test, y_test</code>. Note that the word “experiment” is not intended to denote academic use only, because even in commercial settings machine learning usually starts out experimentally.</p> <p>In scikit-learn a random split into training and test sets can be quickly computed with the <a class="reference internal" href="../generated/sklearn.model_selection.train_test_split/#sklearn.model_selection.train_test_split" title="sklearn.model_selection.train_test_split"><code>train_test_split</code></a> helper function. Let’s load the iris data set to fit a linear support vector machine on it:</p> <pre data-language="python">&gt;&gt;&gt; import numpy as np
&gt;&gt;&gt; from sklearn.model_selection import train_test_split
&gt;&gt;&gt; from sklearn import datasets
&gt;&gt;&gt; from sklearn import svm

&gt;&gt;&gt; iris = datasets.load_iris()
&gt;&gt;&gt; iris.data.shape, iris.target.shape
((150, 4), (150,))
</pre> <p>We can now quickly sample a training set while holding out 40% of the data for testing (evaluating) our classifier:</p> <pre data-language="python">&gt;&gt;&gt; X_train, X_test, y_train, y_test = train_test_split(
...     iris.data, iris.target, test_size=0.4, random_state=0)

&gt;&gt;&gt; X_train.shape, y_train.shape
((90, 4), (90,))
&gt;&gt;&gt; X_test.shape, y_test.shape
((60, 4), (60,))

&gt;&gt;&gt; clf = svm.SVC(kernel='linear', C=1).fit(X_train, y_train)
&gt;&gt;&gt; clf.score(X_test, y_test)                           
0.96...
</pre> <p>When evaluating different settings (“hyperparameters”) for estimators, such as the <code>C</code> setting that must be manually set for an SVM, there is still a risk of overfitting <em>on the test set</em> because the parameters can be tweaked until the estimator performs optimally. This way, knowledge about the test set can “leak” into the model and evaluation metrics no longer report on generalization performance. To solve this problem, yet another part of the dataset can be held out as a so-called “validation set”: training proceeds on the training set, after which evaluation is done on the validation set, and when the experiment seems to be successful, final evaluation can be done on the test set.</p> <p>However, by partitioning the available data into three sets, we drastically reduce the number of samples which can be used for learning the model, and the results can depend on a particular random choice for the pair of (train, validation) sets.</p> <p>A solution to this problem is a procedure called <a class="reference external" href="https://en.wikipedia.org/wiki/Cross-validation_(statistics)" target="_blank">cross-validation</a> (CV for short). A test set should still be held out for final evaluation, but the validation set is no longer needed when doing CV. In the basic approach, called <em>k</em>-fold CV, the training set is split into <em>k</em> smaller sets (other approaches are described below, but generally follow the same principles). The following procedure is followed for each of the <em>k</em> “folds”:</p>  <ul class="simple"> <li>A model is trained using <img class="math" src="http://scikit-learn.org/stable/_images/math/61e28425012ff04c501a81720cdd9f9b5afb962e.png" alt="k-1"> of the folds as training data;</li> <li>the resulting model is validated on the remaining part of the data (i.e., it is used as a test set to compute a performance measure such as accuracy).</li> </ul>  <p>The performance measure reported by <em>k</em>-fold cross-validation is then the average of the values computed in the loop. This approach can be computationally expensive, but does not waste too much data (as it is the case when fixing an arbitrary test set), which is a major advantage in problem such as inverse inference where the number of samples is very small.</p>  <h2 id="computing-cross-validated-metrics">3.1.1. Computing cross-validated metrics</h2> <p>The simplest way to use cross-validation is to call the <a class="reference internal" href="../generated/sklearn.model_selection.cross_val_score/#sklearn.model_selection.cross_val_score" title="sklearn.model_selection.cross_val_score"><code>cross_val_score</code></a> helper function on the estimator and the dataset.</p> <p>The following example demonstrates how to estimate the accuracy of a linear kernel support vector machine on the iris dataset by splitting the data, fitting a model and computing the score 5 consecutive times (with different splits each time):</p> <pre data-language="python">&gt;&gt;&gt; from sklearn.model_selection import cross_val_score
&gt;&gt;&gt; clf = svm.SVC(kernel='linear', C=1)
&gt;&gt;&gt; scores = cross_val_score(clf, iris.data, iris.target, cv=5)
&gt;&gt;&gt; scores                                              
array([ 0.96...,  1.  ...,  0.96...,  0.96...,  1.        ])
</pre> <p>The mean score and the 95% confidence interval of the score estimate are hence given by:</p> <pre data-language="python">&gt;&gt;&gt; print("Accuracy: %0.2f (+/- %0.2f)" % (scores.mean(), scores.std() * 2))
Accuracy: 0.98 (+/- 0.03)
</pre> <p>By default, the score computed at each CV iteration is the <code>score</code> method of the estimator. It is possible to change this by using the scoring parameter:</p> <pre data-language="python">&gt;&gt;&gt; from sklearn import metrics
&gt;&gt;&gt; scores = cross_val_score(
...     clf, iris.data, iris.target, cv=5, scoring='f1_macro')
&gt;&gt;&gt; scores                                              
array([ 0.96...,  1.  ...,  0.96...,  0.96...,  1.        ])
</pre> <p>See <a class="reference internal" href="../model_evaluation/#scoring-parameter"><span class="std std-ref">The scoring parameter: defining model evaluation rules</span></a> for details. In the case of the Iris dataset, the samples are balanced across target classes hence the accuracy and the F1-score are almost equal.</p> <p>When the <code>cv</code> argument is an integer, <a class="reference internal" href="../generated/sklearn.model_selection.cross_val_score/#sklearn.model_selection.cross_val_score" title="sklearn.model_selection.cross_val_score"><code>cross_val_score</code></a> uses the <a class="reference internal" href="../generated/sklearn.model_selection.kfold/#sklearn.model_selection.KFold" title="sklearn.model_selection.KFold"><code>KFold</code></a> or <a class="reference internal" href="../generated/sklearn.model_selection.stratifiedkfold/#sklearn.model_selection.StratifiedKFold" title="sklearn.model_selection.StratifiedKFold"><code>StratifiedKFold</code></a> strategies by default, the latter being used if the estimator derives from <a class="reference internal" href="../generated/sklearn.base.classifiermixin/#sklearn.base.ClassifierMixin" title="sklearn.base.ClassifierMixin"><code>ClassifierMixin</code></a>.</p> <p>It is also possible to use other cross validation strategies by passing a cross validation iterator instead, for instance:</p> <pre data-language="python">&gt;&gt;&gt; from sklearn.model_selection import ShuffleSplit
&gt;&gt;&gt; n_samples = iris.data.shape[0]
&gt;&gt;&gt; cv = ShuffleSplit(n_splits=3, test_size=0.3, random_state=0)
&gt;&gt;&gt; cross_val_score(clf, iris.data, iris.target, cv=cv)
...                                                     
array([ 0.97...,  0.97...,  1.        ])
</pre> <div class="topic"> <p class="topic-title first">Data transformation with held out data</p> <p>Just as it is important to test a predictor on data held-out from training, preprocessing (such as standardization, feature selection, etc.) and similar <a class="reference internal" href="http://scikit-learn.org/stable/data_transforms.html#data-transforms" target="_blank"><span class="std std-ref">data transformations</span></a> similarly should be learnt from a training set and applied to held-out data for prediction:</p> <pre data-language="python">&gt;&gt;&gt; from sklearn import preprocessing
&gt;&gt;&gt; X_train, X_test, y_train, y_test = train_test_split(
...     iris.data, iris.target, test_size=0.4, random_state=0)
&gt;&gt;&gt; scaler = preprocessing.StandardScaler().fit(X_train)
&gt;&gt;&gt; X_train_transformed = scaler.transform(X_train)
&gt;&gt;&gt; clf = svm.SVC(C=1).fit(X_train_transformed, y_train)
&gt;&gt;&gt; X_test_transformed = scaler.transform(X_test)
&gt;&gt;&gt; clf.score(X_test_transformed, y_test)  
0.9333...
</pre> <p>A <a class="reference internal" href="../generated/sklearn.pipeline.pipeline/#sklearn.pipeline.Pipeline" title="sklearn.pipeline.Pipeline"><code>Pipeline</code></a> makes it easier to compose estimators, providing this behavior under cross-validation:</p> <pre data-language="python">&gt;&gt;&gt; from sklearn.pipeline import make_pipeline
&gt;&gt;&gt; clf = make_pipeline(preprocessing.StandardScaler(), svm.SVC(C=1))
&gt;&gt;&gt; cross_val_score(clf, iris.data, iris.target, cv=cv)
...                                                 
array([ 0.97...,  0.93...,  0.95...])
</pre> <p>See <a class="reference internal" href="../pipeline/#combining-estimators"><span class="std std-ref">Pipeline and FeatureUnion: combining estimators</span></a>.</p> </div>  <h3 id="obtaining-predictions-by-cross-validation">3.1.1.1. Obtaining predictions by cross-validation</h3> <p>The function <a class="reference internal" href="../generated/sklearn.model_selection.cross_val_predict/#sklearn.model_selection.cross_val_predict" title="sklearn.model_selection.cross_val_predict"><code>cross_val_predict</code></a> has a similar interface to <a class="reference internal" href="../generated/sklearn.model_selection.cross_val_score/#sklearn.model_selection.cross_val_score" title="sklearn.model_selection.cross_val_score"><code>cross_val_score</code></a>, but returns, for each element in the input, the prediction that was obtained for that element when it was in the test set. Only cross-validation strategies that assign all elements to a test set exactly once can be used (otherwise, an exception is raised).</p> <p>These prediction can then be used to evaluate the classifier:</p> <pre data-language="python">&gt;&gt;&gt; from sklearn.model_selection import cross_val_predict
&gt;&gt;&gt; predicted = cross_val_predict(clf, iris.data, iris.target, cv=10)
&gt;&gt;&gt; metrics.accuracy_score(iris.target, predicted) 
0.966...
</pre> <p>Note that the result of this computation may be slightly different from those obtained using <a class="reference internal" href="../generated/sklearn.model_selection.cross_val_score/#sklearn.model_selection.cross_val_score" title="sklearn.model_selection.cross_val_score"><code>cross_val_score</code></a> as the elements are grouped in different ways.</p> <p>The available cross validation iterators are introduced in the following section.</p> <div class="topic"> <p class="topic-title first">Examples</p> <ul class="simple"> <li>
<a class="reference internal" href="../../auto_examples/model_selection/plot_roc_crossval/#sphx-glr-auto-examples-model-selection-plot-roc-crossval-py"><span class="std std-ref">Receiver Operating Characteristic (ROC) with cross validation</span></a>,</li> <li>
<a class="reference internal" href="../../auto_examples/feature_selection/plot_rfe_with_cross_validation/#sphx-glr-auto-examples-feature-selection-plot-rfe-with-cross-validation-py"><span class="std std-ref">Recursive feature elimination with cross-validation</span></a>,</li> <li>
<a class="reference internal" href="../../auto_examples/model_selection/grid_search_digits/#sphx-glr-auto-examples-model-selection-grid-search-digits-py"><span class="std std-ref">Parameter estimation using grid search with cross-validation</span></a>,</li> <li>
<a class="reference internal" href="../../auto_examples/model_selection/grid_search_text_feature_extraction/#sphx-glr-auto-examples-model-selection-grid-search-text-feature-extraction-py"><span class="std std-ref">Sample pipeline for text feature extraction and evaluation</span></a>,</li> <li>
<a class="reference internal" href="../../auto_examples/plot_cv_predict/#sphx-glr-auto-examples-plot-cv-predict-py"><span class="std std-ref">Plotting Cross-Validated Predictions</span></a>,</li> <li>
<a class="reference internal" href="../../auto_examples/model_selection/plot_nested_cross_validation_iris/#sphx-glr-auto-examples-model-selection-plot-nested-cross-validation-iris-py"><span class="std std-ref">Nested versus non-nested cross-validation</span></a>.</li> </ul> </div>    <h2 id="cross-validation-iterators">3.1.2. Cross validation iterators</h2> <p>The following sections list utilities to generate indices that can be used to generate dataset splits according to different cross validation strategies.</p>   <h2 id="cross-validation-iterators-for-i-i-d-data">3.1.3. Cross-validation iterators for i.i.d. data</h2> <p>Assuming that some data is Independent Identically Distributed (i.i.d.) is making the assumption that all samples stem from the same generative process and that the generative process is assumed to have no memory of past generated samples.</p> <p>The following cross-validators can be used in such cases.</p> <p><strong>NOTE</strong></p> <p>While i.i.d. data is a common assumption in machine learning theory, it rarely holds in practice. If one knows that the samples have been generated using a time-dependent process, it’s safer to use a <code>time-series aware cross-validation scheme &lt;time_series_cv&gt;</code> Similarly if we know that the generative process has a group structure (samples from collected from different subjects, experiments, measurement devices) it safer to use <code>group-wise cross-validation &lt;group_cv&gt;</code>.</p>  <h3 id="k-fold">3.1.3.1. K-fold</h3> <p><a class="reference internal" href="../generated/sklearn.model_selection.kfold/#sklearn.model_selection.KFold" title="sklearn.model_selection.KFold"><code>KFold</code></a> divides all the samples in <img class="math" src="http://scikit-learn.org/stable/_images/math/0b7c1e16a3a8a849bb8ffdcdbf86f65fd1f30438.png" alt="k"> groups of samples, called folds (if <img class="math" src="http://scikit-learn.org/stable/_images/math/1fc9e19dd71e5535697f6babb867aeb7562522dd.png" alt="k = n">, this is equivalent to the <em>Leave One Out</em> strategy), of equal sizes (if possible). The prediction function is learned using <img class="math" src="http://scikit-learn.org/stable/_images/math/a9e4e9b9b08c8a427086d52289abb1934f901edb.png" alt="k - 1"> folds, and the fold left out is used for test.</p> <p>Example of 2-fold cross-validation on a dataset with 4 samples:</p> <pre data-language="python">&gt;&gt;&gt; import numpy as np
&gt;&gt;&gt; from sklearn.model_selection import KFold

&gt;&gt;&gt; X = ["a", "b", "c", "d"]
&gt;&gt;&gt; kf = KFold(n_splits=2)
&gt;&gt;&gt; for train, test in kf.split(X):
...     print("%s %s" % (train, test))
[2 3] [0 1]
[0 1] [2 3]
</pre> <p>Each fold is constituted by two arrays: the first one is related to the <em>training set</em>, and the second one to the <em>test set</em>. Thus, one can create the training/test sets using numpy indexing:</p> <pre data-language="python">&gt;&gt;&gt; X = np.array([[0., 0.], [1., 1.], [-1., -1.], [2., 2.]])
&gt;&gt;&gt; y = np.array([0, 1, 0, 1])
&gt;&gt;&gt; X_train, X_test, y_train, y_test = X[train], X[test], y[train], y[test]
</pre>   <h3 id="leave-one-out-loo">3.1.3.2. Leave One Out (LOO)</h3> <p><a class="reference internal" href="../generated/sklearn.model_selection.leaveoneout/#sklearn.model_selection.LeaveOneOut" title="sklearn.model_selection.LeaveOneOut"><code>LeaveOneOut</code></a> (or LOO) is a simple cross-validation. Each learning set is created by taking all the samples except one, the test set being the sample left out. Thus, for <img class="math" src="http://scikit-learn.org/stable/_images/math/e11f2701c4a39c7fe543a6c4150b421d50f1c159.png" alt="n"> samples, we have <img class="math" src="http://scikit-learn.org/stable/_images/math/e11f2701c4a39c7fe543a6c4150b421d50f1c159.png" alt="n"> different training sets and <img class="math" src="http://scikit-learn.org/stable/_images/math/e11f2701c4a39c7fe543a6c4150b421d50f1c159.png" alt="n"> different tests set. This cross-validation procedure does not waste much data as only one sample is removed from the training set:</p> <pre data-language="python">&gt;&gt;&gt; from sklearn.model_selection import LeaveOneOut

&gt;&gt;&gt; X = [1, 2, 3, 4]
&gt;&gt;&gt; loo = LeaveOneOut()
&gt;&gt;&gt; for train, test in loo.split(X):
...     print("%s %s" % (train, test))
[1 2 3] [0]
[0 2 3] [1]
[0 1 3] [2]
[0 1 2] [3]
</pre> <p>Potential users of LOO for model selection should weigh a few known caveats. When compared with <img class="math" src="http://scikit-learn.org/stable/_images/math/0b7c1e16a3a8a849bb8ffdcdbf86f65fd1f30438.png" alt="k">-fold cross validation, one builds <img class="math" src="http://scikit-learn.org/stable/_images/math/e11f2701c4a39c7fe543a6c4150b421d50f1c159.png" alt="n"> models from <img class="math" src="http://scikit-learn.org/stable/_images/math/e11f2701c4a39c7fe543a6c4150b421d50f1c159.png" alt="n"> samples instead of <img class="math" src="http://scikit-learn.org/stable/_images/math/0b7c1e16a3a8a849bb8ffdcdbf86f65fd1f30438.png" alt="k"> models, where <img class="math" src="http://scikit-learn.org/stable/_images/math/74ee316bb8dee156028f664712dc8a7a5041c3e9.png" alt="n &gt; k">. Moreover, each is trained on <img class="math" src="http://scikit-learn.org/stable/_images/math/72d8a65b17ed7725b7ea4889ade867111639176d.png" alt="n - 1"> samples rather than <img class="math" src="http://scikit-learn.org/stable/_images/math/2baeb8d2dd3a6f7786fdcf029ad7c8c753970291.png" alt="(k-1) n / k">. In both ways, assuming <img class="math" src="http://scikit-learn.org/stable/_images/math/0b7c1e16a3a8a849bb8ffdcdbf86f65fd1f30438.png" alt="k"> is not too large and <img class="math" src="http://scikit-learn.org/stable/_images/math/0c3095fa818c49399a1b1160ae1f756e94acb6e9.png" alt="k &lt; n">, LOO is more computationally expensive than <img class="math" src="http://scikit-learn.org/stable/_images/math/0b7c1e16a3a8a849bb8ffdcdbf86f65fd1f30438.png" alt="k">-fold cross validation.</p> <p>In terms of accuracy, LOO often results in high variance as an estimator for the test error. Intuitively, since <img class="math" src="http://scikit-learn.org/stable/_images/math/72d8a65b17ed7725b7ea4889ade867111639176d.png" alt="n - 1"> of the <img class="math" src="http://scikit-learn.org/stable/_images/math/e11f2701c4a39c7fe543a6c4150b421d50f1c159.png" alt="n"> samples are used to build each model, models constructed from folds are virtually identical to each other and to the model built from the entire training set.</p> <p>However, if the learning curve is steep for the training size in question, then 5- or 10- fold cross validation can overestimate the generalization error.</p> <p>As a general rule, most authors, and empirical evidence, suggest that 5- or 10- fold cross validation should be preferred to LOO.</p> <div class="topic"> <p class="topic-title first">References:</p> <ul class="simple"> <li>
<a class="reference external" href="http://www.faqs.org/faqs/ai-faq/neural-nets/part3/section-12.html" target="_blank">http://www.faqs.org/faqs/ai-faq/neural-nets/part3/section-12.html</a>;</li> <li>T. Hastie, R. Tibshirani, J. Friedman, <a class="reference external" href="http://statweb.stanford.edu/~tibs/ElemStatLearn" target="_blank">The Elements of Statistical Learning</a>, Springer 2009</li> <li>L. Breiman, P. Spector <a class="reference external" href="http://digitalassets.lib.berkeley.edu/sdtr/ucb/text/197.pdf" target="_blank">Submodel selection and evaluation in regression: The X-random case</a>, International Statistical Review 1992;</li> <li>R. Kohavi, <a class="reference external" href="http://web.cs.iastate.edu/~jtian/cs573/Papers/Kohavi-IJCAI-95.pdf" target="_blank">A Study of Cross-Validation and Bootstrap for Accuracy Estimation and Model Selection</a>, Intl. Jnt. Conf. AI</li> <li>R. Bharat Rao, G. Fung, R. Rosales, <a class="reference external" href="http://people.csail.mit.edu/romer/papers/CrossVal_SDM08.pdf" target="_blank">On the Dangers of Cross-Validation. An Experimental Evaluation</a>, SIAM 2008;</li> <li>G. James, D. Witten, T. Hastie, R Tibshirani, <a class="reference external" href="http://www-bcf.usc.edu/~gareth/ISL" target="_blank">An Introduction to Statistical Learning</a>, Springer 2013.</li> </ul> </div>   <h3 id="leave-p-out-lpo">3.1.3.3. Leave P Out (LPO)</h3> <p><a class="reference internal" href="../generated/sklearn.model_selection.leavepout/#sklearn.model_selection.LeavePOut" title="sklearn.model_selection.LeavePOut"><code>LeavePOut</code></a> is very similar to <a class="reference internal" href="../generated/sklearn.model_selection.leaveoneout/#sklearn.model_selection.LeaveOneOut" title="sklearn.model_selection.LeaveOneOut"><code>LeaveOneOut</code></a> as it creates all the possible training/test sets by removing <img class="math" src="http://scikit-learn.org/stable/_images/math/27d463da4622be5b3ef1d4176ced7d7a323c6425.png" alt="p"> samples from the complete set. For <img class="math" src="http://scikit-learn.org/stable/_images/math/e11f2701c4a39c7fe543a6c4150b421d50f1c159.png" alt="n"> samples, this produces <img class="math" src="http://scikit-learn.org/stable/_images/math/db0633044e8b47d65250ffea6683c3aa3dd2a3c6.png" alt="{n \choose p}"> train-test pairs. Unlike <a class="reference internal" href="../generated/sklearn.model_selection.leaveoneout/#sklearn.model_selection.LeaveOneOut" title="sklearn.model_selection.LeaveOneOut"><code>LeaveOneOut</code></a> and <a class="reference internal" href="../generated/sklearn.model_selection.kfold/#sklearn.model_selection.KFold" title="sklearn.model_selection.KFold"><code>KFold</code></a>, the test sets will overlap for <img class="math" src="http://scikit-learn.org/stable/_images/math/1d718544ce7f48c349cbefc3be3cb4afdf451e12.png" alt="p &gt; 1">.</p> <p>Example of Leave-2-Out on a dataset with 4 samples:</p> <pre data-language="python">&gt;&gt;&gt; from sklearn.model_selection import LeavePOut

&gt;&gt;&gt; X = np.ones(4)
&gt;&gt;&gt; lpo = LeavePOut(p=2)
&gt;&gt;&gt; for train, test in lpo.split(X):
...     print("%s %s" % (train, test))
[2 3] [0 1]
[1 3] [0 2]
[1 2] [0 3]
[0 3] [1 2]
[0 2] [1 3]
[0 1] [2 3]
</pre>   <h3 id="shufflesplit">3.1.3.4. Random permutations cross-validation a.k.a. Shuffle &amp; Split</h3> <p id="random-permutations-cross-validation-a-k-a-shuffle-split"><a class="reference internal" href="../generated/sklearn.model_selection.shufflesplit/#sklearn.model_selection.ShuffleSplit" title="sklearn.model_selection.ShuffleSplit"><code>ShuffleSplit</code></a></p> <p>The <a class="reference internal" href="../generated/sklearn.model_selection.shufflesplit/#sklearn.model_selection.ShuffleSplit" title="sklearn.model_selection.ShuffleSplit"><code>ShuffleSplit</code></a> iterator will generate a user defined number of independent train / test dataset splits. Samples are first shuffled and then split into a pair of train and test sets.</p> <p>It is possible to control the randomness for reproducibility of the results by explicitly seeding the <code>random_state</code> pseudo random number generator.</p> <p>Here is a usage example:</p> <pre data-language="python">&gt;&gt;&gt; from sklearn.model_selection import ShuffleSplit
&gt;&gt;&gt; X = np.arange(5)
&gt;&gt;&gt; ss = ShuffleSplit(n_splits=3, test_size=0.25,
...     random_state=0)
&gt;&gt;&gt; for train_index, test_index in ss.split(X):
...     print("%s %s" % (train_index, test_index))
...
[1 3 4] [2 0]
[1 4 3] [0 2]
[4 0 2] [1 3]
</pre> <p><a class="reference internal" href="../generated/sklearn.model_selection.shufflesplit/#sklearn.model_selection.ShuffleSplit" title="sklearn.model_selection.ShuffleSplit"><code>ShuffleSplit</code></a> is thus a good alternative to <a class="reference internal" href="../generated/sklearn.model_selection.kfold/#sklearn.model_selection.KFold" title="sklearn.model_selection.KFold"><code>KFold</code></a> cross validation that allows a finer control on the number of iterations and the proportion of samples on each side of the train / test split.</p>    <h2 id="cross-validation-iterators-with-stratification-based-on-class-labels">3.1.4. Cross-validation iterators with stratification based on class labels.</h2> <p>Some classification problems can exhibit a large imbalance in the distribution of the target classes: for instance there could be several times more negative samples than positive samples. In such cases it is recommended to use stratified sampling as implemented in <a class="reference internal" href="../generated/sklearn.model_selection.stratifiedkfold/#sklearn.model_selection.StratifiedKFold" title="sklearn.model_selection.StratifiedKFold"><code>StratifiedKFold</code></a> and <a class="reference internal" href="../generated/sklearn.model_selection.stratifiedshufflesplit/#sklearn.model_selection.StratifiedShuffleSplit" title="sklearn.model_selection.StratifiedShuffleSplit"><code>StratifiedShuffleSplit</code></a> to ensure that relative class frequencies is approximately preserved in each train and validation fold.</p>  <h3 id="stratified-k-fold">3.1.4.1. Stratified k-fold</h3> <p><a class="reference internal" href="../generated/sklearn.model_selection.stratifiedkfold/#sklearn.model_selection.StratifiedKFold" title="sklearn.model_selection.StratifiedKFold"><code>StratifiedKFold</code></a> is a variation of <em>k-fold</em> which returns <em>stratified</em> folds: each set contains approximately the same percentage of samples of each target class as the complete set.</p> <p>Example of stratified 3-fold cross-validation on a dataset with 10 samples from two slightly unbalanced classes:</p> <pre data-language="python">&gt;&gt;&gt; from sklearn.model_selection import StratifiedKFold

&gt;&gt;&gt; X = np.ones(10)
&gt;&gt;&gt; y = [0, 0, 0, 0, 1, 1, 1, 1, 1, 1]
&gt;&gt;&gt; skf = StratifiedKFold(n_splits=3)
&gt;&gt;&gt; for train, test in skf.split(X, y):
...     print("%s %s" % (train, test))
[2 3 6 7 8 9] [0 1 4 5]
[0 1 3 4 5 8 9] [2 6 7]
[0 1 2 4 5 6 7] [3 8 9]
</pre>   <h3 id="stratified-shuffle-split">3.1.4.2. Stratified Shuffle Split</h3> <p><a class="reference internal" href="../generated/sklearn.model_selection.stratifiedshufflesplit/#sklearn.model_selection.StratifiedShuffleSplit" title="sklearn.model_selection.StratifiedShuffleSplit"><code>StratifiedShuffleSplit</code></a> is a variation of <em>ShuffleSplit</em>, which returns stratified splits, <em>i.e</em> which creates splits by preserving the same percentage for each target class as in the complete set.</p>    <h2 id="cross-validation-iterators-for-grouped-data">3.1.5. Cross-validation iterators for grouped data.</h2> <p>The i.i.d. assumption is broken if the underlying generative process yield groups of dependent samples.</p> <p>Such a grouping of data is domain specific. An example would be when there is medical data collected from multiple patients, with multiple samples taken from each patient. And such data is likely to be dependent on the individual group. In our example, the patient id for each sample will be its group identifier.</p> <p>In this case we would like to know if a model trained on a particular set of groups generalizes well to the unseen groups. To measure this, we need to ensure that all the samples in the validation fold come from groups that are not represented at all in the paired training fold.</p> <p>The following cross-validation splitters can be used to do that. The grouping identifier for the samples is specified via the <code>groups</code> parameter.</p>  <h3 id="group-k-fold">3.1.5.1. Group k-fold</h3> <p>class:GroupKFold is a variation of k-fold which ensures that the same group is not represented in both testing and training sets. For example if the data is obtained from different subjects with several samples per-subject and if the model is flexible enough to learn from highly person specific features it could fail to generalize to new subjects. class:GroupKFold makes it possible to detect this kind of overfitting situations.</p> <p>Imagine you have three subjects, each with an associated number from 1 to 3:</p> <pre data-language="python">&gt;&gt;&gt; from sklearn.model_selection import GroupKFold

&gt;&gt;&gt; X = [0.1, 0.2, 2.2, 2.4, 2.3, 4.55, 5.8, 8.8, 9, 10]
&gt;&gt;&gt; y = ["a", "b", "b", "b", "c", "c", "c", "d", "d", "d"]
&gt;&gt;&gt; groups = [1, 1, 1, 2, 2, 2, 3, 3, 3, 3]

&gt;&gt;&gt; gkf = GroupKFold(n_splits=3)
&gt;&gt;&gt; for train, test in gkf.split(X, y, groups=groups):
...     print("%s %s" % (train, test))
[0 1 2 3 4 5] [6 7 8 9]
[0 1 2 6 7 8 9] [3 4 5]
[3 4 5 6 7 8 9] [0 1 2]
</pre> <p>Each subject is in a different testing fold, and the same subject is never in both testing and training. Notice that the folds do not have exactly the same size due to the imbalance in the data.</p>   <h3 id="leave-one-group-out">3.1.5.2. Leave One Group Out</h3> <p><a class="reference internal" href="../generated/sklearn.model_selection.leaveonegroupout/#sklearn.model_selection.LeaveOneGroupOut" title="sklearn.model_selection.LeaveOneGroupOut"><code>LeaveOneGroupOut</code></a> is a cross-validation scheme which holds out the samples according to a third-party provided array of integer groups. This group information can be used to encode arbitrary domain specific pre-defined cross-validation folds.</p> <p>Each training set is thus constituted by all the samples except the ones related to a specific group.</p> <p>For example, in the cases of multiple experiments, <a class="reference internal" href="../generated/sklearn.model_selection.leaveonegroupout/#sklearn.model_selection.LeaveOneGroupOut" title="sklearn.model_selection.LeaveOneGroupOut"><code>LeaveOneGroupOut</code></a> can be used to create a cross-validation based on the different experiments: we create a training set using the samples of all the experiments except one:</p> <pre data-language="python">&gt;&gt;&gt; from sklearn.model_selection import LeaveOneGroupOut

&gt;&gt;&gt; X = [1, 5, 10, 50, 60, 70, 80]
&gt;&gt;&gt; y = [0, 1, 1, 2, 2, 2, 2]
&gt;&gt;&gt; groups = [1, 1, 2, 2, 3, 3, 3]
&gt;&gt;&gt; logo = LeaveOneGroupOut()
&gt;&gt;&gt; for train, test in logo.split(X, y, groups=groups):
...     print("%s %s" % (train, test))
[2 3 4 5 6] [0 1]
[0 1 4 5 6] [2 3]
[0 1 2 3] [4 5 6]
</pre> <p>Another common application is to use time information: for instance the groups could be the year of collection of the samples and thus allow for cross-validation against time-based splits.</p>   <h3 id="leave-p-groups-out">3.1.5.3. Leave P Groups Out</h3> <p><a class="reference internal" href="../generated/sklearn.model_selection.leavepgroupsout/#sklearn.model_selection.LeavePGroupsOut" title="sklearn.model_selection.LeavePGroupsOut"><code>LeavePGroupsOut</code></a> is similar as <a class="reference internal" href="../generated/sklearn.model_selection.leaveonegroupout/#sklearn.model_selection.LeaveOneGroupOut" title="sklearn.model_selection.LeaveOneGroupOut"><code>LeaveOneGroupOut</code></a>, but removes samples related to <img class="math" src="http://scikit-learn.org/stable/_images/math/9dcbbef8e0f76051d388013b90a95bec3069e484.png" alt="P"> groups for each training/test set.</p> <p>Example of Leave-2-Group Out:</p> <pre data-language="python">&gt;&gt;&gt; from sklearn.model_selection import LeavePGroupsOut

&gt;&gt;&gt; X = np.arange(6)
&gt;&gt;&gt; y = [1, 1, 1, 2, 2, 2]
&gt;&gt;&gt; groups = [1, 1, 2, 2, 3, 3]
&gt;&gt;&gt; lpgo = LeavePGroupsOut(n_groups=2)
&gt;&gt;&gt; for train, test in lpgo.split(X, y, groups=groups):
...     print("%s %s" % (train, test))
[4 5] [0 1 2 3]
[2 3] [0 1 4 5]
[0 1] [2 3 4 5]
</pre>   <h3 id="group-shuffle-split">3.1.5.4. Group Shuffle Split</h3> <p><a class="reference internal" href="../generated/sklearn.model_selection.groupshufflesplit/#sklearn.model_selection.GroupShuffleSplit" title="sklearn.model_selection.GroupShuffleSplit"><code>GroupShuffleSplit</code></a></p> <p>The <a class="reference internal" href="../generated/sklearn.model_selection.groupshufflesplit/#sklearn.model_selection.GroupShuffleSplit" title="sklearn.model_selection.GroupShuffleSplit"><code>GroupShuffleSplit</code></a> iterator behaves as a combination of <a class="reference internal" href="../generated/sklearn.model_selection.shufflesplit/#sklearn.model_selection.ShuffleSplit" title="sklearn.model_selection.ShuffleSplit"><code>ShuffleSplit</code></a> and <a class="reference internal" href="../generated/sklearn.model_selection.leavepgroupsout/#sklearn.model_selection.LeavePGroupsOut" title="sklearn.model_selection.LeavePGroupsOut"><code>LeavePGroupsOut</code></a>, and generates a sequence of randomized partitions in which a subset of groups are held out for each split.</p> <p>Here is a usage example:</p> <pre data-language="python">&gt;&gt;&gt; from sklearn.model_selection import GroupShuffleSplit

&gt;&gt;&gt; X = [0.1, 0.2, 2.2, 2.4, 2.3, 4.55, 5.8, 0.001]
&gt;&gt;&gt; y = ["a", "b", "b", "b", "c", "c", "c", "a"]
&gt;&gt;&gt; groups = [1, 1, 2, 2, 3, 3, 4, 4]
&gt;&gt;&gt; gss = GroupShuffleSplit(n_splits=4, test_size=0.5, random_state=0)
&gt;&gt;&gt; for train, test in gss.split(X, y, groups=groups):
...     print("%s %s" % (train, test))
...
[0 1 2 3] [4 5 6 7]
[2 3 6 7] [0 1 4 5]
[2 3 4 5] [0 1 6 7]
[4 5 6 7] [0 1 2 3]
</pre> <p>This class is useful when the behavior of <a class="reference internal" href="../generated/sklearn.model_selection.leavepgroupsout/#sklearn.model_selection.LeavePGroupsOut" title="sklearn.model_selection.LeavePGroupsOut"><code>LeavePGroupsOut</code></a> is desired, but the number of groups is large enough that generating all possible partitions with <img class="math" src="http://scikit-learn.org/stable/_images/math/9dcbbef8e0f76051d388013b90a95bec3069e484.png" alt="P"> groups withheld would be prohibitively expensive. In such a scenario, <a class="reference internal" href="../generated/sklearn.model_selection.groupshufflesplit/#sklearn.model_selection.GroupShuffleSplit" title="sklearn.model_selection.GroupShuffleSplit"><code>GroupShuffleSplit</code></a> provides a random sample (with replacement) of the train / test splits generated by <a class="reference internal" href="../generated/sklearn.model_selection.leavepgroupsout/#sklearn.model_selection.LeavePGroupsOut" title="sklearn.model_selection.LeavePGroupsOut"><code>LeavePGroupsOut</code></a>.</p>    <h2 id="predefined-fold-splits-validation-sets">3.1.6. Predefined Fold-Splits / Validation-Sets</h2> <p>For some datasets, a pre-defined split of the data into training- and validation fold or into several cross-validation folds already exists. Using <a class="reference internal" href="../generated/sklearn.model_selection.predefinedsplit/#sklearn.model_selection.PredefinedSplit" title="sklearn.model_selection.PredefinedSplit"><code>PredefinedSplit</code></a> it is possible to use these folds e.g. when searching for hyperparameters.</p> <p>For example, when using a validation set, set the <code>test_fold</code> to 0 for all samples that are part of the validation set, and to -1 for all other samples.</p>   <h2 id="cross-validation-of-time-series-data">3.1.7. Cross validation of time series data</h2> <p>Time series data is characterised by the correlation between observations that are near in time (<em>autocorrelation</em>). However, classical cross-validation techniques such as <a class="reference internal" href="../generated/sklearn.model_selection.kfold/#sklearn.model_selection.KFold" title="sklearn.model_selection.KFold"><code>KFold</code></a> and <a class="reference internal" href="../generated/sklearn.model_selection.shufflesplit/#sklearn.model_selection.ShuffleSplit" title="sklearn.model_selection.ShuffleSplit"><code>ShuffleSplit</code></a> assume the samples are independent and identically distributed, and would result in unreasonable correlation between training and testing instances (yielding poor estimates of generalisation error) on time series data. Therefore, it is very important to evaluate our model for time series data on the “future” observations least like those that are used to train the model. To achieve this, one solution is provided by <a class="reference internal" href="../generated/sklearn.model_selection.timeseriessplit/#sklearn.model_selection.TimeSeriesSplit" title="sklearn.model_selection.TimeSeriesSplit"><code>TimeSeriesSplit</code></a>.</p>  <h3 id="time-series-split">3.1.7.1. Time Series Split</h3> <p><a class="reference internal" href="../generated/sklearn.model_selection.timeseriessplit/#sklearn.model_selection.TimeSeriesSplit" title="sklearn.model_selection.TimeSeriesSplit"><code>TimeSeriesSplit</code></a> is a variation of <em>k-fold</em> which returns first <img class="math" src="http://scikit-learn.org/stable/_images/math/0b7c1e16a3a8a849bb8ffdcdbf86f65fd1f30438.png" alt="k"> folds as train set and the <img class="math" src="http://scikit-learn.org/stable/_images/math/0f16395b0768b43f817540eac6a0c660ef5715f8.png" alt="(k+1)"> th fold as test set. Note that unlike standard cross-validation methods, successive training sets are supersets of those that come before them. Also, it adds all surplus data to the first training partition, which is always used to train the model.</p> <p>This class can be used to cross-validate time series data samples that are observed at fixed time intervals.</p> <p>Example of 3-split time series cross-validation on a dataset with 6 samples:</p> <pre data-language="python">&gt;&gt;&gt; from sklearn.model_selection import TimeSeriesSplit

&gt;&gt;&gt; X = np.array([[1, 2], [3, 4], [1, 2], [3, 4], [1, 2], [3, 4]])
&gt;&gt;&gt; y = np.array([1, 2, 3, 4, 5, 6])
&gt;&gt;&gt; tscv = TimeSeriesSplit(n_splits=3)
&gt;&gt;&gt; print(tscv)  
TimeSeriesSplit(n_splits=3)
&gt;&gt;&gt; for train, test in tscv.split(X):
...     print("%s %s" % (train, test))
[0 1 2] [3]
[0 1 2 3] [4]
[0 1 2 3 4] [5]
</pre>    <h2 id="a-note-on-shuffling">3.1.8. A note on shuffling</h2> <p>If the data ordering is not arbitrary (e.g. samples with the same class label are contiguous), shuffling it first may be essential to get a meaningful cross- validation result. However, the opposite may be true if the samples are not independently and identically distributed. For example, if samples correspond to news articles, and are ordered by their time of publication, then shuffling the data will likely lead to a model that is overfit and an inflated validation score: it will be tested on samples that are artificially similar (close in time) to training samples.</p> <p>Some cross validation iterators, such as <a class="reference internal" href="../generated/sklearn.model_selection.kfold/#sklearn.model_selection.KFold" title="sklearn.model_selection.KFold"><code>KFold</code></a>, have an inbuilt option to shuffle the data indices before splitting them. Note that:</p> <ul class="simple"> <li>This consumes less memory than shuffling the data directly.</li> <li>By default no shuffling occurs, including for the (stratified) K fold cross- validation performed by specifying <code>cv=some_integer</code> to <a class="reference internal" href="../generated/sklearn.model_selection.cross_val_score/#sklearn.model_selection.cross_val_score" title="sklearn.model_selection.cross_val_score"><code>cross_val_score</code></a>, grid search, etc. Keep in mind that <a class="reference internal" href="../generated/sklearn.model_selection.train_test_split/#sklearn.model_selection.train_test_split" title="sklearn.model_selection.train_test_split"><code>train_test_split</code></a> still returns a random split.</li> <li>The <code>random_state</code> parameter defaults to <code>None</code>, meaning that the shuffling will be different every time <code>KFold(..., shuffle=True)</code> is iterated. However, <code>GridSearchCV</code> will use the same shuffling for each set of parameters validated by a single call to its <code>fit</code> method.</li> <li>To ensure results are repeatable (<em>on the same platform</em>), use a fixed value for <code>random_state</code>.</li> </ul>   <h2 id="cross-validation-and-model-selection">3.1.9. Cross validation and model selection</h2> <p>Cross validation iterators can also be used to directly perform model selection using Grid Search for the optimal hyperparameters of the model. This is the topic of the next section: <a class="reference internal" href="../grid_search/#grid-search"><span class="std std-ref">Tuning the hyper-parameters of an estimator</span></a>.</p>
<div class="_attribution">
  <p class="_attribution-p">
    © 2007–2016 The scikit-learn developers<br>Licensed under the 3-clause BSD License.<br>
    <a href="http://scikit-learn.org/stable/modules/cross_validation.html" class="_attribution-link" target="_blank">http://scikit-learn.org/stable/modules/cross_validation.html</a>
  </p>
</div>

			</div>
		</div>
	</section>

	</div>
</body>
</html>
