
<!DOCTYPE HTML>

<html lang="en">

<head>
  <meta charset="utf-8">
  <title>1.1. Generalized Linear Models - Scikit-learn - W3cubDocs</title>
  
  <meta name="description" content="The following are a set of methods intended for regression in which the target value is expected to be a linear combination of the input variables. &hellip;">
  <meta name="keywords" content="generalized, linear, models, -, scikit-learn, scikit_learn">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="http://docs.w3cub.com/scikit_learn/modules/linear_model/">
  <link href="/favicon.png" rel="icon">
  <link type="text/css" rel="stylesheet" href="/assets/application-50364fff564ce3b6327021805f3f00e2957b441cf27f576a7dd4ff63bbc47047.css">
  <script type="text/javascript" src="/assets/application-db64bfd54ceb42be11af7995804cf4902548419ceb79d509b0b7d62c22d98e6f.js"></script>
  <script src="/json/scikit_learn.js"></script>
  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-71174418-1']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>


</head>

<body>
	<div class="_app">
	<header class="_header">
  
  <form class="_search">
    <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
    <a class="_search-clear"></a>
    <div class="_search-tag"></div>
  </form>
  
  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/scikit_learn/" class="_nav-link" title="" style="margin-left:0;">scikit-learn</a></span>
  
  <nav class="_nav">
    <a href="/app/" class="_nav-link ">App</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		<div class="_list">
			
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<div class="_page _sphinx">
				
<h1 id="linear-model">1.1. Generalized Linear Models</h1> <p id="generalized-linear-models">The following are a set of methods intended for regression in which the target value is expected to be a linear combination of the input variables. In mathematical notion, if <img class="math" src="http://scikit-learn.org/stable/_images/math/480dcbe70367e5f775ea3004cce070d91315d6a2.png" alt="\hat{y}"> is the predicted value.</p> <div class="math"> <p><img src="http://scikit-learn.org/stable/_images/math/334dd847bce79ed52a760f02b3efd8faefdb6e8b.png" alt="\hat{y}(w, x) = w_0 + w_1 x_1 + ... + w_p x_p"></p> </div>
<p>Across the module, we designate the vector <img class="math" src="http://scikit-learn.org/stable/_images/math/843835b028b47682b57b538b10dc03336f27a34d.png" alt="w = (w_1,
..., w_p)"> as <code>coef_</code> and <img class="math" src="http://scikit-learn.org/stable/_images/math/faafb19d9d95d41a5554bd1b8d8ca2e16a89935d.png" alt="w_0"> as <code>intercept_</code>.</p> <p>To perform classification with generalized linear models, see <a class="reference internal" href="#logistic-regression"><span class="std std-ref">Logistic regression</span></a>.</p>  <h2 id="id1">1.1.1. Ordinary Least Squares</h2> <p id="ordinary-least-squares"><a class="reference internal" href="../generated/sklearn.linear_model.linearregression/#sklearn.linear_model.LinearRegression" title="sklearn.linear_model.LinearRegression"><code>LinearRegression</code></a> fits a linear model with coefficients <img class="math" src="http://scikit-learn.org/stable/_images/math/872414c3660f264ddafc518783bd27a3a18ff486.png" alt="w = (w_1, ..., w_p)"> to minimize the residual sum of squares between the observed responses in the dataset, and the responses predicted by the linear approximation. Mathematically it solves a problem of the form:</p> <div class="math"> <p><img src="http://scikit-learn.org/stable/_images/math/e8e92a5482d9327d939e7a17946a8a1b98006018.png" alt="\underset{w}{min\,} {|| X w - y||_2}^2"></p> </div>
<div class="figure align-center"> <a class="reference external image-reference" href="../../auto_examples/linear_model/plot_ols/"><img alt="../_images/sphx_glr_plot_ols_0011.png" src="http://scikit-learn.org/stable/_images/sphx_glr_plot_ols_0011.png" style="width: 400.0px; height: 300.0px;"></a> </div> <p><a class="reference internal" href="../generated/sklearn.linear_model.linearregression/#sklearn.linear_model.LinearRegression" title="sklearn.linear_model.LinearRegression"><code>LinearRegression</code></a> will take in its <code>fit</code> method arrays X, y and will store the coefficients <img class="math" src="http://scikit-learn.org/stable/_images/math/ecd1ee2a1cd226b40c37e079aca62398d4b774f5.png" alt="w"> of the linear model in its <code>coef_</code> member:</p> <pre data-language="python">&gt;&gt;&gt; from sklearn import linear_model
&gt;&gt;&gt; reg = linear_model.LinearRegression()
&gt;&gt;&gt; reg.fit ([[0, 0], [1, 1], [2, 2]], [0, 1, 2])
LinearRegression(copy_X=True, fit_intercept=True, n_jobs=1, normalize=False)
&gt;&gt;&gt; reg.coef_
array([ 0.5,  0.5])
</pre> <p>However, coefficient estimates for Ordinary Least Squares rely on the independence of the model terms. When terms are correlated and the columns of the design matrix <img class="math" src="http://scikit-learn.org/stable/_images/math/7a7bb470119808e2db2879fc2b2526f467b7a40b.png" alt="X"> have an approximate linear dependence, the design matrix becomes close to singular and as a result, the least-squares estimate becomes highly sensitive to random errors in the observed response, producing a large variance. This situation of <em>multicollinearity</em> can arise, for example, when data are collected without an experimental design.</p> <div class="topic"> <p class="topic-title first">Examples:</p> <ul class="simple"> <li><a class="reference internal" href="../../auto_examples/linear_model/plot_ols/#sphx-glr-auto-examples-linear-model-plot-ols-py"><span class="std std-ref">Linear Regression Example</span></a></li> </ul> </div>  <h3 id="ordinary-least-squares-complexity">1.1.1.1. Ordinary Least Squares Complexity</h3> <p>This method computes the least squares solution using a singular value decomposition of X. If X is a matrix of size (n, p) this method has a cost of <img class="math" src="http://scikit-learn.org/stable/_images/math/ed6ddbbf57a29a1b9e7a4afd3898df76d7cff16e.png" alt="O(n p^2)">, assuming that <img class="math" src="http://scikit-learn.org/stable/_images/math/06403bebf610a3c6eb454c503158c34977a418f0.png" alt="n \geq p">.</p>    <h2 id="id2">1.1.2. Ridge Regression</h2> <p id="ridge-regression"><a class="reference internal" href="../generated/sklearn.linear_model.ridge/#sklearn.linear_model.Ridge" title="sklearn.linear_model.Ridge"><code>Ridge</code></a> regression addresses some of the problems of <a class="reference internal" href="#ordinary-least-squares"><span class="std std-ref">Ordinary Least Squares</span></a> by imposing a penalty on the size of coefficients. The ridge coefficients minimize a penalized residual sum of squares,</p> <div class="math"> <p><img src="http://scikit-learn.org/stable/_images/math/48dbdad39c89539c714a825c0c0d5524eb526851.png" alt="\underset{w}{min\,} {{|| X w - y||_2}^2 + \alpha {||w||_2}^2}"></p> </div>
<p>Here, <img class="math" src="http://scikit-learn.org/stable/_images/math/48196aec5f482605914f9498015d86600e59c0d9.png" alt="\alpha \geq 0"> is a complexity parameter that controls the amount of shrinkage: the larger the value of <img class="math" src="http://scikit-learn.org/stable/_images/math/877d234f4cec6974ce218fc2e975a486a7972dfd.png" alt="\alpha">, the greater the amount of shrinkage and thus the coefficients become more robust to collinearity.</p> <div class="figure align-center"> <a class="reference external image-reference" href="../../auto_examples/linear_model/plot_ridge_path/"><img alt="../_images/sphx_glr_plot_ridge_path_0011.png" src="http://scikit-learn.org/stable/_images/sphx_glr_plot_ridge_path_0011.png" style="width: 400.0px; height: 300.0px;"></a> </div> <p>As with other linear models, <a class="reference internal" href="../generated/sklearn.linear_model.ridge/#sklearn.linear_model.Ridge" title="sklearn.linear_model.Ridge"><code>Ridge</code></a> will take in its <code>fit</code> method arrays X, y and will store the coefficients <img class="math" src="http://scikit-learn.org/stable/_images/math/ecd1ee2a1cd226b40c37e079aca62398d4b774f5.png" alt="w"> of the linear model in its <code>coef_</code> member:</p> <pre data-language="python">&gt;&gt;&gt; from sklearn import linear_model
&gt;&gt;&gt; reg = linear_model.Ridge (alpha = .5)
&gt;&gt;&gt; reg.fit ([[0, 0], [0, 0], [1, 1]], [0, .1, 1]) 
Ridge(alpha=0.5, copy_X=True, fit_intercept=True, max_iter=None,
      normalize=False, random_state=None, solver='auto', tol=0.001)
&gt;&gt;&gt; reg.coef_
array([ 0.34545455,  0.34545455])
&gt;&gt;&gt; reg.intercept_ 
0.13636...
</pre> <div class="topic"> <p class="topic-title first">Examples:</p> <ul class="simple"> <li><a class="reference internal" href="../../auto_examples/linear_model/plot_ridge_path/#sphx-glr-auto-examples-linear-model-plot-ridge-path-py"><span class="std std-ref">Plot Ridge coefficients as a function of the regularization</span></a></li> <li><a class="reference internal" href="../../auto_examples/text/document_classification_20newsgroups/#sphx-glr-auto-examples-text-document-classification-20newsgroups-py"><span class="std std-ref">Classification of text documents using sparse features</span></a></li> </ul> </div>  <h3 id="ridge-complexity">1.1.2.1. Ridge Complexity</h3> <p>This method has the same order of complexity than an <a class="reference internal" href="#ordinary-least-squares"><span class="std std-ref">Ordinary Least Squares</span></a>.</p>   <h3 id="setting-the-regularization-parameter-generalized-cross-validation">1.1.2.2. Setting the regularization parameter: generalized Cross-Validation</h3> <p><a class="reference internal" href="../generated/sklearn.linear_model.ridgecv/#sklearn.linear_model.RidgeCV" title="sklearn.linear_model.RidgeCV"><code>RidgeCV</code></a> implements ridge regression with built-in cross-validation of the alpha parameter. The object works in the same way as GridSearchCV except that it defaults to Generalized Cross-Validation (GCV), an efficient form of leave-one-out cross-validation:</p> <pre data-language="python">&gt;&gt;&gt; from sklearn import linear_model
&gt;&gt;&gt; reg = linear_model.RidgeCV(alphas=[0.1, 1.0, 10.0])
&gt;&gt;&gt; reg.fit([[0, 0], [0, 0], [1, 1]], [0, .1, 1])       
RidgeCV(alphas=[0.1, 1.0, 10.0], cv=None, fit_intercept=True, scoring=None,
    normalize=False)
&gt;&gt;&gt; reg.alpha_                                      
0.1
</pre> <div class="topic"> <p class="topic-title first">References</p> <ul class="simple"> <li>“Notes on Regularized Least Squares”, Rifkin &amp; Lippert (<a class="reference external" href="http://cbcl.mit.edu/projects/cbcl/publications/ps/MIT-CSAIL-TR-2007-025.pdf" target="_blank">technical report</a>, <a class="reference external" href="http://www.mit.edu/~9.520/spring07/Classes/rlsslides.pdf" target="_blank">course slides</a>).</li> </ul> </div>    <h2 id="id3">1.1.3. Lasso</h2> <p id="lasso">The <a class="reference internal" href="../generated/sklearn.linear_model.lasso/#sklearn.linear_model.Lasso" title="sklearn.linear_model.Lasso"><code>Lasso</code></a> is a linear model that estimates sparse coefficients. It is useful in some contexts due to its tendency to prefer solutions with fewer parameter values, effectively reducing the number of variables upon which the given solution is dependent. For this reason, the Lasso and its variants are fundamental to the field of compressed sensing. Under certain conditions, it can recover the exact set of non-zero weights (see <a class="reference internal" href="../../auto_examples/applications/plot_tomography_l1_reconstruction/#sphx-glr-auto-examples-applications-plot-tomography-l1-reconstruction-py"><span class="std std-ref">Compressive sensing: tomography reconstruction with L1 prior (Lasso)</span></a>).</p> <p>Mathematically, it consists of a linear model trained with <img class="math" src="http://scikit-learn.org/stable/_images/math/a301afaec3a8e4e639ad1d14140c7c5470a8eef2.png" alt="\ell_1"> prior as regularizer. The objective function to minimize is:</p> <div class="math"> <p><img src="http://scikit-learn.org/stable/_images/math/07c30d8004d4406105b2547be4f3050048531656.png" alt="\underset{w}{min\,} { \frac{1}{2n_{samples}} ||X w - y||_2 ^ 2 + \alpha ||w||_1}"></p> </div>
<p>The lasso estimate thus solves the minimization of the least-squares penalty with <img class="math" src="http://scikit-learn.org/stable/_images/math/7f5743fd8d7d5f38ac1c1b69264a46a7db7c5ef8.png" alt="\alpha ||w||_1"> added, where <img class="math" src="http://scikit-learn.org/stable/_images/math/877d234f4cec6974ce218fc2e975a486a7972dfd.png" alt="\alpha"> is a constant and <img class="math" src="http://scikit-learn.org/stable/_images/math/99c2ab1cc7a9538a1f081f7391fa368fa6f25799.png" alt="||w||_1"> is the <img class="math" src="http://scikit-learn.org/stable/_images/math/a301afaec3a8e4e639ad1d14140c7c5470a8eef2.png" alt="\ell_1">-norm of the parameter vector.</p> <p>The implementation in the class <a class="reference internal" href="../generated/sklearn.linear_model.lasso/#sklearn.linear_model.Lasso" title="sklearn.linear_model.Lasso"><code>Lasso</code></a> uses coordinate descent as the algorithm to fit the coefficients. See <a class="reference internal" href="#least-angle-regression"><span class="std std-ref">Least Angle Regression</span></a> for another implementation:</p> <pre data-language="python">&gt;&gt;&gt; from sklearn import linear_model
&gt;&gt;&gt; reg = linear_model.Lasso(alpha = 0.1)
&gt;&gt;&gt; reg.fit([[0, 0], [1, 1]], [0, 1])
Lasso(alpha=0.1, copy_X=True, fit_intercept=True, max_iter=1000,
   normalize=False, positive=False, precompute=False, random_state=None,
   selection='cyclic', tol=0.0001, warm_start=False)
&gt;&gt;&gt; reg.predict([[1, 1]])
array([ 0.8])
</pre> <p>Also useful for lower-level tasks is the function <a class="reference internal" href="../generated/sklearn.linear_model.lasso_path/#sklearn.linear_model.lasso_path" title="sklearn.linear_model.lasso_path"><code>lasso_path</code></a> that computes the coefficients along the full path of possible values.</p> <div class="topic"> <p class="topic-title first">Examples:</p> <ul class="simple"> <li><a class="reference internal" href="../../auto_examples/linear_model/plot_lasso_and_elasticnet/#sphx-glr-auto-examples-linear-model-plot-lasso-and-elasticnet-py"><span class="std std-ref">Lasso and Elastic Net for Sparse Signals</span></a></li> <li><a class="reference internal" href="../../auto_examples/applications/plot_tomography_l1_reconstruction/#sphx-glr-auto-examples-applications-plot-tomography-l1-reconstruction-py"><span class="std std-ref">Compressive sensing: tomography reconstruction with L1 prior (Lasso)</span></a></li> </ul> </div> <div class="admonition note"> <p class="first admonition-title">Note</p> <p><strong>Feature selection with Lasso</strong></p> <p class="last">As the Lasso regression yields sparse models, it can thus be used to perform feature selection, as detailed in <a class="reference internal" href="../feature_selection/#l1-feature-selection"><span class="std std-ref">L1-based feature selection</span></a>.</p> </div> <div class="admonition note"> <p class="first admonition-title">Note</p> <p><strong>Randomized sparsity</strong></p> <p class="last">For feature selection or sparse recovery, it may be interesting to use <a class="reference internal" href="../feature_selection/#randomized-l1"><span class="std std-ref">Randomized sparse models</span></a>.</p> </div>  <h3 id="setting-regularization-parameter">1.1.3.1. Setting regularization parameter</h3> <p>The <code>alpha</code> parameter controls the degree of sparsity of the coefficients estimated.</p>  <h4 id="using-cross-validation">1.1.3.1.1. Using cross-validation</h4> <p>scikit-learn exposes objects that set the Lasso <code>alpha</code> parameter by cross-validation: <a class="reference internal" href="../generated/sklearn.linear_model.lassocv/#sklearn.linear_model.LassoCV" title="sklearn.linear_model.LassoCV"><code>LassoCV</code></a> and <a class="reference internal" href="../generated/sklearn.linear_model.lassolarscv/#sklearn.linear_model.LassoLarsCV" title="sklearn.linear_model.LassoLarsCV"><code>LassoLarsCV</code></a>. <a class="reference internal" href="../generated/sklearn.linear_model.lassolarscv/#sklearn.linear_model.LassoLarsCV" title="sklearn.linear_model.LassoLarsCV"><code>LassoLarsCV</code></a> is based on the <a class="reference internal" href="#least-angle-regression"><span class="std std-ref">Least Angle Regression</span></a> algorithm explained below.</p> <p>For high-dimensional datasets with many collinear regressors, <a class="reference internal" href="../generated/sklearn.linear_model.lassocv/#sklearn.linear_model.LassoCV" title="sklearn.linear_model.LassoCV"><code>LassoCV</code></a> is most often preferable. However, <a class="reference internal" href="../generated/sklearn.linear_model.lassolarscv/#sklearn.linear_model.LassoLarsCV" title="sklearn.linear_model.LassoLarsCV"><code>LassoLarsCV</code></a> has the advantage of exploring more relevant values of <code>alpha</code> parameter, and if the number of samples is very small compared to the number of observations, it is often faster than <a class="reference internal" href="../generated/sklearn.linear_model.lassocv/#sklearn.linear_model.LassoCV" title="sklearn.linear_model.LassoCV"><code>LassoCV</code></a>.</p> <p class="centered"> <strong><a class="reference external" href="../../auto_examples/linear_model/plot_lasso_model_selection/"><img alt="lasso_cv_1" src="http://scikit-learn.org/stable/_images/sphx_glr_plot_lasso_model_selection_0021.png" style="width: 384.0px; height: 288.0px;"></a> <a class="reference external" href="../../auto_examples/linear_model/plot_lasso_model_selection/"><img alt="lasso_cv_2" src="http://scikit-learn.org/stable/_images/sphx_glr_plot_lasso_model_selection_0031.png" style="width: 384.0px; height: 288.0px;"></a></strong></p>  <h4 id="information-criteria-based-model-selection">1.1.3.1.2. Information-criteria based model selection</h4> <p>Alternatively, the estimator <a class="reference internal" href="../generated/sklearn.linear_model.lassolarsic/#sklearn.linear_model.LassoLarsIC" title="sklearn.linear_model.LassoLarsIC"><code>LassoLarsIC</code></a> proposes to use the Akaike information criterion (AIC) and the Bayes Information criterion (BIC). It is a computationally cheaper alternative to find the optimal value of alpha as the regularization path is computed only once instead of k+1 times when using k-fold cross-validation. However, such criteria needs a proper estimation of the degrees of freedom of the solution, are derived for large samples (asymptotic results) and assume the model is correct, i.e. that the data are actually generated by this model. They also tend to break when the problem is badly conditioned (more features than samples).</p> <div class="figure align-center"> <a class="reference external image-reference" href="../../auto_examples/linear_model/plot_lasso_model_selection/"><img alt="../_images/sphx_glr_plot_lasso_model_selection_0011.png" src="http://scikit-learn.org/stable/_images/sphx_glr_plot_lasso_model_selection_0011.png" style="width: 400.0px; height: 300.0px;"></a> </div> <div class="topic"> <p class="topic-title first">Examples:</p> <ul class="simple"> <li><a class="reference internal" href="../../auto_examples/linear_model/plot_lasso_model_selection/#sphx-glr-auto-examples-linear-model-plot-lasso-model-selection-py"><span class="std std-ref">Lasso model selection: Cross-Validation / AIC / BIC</span></a></li> </ul> </div>     <h2 id="id4">1.1.4. Multi-task Lasso</h2> <p id="multi-task-lasso">The <a class="reference internal" href="../generated/sklearn.linear_model.multitasklasso/#sklearn.linear_model.MultiTaskLasso" title="sklearn.linear_model.MultiTaskLasso"><code>MultiTaskLasso</code></a> is a linear model that estimates sparse coefficients for multiple regression problems jointly: <code>y</code> is a 2D array, of shape <code>(n_samples, n_tasks)</code>. The constraint is that the selected features are the same for all the regression problems, also called tasks.</p> <p>The following figure compares the location of the non-zeros in W obtained with a simple Lasso or a MultiTaskLasso. The Lasso estimates yields scattered non-zeros while the non-zeros of the MultiTaskLasso are full columns.</p> <p class="centered"> <strong><a class="reference external" href="../../auto_examples/linear_model/plot_multi_task_lasso_support/"><img alt="multi_task_lasso_1" src="http://scikit-learn.org/stable/_images/sphx_glr_plot_multi_task_lasso_support_0011.png" style="width: 384.0px; height: 240.0px;"></a> <a class="reference external" href="../../auto_examples/linear_model/plot_multi_task_lasso_support/"><img alt="multi_task_lasso_2" src="http://scikit-learn.org/stable/_images/sphx_glr_plot_multi_task_lasso_support_0021.png" style="width: 384.0px; height: 288.0px;"></a></strong></p>
<p class="centered"> <strong>Fitting a time-series model, imposing that any active feature be active at all times.</strong></p>
<div class="topic"> <p class="topic-title first">Examples:</p> <ul class="simple"> <li><a class="reference internal" href="../../auto_examples/linear_model/plot_multi_task_lasso_support/#sphx-glr-auto-examples-linear-model-plot-multi-task-lasso-support-py"><span class="std std-ref">Joint feature selection with multi-task Lasso</span></a></li> </ul> </div> <p>Mathematically, it consists of a linear model trained with a mixed <img class="math" src="http://scikit-learn.org/stable/_images/math/a301afaec3a8e4e639ad1d14140c7c5470a8eef2.png" alt="\ell_1"> <img class="math" src="http://scikit-learn.org/stable/_images/math/4cdcdbcd7242f4bc56b5900649a2839bc9689fef.png" alt="\ell_2"> prior as regularizer. The objective function to minimize is:</p> <div class="math"> <p><img src="http://scikit-learn.org/stable/_images/math/fb8862ba8a0bbd86df74a2d45e115042abaaf337.png" alt="\underset{w}{min\,} { \frac{1}{2n_{samples}} ||X W - Y||_{Fro} ^ 2 + \alpha ||W||_{21}}"></p> </div>
<p>where <img class="math" src="http://scikit-learn.org/stable/_images/math/86f8a2f1cc06338a5c5a9211184a8ce6e87bbd76.png" alt="Fro"> indicates the Frobenius norm:</p> <div class="math"> <p><img src="http://scikit-learn.org/stable/_images/math/ab1b1502d6ca4bf16f01209e3b0a37593249271f.png" alt="||A||_{Fro} = \sqrt{\sum_{ij} a_{ij}^2}"></p> </div>
<p>and <img class="math" src="http://scikit-learn.org/stable/_images/math/a301afaec3a8e4e639ad1d14140c7c5470a8eef2.png" alt="\ell_1"> <img class="math" src="http://scikit-learn.org/stable/_images/math/4cdcdbcd7242f4bc56b5900649a2839bc9689fef.png" alt="\ell_2"> reads:</p> <div class="math"> <p><img src="http://scikit-learn.org/stable/_images/math/95a01d8b63169b1769176434fe57ec5a02e43b0d.png" alt="||A||_{2 1} = \sum_i \sqrt{\sum_j a_{ij}^2}"></p> </div>
<p>The implementation in the class <a class="reference internal" href="../generated/sklearn.linear_model.multitasklasso/#sklearn.linear_model.MultiTaskLasso" title="sklearn.linear_model.MultiTaskLasso"><code>MultiTaskLasso</code></a> uses coordinate descent as the algorithm to fit the coefficients.</p>   <h2 id="id5">1.1.5. Elastic Net</h2> <p id="elastic-net"><a class="reference internal" href="../generated/sklearn.linear_model.elasticnet/#sklearn.linear_model.ElasticNet" title="sklearn.linear_model.ElasticNet"><code>ElasticNet</code></a> is a linear regression model trained with L1 and L2 prior as regularizer. This combination allows for learning a sparse model where few of the weights are non-zero like <a class="reference internal" href="../generated/sklearn.linear_model.lasso/#sklearn.linear_model.Lasso" title="sklearn.linear_model.Lasso"><code>Lasso</code></a>, while still maintaining the regularization properties of <a class="reference internal" href="../generated/sklearn.linear_model.ridge/#sklearn.linear_model.Ridge" title="sklearn.linear_model.Ridge"><code>Ridge</code></a>. We control the convex combination of L1 and L2 using the <code>l1_ratio</code> parameter.</p> <p>Elastic-net is useful when there are multiple features which are correlated with one another. Lasso is likely to pick one of these at random, while elastic-net is likely to pick both.</p> <p>A practical advantage of trading-off between Lasso and Ridge is it allows Elastic-Net to inherit some of Ridge’s stability under rotation.</p> <p>The objective function to minimize is in this case</p> <div class="math"> <p><img src="http://scikit-learn.org/stable/_images/math/51443eb62398fc5253e0a0d06a5695686e972d08.png" alt="\underset{w}{min\,} { \frac{1}{2n_{samples}} ||X w - y||_2 ^ 2 + \alpha \rho ||w||_1 +
\frac{\alpha(1-\rho)}{2} ||w||_2 ^ 2}"></p> </div>
<div class="figure align-center"> <a class="reference external image-reference" href="../../auto_examples/linear_model/plot_lasso_coordinate_descent_path/"><img alt="../_images/sphx_glr_plot_lasso_coordinate_descent_path_0011.png" src="http://scikit-learn.org/stable/_images/sphx_glr_plot_lasso_coordinate_descent_path_0011.png" style="width: 400.0px; height: 300.0px;"></a> </div> <p>The class <a class="reference internal" href="../generated/sklearn.linear_model.elasticnetcv/#sklearn.linear_model.ElasticNetCV" title="sklearn.linear_model.ElasticNetCV"><code>ElasticNetCV</code></a> can be used to set the parameters <code>alpha</code> (<img class="math" src="http://scikit-learn.org/stable/_images/math/877d234f4cec6974ce218fc2e975a486a7972dfd.png" alt="\alpha">) and <code>l1_ratio</code> (<img class="math" src="http://scikit-learn.org/stable/_images/math/9a51ab9a0b521705e1e8762fac6bdd6f11771758.png" alt="\rho">) by cross-validation.</p> <div class="topic"> <p class="topic-title first">Examples:</p> <ul class="simple"> <li><a class="reference internal" href="../../auto_examples/linear_model/plot_lasso_and_elasticnet/#sphx-glr-auto-examples-linear-model-plot-lasso-and-elasticnet-py"><span class="std std-ref">Lasso and Elastic Net for Sparse Signals</span></a></li> <li><a class="reference internal" href="../../auto_examples/linear_model/plot_lasso_coordinate_descent_path/#sphx-glr-auto-examples-linear-model-plot-lasso-coordinate-descent-path-py"><span class="std std-ref">Lasso and Elastic Net</span></a></li> </ul> </div>   <h2 id="id6">1.1.6. Multi-task Elastic Net</h2> <p id="multi-task-elastic-net">The <a class="reference internal" href="../generated/sklearn.linear_model.multitaskelasticnet/#sklearn.linear_model.MultiTaskElasticNet" title="sklearn.linear_model.MultiTaskElasticNet"><code>MultiTaskElasticNet</code></a> is an elastic-net model that estimates sparse coefficients for multiple regression problems jointly: <code>Y</code> is a 2D array, of shape <code>(n_samples, n_tasks)</code>. The constraint is that the selected features are the same for all the regression problems, also called tasks.</p> <p>Mathematically, it consists of a linear model trained with a mixed <img class="math" src="http://scikit-learn.org/stable/_images/math/a301afaec3a8e4e639ad1d14140c7c5470a8eef2.png" alt="\ell_1"> <img class="math" src="http://scikit-learn.org/stable/_images/math/4cdcdbcd7242f4bc56b5900649a2839bc9689fef.png" alt="\ell_2"> prior and <img class="math" src="http://scikit-learn.org/stable/_images/math/4cdcdbcd7242f4bc56b5900649a2839bc9689fef.png" alt="\ell_2"> prior as regularizer. The objective function to minimize is:</p> <div class="math"> <p><img src="http://scikit-learn.org/stable/_images/math/a0ef45ea26ee66211e7a17d2192da2a21e2ce714.png" alt="\underset{W}{min\,} { \frac{1}{2n_{samples}} ||X W - Y||_{Fro}^2 + \alpha \rho ||W||_{2 1} +
\frac{\alpha(1-\rho)}{2} ||W||_{Fro}^2}"></p> </div>
<p>The implementation in the class <a class="reference internal" href="../generated/sklearn.linear_model.multitaskelasticnet/#sklearn.linear_model.MultiTaskElasticNet" title="sklearn.linear_model.MultiTaskElasticNet"><code>MultiTaskElasticNet</code></a> uses coordinate descent as the algorithm to fit the coefficients.</p> <p>The class <a class="reference internal" href="../generated/sklearn.linear_model.multitaskelasticnetcv/#sklearn.linear_model.MultiTaskElasticNetCV" title="sklearn.linear_model.MultiTaskElasticNetCV"><code>MultiTaskElasticNetCV</code></a> can be used to set the parameters <code>alpha</code> (<img class="math" src="http://scikit-learn.org/stable/_images/math/877d234f4cec6974ce218fc2e975a486a7972dfd.png" alt="\alpha">) and <code>l1_ratio</code> (<img class="math" src="http://scikit-learn.org/stable/_images/math/9a51ab9a0b521705e1e8762fac6bdd6f11771758.png" alt="\rho">) by cross-validation.</p>   <h2 id="id7">1.1.7. Least Angle Regression</h2> <p id="least-angle-regression">Least-angle regression (LARS) is a regression algorithm for high-dimensional data, developed by Bradley Efron, Trevor Hastie, Iain Johnstone and Robert Tibshirani.</p> <p>The advantages of LARS are:</p>  <ul class="simple"> <li>It is numerically efficient in contexts where p &gt;&gt; n (i.e., when the number of dimensions is significantly greater than the number of points)</li> <li>It is computationally just as fast as forward selection and has the same order of complexity as an ordinary least squares.</li> <li>It produces a full piecewise linear solution path, which is useful in cross-validation or similar attempts to tune the model.</li> <li>If two variables are almost equally correlated with the response, then their coefficients should increase at approximately the same rate. The algorithm thus behaves as intuition would expect, and also is more stable.</li> <li>It is easily modified to produce solutions for other estimators, like the Lasso.</li> </ul>  <p>The disadvantages of the LARS method include:</p>  <ul class="simple"> <li>Because LARS is based upon an iterative refitting of the residuals, it would appear to be especially sensitive to the effects of noise. This problem is discussed in detail by Weisberg in the discussion section of the Efron et al. (2004) Annals of Statistics article.</li> </ul>  <p>The LARS model can be used using estimator <a class="reference internal" href="../generated/sklearn.linear_model.lars/#sklearn.linear_model.Lars" title="sklearn.linear_model.Lars"><code>Lars</code></a>, or its low-level implementation <a class="reference internal" href="../generated/sklearn.linear_model.lars_path/#sklearn.linear_model.lars_path" title="sklearn.linear_model.lars_path"><code>lars_path</code></a>.</p>   <h2 id="lars-lasso">1.1.8. LARS Lasso</h2> <p><a class="reference internal" href="../generated/sklearn.linear_model.lassolars/#sklearn.linear_model.LassoLars" title="sklearn.linear_model.LassoLars"><code>LassoLars</code></a> is a lasso model implemented using the LARS algorithm, and unlike the implementation based on coordinate_descent, this yields the exact solution, which is piecewise linear as a function of the norm of its coefficients.</p> <div class="figure align-center"> <a class="reference external image-reference" href="../../auto_examples/linear_model/plot_lasso_lars/"><img alt="../_images/sphx_glr_plot_lasso_lars_0011.png" src="http://scikit-learn.org/stable/_images/sphx_glr_plot_lasso_lars_0011.png" style="width: 400.0px; height: 300.0px;"></a> </div> <pre data-language="python">&gt;&gt;&gt; from sklearn import linear_model
&gt;&gt;&gt; reg = linear_model.LassoLars(alpha=.1)
&gt;&gt;&gt; reg.fit([[0, 0], [1, 1]], [0, 1])  
LassoLars(alpha=0.1, copy_X=True, eps=..., fit_intercept=True,
     fit_path=True, max_iter=500, normalize=True, positive=False,
     precompute='auto', verbose=False)
&gt;&gt;&gt; reg.coef_    
array([ 0.717157...,  0.        ])
</pre> <div class="topic"> <p class="topic-title first">Examples:</p> <ul class="simple"> <li><a class="reference internal" href="../../auto_examples/linear_model/plot_lasso_lars/#sphx-glr-auto-examples-linear-model-plot-lasso-lars-py"><span class="std std-ref">Lasso path using LARS</span></a></li> </ul> </div> <p>The Lars algorithm provides the full path of the coefficients along the regularization parameter almost for free, thus a common operation consist of retrieving the path with function <a class="reference internal" href="../generated/sklearn.linear_model.lars_path/#sklearn.linear_model.lars_path" title="sklearn.linear_model.lars_path"><code>lars_path</code></a></p>  <h3 id="mathematical-formulation">1.1.8.1. Mathematical formulation</h3> <p>The algorithm is similar to forward stepwise regression, but instead of including variables at each step, the estimated parameters are increased in a direction equiangular to each one’s correlations with the residual.</p> <p>Instead of giving a vector result, the LARS solution consists of a curve denoting the solution for each value of the L1 norm of the parameter vector. The full coefficients path is stored in the array <code>coef_path_</code>, which has size (n_features, max_features+1). The first column is always zero.</p> <div class="topic"> <p class="topic-title first">References:</p> <ul class="simple"> <li>Original Algorithm is detailed in the paper <a class="reference external" href="http://www-stat.stanford.edu/~hastie/Papers/LARS/LeastAngle_2002.pdf" target="_blank">Least Angle Regression</a> by Hastie et al.</li> </ul> </div>    <h2 id="omp">1.1.9. Orthogonal Matching Pursuit (OMP)</h2> <p id="orthogonal-matching-pursuit-omp"><a class="reference internal" href="../generated/sklearn.linear_model.orthogonalmatchingpursuit/#sklearn.linear_model.OrthogonalMatchingPursuit" title="sklearn.linear_model.OrthogonalMatchingPursuit"><code>OrthogonalMatchingPursuit</code></a> and <a class="reference internal" href="../generated/sklearn.linear_model.orthogonal_mp/#sklearn.linear_model.orthogonal_mp" title="sklearn.linear_model.orthogonal_mp"><code>orthogonal_mp</code></a> implements the OMP algorithm for approximating the fit of a linear model with constraints imposed on the number of non-zero coefficients (ie. the L <sub>0</sub> pseudo-norm).</p> <p>Being a forward feature selection method like <a class="reference internal" href="#least-angle-regression"><span class="std std-ref">Least Angle Regression</span></a>, orthogonal matching pursuit can approximate the optimum solution vector with a fixed number of non-zero elements:</p> <div class="math"> <p><img src="http://scikit-learn.org/stable/_images/math/a4acdafd29eec35831ca225d906e7691941d9567.png" alt="\text{arg\,min\,} ||y - X\gamma||_2^2 \text{ subject to } \
||\gamma||_0 \leq n_{nonzero\_coefs}"></p> </div>
<p>Alternatively, orthogonal matching pursuit can target a specific error instead of a specific number of non-zero coefficients. This can be expressed as:</p> <div class="math"> <p><img src="http://scikit-learn.org/stable/_images/math/c6ed31043514c4aa6af8b14f9a6d51d162fed543.png" alt="\text{arg\,min\,} ||\gamma||_0 \text{ subject to } ||y-X\gamma||_2^2 \
\leq \text{tol}"></p> </div>
<p>OMP is based on a greedy algorithm that includes at each step the atom most highly correlated with the current residual. It is similar to the simpler matching pursuit (MP) method, but better in that at each iteration, the residual is recomputed using an orthogonal projection on the space of the previously chosen dictionary elements.</p> <div class="topic"> <p class="topic-title first">Examples:</p> <ul class="simple"> <li><a class="reference internal" href="../../auto_examples/linear_model/plot_omp/#sphx-glr-auto-examples-linear-model-plot-omp-py"><span class="std std-ref">Orthogonal Matching Pursuit</span></a></li> </ul> </div> <div class="topic"> <p class="topic-title first">References:</p> <ul class="simple"> <li><a class="reference external" href="http://www.cs.technion.ac.il/~ronrubin/Publications/KSVD-OMP-v2.pdf" target="_blank">http://www.cs.technion.ac.il/~ronrubin/Publications/KSVD-OMP-v2.pdf</a></li> <li>
<a class="reference external" href="http://blanche.polytechnique.fr/~mallat/papiers/MallatPursuit93.pdf" target="_blank">Matching pursuits with time-frequency dictionaries</a>, S. G. Mallat, Z. Zhang,</li> </ul> </div>   <h2 id="id9">1.1.10. Bayesian Regression</h2> <p id="bayesian-regression">Bayesian regression techniques can be used to include regularization parameters in the estimation procedure: the regularization parameter is not set in a hard sense but tuned to the data at hand.</p> <p>This can be done by introducing <a class="reference external" href="https://en.wikipedia.org/wiki/Non-informative_prior#Uninformative_priors" target="_blank">uninformative priors</a> over the hyper parameters of the model. The <img class="math" src="http://scikit-learn.org/stable/_images/math/f77f5b2c6971d3c72c400d10b87707edc1d7156d.png" alt="\ell_{2}"> regularization used in <a class="reference internal" href="#id2">Ridge Regression</a> is equivalent to finding a maximum a-postiori solution under a Gaussian prior over the parameters <img class="math" src="http://scikit-learn.org/stable/_images/math/ecd1ee2a1cd226b40c37e079aca62398d4b774f5.png" alt="w"> with precision <img class="math" src="http://scikit-learn.org/stable/_images/math/8d9c0a8849bc58486d5c91815dea17d26b0c8305.png" alt="\lambda^-1">. Instead of setting <code>lambda</code> manually, it is possible to treat it as a random variable to be estimated from the data.</p> <p>To obtain a fully probabilistic model, the output <img class="math" src="http://scikit-learn.org/stable/_images/math/276f7e256cbddeb81eee42e1efc348f3cb4ab5f8.png" alt="y"> is assumed to be Gaussian distributed around <img class="math" src="http://scikit-learn.org/stable/_images/math/4dc06edd94309641af4846043fe7c7b650e40037.png" alt="X w">:</p> <div class="math"> <p><img src="http://scikit-learn.org/stable/_images/math/f478d5b226c02754ede31ce247d4d9870ff7c416.png" alt="p(y|X,w,\alpha) = \mathcal{N}(y|X w,\alpha)"></p> </div>
<p>Alpha is again treated as a random variable that is to be estimated from the data.</p> <p>The advantages of Bayesian Regression are:</p>  <ul class="simple"> <li>It adapts to the data at hand.</li> <li>It can be used to include regularization parameters in the estimation procedure.</li> </ul>  <p>The disadvantages of Bayesian regression include:</p>  <ul class="simple"> <li>Inference of the model can be time consuming.</li> </ul>  <div class="topic"> <p class="topic-title first">References</p> <ul class="simple"> <li>A good introduction to Bayesian methods is given in C. Bishop: Pattern Recognition and Machine learning</li> <li>Original Algorithm is detailed in the book <code>Bayesian learning for neural networks</code> by Radford M. Neal</li> </ul> </div>  <h3 id="id10">1.1.10.1. Bayesian Ridge Regression</h3> <p id="bayesian-ridge-regression"><a class="reference internal" href="../generated/sklearn.linear_model.bayesianridge/#sklearn.linear_model.BayesianRidge" title="sklearn.linear_model.BayesianRidge"><code>BayesianRidge</code></a> estimates a probabilistic model of the regression problem as described above. The prior for the parameter <img class="math" src="http://scikit-learn.org/stable/_images/math/ecd1ee2a1cd226b40c37e079aca62398d4b774f5.png" alt="w"> is given by a spherical Gaussian:</p> <div class="math"> <p><img src="http://scikit-learn.org/stable/_images/math/ebf24e7f03ce757cbfab29367628715eb161fc38.png" alt="p(w|\lambda) =
\mathcal{N}(w|0,\lambda^{-1}\bold{I_{p}})"></p> </div>
<p>The priors over <img class="math" src="http://scikit-learn.org/stable/_images/math/877d234f4cec6974ce218fc2e975a486a7972dfd.png" alt="\alpha"> and <img class="math" src="http://scikit-learn.org/stable/_images/math/76f1d8ace30435987c01a00ca53a71cba1f40e6c.png" alt="\lambda"> are chosen to be <a class="reference external" href="https://en.wikipedia.org/wiki/Gamma_distribution" target="_blank">gamma distributions</a>, the conjugate prior for the precision of the Gaussian.</p> <p>The resulting model is called <em>Bayesian Ridge Regression</em>, and is similar to the classical <a class="reference internal" href="../generated/sklearn.linear_model.ridge/#sklearn.linear_model.Ridge" title="sklearn.linear_model.Ridge"><code>Ridge</code></a>. The parameters <img class="math" src="http://scikit-learn.org/stable/_images/math/ecd1ee2a1cd226b40c37e079aca62398d4b774f5.png" alt="w">, <img class="math" src="http://scikit-learn.org/stable/_images/math/877d234f4cec6974ce218fc2e975a486a7972dfd.png" alt="\alpha"> and <img class="math" src="http://scikit-learn.org/stable/_images/math/76f1d8ace30435987c01a00ca53a71cba1f40e6c.png" alt="\lambda"> are estimated jointly during the fit of the model. The remaining hyperparameters are the parameters of the gamma priors over <img class="math" src="http://scikit-learn.org/stable/_images/math/877d234f4cec6974ce218fc2e975a486a7972dfd.png" alt="\alpha"> and <img class="math" src="http://scikit-learn.org/stable/_images/math/76f1d8ace30435987c01a00ca53a71cba1f40e6c.png" alt="\lambda">. These are usually chosen to be <em>non-informative</em>. The parameters are estimated by maximizing the <em>marginal log likelihood</em>.</p> <p>By default <img class="math" src="http://scikit-learn.org/stable/_images/math/7829d1ebb16b37fd70914438ea291a9b3e216296.png" alt="\alpha_1 = \alpha_2 =  \lambda_1 = \lambda_2 = 1.e^{-6}">.</p> <div class="figure align-center"> <a class="reference external image-reference" href="../../auto_examples/linear_model/plot_bayesian_ridge/"><img alt="../_images/sphx_glr_plot_bayesian_ridge_0011.png" src="http://scikit-learn.org/stable/_images/sphx_glr_plot_bayesian_ridge_0011.png" style="width: 300.0px; height: 250.0px;"></a> </div> <p>Bayesian Ridge Regression is used for regression:</p> <pre data-language="python">&gt;&gt;&gt; from sklearn import linear_model
&gt;&gt;&gt; X = [[0., 0.], [1., 1.], [2., 2.], [3., 3.]]
&gt;&gt;&gt; Y = [0., 1., 2., 3.]
&gt;&gt;&gt; reg = linear_model.BayesianRidge()
&gt;&gt;&gt; reg.fit(X, Y)
BayesianRidge(alpha_1=1e-06, alpha_2=1e-06, compute_score=False, copy_X=True,
       fit_intercept=True, lambda_1=1e-06, lambda_2=1e-06, n_iter=300,
       normalize=False, tol=0.001, verbose=False)
</pre> <p>After being fitted, the model can then be used to predict new values:</p> <pre data-language="python">&gt;&gt;&gt; reg.predict ([[1, 0.]])
array([ 0.50000013])
</pre> <p>The weights <img class="math" src="http://scikit-learn.org/stable/_images/math/ecd1ee2a1cd226b40c37e079aca62398d4b774f5.png" alt="w"> of the model can be access:</p> <pre data-language="python">&gt;&gt;&gt; reg.coef_
array([ 0.49999993,  0.49999993])
</pre> <p>Due to the Bayesian framework, the weights found are slightly different to the ones found by <a class="reference internal" href="#ordinary-least-squares"><span class="std std-ref">Ordinary Least Squares</span></a>. However, Bayesian Ridge Regression is more robust to ill-posed problem.</p> <div class="topic"> <p class="topic-title first">Examples:</p> <ul class="simple"> <li><a class="reference internal" href="../../auto_examples/linear_model/plot_bayesian_ridge/#sphx-glr-auto-examples-linear-model-plot-bayesian-ridge-py"><span class="std std-ref">Bayesian Ridge Regression</span></a></li> </ul> </div> <div class="topic"> <p class="topic-title first">References</p> <ul class="simple"> <li>More details can be found in the article <a class="reference external" href="http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.27.9072&amp;rep=rep1&amp;type=pdf" target="_blank">Bayesian Interpolation</a> by MacKay, David J. C.</li> </ul> </div>   <h3 id="automatic-relevance-determination-ard">1.1.10.2. Automatic Relevance Determination - ARD</h3> <p><a class="reference internal" href="../generated/sklearn.linear_model.ardregression/#sklearn.linear_model.ARDRegression" title="sklearn.linear_model.ARDRegression"><code>ARDRegression</code></a> is very similar to <a class="reference internal" href="#id10">Bayesian Ridge Regression</a>, but can lead to sparser weights <img class="math" src="http://scikit-learn.org/stable/_images/math/ecd1ee2a1cd226b40c37e079aca62398d4b774f5.png" alt="w"> <a class="footnote-reference" href="#id15" id="id11">[1]</a> <a class="footnote-reference" href="#id16" id="id12">[2]</a>. <a class="reference internal" href="../generated/sklearn.linear_model.ardregression/#sklearn.linear_model.ARDRegression" title="sklearn.linear_model.ARDRegression"><code>ARDRegression</code></a> poses a different prior over <img class="math" src="http://scikit-learn.org/stable/_images/math/ecd1ee2a1cd226b40c37e079aca62398d4b774f5.png" alt="w">, by dropping the assumption of the Gaussian being spherical.</p> <p>Instead, the distribution over <img class="math" src="http://scikit-learn.org/stable/_images/math/ecd1ee2a1cd226b40c37e079aca62398d4b774f5.png" alt="w"> is assumed to be an axis-parallel, elliptical Gaussian distribution.</p> <p>This means each weight <img class="math" src="http://scikit-learn.org/stable/_images/math/8cef10bb133d7cb70cdf6433fc0cbef817b7b5aa.png" alt="w_{i}"> is drawn from a Gaussian distribution, centered on zero and with a precision <img class="math" src="http://scikit-learn.org/stable/_images/math/03fb95641efd224604d31e10ad0d43f2a1981cfe.png" alt="\lambda_{i}">:</p> <div class="math"> <p><img src="http://scikit-learn.org/stable/_images/math/e0dbb05b8bf9656ef6b32514010a9bfe514c9945.png" alt="p(w|\lambda) = \mathcal{N}(w|0,A^{-1})"></p> </div>
<p>with <img class="math" src="http://scikit-learn.org/stable/_images/math/149c8337ae0f9ffc3e3c6021f779738b650ae69f.png" alt="diag \; (A) = \lambda = \{\lambda_{1},...,\lambda_{p}\}">.</p> <p>In contrast to <a class="reference internal" href="#id10">Bayesian Ridge Regression</a>, each coordinate of <img class="math" src="http://scikit-learn.org/stable/_images/math/8cef10bb133d7cb70cdf6433fc0cbef817b7b5aa.png" alt="w_{i}"> has its own standard deviation <img class="math" src="http://scikit-learn.org/stable/_images/math/159e1bfcbbeedf7e28983ee80db2b2d37c3b3ebc.png" alt="\lambda_i">. The prior over all <img class="math" src="http://scikit-learn.org/stable/_images/math/159e1bfcbbeedf7e28983ee80db2b2d37c3b3ebc.png" alt="\lambda_i"> is chosen to be the same gamma distribution given by hyperparameters <img class="math" src="http://scikit-learn.org/stable/_images/math/a2c5c1af213db8e97bdaaf60c8fceab2faef8271.png" alt="\lambda_1"> and <img class="math" src="http://scikit-learn.org/stable/_images/math/6bf459c11ce1eb9a1bfa05d02185f322e796f5f4.png" alt="\lambda_2">.</p> <div class="figure align-center"> <a class="reference external image-reference" href="../../auto_examples/linear_model/plot_ard/"><img alt="../_images/sphx_glr_plot_ard_0011.png" src="http://scikit-learn.org/stable/_images/sphx_glr_plot_ard_0011.png" style="width: 300.0px; height: 250.0px;"></a> </div> <p>ARD is also known in the literature as <em>Sparse Bayesian Learning</em> and <em>Relevance Vector Machine</em> <a class="footnote-reference" href="#id17" id="id13">[3]</a> <a class="footnote-reference" href="#id18" id="id14">[4]</a>.</p> <div class="topic"> <p class="topic-title first">Examples:</p> <ul class="simple"> <li><a class="reference internal" href="../../auto_examples/linear_model/plot_ard/#sphx-glr-auto-examples-linear-model-plot-ard-py"><span class="std std-ref">Automatic Relevance Determination Regression (ARD)</span></a></li> </ul> </div> <div class="topic"> <p class="topic-title first">References:</p> <table class="docutils footnote" frame="void" id="id15" rules="none">   <tr>
<td class="label"><a class="fn-backref" href="#id11">[1]</a></td>
<td>Christopher M. Bishop: Pattern Recognition and Machine Learning, Chapter 7.2.1</td>
</tr>  </table> <table class="docutils footnote" frame="void" id="id16" rules="none">   <tr>
<td class="label"><a class="fn-backref" href="#id12">[2]</a></td>
<td>David Wipf and Srikantan Nagarajan: <a class="reference external" href="http://papers.nips.cc/paper/3372-a-new-view-of-automatic-relevance-determination.pdf" target="_blank">A new view of automatic relevance determination</a>
</td>
</tr>  </table> <table class="docutils footnote" frame="void" id="id17" rules="none">   <tr>
<td class="label"><a class="fn-backref" href="#id13">[3]</a></td>
<td>Michael E. Tipping: <a class="reference external" href="http://www.jmlr.org/papers/volume1/tipping01a/tipping01a.pdf" target="_blank">Sparse Bayesian Learning and the Relevance Vector Machine</a>
</td>
</tr>  </table> <table class="docutils footnote" frame="void" id="id18" rules="none">   <tr>
<td class="label"><a class="fn-backref" href="#id14">[4]</a></td>
<td>Tristan Fletcher: <a class="reference external" href="http://www.tristanfletcher.co.uk/RVM%20Explained.pdf" target="_blank">Relevance Vector Machines explained</a>
</td>
</tr>  </table> </div>    <h2 id="id19">1.1.11. Logistic regression</h2> <p id="logistic-regression">Logistic regression, despite its name, is a linear model for classification rather than regression. Logistic regression is also known in the literature as logit regression, maximum-entropy classification (MaxEnt) or the log-linear classifier. In this model, the probabilities describing the possible outcomes of a single trial are modeled using a <a class="reference external" href="https://en.wikipedia.org/wiki/Logistic_function" target="_blank">logistic function</a>.</p> <p>The implementation of logistic regression in scikit-learn can be accessed from class <a class="reference internal" href="../generated/sklearn.linear_model.logisticregression/#sklearn.linear_model.LogisticRegression" title="sklearn.linear_model.LogisticRegression"><code>LogisticRegression</code></a>. This implementation can fit binary, One-vs- Rest, or multinomial logistic regression with optional L2 or L1 regularization.</p> <p>As an optimization problem, binary class L2 penalized logistic regression minimizes the following cost function:</p> <div class="math"> <p><img src="http://scikit-learn.org/stable/_images/math/760c999ccbc78b72d2a91186ba55ce37f0d2cf37.png" alt="\underset{w, c}{min\,} \frac{1}{2}w^T w + C \sum_{i=1}^n \log(\exp(- y_i (X_i^T w + c)) + 1) ."></p> </div>
<p>Similarly, L1 regularized logistic regression solves the following optimization problem</p> <div class="math"> <p><img src="http://scikit-learn.org/stable/_images/math/6a0bcf21baaeb0c2b879ab74fe333c0aab0d6ae6.png" alt="\underset{w, c}{min\,} \|w\|_1 + C \sum_{i=1}^n \log(\exp(- y_i (X_i^T w + c)) + 1) ."></p> </div>
<p>The solvers implemented in the class <a class="reference internal" href="../generated/sklearn.linear_model.logisticregression/#sklearn.linear_model.LogisticRegression" title="sklearn.linear_model.LogisticRegression"><code>LogisticRegression</code></a> are “liblinear”, “newton-cg”, “lbfgs” and “sag”:</p> <p>The solver “liblinear” uses a coordinate descent (CD) algorithm, and relies on the excellent C++ <a class="reference external" href="http://www.csie.ntu.edu.tw/~cjlin/liblinear/" target="_blank">LIBLINEAR library</a>, which is shipped with scikit-learn. However, the CD algorithm implemented in liblinear cannot learn a true multinomial (multiclass) model; instead, the optimization problem is decomposed in a “one-vs-rest” fashion so separate binary classifiers are trained for all classes. This happens under the hood, so <a class="reference internal" href="../generated/sklearn.linear_model.logisticregression/#sklearn.linear_model.LogisticRegression" title="sklearn.linear_model.LogisticRegression"><code>LogisticRegression</code></a> instances using this solver behave as multiclass classifiers. For L1 penalization <a class="reference internal" href="../generated/sklearn.svm.l1_min_c/#sklearn.svm.l1_min_c" title="sklearn.svm.l1_min_c"><code>sklearn.svm.l1_min_c</code></a> allows to calculate the lower bound for C in order to get a non “null” (all feature weights to zero) model.</p> <p>The “lbfgs”, “sag” and “newton-cg” solvers only support L2 penalization and are found to converge faster for some high dimensional data. Setting <code>multi_class</code> to “multinomial” with these solvers learns a true multinomial logistic regression model <a class="footnote-reference" href="#id22" id="id20">[5]</a>, which means that its probability estimates should be better calibrated than the default “one-vs-rest” setting. The “lbfgs”, “sag” and “newton-cg”” solvers cannot optimize L1-penalized models, therefore the “multinomial” setting does not learn sparse models.</p> <p>The solver “sag” uses a Stochastic Average Gradient descent <a class="footnote-reference" href="#id23" id="id21">[6]</a>. It is faster than other solvers for large datasets, when both the number of samples and the number of features are large.</p> <p>In a nutshell, one may choose the solver with the following rules:</p> <table class="docutils">  <thead valign="bottom"> <tr class="row-odd">
<th class="head">Case</th> <th class="head">Solver</th> </tr> </thead>  <tr class="row-even">
<td>Small dataset or L1 penalty</td> <td>“liblinear”</td> </tr> <tr class="row-odd">
<td>Multinomial loss or large dataset</td> <td>“lbfgs”, “sag” or “newton-cg”</td> </tr> <tr class="row-even">
<td>Very Large dataset</td> <td>“sag”</td> </tr>  </table> <p>For large dataset, you may also consider using <a class="reference internal" href="../generated/sklearn.linear_model.sgdclassifier/#sklearn.linear_model.SGDClassifier" title="sklearn.linear_model.SGDClassifier"><code>SGDClassifier</code></a> with ‘log’ loss.</p> <div class="topic"> <p class="topic-title first">Examples:</p> <ul class="simple"> <li><a class="reference internal" href="../../auto_examples/linear_model/plot_logistic_l1_l2_sparsity/#sphx-glr-auto-examples-linear-model-plot-logistic-l1-l2-sparsity-py"><span class="std std-ref">L1 Penalty and Sparsity in Logistic Regression</span></a></li> <li><a class="reference internal" href="../../auto_examples/linear_model/plot_logistic_path/#sphx-glr-auto-examples-linear-model-plot-logistic-path-py"><span class="std std-ref">Path with L1- Logistic Regression</span></a></li> <li><a class="reference internal" href="../../auto_examples/linear_model/plot_logistic_multinomial/#sphx-glr-auto-examples-linear-model-plot-logistic-multinomial-py"><span class="std std-ref">Plot multinomial and One-vs-Rest Logistic Regression</span></a></li> </ul> </div> <div class="topic" id="liblinear-differences"> <p class="topic-title first">Differences from liblinear:</p> <p>There might be a difference in the scores obtained between <a class="reference internal" href="../generated/sklearn.linear_model.logisticregression/#sklearn.linear_model.LogisticRegression" title="sklearn.linear_model.LogisticRegression"><code>LogisticRegression</code></a> with <code>solver=liblinear</code> or <code>LinearSVC</code> and the external liblinear library directly, when <code>fit_intercept=False</code> and the fit <code>coef_</code> (or) the data to be predicted are zeroes. This is because for the sample(s) with <code>decision_function</code> zero, <a class="reference internal" href="../generated/sklearn.linear_model.logisticregression/#sklearn.linear_model.LogisticRegression" title="sklearn.linear_model.LogisticRegression"><code>LogisticRegression</code></a> and <code>LinearSVC</code> predict the negative class, while liblinear predicts the positive class. Note that a model with <code>fit_intercept=False</code> and having many samples with <code>decision_function</code> zero, is likely to be a underfit, bad model and you are advised to set <code>fit_intercept=True</code> and increase the intercept_scaling.</p> </div> <div class="admonition note"> <p class="first admonition-title">Note</p> <p><strong>Feature selection with sparse logistic regression</strong></p> <p class="last">A logistic regression with L1 penalty yields sparse models, and can thus be used to perform feature selection, as detailed in <a class="reference internal" href="../feature_selection/#l1-feature-selection"><span class="std std-ref">L1-based feature selection</span></a>.</p> </div> <p><a class="reference internal" href="../generated/sklearn.linear_model.logisticregressioncv/#sklearn.linear_model.LogisticRegressionCV" title="sklearn.linear_model.LogisticRegressionCV"><code>LogisticRegressionCV</code></a> implements Logistic Regression with builtin cross-validation to find out the optimal C parameter. “newton-cg”, “sag” and “lbfgs” solvers are found to be faster for high-dimensional dense data, due to warm-starting. For the multiclass case, if <code>multi_class</code> option is set to “ovr”, an optimal C is obtained for each class and if the <code>multi_class</code> option is set to “multinomial”, an optimal C is obtained by minimizing the cross- entropy loss.</p> <div class="topic"> <p class="topic-title first">References:</p> <table class="docutils footnote" frame="void" id="id22" rules="none">   <tr>
<td class="label"><a class="fn-backref" href="#id20">[5]</a></td>
<td>Christopher M. Bishop: Pattern Recognition and Machine Learning, Chapter 4.3.4</td>
</tr>  </table> <table class="docutils footnote" frame="void" id="id23" rules="none">   <tr>
<td class="label"><a class="fn-backref" href="#id21">[6]</a></td>
<td>Mark Schmidt, Nicolas Le Roux, and Francis Bach: <a class="reference external" href="http://hal.inria.fr/hal-00860051/PDF/sag_journal.pdf" target="_blank">Minimizing Finite Sums with the Stochastic Average Gradient.</a>
</td>
</tr>  </table> </div>   <h2 id="stochastic-gradient-descent-sgd">1.1.12. Stochastic Gradient Descent - SGD</h2> <p>Stochastic gradient descent is a simple yet very efficient approach to fit linear models. It is particularly useful when the number of samples (and the number of features) is very large. The <code>partial_fit</code> method allows only/out-of-core learning.</p> <p>The classes <a class="reference internal" href="../generated/sklearn.linear_model.sgdclassifier/#sklearn.linear_model.SGDClassifier" title="sklearn.linear_model.SGDClassifier"><code>SGDClassifier</code></a> and <a class="reference internal" href="../generated/sklearn.linear_model.sgdregressor/#sklearn.linear_model.SGDRegressor" title="sklearn.linear_model.SGDRegressor"><code>SGDRegressor</code></a> provide functionality to fit linear models for classification and regression using different (convex) loss functions and different penalties. E.g., with <code>loss="log"</code>, <a class="reference internal" href="../generated/sklearn.linear_model.sgdclassifier/#sklearn.linear_model.SGDClassifier" title="sklearn.linear_model.SGDClassifier"><code>SGDClassifier</code></a> fits a logistic regression model, while with <code>loss="hinge"</code> it fits a linear support vector machine (SVM).</p> <div class="topic"> <p class="topic-title first">References</p> <ul class="simple"> <li><a class="reference internal" href="../sgd/#sgd"><span class="std std-ref">Stochastic Gradient Descent</span></a></li> </ul> </div>   <h2 id="id24">1.1.13. Perceptron</h2> <p id="perceptron">The <a class="reference internal" href="../generated/sklearn.linear_model.perceptron/#sklearn.linear_model.Perceptron" title="sklearn.linear_model.Perceptron"><code>Perceptron</code></a> is another simple algorithm suitable for large scale learning. By default:</p>  <ul class="simple"> <li>It does not require a learning rate.</li> <li>It is not regularized (penalized).</li> <li>It updates its model only on mistakes.</li> </ul>  <p>The last characteristic implies that the Perceptron is slightly faster to train than SGD with the hinge loss and that the resulting models are sparser.</p>   <h2 id="passive-aggressive">1.1.14. Passive Aggressive Algorithms</h2> <p id="passive-aggressive-algorithms">The passive-aggressive algorithms are a family of algorithms for large-scale learning. They are similar to the Perceptron in that they do not require a learning rate. However, contrary to the Perceptron, they include a regularization parameter <code>C</code>.</p> <p>For classification, <a class="reference internal" href="../generated/sklearn.linear_model.passiveaggressiveclassifier/#sklearn.linear_model.PassiveAggressiveClassifier" title="sklearn.linear_model.PassiveAggressiveClassifier"><code>PassiveAggressiveClassifier</code></a> can be used with <code>loss='hinge'</code> (PA-I) or <code>loss='squared_hinge'</code> (PA-II). For regression, <a class="reference internal" href="../generated/sklearn.linear_model.passiveaggressiveregressor/#sklearn.linear_model.PassiveAggressiveRegressor" title="sklearn.linear_model.PassiveAggressiveRegressor"><code>PassiveAggressiveRegressor</code></a> can be used with <code>loss='epsilon_insensitive'</code> (PA-I) or <code>loss='squared_epsilon_insensitive'</code> (PA-II).</p> <div class="topic"> <p class="topic-title first">References:</p> <ul class="simple"> <li>
<a class="reference external" href="http://jmlr.csail.mit.edu/papers/volume7/crammer06a/crammer06a.pdf" target="_blank">“Online Passive-Aggressive Algorithms”</a> K. Crammer, O. Dekel, J. Keshat, S. Shalev-Shwartz, Y. Singer - JMLR 7 (2006)</li> </ul> </div>   <h2 id="robustness-regression-outliers-and-modeling-errors">1.1.15. Robustness regression: outliers and modeling errors</h2> <p>Robust regression is interested in fitting a regression model in the presence of corrupt data: either outliers, or error in the model.</p> <div class="figure align-center"> <a class="reference external image-reference" href="../../auto_examples/linear_model/plot_theilsen/"><img alt="../_images/sphx_glr_plot_theilsen_0011.png" src="http://scikit-learn.org/stable/_images/sphx_glr_plot_theilsen_0011.png" style="width: 400.0px; height: 300.0px;"></a> </div>  <h3 id="different-scenario-and-useful-concepts">1.1.15.1. Different scenario and useful concepts</h3> <p>There are different things to keep in mind when dealing with data corrupted by outliers:</p> <ul> <li>
<p class="first"><strong>Outliers in X or in y</strong>?</p> <table class="docutils">  <thead valign="bottom"> <tr class="row-odd">
<th class="head">Outliers in the y direction</th> <th class="head">Outliers in the X direction</th> </tr> </thead>  <tr class="row-even">
<td><a class="reference external" href="../../auto_examples/linear_model/plot_robust_fit/"><img alt="y_outliers" src="http://scikit-learn.org/stable/_images/sphx_glr_plot_robust_fit_0031.png" style="width: 300.0px; height: 240.0px;"></a></td> <td><a class="reference external" href="../../auto_examples/linear_model/plot_robust_fit/"><img alt="X_outliers" src="http://scikit-learn.org/stable/_images/sphx_glr_plot_robust_fit_0021.png" style="width: 300.0px; height: 240.0px;"></a></td> </tr>  </table> </li> <li>
<p class="first"><strong>Fraction of outliers versus amplitude of error</strong></p> <p>The number of outlying points matters, but also how much they are outliers.</p> <table class="docutils">  <thead valign="bottom"> <tr class="row-odd">
<th class="head">Small outliers</th> <th class="head">Large outliers</th> </tr> </thead>  <tr class="row-even">
<td><a class="reference external" href="../../auto_examples/linear_model/plot_robust_fit/"><img alt="y_outliers" src="http://scikit-learn.org/stable/_images/sphx_glr_plot_robust_fit_0031.png" style="width: 300.0px; height: 240.0px;"></a></td> <td><a class="reference external" href="../../auto_examples/linear_model/plot_robust_fit/"><img alt="large_y_outliers" src="http://scikit-learn.org/stable/_images/sphx_glr_plot_robust_fit_0051.png" style="width: 300.0px; height: 240.0px;"></a></td> </tr>  </table> </li> </ul> <p>An important notion of robust fitting is that of breakdown point: the fraction of data that can be outlying for the fit to start missing the inlying data.</p> <p>Note that in general, robust fitting in high-dimensional setting (large <code>n_features</code>) is very hard. The robust models here will probably not work in these settings.</p> <div class="topic"> <p class="topic-title first"><strong>Trade-offs: which estimator?</strong></p>  <p>Scikit-learn provides 3 robust regression estimators: <a class="reference internal" href="#ransac-regression"><span class="std std-ref">RANSAC</span></a>, <a class="reference internal" href="#theil-sen-regression"><span class="std std-ref">Theil Sen</span></a> and <a class="reference internal" href="#huber-regression"><span class="std std-ref">HuberRegressor</span></a></p> <ul class="simple"> <li>
<a class="reference internal" href="#huber-regression"><span class="std std-ref">HuberRegressor</span></a> should be faster than <a class="reference internal" href="#ransac-regression"><span class="std std-ref">RANSAC</span></a> and <a class="reference internal" href="#theil-sen-regression"><span class="std std-ref">Theil Sen</span></a> unless the number of samples are very large, i.e <code>n_samples</code> &gt;&gt; <code>n_features</code>. This is because <a class="reference internal" href="#ransac-regression"><span class="std std-ref">RANSAC</span></a> and <a class="reference internal" href="#theil-sen-regression"><span class="std std-ref">Theil Sen</span></a> fit on smaller subsets of the data. However, both <a class="reference internal" href="#theil-sen-regression"><span class="std std-ref">Theil Sen</span></a> and <a class="reference internal" href="#ransac-regression"><span class="std std-ref">RANSAC</span></a> are unlikely to be as robust as <a class="reference internal" href="#huber-regression"><span class="std std-ref">HuberRegressor</span></a> for the default parameters.</li> <li>
<a class="reference internal" href="#ransac-regression"><span class="std std-ref">RANSAC</span></a> is faster than <a class="reference internal" href="#theil-sen-regression"><span class="std std-ref">Theil Sen</span></a> and scales much better with the number of samples</li> <li>
<a class="reference internal" href="#ransac-regression"><span class="std std-ref">RANSAC</span></a> will deal better with large outliers in the y direction (most common situation)</li> <li>
<a class="reference internal" href="#theil-sen-regression"><span class="std std-ref">Theil Sen</span></a> will cope better with medium-size outliers in the X direction, but this property will disappear in large dimensional settings.</li> </ul>  <p>When in doubt, use <a class="reference internal" href="#ransac-regression"><span class="std std-ref">RANSAC</span></a></p> </div>   <h3 id="ransac-regression">1.1.15.2. RANSAC: RANdom SAmple Consensus</h3> <p id="ransac-random-sample-consensus">RANSAC (RANdom SAmple Consensus) fits a model from random subsets of inliers from the complete data set.</p> <p>RANSAC is a non-deterministic algorithm producing only a reasonable result with a certain probability, which is dependent on the number of iterations (see <code>max_trials</code> parameter). It is typically used for linear and non-linear regression problems and is especially popular in the fields of photogrammetric computer vision.</p> <p>The algorithm splits the complete input sample data into a set of inliers, which may be subject to noise, and outliers, which are e.g. caused by erroneous measurements or invalid hypotheses about the data. The resulting model is then estimated only from the determined inliers.</p> <div class="figure align-center"> <a class="reference external image-reference" href="../../auto_examples/linear_model/plot_ransac/"><img alt="../_images/sphx_glr_plot_ransac_0011.png" src="http://scikit-learn.org/stable/_images/sphx_glr_plot_ransac_0011.png" style="width: 400.0px; height: 300.0px;"></a> </div>  <h4 id="details-of-the-algorithm">1.1.15.2.1. Details of the algorithm</h4> <p>Each iteration performs the following steps:</p> <ol class="arabic simple"> <li>Select <code>min_samples</code> random samples from the original data and check whether the set of data is valid (see <code>is_data_valid</code>).</li> <li>Fit a model to the random subset (<code>base_estimator.fit</code>) and check whether the estimated model is valid (see <code>is_model_valid</code>).</li> <li>Classify all data as inliers or outliers by calculating the residuals to the estimated model (<code>base_estimator.predict(X) - y</code>) - all data samples with absolute residuals smaller than the <code>residual_threshold</code> are considered as inliers.</li> <li>Save fitted model as best model if number of inlier samples is maximal. In case the current estimated model has the same number of inliers, it is only considered as the best model if it has better score.</li> </ol> <p>These steps are performed either a maximum number of times (<code>max_trials</code>) or until one of the special stop criteria are met (see <code>stop_n_inliers</code> and <code>stop_score</code>). The final model is estimated using all inlier samples (consensus set) of the previously determined best model.</p> <p>The <code>is_data_valid</code> and <code>is_model_valid</code> functions allow to identify and reject degenerate combinations of random sub-samples. If the estimated model is not needed for identifying degenerate cases, <code>is_data_valid</code> should be used as it is called prior to fitting the model and thus leading to better computational performance.</p> <div class="topic"> <p class="topic-title first">Examples:</p> <ul class="simple"> <li><a class="reference internal" href="../../auto_examples/linear_model/plot_ransac/#sphx-glr-auto-examples-linear-model-plot-ransac-py"><span class="std std-ref">Robust linear model estimation using RANSAC</span></a></li> <li><a class="reference internal" href="../../auto_examples/linear_model/plot_robust_fit/#sphx-glr-auto-examples-linear-model-plot-robust-fit-py"><span class="std std-ref">Robust linear estimator fitting</span></a></li> </ul> </div> <div class="topic"> <p class="topic-title first">References:</p> <ul class="simple"> <li><a class="reference external" href="https://en.wikipedia.org/wiki/RANSAC" target="_blank">https://en.wikipedia.org/wiki/RANSAC</a></li> <li>
<a class="reference external" href="http://www.cs.columbia.edu/~belhumeur/courses/compPhoto/ransac.pdf" target="_blank">“Random Sample Consensus: A Paradigm for Model Fitting with Applications to Image Analysis and Automated Cartography”</a> Martin A. Fischler and Robert C. Bolles - SRI International (1981)</li> <li>
<a class="reference external" href="http://www.bmva.org/bmvc/2009/Papers/Paper355/Paper355.pdf" target="_blank">“Performance Evaluation of RANSAC Family”</a> Sunglok Choi, Taemin Kim and Wonpil Yu - BMVC (2009)</li> </ul> </div>    <h3 id="theil-sen-regression">1.1.15.3. Theil-Sen estimator: generalized-median-based estimator</h3> <p id="theil-sen-estimator-generalized-median-based-estimator">The <a class="reference internal" href="../generated/sklearn.linear_model.theilsenregressor/#sklearn.linear_model.TheilSenRegressor" title="sklearn.linear_model.TheilSenRegressor"><code>TheilSenRegressor</code></a> estimator uses a generalization of the median in multiple dimensions. It is thus robust to multivariate outliers. Note however that the robustness of the estimator decreases quickly with the dimensionality of the problem. It looses its robustness properties and becomes no better than an ordinary least squares in high dimension.</p> <div class="topic"> <p class="topic-title first">Examples:</p> <ul class="simple"> <li><a class="reference internal" href="../../auto_examples/linear_model/plot_theilsen/#sphx-glr-auto-examples-linear-model-plot-theilsen-py"><span class="std std-ref">Theil-Sen Regression</span></a></li> <li><a class="reference internal" href="../../auto_examples/linear_model/plot_robust_fit/#sphx-glr-auto-examples-linear-model-plot-robust-fit-py"><span class="std std-ref">Robust linear estimator fitting</span></a></li> </ul> </div> <div class="topic"> <p class="topic-title first">References:</p> <ul class="simple"> <li><a class="reference external" href="https://en.wikipedia.org/wiki/Theil%E2%80%93Sen_estimator" target="_blank">https://en.wikipedia.org/wiki/Theil%E2%80%93Sen_estimator</a></li> </ul> </div>  <h4 id="theoretical-considerations">1.1.15.3.1. Theoretical considerations</h4> <p><a class="reference internal" href="../generated/sklearn.linear_model.theilsenregressor/#sklearn.linear_model.TheilSenRegressor" title="sklearn.linear_model.TheilSenRegressor"><code>TheilSenRegressor</code></a> is comparable to the <a class="reference internal" href="#ordinary-least-squares"><span class="std std-ref">Ordinary Least Squares (OLS)</span></a> in terms of asymptotic efficiency and as an unbiased estimator. In contrast to OLS, Theil-Sen is a non-parametric method which means it makes no assumption about the underlying distribution of the data. Since Theil-Sen is a median-based estimator, it is more robust against corrupted data aka outliers. In univariate setting, Theil-Sen has a breakdown point of about 29.3% in case of a simple linear regression which means that it can tolerate arbitrary corrupted data of up to 29.3%.</p> <div class="figure align-center"> <a class="reference external image-reference" href="../../auto_examples/linear_model/plot_theilsen/"><img alt="../_images/sphx_glr_plot_theilsen_0011.png" src="http://scikit-learn.org/stable/_images/sphx_glr_plot_theilsen_0011.png" style="width: 400.0px; height: 300.0px;"></a> </div> <p>The implementation of <a class="reference internal" href="../generated/sklearn.linear_model.theilsenregressor/#sklearn.linear_model.TheilSenRegressor" title="sklearn.linear_model.TheilSenRegressor"><code>TheilSenRegressor</code></a> in scikit-learn follows a generalization to a multivariate linear regression model <a href="#id30"><span class="problematic" id="id31">[#f1]_</span></a> using the spatial median which is a generalization of the median to multiple dimensions <a class="footnote-reference" href="#f2" id="id26">[8]</a>.</p> <p>In terms of time and space complexity, Theil-Sen scales according to</p> <div class="math"> <p><img src="http://scikit-learn.org/stable/_images/math/cbf87473164b3658d7ba9e55d88133d12c409a35.png" alt="\binom{n_{samples}}{n_{subsamples}}"></p> </div>
<p>which makes it infeasible to be applied exhaustively to problems with a large number of samples and features. Therefore, the magnitude of a subpopulation can be chosen to limit the time and space complexity by considering only a random subset of all possible combinations.</p> <div class="topic"> <p class="topic-title first">Examples:</p> <ul class="simple"> <li><a class="reference internal" href="../../auto_examples/linear_model/plot_theilsen/#sphx-glr-auto-examples-linear-model-plot-theilsen-py"><span class="std std-ref">Theil-Sen Regression</span></a></li> </ul> </div> <div class="topic"> <p class="topic-title first">References:</p> <table class="docutils footnote" frame="void" id="f1" rules="none">   <tr>
<td class="label">[7]</td>
<td>Xin Dang, Hanxiang Peng, Xueqin Wang and Heping Zhang: <a class="reference external" href="http://home.olemiss.edu/~xdang/papers/MTSE.pdf" target="_blank">Theil-Sen Estimators in a Multiple Linear Regression Model.</a>
</td>
</tr>  </table> <table class="docutils footnote" frame="void" id="f2" rules="none">   <tr>
<td class="label"><a class="fn-backref" href="#id26">[8]</a></td>
<td>
<ol class="first last upperalpha simple" start="20"> <li>Kärkkäinen and S. Äyrämö: <a class="reference external" href="http://users.jyu.fi/~samiayr/pdf/ayramo_eurogen05.pdf" target="_blank">On Computation of Spatial Median for Robust Data Mining.</a>
</li> </ol> </td>
</tr>  </table> </div>    <h3 id="id27">1.1.15.4. Huber Regression</h3> <p id="huber-regression">The <a class="reference internal" href="../generated/sklearn.linear_model.huberregressor/#sklearn.linear_model.HuberRegressor" title="sklearn.linear_model.HuberRegressor"><code>HuberRegressor</code></a> is different to <a class="reference internal" href="../generated/sklearn.linear_model.ridge/#sklearn.linear_model.Ridge" title="sklearn.linear_model.Ridge"><code>Ridge</code></a> because it applies a linear loss to samples that are classified as outliers. A sample is classified as an inlier if the absolute error of that sample is lesser than a certain threshold. It differs from <a class="reference internal" href="../generated/sklearn.linear_model.theilsenregressor/#sklearn.linear_model.TheilSenRegressor" title="sklearn.linear_model.TheilSenRegressor"><code>TheilSenRegressor</code></a> and <a class="reference internal" href="../generated/sklearn.linear_model.ransacregressor/#sklearn.linear_model.RANSACRegressor" title="sklearn.linear_model.RANSACRegressor"><code>RANSACRegressor</code></a> because it does not ignore the effect of the outliers but gives a lesser weight to them.</p> <div class="figure align-center"> <a class="reference external image-reference" href="../../auto_examples/linear_model/plot_huber_vs_ridge/"><img alt="../_images/sphx_glr_plot_huber_vs_ridge_001.png" src="http://scikit-learn.org/stable/_images/sphx_glr_plot_huber_vs_ridge_001.png" style="width: 400.0px; height: 300.0px;"></a> </div> <p>The loss function that <a class="reference internal" href="../generated/sklearn.linear_model.huberregressor/#sklearn.linear_model.HuberRegressor" title="sklearn.linear_model.HuberRegressor"><code>HuberRegressor</code></a> minimizes is given by</p> <div class="math"> <p><img src="http://scikit-learn.org/stable/_images/math/0d258a58c106569aa29ce544fda8f206ada92c18.png" alt="\underset{w, \sigma}{min\,} {\sum_{i=1}^n\left(\sigma + H_m\left(\frac{X_{i}w - y_{i}}{\sigma}\right)\sigma\right) + \alpha {||w||_2}^2}"></p> </div>
<p>where</p> <div class="math"> <p><img src="http://scikit-learn.org/stable/_images/math/eac100ea9c5c41a717a9414ce87e34b43de19c35.png" alt="H_m(z) = \begin{cases}
       z^2, &amp; \text {if } |z| &lt; \epsilon, \\
       2\epsilon|z| - \epsilon^2, &amp; \text{otherwise}
\end{cases}"></p> </div>
<p>It is advised to set the parameter <code>epsilon</code> to 1.35 to achieve 95% statistical efficiency.</p>   <h3 id="notes">1.1.15.5. Notes</h3> <p>The <a class="reference internal" href="../generated/sklearn.linear_model.huberregressor/#sklearn.linear_model.HuberRegressor" title="sklearn.linear_model.HuberRegressor"><code>HuberRegressor</code></a> differs from using <a class="reference internal" href="../generated/sklearn.linear_model.sgdregressor/#sklearn.linear_model.SGDRegressor" title="sklearn.linear_model.SGDRegressor"><code>SGDRegressor</code></a> with loss set to <code>huber</code> in the following ways.</p> <ul class="simple"> <li>
<a class="reference internal" href="../generated/sklearn.linear_model.huberregressor/#sklearn.linear_model.HuberRegressor" title="sklearn.linear_model.HuberRegressor"><code>HuberRegressor</code></a> is scaling invariant. Once <code>epsilon</code> is set, scaling <code>X</code> and <code>y</code> down or up by different values would produce the same robustness to outliers as before. as compared to <a class="reference internal" href="../generated/sklearn.linear_model.sgdregressor/#sklearn.linear_model.SGDRegressor" title="sklearn.linear_model.SGDRegressor"><code>SGDRegressor</code></a> where <code>epsilon</code> has to be set again when <code>X</code> and <code>y</code> are scaled.</li> <li>
<a class="reference internal" href="../generated/sklearn.linear_model.huberregressor/#sklearn.linear_model.HuberRegressor" title="sklearn.linear_model.HuberRegressor"><code>HuberRegressor</code></a> should be more efficient to use on data with small number of samples while <a class="reference internal" href="../generated/sklearn.linear_model.sgdregressor/#sklearn.linear_model.SGDRegressor" title="sklearn.linear_model.SGDRegressor"><code>SGDRegressor</code></a> needs a number of passes on the training data to produce the same robustness.</li> </ul> <div class="topic"> <p class="topic-title first">Examples:</p> <ul class="simple"> <li><a class="reference internal" href="../../auto_examples/linear_model/plot_huber_vs_ridge/#sphx-glr-auto-examples-linear-model-plot-huber-vs-ridge-py"><span class="std std-ref">HuberRegressor vs Ridge on dataset with strong outliers</span></a></li> </ul> </div> <div class="topic"> <p class="topic-title first">References:</p> <table class="docutils footnote" frame="void" id="id28" rules="none">   <tr>
<td class="label">[9]</td>
<td>Peter J. Huber, Elvezio M. Ronchetti: Robust Statistics, Concomitant scale estimates, pg 172</td>
</tr>  </table> </div> <p>Also, this estimator is different from the R implementation of Robust Regression (<a class="reference external" href="http://www.ats.ucla.edu/stat/r/dae/rreg.htm" target="_blank">http://www.ats.ucla.edu/stat/r/dae/rreg.htm</a>) because the R implementation does a weighted least squares implementation with weights given to each sample on the basis of how much the residual is greater than a certain threshold.</p>    <h2 id="polynomial-regression">1.1.16. Polynomial regression: extending linear models with basis functions</h2> <p id="polynomial-regression-extending-linear-models-with-basis-functions">One common pattern within machine learning is to use linear models trained on nonlinear functions of the data. This approach maintains the generally fast performance of linear methods, while allowing them to fit a much wider range of data.</p> <p>For example, a simple linear regression can be extended by constructing <strong>polynomial features</strong> from the coefficients. In the standard linear regression case, you might have a model that looks like this for two-dimensional data:</p> <div class="math"> <p><img src="http://scikit-learn.org/stable/_images/math/3666ec3bc883af433b318bff9143b5166bcaef15.png" alt="\hat{y}(w, x) = w_0 + w_1 x_1 + w_2 x_2"></p> </div>
<p>If we want to fit a paraboloid to the data instead of a plane, we can combine the features in second-order polynomials, so that the model looks like this:</p> <div class="math"> <p><img src="http://scikit-learn.org/stable/_images/math/1e1f74179df321954b823943c08d555a524e69f9.png" alt="\hat{y}(w, x) = w_0 + w_1 x_1 + w_2 x_2 + w_3 x_1 x_2 + w_4 x_1^2 + w_5 x_2^2"></p> </div>
<p>The (sometimes surprising) observation is that this is <em>still a linear model</em>: to see this, imagine creating a new variable</p> <div class="math"> <p><img src="http://scikit-learn.org/stable/_images/math/2c0a9947255ef61995c3f5e6319fc7fdfa3503c6.png" alt="z = [x_1, x_2, x_1 x_2, x_1^2, x_2^2]"></p> </div>
<p>With this re-labeling of the data, our problem can be written</p> <div class="math"> <p><img src="http://scikit-learn.org/stable/_images/math/618623438e33ecf053d364a0b938f056cd758b34.png" alt="\hat{y}(w, x) = w_0 + w_1 z_1 + w_2 z_2 + w_3 z_3 + w_4 z_4 + w_5 z_5"></p> </div>
<p>We see that the resulting <em>polynomial regression</em> is in the same class of linear models we’d considered above (i.e. the model is linear in <img class="math" src="http://scikit-learn.org/stable/_images/math/ecd1ee2a1cd226b40c37e079aca62398d4b774f5.png" alt="w">) and can be solved by the same techniques. By considering linear fits within a higher-dimensional space built with these basis functions, the model has the flexibility to fit a much broader range of data.</p> <p>Here is an example of applying this idea to one-dimensional data, using polynomial features of varying degrees:</p> <div class="figure align-center"> <a class="reference external image-reference" href="../../auto_examples/linear_model/plot_polynomial_interpolation/"><img alt="../_images/sphx_glr_plot_polynomial_interpolation_0011.png" src="http://scikit-learn.org/stable/_images/sphx_glr_plot_polynomial_interpolation_0011.png" style="width: 400.0px; height: 300.0px;"></a> </div> <p>This figure is created using the <a class="reference internal" href="../generated/sklearn.preprocessing.polynomialfeatures/#sklearn.preprocessing.PolynomialFeatures" title="sklearn.preprocessing.PolynomialFeatures"><code>PolynomialFeatures</code></a> preprocessor. This preprocessor transforms an input data matrix into a new data matrix of a given degree. It can be used as follows:</p> <pre data-language="python">&gt;&gt;&gt; from sklearn.preprocessing import PolynomialFeatures
&gt;&gt;&gt; import numpy as np
&gt;&gt;&gt; X = np.arange(6).reshape(3, 2)
&gt;&gt;&gt; X
array([[0, 1],
       [2, 3],
       [4, 5]])
&gt;&gt;&gt; poly = PolynomialFeatures(degree=2)
&gt;&gt;&gt; poly.fit_transform(X)
array([[  1.,   0.,   1.,   0.,   0.,   1.],
       [  1.,   2.,   3.,   4.,   6.,   9.],
       [  1.,   4.,   5.,  16.,  20.,  25.]])
</pre> <p>The features of <code>X</code> have been transformed from <img class="math" src="http://scikit-learn.org/stable/_images/math/f75be564a03e84d56ceb3b55386f45b58d2f9b3a.png" alt="[x_1, x_2]"> to <img class="math" src="http://scikit-learn.org/stable/_images/math/812a701e111e7fc5dc083e98f619aacc1e8ec56e.png" alt="[1, x_1, x_2, x_1^2, x_1 x_2, x_2^2]">, and can now be used within any linear model.</p> <p>This sort of preprocessing can be streamlined with the <a class="reference internal" href="../pipeline/#pipeline"><span class="std std-ref">Pipeline</span></a> tools. A single object representing a simple polynomial regression can be created and used as follows:</p> <pre data-language="python">&gt;&gt;&gt; from sklearn.preprocessing import PolynomialFeatures
&gt;&gt;&gt; from sklearn.linear_model import LinearRegression
&gt;&gt;&gt; from sklearn.pipeline import Pipeline
&gt;&gt;&gt; import numpy as np
&gt;&gt;&gt; model = Pipeline([('poly', PolynomialFeatures(degree=3)),
...                   ('linear', LinearRegression(fit_intercept=False))])
&gt;&gt;&gt; # fit to an order-3 polynomial data
&gt;&gt;&gt; x = np.arange(5)
&gt;&gt;&gt; y = 3 - 2 * x + x ** 2 - x ** 3
&gt;&gt;&gt; model = model.fit(x[:, np.newaxis], y)
&gt;&gt;&gt; model.named_steps['linear'].coef_
array([ 3., -2.,  1., -1.])
</pre> <p>The linear model trained on polynomial features is able to exactly recover the input polynomial coefficients.</p> <p>In some cases it’s not necessary to include higher powers of any single feature, but only the so-called <em>interaction features</em> that multiply together at most <img class="math" src="http://scikit-learn.org/stable/_images/math/b9d10b54744d07746b97f53c55eb98046fd76c8c.png" alt="d"> distinct features. These can be gotten from <a class="reference internal" href="../generated/sklearn.preprocessing.polynomialfeatures/#sklearn.preprocessing.PolynomialFeatures" title="sklearn.preprocessing.PolynomialFeatures"><code>PolynomialFeatures</code></a> with the setting <code>interaction_only=True</code>.</p> <p>For example, when dealing with boolean features, <img class="math" src="http://scikit-learn.org/stable/_images/math/f6482a828417735ebd0aeb8117358b78a1090b6b.png" alt="x_i^n = x_i"> for all <img class="math" src="http://scikit-learn.org/stable/_images/math/e11f2701c4a39c7fe543a6c4150b421d50f1c159.png" alt="n"> and is therefore useless; but <img class="math" src="http://scikit-learn.org/stable/_images/math/65d728c141eeafa8aa4c3499e9d2e8f6b755c903.png" alt="x_i x_j"> represents the conjunction of two booleans. This way, we can solve the XOR problem with a linear classifier:</p> <pre data-language="python">&gt;&gt;&gt; from sklearn.linear_model import Perceptron
&gt;&gt;&gt; from sklearn.preprocessing import PolynomialFeatures
&gt;&gt;&gt; import numpy as np
&gt;&gt;&gt; X = np.array([[0, 0], [0, 1], [1, 0], [1, 1]])
&gt;&gt;&gt; y = X[:, 0] ^ X[:, 1]
&gt;&gt;&gt; y
array([0, 1, 1, 0])
&gt;&gt;&gt; X = PolynomialFeatures(interaction_only=True).fit_transform(X).astype(int)
&gt;&gt;&gt; X
array([[1, 0, 0, 0],
       [1, 0, 1, 0],
       [1, 1, 0, 0],
       [1, 1, 1, 1]])
&gt;&gt;&gt; clf = Perceptron(fit_intercept=False, n_iter=10, shuffle=False).fit(X, y)
</pre> <p>And the classifier “predictions” are perfect:</p> <pre data-language="python">&gt;&gt;&gt; clf.predict(X)
array([0, 1, 1, 0])
&gt;&gt;&gt; clf.score(X, y)
1.0
</pre>
<div class="_attribution">
  <p class="_attribution-p">
    © 2007–2016 The scikit-learn developers<br>Licensed under the 3-clause BSD License.<br>
    <a href="http://scikit-learn.org/stable/modules/linear_model.html" class="_attribution-link" target="_blank">http://scikit-learn.org/stable/modules/linear_model.html</a>
  </p>
</div>

			</div>
		</div>
	</section>

	</div>
</body>
</html>
