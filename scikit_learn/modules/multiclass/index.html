
<!DOCTYPE HTML>

<html lang="en">

<head>
  <meta charset="utf-8">
  <title>1.12. Multiclass and Multilabel Algorithms - Scikit-learn - W3cubDocs</title>
  
  <meta name="description" content=" Warning ">
  <meta name="keywords" content="multiclass, and, multilabel, algorithms, -, scikit-learn, scikit_learn">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="http://docs.w3cub.com/scikit_learn/modules/multiclass/">
  <link href="/favicon.png" rel="icon">
  <link type="text/css" rel="stylesheet" href="/assets/application-50364fff564ce3b6327021805f3f00e2957b441cf27f576a7dd4ff63bbc47047.css">
  <script type="text/javascript" src="/assets/application-db64bfd54ceb42be11af7995804cf4902548419ceb79d509b0b7d62c22d98e6f.js"></script>
  <script src="/json/scikit_learn.js"></script>
  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-71174418-1']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>


</head>

<body>
	<div class="_app">
	<header class="_header">
  
  <form class="_search">
    <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
    <a class="_search-clear"></a>
    <div class="_search-tag"></div>
  </form>
  
  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/scikit_learn/" class="_nav-link" title="" style="margin-left:0;">scikit-learn</a></span>
  
  <nav class="_nav">
    <a href="/app/" class="_nav-link ">App</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		<div class="_list">
			
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<div class="_page _sphinx">
				
<h1 id="multiclass">1.12. Multiclass and multilabel algorithms</h1> <div class="admonition warning" id="multiclass-and-multilabel-algorithms"> <p class="first admonition-title">Warning</p> <p class="last">All classifiers in scikit-learn do multiclass classification out-of-the-box. You don’t need to use the <a class="reference internal" href="../classes/#module-sklearn.multiclass" title="sklearn.multiclass"><code>sklearn.multiclass</code></a> module unless you want to experiment with different multiclass strategies.</p> </div> <p>The <a class="reference internal" href="../classes/#module-sklearn.multiclass" title="sklearn.multiclass"><code>sklearn.multiclass</code></a> module implements <em>meta-estimators</em> to solve <code>multiclass</code> and <code>multilabel</code> classification problems by decomposing such problems into binary classification problems. Multitarget regression is also supported.</p>  <ul> <li>
<strong>Multiclass classification</strong> means a classification task with more than two classes; e.g., classify a set of images of fruits which may be oranges, apples, or pears. Multiclass classification makes the assumption that each sample is assigned to one and only one label: a fruit can be either an apple or a pear but not both at the same time. </li> <li>
<strong>Multilabel classification</strong> assigns to each sample a set of target labels. This can be thought as predicting properties of a data-point that are not mutually exclusive, such as topics that are relevant for a document. A text might be about any of religion, politics, finance or education at the same time or none of these. </li> <li>
<strong>Multioutput regression</strong> assigns each sample a set of target values. This can be thought of as predicting several properties for each data-point, such as wind direction and magnitude at a certain location. </li> <li>
<p class="first"><strong>Multioutput-multiclass classification</strong> and <strong>multi-task classification</strong> means that a single estimator has to handle several joint classification tasks. This is a generalization of the multi-label classification task, where the set of classification problem is restricted to binary classification, and of the multi-class classification task. <em>The output format is a 2d numpy array or sparse matrix.</em></p> <p>The set of labels can be different for each output variable. For instance a sample could be assigned “pear” for an output variable that takes possible values in a finite set of species such as “pear”, “apple”, “orange” and “green” for a second output variable that takes possible values in a finite set of colors such as “green”, “red”, “orange”, “yellow”...</p> <p>This means that any classifiers handling multi-output multiclass or multi-task classification task supports the multi-label classification task as a special case. Multi-task classification is similar to the multi-output classification task with different model formulations. For more information, see the relevant estimator documentation.</p> </li> </ul>  <p>All scikit-learn classifiers are capable of multiclass classification, but the meta-estimators offered by <a class="reference internal" href="../classes/#module-sklearn.multiclass" title="sklearn.multiclass"><code>sklearn.multiclass</code></a> permit changing the way they handle more than two classes because this may have an effect on classifier performance (either in terms of generalization error or required computational resources).</p> <p>Below is a summary of the classifiers supported by scikit-learn grouped by strategy; you don’t need the meta-estimators in this class if you’re using one of these unless you want custom multiclass behavior:</p>  <ul class="simple"> <li>Inherently multiclass: <a class="reference internal" href="../naive_bayes/#naive-bayes"><span class="std std-ref">Naive Bayes</span></a>, <a class="reference internal" href="../lda_qda/#lda-qda"><span class="std std-ref">LDA and QDA</span></a>, <a class="reference internal" href="../tree/#tree"><span class="std std-ref">Decision Trees</span></a>, <a class="reference internal" href="../ensemble/#forest"><span class="std std-ref">Random Forests</span></a>, <a class="reference internal" href="../neighbors/#neighbors"><span class="std std-ref">Nearest Neighbors</span></a>, setting <code>multi_class='multinomial'</code> in <a class="reference internal" href="../generated/sklearn.linear_model.logisticregression/#sklearn.linear_model.LogisticRegression" title="sklearn.linear_model.LogisticRegression"><code>sklearn.linear_model.LogisticRegression</code></a>.</li> <li>Support multilabel: <a class="reference internal" href="../tree/#tree"><span class="std std-ref">Decision Trees</span></a>, <a class="reference internal" href="../ensemble/#forest"><span class="std std-ref">Random Forests</span></a>, <a class="reference internal" href="../neighbors/#neighbors"><span class="std std-ref">Nearest Neighbors</span></a>.</li> <li>One-Vs-One: <a class="reference internal" href="../generated/sklearn.svm.svc/#sklearn.svm.SVC" title="sklearn.svm.SVC"><code>sklearn.svm.SVC</code></a>.</li> <li>One-Vs-All: all linear models except <a class="reference internal" href="../generated/sklearn.svm.svc/#sklearn.svm.SVC" title="sklearn.svm.SVC"><code>sklearn.svm.SVC</code></a>.</li> </ul>  <p>Some estimators also support multioutput-multiclass classification tasks <a class="reference internal" href="../tree/#tree"><span class="std std-ref">Decision Trees</span></a>, <a class="reference internal" href="../ensemble/#forest"><span class="std std-ref">Random Forests</span></a>, <a class="reference internal" href="../neighbors/#neighbors"><span class="std std-ref">Nearest Neighbors</span></a>.</p> <div class="admonition warning"> <p class="first admonition-title">Warning</p> <p class="last">At present, no metric in <a class="reference internal" href="../classes/#module-sklearn.metrics" title="sklearn.metrics"><code>sklearn.metrics</code></a> supports the multioutput-multiclass classification task.</p> </div>  <h2 id="multilabel-classification-format">1.12.1. Multilabel classification format</h2> <p>In multilabel learning, the joint set of binary classification tasks is expressed with label binary indicator array: each sample is one row of a 2d array of shape (n_samples, n_classes) with binary values: the one, i.e. the non zero elements, corresponds to the subset of labels. An array such as <code>np.array([[1, 0, 0], [0, 1, 1], [0, 0, 0]])</code> represents label 0 in the first sample, labels 1 and 2 in the second sample, and no labels in the third sample.</p> <p>Producing multilabel data as a list of sets of labels may be more intuitive. The <a class="reference internal" href="../generated/sklearn.preprocessing.multilabelbinarizer/#sklearn.preprocessing.MultiLabelBinarizer" title="sklearn.preprocessing.MultiLabelBinarizer"><code>MultiLabelBinarizer</code></a> transformer can be used to convert between a collection of collections of labels and the indicator format.</p> <pre data-language="python">&gt;&gt;&gt; from sklearn.preprocessing import MultiLabelBinarizer
&gt;&gt;&gt; y = [[2, 3, 4], [2], [0, 1, 3], [0, 1, 2, 3, 4], [0, 1, 2]]
&gt;&gt;&gt; MultiLabelBinarizer().fit_transform(y)
array([[0, 0, 1, 1, 1],
       [0, 0, 1, 0, 0],
       [1, 1, 0, 1, 0],
       [1, 1, 1, 1, 1],
       [1, 1, 1, 0, 0]])
</pre>   <h2 id="ovr-classification">1.12.2. One-Vs-The-Rest</h2> <p id="one-vs-the-rest">This strategy, also known as <strong>one-vs-all</strong>, is implemented in <a class="reference internal" href="../generated/sklearn.multiclass.onevsrestclassifier/#sklearn.multiclass.OneVsRestClassifier" title="sklearn.multiclass.OneVsRestClassifier"><code>OneVsRestClassifier</code></a>. The strategy consists in fitting one classifier per class. For each classifier, the class is fitted against all the other classes. In addition to its computational efficiency (only <code>n_classes</code> classifiers are needed), one advantage of this approach is its interpretability. Since each class is represented by one and one classifier only, it is possible to gain knowledge about the class by inspecting its corresponding classifier. This is the most commonly used strategy and is a fair default choice.</p>  <h3 id="multiclass-learning">1.12.2.1. Multiclass learning</h3> <p>Below is an example of multiclass learning using OvR:</p> <pre data-language="python">&gt;&gt;&gt; from sklearn import datasets
&gt;&gt;&gt; from sklearn.multiclass import OneVsRestClassifier
&gt;&gt;&gt; from sklearn.svm import LinearSVC
&gt;&gt;&gt; iris = datasets.load_iris()
&gt;&gt;&gt; X, y = iris.data, iris.target
&gt;&gt;&gt; OneVsRestClassifier(LinearSVC(random_state=0)).fit(X, y).predict(X)
array([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
       0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
       0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
       1, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 1, 1, 1, 1, 1, 1, 1,
       1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
       2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 2, 2, 2, 1, 2, 2, 2, 2,
       2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2])
</pre>   <h3 id="multilabel-learning">1.12.2.2. Multilabel learning</h3> <p><a class="reference internal" href="../generated/sklearn.multiclass.onevsrestclassifier/#sklearn.multiclass.OneVsRestClassifier" title="sklearn.multiclass.OneVsRestClassifier"><code>OneVsRestClassifier</code></a> also supports multilabel classification. To use this feature, feed the classifier an indicator matrix, in which cell [i, j] indicates the presence of label j in sample i.</p> <div class="figure align-center"> <a class="reference external image-reference" href="../../auto_examples/plot_multilabel/"><img alt="../_images/sphx_glr_plot_multilabel_0011.png" src="http://scikit-learn.org/stable/_images/sphx_glr_plot_multilabel_0011.png" style="width: 600.0px; height: 450.0px;"></a> </div> <div class="topic"> <p class="topic-title first">Examples:</p> <ul class="simple"> <li><a class="reference internal" href="../../auto_examples/plot_multilabel/#sphx-glr-auto-examples-plot-multilabel-py"><span class="std std-ref">Multilabel classification</span></a></li> </ul> </div>    <h2 id="ovo-classification">1.12.3. One-Vs-One</h2> <p id="one-vs-one"><a class="reference internal" href="../generated/sklearn.multiclass.onevsoneclassifier/#sklearn.multiclass.OneVsOneClassifier" title="sklearn.multiclass.OneVsOneClassifier"><code>OneVsOneClassifier</code></a> constructs one classifier per pair of classes. At prediction time, the class which received the most votes is selected. In the event of a tie (among two classes with an equal number of votes), it selects the class with the highest aggregate classification confidence by summing over the pair-wise classification confidence levels computed by the underlying binary classifiers.</p> <p>Since it requires to fit <code>n_classes * (n_classes - 1) / 2</code> classifiers, this method is usually slower than one-vs-the-rest, due to its O(n_classes^2) complexity. However, this method may be advantageous for algorithms such as kernel algorithms which don’t scale well with <code>n_samples</code>. This is because each individual learning problem only involves a small subset of the data whereas, with one-vs-the-rest, the complete dataset is used <code>n_classes</code> times.</p>  <h3 id="id1">1.12.3.1. Multiclass learning</h3> <p>Below is an example of multiclass learning using OvO:</p> <pre data-language="python">&gt;&gt;&gt; from sklearn import datasets
&gt;&gt;&gt; from sklearn.multiclass import OneVsOneClassifier
&gt;&gt;&gt; from sklearn.svm import LinearSVC
&gt;&gt;&gt; iris = datasets.load_iris()
&gt;&gt;&gt; X, y = iris.data, iris.target
&gt;&gt;&gt; OneVsOneClassifier(LinearSVC(random_state=0)).fit(X, y).predict(X)
array([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
       0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
       0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
       1, 2, 1, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 1, 1, 1, 1, 1, 1, 1, 1,
       1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
       2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
       2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2])
</pre> <div class="topic"> <p class="topic-title first">References:</p> <table class="docutils footnote" frame="void" id="id2" rules="none">   <tr>
<td class="label">[1]</td>
<td>“Pattern Recognition and Machine Learning. Springer”, Christopher M. Bishop, page 183, (First Edition)</td>
</tr>  </table> </div>    <h2 id="ecoc">1.12.4. Error-Correcting Output-Codes</h2> <p id="error-correcting-output-codes">Output-code based strategies are fairly different from one-vs-the-rest and one-vs-one. With these strategies, each class is represented in a euclidean space, where each dimension can only be 0 or 1. Another way to put it is that each class is represented by a binary code (an array of 0 and 1). The matrix which keeps track of the location/code of each class is called the code book. The code size is the dimensionality of the aforementioned space. Intuitively, each class should be represented by a code as unique as possible and a good code book should be designed to optimize classification accuracy. In this implementation, we simply use a randomly-generated code book as advocated in <a class="footnote-reference" href="#id6" id="id3">[3]</a> although more elaborate methods may be added in the future.</p> <p>At fitting time, one binary classifier per bit in the code book is fitted. At prediction time, the classifiers are used to project new points in the class space and the class closest to the points is chosen.</p> <p>In <a class="reference internal" href="../generated/sklearn.multiclass.outputcodeclassifier/#sklearn.multiclass.OutputCodeClassifier" title="sklearn.multiclass.OutputCodeClassifier"><code>OutputCodeClassifier</code></a>, the <code>code_size</code> attribute allows the user to control the number of classifiers which will be used. It is a percentage of the total number of classes.</p> <p>A number between 0 and 1 will require fewer classifiers than one-vs-the-rest. In theory, <code>log2(n_classes) / n_classes</code> is sufficient to represent each class unambiguously. However, in practice, it may not lead to good accuracy since <code>log2(n_classes)</code> is much smaller than n_classes.</p> <p>A number greater than 1 will require more classifiers than one-vs-the-rest. In this case, some classifiers will in theory correct for the mistakes made by other classifiers, hence the name “error-correcting”. In practice, however, this may not happen as classifier mistakes will typically be correlated. The error-correcting output codes have a similar effect to bagging.</p>  <h3 id="id4">1.12.4.1. Multiclass learning</h3> <p>Below is an example of multiclass learning using Output-Codes:</p> <pre data-language="python">&gt;&gt;&gt; from sklearn import datasets
&gt;&gt;&gt; from sklearn.multiclass import OutputCodeClassifier
&gt;&gt;&gt; from sklearn.svm import LinearSVC
&gt;&gt;&gt; iris = datasets.load_iris()
&gt;&gt;&gt; X, y = iris.data, iris.target
&gt;&gt;&gt; clf = OutputCodeClassifier(LinearSVC(random_state=0),
...                            code_size=2, random_state=0)
&gt;&gt;&gt; clf.fit(X, y).predict(X)
array([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
       0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
       0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 1, 1,
       1, 2, 1, 1, 1, 1, 1, 1, 2, 1, 1, 1, 1, 1, 2, 2, 2, 1, 1, 1, 1, 1, 1,
       1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
       2, 2, 2, 2, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 2, 2, 2, 1, 1, 2, 2, 2,
       2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2])
</pre> <div class="topic"> <p class="topic-title first">References:</p> <table class="docutils footnote" frame="void" id="id5" rules="none">   <tr>
<td class="label">[2]</td>
<td>“Solving multiclass learning problems via error-correcting output codes”, Dietterich T., Bakiri G., Journal of Artificial Intelligence Research 2, 1995.</td>
</tr>  </table> <table class="docutils footnote" frame="void" id="id6" rules="none">   <tr>
<td class="label"><a class="fn-backref" href="#id3">[3]</a></td>
<td>“The error coding method and PICTs”, James G., Hastie T., Journal of Computational and Graphical statistics 7, 1998.</td>
</tr>  </table> <table class="docutils footnote" frame="void" id="id7" rules="none">   <tr>
<td class="label">[4]</td>
<td>“The Elements of Statistical Learning”, Hastie T., Tibshirani R., Friedman J., page 606 (second-edition) 2008.</td>
</tr>  </table> </div>    <h2 id="multioutput-regression">1.12.5. Multioutput regression</h2> <p>Multioutput regression support can be added to any regressor with <code>MultiOutputRegressor</code>. This strategy consists of fitting one regressor per target. Since each target is represented by exactly one regressor it is possible to gain knowledge about the target by inspecting its corresponding regressor. As <code>MultiOutputRegressor</code> fits one regressor per target it can not take advantage of correlations between targets.</p> <p>Below is an example of multioutput regression:</p> <pre data-language="python">&gt;&gt;&gt; from sklearn.datasets import make_regression
&gt;&gt;&gt; from sklearn.multioutput import MultiOutputRegressor
&gt;&gt;&gt; from sklearn.ensemble import GradientBoostingRegressor
&gt;&gt;&gt; X, y = make_regression(n_samples=10, n_targets=3, random_state=1)
&gt;&gt;&gt; MultiOutputRegressor(GradientBoostingRegressor(random_state=0)).fit(X, y).predict(X)
array([[-154.75474165, -147.03498585,  -50.03812219],
       [   7.12165031,    5.12914884,  -81.46081961],
       [-187.8948621 , -100.44373091,   13.88978285],
       [-141.62745778,   95.02891072, -191.48204257],
       [  97.03260883,  165.34867495,  139.52003279],
       [ 123.92529176,   21.25719016,   -7.84253   ],
       [-122.25193977,  -85.16443186, -107.12274212],
       [ -30.170388  ,  -94.80956739,   12.16979946],
       [ 140.72667194,  176.50941682,  -17.50447799],
       [ 149.37967282,  -81.15699552,   -5.72850319]])
</pre>   <h2 id="multioutput-classification">1.12.6. Multioutput classification</h2> <p>Multioutput classification support can be added to any classifier with <code>MultiOutputClassifier</code>. This strategy consists of fitting one classifier per target. This allows multiple target variable classifications. The purpose of this class is to extend estimators to be able to estimate a series of target functions (f1,f2,f3...,fn) that are trained on a single X predictor matrix to predict a series of reponses (y1,y2,y3...,yn).</p> <p>Below is an example of multioutput classification:</p> <pre data-language="python">&gt;&gt;&gt; from sklearn.datasets import make_classification
&gt;&gt;&gt; from sklearn.multioutput import MultiOutputClassifier
&gt;&gt;&gt; from sklearn.ensemble import RandomForestClassifier
&gt;&gt;&gt; from sklearn.utils import shuffle
&gt;&gt;&gt; import numpy as np
&gt;&gt;&gt; X, y1 = make_classification(n_samples=10, n_features=100, n_informative=30, n_classes=3, random_state=1)
&gt;&gt;&gt; y2 = shuffle(y1, random_state=1)
&gt;&gt;&gt; y3 = shuffle(y1, random_state=2)
&gt;&gt;&gt; Y = np.vstack((y1, y2, y3)).T
&gt;&gt;&gt; n_samples, n_features = X.shape # 10,100
&gt;&gt;&gt; n_outputs = Y.shape[1] # 3
&gt;&gt;&gt; n_classes = 3
&gt;&gt;&gt; forest = RandomForestClassifier(n_estimators=100, random_state=1)
&gt;&gt;&gt; multi_target_forest = MultiOutputClassifier(forest, n_jobs=-1)
&gt;&gt;&gt; multi_target_forest.fit(X, Y).predict(X)
array([[2, 2, 0],
       [1, 2, 1],
       [2, 1, 0],
       [0, 0, 2],
       [0, 2, 1],
       [0, 0, 2],
       [1, 1, 0],
       [1, 1, 1],
       [0, 0, 2],
       [2, 0, 0]])
</pre>
<div class="_attribution">
  <p class="_attribution-p">
    © 2007–2016 The scikit-learn developers<br>Licensed under the 3-clause BSD License.<br>
    <a href="http://scikit-learn.org/stable/modules/multiclass.html" class="_attribution-link" target="_blank">http://scikit-learn.org/stable/modules/multiclass.html</a>
  </p>
</div>

			</div>
		</div>
	</section>

	</div>
</body>
</html>
