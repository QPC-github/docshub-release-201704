
<!DOCTYPE HTML>

<html lang="en">

<head>
  <meta charset="utf-8">
  <title>2.3. Clustering - Scikit-learn - W3cubDocs</title>
  
  <meta name="description" content=" Clustering of unlabeled data can be performed with the module sklearn.cluster. ">
  <meta name="keywords" content="clustering, -, scikit-learn, scikit_learn">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="http://docs.w3cub.com/scikit_learn/modules/clustering/">
  <link href="/favicon.png" rel="icon">
  <link type="text/css" rel="stylesheet" href="/assets/application-50364fff564ce3b6327021805f3f00e2957b441cf27f576a7dd4ff63bbc47047.css">
  <script type="text/javascript" src="/assets/application-db64bfd54ceb42be11af7995804cf4902548419ceb79d509b0b7d62c22d98e6f.js"></script>
  <script src="/json/scikit_learn.js"></script>
  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-71174418-1']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>


</head>

<body>
	<div class="_app">
	<header class="_header">
  
  <form class="_search">
    <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
    <a class="_search-clear"></a>
    <div class="_search-tag"></div>
  </form>
  
  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/scikit_learn/" class="_nav-link" title="" style="margin-left:0;">scikit-learn</a></span>
  
  <nav class="_nav">
    <a href="/app/" class="_nav-link ">App</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		<div class="_list">
			
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<div class="_page _sphinx">
				
<h1 id="id1">2.3. Clustering</h1> <p id="clustering"><a class="reference external" href="https://en.wikipedia.org/wiki/Cluster_analysis" target="_blank">Clustering</a> of unlabeled data can be performed with the module <a class="reference internal" href="../classes/#module-sklearn.cluster" title="sklearn.cluster"><code>sklearn.cluster</code></a>.</p> <p>Each clustering algorithm comes in two variants: a class, that implements the <code>fit</code> method to learn the clusters on train data, and a function, that, given train data, returns an array of integer labels corresponding to the different clusters. For the class, the labels over the training data can be found in the <code>labels_</code> attribute.</p> <div class="topic"> <p class="topic-title first">Input data</p> <p>One important thing to note is that the algorithms implemented in this module can take different kinds of matrix as input. All the methods accept standard data matrices of shape <code>[n_samples, n_features]</code>. These can be obtained from the classes in the <a class="reference internal" href="../classes/#module-sklearn.feature_extraction" title="sklearn.feature_extraction"><code>sklearn.feature_extraction</code></a> module. For <a class="reference internal" href="../generated/sklearn.cluster.affinitypropagation/#sklearn.cluster.AffinityPropagation" title="sklearn.cluster.AffinityPropagation"><code>AffinityPropagation</code></a>, <a class="reference internal" href="../generated/sklearn.cluster.spectralclustering/#sklearn.cluster.SpectralClustering" title="sklearn.cluster.SpectralClustering"><code>SpectralClustering</code></a> and <a class="reference internal" href="../generated/sklearn.cluster.dbscan/#sklearn.cluster.DBSCAN" title="sklearn.cluster.DBSCAN"><code>DBSCAN</code></a> one can also input similarity matrices of shape <code>[n_samples, n_samples]</code>. These can be obtained from the functions in the <a class="reference internal" href="../classes/#module-sklearn.metrics.pairwise" title="sklearn.metrics.pairwise"><code>sklearn.metrics.pairwise</code></a> module.</p> </div>  <h2 id="overview-of-clustering-methods">2.3.1. Overview of clustering methods</h2> <div class="figure align-center" id="id25"> <a class="reference external image-reference" href="../../auto_examples/cluster/plot_cluster_comparison/"><img alt="../_images/sphx_glr_plot_cluster_comparison_0011.png" src="http://scikit-learn.org/stable/_images/sphx_glr_plot_cluster_comparison_0011.png" style="width: 950.0px; height: 475.0px;"></a> <p class="caption"><span class="caption-text">A comparison of the clustering algorithms in scikit-learn</span></p> </div> <table class="docutils">  <thead valign="bottom"> <tr class="row-odd">
<th class="head">Method name</th> <th class="head">Parameters</th> <th class="head">Scalability</th> <th class="head">Usecase</th> <th class="head">Geometry (metric used)</th> </tr> </thead>  <tr class="row-even">
<td><a class="reference internal" href="#k-means"><span class="std std-ref">K-Means</span></a></td> <td>number of clusters</td> <td>Very large <code>n_samples</code>, medium <code>n_clusters</code> with <a class="reference internal" href="#mini-batch-kmeans"><span class="std std-ref">MiniBatch code</span></a>
</td> <td>General-purpose, even cluster size, flat geometry, not too many clusters</td> <td>Distances between points</td> </tr> <tr class="row-odd">
<td><a class="reference internal" href="#affinity-propagation"><span class="std std-ref">Affinity propagation</span></a></td> <td>damping, sample preference</td> <td>Not scalable with n_samples</td> <td>Many clusters, uneven cluster size, non-flat geometry</td> <td>Graph distance (e.g. nearest-neighbor graph)</td> </tr> <tr class="row-even">
<td><a class="reference internal" href="#mean-shift"><span class="std std-ref">Mean-shift</span></a></td> <td>bandwidth</td> <td>Not scalable with <code>n_samples</code>
</td> <td>Many clusters, uneven cluster size, non-flat geometry</td> <td>Distances between points</td> </tr> <tr class="row-odd">
<td><a class="reference internal" href="#spectral-clustering"><span class="std std-ref">Spectral clustering</span></a></td> <td>number of clusters</td> <td>Medium <code>n_samples</code>, small <code>n_clusters</code>
</td> <td>Few clusters, even cluster size, non-flat geometry</td> <td>Graph distance (e.g. nearest-neighbor graph)</td> </tr> <tr class="row-even">
<td><a class="reference internal" href="#hierarchical-clustering"><span class="std std-ref">Ward hierarchical clustering</span></a></td> <td>number of clusters</td> <td>Large <code>n_samples</code> and <code>n_clusters</code>
</td> <td>Many clusters, possibly connectivity constraints</td> <td>Distances between points</td> </tr> <tr class="row-odd">
<td><a class="reference internal" href="#hierarchical-clustering"><span class="std std-ref">Agglomerative clustering</span></a></td> <td>number of clusters, linkage type, distance</td> <td>Large <code>n_samples</code> and <code>n_clusters</code>
</td> <td>Many clusters, possibly connectivity constraints, non Euclidean distances</td> <td>Any pairwise distance</td> </tr> <tr class="row-even">
<td><a class="reference internal" href="#dbscan"><span class="std std-ref">DBSCAN</span></a></td> <td>neighborhood size</td> <td>Very large <code>n_samples</code>, medium <code>n_clusters</code>
</td> <td>Non-flat geometry, uneven cluster sizes</td> <td>Distances between nearest points</td> </tr> <tr class="row-odd">
<td><a class="reference internal" href="../mixture/#mixture"><span class="std std-ref">Gaussian mixtures</span></a></td> <td>many</td> <td>Not scalable</td> <td>Flat geometry, good for density estimation</td> <td>Mahalanobis distances to centers</td> </tr> <tr class="row-even">
<td><a class="reference internal" href="#birch"><span class="std std-ref">Birch</span></a></td> <td>branching factor, threshold, optional global clusterer.</td> <td>Large <code>n_clusters</code> and <code>n_samples</code>
</td> <td>Large dataset, outlier removal, data reduction.</td> <td>Euclidean distance between points</td> </tr>  </table> <p>Non-flat geometry clustering is useful when the clusters have a specific shape, i.e. a non-flat manifold, and the standard euclidean distance is not the right metric. This case arises in the two top rows of the figure above.</p> <p>Gaussian mixture models, useful for clustering, are described in <a class="reference internal" href="../mixture/#mixture"><span class="std std-ref">another chapter of the documentation</span></a> dedicated to mixture models. KMeans can be seen as a special case of Gaussian mixture model with equal covariance per component.</p>   <h2 id="id2">2.3.2. K-means</h2> <p id="k-means">The <a class="reference internal" href="../generated/sklearn.cluster.kmeans/#sklearn.cluster.KMeans" title="sklearn.cluster.KMeans"><code>KMeans</code></a> algorithm clusters data by trying to separate samples in n groups of equal variance, minimizing a criterion known as the <a class="reference external" href="../inertia/">inertia</a> or within-cluster sum-of-squares. This algorithm requires the number of clusters to be specified. It scales well to large number of samples and has been used across a large range of application areas in many different fields.</p> <p>The k-means algorithm divides a set of <img class="math" src="http://scikit-learn.org/stable/_images/math/f4170ed8938b79490d8923857962695514a8e4cb.png" alt="N"> samples <img class="math" src="http://scikit-learn.org/stable/_images/math/7a7bb470119808e2db2879fc2b2526f467b7a40b.png" alt="X"> into <img class="math" src="http://scikit-learn.org/stable/_images/math/684381a21cd73ebbf43b63a087d3f7410ee99ce8.png" alt="K"> disjoint clusters <img class="math" src="http://scikit-learn.org/stable/_images/math/afce44aa7c55836ca9345404c22fc7b599d2ed84.png" alt="C">, each described by the mean <img class="math" src="http://scikit-learn.org/stable/_images/math/169afc05a24e52e428b94e0041ab0577a2d580ee.png" alt="\mu_j"> of the samples in the cluster. The means are commonly called the cluster “centroids”; note that they are not, in general, points from <img class="math" src="http://scikit-learn.org/stable/_images/math/7a7bb470119808e2db2879fc2b2526f467b7a40b.png" alt="X">, although they live in the same space. The K-means algorithm aims to choose centroids that minimise the <em>inertia</em>, or within-cluster sum of squared criterion:</p> <div class="math"> <p><img src="http://scikit-learn.org/stable/_images/math/1886f2c69775746ac7b6c1cdd88c53c676839015.png" alt="\sum_{i=0}^{n}\min_{\mu_j \in C}(||x_j - \mu_i||^2)"></p> </div>
<p>Inertia, or the within-cluster sum of squares criterion, can be recognized as a measure of how internally coherent clusters are. It suffers from various drawbacks:</p> <ul class="simple"> <li>Inertia makes the assumption that clusters are convex and isotropic, which is not always the case. It responds poorly to elongated clusters, or manifolds with irregular shapes.</li> <li>Inertia is not a normalized metric: we just know that lower values are better and zero is optimal. But in very high-dimensional spaces, Euclidean distances tend to become inflated (this is an instance of the so-called “curse of dimensionality”). Running a dimensionality reduction algorithm such as <a class="reference external" href="../pca/">PCA</a> prior to k-means clustering can alleviate this problem and speed up the computations.</li> </ul> <a class="reference external image-reference" href="../../auto_examples/cluster/plot_kmeans_assumptions/"><img alt="../_images/sphx_glr_plot_kmeans_assumptions_0011.png" class="align-center" src="http://scikit-learn.org/stable/_images/sphx_glr_plot_kmeans_assumptions_0011.png" style="width: 600.0px; height: 600.0px;"></a> <p>K-means is often referred to as Lloyd’s algorithm. In basic terms, the algorithm has three steps. The first step chooses the initial centroids, with the most basic method being to choose <img class="math" src="http://scikit-learn.org/stable/_images/math/0b7c1e16a3a8a849bb8ffdcdbf86f65fd1f30438.png" alt="k"> samples from the dataset <img class="math" src="http://scikit-learn.org/stable/_images/math/7a7bb470119808e2db2879fc2b2526f467b7a40b.png" alt="X">. After initialization, K-means consists of looping between the two other steps. The first step assigns each sample to its nearest centroid. The second step creates new centroids by taking the mean value of all of the samples assigned to each previous centroid. The difference between the old and the new centroids are computed and the algorithm repeats these last two steps until this value is less than a threshold. In other words, it repeats until the centroids do not move significantly.</p> <a class="reference external image-reference" href="../../auto_examples/cluster/plot_kmeans_digits/"><img alt="../_images/sphx_glr_plot_kmeans_digits_0011.png" class="align-right" src="http://scikit-learn.org/stable/_images/sphx_glr_plot_kmeans_digits_0011.png" style="width: 280.0px; height: 210.0px;"></a> <p>K-means is equivalent to the expectation-maximization algorithm with a small, all-equal, diagonal covariance matrix.</p> <p>The algorithm can also be understood through the concept of <a class="reference external" href="https://en.wikipedia.org/wiki/Voronoi_diagram" target="_blank">Voronoi diagrams</a>. First the Voronoi diagram of the points is calculated using the current centroids. Each segment in the Voronoi diagram becomes a separate cluster. Secondly, the centroids are updated to the mean of each segment. The algorithm then repeats this until a stopping criterion is fulfilled. Usually, the algorithm stops when the relative decrease in the objective function between iterations is less than the given tolerance value. This is not the case in this implementation: iteration stops when centroids move less than the tolerance.</p> <p>Given enough time, K-means will always converge, however this may be to a local minimum. This is highly dependent on the initialization of the centroids. As a result, the computation is often done several times, with different initializations of the centroids. One method to help address this issue is the k-means++ initialization scheme, which has been implemented in scikit-learn (use the <code>init='kmeans++'</code> parameter). This initializes the centroids to be (generally) distant from each other, leading to provably better results than random initialization, as shown in the reference.</p> <p>A parameter can be given to allow K-means to be run in parallel, called <code>n_jobs</code>. Giving this parameter a positive value uses that many processors (default: 1). A value of -1 uses all available processors, with -2 using one less, and so on. Parallelization generally speeds up computation at the cost of memory (in this case, multiple copies of centroids need to be stored, one for each job).</p> <div class="admonition warning"> <p class="first admonition-title">Warning</p> <p class="last">The parallel version of K-Means is broken on OS X when <code>numpy</code> uses the <code>Accelerate</code> Framework. This is expected behavior: <code>Accelerate</code> can be called after a fork but you need to execv the subprocess with the Python binary (which multiprocessing does not do under posix).</p> </div> <p>K-means can be used for vector quantization. This is achieved using the transform method of a trained model of <a class="reference internal" href="../generated/sklearn.cluster.kmeans/#sklearn.cluster.KMeans" title="sklearn.cluster.KMeans"><code>KMeans</code></a>.</p> <div class="topic"> <p class="topic-title first">Examples:</p> <ul class="simple"> <li>
<a class="reference internal" href="../../auto_examples/cluster/plot_kmeans_assumptions/#sphx-glr-auto-examples-cluster-plot-kmeans-assumptions-py"><span class="std std-ref">Demonstration of k-means assumptions</span></a>: Demonstrating when k-means performs intuitively and when it does not</li> <li>
<a class="reference internal" href="../../auto_examples/cluster/plot_kmeans_digits/#sphx-glr-auto-examples-cluster-plot-kmeans-digits-py"><span class="std std-ref">A demo of K-Means clustering on the handwritten digits data</span></a>: Clustering handwritten digits</li> </ul> </div> <div class="topic"> <p class="topic-title first">References:</p> <ul class="simple"> <li>
<a class="reference external" href="http://ilpubs.stanford.edu:8090/778/1/2006-13.pdf" target="_blank">“k-means++: The advantages of careful seeding”</a> Arthur, David, and Sergei Vassilvitskii, <em>Proceedings of the eighteenth annual ACM-SIAM symposium on Discrete algorithms</em>, Society for Industrial and Applied Mathematics (2007)</li> </ul> </div>  <h3 id="mini-batch-kmeans">2.3.2.1. Mini Batch K-Means</h3> <p id="mini-batch-k-means">The <a class="reference internal" href="../generated/sklearn.cluster.minibatchkmeans/#sklearn.cluster.MiniBatchKMeans" title="sklearn.cluster.MiniBatchKMeans"><code>MiniBatchKMeans</code></a> is a variant of the <a class="reference internal" href="../generated/sklearn.cluster.kmeans/#sklearn.cluster.KMeans" title="sklearn.cluster.KMeans"><code>KMeans</code></a> algorithm which uses mini-batches to reduce the computation time, while still attempting to optimise the same objective function. Mini-batches are subsets of the input data, randomly sampled in each training iteration. These mini-batches drastically reduce the amount of computation required to converge to a local solution. In contrast to other algorithms that reduce the convergence time of k-means, mini-batch k-means produces results that are generally only slightly worse than the standard algorithm.</p> <p>The algorithm iterates between two major steps, similar to vanilla k-means. In the first step, <img class="math" src="http://scikit-learn.org/stable/_images/math/57c9d14bb082716df9000146882ce365335d08f1.png" alt="b"> samples are drawn randomly from the dataset, to form a mini-batch. These are then assigned to the nearest centroid. In the second step, the centroids are updated. In contrast to k-means, this is done on a per-sample basis. For each sample in the mini-batch, the assigned centroid is updated by taking the streaming average of the sample and all previous samples assigned to that centroid. This has the effect of decreasing the rate of change for a centroid over time. These steps are performed until convergence or a predetermined number of iterations is reached.</p> <p><a class="reference internal" href="../generated/sklearn.cluster.minibatchkmeans/#sklearn.cluster.MiniBatchKMeans" title="sklearn.cluster.MiniBatchKMeans"><code>MiniBatchKMeans</code></a> converges faster than <a class="reference internal" href="../generated/sklearn.cluster.kmeans/#sklearn.cluster.KMeans" title="sklearn.cluster.KMeans"><code>KMeans</code></a>, but the quality of the results is reduced. In practice this difference in quality can be quite small, as shown in the example and cited reference.</p> <div class="figure align-center"> <a class="reference external image-reference" href="../../auto_examples/cluster/plot_mini_batch_kmeans/"><img alt="../_images/sphx_glr_plot_mini_batch_kmeans_0011.png" src="http://scikit-learn.org/stable/_images/sphx_glr_plot_mini_batch_kmeans_0011.png" style="width: 800.0px; height: 300.0px;"></a> </div> <div class="topic"> <p class="topic-title first">Examples:</p> <ul class="simple"> <li>
<a class="reference internal" href="../../auto_examples/cluster/plot_mini_batch_kmeans/#sphx-glr-auto-examples-cluster-plot-mini-batch-kmeans-py"><span class="std std-ref">Comparison of the K-Means and MiniBatchKMeans clustering algorithms</span></a>: Comparison of KMeans and MiniBatchKMeans</li> <li>
<a class="reference internal" href="../../auto_examples/text/document_clustering/#sphx-glr-auto-examples-text-document-clustering-py"><span class="std std-ref">Clustering text documents using k-means</span></a>: Document clustering using sparse MiniBatchKMeans</li> <li><a class="reference internal" href="../../auto_examples/cluster/plot_dict_face_patches/#sphx-glr-auto-examples-cluster-plot-dict-face-patches-py"><span class="std std-ref">Online learning of a dictionary of parts of faces</span></a></li> </ul> </div> <div class="topic"> <p class="topic-title first">References:</p> <ul class="simple"> <li>
<a class="reference external" href="http://www.eecs.tufts.edu/~dsculley/papers/fastkmeans.pdf" target="_blank">“Web Scale K-Means clustering”</a> D. Sculley, <em>Proceedings of the 19th international conference on World wide web</em> (2010)</li> </ul> </div>    <h2 id="id3">2.3.3. Affinity Propagation</h2> <p id="affinity-propagation"><a class="reference internal" href="../generated/sklearn.cluster.affinitypropagation/#sklearn.cluster.AffinityPropagation" title="sklearn.cluster.AffinityPropagation"><code>AffinityPropagation</code></a> creates clusters by sending messages between pairs of samples until convergence. A dataset is then described using a small number of exemplars, which are identified as those most representative of other samples. The messages sent between pairs represent the suitability for one sample to be the exemplar of the other, which is updated in response to the values from other pairs. This updating happens iteratively until convergence, at which point the final exemplars are chosen, and hence the final clustering is given.</p> <div class="figure align-center"> <a class="reference external image-reference" href="../../auto_examples/cluster/plot_affinity_propagation/"><img alt="../_images/sphx_glr_plot_affinity_propagation_0011.png" src="http://scikit-learn.org/stable/_images/sphx_glr_plot_affinity_propagation_0011.png" style="width: 400.0px; height: 300.0px;"></a> </div> <p>Affinity Propagation can be interesting as it chooses the number of clusters based on the data provided. For this purpose, the two important parameters are the <em>preference</em>, which controls how many exemplars are used, and the <em>damping factor</em>.</p> <p>The main drawback of Affinity Propagation is its complexity. The algorithm has a time complexity of the order <img class="math" src="http://scikit-learn.org/stable/_images/math/17245ed0c52b27603fc90accab918af090e79b39.png" alt="O(N^2 T)">, where <img class="math" src="http://scikit-learn.org/stable/_images/math/f4170ed8938b79490d8923857962695514a8e4cb.png" alt="N"> is the number of samples and <img class="math" src="http://scikit-learn.org/stable/_images/math/f2d283a2071f9d043c9e0b0f794a8880fa0d3ce9.png" alt="T"> is the number of iterations until convergence. Further, the memory complexity is of the order <img class="math" src="http://scikit-learn.org/stable/_images/math/f931697f3e36486c3b380c8e5faa4ad1fe8536d8.png" alt="O(N^2)"> if a dense similarity matrix is used, but reducible if a sparse similarity matrix is used. This makes Affinity Propagation most appropriate for small to medium sized datasets.</p> <div class="topic"> <p class="topic-title first">Examples:</p> <ul class="simple"> <li>
<a class="reference internal" href="../../auto_examples/cluster/plot_affinity_propagation/#sphx-glr-auto-examples-cluster-plot-affinity-propagation-py"><span class="std std-ref">Demo of affinity propagation clustering algorithm</span></a>: Affinity Propagation on a synthetic 2D datasets with 3 classes.</li> <li>
<a class="reference internal" href="../../auto_examples/applications/plot_stock_market/#sphx-glr-auto-examples-applications-plot-stock-market-py"><span class="std std-ref">Visualizing the stock market structure</span></a> Affinity Propagation on Financial time series to find groups of companies</li> </ul> </div> <p><strong>Algorithm description:</strong> The messages sent between points belong to one of two categories. The first is the responsibility <img class="math" src="http://scikit-learn.org/stable/_images/math/096ac3dbab1fd906329dd9179a2328cf7e1bc702.png" alt="r(i, k)">, which is the accumulated evidence that sample <img class="math" src="http://scikit-learn.org/stable/_images/math/0b7c1e16a3a8a849bb8ffdcdbf86f65fd1f30438.png" alt="k"> should be the exemplar for sample <img class="math" src="http://scikit-learn.org/stable/_images/math/df0deb143e5ac127f00bd248ee8001ecae572adc.png" alt="i">. The second is the availability <img class="math" src="http://scikit-learn.org/stable/_images/math/d457377199e4598caea3edd6836865f4c3dd409e.png" alt="a(i, k)"> which is the accumulated evidence that sample <img class="math" src="http://scikit-learn.org/stable/_images/math/df0deb143e5ac127f00bd248ee8001ecae572adc.png" alt="i"> should choose sample <img class="math" src="http://scikit-learn.org/stable/_images/math/0b7c1e16a3a8a849bb8ffdcdbf86f65fd1f30438.png" alt="k"> to be its exemplar, and considers the values for all other samples that <img class="math" src="http://scikit-learn.org/stable/_images/math/0b7c1e16a3a8a849bb8ffdcdbf86f65fd1f30438.png" alt="k"> should be an exemplar. In this way, exemplars are chosen by samples if they are (1) similar enough to many samples and (2) chosen by many samples to be representative of themselves.</p> <p>More formally, the responsibility of a sample <img class="math" src="http://scikit-learn.org/stable/_images/math/0b7c1e16a3a8a849bb8ffdcdbf86f65fd1f30438.png" alt="k"> to be the exemplar of sample <img class="math" src="http://scikit-learn.org/stable/_images/math/df0deb143e5ac127f00bd248ee8001ecae572adc.png" alt="i"> is given by:</p> <div class="math"> <p><img src="http://scikit-learn.org/stable/_images/math/6e844968a4ec7af98ad0ba474c3e78b68b6aa643.png" alt="r(i, k) \leftarrow s(i, k) - max [ a(i, \acute{k}) + s(i, \acute{k}) \forall \acute{k} \neq k ]"></p> </div>
<p>Where <img class="math" src="http://scikit-learn.org/stable/_images/math/41f0cafe8618e44e80191564dc11d6365b618ade.png" alt="s(i, k)"> is the similarity between samples <img class="math" src="http://scikit-learn.org/stable/_images/math/df0deb143e5ac127f00bd248ee8001ecae572adc.png" alt="i"> and <img class="math" src="http://scikit-learn.org/stable/_images/math/0b7c1e16a3a8a849bb8ffdcdbf86f65fd1f30438.png" alt="k">. The availability of sample <img class="math" src="http://scikit-learn.org/stable/_images/math/0b7c1e16a3a8a849bb8ffdcdbf86f65fd1f30438.png" alt="k"> to be the exemplar of sample <img class="math" src="http://scikit-learn.org/stable/_images/math/df0deb143e5ac127f00bd248ee8001ecae572adc.png" alt="i"> is given by:</p> <div class="math"> <p><img src="http://scikit-learn.org/stable/_images/math/937cb41cd85b9c33172c81801360ababa7a2c803.png" alt="a(i, k) \leftarrow min [0, r(k, k) + \sum_{\acute{i}~s.t.~\acute{i} \notin \{i, k\}}{r(\acute{i}, k)}]"></p> </div>
<p>To begin with, all values for <img class="math" src="http://scikit-learn.org/stable/_images/math/eaa6ad49a7f78fe5a13b486690163bf2dc7e3e60.png" alt="r"> and <img class="math" src="http://scikit-learn.org/stable/_images/math/bd9d9c7512c898e0a254a0882184197bc1bd9c9f.png" alt="a"> are set to zero, and the calculation of each iterates until convergence.</p>   <h2 id="id4">2.3.4. Mean Shift</h2> <p id="mean-shift"><a class="reference internal" href="../generated/sklearn.cluster.meanshift/#sklearn.cluster.MeanShift" title="sklearn.cluster.MeanShift"><code>MeanShift</code></a> clustering aims to discover <em>blobs</em> in a smooth density of samples. It is a centroid based algorithm, which works by updating candidates for centroids to be the mean of the points within a given region. These candidates are then filtered in a post-processing stage to eliminate near-duplicates to form the final set of centroids.</p> <p>Given a candidate centroid <img class="math" src="http://scikit-learn.org/stable/_images/math/7720e563212e11bf72de255ab82c2a3b97c1a7f5.png" alt="x_i"> for iteration <img class="math" src="http://scikit-learn.org/stable/_images/math/5ec053cf70dc1c98cc297322250569eda193e7a4.png" alt="t">, the candidate is updated according to the following equation:</p> <div class="math"> <p><img src="http://scikit-learn.org/stable/_images/math/df67cad6c90923bd6d5dd1ba1cc98b73ba772bd8.png" alt="x_i^{t+1} = x_i^t + m(x_i^t)"></p> </div>
<p>Where <img class="math" src="http://scikit-learn.org/stable/_images/math/8a4fb6733cef4f61dc7068488842e4ed7e454816.png" alt="N(x_i)"> is the neighborhood of samples within a given distance around <img class="math" src="http://scikit-learn.org/stable/_images/math/7720e563212e11bf72de255ab82c2a3b97c1a7f5.png" alt="x_i"> and <img class="math" src="http://scikit-learn.org/stable/_images/math/edba97b4c0d864d26e92ea7ea73767fa38eef3f7.png" alt="m"> is the <em>mean shift</em> vector that is computed for each centroid that points towards a region of the maximum increase in the density of points. This is computed using the following equation, effectively updating a centroid to be the mean of the samples within its neighborhood:</p> <div class="math"> <p><img src="http://scikit-learn.org/stable/_images/math/64f9e995cea2b11641d37f2ec1cfcf1d590d2797.png" alt="m(x_i) = \frac{\sum_{x_j \in N(x_i)}K(x_j - x_i)x_j}{\sum_{x_j \in N(x_i)}K(x_j - x_i)}"></p> </div>
<p>The algorithm automatically sets the number of clusters, instead of relying on a parameter <code>bandwidth</code>, which dictates the size of the region to search through. This parameter can be set manually, but can be estimated using the provided <code>estimate_bandwidth</code> function, which is called if the bandwidth is not set.</p> <p>The algorithm is not highly scalable, as it requires multiple nearest neighbor searches during the execution of the algorithm. The algorithm is guaranteed to converge, however the algorithm will stop iterating when the change in centroids is small.</p> <p>Labelling a new sample is performed by finding the nearest centroid for a given sample.</p> <div class="figure align-center"> <a class="reference external image-reference" href="../../auto_examples/cluster/plot_mean_shift/"><img alt="../_images/sphx_glr_plot_mean_shift_0011.png" src="http://scikit-learn.org/stable/_images/sphx_glr_plot_mean_shift_0011.png" style="width: 400.0px; height: 300.0px;"></a> </div> <div class="topic"> <p class="topic-title first">Examples:</p> <ul class="simple"> <li>
<a class="reference internal" href="../../auto_examples/cluster/plot_mean_shift/#sphx-glr-auto-examples-cluster-plot-mean-shift-py"><span class="std std-ref">A demo of the mean-shift clustering algorithm</span></a>: Mean Shift clustering on a synthetic 2D datasets with 3 classes.</li> </ul> </div> <div class="topic"> <p class="topic-title first">References:</p> <ul class="simple"> <li>
<a class="reference external" href="http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.76.8968&amp;rep=rep1&amp;type=pdf" target="_blank">“Mean shift: A robust approach toward feature space analysis.”</a> D. Comaniciu and P. Meer, <em>IEEE Transactions on Pattern Analysis and Machine Intelligence</em> (2002)</li> </ul> </div>   <h2 id="id5">2.3.5. Spectral clustering</h2> <p id="spectral-clustering"><a class="reference internal" href="../generated/sklearn.cluster.spectralclustering/#sklearn.cluster.SpectralClustering" title="sklearn.cluster.SpectralClustering"><code>SpectralClustering</code></a> does a low-dimension embedding of the affinity matrix between samples, followed by a KMeans in the low dimensional space. It is especially efficient if the affinity matrix is sparse and the <a class="reference external" href="http://pyamg.org/" target="_blank">pyamg</a> module is installed. SpectralClustering requires the number of clusters to be specified. It works well for a small number of clusters but is not advised when using many clusters.</p> <p>For two clusters, it solves a convex relaxation of the <a class="reference external" href="http://people.eecs.berkeley.edu/~malik/papers/SM-ncut.pdf" target="_blank">normalised cuts</a> problem on the similarity graph: cutting the graph in two so that the weight of the edges cut is small compared to the weights of the edges inside each cluster. This criteria is especially interesting when working on images: graph vertices are pixels, and edges of the similarity graph are a function of the gradient of the image.</p> <p class="centered"> <strong><a class="reference external" href="../../auto_examples/cluster/plot_segmentation_toy/"><img alt="noisy_img" src="http://scikit-learn.org/stable/_images/sphx_glr_plot_segmentation_toy_0011.png" style="width: 300.0px; height: 300.0px;"></a> <a class="reference external" href="../../auto_examples/cluster/plot_segmentation_toy/"><img alt="segmented_img" src="http://scikit-learn.org/stable/_images/sphx_glr_plot_segmentation_toy_0021.png" style="width: 300.0px; height: 300.0px;"></a></strong></p>
<div class="admonition warning"> <p class="first admonition-title">Warning</p> <p>Transforming distance to well-behaved similarities</p> <p>Note that if the values of your similarity matrix are not well distributed, e.g. with negative values or with a distance matrix rather than a similarity, the spectral problem will be singular and the problem not solvable. In which case it is advised to apply a transformation to the entries of the matrix. For instance, in the case of a signed distance matrix, is common to apply a heat kernel:</p> <pre data-language="python">similarity = np.exp(-beta * distance / distance.std())
</pre> <p class="last">See the examples for such an application.</p> </div> <div class="topic"> <p class="topic-title first">Examples:</p> <ul class="simple"> <li>
<a class="reference internal" href="../../auto_examples/cluster/plot_segmentation_toy/#sphx-glr-auto-examples-cluster-plot-segmentation-toy-py"><span class="std std-ref">Spectral clustering for image segmentation</span></a>: Segmenting objects from a noisy background using spectral clustering.</li> <li>
<a class="reference internal" href="../../auto_examples/cluster/plot_face_segmentation/#sphx-glr-auto-examples-cluster-plot-face-segmentation-py"><span class="std std-ref">Segmenting the picture of a raccoon face in regions</span></a>: Spectral clustering to split the image of the raccoon face in regions.</li> </ul> </div>  <h3 id="different-label-assignment-strategies">2.3.5.1. Different label assignment strategies</h3> <p>Different label assignment strategies can be used, corresponding to the <code>assign_labels</code> parameter of <a class="reference internal" href="../generated/sklearn.cluster.spectralclustering/#sklearn.cluster.SpectralClustering" title="sklearn.cluster.SpectralClustering"><code>SpectralClustering</code></a>. The <code>"kmeans"</code> strategy can match finer details of the data, but it can be more unstable. In particular, unless you control the <code>random_state</code>, it may not be reproducible from run-to-run, as it depends on a random initialization. On the other hand, the <code>"discretize"</code> strategy is 100% reproducible, but it tends to create parcels of fairly even and geometrical shape.</p> <table class="docutils">  <thead valign="bottom"> <tr class="row-odd">
<th class="head"><code>assign_labels="kmeans"</code></th> <th class="head"><code>assign_labels="discretize"</code></th> </tr> </thead>  <tr class="row-even">
<td><a class="reference external" href="../../auto_examples/cluster/plot_face_segmentation/"><img alt="face_kmeans" src="http://scikit-learn.org/stable/_images/sphx_glr_plot_face_segmentation_0011.png" style="width: 325.0px; height: 325.0px;"></a></td> <td><a class="reference external" href="../../auto_examples/cluster/plot_face_segmentation/"><img alt="face_discretize" src="http://scikit-learn.org/stable/_images/sphx_glr_plot_face_segmentation_0021.png" style="width: 325.0px; height: 325.0px;"></a></td> </tr>  </table> <div class="topic"> <p class="topic-title first">References:</p> <ul class="simple"> <li>
<a class="reference external" href="http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.165.9323" target="_blank">“A Tutorial on Spectral Clustering”</a> Ulrike von Luxburg, 2007</li> <li>
<a class="reference external" href="http://citeseer.ist.psu.edu/viewdoc/summary?doi=10.1.1.160.2324" target="_blank">“Normalized cuts and image segmentation”</a> Jianbo Shi, Jitendra Malik, 2000</li> <li>
<a class="reference external" href="http://citeseer.ist.psu.edu/viewdoc/summary?doi=10.1.1.33.1501" target="_blank">“A Random Walks View of Spectral Segmentation”</a> Marina Meila, Jianbo Shi, 2001</li> <li>
<a class="reference external" href="http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.19.8100" target="_blank">“On Spectral Clustering: Analysis and an algorithm”</a> Andrew Y. Ng, Michael I. Jordan, Yair Weiss, 2001</li> </ul> </div>    <h2 id="id6">2.3.6. Hierarchical clustering</h2> <p id="hierarchical-clustering">Hierarchical clustering is a general family of clustering algorithms that build nested clusters by merging or splitting them successively. This hierarchy of clusters is represented as a tree (or dendrogram). The root of the tree is the unique cluster that gathers all the samples, the leaves being the clusters with only one sample. See the <a class="reference external" href="https://en.wikipedia.org/wiki/Hierarchical_clustering" target="_blank">Wikipedia page</a> for more details.</p> <p>The <a class="reference internal" href="../generated/sklearn.cluster.agglomerativeclustering/#sklearn.cluster.AgglomerativeClustering" title="sklearn.cluster.AgglomerativeClustering"><code>AgglomerativeClustering</code></a> object performs a hierarchical clustering using a bottom up approach: each observation starts in its own cluster, and clusters are successively merged together. The linkage criteria determines the metric used for the merge strategy:</p> <ul class="simple"> <li>
<strong>Ward</strong> minimizes the sum of squared differences within all clusters. It is a variance-minimizing approach and in this sense is similar to the k-means objective function but tackled with an agglomerative hierarchical approach.</li> <li>
<strong>Maximum</strong> or <strong>complete linkage</strong> minimizes the maximum distance between observations of pairs of clusters.</li> <li>
<strong>Average linkage</strong> minimizes the average of the distances between all observations of pairs of clusters.</li> </ul> <p><a class="reference internal" href="../generated/sklearn.cluster.agglomerativeclustering/#sklearn.cluster.AgglomerativeClustering" title="sklearn.cluster.AgglomerativeClustering"><code>AgglomerativeClustering</code></a> can also scale to large number of samples when it is used jointly with a connectivity matrix, but is computationally expensive when no connectivity constraints are added between samples: it considers at each step all the possible merges.</p> <div class="topic"> <p class="topic-title first"><a class="reference internal" href="../generated/sklearn.cluster.featureagglomeration/#sklearn.cluster.FeatureAgglomeration" title="sklearn.cluster.FeatureAgglomeration"><code>FeatureAgglomeration</code></a></p> <p>The <a class="reference internal" href="../generated/sklearn.cluster.featureagglomeration/#sklearn.cluster.FeatureAgglomeration" title="sklearn.cluster.FeatureAgglomeration"><code>FeatureAgglomeration</code></a> uses agglomerative clustering to group together features that look very similar, thus decreasing the number of features. It is a dimensionality reduction tool, see <a class="reference internal" href="../unsupervised_reduction/#data-reduction"><span class="std std-ref">Unsupervised dimensionality reduction</span></a>.</p> </div>  <h3 id="different-linkage-type-ward-complete-and-average-linkage">2.3.6.1. Different linkage type: Ward, complete and average linkage</h3> <p><a class="reference internal" href="../generated/sklearn.cluster.agglomerativeclustering/#sklearn.cluster.AgglomerativeClustering" title="sklearn.cluster.AgglomerativeClustering"><code>AgglomerativeClustering</code></a> supports Ward, average, and complete linkage strategies.</p> <a class="reference external image-reference" href="../../auto_examples/cluster/plot_digits_linkage/"><img alt="../_images/sphx_glr_plot_digits_linkage_0011.png" src="http://scikit-learn.org/stable/_images/sphx_glr_plot_digits_linkage_0011.png" style="width: 258.0px; height: 172.0px;"></a> <a class="reference external image-reference" href="../../auto_examples/cluster/plot_digits_linkage/"><img alt="../_images/sphx_glr_plot_digits_linkage_0021.png" src="http://scikit-learn.org/stable/_images/sphx_glr_plot_digits_linkage_0021.png" style="width: 258.0px; height: 172.0px;"></a> <a class="reference external image-reference" href="../../auto_examples/cluster/plot_digits_linkage/"><img alt="../_images/sphx_glr_plot_digits_linkage_0031.png" src="http://scikit-learn.org/stable/_images/sphx_glr_plot_digits_linkage_0031.png" style="width: 258.0px; height: 172.0px;"></a> <p>Agglomerative cluster has a “rich get richer” behavior that leads to uneven cluster sizes. In this regard, complete linkage is the worst strategy, and Ward gives the most regular sizes. However, the affinity (or distance used in clustering) cannot be varied with Ward, thus for non Euclidean metrics, average linkage is a good alternative.</p> <div class="topic"> <p class="topic-title first">Examples:</p> <ul class="simple"> <li>
<a class="reference internal" href="../../auto_examples/cluster/plot_digits_linkage/#sphx-glr-auto-examples-cluster-plot-digits-linkage-py"><span class="std std-ref">Various Agglomerative Clustering on a 2D embedding of digits</span></a>: exploration of the different linkage strategies in a real dataset.</li> </ul> </div>   <h3 id="adding-connectivity-constraints">2.3.6.2. Adding connectivity constraints</h3> <p>An interesting aspect of <a class="reference internal" href="../generated/sklearn.cluster.agglomerativeclustering/#sklearn.cluster.AgglomerativeClustering" title="sklearn.cluster.AgglomerativeClustering"><code>AgglomerativeClustering</code></a> is that connectivity constraints can be added to this algorithm (only adjacent clusters can be merged together), through a connectivity matrix that defines for each sample the neighboring samples following a given structure of the data. For instance, in the swiss-roll example below, the connectivity constraints forbid the merging of points that are not adjacent on the swiss roll, and thus avoid forming clusters that extend across overlapping folds of the roll.</p> <p class="centered"> <strong><a class="reference external" href="../../auto_examples/cluster/plot_ward_structured_vs_unstructured/"><img alt="unstructured" src="http://scikit-learn.org/stable/_images/sphx_glr_plot_ward_structured_vs_unstructured_0011.png" style="width: 392.0px; height: 294.0px;"></a> <a class="reference external" href="../../auto_examples/cluster/plot_ward_structured_vs_unstructured/"><img alt="structured" src="http://scikit-learn.org/stable/_images/sphx_glr_plot_ward_structured_vs_unstructured_0021.png" style="width: 392.0px; height: 294.0px;"></a></strong></p>
<p>These constraint are useful to impose a certain local structure, but they also make the algorithm faster, especially when the number of the samples is high.</p> <p>The connectivity constraints are imposed via an connectivity matrix: a scipy sparse matrix that has elements only at the intersection of a row and a column with indices of the dataset that should be connected. This matrix can be constructed from a-priori information: for instance, you may wish to cluster web pages by only merging pages with a link pointing from one to another. It can also be learned from the data, for instance using <a class="reference internal" href="../generated/sklearn.neighbors.kneighbors_graph/#sklearn.neighbors.kneighbors_graph" title="sklearn.neighbors.kneighbors_graph"><code>sklearn.neighbors.kneighbors_graph</code></a> to restrict merging to nearest neighbors as in <a class="reference internal" href="../../auto_examples/cluster/plot_agglomerative_clustering/#sphx-glr-auto-examples-cluster-plot-agglomerative-clustering-py"><span class="std std-ref">this example</span></a>, or using <a class="reference internal" href="../generated/sklearn.feature_extraction.image.grid_to_graph/#sklearn.feature_extraction.image.grid_to_graph" title="sklearn.feature_extraction.image.grid_to_graph"><code>sklearn.feature_extraction.image.grid_to_graph</code></a> to enable only merging of neighboring pixels on an image, as in the <a class="reference internal" href="../../auto_examples/cluster/plot_face_ward_segmentation/#sphx-glr-auto-examples-cluster-plot-face-ward-segmentation-py"><span class="std std-ref">raccoon face</span></a> example.</p> <div class="topic"> <p class="topic-title first">Examples:</p> <ul class="simple"> <li>
<a class="reference internal" href="../../auto_examples/cluster/plot_face_ward_segmentation/#sphx-glr-auto-examples-cluster-plot-face-ward-segmentation-py"><span class="std std-ref">A demo of structured Ward hierarchical clustering on a raccoon face image</span></a>: Ward clustering to split the image of a raccoon face in regions.</li> <li>
<a class="reference internal" href="../../auto_examples/cluster/plot_ward_structured_vs_unstructured/#sphx-glr-auto-examples-cluster-plot-ward-structured-vs-unstructured-py"><span class="std std-ref">Hierarchical clustering: structured vs unstructured ward</span></a>: Example of Ward algorithm on a swiss-roll, comparison of structured approaches versus unstructured approaches.</li> <li>
<a class="reference internal" href="../../auto_examples/cluster/plot_feature_agglomeration_vs_univariate_selection/#sphx-glr-auto-examples-cluster-plot-feature-agglomeration-vs-univariate-selection-py"><span class="std std-ref">Feature agglomeration vs. univariate selection</span></a>: Example of dimensionality reduction with feature agglomeration based on Ward hierarchical clustering.</li> <li><a class="reference internal" href="../../auto_examples/cluster/plot_agglomerative_clustering/#sphx-glr-auto-examples-cluster-plot-agglomerative-clustering-py"><span class="std std-ref">Agglomerative clustering with and without structure</span></a></li> </ul> </div> <div class="admonition warning"> <p class="first admonition-title">Warning</p> <p><strong>Connectivity constraints with average and complete linkage</strong></p> <p class="last">Connectivity constraints and complete or average linkage can enhance the ‘rich getting richer’ aspect of agglomerative clustering, particularly so if they are built with <a class="reference internal" href="../generated/sklearn.neighbors.kneighbors_graph/#sklearn.neighbors.kneighbors_graph" title="sklearn.neighbors.kneighbors_graph"><code>sklearn.neighbors.kneighbors_graph</code></a>. In the limit of a small number of clusters, they tend to give a few macroscopically occupied clusters and almost empty ones. (see the discussion in <a class="reference internal" href="../../auto_examples/cluster/plot_agglomerative_clustering/#sphx-glr-auto-examples-cluster-plot-agglomerative-clustering-py"><span class="std std-ref">Agglomerative clustering with and without structure</span></a>).</p> </div> <a class="reference external image-reference" href="../../auto_examples/cluster/plot_agglomerative_clustering/"><img alt="../_images/sphx_glr_plot_agglomerative_clustering_0011.png" src="http://scikit-learn.org/stable/_images/sphx_glr_plot_agglomerative_clustering_0011.png" style="width: 380.0px; height: 152.0px;"></a> <a class="reference external image-reference" href="../../auto_examples/cluster/plot_agglomerative_clustering/"><img alt="../_images/sphx_glr_plot_agglomerative_clustering_0021.png" src="http://scikit-learn.org/stable/_images/sphx_glr_plot_agglomerative_clustering_0021.png" style="width: 380.0px; height: 152.0px;"></a> <a class="reference external image-reference" href="../../auto_examples/cluster/plot_agglomerative_clustering/"><img alt="../_images/sphx_glr_plot_agglomerative_clustering_0031.png" src="http://scikit-learn.org/stable/_images/sphx_glr_plot_agglomerative_clustering_0031.png" style="width: 380.0px; height: 152.0px;"></a> <a class="reference external image-reference" href="../../auto_examples/cluster/plot_agglomerative_clustering/"><img alt="../_images/sphx_glr_plot_agglomerative_clustering_0041.png" src="http://scikit-learn.org/stable/_images/sphx_glr_plot_agglomerative_clustering_0041.png" style="width: 380.0px; height: 152.0px;"></a>   <h3 id="varying-the-metric">2.3.6.3. Varying the metric</h3> <p>Average and complete linkage can be used with a variety of distances (or affinities), in particular Euclidean distance (<em>l2</em>), Manhattan distance (or Cityblock, or <em>l1</em>), cosine distance, or any precomputed affinity matrix.</p> <ul class="simple"> <li>
<em>l1</em> distance is often good for sparse features, or sparse noise: ie many of the features are zero, as in text mining using occurences of rare words.</li> <li>
<em>cosine</em> distance is interesting because it is invariant to global scalings of the signal.</li> </ul> <p>The guidelines for choosing a metric is to use one that maximizes the distance between samples in different classes, and minimizes that within each class.</p> <a class="reference external image-reference" href="../../auto_examples/cluster/plot_agglomerative_clustering_metrics/"><img alt="../_images/sphx_glr_plot_agglomerative_clustering_metrics_0051.png" src="http://scikit-learn.org/stable/_images/sphx_glr_plot_agglomerative_clustering_metrics_0051.png" style="width: 256.0px; height: 192.0px;"></a> <a class="reference external image-reference" href="../../auto_examples/cluster/plot_agglomerative_clustering_metrics/"><img alt="../_images/sphx_glr_plot_agglomerative_clustering_metrics_0061.png" src="http://scikit-learn.org/stable/_images/sphx_glr_plot_agglomerative_clustering_metrics_0061.png" style="width: 256.0px; height: 192.0px;"></a> <a class="reference external image-reference" href="../../auto_examples/cluster/plot_agglomerative_clustering_metrics/"><img alt="../_images/sphx_glr_plot_agglomerative_clustering_metrics_0071.png" src="http://scikit-learn.org/stable/_images/sphx_glr_plot_agglomerative_clustering_metrics_0071.png" style="width: 256.0px; height: 192.0px;"></a> <div class="topic"> <p class="topic-title first">Examples:</p> <ul class="simple"> <li><a class="reference internal" href="../../auto_examples/cluster/plot_agglomerative_clustering_metrics/#sphx-glr-auto-examples-cluster-plot-agglomerative-clustering-metrics-py"><span class="std std-ref">Agglomerative clustering with different metrics</span></a></li> </ul> </div>    <h2 id="id7">2.3.7. DBSCAN</h2> <p id="dbscan">The <a class="reference internal" href="../generated/sklearn.cluster.dbscan/#sklearn.cluster.DBSCAN" title="sklearn.cluster.DBSCAN"><code>DBSCAN</code></a> algorithm views clusters as areas of high density separated by areas of low density. Due to this rather generic view, clusters found by DBSCAN can be any shape, as opposed to k-means which assumes that clusters are convex shaped. The central component to the DBSCAN is the concept of <em>core samples</em>, which are samples that are in areas of high density. A cluster is therefore a set of core samples, each close to each other (measured by some distance measure) and a set of non-core samples that are close to a core sample (but are not themselves core samples). There are two parameters to the algorithm, <code>min_samples</code> and <code>eps</code>, which define formally what we mean when we say <em>dense</em>. Higher <code>min_samples</code> or lower <code>eps</code> indicate higher density necessary to form a cluster.</p> <p>More formally, we define a core sample as being a sample in the dataset such that there exist <code>min_samples</code> other samples within a distance of <code>eps</code>, which are defined as <em>neighbors</em> of the core sample. This tells us that the core sample is in a dense area of the vector space. A cluster is a set of core samples that can be built by recursively taking a core sample, finding all of its neighbors that are core samples, finding all of <em>their</em> neighbors that are core samples, and so on. A cluster also has a set of non-core samples, which are samples that are neighbors of a core sample in the cluster but are not themselves core samples. Intuitively, these samples are on the fringes of a cluster.</p> <p>Any core sample is part of a cluster, by definition. Any sample that is not a core sample, and is at least <code>eps</code> in distance from any core sample, is considered an outlier by the algorithm.</p> <p>In the figure below, the color indicates cluster membership, with large circles indicating core samples found by the algorithm. Smaller circles are non-core samples that are still part of a cluster. Moreover, the outliers are indicated by black points below.</p> <p class="centered"> <strong><a class="reference external" href="../../auto_examples/cluster/plot_dbscan/"><img alt="dbscan_results" src="http://scikit-learn.org/stable/_images/sphx_glr_plot_dbscan_0011.png" style="width: 400.0px; height: 300.0px;"></a></strong></p>
<div class="topic"> <p class="topic-title first">Examples:</p> <ul class="simple"> <li><a class="reference internal" href="../../auto_examples/cluster/plot_dbscan/#sphx-glr-auto-examples-cluster-plot-dbscan-py"><span class="std std-ref">Demo of DBSCAN clustering algorithm</span></a></li> </ul> </div> <div class="topic"> <p class="topic-title first">Implementation</p> <p>The algorithm is non-deterministic, but the core samples will always belong to the same clusters (although the labels may be different). The non-determinism comes from deciding to which cluster a non-core sample belongs. A non-core sample can have a distance lower than <code>eps</code> to two core samples in different clusters. By the triangular inequality, those two core samples must be more distant than <code>eps</code> from each other, or they would be in the same cluster. The non-core sample is assigned to whichever cluster is generated first, where the order is determined randomly. Other than the ordering of the dataset, the algorithm is deterministic, making the results relatively stable between runs on the same data.</p> <p>The current implementation uses ball trees and kd-trees to determine the neighborhood of points, which avoids calculating the full distance matrix (as was done in scikit-learn versions before 0.14). The possibility to use custom metrics is retained; for details, see <code>NearestNeighbors</code>.</p> </div> <div class="topic"> <p class="topic-title first">Memory consumption for large sample sizes</p> <p>This implementation is by default not memory efficient because it constructs a full pairwise similarity matrix in the case where kd-trees or ball-trees cannot be used (e.g. with sparse matrices). This matrix will consume n^2 floats. A couple of mechanisms for getting around this are:</p> <ul class="simple"> <li>A sparse radius neighborhood graph (where missing entries are presumed to be out of eps) can be precomputed in a memory-efficient way and dbscan can be run over this with <code>metric='precomputed'</code>.</li> <li>The dataset can be compressed, either by removing exact duplicates if these occur in your data, or by using BIRCH. Then you only have a relatively small number of representatives for a large number of points. You can then provide a <code>sample_weight</code> when fitting DBSCAN.</li> </ul> </div> <div class="topic"> <p class="topic-title first">References:</p> <ul class="simple"> <li>“A Density-Based Algorithm for Discovering Clusters in Large Spatial Databases with Noise” Ester, M., H. P. Kriegel, J. Sander, and X. Xu, In Proceedings of the 2nd International Conference on Knowledge Discovery and Data Mining, Portland, OR, AAAI Press, pp. 226–231. 1996</li> </ul> </div>   <h2 id="id8">2.3.8. Birch</h2> <p id="birch">The <a class="reference internal" href="../generated/sklearn.cluster.birch/#sklearn.cluster.Birch" title="sklearn.cluster.Birch"><code>Birch</code></a> builds a tree called the Characteristic Feature Tree (CFT) for the given data. The data is essentially lossy compressed to a set of Characteristic Feature nodes (CF Nodes). The CF Nodes have a number of subclusters called Characteristic Feature subclusters (CF Subclusters) and these CF Subclusters located in the non-terminal CF Nodes can have CF Nodes as children.</p> <p>The CF Subclusters hold the necessary information for clustering which prevents the need to hold the entire input data in memory. This information includes:</p> <ul class="simple"> <li>Number of samples in a subcluster.</li> <li>Linear Sum - A n-dimensional vector holding the sum of all samples</li> <li>Squared Sum - Sum of the squared L2 norm of all samples.</li> <li>Centroids - To avoid recalculation linear sum / n_samples.</li> <li>Squared norm of the centroids.</li> </ul> <p>The Birch algorithm has two parameters, the threshold and the branching factor. The branching factor limits the number of subclusters in a node and the threshold limits the distance between the entering sample and the existing subclusters.</p> <p>This algorithm can be viewed as an instance or data reduction method, since it reduces the input data to a set of subclusters which are obtained directly from the leaves of the CFT. This reduced data can be further processed by feeding it into a global clusterer. This global clusterer can be set by <code>n_clusters</code>. If <code>n_clusters</code> is set to None, the subclusters from the leaves are directly read off, otherwise a global clustering step labels these subclusters into global clusters (labels) and the samples are mapped to the global label of the nearest subcluster.</p> <p><strong>Algorithm description:</strong></p> <ul class="simple"> <li>A new sample is inserted into the root of the CF Tree which is a CF Node. It is then merged with the subcluster of the root, that has the smallest radius after merging, constrained by the threshold and branching factor conditions. If the subcluster has any child node, then this is done repeatedly till it reaches a leaf. After finding the nearest subcluster in the leaf, the properties of this subcluster and the parent subclusters are recursively updated.</li> <li>If the radius of the subcluster obtained by merging the new sample and the nearest subcluster is greater than the square of the threshold and if the number of subclusters is greater than the branching factor, then a space is temporarily allocated to this new sample. The two farthest subclusters are taken and the subclusters are divided into two groups on the basis of the distance between these subclusters.</li> <li>If this split node has a parent subcluster and there is room for a new subcluster, then the parent is split into two. If there is no room, then this node is again split into two and the process is continued recursively, till it reaches the root.</li> </ul> <p><strong>Birch or MiniBatchKMeans?</strong></p>  <ul class="simple"> <li>Birch does not scale very well to high dimensional data. As a rule of thumb if <code>n_features</code> is greater than twenty, it is generally better to use MiniBatchKMeans.</li> <li>If the number of instances of data needs to be reduced, or if one wants a large number of subclusters either as a preprocessing step or otherwise, Birch is more useful than MiniBatchKMeans.</li> </ul>  <p><strong>How to use partial_fit?</strong></p> <p>To avoid the computation of global clustering, for every call of <code>partial_fit</code> the user is advised</p>  <ol class="arabic simple"> <li>To set <code>n_clusters=None</code> initially</li> <li>Train all data by multiple calls to partial_fit.</li> <li>Set <code>n_clusters</code> to a required value using <code>brc.set_params(n_clusters=n_clusters)</code>.</li> <li>Call <code>partial_fit</code> finally with no arguments, i.e <code>brc.partial_fit()</code> which performs the global clustering.</li> </ol>  <a class="reference external image-reference" href="../../auto_examples/cluster/plot_birch_vs_minibatchkmeans/"><img alt="../_images/sphx_glr_plot_birch_vs_minibatchkmeans_0011.png" src="http://scikit-learn.org/stable/_images/sphx_glr_plot_birch_vs_minibatchkmeans_0011.png"></a> <div class="topic"> <p class="topic-title first">References:</p> <ul class="simple"> <li>Tian Zhang, Raghu Ramakrishnan, Maron Livny BIRCH: An efficient data clustering method for large databases. <a class="reference external" href="http://www.cs.sfu.ca/CourseCentral/459/han/papers/zhang96.pdf" target="_blank">http://www.cs.sfu.ca/CourseCentral/459/han/papers/zhang96.pdf</a>
</li> <li>Roberto Perdisci JBirch - Java implementation of BIRCH clustering algorithm <a class="reference external" href="https://code.google.com/archive/p/jbirch" target="_blank">https://code.google.com/archive/p/jbirch</a>
</li> </ul> </div>   <h2 id="clustering-evaluation">2.3.9. Clustering performance evaluation</h2> <p id="clustering-performance-evaluation">Evaluating the performance of a clustering algorithm is not as trivial as counting the number of errors or the precision and recall of a supervised classification algorithm. In particular any evaluation metric should not take the absolute values of the cluster labels into account but rather if this clustering define separations of the data similar to some ground truth set of classes or satisfying some assumption such that members belong to the same class are more similar that members of different classes according to some similarity metric.</p>  <h3 id="adjusted-rand-score">2.3.9.1. Adjusted Rand index</h3> <p id="adjusted-rand-index">Given the knowledge of the ground truth class assignments <code>labels_true</code> and our clustering algorithm assignments of the same samples <code>labels_pred</code>, the <strong>adjusted Rand index</strong> is a function that measures the <strong>similarity</strong> of the two assignments, ignoring permutations and <strong>with chance normalization</strong>:</p> <pre data-language="python">&gt;&gt;&gt; from sklearn import metrics
&gt;&gt;&gt; labels_true = [0, 0, 0, 1, 1, 1]
&gt;&gt;&gt; labels_pred = [0, 0, 1, 1, 2, 2]

&gt;&gt;&gt; metrics.adjusted_rand_score(labels_true, labels_pred)  
0.24...
</pre> <p>One can permute 0 and 1 in the predicted labels, rename 2 to 3, and get the same score:</p> <pre data-language="python">&gt;&gt;&gt; labels_pred = [1, 1, 0, 0, 3, 3]
&gt;&gt;&gt; metrics.adjusted_rand_score(labels_true, labels_pred)  
0.24...
</pre> <p>Furthermore, <a class="reference internal" href="../generated/sklearn.metrics.adjusted_rand_score/#sklearn.metrics.adjusted_rand_score" title="sklearn.metrics.adjusted_rand_score"><code>adjusted_rand_score</code></a> is <strong>symmetric</strong>: swapping the argument does not change the score. It can thus be used as a <strong>consensus measure</strong>:</p> <pre data-language="python">&gt;&gt;&gt; metrics.adjusted_rand_score(labels_pred, labels_true)  
0.24...
</pre> <p>Perfect labeling is scored 1.0:</p> <pre data-language="python">&gt;&gt;&gt; labels_pred = labels_true[:]
&gt;&gt;&gt; metrics.adjusted_rand_score(labels_true, labels_pred)
1.0
</pre> <p>Bad (e.g. independent labelings) have negative or close to 0.0 scores:</p> <pre data-language="python">&gt;&gt;&gt; labels_true = [0, 1, 2, 0, 3, 4, 5, 1]
&gt;&gt;&gt; labels_pred = [1, 1, 0, 0, 2, 2, 2, 2]
&gt;&gt;&gt; metrics.adjusted_rand_score(labels_true, labels_pred)  
-0.12...
</pre>  <h4 id="advantages">2.3.9.1.1. Advantages</h4> <ul class="simple"> <li>
<strong>Random (uniform) label assignments have a ARI score close to 0.0</strong> for any value of <code>n_clusters</code> and <code>n_samples</code> (which is not the case for raw Rand index or the V-measure for instance).</li> <li>
<strong>Bounded range [-1, 1]</strong>: negative values are bad (independent labelings), similar clusterings have a positive ARI, 1.0 is the perfect match score.</li> <li>
<strong>No assumption is made on the cluster structure</strong>: can be used to compare clustering algorithms such as k-means which assumes isotropic blob shapes with results of spectral clustering algorithms which can find cluster with “folded” shapes.</li> </ul>   <h4 id="drawbacks">2.3.9.1.2. Drawbacks</h4> <ul> <li>
<p class="first">Contrary to inertia, <strong>ARI requires knowledge of the ground truth classes</strong> while is almost never available in practice or requires manual assignment by human annotators (as in the supervised learning setting).</p> <p>However ARI can also be useful in a purely unsupervised setting as a building block for a Consensus Index that can be used for clustering model selection (TODO).</p> </li> </ul> <div class="topic"> <p class="topic-title first">Examples:</p> <ul class="simple"> <li>
<a class="reference internal" href="../../auto_examples/cluster/plot_adjusted_for_chance_measures/#sphx-glr-auto-examples-cluster-plot-adjusted-for-chance-measures-py"><span class="std std-ref">Adjustment for chance in clustering performance evaluation</span></a>: Analysis of the impact of the dataset size on the value of clustering measures for random assignments.</li> </ul> </div>   <h4 id="mathematical-formulation">2.3.9.1.3. Mathematical formulation</h4> <p>If C is a ground truth class assignment and K the clustering, let us define <img class="math" src="http://scikit-learn.org/stable/_images/math/bd9d9c7512c898e0a254a0882184197bc1bd9c9f.png" alt="a"> and <img class="math" src="http://scikit-learn.org/stable/_images/math/57c9d14bb082716df9000146882ce365335d08f1.png" alt="b"> as:</p> <ul class="simple"> <li>
<img class="math" src="http://scikit-learn.org/stable/_images/math/bd9d9c7512c898e0a254a0882184197bc1bd9c9f.png" alt="a">, the number of pairs of elements that are in the same set in C and in the same set in K</li> <li>
<img class="math" src="http://scikit-learn.org/stable/_images/math/57c9d14bb082716df9000146882ce365335d08f1.png" alt="b">, the number of pairs of elements that are in different sets in C and in different sets in K</li> </ul> <p>The raw (unadjusted) Rand index is then given by:</p> <div class="math"> <p><img src="http://scikit-learn.org/stable/_images/math/c3e772379f4b933484a8380e036768cffe5af3fe.png" alt="\text{RI} = \frac{a + b}{C_2^{n_{samples}}}"></p> </div>
<p>Where <img class="math" src="http://scikit-learn.org/stable/_images/math/33619d8b145aaea780de8097bf6dd4f43e611a02.png" alt="C_2^{n_{samples}}"> is the total number of possible pairs in the dataset (without ordering).</p> <p>However the RI score does not guarantee that random label assignments will get a value close to zero (esp. if the number of clusters is in the same order of magnitude as the number of samples).</p> <p>To counter this effect we can discount the expected RI <img class="math" src="http://scikit-learn.org/stable/_images/math/727d5ef6af39e327a816393232243bff21c00a3e.png" alt="E[\text{RI}]"> of random labelings by defining the adjusted Rand index as follows:</p> <div class="math"> <p><img src="http://scikit-learn.org/stable/_images/math/706b310c505152bcf2f86d85c60ea2529611d42b.png" alt="\text{ARI} = \frac{\text{RI} - E[\text{RI}]}{\max(\text{RI}) - E[\text{RI}]}"></p> </div>
<div class="topic"> <p class="topic-title first">References</p> <ul class="simple"> <li>
<a class="reference external" href="http://link.springer.com/article/10.1007%2FBF01908075" target="_blank">Comparing Partitions</a> L. Hubert and P. Arabie, Journal of Classification 1985</li> <li><a class="reference external" href="https://en.wikipedia.org/wiki/Rand_index#Adjusted_Rand_index" target="_blank">Wikipedia entry for the adjusted Rand index</a></li> </ul> </div>    <h3 id="mutual-info-score">2.3.9.2. Mutual Information based scores</h3> <p id="mutual-information-based-scores">Given the knowledge of the ground truth class assignments <code>labels_true</code> and our clustering algorithm assignments of the same samples <code>labels_pred</code>, the <strong>Mutual Information</strong> is a function that measures the <strong>agreement</strong> of the two assignments, ignoring permutations. Two different normalized versions of this measure are available, <strong>Normalized Mutual Information(NMI)</strong> and <strong>Adjusted Mutual Information(AMI)</strong>. NMI is often used in the literature while AMI was proposed more recently and is <strong>normalized against chance</strong>:</p> <pre data-language="python">&gt;&gt;&gt; from sklearn import metrics
&gt;&gt;&gt; labels_true = [0, 0, 0, 1, 1, 1]
&gt;&gt;&gt; labels_pred = [0, 0, 1, 1, 2, 2]

&gt;&gt;&gt; metrics.adjusted_mutual_info_score(labels_true, labels_pred)  
0.22504...
</pre> <p>One can permute 0 and 1 in the predicted labels, rename 2 to 3 and get the same score:</p> <pre data-language="python">&gt;&gt;&gt; labels_pred = [1, 1, 0, 0, 3, 3]
&gt;&gt;&gt; metrics.adjusted_mutual_info_score(labels_true, labels_pred)  
0.22504...
</pre> <p>All, <a class="reference internal" href="../generated/sklearn.metrics.mutual_info_score/#sklearn.metrics.mutual_info_score" title="sklearn.metrics.mutual_info_score"><code>mutual_info_score</code></a>, <a class="reference internal" href="../generated/sklearn.metrics.adjusted_mutual_info_score/#sklearn.metrics.adjusted_mutual_info_score" title="sklearn.metrics.adjusted_mutual_info_score"><code>adjusted_mutual_info_score</code></a> and <a class="reference internal" href="../generated/sklearn.metrics.normalized_mutual_info_score/#sklearn.metrics.normalized_mutual_info_score" title="sklearn.metrics.normalized_mutual_info_score"><code>normalized_mutual_info_score</code></a> are symmetric: swapping the argument does not change the score. Thus they can be used as a <strong>consensus measure</strong>:</p> <pre data-language="python">&gt;&gt;&gt; metrics.adjusted_mutual_info_score(labels_pred, labels_true)  
0.22504...
</pre> <p>Perfect labeling is scored 1.0:</p> <pre data-language="python">&gt;&gt;&gt; labels_pred = labels_true[:]
&gt;&gt;&gt; metrics.adjusted_mutual_info_score(labels_true, labels_pred)
1.0

&gt;&gt;&gt; metrics.normalized_mutual_info_score(labels_true, labels_pred)
1.0
</pre> <p>This is not true for <code>mutual_info_score</code>, which is therefore harder to judge:</p> <pre data-language="python">&gt;&gt;&gt; metrics.mutual_info_score(labels_true, labels_pred)  
0.69...
</pre> <p>Bad (e.g. independent labelings) have non-positive scores:</p> <pre data-language="python">&gt;&gt;&gt; labels_true = [0, 1, 2, 0, 3, 4, 5, 1]
&gt;&gt;&gt; labels_pred = [1, 1, 0, 0, 2, 2, 2, 2]
&gt;&gt;&gt; metrics.adjusted_mutual_info_score(labels_true, labels_pred)  
-0.10526...
</pre>  <h4 id="id9">2.3.9.2.1. Advantages</h4> <ul class="simple"> <li>
<strong>Random (uniform) label assignments have a AMI score close to 0.0</strong> for any value of <code>n_clusters</code> and <code>n_samples</code> (which is not the case for raw Mutual Information or the V-measure for instance).</li> <li>
<strong>Bounded range [0, 1]</strong>: Values close to zero indicate two label assignments that are largely independent, while values close to one indicate significant agreement. Further, values of exactly 0 indicate <strong>purely</strong> independent label assignments and a AMI of exactly 1 indicates that the two label assignments are equal (with or without permutation).</li> <li>
<strong>No assumption is made on the cluster structure</strong>: can be used to compare clustering algorithms such as k-means which assumes isotropic blob shapes with results of spectral clustering algorithms which can find cluster with “folded” shapes.</li> </ul>   <h4 id="id10">2.3.9.2.2. Drawbacks</h4> <ul> <li>
<p class="first">Contrary to inertia, <strong>MI-based measures require the knowledge of the ground truth classes</strong> while almost never available in practice or requires manual assignment by human annotators (as in the supervised learning setting).</p> <p>However MI-based measures can also be useful in purely unsupervised setting as a building block for a Consensus Index that can be used for clustering model selection.</p> </li> <li>NMI and MI are not adjusted against chance. </li> </ul> <div class="topic"> <p class="topic-title first">Examples:</p> <ul class="simple"> <li>
<a class="reference internal" href="../../auto_examples/cluster/plot_adjusted_for_chance_measures/#sphx-glr-auto-examples-cluster-plot-adjusted-for-chance-measures-py"><span class="std std-ref">Adjustment for chance in clustering performance evaluation</span></a>: Analysis of the impact of the dataset size on the value of clustering measures for random assignments. This example also includes the Adjusted Rand Index.</li> </ul> </div>   <h4 id="id11">2.3.9.2.3. Mathematical formulation</h4> <p>Assume two label assignments (of the same N objects), <img class="math" src="http://scikit-learn.org/stable/_images/math/169c982b5e649cd1bd6445df5583affe427ea269.png" alt="U"> and <img class="math" src="http://scikit-learn.org/stable/_images/math/fae0e7a73748991e5540d874416000583f64f58e.png" alt="V">. Their entropy is the amount of uncertainty for a partition set, defined by:</p> <div class="math"> <p><img src="http://scikit-learn.org/stable/_images/math/dc1c5873cf5a6b94a49e76bb03f5ee3ff27ecdc4.png" alt="H(U) = \sum_{i=1}^{|U|}P(i)\log(P(i))"></p> </div>
<p>where <img class="math" src="http://scikit-learn.org/stable/_images/math/c159e7b7f8d3423af34caa0dac707cc650fd821f.png" alt="P(i) = |U_i| / N"> is the probability that an object picked at random from <img class="math" src="http://scikit-learn.org/stable/_images/math/169c982b5e649cd1bd6445df5583affe427ea269.png" alt="U"> falls into class <img class="math" src="http://scikit-learn.org/stable/_images/math/328603961e007eb764a788ef42417a8c57a287f7.png" alt="U_i">. Likewise for <img class="math" src="http://scikit-learn.org/stable/_images/math/fae0e7a73748991e5540d874416000583f64f58e.png" alt="V">:</p> <div class="math"> <p><img src="http://scikit-learn.org/stable/_images/math/a12578ad39dee82403d81ed690a9751719967af3.png" alt="H(V) = \sum_{j=1}^{|V|}P'(j)\log(P'(j))"></p> </div>
<p>With <img class="math" src="http://scikit-learn.org/stable/_images/math/41e69936b7ad98cf62cc2357b3b37a95af547ce6.png" alt="P'(j) = |V_j| / N">. The mutual information (MI) between <img class="math" src="http://scikit-learn.org/stable/_images/math/169c982b5e649cd1bd6445df5583affe427ea269.png" alt="U"> and <img class="math" src="http://scikit-learn.org/stable/_images/math/fae0e7a73748991e5540d874416000583f64f58e.png" alt="V"> is calculated by:</p> <div class="math"> <p><img src="http://scikit-learn.org/stable/_images/math/70713505073671b06b1e9e791d2797c2aa82ea0f.png" alt="\text{MI}(U, V) = \sum_{i=1}^{|U|}\sum_{j=1}^{|V|}P(i, j)\log\left(\frac{P(i,j)}{P(i)P'(j)}\right)"></p> </div>
<p>where <img class="math" src="http://scikit-learn.org/stable/_images/math/d6b4beff49273a2872b5a28cc372ef24f32c3d68.png" alt="P(i, j) = |U_i \cap V_j| / N"> is the probability that an object picked at random falls into both classes <img class="math" src="http://scikit-learn.org/stable/_images/math/328603961e007eb764a788ef42417a8c57a287f7.png" alt="U_i"> and <img class="math" src="http://scikit-learn.org/stable/_images/math/a99452676e000d41bc4d0ed2e924700ae3f51824.png" alt="V_j">.</p> <p>The normalized mutual information is defined as</p> <div class="math"> <p><img src="http://scikit-learn.org/stable/_images/math/3767d8ecc0cec3eccf9cda03853ae73c765da4c4.png" alt="\text{NMI}(U, V) = \frac{\text{MI}(U, V)}{\sqrt{H(U)H(V)}}"></p> </div>
<p>This value of the mutual information and also the normalized variant is not adjusted for chance and will tend to increase as the number of different labels (clusters) increases, regardless of the actual amount of “mutual information” between the label assignments.</p> <p>The expected value for the mutual information can be calculated using the following equation, from Vinh, Epps, and Bailey, (2009). In this equation, <img class="math" src="http://scikit-learn.org/stable/_images/math/c575c319007e566186da06fa1c7d6cd345fd38ec.png" alt="a_i = |U_i|"> (the number of elements in <img class="math" src="http://scikit-learn.org/stable/_images/math/328603961e007eb764a788ef42417a8c57a287f7.png" alt="U_i">) and <img class="math" src="http://scikit-learn.org/stable/_images/math/58644320789197200418afa31abcae8cf1ca6204.png" alt="b_j = |V_j|"> (the number of elements in <img class="math" src="http://scikit-learn.org/stable/_images/math/a99452676e000d41bc4d0ed2e924700ae3f51824.png" alt="V_j">).</p> <div class="math"> <p><img src="http://scikit-learn.org/stable/_images/math/ded2972abdf9594995f84b94e6faf2a36ae234fd.png" alt="E[\text{MI}(U,V)]=\sum_{i=1}^|U| \sum_{j=1}^|V| \sum_{n_{ij}=(a_i+b_j-N)^+
}^{\min(a_i, b_j)} \frac{n_{ij}}{N}\log \left( \frac{ N.n_{ij}}{a_i b_j}\right)
\frac{a_i!b_j!(N-a_i)!(N-b_j)!}{N!n_{ij}!(a_i-n_{ij})!(b_j-n_{ij})!
(N-a_i-b_j+n_{ij})!}"></p> </div>
<p>Using the expected value, the adjusted mutual information can then be calculated using a similar form to that of the adjusted Rand index:</p> <div class="math"> <p><img src="http://scikit-learn.org/stable/_images/math/29c4bdc72f97b236b044de12dd4cffc36ac2b851.png" alt="\text{AMI} = \frac{\text{MI} - E[\text{MI}]}{\max(H(U), H(V)) - E[\text{MI}]}"></p> </div>
<div class="topic"> <p class="topic-title first">References</p> <ul class="simple"> <li>Strehl, Alexander, and Joydeep Ghosh (2002). “Cluster ensembles – a knowledge reuse framework for combining multiple partitions”. Journal of Machine Learning Research 3: 583–617. <a class="reference external" href="http://strehl.com/download/strehl-jmlr02.pdf" target="_blank">doi:10.1162/153244303321897735</a>.</li> <li>Vinh, Epps, and Bailey, (2009). “Information theoretic measures for clusterings comparison”. Proceedings of the 26th Annual International Conference on Machine Learning - ICML ‘09. <a class="reference external" href="https://dl.acm.org/citation.cfm?doid=1553374.1553511" target="_blank">doi:10.1145/1553374.1553511</a>. ISBN 9781605585161.</li> <li>Vinh, Epps, and Bailey, (2010). Information Theoretic Measures for Clusterings Comparison: Variants, Properties, Normalization and Correction for Chance, JMLR <a class="reference external" href="http://jmlr.csail.mit.edu/papers/volume11/vinh10a/vinh10a.pdf" target="_blank">http://jmlr.csail.mit.edu/papers/volume11/vinh10a/vinh10a.pdf</a>
</li> <li><a class="reference external" href="https://en.wikipedia.org/wiki/Mutual_Information" target="_blank">Wikipedia entry for the (normalized) Mutual Information</a></li> <li><a class="reference external" href="https://en.wikipedia.org/wiki/Adjusted_Mutual_Information" target="_blank">Wikipedia entry for the Adjusted Mutual Information</a></li> </ul> </div>    <h3 id="homogeneity-completeness">2.3.9.3. Homogeneity, completeness and V-measure</h3> <p id="homogeneity-completeness-and-v-measure">Given the knowledge of the ground truth class assignments of the samples, it is possible to define some intuitive metric using conditional entropy analysis.</p> <p>In particular Rosenberg and Hirschberg (2007) define the following two desirable objectives for any cluster assignment:</p> <ul class="simple"> <li>
<strong>homogeneity</strong>: each cluster contains only members of a single class.</li> <li>
<strong>completeness</strong>: all members of a given class are assigned to the same cluster.</li> </ul> <p>We can turn those concept as scores <a class="reference internal" href="../generated/sklearn.metrics.homogeneity_score/#sklearn.metrics.homogeneity_score" title="sklearn.metrics.homogeneity_score"><code>homogeneity_score</code></a> and <a class="reference internal" href="../generated/sklearn.metrics.completeness_score/#sklearn.metrics.completeness_score" title="sklearn.metrics.completeness_score"><code>completeness_score</code></a>. Both are bounded below by 0.0 and above by 1.0 (higher is better):</p> <pre data-language="python">&gt;&gt;&gt; from sklearn import metrics
&gt;&gt;&gt; labels_true = [0, 0, 0, 1, 1, 1]
&gt;&gt;&gt; labels_pred = [0, 0, 1, 1, 2, 2]

&gt;&gt;&gt; metrics.homogeneity_score(labels_true, labels_pred)  
0.66...

&gt;&gt;&gt; metrics.completeness_score(labels_true, labels_pred) 
0.42...
</pre> <p>Their harmonic mean called <strong>V-measure</strong> is computed by <a class="reference internal" href="../generated/sklearn.metrics.v_measure_score/#sklearn.metrics.v_measure_score" title="sklearn.metrics.v_measure_score"><code>v_measure_score</code></a>:</p> <pre data-language="python">&gt;&gt;&gt; metrics.v_measure_score(labels_true, labels_pred)    
0.51...
</pre> <p>The V-measure is actually equivalent to the mutual information (NMI) discussed above normalized by the sum of the label entropies <a class="reference internal" href="#b2011" id="id12">[B2011]</a>.</p> <p>Homogeneity, completeness and V-measure can be computed at once using <a class="reference internal" href="../generated/sklearn.metrics.homogeneity_completeness_v_measure/#sklearn.metrics.homogeneity_completeness_v_measure" title="sklearn.metrics.homogeneity_completeness_v_measure"><code>homogeneity_completeness_v_measure</code></a> as follows:</p> <pre data-language="python">&gt;&gt;&gt; metrics.homogeneity_completeness_v_measure(labels_true, labels_pred)
...                                                      
(0.66..., 0.42..., 0.51...)
</pre> <p>The following clustering assignment is slightly better, since it is homogeneous but not complete:</p> <pre data-language="python">&gt;&gt;&gt; labels_pred = [0, 0, 0, 1, 2, 2]
&gt;&gt;&gt; metrics.homogeneity_completeness_v_measure(labels_true, labels_pred)
...                                                      
(1.0, 0.68..., 0.81...)
</pre> <div class="admonition note"> <p class="first admonition-title">Note</p> <p><a class="reference internal" href="../generated/sklearn.metrics.v_measure_score/#sklearn.metrics.v_measure_score" title="sklearn.metrics.v_measure_score"><code>v_measure_score</code></a> is <strong>symmetric</strong>: it can be used to evaluate the <strong>agreement</strong> of two independent assignments on the same dataset.</p> <p>This is not the case for <a class="reference internal" href="../generated/sklearn.metrics.completeness_score/#sklearn.metrics.completeness_score" title="sklearn.metrics.completeness_score"><code>completeness_score</code></a> and <a class="reference internal" href="../generated/sklearn.metrics.homogeneity_score/#sklearn.metrics.homogeneity_score" title="sklearn.metrics.homogeneity_score"><code>homogeneity_score</code></a>: both are bound by the relationship:</p> <pre data-language="python">homogeneity_score(a, b) == completeness_score(b, a)
</pre> </div>  <h4 id="id13">2.3.9.3.1. Advantages</h4> <ul class="simple"> <li>
<strong>Bounded scores</strong>: 0.0 is as bad as it can be, 1.0 is a perfect score.</li> <li>Intuitive interpretation: clustering with bad V-measure can be <strong>qualitatively analyzed in terms of homogeneity and completeness</strong> to better feel what ‘kind’ of mistakes is done by the assignment.</li> <li>
<strong>No assumption is made on the cluster structure</strong>: can be used to compare clustering algorithms such as k-means which assumes isotropic blob shapes with results of spectral clustering algorithms which can find cluster with “folded” shapes.</li> </ul>   <h4 id="id14">2.3.9.3.2. Drawbacks</h4> <ul> <li>
<p class="first">The previously introduced metrics are <strong>not normalized with regards to random labeling</strong>: this means that depending on the number of samples, clusters and ground truth classes, a completely random labeling will not always yield the same values for homogeneity, completeness and hence v-measure. In particular <strong>random labeling won’t yield zero scores especially when the number of clusters is large</strong>.</p> <p>This problem can safely be ignored when the number of samples is more than a thousand and the number of clusters is less than 10. <strong>For smaller sample sizes or larger number of clusters it is safer to use an adjusted index such as the Adjusted Rand Index (ARI)</strong>.</p> </li> </ul> <div class="figure align-center"> <a class="reference external image-reference" href="../../auto_examples/cluster/plot_adjusted_for_chance_measures/"><img alt="../_images/sphx_glr_plot_adjusted_for_chance_measures_0011.png" src="http://scikit-learn.org/stable/_images/sphx_glr_plot_adjusted_for_chance_measures_0011.png" style="width: 800.0px; height: 600.0px;"></a> </div> <ul class="simple"> <li>These metrics <strong>require the knowledge of the ground truth classes</strong> while almost never available in practice or requires manual assignment by human annotators (as in the supervised learning setting).</li> </ul> <div class="topic"> <p class="topic-title first">Examples:</p> <ul class="simple"> <li>
<a class="reference internal" href="../../auto_examples/cluster/plot_adjusted_for_chance_measures/#sphx-glr-auto-examples-cluster-plot-adjusted-for-chance-measures-py"><span class="std std-ref">Adjustment for chance in clustering performance evaluation</span></a>: Analysis of the impact of the dataset size on the value of clustering measures for random assignments.</li> </ul> </div>   <h4 id="id15">2.3.9.3.3. Mathematical formulation</h4> <p>Homogeneity and completeness scores are formally given by:</p> <div class="math"> <p><img src="http://scikit-learn.org/stable/_images/math/4eae7305ba610c270c5c9e4263ed9acf913ba007.png" alt="h = 1 - \frac{H(C|K)}{H(C)}"></p> </div>
<div class="math"> <p><img src="http://scikit-learn.org/stable/_images/math/8ff8386869d495bc50a4706de873f17a6b33857b.png" alt="c = 1 - \frac{H(K|C)}{H(K)}"></p> </div>
<p>where <img class="math" src="http://scikit-learn.org/stable/_images/math/aaf61b1fd6d31f036edf11968b0eaad522e34055.png" alt="H(C|K)"> is the <strong>conditional entropy of the classes given the cluster assignments</strong> and is given by:</p> <div class="math"> <p><img src="http://scikit-learn.org/stable/_images/math/2aa7de2883cc6975b1c30c2898808a32788f59d7.png" alt="H(C|K) = - \sum_{c=1}^{|C|} \sum_{k=1}^{|K|} \frac{n_{c,k}}{n}
\cdot \log\left(\frac{n_{c,k}}{n_k}\right)"></p> </div>
<p>and <img class="math" src="http://scikit-learn.org/stable/_images/math/a8595a5df5bd836f3ee3ebe47ccc794962333c40.png" alt="H(C)"> is the <strong>entropy of the classes</strong> and is given by:</p> <div class="math"> <p><img src="http://scikit-learn.org/stable/_images/math/f894c65ebe3815a688a0481f537122712ccafd9b.png" alt="H(C) = - \sum_{c=1}^{|C|} \frac{n_c}{n} \cdot \log\left(\frac{n_c}{n}\right)"></p> </div>
<p>with <img class="math" src="http://scikit-learn.org/stable/_images/math/e11f2701c4a39c7fe543a6c4150b421d50f1c159.png" alt="n"> the total number of samples, <img class="math" src="http://scikit-learn.org/stable/_images/math/051b9dee87be783a0c3611714711273d1aeabe76.png" alt="n_c"> and <img class="math" src="http://scikit-learn.org/stable/_images/math/05a186404e8b4418ad56e3bbefdd24eed1d3b7b9.png" alt="n_k"> the number of samples respectively belonging to class <img class="math" src="http://scikit-learn.org/stable/_images/math/ae12a24f88803b5895632e4848d87d46483c492c.png" alt="c"> and cluster <img class="math" src="http://scikit-learn.org/stable/_images/math/0b7c1e16a3a8a849bb8ffdcdbf86f65fd1f30438.png" alt="k">, and finally <img class="math" src="http://scikit-learn.org/stable/_images/math/37cec6cd5049118b6dbcbc3bfa653ebb8b5642cc.png" alt="n_{c,k}"> the number of samples from class <img class="math" src="http://scikit-learn.org/stable/_images/math/ae12a24f88803b5895632e4848d87d46483c492c.png" alt="c"> assigned to cluster <img class="math" src="http://scikit-learn.org/stable/_images/math/0b7c1e16a3a8a849bb8ffdcdbf86f65fd1f30438.png" alt="k">.</p> <p>The <strong>conditional entropy of clusters given class</strong> <img class="math" src="http://scikit-learn.org/stable/_images/math/85eddde697732d00687c0ad12c6a497619e7ef1a.png" alt="H(K|C)"> and the <strong>entropy of clusters</strong> <img class="math" src="http://scikit-learn.org/stable/_images/math/536e2430593684928dfdf19f1c9c6fd5527627ed.png" alt="H(K)"> are defined in a symmetric manner.</p> <p>Rosenberg and Hirschberg further define <strong>V-measure</strong> as the <strong>harmonic mean of homogeneity and completeness</strong>:</p> <div class="math"> <p><img src="http://scikit-learn.org/stable/_images/math/75386d3303e203cc2e0a4176e7139bac314e1ac2.png" alt="v = 2 \cdot \frac{h \cdot c}{h + c}"></p> </div>
<div class="topic"> <p class="topic-title first">References</p> <table class="docutils citation" frame="void" id="rh2007" rules="none">   <tr>
<td class="label">[RH2007]</td>
<td>
<a class="reference external" href="http://aclweb.org/anthology/D/D07/D07-1043.pdf" target="_blank">V-Measure: A conditional entropy-based external cluster evaluation measure</a> Andrew Rosenberg and Julia Hirschberg, 2007</td>
</tr>  </table> <table class="docutils citation" frame="void" id="b2011" rules="none">   <tr>
<td class="label"><a class="fn-backref" href="#id12">[B2011]</a></td>
<td>
<a class="reference external" href="http://www.cs.columbia.edu/~hila/hila-thesis-distributed.pdf" target="_blank">Identication and Characterization of Events in Social Media</a>, Hila Becker, PhD Thesis.</td>
</tr>  </table> </div>    <h3 id="id16">2.3.9.4. Fowlkes-Mallows scores</h3> <p id="fowlkes-mallows-scores">The Fowlkes-Mallows index (<a class="reference internal" href="../generated/sklearn.metrics.fowlkes_mallows_score/#sklearn.metrics.fowlkes_mallows_score" title="sklearn.metrics.fowlkes_mallows_score"><code>sklearn.metrics.fowlkes_mallows_score</code></a>) can be used when the ground truth class assignments of the samples is known. The Fowlkes-Mallows score FMI is defined as the geometric mean of the pairwise precision and recall:</p> <div class="math"> <p><img src="http://scikit-learn.org/stable/_images/math/a940f78181ed14c52165063f34b7f8d481220498.png" alt="\text{FMI} = \frac{\text{TP}}{\sqrt{(\text{TP} + \text{FP}) (\text{TP} + \text{FN})}}"></p> </div>
<p>Where <code>TP</code> is the number of <strong>True Positive</strong> (i.e. the number of pair of points that belong to the same clusters in both the true labels and the predicted labels), <code>FP</code> is the number of <strong>False Positive</strong> (i.e. the number of pair of points that belong to the same clusters in the true labels and not in the predicted labels) and <code>FN</code> is the number of <strong>False Negative</strong> (i.e the number of pair of points that belongs in the same clusters in the predicted labels and not in the true labels).</p> <p>The score ranges from 0 to 1. A high value indicates a good similarity between two clusters.</p> <pre data-language="python">&gt;&gt;&gt; from sklearn import metrics
&gt;&gt;&gt; labels_true = [0, 0, 0, 1, 1, 1]
&gt;&gt;&gt; labels_pred = [0, 0, 1, 1, 2, 2]
</pre> <pre data-language="python">&gt;&gt;&gt; metrics.fowlkes_mallows_score(labels_true, labels_pred)  
0.47140...
</pre> <p>One can permute 0 and 1 in the predicted labels, rename 2 to 3 and get the same score:</p> <pre data-language="python">&gt;&gt;&gt; labels_pred = [1, 1, 0, 0, 3, 3]

&gt;&gt;&gt; metrics.fowlkes_mallows_score(labels_true, labels_pred)  
0.47140...
</pre> <p>Perfect labeling is scored 1.0:</p> <pre data-language="python">&gt;&gt;&gt; labels_pred = labels_true[:]
&gt;&gt;&gt; metrics.fowlkes_mallows_score(labels_true, labels_pred)  
1.0
</pre> <p>Bad (e.g. independent labelings) have zero scores:</p> <pre data-language="python">&gt;&gt;&gt; labels_true = [0, 1, 2, 0, 3, 4, 5, 1]
&gt;&gt;&gt; labels_pred = [1, 1, 0, 0, 2, 2, 2, 2]
&gt;&gt;&gt; metrics.fowlkes_mallows_score(labels_true, labels_pred)  
0.0
</pre>  <h4 id="id17">2.3.9.4.1. Advantages</h4> <ul class="simple"> <li>
<strong>Random (uniform) label assignments have a FMI score close to 0.0</strong> for any value of <code>n_clusters</code> and <code>n_samples</code> (which is not the case for raw Mutual Information or the V-measure for instance).</li> <li>
<strong>Bounded range [0, 1]</strong>: Values close to zero indicate two label assignments that are largely independent, while values close to one indicate significant agreement. Further, values of exactly 0 indicate <strong>purely</strong> independent label assignments and a AMI of exactly 1 indicates that the two label assignments are equal (with or without permutation).</li> <li>
<strong>No assumption is made on the cluster structure</strong>: can be used to compare clustering algorithms such as k-means which assumes isotropic blob shapes with results of spectral clustering algorithms which can find cluster with “folded” shapes.</li> </ul>   <h4 id="id18">2.3.9.4.2. Drawbacks</h4> <ul class="simple"> <li>Contrary to inertia, <strong>FMI-based measures require the knowledge of the ground truth classes</strong> while almost never available in practice or requires manual assignment by human annotators (as in the supervised learning setting).</li> </ul> <div class="topic"> <p class="topic-title first">References</p> <ul class="simple"> <li>E. B. Fowkles and C. L. Mallows, 1983. “A method for comparing two hierarchical clusterings”. Journal of the American Statistical Association. <a class="reference external" href="http://wildfire.stat.ucla.edu/pdflibrary/fowlkes.pdf" target="_blank">http://wildfire.stat.ucla.edu/pdflibrary/fowlkes.pdf</a>
</li> <li><a class="reference external" href="https://en.wikipedia.org/wiki/Fowlkes-Mallows_index" target="_blank">Wikipedia entry for the Fowlkes-Mallows Index</a></li> </ul> </div>    <h3 id="id19">2.3.9.5. Silhouette Coefficient</h3> <p id="silhouette-coefficient">If the ground truth labels are not known, evaluation must be performed using the model itself. The Silhouette Coefficient (<a class="reference internal" href="../generated/sklearn.metrics.silhouette_score/#sklearn.metrics.silhouette_score" title="sklearn.metrics.silhouette_score"><code>sklearn.metrics.silhouette_score</code></a>) is an example of such an evaluation, where a higher Silhouette Coefficient score relates to a model with better defined clusters. The Silhouette Coefficient is defined for each sample and is composed of two scores:</p> <ul class="simple"> <li>
<strong>a</strong>: The mean distance between a sample and all other points in the same class.</li> <li>
<strong>b</strong>: The mean distance between a sample and all other points in the <em>next nearest cluster</em>.</li> </ul> <p>The Silhouette Coefficient <em>s</em> for a single sample is then given as:</p> <div class="math"> <p><img src="http://scikit-learn.org/stable/_images/math/140645694ceee0214c8d7716954577b3fd2c5bdb.png" alt="s = \frac{b - a}{max(a, b)}"></p> </div>
<p>The Silhouette Coefficient for a set of samples is given as the mean of the Silhouette Coefficient for each sample.</p> <pre data-language="python">&gt;&gt;&gt; from sklearn import metrics
&gt;&gt;&gt; from sklearn.metrics import pairwise_distances
&gt;&gt;&gt; from sklearn import datasets
&gt;&gt;&gt; dataset = datasets.load_iris()
&gt;&gt;&gt; X = dataset.data
&gt;&gt;&gt; y = dataset.target
</pre> <p>In normal usage, the Silhouette Coefficient is applied to the results of a cluster analysis.</p> <pre data-language="python">&gt;&gt;&gt; import numpy as np
&gt;&gt;&gt; from sklearn.cluster import KMeans
&gt;&gt;&gt; kmeans_model = KMeans(n_clusters=3, random_state=1).fit(X)
&gt;&gt;&gt; labels = kmeans_model.labels_
&gt;&gt;&gt; metrics.silhouette_score(X, labels, metric='euclidean')
...                                                      
0.55...
</pre> <div class="topic"> <p class="topic-title first">References</p> <ul class="simple"> <li>Peter J. Rousseeuw (1987). “Silhouettes: a Graphical Aid to the Interpretation and Validation of Cluster Analysis”. Computational and Applied Mathematics 20: 53–65. <a class="reference external" href="http://dx.doi.org/10.1016/0377-0427(87)90125-7" target="_blank">doi:10.1016/0377-0427(87)90125-7</a>.</li> </ul> </div>  <h4 id="id20">2.3.9.5.1. Advantages</h4> <ul class="simple"> <li>The score is bounded between -1 for incorrect clustering and +1 for highly dense clustering. Scores around zero indicate overlapping clusters.</li> <li>The score is higher when clusters are dense and well separated, which relates to a standard concept of a cluster.</li> </ul>   <h4 id="id21">2.3.9.5.2. Drawbacks</h4> <ul class="simple"> <li>The Silhouette Coefficient is generally higher for convex clusters than other concepts of clusters, such as density based clusters like those obtained through DBSCAN.</li> </ul> <div class="topic"> <p class="topic-title first">Examples:</p> <ul class="simple"> <li>
<a class="reference internal" href="../../auto_examples/cluster/plot_kmeans_silhouette_analysis/#sphx-glr-auto-examples-cluster-plot-kmeans-silhouette-analysis-py"><span class="std std-ref">Selecting the number of clusters with silhouette analysis on KMeans clustering</span></a> : In this example the silhouette analysis is used to choose an optimal value for n_clusters.</li> </ul> </div>    <h3 id="id22">2.3.9.6. Calinski-Harabaz Index</h3> <p id="calinski-harabaz-index">If the ground truth labels are not known, the Calinski-Harabaz index (<a class="reference internal" href="../generated/sklearn.metrics.calinski_harabaz_score/#sklearn.metrics.calinski_harabaz_score" title="sklearn.metrics.calinski_harabaz_score"><code>sklearn.metrics.calinski_harabaz_score</code></a>) can be used to evaluate the model, where a higher Calinski-Harabaz score relates to a model with better defined clusters.</p> <p>For <img class="math" src="http://scikit-learn.org/stable/_images/math/0b7c1e16a3a8a849bb8ffdcdbf86f65fd1f30438.png" alt="k"> clusters, the Calinski-Harabaz score <img class="math" src="http://scikit-learn.org/stable/_images/math/63751cb2e98ba393b0f22e45ca127c3cebb61487.png" alt="s"> is given as the ratio of the between-clusters dispersion mean and the within-cluster dispersion:</p> <div class="math"> <p><img src="http://scikit-learn.org/stable/_images/math/66e217c045c57898975dd3d3ea651747ed9a5c19.png" alt="s(k) = \frac{\mathrm{Tr}(B_k)}{\mathrm{Tr}(W_k)} \times \frac{N - k}{k - 1}"></p> </div>
<p>where <img class="math" src="http://scikit-learn.org/stable/_images/math/b0cd669148609abb7c9af6fa3e706b7b79577b5c.png" alt="B_K"> is the between group dispersion matrix and <img class="math" src="http://scikit-learn.org/stable/_images/math/e7d8801b1f41dc013f994d181b7826d2a0fc4f88.png" alt="W_K"> is the within-cluster dispersion matrix defined by:</p> <div class="math"> <p><img src="http://scikit-learn.org/stable/_images/math/48eba4dc277d1cbf5d1f61fe7ec36042198b7a98.png" alt="W_k = \sum_{q=1}^k \sum_{x \in C_q} (x - c_q) (x - c_q)^T"></p> </div>
<div class="math"> <p><img src="http://scikit-learn.org/stable/_images/math/488a40c7485d836c31ddf1b5d4267429d625983e.png" alt="B_k = \sum_q n_q (c_q - c) (c_q - c)^T"></p> </div>
<p>with <img class="math" src="http://scikit-learn.org/stable/_images/math/f4170ed8938b79490d8923857962695514a8e4cb.png" alt="N"> be the number of points in our data, <img class="math" src="http://scikit-learn.org/stable/_images/math/98a0fb38d49709c39a35007dd817dff8b7b3e68a.png" alt="C_q"> be the set of points in cluster <img class="math" src="http://scikit-learn.org/stable/_images/math/620a3ce6403ec82f1347af9985bc03f7a9382f4a.png" alt="q">, <img class="math" src="http://scikit-learn.org/stable/_images/math/70819c4bdcf3aecea24eac192c0365fa0ccab488.png" alt="c_q"> be the center of cluster <img class="math" src="http://scikit-learn.org/stable/_images/math/620a3ce6403ec82f1347af9985bc03f7a9382f4a.png" alt="q">, <img class="math" src="http://scikit-learn.org/stable/_images/math/ae12a24f88803b5895632e4848d87d46483c492c.png" alt="c"> be the center of <img class="math" src="http://scikit-learn.org/stable/_images/math/4b6222b865b812d2a59368cd1629eed6b54454d5.png" alt="E">, <img class="math" src="http://scikit-learn.org/stable/_images/math/435c528d448d9b4bdaf384010cede06da9c69c32.png" alt="n_q"> be the number of points in cluster <img class="math" src="http://scikit-learn.org/stable/_images/math/620a3ce6403ec82f1347af9985bc03f7a9382f4a.png" alt="q">.</p> <pre data-language="python">&gt;&gt;&gt; from sklearn import metrics
&gt;&gt;&gt; from sklearn.metrics import pairwise_distances
&gt;&gt;&gt; from sklearn import datasets
&gt;&gt;&gt; dataset = datasets.load_iris()
&gt;&gt;&gt; X = dataset.data
&gt;&gt;&gt; y = dataset.target
</pre> <p>In normal usage, the Calinski-Harabaz index is applied to the results of a cluster analysis.</p> <pre data-language="python">&gt;&gt;&gt; import numpy as np
&gt;&gt;&gt; from sklearn.cluster import KMeans
&gt;&gt;&gt; kmeans_model = KMeans(n_clusters=3, random_state=1).fit(X)
&gt;&gt;&gt; labels = kmeans_model.labels_
&gt;&gt;&gt; metrics.calinski_harabaz_score(X, labels)  
560.39...
</pre>  <h4 id="id23">2.3.9.6.1. Advantages</h4> <ul class="simple"> <li>The score is higher when clusters are dense and well separated, which relates to a standard concept of a cluster.</li> <li>The score is fast to compute</li> </ul>   <h4 id="id24">2.3.9.6.2. Drawbacks</h4> <ul class="simple"> <li>The Calinski-Harabaz index is generally higher for convex clusters than other concepts of clusters, such as density based clusters like those obtained through DBSCAN.</li> </ul> <div class="topic"> <p class="topic-title first">References</p> <ul class="simple"> <li>Caliński, T., &amp; Harabasz, J. (1974). “A dendrite method for cluster analysis”. Communications in Statistics-theory and Methods 3: 1-27. <a class="reference external" href="http://dx.doi.org/10.1080/03610926.2011.560741" target="_blank">doi:10.1080/03610926.2011.560741</a>.</li> </ul> </div>
<div class="_attribution">
  <p class="_attribution-p">
    © 2007–2016 The scikit-learn developers<br>Licensed under the 3-clause BSD License.<br>
    <a href="http://scikit-learn.org/stable/modules/clustering.html" class="_attribution-link" target="_blank">http://scikit-learn.org/stable/modules/clustering.html</a>
  </p>
</div>

			</div>
		</div>
	</section>

	</div>
</body>
</html>
