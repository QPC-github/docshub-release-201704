
<!DOCTYPE HTML>

<html lang="en">

<head>
  <meta charset="utf-8">
  <title>linear_model.LogisticRegression() - Scikit-learn - W3cubDocs</title>
  
  <meta name="description" content=" Logistic Regression (aka logit, MaxEnt) classifier. ">
  <meta name="keywords" content="sklearn, linear, model, logisticregression, -, scikit-learn, scikit_learn">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="http://docs.w3cub.com/scikit_learn/modules/generated/sklearn.linear_model.logisticregression/">
  <link href="/favicon.png" rel="icon">
  <link type="text/css" rel="stylesheet" href="/assets/application-50364fff564ce3b6327021805f3f00e2957b441cf27f576a7dd4ff63bbc47047.css">
  <script type="text/javascript" src="/assets/application-db64bfd54ceb42be11af7995804cf4902548419ceb79d509b0b7d62c22d98e6f.js"></script>
  <script src="/json/scikit_learn.js"></script>
  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-71174418-1']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>


</head>

<body>
	<div class="_app">
	<header class="_header">
  
  <form class="_search">
    <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
    <a class="_search-clear"></a>
    <div class="_search-tag"></div>
  </form>
  
  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/scikit_learn/" class="_nav-link" title="" style="margin-left:0;">scikit-learn</a></span>
  
  <nav class="_nav">
    <a href="/app/" class="_nav-link ">App</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		<div class="_list">
			
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<div class="_page _sphinx">
				
<h1 id="sklearn-linear-model-logisticregression">sklearn.linear_model.LogisticRegression</h1> <dl class="class"> <dt id="sklearn.linear_model.LogisticRegression">
<code>class sklearn.linear_model.LogisticRegression(penalty='l2', dual=False, tol=0.0001, C=1.0, fit_intercept=True, intercept_scaling=1, class_weight=None, random_state=None, solver='liblinear', max_iter=100, multi_class='ovr', verbose=0, warm_start=False, n_jobs=1)</code> <a class="reference external" href="https://github.com/scikit-learn/scikit-learn/blob/412996f/sklearn/linear_model/logistic.py#L952" target="_blank"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Logistic Regression (aka logit, MaxEnt) classifier.</p> <p>In the multiclass case, the training algorithm uses the one-vs-rest (OvR) scheme if the ‘multi_class’ option is set to ‘ovr’, and uses the cross- entropy loss if the ‘multi_class’ option is set to ‘multinomial’. (Currently the ‘multinomial’ option is supported only by the ‘lbfgs’, ‘sag’ and ‘newton-cg’ solvers.)</p> <p>This class implements regularized logistic regression using the ‘liblinear’ library, ‘newton-cg’, ‘sag’ and ‘lbfgs’ solvers. It can handle both dense and sparse input. Use C-ordered arrays or CSR matrices containing 64-bit floats for optimal performance; any other input format will be converted (and copied).</p> <p>The ‘newton-cg’, ‘sag’, and ‘lbfgs’ solvers support only L2 regularization with primal formulation. The ‘liblinear’ solver supports both L1 and L2 regularization, with a dual formulation only for the L2 penalty.</p> <p>Read more in the <a class="reference internal" href="../../linear_model/#logistic-regression"><span class="std std-ref">User Guide</span></a>.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr class="field-odd field">
<th class="field-name">Parameters:</th>
<td class="field-body">
<p class="first"><strong>penalty</strong> : str, ‘l1’ or ‘l2’, default: ‘l2’</p>  <p>Used to specify the norm used in the penalization. The ‘newton-cg’, ‘sag’ and ‘lbfgs’ solvers support only l2 penalties.</p>  <p><strong>dual</strong> : bool, default: False</p>  <p>Dual or primal formulation. Dual formulation is only implemented for l2 penalty with liblinear solver. Prefer dual=False when n_samples &gt; n_features.</p>  <p><strong>C</strong> : float, default: 1.0</p>  <p>Inverse of regularization strength; must be a positive float. Like in support vector machines, smaller values specify stronger regularization.</p>  <p><strong>fit_intercept</strong> : bool, default: True</p>  <p>Specifies if a constant (a.k.a. bias or intercept) should be added to the decision function.</p>  <p><strong>intercept_scaling</strong> : float, default 1.</p>  <p>Useful only when the solver ‘liblinear’ is used and self.fit_intercept is set to True. In this case, x becomes [x, self.intercept_scaling], i.e. a “synthetic” feature with constant value equal to intercept_scaling is appended to the instance vector. The intercept becomes <code>intercept_scaling * synthetic_feature_weight</code>.</p> <p>Note! the synthetic feature weight is subject to l1/l2 regularization as all other features. To lessen the effect of regularization on synthetic feature weight (and therefore on the intercept) intercept_scaling has to be increased.</p>  <p><strong>class_weight</strong> : dict or ‘balanced’, default: None</p>  <p>Weights associated with classes in the form <code>{class_label: weight}</code>. If not given, all classes are supposed to have weight one.</p> <p>The “balanced” mode uses the values of y to automatically adjust weights inversely proportional to class frequencies in the input data as <code>n_samples / (n_classes * np.bincount(y))</code>.</p> <p>Note that these weights will be multiplied with sample_weight (passed through the fit method) if sample_weight is specified.</p> <div class="versionadded"> <p><span class="versionmodified">New in version 0.17: </span><em>class_weight=’balanced’</em> instead of deprecated <em>class_weight=’auto’</em>.</p> </div>  <p><strong>max_iter</strong> : int, default: 100</p>  <p>Useful only for the newton-cg, sag and lbfgs solvers. Maximum number of iterations taken for the solvers to converge.</p>  <p><strong>random_state</strong> : int seed, RandomState instance, default: None</p>  <p>The seed of the pseudo random number generator to use when shuffling the data. Used only in solvers ‘sag’ and ‘liblinear’.</p>  <p><strong>solver</strong> : {‘newton-cg’, ‘lbfgs’, ‘liblinear’, ‘sag’}, default: ‘liblinear’</p>  <p>Algorithm to use in the optimization problem.</p> <ul> <li>
<dl class="first docutils"> <dt>For small datasets, ‘liblinear’ is a good choice, whereas ‘sag’ is</dt> <dd>
<p class="first last">faster for large ones.</p> </dd> </dl> </li> <li>
<dl class="first docutils"> <dt>For multiclass problems, only ‘newton-cg’, ‘sag’ and ‘lbfgs’ handle</dt> <dd>
<p class="first last">multinomial loss; ‘liblinear’ is limited to one-versus-rest schemes.</p> </dd> </dl> </li> <li>‘newton-cg’, ‘lbfgs’ and ‘sag’ only handle L2 penalty. </li> </ul> <p>Note that ‘sag’ fast convergence is only guaranteed on features with approximately the same scale. You can preprocess the data with a scaler from sklearn.preprocessing.</p> <div class="versionadded"> <p><span class="versionmodified">New in version 0.17: </span>Stochastic Average Gradient descent solver.</p> </div>  <p><strong>tol</strong> : float, default: 1e-4</p>  <p>Tolerance for stopping criteria.</p>  <p><strong>multi_class</strong> : str, {‘ovr’, ‘multinomial’}, default: ‘ovr’</p>  <p>Multiclass option can be either ‘ovr’ or ‘multinomial’. If the option chosen is ‘ovr’, then a binary problem is fit for each label. Else the loss minimised is the multinomial loss fit across the entire probability distribution. Works only for the ‘newton-cg’, ‘sag’ and ‘lbfgs’ solver.</p> <div class="versionadded"> <p><span class="versionmodified">New in version 0.18: </span>Stochastic Average Gradient descent solver for ‘multinomial’ case.</p> </div>  <p><strong>verbose</strong> : int, default: 0</p>  <p>For the liblinear and lbfgs solvers set verbose to any positive number for verbosity.</p>  <p><strong>warm_start</strong> : bool, default: False</p>  <p>When set to True, reuse the solution of the previous call to fit as initialization, otherwise, just erase the previous solution. Useless for liblinear solver.</p> <div class="versionadded"> <p><span class="versionmodified">New in version 0.17: </span><em>warm_start</em> to support <em>lbfgs</em>, <em>newton-cg</em>, <em>sag</em> solvers.</p> </div>  <p><strong>n_jobs</strong> : int, default: 1</p>  <p>Number of CPU cores used during the cross-validation loop. If given a value of -1, all cores are used.</p>  </td> </tr> <tr class="field-even field">
<th class="field-name">Attributes:</th>
<td class="field-body">
<p class="first"><strong>coef_</strong> : array, shape (n_classes, n_features)</p>  <p>Coefficient of the features in the decision function.</p>  <p><strong>intercept_</strong> : array, shape (n_classes,)</p>  <p>Intercept (a.k.a. bias) added to the decision function. If <code>fit_intercept</code> is set to False, the intercept is set to zero.</p>  <p><strong>n_iter_</strong> : array, shape (n_classes,) or (1, )</p>  <p>Actual number of iterations for all classes. If binary or multinomial, it returns only 1 element. For liblinear solver, only the maximum number of iteration across all classes is given.</p>  </td> </tr>  </table> <div class="admonition seealso"> <p class="first admonition-title">See also</p> <dl class="last docutils"> <dt>
 <a class="reference internal" href="../sklearn.linear_model.sgdclassifier/#sklearn.linear_model.SGDClassifier" title="sklearn.linear_model.SGDClassifier"><code>SGDClassifier</code></a>
</dt> <dd>incrementally trained logistic regression (when given the parameter <code>loss="log"</code>).</dd> <dt>
 <a class="reference internal" href="../sklearn.svm.linearsvc/#sklearn.svm.LinearSVC" title="sklearn.svm.LinearSVC"><code>sklearn.svm.LinearSVC</code></a>
</dt> <dd>learns SVM models using the same algorithm.</dd> </dl> </div> <h4 class="rubric">Notes</h4> <p>The underlying C implementation uses a random number generator to select features when fitting the model. It is thus not uncommon, to have slightly different results for the same input data. If that happens, try with a smaller tol parameter.</p> <p>Predict output may not match that of standalone liblinear in certain cases. See <a class="reference internal" href="../../linear_model/#liblinear-differences"><span class="std std-ref">differences from liblinear</span></a> in the narrative documentation.</p> <h4 class="rubric">References</h4> <dl class="docutils"> <dt>LIBLINEAR – A Library for Large Linear Classification</dt> <dd><a class="reference external" href="http://www.csie.ntu.edu.tw/~cjlin/liblinear/" target="_blank">http://www.csie.ntu.edu.tw/~cjlin/liblinear/</a></dd> <dt>Hsiang-Fu Yu, Fang-Lan Huang, Chih-Jen Lin (2011). Dual coordinate descent</dt> <dd>methods for logistic regression and maximum entropy models. Machine Learning 85(1-2):41-75. <a class="reference external" href="http://www.csie.ntu.edu.tw/~cjlin/papers/maxent_dual.pdf" target="_blank">http://www.csie.ntu.edu.tw/~cjlin/papers/maxent_dual.pdf</a>
</dd> </dl> <h4 class="rubric">Methods</h4> <table class="longtable docutils">   <tr class="row-odd">
<td>
<a class="reference internal" href="#sklearn.linear_model.LogisticRegression.decision_function" title="sklearn.linear_model.LogisticRegression.decision_function"><code>decision_function</code></a>(X)</td> <td>Predict confidence scores for samples.</td> </tr> <tr class="row-even">
<td>
<a class="reference internal" href="#sklearn.linear_model.LogisticRegression.densify" title="sklearn.linear_model.LogisticRegression.densify"><code>densify</code></a>()</td> <td>Convert coefficient matrix to dense array format.</td> </tr> <tr class="row-odd">
<td>
<a class="reference internal" href="#sklearn.linear_model.LogisticRegression.fit" title="sklearn.linear_model.LogisticRegression.fit"><code>fit</code></a>(X, y[, sample_weight])</td> <td>Fit the model according to the given training data.</td> </tr> <tr class="row-even">
<td>
<a class="reference internal" href="#sklearn.linear_model.LogisticRegression.fit_transform" title="sklearn.linear_model.LogisticRegression.fit_transform"><code>fit_transform</code></a>(X[, y])</td> <td>Fit to data, then transform it.</td> </tr> <tr class="row-odd">
<td>
<a class="reference internal" href="#sklearn.linear_model.LogisticRegression.get_params" title="sklearn.linear_model.LogisticRegression.get_params"><code>get_params</code></a>([deep])</td> <td>Get parameters for this estimator.</td> </tr> <tr class="row-even">
<td>
<a class="reference internal" href="#sklearn.linear_model.LogisticRegression.predict" title="sklearn.linear_model.LogisticRegression.predict"><code>predict</code></a>(X)</td> <td>Predict class labels for samples in X.</td> </tr> <tr class="row-odd">
<td>
<a class="reference internal" href="#sklearn.linear_model.LogisticRegression.predict_log_proba" title="sklearn.linear_model.LogisticRegression.predict_log_proba"><code>predict_log_proba</code></a>(X)</td> <td>Log of probability estimates.</td> </tr> <tr class="row-even">
<td>
<a class="reference internal" href="#sklearn.linear_model.LogisticRegression.predict_proba" title="sklearn.linear_model.LogisticRegression.predict_proba"><code>predict_proba</code></a>(X)</td> <td>Probability estimates.</td> </tr> <tr class="row-odd">
<td>
<a class="reference internal" href="#sklearn.linear_model.LogisticRegression.score" title="sklearn.linear_model.LogisticRegression.score"><code>score</code></a>(X, y[, sample_weight])</td> <td>Returns the mean accuracy on the given test data and labels.</td> </tr> <tr class="row-even">
<td>
<a class="reference internal" href="#sklearn.linear_model.LogisticRegression.set_params" title="sklearn.linear_model.LogisticRegression.set_params"><code>set_params</code></a>(**params)</td> <td>Set the parameters of this estimator.</td> </tr> <tr class="row-odd">
<td>
<a class="reference internal" href="#sklearn.linear_model.LogisticRegression.sparsify" title="sklearn.linear_model.LogisticRegression.sparsify"><code>sparsify</code></a>()</td> <td>Convert coefficient matrix to sparse format.</td> </tr> <tr class="row-even">
<td>
<a class="reference internal" href="#sklearn.linear_model.LogisticRegression.transform" title="sklearn.linear_model.LogisticRegression.transform"><code>transform</code></a>(*args, **kwargs)</td> <td>DEPRECATED: Support to use estimators as feature selectors will be removed in version 0.19.</td> </tr>  </table> <dl class="method"> <dt id="sklearn.linear_model.LogisticRegression.__init__">
<code>__init__(penalty='l2', dual=False, tol=0.0001, C=1.0, fit_intercept=True, intercept_scaling=1, class_weight=None, random_state=None, solver='liblinear', max_iter=100, multi_class='ovr', verbose=0, warm_start=False, n_jobs=1)</code> <a class="reference external" href="https://github.com/scikit-learn/scikit-learn/blob/412996f/sklearn/linear_model/logistic.py#L1119" target="_blank"><span class="viewcode-link">[source]</span></a>
</dt> 
</dl> <dl class="method"> <dt id="sklearn.linear_model.LogisticRegression.decision_function">
<code>decision_function(X)</code> <a class="reference external" href="https://github.com/scikit-learn/scikit-learn/blob/412996f/sklearn/linear_model/base.py#L290" target="_blank"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Predict confidence scores for samples.</p> <p>The confidence score for a sample is the signed distance of that sample to the hyperplane.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr class="field-odd field">
<th class="field-name">Parameters:</th>
<td class="field-body">
<p class="first"><strong>X</strong> : {array-like, sparse matrix}, shape = (n_samples, n_features)</p>  <p>Samples.</p>  </td> </tr> <tr class="field-even field">
<th class="field-name">Returns:</th>
<td class="field-body">
<p class="first"><strong>array, shape=(n_samples,) if n_classes == 2 else (n_samples, n_classes)</strong> :</p>  <p>Confidence scores per (sample, class) combination. In the binary case, confidence score for self.classes_[1] where &gt;0 means this class would be predicted.</p>  </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="sklearn.linear_model.LogisticRegression.densify">
<code>densify()</code> <a class="reference external" href="https://github.com/scikit-learn/scikit-learn/blob/412996f/sklearn/linear_model/base.py#L369" target="_blank"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Convert coefficient matrix to dense array format.</p> <p>Converts the <code>coef_</code> member (back) to a numpy.ndarray. This is the default format of <code>coef_</code> and is required for fitting, so calling this method is only required on models that have previously been sparsified; otherwise, it is a no-op.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr class="field-odd field">
<th class="field-name">Returns:</th>
<td class="field-body">
<strong>self: estimator</strong> :</td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="sklearn.linear_model.LogisticRegression.fit">
<code>fit(X, y, sample_weight=None)</code> <a class="reference external" href="https://github.com/scikit-learn/scikit-learn/blob/412996f/sklearn/linear_model/logistic.py#L1139" target="_blank"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Fit the model according to the given training data.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr class="field-odd field">
<th class="field-name">Parameters:</th>
<td class="field-body">
<p class="first"><strong>X</strong> : {array-like, sparse matrix}, shape (n_samples, n_features)</p>  <p>Training vector, where n_samples is the number of samples and n_features is the number of features.</p>  <p><strong>y</strong> : array-like, shape (n_samples,)</p>  <p>Target vector relative to X.</p>  <p><strong>sample_weight</strong> : array-like, shape (n_samples,) optional</p>  <p>Array of weights that are assigned to individual samples. If not provided, then each sample is given unit weight.</p> <div class="versionadded"> <p><span class="versionmodified">New in version 0.17: </span><em>sample_weight</em> support to LogisticRegression.</p> </div>  </td> </tr> <tr class="field-even field">
<th class="field-name">Returns:</th>
<td class="field-body">
<p class="first"><strong>self</strong> : object</p>  <p>Returns self.</p>  </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="sklearn.linear_model.LogisticRegression.fit_transform">
<code>fit_transform(X, y=None, **fit_params)</code> <a class="reference external" href="https://github.com/scikit-learn/scikit-learn/blob/412996f/sklearn/base.py#L470" target="_blank"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Fit to data, then transform it.</p> <p>Fits transformer to X and y with optional parameters fit_params and returns a transformed version of X.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr class="field-odd field">
<th class="field-name">Parameters:</th>
<td class="field-body">
<p class="first"><strong>X</strong> : numpy array of shape [n_samples, n_features]</p>  <p>Training set.</p>  <p><strong>y</strong> : numpy array of shape [n_samples]</p>  <p>Target values.</p>  </td> </tr> <tr class="field-even field">
<th class="field-name">Returns:</th>
<td class="field-body">
<p class="first"><strong>X_new</strong> : numpy array of shape [n_samples, n_features_new]</p>  <p>Transformed array.</p>  </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="sklearn.linear_model.LogisticRegression.get_params">
<code>get_params(deep=True)</code> <a class="reference external" href="https://github.com/scikit-learn/scikit-learn/blob/412996f/sklearn/base.py#L220" target="_blank"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Get parameters for this estimator.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr class="field-odd field">
<th class="field-name">Parameters:</th>
<td class="field-body">
<p class="first"><strong>deep: boolean, optional</strong> :</p>  <p>If True, will return the parameters for this estimator and contained subobjects that are estimators.</p>  </td> </tr> <tr class="field-even field">
<th class="field-name">Returns:</th>
<td class="field-body">
<p class="first"><strong>params</strong> : mapping of string to any</p>  <p>Parameter names mapped to their values.</p>  </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="sklearn.linear_model.LogisticRegression.predict">
<code>predict(X)</code> <a class="reference external" href="https://github.com/scikit-learn/scikit-learn/blob/412996f/sklearn/linear_model/base.py#L323" target="_blank"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Predict class labels for samples in X.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr class="field-odd field">
<th class="field-name">Parameters:</th>
<td class="field-body">
<p class="first"><strong>X</strong> : {array-like, sparse matrix}, shape = [n_samples, n_features]</p>  <p>Samples.</p>  </td> </tr> <tr class="field-even field">
<th class="field-name">Returns:</th>
<td class="field-body">
<p class="first"><strong>C</strong> : array, shape = [n_samples]</p>  <p>Predicted class label per sample.</p>  </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="sklearn.linear_model.LogisticRegression.predict_log_proba">
<code>predict_log_proba(X)</code> <a class="reference external" href="https://github.com/scikit-learn/scikit-learn/blob/412996f/sklearn/linear_model/logistic.py#L1291" target="_blank"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Log of probability estimates.</p> <p>The returned estimates for all classes are ordered by the label of classes.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr class="field-odd field">
<th class="field-name">Parameters:</th>
<td class="field-body">
<p class="first"><strong>X</strong> : array-like, shape = [n_samples, n_features]</p> </td> </tr> <tr class="field-even field">
<th class="field-name">Returns:</th>
<td class="field-body">
<p class="first"><strong>T</strong> : array-like, shape = [n_samples, n_classes]</p>  <p>Returns the log-probability of the sample for each class in the model, where classes are ordered as they are in <code>self.classes_</code>.</p>  </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="sklearn.linear_model.LogisticRegression.predict_proba">
<code>predict_proba(X)</code> <a class="reference external" href="https://github.com/scikit-learn/scikit-learn/blob/412996f/sklearn/linear_model/logistic.py#L1260" target="_blank"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Probability estimates.</p> <p>The returned estimates for all classes are ordered by the label of classes.</p> <p>For a multi_class problem, if multi_class is set to be “multinomial” the softmax function is used to find the predicted probability of each class. Else use a one-vs-rest approach, i.e calculate the probability of each class assuming it to be positive using the logistic function. and normalize these values across all the classes.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr class="field-odd field">
<th class="field-name">Parameters:</th>
<td class="field-body">
<p class="first"><strong>X</strong> : array-like, shape = [n_samples, n_features]</p> </td> </tr> <tr class="field-even field">
<th class="field-name">Returns:</th>
<td class="field-body">
<p class="first"><strong>T</strong> : array-like, shape = [n_samples, n_classes]</p>  <p>Returns the probability of the sample for each class in the model, where classes are ordered as they are in <code>self.classes_</code>.</p>  </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="sklearn.linear_model.LogisticRegression.score">
<code>score(X, y, sample_weight=None)</code> <a class="reference external" href="https://github.com/scikit-learn/scikit-learn/blob/412996f/sklearn/base.py#L324" target="_blank"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Returns the mean accuracy on the given test data and labels.</p> <p>In multi-label classification, this is the subset accuracy which is a harsh metric since you require for each sample that each label set be correctly predicted.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr class="field-odd field">
<th class="field-name">Parameters:</th>
<td class="field-body">
<p class="first"><strong>X</strong> : array-like, shape = (n_samples, n_features)</p>  <p>Test samples.</p>  <p><strong>y</strong> : array-like, shape = (n_samples) or (n_samples, n_outputs)</p>  <p>True labels for X.</p>  <p><strong>sample_weight</strong> : array-like, shape = [n_samples], optional</p>  <p>Sample weights.</p>  </td> </tr> <tr class="field-even field">
<th class="field-name">Returns:</th>
<td class="field-body">
<p class="first"><strong>score</strong> : float</p>  <p>Mean accuracy of self.predict(X) wrt. y.</p>  </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="sklearn.linear_model.LogisticRegression.set_params">
<code>set_params(**params)</code> <a class="reference external" href="https://github.com/scikit-learn/scikit-learn/blob/412996f/sklearn/base.py#L257" target="_blank"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Set the parameters of this estimator.</p> <p>The method works on simple estimators as well as on nested objects (such as pipelines). The latter have parameters of the form <code>&lt;component&gt;__&lt;parameter&gt;</code> so that it’s possible to update each component of a nested object.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr class="field-odd field">
<th class="field-name">Returns:</th>
<td class="field-body">
<strong>self</strong> :</td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="sklearn.linear_model.LogisticRegression.sparsify">
<code>sparsify()</code> <a class="reference external" href="https://github.com/scikit-learn/scikit-learn/blob/412996f/sklearn/linear_model/base.py#L387" target="_blank"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Convert coefficient matrix to sparse format.</p> <p>Converts the <code>coef_</code> member to a scipy.sparse matrix, which for L1-regularized models can be much more memory- and storage-efficient than the usual numpy.ndarray representation.</p> <p>The <code>intercept_</code> member is not converted.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr class="field-odd field">
<th class="field-name">Returns:</th>
<td class="field-body">
<strong>self: estimator</strong> :</td> </tr>  </table> <h4 class="rubric">Notes</h4> <p>For non-sparse models, i.e. when there are not many zeros in <code>coef_</code>, this may actually <em>increase</em> memory usage, so use this method with care. A rule of thumb is that the number of zero elements, which can be computed with <code>(coef_ == 0).sum()</code>, must be more than 50% for this to provide significant benefits.</p> <p>After calling this method, further fitting with the partial_fit method (if any) will not work until you call densify.</p> </dd>
</dl> <dl class="method"> <dt id="sklearn.linear_model.LogisticRegression.transform">
<code>transform(*args, **kwargs)</code> <a class="reference external" href="https://github.com/scikit-learn/scikit-learn/blob/412996f/sklearn/utils/deprecation.py#L69" target="_blank"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>DEPRECATED: Support to use estimators as feature selectors will be removed in version 0.19. Use SelectFromModel instead.</p> <p>Reduce X to its most important features.</p>  Uses <code>coef_</code> or <code>feature_importances_</code> to determine the most important features. For models with a <code>coef_</code> for each class, the absolute sum over the classes is used. <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr class="field-odd field">
<th class="field-name">Parameters:</th>
<td class="field-body">
<p class="first"><strong>X</strong> : array or scipy sparse matrix of shape [n_samples, n_features]</p>   <p>The input samples.</p>  <dl class="docutils"> <dt>threshold</dt> <span class="classifier-delimiter">:</span> <span class="classifier">string, float or None, optional (default=None)</span><dd>
<p class="first last">The threshold value to use for feature selection. Features whose importance is greater or equal are kept while the others are discarded. If “median” (resp. “mean”), then the threshold value is the median (resp. the mean) of the feature importances. A scaling factor (e.g., “1.25*mean”) may also be used. If None and if available, the object attribute <code>threshold</code> is used. Otherwise, “mean” is used by default.</p> </dd> </dl>  </td> </tr> <tr class="field-even field">
<th class="field-name">Returns:</th>
<td class="field-body">
<p class="first"><strong>X_r</strong> : array of shape [n_samples, n_selected_features]</p>  <p>The input samples with only the selected features.</p>  </td> </tr>  </table> </dd>
</dl> </dd>
</dl>  <h2 id="examples-using-sklearn-linear-model-logisticregression">Examples using <code>sklearn.linear_model.LogisticRegression</code>
</h2> <div class="sphx-glr-thumbcontainer" tooltip="The PCA does an unsupervised dimensionality reduction, while the logistic regression does the p...">
<div class="figure" id="id1"> <img alt="../../_images/sphx_glr_plot_digits_pipe_thumb.png" src="http://scikit-learn.org/stable/_images/sphx_glr_plot_digits_pipe_thumb.png"> <p class="caption"><span class="caption-text"><a class="reference internal" href="../../../auto_examples/plot_digits_pipe/#sphx-glr-auto-examples-plot-digits-pipe-py"><span class="std std-ref">Pipelining: chaining a PCA and a logistic regression</span></a></span></p> </div> </div>
<div class="sphx-glr-thumbcontainer" tooltip="When performing classification one often wants to predict not only the class label, but also th...">
<div class="figure" id="id2"> <img alt="../../_images/sphx_glr_plot_calibration_curve_thumb.png" src="http://scikit-learn.org/stable/_images/sphx_glr_plot_calibration_curve_thumb.png"> <p class="caption"><span class="caption-text"><a class="reference internal" href="../../../auto_examples/calibration/plot_calibration_curve/#sphx-glr-auto-examples-calibration-plot-calibration-curve-py"><span class="std std-ref">Probability Calibration curves</span></a></span></p> </div> </div>
<div class="sphx-glr-thumbcontainer" tooltip="Well calibrated classifiers are probabilistic classifiers for which the output of the predict_p...">
<div class="figure" id="id3"> <img alt="../../_images/sphx_glr_plot_compare_calibration_thumb.png" src="http://scikit-learn.org/stable/_images/sphx_glr_plot_compare_calibration_thumb.png"> <p class="caption"><span class="caption-text"><a class="reference internal" href="../../../auto_examples/calibration/plot_compare_calibration/#sphx-glr-auto-examples-calibration-plot-compare-calibration-py"><span class="std std-ref">Comparison of Calibration of Classifiers</span></a></span></p> </div> </div>
<div class="sphx-glr-thumbcontainer" tooltip="Plot the classification probability for different classifiers. We use a 3 class dataset, and we...">
<div class="figure" id="id4"> <img alt="../../_images/sphx_glr_plot_classification_probability_thumb.png" src="http://scikit-learn.org/stable/_images/sphx_glr_plot_classification_probability_thumb.png"> <p class="caption"><span class="caption-text"><a class="reference internal" href="../../../auto_examples/classification/plot_classification_probability/#sphx-glr-auto-examples-classification-plot-classification-probability-py"><span class="std std-ref">Plot classification probability</span></a></span></p> </div> </div>
<div class="sphx-glr-thumbcontainer" tooltip="Transform your features into a higher dimensional, sparse space. Then train a linear model on t...">
<div class="figure" id="id5"> <img alt="../../_images/sphx_glr_plot_feature_transformation_thumb.png" src="http://scikit-learn.org/stable/_images/sphx_glr_plot_feature_transformation_thumb.png"> <p class="caption"><span class="caption-text"><a class="reference internal" href="../../../auto_examples/ensemble/plot_feature_transformation/#sphx-glr-auto-examples-ensemble-plot-feature-transformation-py"><span class="std std-ref">Feature transformations with ensembles of trees</span></a></span></p> </div> </div>
<div class="sphx-glr-thumbcontainer" tooltip="Plot the class probabilities of the first sample in a toy dataset predicted by three different ...">
<div class="figure" id="id6"> <img alt="../../_images/sphx_glr_plot_voting_probas_thumb.png" src="http://scikit-learn.org/stable/_images/sphx_glr_plot_voting_probas_thumb.png"> <p class="caption"><span class="caption-text"><a class="reference internal" href="../../../auto_examples/ensemble/plot_voting_probas/#sphx-glr-auto-examples-ensemble-plot-voting-probas-py"><span class="std std-ref">Plot class probabilities calculated by the VotingClassifier</span></a></span></p> </div> </div>
<div class="sphx-glr-thumbcontainer" tooltip="A tutorial exercise regarding the use of classification techniques on the Digits dataset.">
<div class="figure" id="id7"> <img alt="../../_images/sphx_glr_digits_classification_exercise_thumb.png" src="http://scikit-learn.org/stable/_images/sphx_glr_digits_classification_exercise_thumb.png"> <p class="caption"><span class="caption-text"><a class="reference internal" href="../../../auto_examples/exercises/digits_classification_exercise/#sphx-glr-auto-examples-exercises-digits-classification-exercise-py"><span class="std std-ref">Digits Classification Exercise</span></a></span></p> </div> </div>
<div class="sphx-glr-thumbcontainer" tooltip="Show below is a logistic-regression classifiers decision boundaries on the `iris &lt;https://en.wi...">
<div class="figure" id="id8"> <img alt="../../_images/sphx_glr_plot_iris_logistic_thumb.png" src="http://scikit-learn.org/stable/_images/sphx_glr_plot_iris_logistic_thumb.png"> <p class="caption"><span class="caption-text"><a class="reference internal" href="../../../auto_examples/linear_model/plot_iris_logistic/#sphx-glr-auto-examples-linear-model-plot-iris-logistic-py"><span class="std std-ref">Logistic Regression 3-class Classifier</span></a></span></p> </div> </div>
<div class="sphx-glr-thumbcontainer" tooltip="Show in the plot is how the logistic regression would, in this synthetic dataset, classify valu...">
<div class="figure" id="id9"> <img alt="../../_images/sphx_glr_plot_logistic_thumb.png" src="http://scikit-learn.org/stable/_images/sphx_glr_plot_logistic_thumb.png"> <p class="caption"><span class="caption-text"><a class="reference internal" href="../../../auto_examples/linear_model/plot_logistic/#sphx-glr-auto-examples-linear-model-plot-logistic-py"><span class="std std-ref">Logit function</span></a></span></p> </div> </div>
<div class="sphx-glr-thumbcontainer" tooltip="Comparison of the sparsity (percentage of zero coefficients) of solutions when L1 and L2 penalt...">
<div class="figure" id="id10"> <img alt="../../_images/sphx_glr_plot_logistic_l1_l2_sparsity_thumb.png" src="http://scikit-learn.org/stable/_images/sphx_glr_plot_logistic_l1_l2_sparsity_thumb.png"> <p class="caption"><span class="caption-text"><a class="reference internal" href="../../../auto_examples/linear_model/plot_logistic_l1_l2_sparsity/#sphx-glr-auto-examples-linear-model-plot-logistic-l1-l2-sparsity-py"><span class="std std-ref">L1 Penalty and Sparsity in Logistic Regression</span></a></span></p> </div> </div>
<div class="sphx-glr-thumbcontainer" tooltip="Plot decision surface of multinomial and One-vs-Rest Logistic Regression. The hyperplanes corre...">
<div class="figure" id="id11"> <img alt="../../_images/sphx_glr_plot_logistic_multinomial_thumb.png" src="http://scikit-learn.org/stable/_images/sphx_glr_plot_logistic_multinomial_thumb.png"> <p class="caption"><span class="caption-text"><a class="reference internal" href="../../../auto_examples/linear_model/plot_logistic_multinomial/#sphx-glr-auto-examples-linear-model-plot-logistic-multinomial-py"><span class="std std-ref">Plot multinomial and One-vs-Rest Logistic Regression</span></a></span></p> </div> </div>
<div class="sphx-glr-thumbcontainer" tooltip="Computes path on IRIS dataset.">
<div class="figure" id="id12"> <img alt="../../_images/sphx_glr_plot_logistic_path_thumb.png" src="http://scikit-learn.org/stable/_images/sphx_glr_plot_logistic_path_thumb.png"> <p class="caption"><span class="caption-text"><a class="reference internal" href="../../../auto_examples/linear_model/plot_logistic_path/#sphx-glr-auto-examples-linear-model-plot-logistic-path-py"><span class="std std-ref">Path with L1- Logistic Regression</span></a></span></p> </div> </div>
<div class="sphx-glr-thumbcontainer" tooltip="An example showing how different online solvers perform on the hand-written digits dataset.">
<div class="figure" id="id13"> <img alt="../../_images/sphx_glr_plot_sgd_comparison_thumb.png" src="http://scikit-learn.org/stable/_images/sphx_glr_plot_sgd_comparison_thumb.png"> <p class="caption"><span class="caption-text"><a class="reference internal" href="../../../auto_examples/linear_model/plot_sgd_comparison/#sphx-glr-auto-examples-linear-model-plot-sgd-comparison-py"><span class="std std-ref">Comparing various online solvers</span></a></span></p> </div> </div>
<div class="sphx-glr-thumbcontainer" tooltip="For greyscale image data where pixel values can be interpreted as degrees of blackness on a whi...">
<div class="figure" id="id14"> <img alt="../../_images/sphx_glr_plot_rbm_logistic_classification_thumb.png" src="http://scikit-learn.org/stable/_images/sphx_glr_plot_rbm_logistic_classification_thumb.png"> <p class="caption"><span class="caption-text"><a class="reference internal" href="../../../auto_examples/neural_networks/plot_rbm_logistic_classification/#sphx-glr-auto-examples-neural-networks-plot-rbm-logistic-classification-py"><span class="std std-ref">Restricted Boltzmann Machine features for digit classification</span></a></span></p> </div> </div>
<div class="_attribution">
  <p class="_attribution-p">
    © 2007–2016 The scikit-learn developers<br>Licensed under the 3-clause BSD License.<br>
    <a href="http://scikit-learn.org/stable/modules/generated/sklearn.linear_model.LogisticRegression.html" class="_attribution-link" target="_blank">http://scikit-learn.org/stable/modules/generated/sklearn.linear_model.LogisticRegression.html</a>
  </p>
</div>

			</div>
		</div>
	</section>

	</div>
</body>
</html>
