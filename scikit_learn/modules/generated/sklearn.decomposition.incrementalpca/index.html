
<!DOCTYPE HTML>

<html lang="en">

<head>
  <meta charset="utf-8">
  <title>decomposition.IncrementalPCA() - Scikit-learn - W3cubDocs</title>
  
  <meta name="description" content=" Incremental principal components analysis (IPCA). ">
  <meta name="keywords" content="sklearn, decomposition, incrementalpca, -, scikit-learn, scikit_learn">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="http://docs.w3cub.com/scikit_learn/modules/generated/sklearn.decomposition.incrementalpca/">
  <link href="/favicon.png" rel="icon">
  <link type="text/css" rel="stylesheet" href="/assets/application-50364fff564ce3b6327021805f3f00e2957b441cf27f576a7dd4ff63bbc47047.css">
  <script type="text/javascript" src="/assets/application-db64bfd54ceb42be11af7995804cf4902548419ceb79d509b0b7d62c22d98e6f.js"></script>
  <script src="/json/scikit_learn.js"></script>
  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-71174418-1']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>


</head>

<body>
	<div class="_app">
	<header class="_header">
  
  <form class="_search">
    <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
    <a class="_search-clear"></a>
    <div class="_search-tag"></div>
  </form>
  
  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/scikit_learn/" class="_nav-link" title="" style="margin-left:0;">scikit-learn</a></span>
  
  <nav class="_nav">
    <a href="/app/" class="_nav-link ">App</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		<div class="_list">
			
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<div class="_page _sphinx">
				
<h1 id="sklearn-decomposition-incrementalpca">sklearn.decomposition.IncrementalPCA</h1> <dl class="class"> <dt id="sklearn.decomposition.IncrementalPCA">
<code>class sklearn.decomposition.IncrementalPCA(n_components=None, whiten=False, copy=True, batch_size=None)</code> <a class="reference external" href="https://github.com/scikit-learn/scikit-learn/blob/412996f/sklearn/decomposition/incremental_pca.py#L15" target="_blank"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Incremental principal components analysis (IPCA).</p> <p>Linear dimensionality reduction using Singular Value Decomposition of centered data, keeping only the most significant singular vectors to project the data to a lower dimensional space.</p> <p>Depending on the size of the input data, this algorithm can be much more memory efficient than a PCA.</p> <p>This algorithm has constant memory complexity, on the order of <code>batch_size</code>, enabling use of np.memmap files without loading the entire file into memory.</p> <p>The computational overhead of each SVD is <code>O(batch_size * n_features ** 2)</code>, but only 2 * batch_size samples remain in memory at a time. There will be <code>n_samples / batch_size</code> SVD computations to get the principal components, versus 1 large SVD of complexity <code>O(n_samples * n_features ** 2)</code> for PCA.</p> <p>Read more in the <a class="reference internal" href="../../decomposition/#incrementalpca"><span class="std std-ref">User Guide</span></a>.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr class="field-odd field">
<th class="field-name">Parameters:</th>
<td class="field-body">
<p class="first"><strong>n_components</strong> : int or None, (default=None)</p>  <p>Number of components to keep. If <code>n_components `` is ``None</code>, then <code>n_components</code> is set to <code>min(n_samples, n_features)</code>.</p>  <p><strong>batch_size</strong> : int or None, (default=None)</p>  <p>The number of samples to use for each batch. Only used when calling <code>fit</code>. If <code>batch_size</code> is <code>None</code>, then <code>batch_size</code> is inferred from the data and set to <code>5 * n_features</code>, to provide a balance between approximation accuracy and memory consumption.</p>  <p><strong>copy</strong> : bool, (default=True)</p>  <p>If False, X will be overwritten. <code>copy=False</code> can be used to save memory but is unsafe for general use.</p>  <p><strong>whiten</strong> : bool, optional</p>  <p>When True (False by default) the <code>components_</code> vectors are divided by <code>n_samples</code> times <code>components_</code> to ensure uncorrelated outputs with unit component-wise variances.</p> <p>Whitening will remove some information from the transformed signal (the relative variance scales of the components) but can sometimes improve the predictive accuracy of the downstream estimators by making data respect some hard-wired assumptions.</p>  </td> </tr> <tr class="field-even field">
<th class="field-name">Attributes:</th>
<td class="field-body">
<p class="first"><strong>components_</strong> : array, shape (n_components, n_features)</p>  <p>Components with maximum variance.</p>  <p><strong>explained_variance_</strong> : array, shape (n_components,)</p>  <p>Variance explained by each of the selected components.</p>  <p><strong>explained_variance_ratio_</strong> : array, shape (n_components,)</p>  <p>Percentage of variance explained by each of the selected components. If all components are stored, the sum of explained variances is equal to 1.0</p>  <p><strong>mean_</strong> : array, shape (n_features,)</p>  <p>Per-feature empirical mean, aggregate over calls to <code>partial_fit</code>.</p>  <p><strong>var_</strong> : array, shape (n_features,)</p>  <p>Per-feature empirical variance, aggregate over calls to <code>partial_fit</code>.</p>  <p><strong>noise_variance_</strong> : float</p>  <p>The estimated noise covariance following the Probabilistic PCA model from Tipping and Bishop 1999. See “Pattern Recognition and Machine Learning” by C. Bishop, 12.2.1 p. 574 or <a class="reference external" href="http://www.miketipping.com/papers/met-mppca.pdf" target="_blank">http://www.miketipping.com/papers/met-mppca.pdf</a>.</p>  <p><strong>n_components_</strong> : int</p>  <p>The estimated number of components. Relevant when <code>n_components=None</code>.</p>  <p><strong>n_samples_seen_</strong> : int</p>  <p>The number of samples processed by the estimator. Will be reset on new calls to fit, but increments across <code>partial_fit</code> calls.</p>  </td> </tr>  </table> <div class="admonition seealso"> <p class="first admonition-title">See also</p> <p class="last"><a class="reference internal" href="../sklearn.decomposition.pca/#sklearn.decomposition.PCA" title="sklearn.decomposition.PCA"><code>PCA</code></a>, <a class="reference internal" href="../sklearn.decomposition.randomizedpca/#sklearn.decomposition.RandomizedPCA" title="sklearn.decomposition.RandomizedPCA"><code>RandomizedPCA</code></a>, <a class="reference internal" href="../sklearn.decomposition.kernelpca/#sklearn.decomposition.KernelPCA" title="sklearn.decomposition.KernelPCA"><code>KernelPCA</code></a>, <a class="reference internal" href="../sklearn.decomposition.sparsepca/#sklearn.decomposition.SparsePCA" title="sklearn.decomposition.SparsePCA"><code>SparsePCA</code></a>, <a class="reference internal" href="../sklearn.decomposition.truncatedsvd/#sklearn.decomposition.TruncatedSVD" title="sklearn.decomposition.TruncatedSVD"><code>TruncatedSVD</code></a></p> </div> <h4 class="rubric">Notes</h4> <p>Implements the incremental PCA model from: <code>D. Ross, J. Lim, R. Lin, M. Yang, Incremental Learning for Robust Visual Tracking, International Journal of Computer Vision, Volume 77, Issue 1-3, pp. 125-141, May 2008.</code> See <a class="reference external" href="http://www.cs.toronto.edu/~dross/ivt/RossLimLinYang_ijcv.pdf" target="_blank">http://www.cs.toronto.edu/~dross/ivt/RossLimLinYang_ijcv.pdf</a></p> <p>This model is an extension of the Sequential Karhunen-Loeve Transform from: <code>A. Levy and M. Lindenbaum, Sequential Karhunen-Loeve Basis Extraction and its Application to Images, IEEE Transactions on Image Processing, Volume 9, Number 8, pp. 1371-1374, August 2000.</code> See <a class="reference external" href="http://www.cs.technion.ac.il/~mic/doc/skl-ip.pdf" target="_blank">http://www.cs.technion.ac.il/~mic/doc/skl-ip.pdf</a></p> <p>We have specifically abstained from an optimization used by authors of both papers, a QR decomposition used in specific situations to reduce the algorithmic complexity of the SVD. The source for this technique is <code>Matrix Computations, Third Edition, G. Holub and C. Van Loan, Chapter 5, section 5.4.4, pp 252-253.</code>. This technique has been omitted because it is advantageous only when decomposing a matrix with <code>n_samples</code> (rows) &gt;= 5/3 * <code>n_features</code> (columns), and hurts the readability of the implemented algorithm. This would be a good opportunity for future optimization, if it is deemed necessary.</p> <h4 class="rubric">References</h4> <ol class="upperalpha" start="4"> <li>
<dl class="first docutils"> <dt>Ross, J. Lim, R. Lin, M. Yang. Incremental Learning for Robust Visual</dt> <dd>
<p class="first last">Tracking, International Journal of Computer Vision, Volume 77, Issue 1-3, pp. 125-141, May 2008.</p> </dd> </dl> </li> </ol> <ol class="upperalpha" start="7"> <li>
<dl class="first docutils"> <dt>Golub and C. Van Loan. Matrix Computations, Third Edition, Chapter 5,</dt> <dd>
<p class="first last">Section 5.4.4, pp. 252-253.</p> </dd> </dl> </li> </ol> <h4 class="rubric">Methods</h4> <table class="longtable docutils">   <tr class="row-odd">
<td>
<a class="reference internal" href="#sklearn.decomposition.IncrementalPCA.fit" title="sklearn.decomposition.IncrementalPCA.fit"><code>fit</code></a>(X[, y])</td> <td>Fit the model with X, using minibatches of size batch_size.</td> </tr> <tr class="row-even">
<td>
<a class="reference internal" href="#sklearn.decomposition.IncrementalPCA.fit_transform" title="sklearn.decomposition.IncrementalPCA.fit_transform"><code>fit_transform</code></a>(X[, y])</td> <td>Fit to data, then transform it.</td> </tr> <tr class="row-odd">
<td>
<a class="reference internal" href="#sklearn.decomposition.IncrementalPCA.get_covariance" title="sklearn.decomposition.IncrementalPCA.get_covariance"><code>get_covariance</code></a>()</td> <td>Compute data covariance with the generative model.</td> </tr> <tr class="row-even">
<td>
<a class="reference internal" href="#sklearn.decomposition.IncrementalPCA.get_params" title="sklearn.decomposition.IncrementalPCA.get_params"><code>get_params</code></a>([deep])</td> <td>Get parameters for this estimator.</td> </tr> <tr class="row-odd">
<td>
<a class="reference internal" href="#sklearn.decomposition.IncrementalPCA.get_precision" title="sklearn.decomposition.IncrementalPCA.get_precision"><code>get_precision</code></a>()</td> <td>Compute data precision matrix with the generative model.</td> </tr> <tr class="row-even">
<td>
<a class="reference internal" href="#sklearn.decomposition.IncrementalPCA.inverse_transform" title="sklearn.decomposition.IncrementalPCA.inverse_transform"><code>inverse_transform</code></a>(X[, y])</td> <td>Transform data back to its original space.</td> </tr> <tr class="row-odd">
<td>
<a class="reference internal" href="#sklearn.decomposition.IncrementalPCA.partial_fit" title="sklearn.decomposition.IncrementalPCA.partial_fit"><code>partial_fit</code></a>(X[, y, check_input])</td> <td>Incremental fit with X.</td> </tr> <tr class="row-even">
<td>
<a class="reference internal" href="#sklearn.decomposition.IncrementalPCA.set_params" title="sklearn.decomposition.IncrementalPCA.set_params"><code>set_params</code></a>(**params)</td> <td>Set the parameters of this estimator.</td> </tr> <tr class="row-odd">
<td>
<a class="reference internal" href="#sklearn.decomposition.IncrementalPCA.transform" title="sklearn.decomposition.IncrementalPCA.transform"><code>transform</code></a>(X[, y])</td> <td>Apply dimensionality reduction to X.</td> </tr>  </table> <dl class="method"> <dt id="sklearn.decomposition.IncrementalPCA.__init__">
<code>__init__(n_components=None, whiten=False, copy=True, batch_size=None)</code> <a class="reference external" href="https://github.com/scikit-learn/scikit-learn/blob/412996f/sklearn/decomposition/incremental_pca.py#L139" target="_blank"><span class="viewcode-link">[source]</span></a>
</dt> 
</dl> <dl class="method"> <dt id="sklearn.decomposition.IncrementalPCA.fit">
<code>fit(X, y=None)</code> <a class="reference external" href="https://github.com/scikit-learn/scikit-learn/blob/412996f/sklearn/decomposition/incremental_pca.py#L146" target="_blank"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Fit the model with X, using minibatches of size batch_size.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr class="field-odd field">
<th class="field-name">Parameters:</th>
<td class="field-body">
<p class="first"><strong>X: array-like, shape (n_samples, n_features)</strong> :</p>  <p>Training data, where n_samples is the number of samples and n_features is the number of features.</p>  <p><strong>y: Passthrough for ``Pipeline`` compatibility.</strong> :</p> </td> </tr> <tr class="field-even field">
<th class="field-name">Returns:</th>
<td class="field-body">
<p class="first"><strong>self: object</strong> :</p>  <p>Returns the instance itself.</p>  </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="sklearn.decomposition.IncrementalPCA.fit_transform">
<code>fit_transform(X, y=None, **fit_params)</code> <a class="reference external" href="https://github.com/scikit-learn/scikit-learn/blob/412996f/sklearn/base.py#L470" target="_blank"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Fit to data, then transform it.</p> <p>Fits transformer to X and y with optional parameters fit_params and returns a transformed version of X.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr class="field-odd field">
<th class="field-name">Parameters:</th>
<td class="field-body">
<p class="first"><strong>X</strong> : numpy array of shape [n_samples, n_features]</p>  <p>Training set.</p>  <p><strong>y</strong> : numpy array of shape [n_samples]</p>  <p>Target values.</p>  </td> </tr> <tr class="field-even field">
<th class="field-name">Returns:</th>
<td class="field-body">
<p class="first"><strong>X_new</strong> : numpy array of shape [n_samples, n_features_new]</p>  <p>Transformed array.</p>  </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="sklearn.decomposition.IncrementalPCA.get_covariance">
<code>get_covariance()</code> <a class="reference external" href="https://github.com/scikit-learn/scikit-learn/blob/412996f/sklearn/decomposition/base.py#L28" target="_blank"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Compute data covariance with the generative model.</p> <p><code>cov = components_.T * S**2 * components_ + sigma2 * eye(n_features)</code> where S**2 contains the explained variances, and sigma2 contains the noise variances.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr class="field-odd field">
<th class="field-name">Returns:</th>
<td class="field-body">
<p class="first"><strong>cov</strong> : array, shape=(n_features, n_features)</p>  <p>Estimated covariance of data.</p>  </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="sklearn.decomposition.IncrementalPCA.get_params">
<code>get_params(deep=True)</code> <a class="reference external" href="https://github.com/scikit-learn/scikit-learn/blob/412996f/sklearn/base.py#L220" target="_blank"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Get parameters for this estimator.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr class="field-odd field">
<th class="field-name">Parameters:</th>
<td class="field-body">
<p class="first"><strong>deep: boolean, optional</strong> :</p>  <p>If True, will return the parameters for this estimator and contained subobjects that are estimators.</p>  </td> </tr> <tr class="field-even field">
<th class="field-name">Returns:</th>
<td class="field-body">
<p class="first"><strong>params</strong> : mapping of string to any</p>  <p>Parameter names mapped to their values.</p>  </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="sklearn.decomposition.IncrementalPCA.get_precision">
<code>get_precision()</code> <a class="reference external" href="https://github.com/scikit-learn/scikit-learn/blob/412996f/sklearn/decomposition/base.py#L49" target="_blank"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Compute data precision matrix with the generative model.</p> <p>Equals the inverse of the covariance but computed with the matrix inversion lemma for efficiency.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr class="field-odd field">
<th class="field-name">Returns:</th>
<td class="field-body">
<p class="first"><strong>precision</strong> : array, shape=(n_features, n_features)</p>  <p>Estimated precision of data.</p>  </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="sklearn.decomposition.IncrementalPCA.inverse_transform">
<code>inverse_transform(X, y=None)</code> <a class="reference external" href="https://github.com/scikit-learn/scikit-learn/blob/412996f/sklearn/decomposition/base.py#L138" target="_blank"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Transform data back to its original space.</p> <p>In other words, return an input X_original whose transform would be X.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr class="field-odd field">
<th class="field-name">Parameters:</th>
<td class="field-body">
<p class="first"><strong>X</strong> : array-like, shape (n_samples, n_components)</p>  <p>New data, where n_samples is the number of samples and n_components is the number of components.</p>  </td> </tr> <tr class="field-even field">
<th class="field-name">Returns:</th>
<td class="field-body">
<p class="first last"><strong>X_original array-like, shape (n_samples, n_features)</strong> :</p> </td> </tr>  </table> <h4 class="rubric">Notes</h4> <p>If whitening is enabled, inverse_transform will compute the exact inverse operation, which includes reversing whitening.</p> </dd>
</dl> <dl class="method"> <dt id="sklearn.decomposition.IncrementalPCA.partial_fit">
<code>partial_fit(X, y=None, check_input=True)</code> <a class="reference external" href="https://github.com/scikit-learn/scikit-learn/blob/412996f/sklearn/decomposition/incremental_pca.py#L184" target="_blank"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Incremental fit with X. All of X is processed as a single batch.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr class="field-odd field">
<th class="field-name">Parameters:</th>
<td class="field-body">
<p class="first"><strong>X: array-like, shape (n_samples, n_features)</strong> :</p>  <p>Training data, where n_samples is the number of samples and n_features is the number of features.</p>  </td> </tr> <tr class="field-even field">
<th class="field-name">Returns:</th>
<td class="field-body">
<p class="first"><strong>self: object</strong> :</p>  <p>Returns the instance itself.</p>  </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="sklearn.decomposition.IncrementalPCA.set_params">
<code>set_params(**params)</code> <a class="reference external" href="https://github.com/scikit-learn/scikit-learn/blob/412996f/sklearn/base.py#L257" target="_blank"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Set the parameters of this estimator.</p> <p>The method works on simple estimators as well as on nested objects (such as pipelines). The latter have parameters of the form <code>&lt;component&gt;__&lt;parameter&gt;</code> so that it’s possible to update each component of a nested object.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr class="field-odd field">
<th class="field-name">Returns:</th>
<td class="field-body">
<strong>self</strong> :</td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="sklearn.decomposition.IncrementalPCA.transform">
<code>transform(X, y=None)</code> <a class="reference external" href="https://github.com/scikit-learn/scikit-learn/blob/412996f/sklearn/decomposition/base.py#L101" target="_blank"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Apply dimensionality reduction to X.</p> <p>X is projected on the first principal components previously extracted from a training set.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr class="field-odd field">
<th class="field-name">Parameters:</th>
<td class="field-body">
<p class="first"><strong>X</strong> : array-like, shape (n_samples, n_features)</p>  <p>New data, where n_samples is the number of samples and n_features is the number of features.</p>  </td> </tr> <tr class="field-even field">
<th class="field-name">Returns:</th>
<td class="field-body">
<p class="first last"><strong>X_new</strong> : array-like, shape (n_samples, n_components)</p> </td> </tr>  </table> <h4 class="rubric">Examples</h4> <pre data-language="python">&gt;&gt;&gt; import numpy as np
&gt;&gt;&gt; from sklearn.decomposition import IncrementalPCA
&gt;&gt;&gt; X = np.array([[-1, -1], [-2, -1], [-3, -2], [1, 1], [2, 1], [3, 2]])
&gt;&gt;&gt; ipca = IncrementalPCA(n_components=2, batch_size=3)
&gt;&gt;&gt; ipca.fit(X)
IncrementalPCA(batch_size=3, copy=True, n_components=2, whiten=False)
&gt;&gt;&gt; ipca.transform(X) 
</pre> </dd>
</dl> </dd>
</dl>  <h2 id="examples-using-sklearn-decomposition-incrementalpca">Examples using <code>sklearn.decomposition.IncrementalPCA</code>
</h2> <div class="sphx-glr-thumbcontainer" tooltip="Incremental principal component analysis (IPCA) is typically used as a replacement for principa...">
<div class="figure" id="id1"> <img alt="../../_images/sphx_glr_plot_incremental_pca_thumb.png" src="http://scikit-learn.org/stable/_images/sphx_glr_plot_incremental_pca_thumb.png"> <p class="caption"><span class="caption-text"><a class="reference internal" href="../../../auto_examples/decomposition/plot_incremental_pca/#sphx-glr-auto-examples-decomposition-plot-incremental-pca-py"><span class="std std-ref">Incremental PCA</span></a></span></p> </div> </div>
<div class="_attribution">
  <p class="_attribution-p">
    © 2007–2016 The scikit-learn developers<br>Licensed under the 3-clause BSD License.<br>
    <a href="http://scikit-learn.org/stable/modules/generated/sklearn.decomposition.IncrementalPCA.html" class="_attribution-link" target="_blank">http://scikit-learn.org/stable/modules/generated/sklearn.decomposition.IncrementalPCA.html</a>
  </p>
</div>

			</div>
		</div>
	</section>

	</div>
</body>
</html>
