
<!DOCTYPE HTML>

<html lang="en">

<head>
  <meta charset="utf-8">
  <title>1.4. Support Vector Machines - Scikit-learn - W3cubDocs</title>
  
  <meta name="description" content=" Support vector machines (SVMs) are a set of supervised learning methods used for classification, regression and outliers detection. ">
  <meta name="keywords" content="support, vector, machines, -, scikit-learn, scikit_learn">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="http://docs.w3cub.com/scikit_learn/modules/svm/">
  <link href="/favicon.png" rel="icon">
  <link type="text/css" rel="stylesheet" href="/assets/application-50364fff564ce3b6327021805f3f00e2957b441cf27f576a7dd4ff63bbc47047.css">
  <script type="text/javascript" src="/assets/application-db64bfd54ceb42be11af7995804cf4902548419ceb79d509b0b7d62c22d98e6f.js"></script>
  <script src="/json/scikit_learn.js"></script>
  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-71174418-1']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>


</head>

<body>
	<div class="_app">
	<header class="_header">
  
  <form class="_search">
    <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
    <a class="_search-clear"></a>
    <div class="_search-tag"></div>
  </form>
  
  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/scikit_learn/" class="_nav-link" title="" style="margin-left:0;">scikit-learn</a></span>
  
  <nav class="_nav">
    <a href="/app/" class="_nav-link ">App</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		<div class="_list">
			
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<div class="_page _sphinx">
				
<h1 id="svm">1.4. Support Vector Machines</h1> <p id="support-vector-machines"><strong>Support vector machines (SVMs)</strong> are a set of supervised learning methods used for <a class="reference internal" href="#svm-classification"><span class="std std-ref">classification</span></a>, <a class="reference internal" href="#svm-regression"><span class="std std-ref">regression</span></a> and <a class="reference internal" href="#svm-outlier-detection"><span class="std std-ref">outliers detection</span></a>.</p> <p>The advantages of support vector machines are:</p>  <ul class="simple"> <li>Effective in high dimensional spaces.</li> <li>Still effective in cases where number of dimensions is greater than the number of samples.</li> <li>Uses a subset of training points in the decision function (called support vectors), so it is also memory efficient.</li> <li>Versatile: different <a class="reference internal" href="#svm-kernels"><span class="std std-ref">Kernel functions</span></a> can be specified for the decision function. Common kernels are provided, but it is also possible to specify custom kernels.</li> </ul>  <p>The disadvantages of support vector machines include:</p>  <ul class="simple"> <li>If the number of features is much greater than the number of samples, the method is likely to give poor performances.</li> <li>SVMs do not directly provide probability estimates, these are calculated using an expensive five-fold cross-validation (see <a class="reference internal" href="#scores-probabilities"><span class="std std-ref">Scores and probabilities</span></a>, below).</li> </ul>  <p>The support vector machines in scikit-learn support both dense (<code>numpy.ndarray</code> and convertible to that by <code>numpy.asarray</code>) and sparse (any <code>scipy.sparse</code>) sample vectors as input. However, to use an SVM to make predictions for sparse data, it must have been fit on such data. For optimal performance, use C-ordered <code>numpy.ndarray</code> (dense) or <code>scipy.sparse.csr_matrix</code> (sparse) with <code>dtype=float64</code>.</p>  <h2 id="svm-classification">1.4.1. Classification</h2> <p id="classification"><a class="reference internal" href="../generated/sklearn.svm.svc/#sklearn.svm.SVC" title="sklearn.svm.SVC"><code>SVC</code></a>, <a class="reference internal" href="../generated/sklearn.svm.nusvc/#sklearn.svm.NuSVC" title="sklearn.svm.NuSVC"><code>NuSVC</code></a> and <a class="reference internal" href="../generated/sklearn.svm.linearsvc/#sklearn.svm.LinearSVC" title="sklearn.svm.LinearSVC"><code>LinearSVC</code></a> are classes capable of performing multi-class classification on a dataset.</p> <div class="figure align-center"> <a class="reference external image-reference" href="../../auto_examples/svm/plot_iris/"><img alt="../_images/sphx_glr_plot_iris_0012.png" src="http://scikit-learn.org/stable/_images/sphx_glr_plot_iris_0012.png"></a> </div> <p><a class="reference internal" href="../generated/sklearn.svm.svc/#sklearn.svm.SVC" title="sklearn.svm.SVC"><code>SVC</code></a> and <a class="reference internal" href="../generated/sklearn.svm.nusvc/#sklearn.svm.NuSVC" title="sklearn.svm.NuSVC"><code>NuSVC</code></a> are similar methods, but accept slightly different sets of parameters and have different mathematical formulations (see section <a class="reference internal" href="#svm-mathematical-formulation"><span class="std std-ref">Mathematical formulation</span></a>). On the other hand, <a class="reference internal" href="../generated/sklearn.svm.linearsvc/#sklearn.svm.LinearSVC" title="sklearn.svm.LinearSVC"><code>LinearSVC</code></a> is another implementation of Support Vector Classification for the case of a linear kernel. Note that <a class="reference internal" href="../generated/sklearn.svm.linearsvc/#sklearn.svm.LinearSVC" title="sklearn.svm.LinearSVC"><code>LinearSVC</code></a> does not accept keyword <code>kernel</code>, as this is assumed to be linear. It also lacks some of the members of <a class="reference internal" href="../generated/sklearn.svm.svc/#sklearn.svm.SVC" title="sklearn.svm.SVC"><code>SVC</code></a> and <a class="reference internal" href="../generated/sklearn.svm.nusvc/#sklearn.svm.NuSVC" title="sklearn.svm.NuSVC"><code>NuSVC</code></a>, like <code>support_</code>.</p> <p>As other classifiers, <a class="reference internal" href="../generated/sklearn.svm.svc/#sklearn.svm.SVC" title="sklearn.svm.SVC"><code>SVC</code></a>, <a class="reference internal" href="../generated/sklearn.svm.nusvc/#sklearn.svm.NuSVC" title="sklearn.svm.NuSVC"><code>NuSVC</code></a> and <a class="reference internal" href="../generated/sklearn.svm.linearsvc/#sklearn.svm.LinearSVC" title="sklearn.svm.LinearSVC"><code>LinearSVC</code></a> take as input two arrays: an array X of size <code>[n_samples,
n_features]</code> holding the training samples, and an array y of class labels (strings or integers), size <code>[n_samples]</code>:</p> <pre data-language="python">&gt;&gt;&gt; from sklearn import svm
&gt;&gt;&gt; X = [[0, 0], [1, 1]]
&gt;&gt;&gt; y = [0, 1]
&gt;&gt;&gt; clf = svm.SVC()
&gt;&gt;&gt; clf.fit(X, y)  
SVC(C=1.0, cache_size=200, class_weight=None, coef0=0.0,
    decision_function_shape=None, degree=3, gamma='auto', kernel='rbf',
    max_iter=-1, probability=False, random_state=None, shrinking=True,
    tol=0.001, verbose=False)
</pre> <p>After being fitted, the model can then be used to predict new values:</p> <pre data-language="python">&gt;&gt;&gt; clf.predict([[2., 2.]])
array([1])
</pre> <p>SVMs decision function depends on some subset of the training data, called the support vectors. Some properties of these support vectors can be found in members <code>support_vectors_</code>, <code>support_</code> and <code>n_support</code>:</p> <pre data-language="python">&gt;&gt;&gt; # get support vectors
&gt;&gt;&gt; clf.support_vectors_
array([[ 0.,  0.],
       [ 1.,  1.]])
&gt;&gt;&gt; # get indices of support vectors
&gt;&gt;&gt; clf.support_ 
array([0, 1]...)
&gt;&gt;&gt; # get number of support vectors for each class
&gt;&gt;&gt; clf.n_support_ 
array([1, 1]...)
</pre>  <h3 id="svm-multi-class">1.4.1.1. Multi-class classification</h3> <p id="multi-class-classification"><a class="reference internal" href="../generated/sklearn.svm.svc/#sklearn.svm.SVC" title="sklearn.svm.SVC"><code>SVC</code></a> and <a class="reference internal" href="../generated/sklearn.svm.nusvc/#sklearn.svm.NuSVC" title="sklearn.svm.NuSVC"><code>NuSVC</code></a> implement the “one-against-one” approach (Knerr et al., 1990) for multi- class classification. If <code>n_class</code> is the number of classes, then <code>n_class * (n_class - 1) / 2</code> classifiers are constructed and each one trains data from two classes. To provide a consistent interface with other classifiers, the <code>decision_function_shape</code> option allows to aggregate the results of the “one-against-one” classifiers to a decision function of shape <code>(n_samples,
n_classes)</code>:</p> <pre data-language="python">&gt;&gt;&gt; X = [[0], [1], [2], [3]]
&gt;&gt;&gt; Y = [0, 1, 2, 3]
&gt;&gt;&gt; clf = svm.SVC(decision_function_shape='ovo')
&gt;&gt;&gt; clf.fit(X, Y) 
SVC(C=1.0, cache_size=200, class_weight=None, coef0=0.0,
    decision_function_shape='ovo', degree=3, gamma='auto', kernel='rbf',
    max_iter=-1, probability=False, random_state=None, shrinking=True,
    tol=0.001, verbose=False)
&gt;&gt;&gt; dec = clf.decision_function([[1]])
&gt;&gt;&gt; dec.shape[1] # 4 classes: 4*3/2 = 6
6
&gt;&gt;&gt; clf.decision_function_shape = "ovr"
&gt;&gt;&gt; dec = clf.decision_function([[1]])
&gt;&gt;&gt; dec.shape[1] # 4 classes
4
</pre> <p>On the other hand, <a class="reference internal" href="../generated/sklearn.svm.linearsvc/#sklearn.svm.LinearSVC" title="sklearn.svm.LinearSVC"><code>LinearSVC</code></a> implements “one-vs-the-rest” multi-class strategy, thus training n_class models. If there are only two classes, only one model is trained:</p> <pre data-language="python">&gt;&gt;&gt; lin_clf = svm.LinearSVC()
&gt;&gt;&gt; lin_clf.fit(X, Y) 
LinearSVC(C=1.0, class_weight=None, dual=True, fit_intercept=True,
     intercept_scaling=1, loss='squared_hinge', max_iter=1000,
     multi_class='ovr', penalty='l2', random_state=None, tol=0.0001,
     verbose=0)
&gt;&gt;&gt; dec = lin_clf.decision_function([[1]])
&gt;&gt;&gt; dec.shape[1]
4
</pre> <p>See <a class="reference internal" href="#svm-mathematical-formulation"><span class="std std-ref">Mathematical formulation</span></a> for a complete description of the decision function.</p> <p>Note that the <a class="reference internal" href="../generated/sklearn.svm.linearsvc/#sklearn.svm.LinearSVC" title="sklearn.svm.LinearSVC"><code>LinearSVC</code></a> also implements an alternative multi-class strategy, the so-called multi-class SVM formulated by Crammer and Singer, by using the option <code>multi_class='crammer_singer'</code>. This method is consistent, which is not true for one-vs-rest classification. In practice, one-vs-rest classification is usually preferred, since the results are mostly similar, but the runtime is significantly less.</p> <p>For “one-vs-rest” <a class="reference internal" href="../generated/sklearn.svm.linearsvc/#sklearn.svm.LinearSVC" title="sklearn.svm.LinearSVC"><code>LinearSVC</code></a> the attributes <code>coef_</code> and <code>intercept_</code> have the shape <code>[n_class, n_features]</code> and <code>[n_class]</code> respectively. Each row of the coefficients corresponds to one of the <code>n_class</code> many “one-vs-rest” classifiers and similar for the intercepts, in the order of the “one” class.</p> <p>In the case of “one-vs-one” <a class="reference internal" href="../generated/sklearn.svm.svc/#sklearn.svm.SVC" title="sklearn.svm.SVC"><code>SVC</code></a>, the layout of the attributes is a little more involved. In the case of having a linear kernel, The layout of <code>coef_</code> and <code>intercept_</code> is similar to the one described for <a class="reference internal" href="../generated/sklearn.svm.linearsvc/#sklearn.svm.LinearSVC" title="sklearn.svm.LinearSVC"><code>LinearSVC</code></a> described above, except that the shape of <code>coef_</code> is <code>[n_class * (n_class - 1) / 2, n_features]</code>, corresponding to as many binary classifiers. The order for classes 0 to n is “0 vs 1”, “0 vs 2” , ... “0 vs n”, “1 vs 2”, “1 vs 3”, “1 vs n”, . . . “n-1 vs n”.</p> <p>The shape of <code>dual_coef_</code> is <code>[n_class-1, n_SV]</code> with a somewhat hard to grasp layout. The columns correspond to the support vectors involved in any of the <code>n_class * (n_class - 1) / 2</code> “one-vs-one” classifiers. Each of the support vectors is used in <code>n_class - 1</code> classifiers. The <code>n_class - 1</code> entries in each row correspond to the dual coefficients for these classifiers.</p> <p>This might be made more clear by an example:</p> <p>Consider a three class problem with class 0 having three support vectors <img class="math" src="http://scikit-learn.org/stable/_images/math/773bcf5cf311791578c5444d0557e58a2d81d16f.png" alt="v^{0}_0, v^{1}_0, v^{2}_0"> and class 1 and 2 having two support vectors <img class="math" src="http://scikit-learn.org/stable/_images/math/5c032716cc6b50ab78538cab7725241bb8e6756b.png" alt="v^{0}_1, v^{1}_1"> and <img class="math" src="http://scikit-learn.org/stable/_images/math/f864937fe75bc5ce50ba6e8fd303af07a7c7b080.png" alt="v^{0}_2, v^{1}_2"> respectively. For each support vector <img class="math" src="http://scikit-learn.org/stable/_images/math/22d275b512db1a089ef1416dfcddb889b16880f7.png" alt="v^{j}_i">, there are two dual coefficients. Let’s call the coefficient of support vector <img class="math" src="http://scikit-learn.org/stable/_images/math/22d275b512db1a089ef1416dfcddb889b16880f7.png" alt="v^{j}_i"> in the classifier between classes <img class="math" src="http://scikit-learn.org/stable/_images/math/df0deb143e5ac127f00bd248ee8001ecae572adc.png" alt="i"> and <img class="math" src="http://scikit-learn.org/stable/_images/math/0b7c1e16a3a8a849bb8ffdcdbf86f65fd1f30438.png" alt="k"> <img class="math" src="http://scikit-learn.org/stable/_images/math/da22b3bba4f7a4c4c646d9710aa7af4f022fec4c.png" alt="\alpha^{j}_{i,k}">. Then <code>dual_coef_</code> looks like this:</p> <table class="docutils">   <tr class="row-odd">
<td><img class="math" src="http://scikit-learn.org/stable/_images/math/dcdd95966e888a42ee3d0d23aae26754745a9ad4.png" alt="\alpha^{0}_{0,1}"></td> <td><img class="math" src="http://scikit-learn.org/stable/_images/math/17a546eece2a71021abea78ece3cfd35264c8c56.png" alt="\alpha^{0}_{0,2}"></td> <td rowspan="3">Coefficients for SVs of class 0</td> </tr> <tr class="row-even">
<td><img class="math" src="http://scikit-learn.org/stable/_images/math/975629da90654ceaaff541894ae1ea46d5044b25.png" alt="\alpha^{1}_{0,1}"></td> <td><img class="math" src="http://scikit-learn.org/stable/_images/math/b0b9dfa928a67ae8caf2b48ad0af117615ba8578.png" alt="\alpha^{1}_{0,2}"></td> </tr> <tr class="row-odd">
<td><img class="math" src="http://scikit-learn.org/stable/_images/math/bc0c9c85bd25621028132c9984c17d8894e81c5e.png" alt="\alpha^{2}_{0,1}"></td> <td><img class="math" src="http://scikit-learn.org/stable/_images/math/af6628140795a3b2e2cdc6459187b23f7db21766.png" alt="\alpha^{2}_{0,2}"></td> </tr> <tr class="row-even">
<td><img class="math" src="http://scikit-learn.org/stable/_images/math/9007a2b59d9d172abe856cf51266e4063d4e22f9.png" alt="\alpha^{0}_{1,0}"></td> <td><img class="math" src="http://scikit-learn.org/stable/_images/math/d76b0df07f7e6b44560ff2ee867c69be0b279d6e.png" alt="\alpha^{0}_{1,2}"></td> <td rowspan="2">Coefficients for SVs of class 1</td> </tr> <tr class="row-odd">
<td><img class="math" src="http://scikit-learn.org/stable/_images/math/f2bcccb6fc88b04000c14f30cb37f983a184565d.png" alt="\alpha^{1}_{1,0}"></td> <td><img class="math" src="http://scikit-learn.org/stable/_images/math/9b88bc2bf2d57760fc4c014e5fa52df561e3ecb8.png" alt="\alpha^{1}_{1,2}"></td> </tr> <tr class="row-even">
<td><img class="math" src="http://scikit-learn.org/stable/_images/math/1fcb858a59b0399c7d0630b9706095b69d7d4f60.png" alt="\alpha^{0}_{2,0}"></td> <td><img class="math" src="http://scikit-learn.org/stable/_images/math/882f6f3c0c7b918e4203d0964bae43319dc21f4a.png" alt="\alpha^{0}_{2,1}"></td> <td rowspan="2">Coefficients for SVs of class 2</td> </tr> <tr class="row-odd">
<td><img class="math" src="http://scikit-learn.org/stable/_images/math/f18ca1ee63ba080acc9bb5a990b547c13ffe32bc.png" alt="\alpha^{1}_{2,0}"></td> <td><img class="math" src="http://scikit-learn.org/stable/_images/math/ce88bc6d182f371512d365c516cad9081471f721.png" alt="\alpha^{1}_{2,1}"></td> </tr>  </table>   <h3 id="scores-probabilities">1.4.1.2. Scores and probabilities</h3> <p id="scores-and-probabilities">The <a class="reference internal" href="../generated/sklearn.svm.svc/#sklearn.svm.SVC" title="sklearn.svm.SVC"><code>SVC</code></a> method <code>decision_function</code> gives per-class scores for each sample (or a single score per sample in the binary case). When the constructor option <code>probability</code> is set to <code>True</code>, class membership probability estimates (from the methods <code>predict_proba</code> and <code>predict_log_proba</code>) are enabled. In the binary case, the probabilities are calibrated using Platt scaling: logistic regression on the SVM’s scores, fit by an additional cross-validation on the training data. In the multiclass case, this is extended as per Wu et al. (2004).</p> <p>Needless to say, the cross-validation involved in Platt scaling is an expensive operation for large datasets. In addition, the probability estimates may be inconsistent with the scores, in the sense that the “argmax” of the scores may not be the argmax of the probabilities. (E.g., in binary classification, a sample may be labeled by <code>predict</code> as belonging to a class that has probability &lt;½ according to <code>predict_proba</code>.) Platt’s method is also known to have theoretical issues. If confidence scores are required, but these do not have to be probabilities, then it is advisable to set <code>probability=False</code> and use <code>decision_function</code> instead of <code>predict_proba</code>.</p> <div class="topic"> <p class="topic-title first">References:</p> <ul class="simple"> <li>Wu, Lin and Weng, <a class="reference external" href="http://www.csie.ntu.edu.tw/~cjlin/papers/svmprob/svmprob.pdf" target="_blank">“Probability estimates for multi-class classification by pairwise coupling”</a>, JMLR 5:975-1005, 2004.</li> </ul> </div>   <h3 id="unbalanced-problems">1.4.1.3. Unbalanced problems</h3> <p>In problems where it is desired to give more importance to certain classes or certain individual samples keywords <code>class_weight</code> and <code>sample_weight</code> can be used.</p> <p><a class="reference internal" href="../generated/sklearn.svm.svc/#sklearn.svm.SVC" title="sklearn.svm.SVC"><code>SVC</code></a> (but not <a class="reference internal" href="../generated/sklearn.svm.nusvc/#sklearn.svm.NuSVC" title="sklearn.svm.NuSVC"><code>NuSVC</code></a>) implement a keyword <code>class_weight</code> in the <code>fit</code> method. It’s a dictionary of the form <code>{class_label : value}</code>, where value is a floating point number &gt; 0 that sets the parameter <code>C</code> of class <code>class_label</code> to <code>C * value</code>.</p> <div class="figure align-center"> <a class="reference external image-reference" href="../../auto_examples/svm/plot_separating_hyperplane_unbalanced/"><img alt="../_images/sphx_glr_plot_separating_hyperplane_unbalanced_0011.png" src="http://scikit-learn.org/stable/_images/sphx_glr_plot_separating_hyperplane_unbalanced_0011.png" style="width: 600.0px; height: 450.0px;"></a> </div> <p><a class="reference internal" href="../generated/sklearn.svm.svc/#sklearn.svm.SVC" title="sklearn.svm.SVC"><code>SVC</code></a>, <a class="reference internal" href="../generated/sklearn.svm.nusvc/#sklearn.svm.NuSVC" title="sklearn.svm.NuSVC"><code>NuSVC</code></a>, <a class="reference internal" href="../generated/sklearn.svm.svr/#sklearn.svm.SVR" title="sklearn.svm.SVR"><code>SVR</code></a>, <a class="reference internal" href="../generated/sklearn.svm.nusvr/#sklearn.svm.NuSVR" title="sklearn.svm.NuSVR"><code>NuSVR</code></a> and <a class="reference internal" href="../generated/sklearn.svm.oneclasssvm/#sklearn.svm.OneClassSVM" title="sklearn.svm.OneClassSVM"><code>OneClassSVM</code></a> implement also weights for individual samples in method <code>fit</code> through keyword <code>sample_weight</code>. Similar to <code>class_weight</code>, these set the parameter <code>C</code> for the i-th example to <code>C * sample_weight[i]</code>.</p> <div class="figure align-center"> <a class="reference external image-reference" href="../../auto_examples/svm/plot_weighted_samples/"><img alt="../_images/sphx_glr_plot_weighted_samples_0011.png" src="http://scikit-learn.org/stable/_images/sphx_glr_plot_weighted_samples_0011.png" style="width: 1050.0px; height: 450.0px;"></a> </div> <div class="topic"> <p class="topic-title first">Examples:</p> <ul class="simple"> <li>
<a class="reference internal" href="../../auto_examples/svm/plot_iris/#sphx-glr-auto-examples-svm-plot-iris-py"><span class="std std-ref">Plot different SVM classifiers in the iris dataset</span></a>,</li> <li>
<a class="reference internal" href="../../auto_examples/svm/plot_separating_hyperplane/#sphx-glr-auto-examples-svm-plot-separating-hyperplane-py"><span class="std std-ref">SVM: Maximum margin separating hyperplane</span></a>,</li> <li><a class="reference internal" href="../../auto_examples/svm/plot_separating_hyperplane_unbalanced/#sphx-glr-auto-examples-svm-plot-separating-hyperplane-unbalanced-py"><span class="std std-ref">SVM: Separating hyperplane for unbalanced classes</span></a></li> <li>
<a class="reference internal" href="../../auto_examples/svm/plot_svm_anova/#sphx-glr-auto-examples-svm-plot-svm-anova-py"><span class="std std-ref">SVM-Anova: SVM with univariate feature selection</span></a>,</li> <li><a class="reference internal" href="../../auto_examples/svm/plot_svm_nonlinear/#sphx-glr-auto-examples-svm-plot-svm-nonlinear-py"><span class="std std-ref">Non-linear SVM</span></a></li> <li>
<a class="reference internal" href="../../auto_examples/svm/plot_weighted_samples/#sphx-glr-auto-examples-svm-plot-weighted-samples-py"><span class="std std-ref">SVM: Weighted samples</span></a>,</li> </ul> </div>    <h2 id="svm-regression">1.4.2. Regression</h2> <p id="regression">The method of Support Vector Classification can be extended to solve regression problems. This method is called Support Vector Regression.</p> <p>The model produced by support vector classification (as described above) depends only on a subset of the training data, because the cost function for building the model does not care about training points that lie beyond the margin. Analogously, the model produced by Support Vector Regression depends only on a subset of the training data, because the cost function for building the model ignores any training data close to the model prediction.</p> <p>There are three different implementations of Support Vector Regression: <a class="reference internal" href="../generated/sklearn.svm.svr/#sklearn.svm.SVR" title="sklearn.svm.SVR"><code>SVR</code></a>, <a class="reference internal" href="../generated/sklearn.svm.nusvr/#sklearn.svm.NuSVR" title="sklearn.svm.NuSVR"><code>NuSVR</code></a> and <a class="reference internal" href="../generated/sklearn.svm.linearsvr/#sklearn.svm.LinearSVR" title="sklearn.svm.LinearSVR"><code>LinearSVR</code></a>. <a class="reference internal" href="../generated/sklearn.svm.linearsvr/#sklearn.svm.LinearSVR" title="sklearn.svm.LinearSVR"><code>LinearSVR</code></a> provides a faster implementation than <a class="reference internal" href="../generated/sklearn.svm.svr/#sklearn.svm.SVR" title="sklearn.svm.SVR"><code>SVR</code></a> but only considers linear kernels, while <a class="reference internal" href="../generated/sklearn.svm.nusvr/#sklearn.svm.NuSVR" title="sklearn.svm.NuSVR"><code>NuSVR</code></a> implements a slightly different formulation than <a class="reference internal" href="../generated/sklearn.svm.svr/#sklearn.svm.SVR" title="sklearn.svm.SVR"><code>SVR</code></a> and <a class="reference internal" href="../generated/sklearn.svm.linearsvr/#sklearn.svm.LinearSVR" title="sklearn.svm.LinearSVR"><code>LinearSVR</code></a>. See <a class="reference internal" href="#svm-implementation-details"><span class="std std-ref">Implementation details</span></a> for further details.</p> <p>As with classification classes, the fit method will take as argument vectors X, y, only that in this case y is expected to have floating point values instead of integer values:</p> <pre data-language="python">&gt;&gt;&gt; from sklearn import svm
&gt;&gt;&gt; X = [[0, 0], [2, 2]]
&gt;&gt;&gt; y = [0.5, 2.5]
&gt;&gt;&gt; clf = svm.SVR()
&gt;&gt;&gt; clf.fit(X, y) 
SVR(C=1.0, cache_size=200, coef0=0.0, degree=3, epsilon=0.1, gamma='auto',
    kernel='rbf', max_iter=-1, shrinking=True, tol=0.001, verbose=False)
&gt;&gt;&gt; clf.predict([[1, 1]])
array([ 1.5])
</pre> <div class="topic"> <p class="topic-title first">Examples:</p> <ul class="simple"> <li><a class="reference internal" href="../../auto_examples/svm/plot_svm_regression/#sphx-glr-auto-examples-svm-plot-svm-regression-py"><span class="std std-ref">Support Vector Regression (SVR) using linear and non-linear kernels</span></a></li> </ul> </div>   <h2 id="svm-outlier-detection">1.4.3. Density estimation, novelty detection</h2> <p id="density-estimation-novelty-detection">One-class SVM is used for novelty detection, that is, given a set of samples, it will detect the soft boundary of that set so as to classify new points as belonging to that set or not. The class that implements this is called <a class="reference internal" href="../generated/sklearn.svm.oneclasssvm/#sklearn.svm.OneClassSVM" title="sklearn.svm.OneClassSVM"><code>OneClassSVM</code></a>.</p> <p>In this case, as it is a type of unsupervised learning, the fit method will only take as input an array X, as there are no class labels.</p> <p>See, section <a class="reference internal" href="../outlier_detection/#outlier-detection"><span class="std std-ref">Novelty and Outlier Detection</span></a> for more details on this usage.</p> <div class="figure align-center"> <a class="reference external image-reference" href="../../auto_examples/svm/plot_oneclass/"><img alt="../_images/sphx_glr_plot_oneclass_0011.png" src="http://scikit-learn.org/stable/_images/sphx_glr_plot_oneclass_0011.png" style="width: 600.0px; height: 450.0px;"></a> </div> <div class="topic"> <p class="topic-title first">Examples:</p> <ul class="simple"> <li><a class="reference internal" href="../../auto_examples/svm/plot_oneclass/#sphx-glr-auto-examples-svm-plot-oneclass-py"><span class="std std-ref">One-class SVM with non-linear kernel (RBF)</span></a></li> <li><a class="reference internal" href="../../auto_examples/applications/plot_species_distribution_modeling/#sphx-glr-auto-examples-applications-plot-species-distribution-modeling-py"><span class="std std-ref">Species distribution modeling</span></a></li> </ul> </div>   <h2 id="complexity">1.4.4. Complexity</h2> <p>Support Vector Machines are powerful tools, but their compute and storage requirements increase rapidly with the number of training vectors. The core of an SVM is a quadratic programming problem (QP), separating support vectors from the rest of the training data. The QP solver used by this <a class="reference external" href="http://www.csie.ntu.edu.tw/~cjlin/libsvm/" target="_blank">libsvm</a>-based implementation scales between <img class="math" src="http://scikit-learn.org/stable/_images/math/bcfb17ffd145d51b0cad81ece1df4ef74c8bbd4d.png" alt="O(n_{features} \times n_{samples}^2)"> and <img class="math" src="http://scikit-learn.org/stable/_images/math/210f32e8b9eb59ec426407cdd4e7a10a37c814de.png" alt="O(n_{features} \times n_{samples}^3)"> depending on how efficiently the <a class="reference external" href="http://www.csie.ntu.edu.tw/~cjlin/libsvm/" target="_blank">libsvm</a> cache is used in practice (dataset dependent). If the data is very sparse <img class="math" src="http://scikit-learn.org/stable/_images/math/5c8e6f9c0b148b5cc3b06072b7daa0bb320ba0e6.png" alt="n_{features}"> should be replaced by the average number of non-zero features in a sample vector.</p> <p>Also note that for the linear case, the algorithm used in <a class="reference internal" href="../generated/sklearn.svm.linearsvc/#sklearn.svm.LinearSVC" title="sklearn.svm.LinearSVC"><code>LinearSVC</code></a> by the <a class="reference external" href="http://www.csie.ntu.edu.tw/~cjlin/liblinear/" target="_blank">liblinear</a> implementation is much more efficient than its <a class="reference external" href="http://www.csie.ntu.edu.tw/~cjlin/libsvm/" target="_blank">libsvm</a>-based <a class="reference internal" href="../generated/sklearn.svm.svc/#sklearn.svm.SVC" title="sklearn.svm.SVC"><code>SVC</code></a> counterpart and can scale almost linearly to millions of samples and/or features.</p>   <h2 id="tips-on-practical-use">1.4.5. Tips on Practical Use</h2>  <ul> <li>
<p class="first"><strong>Avoiding data copy</strong>: For <a class="reference internal" href="../generated/sklearn.svm.svc/#sklearn.svm.SVC" title="sklearn.svm.SVC"><code>SVC</code></a>, <a class="reference internal" href="../generated/sklearn.svm.svr/#sklearn.svm.SVR" title="sklearn.svm.SVR"><code>SVR</code></a>, <a class="reference internal" href="../generated/sklearn.svm.nusvc/#sklearn.svm.NuSVC" title="sklearn.svm.NuSVC"><code>NuSVC</code></a> and <a class="reference internal" href="../generated/sklearn.svm.nusvr/#sklearn.svm.NuSVR" title="sklearn.svm.NuSVR"><code>NuSVR</code></a>, if the data passed to certain methods is not C-ordered contiguous, and double precision, it will be copied before calling the underlying C implementation. You can check whether a given numpy array is C-contiguous by inspecting its <code>flags</code> attribute.</p> <p>For <a class="reference internal" href="../generated/sklearn.svm.linearsvc/#sklearn.svm.LinearSVC" title="sklearn.svm.LinearSVC"><code>LinearSVC</code></a> (and <a class="reference internal" href="../generated/sklearn.linear_model.logisticregression/#sklearn.linear_model.LogisticRegression" title="sklearn.linear_model.LogisticRegression"><code>LogisticRegression</code></a>) any input passed as a numpy array will be copied and converted to the liblinear internal sparse data representation (double precision floats and int32 indices of non-zero components). If you want to fit a large-scale linear classifier without copying a dense numpy C-contiguous double precision array as input we suggest to use the <a class="reference internal" href="../generated/sklearn.linear_model.sgdclassifier/#sklearn.linear_model.SGDClassifier" title="sklearn.linear_model.SGDClassifier"><code>SGDClassifier</code></a> class instead. The objective function can be configured to be almost the same as the <a class="reference internal" href="../generated/sklearn.svm.linearsvc/#sklearn.svm.LinearSVC" title="sklearn.svm.LinearSVC"><code>LinearSVC</code></a> model.</p> </li> <li>
<strong>Kernel cache size</strong>: For <a class="reference internal" href="../generated/sklearn.svm.svc/#sklearn.svm.SVC" title="sklearn.svm.SVC"><code>SVC</code></a>, <a class="reference internal" href="../generated/sklearn.svm.svr/#sklearn.svm.SVR" title="sklearn.svm.SVR"><code>SVR</code></a>, <code>nuSVC</code> and <a class="reference internal" href="../generated/sklearn.svm.nusvr/#sklearn.svm.NuSVR" title="sklearn.svm.NuSVR"><code>NuSVR</code></a>, the size of the kernel cache has a strong impact on run times for larger problems. If you have enough RAM available, it is recommended to set <code>cache_size</code> to a higher value than the default of 200(MB), such as 500(MB) or 1000(MB). </li> <li>
<strong>Setting C</strong>: <code>C</code> is <code>1</code> by default and it’s a reasonable default choice. If you have a lot of noisy observations you should decrease it. It corresponds to regularize more the estimation. </li> <li>Support Vector Machine algorithms are not scale invariant, so <strong>it is highly recommended to scale your data</strong>. For example, scale each attribute on the input vector X to [0,1] or [-1,+1], or standardize it to have mean 0 and variance 1. Note that the <em>same</em> scaling must be applied to the test vector to obtain meaningful results. See section <a class="reference internal" href="../preprocessing/#preprocessing"><span class="std std-ref">Preprocessing data</span></a> for more details on scaling and normalization. </li> <li>Parameter <code>nu</code> in <a class="reference internal" href="../generated/sklearn.svm.nusvc/#sklearn.svm.NuSVC" title="sklearn.svm.NuSVC"><code>NuSVC</code></a>/<a class="reference internal" href="../generated/sklearn.svm.oneclasssvm/#sklearn.svm.OneClassSVM" title="sklearn.svm.OneClassSVM"><code>OneClassSVM</code></a>/<a class="reference internal" href="../generated/sklearn.svm.nusvr/#sklearn.svm.NuSVR" title="sklearn.svm.NuSVR"><code>NuSVR</code></a> approximates the fraction of training errors and support vectors. </li> <li>In <a class="reference internal" href="../generated/sklearn.svm.svc/#sklearn.svm.SVC" title="sklearn.svm.SVC"><code>SVC</code></a>, if data for classification are unbalanced (e.g. many positive and few negative), set <code>class_weight='balanced'</code> and/or try different penalty parameters <code>C</code>. </li> <li>The underlying <a class="reference internal" href="../generated/sklearn.svm.linearsvc/#sklearn.svm.LinearSVC" title="sklearn.svm.LinearSVC"><code>LinearSVC</code></a> implementation uses a random number generator to select features when fitting the model. It is thus not uncommon, to have slightly different results for the same input data. If that happens, try with a smaller tol parameter. </li> <li>Using L1 penalization as provided by <code>LinearSVC(loss='l2', penalty='l1',
dual=False)</code> yields a sparse solution, i.e. only a subset of feature weights is different from zero and contribute to the decision function. Increasing <code>C</code> yields a more complex model (more feature are selected). The <code>C</code> value that yields a “null” model (all weights equal to zero) can be calculated using <a class="reference internal" href="../generated/sklearn.svm.l1_min_c/#sklearn.svm.l1_min_c" title="sklearn.svm.l1_min_c"><code>l1_min_c</code></a>. </li> </ul>    <h2 id="svm-kernels">1.4.6. Kernel functions</h2> <p id="kernel-functions">The <em>kernel function</em> can be any of the following:</p>  <ul class="simple"> <li>linear: <img class="math" src="http://scikit-learn.org/stable/_images/math/cc655b2d07d61893992ca7bfb9256b43314933bf.png" alt="\langle x, x'\rangle">.</li> <li>polynomial: <img class="math" src="http://scikit-learn.org/stable/_images/math/caed8545ad94ab355e204242314fb76bb96b2b09.png" alt="(\gamma \langle x, x'\rangle + r)^d">. <img class="math" src="http://scikit-learn.org/stable/_images/math/b9d10b54744d07746b97f53c55eb98046fd76c8c.png" alt="d"> is specified by keyword <code>degree</code>, <img class="math" src="http://scikit-learn.org/stable/_images/math/eaa6ad49a7f78fe5a13b486690163bf2dc7e3e60.png" alt="r"> by <code>coef0</code>.</li> <li>rbf: <img class="math" src="http://scikit-learn.org/stable/_images/math/6772baa7dcfcb7b1219ae13263bb240bae2539f7.png" alt="\exp(-\gamma |x-x'|^2)">. <img class="math" src="http://scikit-learn.org/stable/_images/math/3666981dc77862de77b6ecfcb64aad59b425cbaf.png" alt="\gamma"> is specified by keyword <code>gamma</code>, must be greater than 0.</li> <li>sigmoid (<img class="math" src="http://scikit-learn.org/stable/_images/math/e5dadad6828c157553e944e605a295afdcc600cf.png" alt="\tanh(\gamma \langle x,x'\rangle + r)">), where <img class="math" src="http://scikit-learn.org/stable/_images/math/eaa6ad49a7f78fe5a13b486690163bf2dc7e3e60.png" alt="r"> is specified by <code>coef0</code>.</li> </ul>  <p>Different kernels are specified by keyword kernel at initialization:</p> <pre data-language="python">&gt;&gt;&gt; linear_svc = svm.SVC(kernel='linear')
&gt;&gt;&gt; linear_svc.kernel
'linear'
&gt;&gt;&gt; rbf_svc = svm.SVC(kernel='rbf')
&gt;&gt;&gt; rbf_svc.kernel
'rbf'
</pre>  <h3 id="custom-kernels">1.4.6.1. Custom Kernels</h3> <p>You can define your own kernels by either giving the kernel as a python function or by precomputing the Gram matrix.</p> <p>Classifiers with custom kernels behave the same way as any other classifiers, except that:</p>  <ul class="simple"> <li>Field <code>support_vectors_</code> is now empty, only indices of support vectors are stored in <code>support_</code>
</li> <li>A reference (and not a copy) of the first argument in the <code>fit()</code> method is stored for future reference. If that array changes between the use of <code>fit()</code> and <code>predict()</code> you will have unexpected results.</li> </ul>   <h4 id="using-python-functions-as-kernels">1.4.6.1.1. Using Python functions as kernels</h4> <p>You can also use your own defined kernels by passing a function to the keyword <code>kernel</code> in the constructor.</p> <p>Your kernel must take as arguments two matrices of shape <code>(n_samples_1, n_features)</code>, <code>(n_samples_2, n_features)</code> and return a kernel matrix of shape <code>(n_samples_1, n_samples_2)</code>.</p> <p>The following code defines a linear kernel and creates a classifier instance that will use that kernel:</p> <pre data-language="python">&gt;&gt;&gt; import numpy as np
&gt;&gt;&gt; from sklearn import svm
&gt;&gt;&gt; def my_kernel(X, Y):
...     return np.dot(X, Y.T)
...
&gt;&gt;&gt; clf = svm.SVC(kernel=my_kernel)
</pre> <div class="topic"> <p class="topic-title first">Examples:</p> <ul class="simple"> <li>
<a class="reference internal" href="../../auto_examples/svm/plot_custom_kernel/#sphx-glr-auto-examples-svm-plot-custom-kernel-py"><span class="std std-ref">SVM with custom kernel</span></a>.</li> </ul> </div>   <h4 id="using-the-gram-matrix">1.4.6.1.2. Using the Gram matrix</h4> <p>Set <code>kernel='precomputed'</code> and pass the Gram matrix instead of X in the fit method. At the moment, the kernel values between <em>all</em> training vectors and the test vectors must be provided.</p> <pre data-language="python">&gt;&gt;&gt; import numpy as np
&gt;&gt;&gt; from sklearn import svm
&gt;&gt;&gt; X = np.array([[0, 0], [1, 1]])
&gt;&gt;&gt; y = [0, 1]
&gt;&gt;&gt; clf = svm.SVC(kernel='precomputed')
&gt;&gt;&gt; # linear kernel computation
&gt;&gt;&gt; gram = np.dot(X, X.T)
&gt;&gt;&gt; clf.fit(gram, y) 
SVC(C=1.0, cache_size=200, class_weight=None, coef0=0.0,
    decision_function_shape=None, degree=3, gamma='auto',
    kernel='precomputed', max_iter=-1, probability=False,
    random_state=None, shrinking=True, tol=0.001, verbose=False)
&gt;&gt;&gt; # predict on training examples
&gt;&gt;&gt; clf.predict(gram)
array([0, 1])
</pre>   <h4 id="parameters-of-the-rbf-kernel">1.4.6.1.3. Parameters of the RBF Kernel</h4> <p>When training an SVM with the <em>Radial Basis Function</em> (RBF) kernel, two parameters must be considered: <code>C</code> and <code>gamma</code>. The parameter <code>C</code>, common to all SVM kernels, trades off misclassification of training examples against simplicity of the decision surface. A low <code>C</code> makes the decision surface smooth, while a high <code>C</code> aims at classifying all training examples correctly. <code>gamma</code> defines how much influence a single training example has. The larger <code>gamma</code> is, the closer other examples must be to be affected.</p> <p>Proper choice of <code>C</code> and <code>gamma</code> is critical to the SVM’s performance. One is advised to use <a class="reference internal" href="../generated/sklearn.model_selection.gridsearchcv/#sklearn.model_selection.GridSearchCV" title="sklearn.model_selection.GridSearchCV"><code>sklearn.model_selection.GridSearchCV</code></a> with <code>C</code> and <code>gamma</code> spaced exponentially far apart to choose good values.</p> <div class="topic"> <p class="topic-title first">Examples:</p> <ul class="simple"> <li><a class="reference internal" href="../../auto_examples/svm/plot_rbf_parameters/#sphx-glr-auto-examples-svm-plot-rbf-parameters-py"><span class="std std-ref">RBF SVM parameters</span></a></li> </ul> </div>     <h2 id="svm-mathematical-formulation">1.4.7. Mathematical formulation</h2> <p id="mathematical-formulation">A support vector machine constructs a hyper-plane or set of hyper-planes in a high or infinite dimensional space, which can be used for classification, regression or other tasks. Intuitively, a good separation is achieved by the hyper-plane that has the largest distance to the nearest training data points of any class (so-called functional margin), since in general the larger the margin the lower the generalization error of the classifier.</p> <div class="figure align-center"> <a class="reference internal image-reference" href="http://scikit-learn.org/stable/_images/sphx_glr_plot_separating_hyperplane_0011.png" target="_blank"><img alt="../_images/sphx_glr_plot_separating_hyperplane_0011.png" src="http://scikit-learn.org/stable/_images/sphx_glr_plot_separating_hyperplane_0011.png" style="width: 600.0px; height: 450.0px;"></a> </div>  <h3 id="svc">1.4.7.1. SVC</h3> <p>Given training vectors <img class="math" src="http://scikit-learn.org/stable/_images/math/3c2810ae28117c8ad2d9464adc7f57ad2143887c.png" alt="x_i \in \mathbb{R}^p">, i=1,..., n, in two classes, and a vector <img class="math" src="http://scikit-learn.org/stable/_images/math/ede528003a9c8d8f47c5e4c3c8ed4dc0056b8c36.png" alt="y \in \{1, -1\}^n">, SVC solves the following primal problem:</p> <div class="math"> <p><img src="http://scikit-learn.org/stable/_images/math/afe25ea32dba823e13d2ae45b439d4529cd15364.png" alt="\min_ {w, b, \zeta} \frac{1}{2} w^T w + C \sum_{i=1}^{n} \zeta_i



\textrm {subject to } &amp; y_i (w^T \phi (x_i) + b) \geq 1 - \zeta_i,\\
&amp; \zeta_i \geq 0, i=1, ..., n"></p> </div>
<p>Its dual is</p> <div class="math"> <p><img src="http://scikit-learn.org/stable/_images/math/ca662d71b1a44a2cdf255fbe69c8a72803eded1c.png" alt="\min_{\alpha} \frac{1}{2} \alpha^T Q \alpha - e^T \alpha


\textrm {subject to } &amp; y^T \alpha = 0\\
&amp; 0 \leq \alpha_i \leq C, i=1, ..., n"></p> </div>
<p>where <img class="math" src="http://scikit-learn.org/stable/_images/math/78a06cf7a34f39fde71fbba0d5539baae7c72d4e.png" alt="e"> is the vector of all ones, <img class="math" src="http://scikit-learn.org/stable/_images/math/f89a97f16b0b67c63a526450f81b354169897caf.png" alt="C &gt; 0"> is the upper bound, <img class="math" src="http://scikit-learn.org/stable/_images/math/331157c6afbd113256867fd408d80277d1a24756.png" alt="Q"> is an <img class="math" src="http://scikit-learn.org/stable/_images/math/e11f2701c4a39c7fe543a6c4150b421d50f1c159.png" alt="n"> by <img class="math" src="http://scikit-learn.org/stable/_images/math/e11f2701c4a39c7fe543a6c4150b421d50f1c159.png" alt="n"> positive semidefinite matrix, <img class="math" src="http://scikit-learn.org/stable/_images/math/02d6bcb474ff4e171fdd4de3e6d3e3b772b41c8c.png" alt="Q_{ij} \equiv y_i y_j K(x_i, x_j)">, where <img class="math" src="http://scikit-learn.org/stable/_images/math/4488f5555693ea818a6bb1cb471fa11fdd11b39f.png" alt="K(x_i, x_j) = \phi (x_i)^T \phi (x_j)"> is the kernel. Here training vectors are implicitly mapped into a higher (maybe infinite) dimensional space by the function <img class="math" src="http://scikit-learn.org/stable/_images/math/c2f31c22645274c375eff7920cfdfdc18d60341f.png" alt="\phi">.</p> <p>The decision function is:</p> <div class="math"> <p><img src="http://scikit-learn.org/stable/_images/math/c4b8feb333aa69aaa37401ee4db26ae4afdbeb63.png" alt="\operatorname{sgn}(\sum_{i=1}^n y_i \alpha_i K(x_i, x) + \rho)"></p> </div>
<div class="admonition note"> <p class="first admonition-title">Note</p> <p class="last">While SVM models derived from <a class="reference external" href="http://www.csie.ntu.edu.tw/~cjlin/libsvm/" target="_blank">libsvm</a> and <a class="reference external" href="http://www.csie.ntu.edu.tw/~cjlin/liblinear/" target="_blank">liblinear</a> use <code>C</code> as regularization parameter, most other estimators use <code>alpha</code>. The relation between both is <img class="math" src="http://scikit-learn.org/stable/_images/math/4a278c3048ebb8a437fd8610921346954fd97cf1.png" alt="C = \frac{n\_samples}{alpha}">.</p> </div> <p>This parameters can be accessed through the members <code>dual_coef_</code> which holds the product <img class="math" src="http://scikit-learn.org/stable/_images/math/7d906e5b0e5d3343fc63c9eb1fc2ce43a75b22dd.png" alt="y_i \alpha_i">, <code>support_vectors_</code> which holds the support vectors, and <code>intercept_</code> which holds the independent term <img class="math" src="http://scikit-learn.org/stable/_images/math/9a51ab9a0b521705e1e8762fac6bdd6f11771758.png" alt="\rho"> :</p> <div class="topic"> <p class="topic-title first">References:</p> <ul class="simple"> <li>
<a class="reference external" href="http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.17.7215" target="_blank">“Automatic Capacity Tuning of Very Large VC-dimension Classifiers”</a>, I. Guyon, B. Boser, V. Vapnik - Advances in neural information processing 1993.</li> <li>
<a class="reference external" href="http://link.springer.com/article/10.1007%2FBF00994018" target="_blank">“Support-vector networks”</a>, C. Cortes, V. Vapnik - Machine Learning, 20, 273-297 (1995).</li> </ul> </div>   <h3 id="nusvc">1.4.7.2. NuSVC</h3> <p>We introduce a new parameter <img class="math" src="http://scikit-learn.org/stable/_images/math/ca3b8fa4180eee2dfc3af9d13fae1da451cd2c31.png" alt="\nu"> which controls the number of support vectors and training errors. The parameter <img class="math" src="http://scikit-learn.org/stable/_images/math/cb88554a78c6610201fd61574c2591aa23da35ac.png" alt="\nu \in (0,
1]"> is an upper bound on the fraction of training errors and a lower bound of the fraction of support vectors.</p> <p>It can be shown that the <img class="math" src="http://scikit-learn.org/stable/_images/math/ca3b8fa4180eee2dfc3af9d13fae1da451cd2c31.png" alt="\nu">-SVC formulation is a reparametrization of the <img class="math" src="http://scikit-learn.org/stable/_images/math/afce44aa7c55836ca9345404c22fc7b599d2ed84.png" alt="C">-SVC and therefore mathematically equivalent.</p>   <h3 id="svr">1.4.7.3. SVR</h3> <p>Given training vectors <img class="math" src="http://scikit-learn.org/stable/_images/math/3c2810ae28117c8ad2d9464adc7f57ad2143887c.png" alt="x_i \in \mathbb{R}^p">, i=1,..., n, and a vector <img class="math" src="http://scikit-learn.org/stable/_images/math/1269782190e528401491505bf582106d5990f870.png" alt="y \in \mathbb{R}^n"> <img class="math" src="http://scikit-learn.org/stable/_images/math/3cb373a8030ad846aed7b1ee45bab27b13775928.png" alt="\varepsilon">-SVR solves the following primal problem:</p> <div class="math"> <p><img src="http://scikit-learn.org/stable/_images/math/84dfa253bd3c36093102158fbe951a73819f96df.png" alt="\min_ {w, b, \zeta, \zeta^*} \frac{1}{2} w^T w + C \sum_{i=1}^{n} (\zeta_i + \zeta_i^*)



\textrm {subject to } &amp; y_i - w^T \phi (x_i) - b \leq \varepsilon + \zeta_i,\\
                      &amp; w^T \phi (x_i) + b - y_i \leq \varepsilon + \zeta_i^*,\\
                      &amp; \zeta_i, \zeta_i^* \geq 0, i=1, ..., n"></p> </div>
<p>Its dual is</p> <div class="math"> <p><img src="http://scikit-learn.org/stable/_images/math/adfba00b3343f39be094f322b9349d472f29fd63.png" alt="\min_{\alpha, \alpha^*} \frac{1}{2} (\alpha - \alpha^*)^T Q (\alpha - \alpha^*) + \varepsilon e^T (\alpha + \alpha^*) - y^T (\alpha - \alpha^*)


\textrm {subject to } &amp; e^T (\alpha - \alpha^*) = 0\\
&amp; 0 \leq \alpha_i, \alpha_i^* \leq C, i=1, ..., n"></p> </div>
<p>where <img class="math" src="http://scikit-learn.org/stable/_images/math/78a06cf7a34f39fde71fbba0d5539baae7c72d4e.png" alt="e"> is the vector of all ones, <img class="math" src="http://scikit-learn.org/stable/_images/math/f89a97f16b0b67c63a526450f81b354169897caf.png" alt="C &gt; 0"> is the upper bound, <img class="math" src="http://scikit-learn.org/stable/_images/math/331157c6afbd113256867fd408d80277d1a24756.png" alt="Q"> is an <img class="math" src="http://scikit-learn.org/stable/_images/math/e11f2701c4a39c7fe543a6c4150b421d50f1c159.png" alt="n"> by <img class="math" src="http://scikit-learn.org/stable/_images/math/e11f2701c4a39c7fe543a6c4150b421d50f1c159.png" alt="n"> positive semidefinite matrix, <img class="math" src="http://scikit-learn.org/stable/_images/math/a3e3a226d8b165a8871e4aa2b981e440ca1ccc1d.png" alt="Q_{ij} \equiv K(x_i, x_j) = \phi (x_i)^T \phi (x_j)"> is the kernel. Here training vectors are implicitly mapped into a higher (maybe infinite) dimensional space by the function <img class="math" src="http://scikit-learn.org/stable/_images/math/c2f31c22645274c375eff7920cfdfdc18d60341f.png" alt="\phi">.</p> <p>The decision function is:</p> <div class="math"> <p><img src="http://scikit-learn.org/stable/_images/math/7b2ae68afb44fc8ac21ce0e4c5028ec7497cb5cc.png" alt="\sum_{i=1}^n (\alpha_i - \alpha_i^*) K(x_i, x) + \rho"></p> </div>
<p>These parameters can be accessed through the members <code>dual_coef_</code> which holds the difference <img class="math" src="http://scikit-learn.org/stable/_images/math/c7e6ffac97e60b9e6f0c0e0e6efe7425064c0013.png" alt="\alpha_i - \alpha_i^*">, <code>support_vectors_</code> which holds the support vectors, and <code>intercept_</code> which holds the independent term <img class="math" src="http://scikit-learn.org/stable/_images/math/9a51ab9a0b521705e1e8762fac6bdd6f11771758.png" alt="\rho"></p> <div class="topic"> <p class="topic-title first">References:</p> <ul class="simple"> <li>
<a class="reference external" href="http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.114.4288" target="_blank">“A Tutorial on Support Vector Regression”</a>, Alex J. Smola, Bernhard Schölkopf - Statistics and Computing archive Volume 14 Issue 3, August 2004, p. 199-222.</li> </ul> </div>    <h2 id="svm-implementation-details">1.4.8. Implementation details</h2> <p id="implementation-details">Internally, we use <a class="reference external" href="http://www.csie.ntu.edu.tw/~cjlin/libsvm/" target="_blank">libsvm</a> and <a class="reference external" href="http://www.csie.ntu.edu.tw/~cjlin/liblinear/" target="_blank">liblinear</a> to handle all computations. These libraries are wrapped using C and Cython.</p> <div class="topic"> <p class="topic-title first">References:</p> <p>For a description of the implementation and details of the algorithms used, please refer to</p>  <ul class="simple"> <li>
<a class="reference external" href="http://www.csie.ntu.edu.tw/~cjlin/papers/libsvm.pdf" target="_blank">LIBSVM: A Library for Support Vector Machines</a>.</li> <li>
<a class="reference external" href="http://www.csie.ntu.edu.tw/~cjlin/liblinear/" target="_blank">LIBLINEAR – A Library for Large Linear Classification</a>.</li> </ul>  </div>
<div class="_attribution">
  <p class="_attribution-p">
    © 2007–2016 The scikit-learn developers<br>Licensed under the 3-clause BSD License.<br>
    <a href="http://scikit-learn.org/stable/modules/svm.html" class="_attribution-link" target="_blank">http://scikit-learn.org/stable/modules/svm.html</a>
  </p>
</div>

			</div>
		</div>
	</section>

	</div>
</body>
</html>
