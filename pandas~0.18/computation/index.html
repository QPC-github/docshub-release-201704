
<!DOCTYPE HTML>

<html lang="en">

<head>
  <meta charset="utf-8">
  <title>13. Computational Tools - Pandas 0.18 - W3cubDocs</title>
  
  <meta name="description" content="Series, DataFrame, and Panel all have a method pct_change to compute the percent change over a given number of periods (using fill_method to fill NA &hellip;">
  <meta name="keywords" content="computational, tools, -, pandas, pandas~0.18">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="http://docs.w3cub.com/pandas~0.18/computation/">
  <link href="/favicon.png" rel="icon">
  <link type="text/css" rel="stylesheet" href="/assets/application-50364fff564ce3b6327021805f3f00e2957b441cf27f576a7dd4ff63bbc47047.css">
  <script type="text/javascript" src="/assets/application-db64bfd54ceb42be11af7995804cf4902548419ceb79d509b0b7d62c22d98e6f.js"></script>
  <script src="/json/pandas~0.18.js"></script>
  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-71174418-1']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>


</head>

<body>
	<div class="_app">
	<header class="_header">
  
  <form class="_search">
    <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
    <a class="_search-clear"></a>
    <div class="_search-tag"></div>
  </form>
  
  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/pandas~0.18/" class="_nav-link" title="" style="margin-left:0;">pandas 0.18</a></span>
  
  <nav class="_nav">
    <a href="/app/" class="_nav-link ">App</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		<div class="_list">
			
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<div class="_page _sphinx">
				
<h1 id="computation">Computational tools</h1>  <h2 id="computational-tools">Statistical Functions</h2>  <h3 id="computation-pct-change">Percent Change</h3> <p id="percent-change"><code>Series</code>, <code>DataFrame</code>, and <code>Panel</code> all have a method <code>pct_change</code> to compute the percent change over a given number of periods (using <code>fill_method</code> to fill NA/null values <em>before</em> computing the percent change).</p> <pre data-language="python">In [1]: ser = pd.Series(np.random.randn(8))

In [2]: ser.pct_change()
Out[2]: 
0         NaN
1   -1.602976
2    4.334938
3   -0.247456
4   -2.067345
5   -1.142903
6   -1.688214
7   -9.759729
dtype: float64
</pre> <pre data-language="python">In [3]: df = pd.DataFrame(np.random.randn(10, 4))

In [4]: df.pct_change(periods=3)
Out[4]: 
          0         1         2         3
0       NaN       NaN       NaN       NaN
1       NaN       NaN       NaN       NaN
2       NaN       NaN       NaN       NaN
3 -0.218320 -1.054001  1.987147 -0.510183
4 -0.439121 -1.816454  0.649715 -4.822809
5 -0.127833 -3.042065 -5.866604 -1.776977
6 -2.596833 -1.959538 -2.111697 -3.798900
7 -0.117826 -2.169058  0.036094 -0.067696
8  2.492606 -1.357320 -1.205802 -1.558697
9 -1.012977  2.324558 -1.003744 -0.371806
</pre>   <h3 id="computation-covariance">Covariance</h3> <p id="covariance">The <code>Series</code> object has a method <code>cov</code> to compute covariance between series (excluding NA/null values).</p> <pre data-language="python">In [5]: s1 = pd.Series(np.random.randn(1000))

In [6]: s2 = pd.Series(np.random.randn(1000))

In [7]: s1.cov(s2)
Out[7]: 0.00068010881743110698
</pre> <p>Analogously, <code>DataFrame</code> has a method <code>cov</code> to compute pairwise covariances among the series in the DataFrame, also excluding NA/null values.</p> <div class="admonition note" id="computation-covariance-caveats"> <p class="first admonition-title">Note</p> <p class="last">Assuming the missing data are missing at random this results in an estimate for the covariance matrix which is unbiased. However, for many applications this estimate may not be acceptable because the estimated covariance matrix is not guaranteed to be positive semi-definite. This could lead to estimated correlations having absolute values which are greater than one, and/or a non-invertible covariance matrix. See <a class="reference external" href="http://en.wikipedia.org/w/index.php?title=Estimation_of_covariance_matrices" target="_blank">Estimation of covariance matrices</a> for more details.</p> </div> <pre data-language="python">In [8]: frame = pd.DataFrame(np.random.randn(1000, 5), columns=['a', 'b', 'c', 'd', 'e'])

In [9]: frame.cov()
Out[9]: 
          a         b         c         d         e
a  1.000882 -0.003177 -0.002698 -0.006889  0.031912
b -0.003177  1.024721  0.000191  0.009212  0.000857
c -0.002698  0.000191  0.950735 -0.031743 -0.005087
d -0.006889  0.009212 -0.031743  1.002983 -0.047952
e  0.031912  0.000857 -0.005087 -0.047952  1.042487
</pre> <p><code>DataFrame.cov</code> also supports an optional <code>min_periods</code> keyword that specifies the required minimum number of observations for each column pair in order to have a valid result.</p> <pre data-language="python">In [10]: frame = pd.DataFrame(np.random.randn(20, 3), columns=['a', 'b', 'c'])

In [11]: frame.ix[:5, 'a'] = np.nan

In [12]: frame.ix[5:10, 'b'] = np.nan

In [13]: frame.cov()
Out[13]: 
          a         b         c
a  1.210090 -0.430629  0.018002
b -0.430629  1.240960  0.347188
c  0.018002  0.347188  1.301149

In [14]: frame.cov(min_periods=12)
Out[14]: 
          a         b         c
a  1.210090       NaN  0.018002
b       NaN  1.240960  0.347188
c  0.018002  0.347188  1.301149
</pre>   <h3 id="computation-correlation">Correlation</h3> <p id="correlation">Several methods for computing correlations are provided:</p> <table class="docutils">  <thead valign="bottom"> <tr class="row-odd">
<th class="head">Method name</th> <th class="head">Description</th> </tr> </thead>  <tr class="row-even">
<td><code>pearson (default)</code></td> <td>Standard correlation coefficient</td> </tr> <tr class="row-odd">
<td><code>kendall</code></td> <td>Kendall Tau correlation coefficient</td> </tr> <tr class="row-even">
<td><code>spearman</code></td> <td>Spearman rank correlation coefficient</td> </tr>  </table> <p>All of these are currently computed using pairwise complete observations.</p> <div class="admonition note"> <p class="first admonition-title">Note</p> <p class="last">Please see the <a class="reference internal" href="#computation-covariance-caveats">caveats</a> associated with this method of calculating correlation matrices in the <a class="reference internal" href="#computation-covariance">covariance section</a>.</p> </div> <pre data-language="python">In [15]: frame = pd.DataFrame(np.random.randn(1000, 5), columns=['a', 'b', 'c', 'd', 'e'])

In [16]: frame.ix[::2] = np.nan

# Series with Series
In [17]: frame['a'].corr(frame['b'])
Out[17]: 0.013479040400098789

In [18]: frame['a'].corr(frame['b'], method='spearman')
Out[18]: -0.0072898851595406388

# Pairwise correlation of DataFrame columns
In [19]: frame.corr()
Out[19]: 
          a         b         c         d         e
a  1.000000  0.013479 -0.049269 -0.042239 -0.028525
b  0.013479  1.000000 -0.020433 -0.011139  0.005654
c -0.049269 -0.020433  1.000000  0.018587 -0.054269
d -0.042239 -0.011139  0.018587  1.000000 -0.017060
e -0.028525  0.005654 -0.054269 -0.017060  1.000000
</pre> <p>Note that non-numeric columns will be automatically excluded from the correlation calculation.</p> <p>Like <code>cov</code>, <code>corr</code> also supports the optional <code>min_periods</code> keyword:</p> <pre data-language="python">In [20]: frame = pd.DataFrame(np.random.randn(20, 3), columns=['a', 'b', 'c'])

In [21]: frame.ix[:5, 'a'] = np.nan

In [22]: frame.ix[5:10, 'b'] = np.nan

In [23]: frame.corr()
Out[23]: 
          a         b         c
a  1.000000 -0.076520  0.160092
b -0.076520  1.000000  0.135967
c  0.160092  0.135967  1.000000

In [24]: frame.corr(min_periods=12)
Out[24]: 
          a         b         c
a  1.000000       NaN  0.160092
b       NaN  1.000000  0.135967
c  0.160092  0.135967  1.000000
</pre> <p>A related method <code>corrwith</code> is implemented on DataFrame to compute the correlation between like-labeled Series contained in different DataFrame objects.</p> <pre data-language="python">In [25]: index = ['a', 'b', 'c', 'd', 'e']

In [26]: columns = ['one', 'two', 'three', 'four']

In [27]: df1 = pd.DataFrame(np.random.randn(5, 4), index=index, columns=columns)

In [28]: df2 = pd.DataFrame(np.random.randn(4, 4), index=index[:4], columns=columns)

In [29]: df1.corrwith(df2)
Out[29]: 
one     -0.125501
two     -0.493244
three    0.344056
four     0.004183
dtype: float64

In [30]: df2.corrwith(df1, axis=1)
Out[30]: 
a   -0.675817
b    0.458296
c    0.190809
d   -0.186275
e         NaN
dtype: float64
</pre>   <h3 id="computation-ranking">Data ranking</h3> <p id="data-ranking">The <code>rank</code> method produces a data ranking with ties being assigned the mean of the ranks (by default) for the group:</p> <pre data-language="python">In [31]: s = pd.Series(np.random.np.random.randn(5), index=list('abcde'))

In [32]: s['d'] = s['b'] # so there's a tie

In [33]: s.rank()
Out[33]: 
a    5.0
b    2.5
c    1.0
d    2.5
e    4.0
dtype: float64
</pre> <p><code>rank</code> is also a DataFrame method and can rank either the rows (<code>axis=0</code>) or the columns (<code>axis=1</code>). <code>NaN</code> values are excluded from the ranking.</p> <pre data-language="python">In [34]: df = pd.DataFrame(np.random.np.random.randn(10, 6))

In [35]: df[4] = df[2][:5] # some ties

In [36]: df
Out[36]: 
          0         1         2         3         4         5
0 -0.904948 -1.163537 -1.457187  0.135463 -1.457187  0.294650
1 -0.976288 -0.244652 -0.748406 -0.999601 -0.748406 -0.800809
2  0.401965  1.460840  1.256057  1.308127  1.256057  0.876004
3  0.205954  0.369552 -0.669304  0.038378 -0.669304  1.140296
4 -0.477586 -0.730705 -1.129149 -0.601463 -1.129149 -0.211196
5 -1.092970 -0.689246  0.908114  0.204848       NaN  0.463347
6  0.376892  0.959292  0.095572 -0.593740       NaN -0.069180
7 -1.002601  1.957794 -0.120708  0.094214       NaN -1.467422
8 -0.547231  0.664402 -0.519424 -0.073254       NaN -1.263544
9 -0.250277 -0.237428 -1.056443  0.419477       NaN  1.375064

In [37]: df.rank(1)
Out[37]: 
     0    1    2    3    4    5
0  4.0  3.0  1.5  5.0  1.5  6.0
1  2.0  6.0  4.5  1.0  4.5  3.0
2  1.0  6.0  3.5  5.0  3.5  2.0
3  4.0  5.0  1.5  3.0  1.5  6.0
4  5.0  3.0  1.5  4.0  1.5  6.0
5  1.0  2.0  5.0  3.0  NaN  4.0
6  4.0  5.0  3.0  1.0  NaN  2.0
7  2.0  5.0  3.0  4.0  NaN  1.0
8  2.0  5.0  3.0  4.0  NaN  1.0
9  2.0  3.0  1.0  4.0  NaN  5.0
</pre> <p><code>rank</code> optionally takes a parameter <code>ascending</code> which by default is true; when false, data is reverse-ranked, with larger values assigned a smaller rank.</p> <p><code>rank</code> supports different tie-breaking methods, specified with the <code>method</code> parameter:</p>  <ul class="simple"> <li>
<code>average</code> : average rank of tied group</li> <li>
<code>min</code> : lowest rank in the group</li> <li>
<code>max</code> : highest rank in the group</li> <li>
<code>first</code> : ranks assigned in the order they appear in the array</li> </ul>     <h2 id="stats-moments">Window Functions</h2> <div class="admonition warning" id="window-functions"> <p class="first admonition-title">Warning</p> <p>Prior to version 0.18.0, <code>pd.rolling_*</code>, <code>pd.expanding_*</code>, and <code>pd.ewm*</code> were module level functions and are now deprecated. These are replaced by using the <code>Rolling</code>, <code>Expanding</code> and <code>EWM</code>. objects and a corresponding method call.</p> <p class="last">The deprecation warning will show the new syntax, see an example <a class="reference internal" href="http://pandas.pydata.org/pandas-docs/version/0.18.1/whatsnew.html#whatsnew-0180-window-deprecations" target="_blank">here</a> You can view the previous documentation <a class="reference external" href="http://pandas.pydata.org/pandas-docs/version/0.17.1/computation.html#moving-rolling-statistics-moments" target="_blank">here</a></p> </div> <p>For working with data, a number of windows functions are provided for computing common <em>window</em> or <em>rolling</em> statistics. Among these are count, sum, mean, median, correlation, variance, covariance, standard deviation, skewness, and kurtosis.</p> <div class="admonition note"> <p class="first admonition-title">Note</p> <p class="last">The API for window statistics is quite similar to the way one works with <code>GroupBy</code> objects, see the documentation <a class="reference internal" href="../groupby/#groupby">here</a></p> </div> <p>We work with <code>rolling</code>, <code>expanding</code> and <code>exponentially weighted</code> data through the corresponding objects, <code>Rolling</code>, <code>Expanding</code> and <code>EWM</code>.</p> <pre data-language="python">In [38]: s = pd.Series(np.random.randn(1000), index=pd.date_range('1/1/2000', periods=1000))

In [39]: s = s.cumsum()

In [40]: s
Out[40]: 
2000-01-01    -0.268824
2000-01-02    -1.771855
2000-01-03    -0.818003
2000-01-04    -0.659244
2000-01-05    -1.942133
2000-01-06    -1.869391
2000-01-07     0.563674
                ...    
2002-09-20   -68.233054
2002-09-21   -66.765687
2002-09-22   -67.457323
2002-09-23   -69.253182
2002-09-24   -70.296818
2002-09-25   -70.844674
2002-09-26   -72.475016
Freq: D, dtype: float64
</pre> <p>These are created from methods on <code>Series</code> and <code>DataFrame</code>.</p> <pre data-language="python">In [41]: r = s.rolling(window=60)

In [42]: r
Out[42]: Rolling [window=60,center=False,axis=0]
</pre> <p>These object provide tab-completion of the avaible methods and properties.</p> <pre data-language="python">In [14]: r.
r.agg         r.apply       r.count       r.exclusions  r.max         r.median      r.name        r.skew        r.sum
r.aggregate   r.corr        r.cov         r.kurt        r.mean        r.min         r.quantile    r.std         r.var
</pre> <p>Generally these methods all have the same interface. They all accept the following arguments:</p> <ul class="simple"> <li>
<code>window</code>: size of moving window</li> <li>
<code>min_periods</code>: threshold of non-null data points to require (otherwise result is NA)</li> <li>
<code>center</code>: boolean, whether to set the labels at the center (default is False)</li> </ul> <div class="admonition warning"> <p class="first admonition-title">Warning</p> <p>The <code>freq</code> and <code>how</code> arguments were in the API prior to 0.18.0 changes. These are deprecated in the new API. You can simply resample the input prior to creating a window function.</p> <p class="last">For example, instead of <code>s.rolling(window=5,freq='D').max()</code> to get the max value on a rolling 5 Day window, one could use <code>s.resample('D').max().rolling(window=5).max()</code>, which first resamples the data to daily data, then provides a rolling 5 day window.</p> </div> <p>We can then call methods on these <code>rolling</code> objects. These return like-indexed objects:</p> <pre data-language="python">In [43]: r.mean()
Out[43]: 
2000-01-01          NaN
2000-01-02          NaN
2000-01-03          NaN
2000-01-04          NaN
2000-01-05          NaN
2000-01-06          NaN
2000-01-07          NaN
                ...    
2002-09-20   -62.694135
2002-09-21   -62.812190
2002-09-22   -62.914971
2002-09-23   -63.061867
2002-09-24   -63.213876
2002-09-25   -63.375074
2002-09-26   -63.539734
Freq: D, dtype: float64
</pre> <pre data-language="python">In [44]: s.plot(style='k--')
Out[44]: &lt;matplotlib.axes._subplots.AxesSubplot at 0x11ce37110&gt;

In [45]: r.mean().plot(style='k')
Out[45]: &lt;matplotlib.axes._subplots.AxesSubplot at 0x11ce37110&gt;
</pre> <img alt="_images/rolling_mean_ex.png" src="http://pandas.pydata.org/pandas-docs/version/0.18.1/_images/rolling_mean_ex.png"> <p>They can also be applied to DataFrame objects. This is really just syntactic sugar for applying the moving window operator to all of the DataFrame’s columns:</p> <pre data-language="python">In [46]: df = pd.DataFrame(np.random.randn(1000, 4),
   ....:                   index=pd.date_range('1/1/2000', periods=1000),
   ....:                   columns=['A', 'B', 'C', 'D'])
   ....: 

In [47]: df = df.cumsum()

In [48]: df.rolling(window=60).sum().plot(subplots=True)
Out[48]: 
array([&lt;matplotlib.axes._subplots.AxesSubplot object at 0x11cdc2890&gt;,
       &lt;matplotlib.axes._subplots.AxesSubplot object at 0x120dfef50&gt;,
       &lt;matplotlib.axes._subplots.AxesSubplot object at 0x120cd4110&gt;,
       &lt;matplotlib.axes._subplots.AxesSubplot object at 0x1127f6e90&gt;], dtype=object)
</pre> <img alt="_images/rolling_mean_frame.png" src="http://pandas.pydata.org/pandas-docs/version/0.18.1/_images/rolling_mean_frame.png">  <h3 id="stats-summary">Method Summary</h3> <p id="method-summary">We provide a number of the common statistical functions:</p> <table class="docutils">  <thead valign="bottom"> <tr class="row-odd">
<th class="head">Method</th> <th class="head">Description</th> </tr> </thead>  <tr class="row-even">
<td><a class="reference internal" href="../generated/pandas.core.window.rolling.count/#pandas.core.window.Rolling.count" title="pandas.core.window.Rolling.count"><code>count()</code></a></td> <td>Number of non-null observations</td> </tr> <tr class="row-odd">
<td><a class="reference internal" href="../generated/pandas.core.window.rolling.sum/#pandas.core.window.Rolling.sum" title="pandas.core.window.Rolling.sum"><code>sum()</code></a></td> <td>Sum of values</td> </tr> <tr class="row-even">
<td><a class="reference internal" href="../generated/pandas.core.window.rolling.mean/#pandas.core.window.Rolling.mean" title="pandas.core.window.Rolling.mean"><code>mean()</code></a></td> <td>Mean of values</td> </tr> <tr class="row-odd">
<td><a class="reference internal" href="../generated/pandas.core.window.rolling.median/#pandas.core.window.Rolling.median" title="pandas.core.window.Rolling.median"><code>median()</code></a></td> <td>Arithmetic median of values</td> </tr> <tr class="row-even">
<td><a class="reference internal" href="../generated/pandas.core.window.rolling.min/#pandas.core.window.Rolling.min" title="pandas.core.window.Rolling.min"><code>min()</code></a></td> <td>Minimum</td> </tr> <tr class="row-odd">
<td><a class="reference internal" href="../generated/pandas.core.window.rolling.max/#pandas.core.window.Rolling.max" title="pandas.core.window.Rolling.max"><code>max()</code></a></td> <td>Maximum</td> </tr> <tr class="row-even">
<td><a class="reference internal" href="../generated/pandas.core.window.rolling.std/#pandas.core.window.Rolling.std" title="pandas.core.window.Rolling.std"><code>std()</code></a></td> <td>Bessel-corrected sample standard deviation</td> </tr> <tr class="row-odd">
<td><a class="reference internal" href="../generated/pandas.core.window.rolling.var/#pandas.core.window.Rolling.var" title="pandas.core.window.Rolling.var"><code>var()</code></a></td> <td>Unbiased variance</td> </tr> <tr class="row-even">
<td><a class="reference internal" href="../generated/pandas.core.window.rolling.skew/#pandas.core.window.Rolling.skew" title="pandas.core.window.Rolling.skew"><code>skew()</code></a></td> <td>Sample skewness (3rd moment)</td> </tr> <tr class="row-odd">
<td><a class="reference internal" href="../generated/pandas.core.window.rolling.kurt/#pandas.core.window.Rolling.kurt" title="pandas.core.window.Rolling.kurt"><code>kurt()</code></a></td> <td>Sample kurtosis (4th moment)</td> </tr> <tr class="row-even">
<td><a class="reference internal" href="../generated/pandas.core.window.rolling.quantile/#pandas.core.window.Rolling.quantile" title="pandas.core.window.Rolling.quantile"><code>quantile()</code></a></td> <td>Sample quantile (value at %)</td> </tr> <tr class="row-odd">
<td><a class="reference internal" href="../generated/pandas.core.window.rolling.apply/#pandas.core.window.Rolling.apply" title="pandas.core.window.Rolling.apply"><code>apply()</code></a></td> <td>Generic apply</td> </tr> <tr class="row-even">
<td><a class="reference internal" href="../generated/pandas.core.window.rolling.cov/#pandas.core.window.Rolling.cov" title="pandas.core.window.Rolling.cov"><code>cov()</code></a></td> <td>Unbiased covariance (binary)</td> </tr> <tr class="row-odd">
<td><a class="reference internal" href="../generated/pandas.core.window.rolling.corr/#pandas.core.window.Rolling.corr" title="pandas.core.window.Rolling.corr"><code>corr()</code></a></td> <td>Correlation (binary)</td> </tr>  </table> <p>The <a class="reference internal" href="../generated/pandas.core.window.rolling.apply/#pandas.core.window.Rolling.apply" title="pandas.core.window.Rolling.apply"><code>apply()</code></a> function takes an extra <code>func</code> argument and performs generic rolling computations. The <code>func</code> argument should be a single function that produces a single value from an ndarray input. Suppose we wanted to compute the mean absolute deviation on a rolling basis:</p> <pre data-language="python">In [49]: mad = lambda x: np.fabs(x - x.mean()).mean()

In [50]: s.rolling(window=60).apply(mad).plot(style='k')
Out[50]: &lt;matplotlib.axes._subplots.AxesSubplot at 0x112f25950&gt;
</pre> <img alt="_images/rolling_apply_ex.png" src="http://pandas.pydata.org/pandas-docs/version/0.18.1/_images/rolling_apply_ex.png">   <h3 id="stats-rolling-window">Rolling Windows</h3> <p id="rolling-windows">Passing <code>win_type</code> to <code>.rolling</code> generates a generic rolling window computation, that is weighted according the <code>win_type</code>. The following methods are available:</p> <table class="docutils">  <thead valign="bottom"> <tr class="row-odd">
<th class="head">Method</th> <th class="head">Description</th> </tr> </thead>  <tr class="row-even">
<td><a class="reference internal" href="../generated/pandas.core.window.window.sum/#pandas.core.window.Window.sum" title="pandas.core.window.Window.sum"><code>sum()</code></a></td> <td>Sum of values</td> </tr> <tr class="row-odd">
<td><a class="reference internal" href="../generated/pandas.core.window.window.mean/#pandas.core.window.Window.mean" title="pandas.core.window.Window.mean"><code>mean()</code></a></td> <td>Mean of values</td> </tr>  </table> <p>The weights used in the window are specified by the <code>win_type</code> keyword. The list of recognized types are:</p> <ul class="simple"> <li><code>boxcar</code></li> <li><code>triang</code></li> <li><code>blackman</code></li> <li><code>hamming</code></li> <li><code>bartlett</code></li> <li><code>parzen</code></li> <li><code>bohman</code></li> <li><code>blackmanharris</code></li> <li><code>nuttall</code></li> <li><code>barthann</code></li> <li>
<code>kaiser</code> (needs beta)</li> <li>
<code>gaussian</code> (needs std)</li> <li>
<code>general_gaussian</code> (needs power, width)</li> <li>
<code>slepian</code> (needs width).</li> </ul> <pre data-language="python">In [51]: ser = pd.Series(np.random.randn(10), index=pd.date_range('1/1/2000', periods=10))

In [52]: ser.rolling(window=5, win_type='triang').mean()
Out[52]: 
2000-01-01         NaN
2000-01-02         NaN
2000-01-03         NaN
2000-01-04         NaN
2000-01-05   -1.037870
2000-01-06   -0.767705
2000-01-07   -0.383197
2000-01-08   -0.395513
2000-01-09   -0.558440
2000-01-10   -0.672416
Freq: D, dtype: float64
</pre> <p>Note that the <code>boxcar</code> window is equivalent to <a class="reference internal" href="../generated/pandas.core.window.rolling.mean/#pandas.core.window.Rolling.mean" title="pandas.core.window.Rolling.mean"><code>mean()</code></a>.</p> <pre data-language="python">In [53]: ser.rolling(window=5, win_type='boxcar').mean()
Out[53]: 
2000-01-01         NaN
2000-01-02         NaN
2000-01-03         NaN
2000-01-04         NaN
2000-01-05   -0.841164
2000-01-06   -0.779948
2000-01-07   -0.565487
2000-01-08   -0.502815
2000-01-09   -0.553755
2000-01-10   -0.472211
Freq: D, dtype: float64

In [54]: ser.rolling(window=5).mean()
Out[54]: 
2000-01-01         NaN
2000-01-02         NaN
2000-01-03         NaN
2000-01-04         NaN
2000-01-05   -0.841164
2000-01-06   -0.779948
2000-01-07   -0.565487
2000-01-08   -0.502815
2000-01-09   -0.553755
2000-01-10   -0.472211
Freq: D, dtype: float64
</pre> <p>For some windowing functions, additional parameters must be specified:</p> <pre data-language="python">In [55]: ser.rolling(window=5, win_type='gaussian').mean(std=0.1)
Out[55]: 
2000-01-01         NaN
2000-01-02         NaN
2000-01-03         NaN
2000-01-04         NaN
2000-01-05   -1.309989
2000-01-06   -1.153000
2000-01-07    0.606382
2000-01-08   -0.681101
2000-01-09   -0.289724
2000-01-10   -0.996632
Freq: D, dtype: float64
</pre> <div class="admonition note" id="stats-moments-normalization"> <p class="first admonition-title">Note</p> <p>For <code>.sum()</code> with a <code>win_type</code>, there is no normalization done to the weights for the window. Passing custom weights of <code>[1, 1, 1]</code> will yield a different result than passing weights of <code>[2, 2, 2]</code>, for example. When passing a <code>win_type</code> instead of explicitly specifying the weights, the weights are already normalized so that the largest weight is 1.</p> <p class="last">In contrast, the nature of the <code>.mean()</code> calculation is such that the weights are normalized with respect to each other. Weights of <code>[1, 1, 1]</code> and <code>[2, 2, 2]</code> yield the same result.</p> </div>   <h3 id="centering-windows">Centering Windows</h3> <p>By default the labels are set to the right edge of the window, but a <code>center</code> keyword is available so the labels can be set at the center.</p> <pre data-language="python">In [56]: ser.rolling(window=5).mean()
Out[56]: 
2000-01-01         NaN
2000-01-02         NaN
2000-01-03         NaN
2000-01-04         NaN
2000-01-05   -0.841164
2000-01-06   -0.779948
2000-01-07   -0.565487
2000-01-08   -0.502815
2000-01-09   -0.553755
2000-01-10   -0.472211
Freq: D, dtype: float64

In [57]: ser.rolling(window=5, center=True).mean()
Out[57]: 
2000-01-01         NaN
2000-01-02         NaN
2000-01-03   -0.841164
2000-01-04   -0.779948
2000-01-05   -0.565487
2000-01-06   -0.502815
2000-01-07   -0.553755
2000-01-08   -0.472211
2000-01-09         NaN
2000-01-10         NaN
Freq: D, dtype: float64
</pre>   <h3 id="stats-moments-binary">Binary Window Functions</h3> <p id="binary-window-functions"><a class="reference internal" href="../generated/pandas.core.window.rolling.cov/#pandas.core.window.Rolling.cov" title="pandas.core.window.Rolling.cov"><code>cov()</code></a> and <a class="reference internal" href="../generated/pandas.core.window.rolling.corr/#pandas.core.window.Rolling.corr" title="pandas.core.window.Rolling.corr"><code>corr()</code></a> can compute moving window statistics about two <code>Series</code> or any combination of <code>DataFrame/Series</code> or <code>DataFrame/DataFrame</code>. Here is the behavior in each case:</p> <ul class="simple"> <li>two <code>Series</code>: compute the statistic for the pairing.</li> <li>
<code>DataFrame/Series</code>: compute the statistics for each column of the DataFrame with the passed Series, thus returning a DataFrame.</li> <li>
<code>DataFrame/DataFrame</code>: by default compute the statistic for matching column names, returning a DataFrame. If the keyword argument <code>pairwise=True</code> is passed then computes the statistic for each pair of columns, returning a <code>Panel</code> whose <code>items</code> are the dates in question (see <a class="reference internal" href="#stats-moments-corr-pairwise">the next section</a>).</li> </ul> <p>For example:</p> <pre data-language="python">In [58]: df2 = df[:20]

In [59]: df2.rolling(window=5).corr(df2['B'])
Out[59]: 
                   A    B         C         D
2000-01-01       NaN  NaN       NaN       NaN
2000-01-02       NaN  NaN       NaN       NaN
2000-01-03       NaN  NaN       NaN       NaN
2000-01-04       NaN  NaN       NaN       NaN
2000-01-05 -0.262853  1.0  0.334449  0.193380
2000-01-06 -0.083745  1.0 -0.521587 -0.556126
2000-01-07 -0.292940  1.0 -0.658532 -0.458128
...              ...  ...       ...       ...
2000-01-14  0.519499  1.0 -0.687277  0.192822
2000-01-15  0.048982  1.0  0.167669 -0.061463
2000-01-16  0.217190  1.0  0.167564 -0.326034
2000-01-17  0.641180  1.0 -0.164780 -0.111487
2000-01-18  0.130422  1.0  0.322833  0.632383
2000-01-19  0.317278  1.0  0.384528  0.813656
2000-01-20  0.293598  1.0  0.159538  0.742381

[20 rows x 4 columns]
</pre>   <h3 id="stats-moments-corr-pairwise">Computing rolling pairwise covariances and correlations</h3> <p id="computing-rolling-pairwise-covariances-and-correlations">In financial data analysis and other fields it’s common to compute covariance and correlation matrices for a collection of time series. Often one is also interested in moving-window covariance and correlation matrices. This can be done by passing the <code>pairwise</code> keyword argument, which in the case of <code>DataFrame</code> inputs will yield a <code>Panel</code> whose <code>items</code> are the dates in question. In the case of a single DataFrame argument the <code>pairwise</code> argument can even be omitted:</p> <div class="admonition note"> <p class="first admonition-title">Note</p> <p class="last">Missing values are ignored and each entry is computed using the pairwise complete observations. Please see the <a class="reference internal" href="#computation-covariance">covariance section</a> for <a class="reference internal" href="#computation-covariance-caveats">caveats</a> associated with this method of calculating covariance and correlation matrices.</p> </div> <pre data-language="python">In [60]: covs = df[['B','C','D']].rolling(window=50).cov(df[['A','B','C']], pairwise=True)

In [61]: covs[df.index[-50]]
Out[61]: 
          A         B          C
B  2.667506  1.671711   1.938634
C  8.513843  1.938634  10.556436
D -7.714737 -1.434529  -7.082653
</pre> <pre data-language="python">In [62]: correls = df.rolling(window=50).corr()

In [63]: correls[df.index[-50]]
Out[63]: 
          A         B         C         D
A  1.000000  0.604221  0.767429 -0.776170
B  0.604221  1.000000  0.461484 -0.381148
C  0.767429  0.461484  1.000000 -0.748863
D -0.776170 -0.381148 -0.748863  1.000000
</pre> <p>You can efficiently retrieve the time series of correlations between two columns using <code>.loc</code> indexing:</p> <pre data-language="python">In [64]: correls.loc[:, 'A', 'C'].plot()
Out[64]: &lt;matplotlib.axes._subplots.AxesSubplot at 0x11ea521d0&gt;
</pre> <img alt="_images/rolling_corr_pairwise_ex.png" src="http://pandas.pydata.org/pandas-docs/version/0.18.1/_images/rolling_corr_pairwise_ex.png">    <h2 id="stats-aggregate">Aggregation</h2> <p id="aggregation">Once the <code>Rolling</code>, <code>Expanding</code> or <code>EWM</code> objects have been created, several methods are available to perform multiple computations on the data. This is very similar to a <code>.groupby(...).agg</code> seen <a class="reference internal" href="../groupby/#groupby-aggregate">here</a>.</p> <pre data-language="python">In [65]: dfa = pd.DataFrame(np.random.randn(1000, 3),
   ....:                    index=pd.date_range('1/1/2000', periods=1000),
   ....:                    columns=['A', 'B', 'C'])
   ....: 

In [66]: r = dfa.rolling(window=60,min_periods=1)

In [67]: r
Out[67]: Rolling [window=60,min_periods=1,center=False,axis=0]
</pre> <p>We can aggregate by passing a function to the entire DataFrame, or select a Series (or multiple Series) via standard getitem.</p> <pre data-language="python">In [68]: r.aggregate(np.sum)
Out[68]: 
                   A          B         C
2000-01-01  0.314226  -0.001675  0.071823
2000-01-02  1.206791   0.678918 -0.267817
2000-01-03  1.421701   0.600508 -0.445482
2000-01-04  1.912539  -0.759594  1.146974
2000-01-05  2.919639  -0.061759 -0.743617
2000-01-06  2.665637   1.298392 -0.803529
2000-01-07  2.513985   1.923089 -1.928308
...              ...        ...       ...
2002-09-20  1.447669 -12.360302  2.734381
2002-09-21  1.871783 -13.896542  3.086102
2002-09-22  2.540658 -12.594402  3.162542
2002-09-23  2.974674 -12.727703  3.861005
2002-09-24  1.391366 -13.584590  3.790683
2002-09-25  2.027313 -15.083214  3.377896
2002-09-26  1.290363 -13.569459  3.809884

[1000 rows x 3 columns]

In [69]: r['A'].aggregate(np.sum)
Out[69]: 
2000-01-01    0.314226
2000-01-02    1.206791
2000-01-03    1.421701
2000-01-04    1.912539
2000-01-05    2.919639
2000-01-06    2.665637
2000-01-07    2.513985
                ...   
2002-09-20    1.447669
2002-09-21    1.871783
2002-09-22    2.540658
2002-09-23    2.974674
2002-09-24    1.391366
2002-09-25    2.027313
2002-09-26    1.290363
Freq: D, Name: A, dtype: float64

In [70]: r[['A','B']].aggregate(np.sum)
Out[70]: 
                   A          B
2000-01-01  0.314226  -0.001675
2000-01-02  1.206791   0.678918
2000-01-03  1.421701   0.600508
2000-01-04  1.912539  -0.759594
2000-01-05  2.919639  -0.061759
2000-01-06  2.665637   1.298392
2000-01-07  2.513985   1.923089
...              ...        ...
2002-09-20  1.447669 -12.360302
2002-09-21  1.871783 -13.896542
2002-09-22  2.540658 -12.594402
2002-09-23  2.974674 -12.727703
2002-09-24  1.391366 -13.584590
2002-09-25  2.027313 -15.083214
2002-09-26  1.290363 -13.569459

[1000 rows x 2 columns]
</pre> <p>As you can see, the result of the aggregation will have the selected columns, or all columns if none are selected.</p>  <h3 id="stats-aggregate-multifunc">Applying multiple functions at once</h3> <p id="applying-multiple-functions-at-once">With windowed Series you can also pass a list or dict of functions to do aggregation with, outputting a DataFrame:</p> <pre data-language="python">In [71]: r['A'].agg([np.sum, np.mean, np.std])
Out[71]: 
                 sum      mean       std
2000-01-01  0.314226  0.314226       NaN
2000-01-02  1.206791  0.603396  0.408948
2000-01-03  1.421701  0.473900  0.365959
2000-01-04  1.912539  0.478135  0.298925
2000-01-05  2.919639  0.583928  0.350682
2000-01-06  2.665637  0.444273  0.464115
2000-01-07  2.513985  0.359141  0.479828
...              ...       ...       ...
2002-09-20  1.447669  0.024128  1.034827
2002-09-21  1.871783  0.031196  1.031417
2002-09-22  2.540658  0.042344  1.026341
2002-09-23  2.974674  0.049578  1.030021
2002-09-24  1.391366  0.023189  1.024793
2002-09-25  2.027313  0.033789  1.022099
2002-09-26  1.290363  0.021506  1.024751

[1000 rows x 3 columns]
</pre> <p>If a dict is passed, the keys will be used to name the columns. Otherwise the function’s name (stored in the function object) will be used.</p> <pre data-language="python">In [72]: r['A'].agg({'result1' : np.sum,
   ....:             'result2' : np.mean})
   ....: 
Out[72]: 
             result2   result1
2000-01-01  0.314226  0.314226
2000-01-02  0.603396  1.206791
2000-01-03  0.473900  1.421701
2000-01-04  0.478135  1.912539
2000-01-05  0.583928  2.919639
2000-01-06  0.444273  2.665637
2000-01-07  0.359141  2.513985
...              ...       ...
2002-09-20  0.024128  1.447669
2002-09-21  0.031196  1.871783
2002-09-22  0.042344  2.540658
2002-09-23  0.049578  2.974674
2002-09-24  0.023189  1.391366
2002-09-25  0.033789  2.027313
2002-09-26  0.021506  1.290363

[1000 rows x 2 columns]
</pre> <p>On a widowed DataFrame, you can pass a list of functions to apply to each column, which produces an aggregated result with a hierarchical index:</p> <pre data-language="python">In [73]: r.agg([np.sum, np.mean])
Out[73]: 
                   A                    B                   C          
                 sum      mean        sum      mean       sum      mean
2000-01-01  0.314226  0.314226  -0.001675 -0.001675  0.071823  0.071823
2000-01-02  1.206791  0.603396   0.678918  0.339459 -0.267817 -0.133908
2000-01-03  1.421701  0.473900   0.600508  0.200169 -0.445482 -0.148494
2000-01-04  1.912539  0.478135  -0.759594 -0.189899  1.146974  0.286744
2000-01-05  2.919639  0.583928  -0.061759 -0.012352 -0.743617 -0.148723
2000-01-06  2.665637  0.444273   1.298392  0.216399 -0.803529 -0.133921
2000-01-07  2.513985  0.359141   1.923089  0.274727 -1.928308 -0.275473
...              ...       ...        ...       ...       ...       ...
2002-09-20  1.447669  0.024128 -12.360302 -0.206005  2.734381  0.045573
2002-09-21  1.871783  0.031196 -13.896542 -0.231609  3.086102  0.051435
2002-09-22  2.540658  0.042344 -12.594402 -0.209907  3.162542  0.052709
2002-09-23  2.974674  0.049578 -12.727703 -0.212128  3.861005  0.064350
2002-09-24  1.391366  0.023189 -13.584590 -0.226410  3.790683  0.063178
2002-09-25  2.027313  0.033789 -15.083214 -0.251387  3.377896  0.056298
2002-09-26  1.290363  0.021506 -13.569459 -0.226158  3.809884  0.063498

[1000 rows x 6 columns]
</pre> <p>Passing a dict of functions has different behavior by default, see the next section.</p>   <h3 id="applying-different-functions-to-dataframe-columns">Applying different functions to DataFrame columns</h3> <p>By passing a dict to <code>aggregate</code> you can apply a different aggregation to the columns of a DataFrame:</p> <pre data-language="python">In [74]: r.agg({'A' : np.sum,
   ....:        'B' : lambda x: np.std(x, ddof=1)})
   ....: 
Out[74]: 
                   A         B
2000-01-01  0.314226       NaN
2000-01-02  1.206791  0.482437
2000-01-03  1.421701  0.417825
2000-01-04  1.912539  0.851468
2000-01-05  2.919639  0.837474
2000-01-06  2.665637  0.935441
2000-01-07  2.513985  0.867770
...              ...       ...
2002-09-20  1.447669  1.084259
2002-09-21  1.871783  1.088368
2002-09-22  2.540658  1.084707
2002-09-23  2.974674  1.084936
2002-09-24  1.391366  1.079268
2002-09-25  2.027313  1.091334
2002-09-26  1.290363  1.060255

[1000 rows x 2 columns]
</pre> <p>The function names can also be strings. In order for a string to be valid it must be implemented on the windowed object</p> <pre data-language="python">In [75]: r.agg({'A' : 'sum', 'B' : 'std'})
Out[75]: 
                   A         B
2000-01-01  0.314226       NaN
2000-01-02  1.206791  0.482437
2000-01-03  1.421701  0.417825
2000-01-04  1.912539  0.851468
2000-01-05  2.919639  0.837474
2000-01-06  2.665637  0.935441
2000-01-07  2.513985  0.867770
...              ...       ...
2002-09-20  1.447669  1.084259
2002-09-21  1.871783  1.088368
2002-09-22  2.540658  1.084707
2002-09-23  2.974674  1.084936
2002-09-24  1.391366  1.079268
2002-09-25  2.027313  1.091334
2002-09-26  1.290363  1.060255

[1000 rows x 2 columns]
</pre> <p>Furthermore you can pass a nested dict to indicate different aggregations on different columns.</p> <pre data-language="python">In [76]: r.agg({'A' : ['sum','std'], 'B' : ['mean','std'] })
Out[76]: 
                   A                   B          
                 sum       std      mean       std
2000-01-01  0.314226       NaN -0.001675       NaN
2000-01-02  1.206791  0.408948  0.339459  0.482437
2000-01-03  1.421701  0.365959  0.200169  0.417825
2000-01-04  1.912539  0.298925 -0.189899  0.851468
2000-01-05  2.919639  0.350682 -0.012352  0.837474
2000-01-06  2.665637  0.464115  0.216399  0.935441
2000-01-07  2.513985  0.479828  0.274727  0.867770
...              ...       ...       ...       ...
2002-09-20  1.447669  1.034827 -0.206005  1.084259
2002-09-21  1.871783  1.031417 -0.231609  1.088368
2002-09-22  2.540658  1.026341 -0.209907  1.084707
2002-09-23  2.974674  1.030021 -0.212128  1.084936
2002-09-24  1.391366  1.024793 -0.226410  1.079268
2002-09-25  2.027313  1.022099 -0.251387  1.091334
2002-09-26  1.290363  1.024751 -0.226158  1.060255

[1000 rows x 4 columns]
</pre>    <h2 id="stats-moments-expanding">Expanding Windows</h2> <p id="expanding-windows">A common alternative to rolling statistics is to use an <em>expanding</em> window, which yields the value of the statistic with all the data available up to that point in time.</p> <p>These follow a similar interface to <code>.rolling</code>, with the <code>.expanding</code> method returning an <code>Expanding</code> object.</p> <p>As these calculations are a special case of rolling statistics, they are implemented in pandas such that the following two calls are equivalent:</p> <pre data-language="python">In [77]: df.rolling(window=len(df), min_periods=1).mean()[:5]
Out[77]: 
                   A         B         C         D
2000-01-01 -1.388345  3.317290  0.344542 -0.036968
2000-01-02 -1.123132  3.622300  1.675867  0.595300
2000-01-03 -0.628502  3.626503  2.455240  1.060158
2000-01-04 -0.768740  3.888917  2.451354  1.281874
2000-01-05 -0.824034  4.108035  2.556112  1.140723

In [78]: df.expanding(min_periods=1).mean()[:5]
Out[78]: 
                   A         B         C         D
2000-01-01 -1.388345  3.317290  0.344542 -0.036968
2000-01-02 -1.123132  3.622300  1.675867  0.595300
2000-01-03 -0.628502  3.626503  2.455240  1.060158
2000-01-04 -0.768740  3.888917  2.451354  1.281874
2000-01-05 -0.824034  4.108035  2.556112  1.140723
</pre> <p>These have a similar set of methods to <code>.rolling</code> methods.</p>  <h3 id="id1">Method Summary</h3> <table class="docutils">  <thead valign="bottom"> <tr class="row-odd">
<th class="head">Function</th> <th class="head">Description</th> </tr> </thead>  <tr class="row-even">
<td><a class="reference internal" href="../generated/pandas.core.window.expanding.count/#pandas.core.window.Expanding.count" title="pandas.core.window.Expanding.count"><code>count()</code></a></td> <td>Number of non-null observations</td> </tr> <tr class="row-odd">
<td><a class="reference internal" href="../generated/pandas.core.window.expanding.sum/#pandas.core.window.Expanding.sum" title="pandas.core.window.Expanding.sum"><code>sum()</code></a></td> <td>Sum of values</td> </tr> <tr class="row-even">
<td><a class="reference internal" href="../generated/pandas.core.window.expanding.mean/#pandas.core.window.Expanding.mean" title="pandas.core.window.Expanding.mean"><code>mean()</code></a></td> <td>Mean of values</td> </tr> <tr class="row-odd">
<td><a class="reference internal" href="../generated/pandas.core.window.expanding.median/#pandas.core.window.Expanding.median" title="pandas.core.window.Expanding.median"><code>median()</code></a></td> <td>Arithmetic median of values</td> </tr> <tr class="row-even">
<td><a class="reference internal" href="../generated/pandas.core.window.expanding.min/#pandas.core.window.Expanding.min" title="pandas.core.window.Expanding.min"><code>min()</code></a></td> <td>Minimum</td> </tr> <tr class="row-odd">
<td><a class="reference internal" href="../generated/pandas.core.window.expanding.max/#pandas.core.window.Expanding.max" title="pandas.core.window.Expanding.max"><code>max()</code></a></td> <td>Maximum</td> </tr> <tr class="row-even">
<td><a class="reference internal" href="../generated/pandas.core.window.expanding.std/#pandas.core.window.Expanding.std" title="pandas.core.window.Expanding.std"><code>std()</code></a></td> <td>Unbiased standard deviation</td> </tr> <tr class="row-odd">
<td><a class="reference internal" href="../generated/pandas.core.window.expanding.var/#pandas.core.window.Expanding.var" title="pandas.core.window.Expanding.var"><code>var()</code></a></td> <td>Unbiased variance</td> </tr> <tr class="row-even">
<td><a class="reference internal" href="../generated/pandas.core.window.expanding.skew/#pandas.core.window.Expanding.skew" title="pandas.core.window.Expanding.skew"><code>skew()</code></a></td> <td>Unbiased skewness (3rd moment)</td> </tr> <tr class="row-odd">
<td><a class="reference internal" href="../generated/pandas.core.window.expanding.kurt/#pandas.core.window.Expanding.kurt" title="pandas.core.window.Expanding.kurt"><code>kurt()</code></a></td> <td>Unbiased kurtosis (4th moment)</td> </tr> <tr class="row-even">
<td><a class="reference internal" href="../generated/pandas.core.window.expanding.quantile/#pandas.core.window.Expanding.quantile" title="pandas.core.window.Expanding.quantile"><code>quantile()</code></a></td> <td>Sample quantile (value at %)</td> </tr> <tr class="row-odd">
<td><a class="reference internal" href="../generated/pandas.core.window.expanding.apply/#pandas.core.window.Expanding.apply" title="pandas.core.window.Expanding.apply"><code>apply()</code></a></td> <td>Generic apply</td> </tr> <tr class="row-even">
<td><a class="reference internal" href="../generated/pandas.core.window.expanding.cov/#pandas.core.window.Expanding.cov" title="pandas.core.window.Expanding.cov"><code>cov()</code></a></td> <td>Unbiased covariance (binary)</td> </tr> <tr class="row-odd">
<td><a class="reference internal" href="../generated/pandas.core.window.expanding.corr/#pandas.core.window.Expanding.corr" title="pandas.core.window.Expanding.corr"><code>corr()</code></a></td> <td>Correlation (binary)</td> </tr>  </table> <p>Aside from not having a <code>window</code> parameter, these functions have the same interfaces as their <code>.rolling</code> counterparts. Like above, the parameters they all accept are:</p> <ul class="simple"> <li>
<code>min_periods</code>: threshold of non-null data points to require. Defaults to minimum needed to compute statistic. No <code>NaNs</code> will be output once <code>min_periods</code> non-null data points have been seen.</li> <li>
<code>center</code>: boolean, whether to set the labels at the center (default is False)</li> </ul> <div class="admonition note"> <p class="first admonition-title">Note</p> <p class="last">The output of the <code>.rolling</code> and <code>.expanding</code> methods do not return a <code>NaN</code> if there are at least <code>min_periods</code> non-null values in the current window. This differs from <code>cumsum</code>, <code>cumprod</code>, <code>cummax</code>, and <code>cummin</code>, which return <code>NaN</code> in the output wherever a <code>NaN</code> is encountered in the input.</p> </div> <p>An expanding window statistic will be more stable (and less responsive) than its rolling window counterpart as the increasing window size decreases the relative impact of an individual data point. As an example, here is the <a class="reference internal" href="../generated/pandas.core.window.expanding.mean/#pandas.core.window.Expanding.mean" title="pandas.core.window.Expanding.mean"><code>mean()</code></a> output for the previous time series dataset:</p> <pre data-language="python">In [79]: s.plot(style='k--')
Out[79]: &lt;matplotlib.axes._subplots.AxesSubplot at 0x118390f10&gt;

In [80]: s.expanding().mean().plot(style='k')
Out[80]: &lt;matplotlib.axes._subplots.AxesSubplot at 0x118390f10&gt;
</pre> <img alt="_images/expanding_mean_frame.png" src="http://pandas.pydata.org/pandas-docs/version/0.18.1/_images/expanding_mean_frame.png">    <h2 id="stats-moments-exponentially-weighted">Exponentially Weighted Windows</h2> <p id="exponentially-weighted-windows">A related set of functions are exponentially weighted versions of several of the above statistics. A similar interface to <code>.rolling</code> and <code>.expanding</code> is accessed thru the <code>.ewm</code> method to receive an <code>EWM</code> object. A number of expanding EW (exponentially weighted) methods are provided:</p> <table class="docutils">  <thead valign="bottom"> <tr class="row-odd">
<th class="head">Function</th> <th class="head">Description</th> </tr> </thead>  <tr class="row-even">
<td><a class="reference internal" href="../generated/pandas.core.window.ewm.mean/#pandas.core.window.EWM.mean" title="pandas.core.window.EWM.mean"><code>mean()</code></a></td> <td>EW moving average</td> </tr> <tr class="row-odd">
<td><a class="reference internal" href="../generated/pandas.core.window.ewm.var/#pandas.core.window.EWM.var" title="pandas.core.window.EWM.var"><code>var()</code></a></td> <td>EW moving variance</td> </tr> <tr class="row-even">
<td><a class="reference internal" href="../generated/pandas.core.window.ewm.std/#pandas.core.window.EWM.std" title="pandas.core.window.EWM.std"><code>std()</code></a></td> <td>EW moving standard deviation</td> </tr> <tr class="row-odd">
<td><a class="reference internal" href="../generated/pandas.core.window.ewm.corr/#pandas.core.window.EWM.corr" title="pandas.core.window.EWM.corr"><code>corr()</code></a></td> <td>EW moving correlation</td> </tr> <tr class="row-even">
<td><a class="reference internal" href="../generated/pandas.core.window.ewm.cov/#pandas.core.window.EWM.cov" title="pandas.core.window.EWM.cov"><code>cov()</code></a></td> <td>EW moving covariance</td> </tr>  </table> <p>In general, a weighted moving average is calculated as</p> <div class="math"> <p><img src="http://pandas.pydata.org/pandas-docs/version/0.18.1/_images/math/e4d2fc22475fc38c6ab461d379e89faa4953fc11.png" alt="y_t = \frac{\sum_{i=0}^t w_i x_{t-i}}{\sum_{i=0}^t w_i},"></p> </div>
<p>where <img class="math" src="http://pandas.pydata.org/pandas-docs/version/0.18.1/_images/math/86ec1edb070ffe9216097a80189ee3434c9b5f20.png" alt="x_t"> is the input and <img class="math" src="http://pandas.pydata.org/pandas-docs/version/0.18.1/_images/math/fc9b39d13c288347abb9aef1e1591a4ea3b85b00.png" alt="y_t"> is the result.</p> <p>The EW functions support two variants of exponential weights. The default, <code>adjust=True</code>, uses the weights <img class="math" src="http://pandas.pydata.org/pandas-docs/version/0.18.1/_images/math/8e7d6303c781d14c7c3f252f0b087329be6f91ce.png" alt="w_i = (1 - \alpha)^i"> which gives</p> <div class="math"> <p><img src="http://pandas.pydata.org/pandas-docs/version/0.18.1/_images/math/bb69529725bd7068c05b20ed4ebcf3dc83bfab35.png" alt="y_t = \frac{x_t + (1 - \alpha)x_{t-1} + (1 - \alpha)^2 x_{t-2} + ...
+ (1 - \alpha)^t x_{0}}{1 + (1 - \alpha) + (1 - \alpha)^2 + ...
+ (1 - \alpha)^t}"></p> </div>
<p>When <code>adjust=False</code> is specified, moving averages are calculated as</p> <div class="math"> <p><img src="http://pandas.pydata.org/pandas-docs/version/0.18.1/_images/math/f2e5b11ad1bdeb0d5fd5c6d696685a289449348b.png" alt="y_0 &amp;= x_0 \\
y_t &amp;= (1 - \alpha) y_{t-1} + \alpha x_t,"></p> </div>
<p>which is equivalent to using weights</p> <div class="math"> <p><img src="http://pandas.pydata.org/pandas-docs/version/0.18.1/_images/math/b9083c84b16f8c0cf7991e46a165e97942d78dc3.png" alt="w_i = \begin{cases}
    \alpha (1 - \alpha)^i &amp; \text{if } i &lt; t \\
    (1 - \alpha)^i        &amp; \text{if } i = t.
\end{cases}"></p> </div>
<div class="admonition note"> <p class="first admonition-title">Note</p> <p>These equations are sometimes written in terms of <img class="math" src="http://pandas.pydata.org/pandas-docs/version/0.18.1/_images/math/2ca659c78940a1c39298c47c91c15fa0d60ae47d.png" alt="\alpha' = 1 - \alpha">, e.g.</p> <div class="last math"> <p><img src="http://pandas.pydata.org/pandas-docs/version/0.18.1/_images/math/19c7b91440988a2a783a5e99b526ae0f554fbf1a.png" alt="y_t = \alpha' y_{t-1} + (1 - \alpha') x_t."></p> </div>
</div> <p>The difference between the above two variants arises because we are dealing with series which have finite history. Consider a series of infinite history:</p> <div class="math"> <p><img src="http://pandas.pydata.org/pandas-docs/version/0.18.1/_images/math/46fc84bfcb30902e105489d73302a0d3486898b6.png" alt="y_t = \frac{x_t + (1 - \alpha)x_{t-1} + (1 - \alpha)^2 x_{t-2} + ...}
{1 + (1 - \alpha) + (1 - \alpha)^2 + ...}"></p> </div>
<p>Noting that the denominator is a geometric series with initial term equal to 1 and a ratio of <img class="math" src="http://pandas.pydata.org/pandas-docs/version/0.18.1/_images/math/324ce9e91c8341018aedd8d360b4b2de1f239f78.png" alt="1 - \alpha"> we have</p> <div class="math"> <p><img src="http://pandas.pydata.org/pandas-docs/version/0.18.1/_images/math/2be73bffdf3cefb77c1cafd822ff2dafccd03a99.png" alt="y_t &amp;= \frac{x_t + (1 - \alpha)x_{t-1} + (1 - \alpha)^2 x_{t-2} + ...}
{\frac{1}{1 - (1 - \alpha)}}\\
&amp;= [x_t + (1 - \alpha)x_{t-1} + (1 - \alpha)^2 x_{t-2} + ...] \alpha \\
&amp;= \alpha x_t + [(1-\alpha)x_{t-1} + (1 - \alpha)^2 x_{t-2} + ...]\alpha \\
&amp;= \alpha x_t + (1 - \alpha)[x_{t-1} + (1 - \alpha) x_{t-2} + ...]\alpha\\
&amp;= \alpha x_t + (1 - \alpha) y_{t-1}"></p> </div>
<p>which shows the equivalence of the above two variants for infinite series. When <code>adjust=True</code> we have <img class="math" src="http://pandas.pydata.org/pandas-docs/version/0.18.1/_images/math/fac73f10d4a062773e5c1dc551c259aab315685a.png" alt="y_0 = x_0"> and from the last representation above we have <img class="math" src="http://pandas.pydata.org/pandas-docs/version/0.18.1/_images/math/d581470e8df68e388fb762efa7025416a76bab73.png" alt="y_t = \alpha x_t + (1 - \alpha) y_{t-1}">, therefore there is an assumption that <img class="math" src="http://pandas.pydata.org/pandas-docs/version/0.18.1/_images/math/c3c08496f07567285212e468b173bea9ca153fab.png" alt="x_0"> is not an ordinary value but rather an exponentially weighted moment of the infinite series up to that point.</p> <p>One must have <img class="math" src="http://pandas.pydata.org/pandas-docs/version/0.18.1/_images/math/cd4a2d0a9116f8ce0bfe6a85ec55d8f0c643d67b.png" alt="0 &lt; \alpha \leq 1">, and while since version 0.18.0 it has been possible to pass <img class="math" src="http://pandas.pydata.org/pandas-docs/version/0.18.1/_images/math/ad59b6e24a4a00ac621801f8d7513d68be654ab5.png" alt="\alpha"> directly, it’s often easier to think about either the <strong>span</strong>, <strong>center of mass (com)</strong> or <strong>half-life</strong> of an EW moment:</p> <div class="math"> <p><img src="http://pandas.pydata.org/pandas-docs/version/0.18.1/_images/math/cac760f2ac4651ca34c7cd45e5f8707359e52910.png" alt="\alpha =
 \begin{cases}
     \frac{2}{s + 1},               &amp; \text{for span}\ s \geq 1\\
     \frac{1}{1 + c},               &amp; \text{for center of mass}\ c \geq 0\\
     1 - \exp^{\frac{\log 0.5}{h}}, &amp; \text{for half-life}\ h &gt; 0
 \end{cases}"></p> </div>
<p>One must specify precisely one of <strong>span</strong>, <strong>center of mass</strong>, <strong>half-life</strong> and <strong>alpha</strong> to the EW functions:</p> <ul class="simple"> <li>
<strong>Span</strong> corresponds to what is commonly called an “N-day EW moving average”.</li> <li>
<strong>Center of mass</strong> has a more physical interpretation and can be thought of in terms of span: <img class="math" src="http://pandas.pydata.org/pandas-docs/version/0.18.1/_images/math/d6dbc28aa3d837f24abc53ab051c3f21a6be5ad9.png" alt="c = (s - 1) / 2">.</li> <li>
<strong>Half-life</strong> is the period of time for the exponential weight to reduce to one half.</li> <li>
<strong>Alpha</strong> specifies the smoothing factor directly.</li> </ul> <p>Here is an example for a univariate time series:</p> <pre data-language="python">In [81]: s.plot(style='k--')
Out[81]: &lt;matplotlib.axes._subplots.AxesSubplot at 0x1132e2dd0&gt;

In [82]: s.ewm(span=20).mean().plot(style='k')
Out[82]: &lt;matplotlib.axes._subplots.AxesSubplot at 0x1132e2dd0&gt;
</pre> <img alt="_images/ewma_ex.png" src="http://pandas.pydata.org/pandas-docs/version/0.18.1/_images/ewma_ex.png"> <p>EWM has a <code>min_periods</code> argument, which has the same meaning it does for all the <code>.expanding</code> and <code>.rolling</code> methods: no output values will be set until at least <code>min_periods</code> non-null values are encountered in the (expanding) window. (This is a change from versions prior to 0.15.0, in which the <code>min_periods</code> argument affected only the <code>min_periods</code> consecutive entries starting at the first non-null value.)</p> <p>EWM also has an <code>ignore_na</code> argument, which deterines how intermediate null values affect the calculation of the weights. When <code>ignore_na=False</code> (the default), weights are calculated based on absolute positions, so that intermediate null values affect the result. When <code>ignore_na=True</code> (which reproduces the behavior in versions prior to 0.15.0), weights are calculated by ignoring intermediate null values. For example, assuming <code>adjust=True</code>, if <code>ignore_na=False</code>, the weighted average of <code>3, NaN, 5</code> would be calculated as</p> <div class="math"> <p><img src="http://pandas.pydata.org/pandas-docs/version/0.18.1/_images/math/0e51849e58bad9035f6e3577282075d2eb58c3b8.png" alt="\frac{(1-\alpha)^2 \cdot 3 + 1 \cdot 5}{(1-\alpha)^2 + 1}"></p> </div>
<p>Whereas if <code>ignore_na=True</code>, the weighted average would be calculated as</p> <div class="math"> <p><img src="http://pandas.pydata.org/pandas-docs/version/0.18.1/_images/math/8250fa89b3661ee8364adde492a2714de7b90cf7.png" alt="\frac{(1-\alpha) \cdot 3 + 1 \cdot 5}{(1-\alpha) + 1}."></p> </div>
<p>The <code>var()</code>, <code>std()</code>, and <code>cov()</code> functions have a <code>bias</code> argument, specifying whether the result should contain biased or unbiased statistics. For example, if <code>bias=True</code>, <code>ewmvar(x)</code> is calculated as <code>ewmvar(x) = ewma(x**2) - ewma(x)**2</code>; whereas if <code>bias=False</code> (the default), the biased variance statistics are scaled by debiasing factors</p> <div class="math"> <p><img src="http://pandas.pydata.org/pandas-docs/version/0.18.1/_images/math/cb2f0cb0c4fb39bd364cdd197e3050dae6a6e16e.png" alt="\frac{\left(\sum_{i=0}^t w_i\right)^2}{\left(\sum_{i=0}^t w_i\right)^2 - \sum_{i=0}^t w_i^2}."></p> </div>
<p>(For <img class="math" src="http://pandas.pydata.org/pandas-docs/version/0.18.1/_images/math/6c0782a869e0c8f863f2d840ed57315c0437d6a6.png" alt="w_i = 1">, this reduces to the usual <img class="math" src="http://pandas.pydata.org/pandas-docs/version/0.18.1/_images/math/84ef2915fd746470bfbc16438f762052a3d936c8.png" alt="N / (N - 1)"> factor, with <img class="math" src="http://pandas.pydata.org/pandas-docs/version/0.18.1/_images/math/95d4ea9771d91d149afe4d3ccbdc7030d72c5ea1.png" alt="N = t + 1">.) See <a class="reference external" href="http://en.wikipedia.org/wiki/Weighted_arithmetic_mean#Weighted_sample_variance" target="_blank">Weighted Sample Variance</a> for further details.</p>
<div class="_attribution">
  <p class="_attribution-p">
    © 2011–2012 Lambda Foundry, Inc. and PyData Development Team<br>© 2008–2011 AQR Capital Management, LLC<br>© 2008–2014 the pandas development team<br>Licensed under the 3-clause BSD License.<br>
    <a href="http://pandas.pydata.org/pandas-docs/version/0.18.1/computation.html" class="_attribution-link" target="_blank">http://pandas.pydata.org/pandas-docs/version/0.18.1/computation.html</a>
  </p>
</div>

			</div>
		</div>
	</section>

	</div>
</body>
</html>
