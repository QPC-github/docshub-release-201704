
<!DOCTYPE HTML>

<html lang="en">

<head>
  <meta charset="utf-8">
  <title>18. Time Series &#47; Date Functionality - Pandas 0.18 - W3cubDocs</title>
  
  <meta name="description" content="pandas has proven very successful as a tool for working with time series data, especially in the financial data analysis space. Using the NumPy &hellip;">
  <meta name="keywords" content="time, series, date, functionality, -, pandas, pandas~0.18">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="http://docs.w3cub.com/pandas~0.18/timeseries/">
  <link href="/favicon.png" rel="icon">
  <link type="text/css" rel="stylesheet" href="/assets/application-50364fff564ce3b6327021805f3f00e2957b441cf27f576a7dd4ff63bbc47047.css">
  <script type="text/javascript" src="/assets/application-db64bfd54ceb42be11af7995804cf4902548419ceb79d509b0b7d62c22d98e6f.js"></script>
  <script src="/json/pandas~0.18.js"></script>
  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-71174418-1']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>


</head>

<body>
	<div class="_app">
	<header class="_header">
  
  <form class="_search">
    <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
    <a class="_search-clear"></a>
    <div class="_search-tag"></div>
  </form>
  
  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/pandas~0.18/" class="_nav-link" title="" style="margin-left:0;">pandas 0.18</a></span>
  
  <nav class="_nav">
    <a href="/app/" class="_nav-link ">App</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		<div class="_list">
			
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<div class="_page _sphinx">
				
<h1 id="timeseries">Time Series / Date functionality</h1> <p id="time-series-date-functionality">pandas has proven very successful as a tool for working with time series data, especially in the financial data analysis space. Using the NumPy <code>datetime64</code> and <code>timedelta64</code> dtypes, we have consolidated a large number of features from other Python libraries like <code>scikits.timeseries</code> as well as created a tremendous amount of new functionality for manipulating time series data.</p> <p>In working with time series data, we will frequently seek to:</p>  <ul class="simple"> <li>generate sequences of fixed-frequency dates and time spans</li> <li>conform or convert time series to a particular frequency</li> <li>compute “relative” dates based on various non-standard time increments (e.g. 5 business days before the last business day of the year), or “roll” dates forward or backward</li> </ul>  <p>pandas provides a relatively compact and self-contained set of tools for performing the above tasks.</p> <p>Create a range of dates:</p> <pre data-language="python"># 72 hours starting with midnight Jan 1st, 2011
In [1]: rng = pd.date_range('1/1/2011', periods=72, freq='H')

In [2]: rng[:5]
Out[2]: 
DatetimeIndex(['2011-01-01 00:00:00', '2011-01-01 01:00:00',
               '2011-01-01 02:00:00', '2011-01-01 03:00:00',
               '2011-01-01 04:00:00'],
              dtype='datetime64[ns]', freq='H')
</pre> <p>Index pandas objects with dates:</p> <pre data-language="python">In [3]: ts = pd.Series(np.random.randn(len(rng)), index=rng)

In [4]: ts.head()
Out[4]: 
2011-01-01 00:00:00    0.469112
2011-01-01 01:00:00   -0.282863
2011-01-01 02:00:00   -1.509059
2011-01-01 03:00:00   -1.135632
2011-01-01 04:00:00    1.212112
Freq: H, dtype: float64
</pre> <p>Change frequency and fill gaps:</p> <pre data-language="python"># to 45 minute frequency and forward fill
In [5]: converted = ts.asfreq('45Min', method='pad')

In [6]: converted.head()
Out[6]: 
2011-01-01 00:00:00    0.469112
2011-01-01 00:45:00    0.469112
2011-01-01 01:30:00   -0.282863
2011-01-01 02:15:00   -1.509059
2011-01-01 03:00:00   -1.135632
Freq: 45T, dtype: float64
</pre> <p>Resample:</p> <pre data-language="python"># Daily means
In [7]: ts.resample('D').mean()
Out[7]: 
2011-01-01   -0.319569
2011-01-02   -0.337703
2011-01-03    0.117258
Freq: D, dtype: float64
</pre>  <h2 id="timeseries-overview">Overview</h2> <p id="overview">Following table shows the type of time-related classes pandas can handle and how to create them.</p> <table class="docutils">  <thead valign="bottom"> <tr class="row-odd">
<th class="head">Class</th> <th class="head">Remarks</th> <th class="head">How to create</th> </tr> </thead>  <tr class="row-even">
<td><code>Timestamp</code></td> <td>Represents a single time stamp</td> <td>
<code>to_datetime</code>, <code>Timestamp</code>
</td> </tr> <tr class="row-odd">
<td><code>DatetimeIndex</code></td> <td>Index of <code>Timestamp</code>
</td> <td>
<code>to_datetime</code>, <code>date_range</code>, <code>DatetimeIndex</code>
</td> </tr> <tr class="row-even">
<td><code>Period</code></td> <td>Represents a single time span</td> <td><code>Period</code></td> </tr> <tr class="row-odd">
<td><code>PeriodIndex</code></td> <td>Index of <code>Period</code>
</td> <td>
<code>period_range</code>, <code>PeriodIndex</code>
</td> </tr>  </table>   <h2 id="timeseries-representation">Time Stamps vs. Time Spans</h2> <p id="time-stamps-vs-time-spans">Time-stamped data is the most basic type of timeseries data that associates values with points in time. For pandas objects it means using the points in time.</p> <pre data-language="python">In [8]: pd.Timestamp(datetime(2012, 5, 1))
Out[8]: Timestamp('2012-05-01 00:00:00')

In [9]: pd.Timestamp('2012-05-01')
Out[9]: Timestamp('2012-05-01 00:00:00')
</pre> <p>However, in many cases it is more natural to associate things like change variables with a time span instead. The span represented by <code>Period</code> can be specified explicitly, or inferred from datetime string format.</p> <p>For example:</p> <pre data-language="python">In [10]: pd.Period('2011-01')
Out[10]: Period('2011-01', 'M')

In [11]: pd.Period('2012-05', freq='D')
Out[11]: Period('2012-05-01', 'D')
</pre> <p><code>Timestamp</code> and <code>Period</code> can be the index. Lists of <code>Timestamp</code> and <code>Period</code> are automatically coerce to <code>DatetimeIndex</code> and <code>PeriodIndex</code> respectively.</p> <pre data-language="python">In [12]: dates = [pd.Timestamp('2012-05-01'), pd.Timestamp('2012-05-02'), pd.Timestamp('2012-05-03')]

In [13]: ts = pd.Series(np.random.randn(3), dates)

In [14]: type(ts.index)
Out[14]: pandas.tseries.index.DatetimeIndex

In [15]: ts.index
Out[15]: DatetimeIndex(['2012-05-01', '2012-05-02', '2012-05-03'], dtype='datetime64[ns]', freq=None)

In [16]: ts
Out[16]: 
2012-05-01   -0.410001
2012-05-02   -0.078638
2012-05-03    0.545952
dtype: float64

In [17]: periods = [pd.Period('2012-01'), pd.Period('2012-02'), pd.Period('2012-03')]

In [18]: ts = pd.Series(np.random.randn(3), periods)

In [19]: type(ts.index)
Out[19]: pandas.tseries.period.PeriodIndex

In [20]: ts.index
Out[20]: PeriodIndex(['2012-01', '2012-02', '2012-03'], dtype='int64', freq='M')

In [21]: ts
Out[21]: 
2012-01   -1.219217
2012-02   -1.226825
2012-03    0.769804
Freq: M, dtype: float64
</pre> <p>pandas allows you to capture both representations and convert between them. Under the hood, pandas represents timestamps using instances of <code>Timestamp</code> and sequences of timestamps using instances of <code>DatetimeIndex</code>. For regular time spans, pandas uses <code>Period</code> objects for scalar values and <code>PeriodIndex</code> for sequences of spans. Better support for irregular intervals with arbitrary start and end points are forth-coming in future releases.</p>   <h2 id="timeseries-converting">Converting to Timestamps</h2> <p id="converting-to-timestamps">To convert a Series or list-like object of date-like objects e.g. strings, epochs, or a mixture, you can use the <code>to_datetime</code> function. When passed a Series, this returns a Series (with the same index), while a list-like is converted to a DatetimeIndex:</p> <pre data-language="python">In [22]: pd.to_datetime(pd.Series(['Jul 31, 2009', '2010-01-10', None]))
Out[22]: 
0   2009-07-31
1   2010-01-10
2          NaT
dtype: datetime64[ns]

In [23]: pd.to_datetime(['2005/11/23', '2010.12.31'])
Out[23]: DatetimeIndex(['2005-11-23', '2010-12-31'], dtype='datetime64[ns]', freq=None)
</pre> <p>If you use dates which start with the day first (i.e. European style), you can pass the <code>dayfirst</code> flag:</p> <pre data-language="python">In [24]: pd.to_datetime(['04-01-2012 10:00'], dayfirst=True)
Out[24]: DatetimeIndex(['2012-01-04 10:00:00'], dtype='datetime64[ns]', freq=None)

In [25]: pd.to_datetime(['14-01-2012', '01-14-2012'], dayfirst=True)
Out[25]: DatetimeIndex(['2012-01-14', '2012-01-14'], dtype='datetime64[ns]', freq=None)
</pre> <div class="admonition warning"> <p class="first admonition-title">Warning</p> <p class="last">You see in the above example that <code>dayfirst</code> isn’t strict, so if a date can’t be parsed with the day being first it will be parsed as if <code>dayfirst</code> were False.</p> </div> <div class="admonition note"> <p class="first admonition-title">Note</p> <p class="last">Specifying a <code>format</code> argument will potentially speed up the conversion considerably and on versions later then 0.13.0 explicitly specifying a format string of ‘%Y%m%d’ takes a faster path still.</p> </div> <p>If you pass a single string to <code>to_datetime</code>, it returns single <code>Timestamp</code>. Also, <code>Timestamp</code> can accept the string input. Note that <code>Timestamp</code> doesn’t accept string parsing option like <code>dayfirst</code> or <code>format</code>, use <code>to_datetime</code> if these are required.</p> <pre data-language="python">In [26]: pd.to_datetime('2010/11/12')
Out[26]: Timestamp('2010-11-12 00:00:00')

In [27]: pd.Timestamp('2010/11/12')
Out[27]: Timestamp('2010-11-12 00:00:00')
</pre> <div class="versionadded"> <p><span class="versionmodified">New in version 0.18.1.</span></p> </div> <p>You can also pass a <code>DataFrame</code> of integer or string columns to assemble into a <code>Series</code> of <code>Timestamps</code>.</p> <pre data-language="python">In [28]: df = pd.DataFrame({'year': [2015, 2016],
   ....:                    'month': [2, 3],
   ....:                    'day': [4, 5],
   ....:                    'hour': [2, 3]})
   ....: 

In [29]: pd.to_datetime(df)
Out[29]: 
0   2015-02-04 02:00:00
1   2016-03-05 03:00:00
dtype: datetime64[ns]
</pre> <p>You can pass only the columns that you need to assemble.</p> <pre data-language="python">In [30]: pd.to_datetime(df[['year', 'month', 'day']])
Out[30]: 
0   2015-02-04
1   2016-03-05
dtype: datetime64[ns]
</pre> <p><code>pd.to_datetime</code> looks for standard designations of the datetime component in the column names, including:</p> <ul class="simple"> <li>required: <code>year</code>, <code>month</code>, <code>day</code>
</li> <li>optional: <code>hour</code>, <code>minute</code>, <code>second</code>, <code>millisecond</code>, <code>microsecond</code>, <code>nanosecond</code>
</li> </ul>  <h3 id="invalid-data">Invalid Data</h3> <div class="admonition note"> <p class="first admonition-title">Note</p> <p class="last">In version 0.17.0, the default for <code>to_datetime</code> is now <code>errors='raise'</code>, rather than <code>errors='ignore'</code>. This means that invalid parsing will raise rather that return the original input as in previous versions.</p> </div> <p>Pass <code>errors='coerce'</code> to convert invalid data to <code>NaT</code> (not a time):</p> <p>Raise when unparseable, this is the default</p> <pre data-language="python">In [2]: pd.to_datetime(['2009/07/31', 'asd'], errors='raise')
ValueError: Unknown string format
</pre> <p>Return the original input when unparseable</p> <pre data-language="python">In [4]: pd.to_datetime(['2009/07/31', 'asd'], errors='ignore')
Out[4]: array(['2009/07/31', 'asd'], dtype=object)
</pre> <p>Return NaT for input when unparseable</p> <pre data-language="python">In [6]: pd.to_datetime(['2009/07/31', 'asd'], errors='coerce')
Out[6]: DatetimeIndex(['2009-07-31', 'NaT'], dtype='datetime64[ns]', freq=None)
</pre>   <h3 id="epoch-timestamps">Epoch Timestamps</h3> <p>It’s also possible to convert integer or float epoch times. The default unit for these is nanoseconds (since these are how <code>Timestamp</code> s are stored). However, often epochs are stored in another <code>unit</code> which can be specified:</p> <p>Typical epoch stored units</p> <pre data-language="python">In [31]: pd.to_datetime([1349720105, 1349806505, 1349892905,
   ....:                 1349979305, 1350065705], unit='s')
   ....: 
Out[31]: 
DatetimeIndex(['2012-10-08 18:15:05', '2012-10-09 18:15:05',
               '2012-10-10 18:15:05', '2012-10-11 18:15:05',
               '2012-10-12 18:15:05'],
              dtype='datetime64[ns]', freq=None)

In [32]: pd.to_datetime([1349720105100, 1349720105200, 1349720105300,
   ....:                 1349720105400, 1349720105500 ], unit='ms')
   ....: 
Out[32]: 
DatetimeIndex(['2012-10-08 18:15:05.100000', '2012-10-08 18:15:05.200000',
               '2012-10-08 18:15:05.300000', '2012-10-08 18:15:05.400000',
               '2012-10-08 18:15:05.500000'],
              dtype='datetime64[ns]', freq=None)
</pre> <p>These <em>work</em>, but the results may be unexpected.</p> <pre data-language="python">In [33]: pd.to_datetime([1])
Out[33]: DatetimeIndex(['1970-01-01 00:00:00.000000001'], dtype='datetime64[ns]', freq=None)

In [34]: pd.to_datetime([1, 3.14], unit='s')
Out[34]: DatetimeIndex(['1970-01-01 00:00:01', '1970-01-01 00:00:03'], dtype='datetime64[ns]', freq=None)
</pre> <div class="admonition note"> <p class="first admonition-title">Note</p> <p class="last">Epoch times will be rounded to the nearest nanosecond.</p> </div>    <h2 id="timeseries-daterange">Generating Ranges of Timestamps</h2> <p id="generating-ranges-of-timestamps">To generate an index with time stamps, you can use either the DatetimeIndex or Index constructor and pass in a list of datetime objects:</p> <pre data-language="python">In [35]: dates = [datetime(2012, 5, 1), datetime(2012, 5, 2), datetime(2012, 5, 3)]

# Note the frequency information
In [36]: index = pd.DatetimeIndex(dates)

In [37]: index
Out[37]: DatetimeIndex(['2012-05-01', '2012-05-02', '2012-05-03'], dtype='datetime64[ns]', freq=None)

# Automatically converted to DatetimeIndex
In [38]: index = pd.Index(dates)

In [39]: index
Out[39]: DatetimeIndex(['2012-05-01', '2012-05-02', '2012-05-03'], dtype='datetime64[ns]', freq=None)
</pre> <p>Practically, this becomes very cumbersome because we often need a very long index with a large number of timestamps. If we need timestamps on a regular frequency, we can use the pandas functions <code>date_range</code> and <code>bdate_range</code> to create timestamp indexes.</p> <pre data-language="python">In [40]: index = pd.date_range('2000-1-1', periods=1000, freq='M')

In [41]: index
Out[41]: 
DatetimeIndex(['2000-01-31', '2000-02-29', '2000-03-31', '2000-04-30',
               '2000-05-31', '2000-06-30', '2000-07-31', '2000-08-31',
               '2000-09-30', '2000-10-31',
               ...
               '2082-07-31', '2082-08-31', '2082-09-30', '2082-10-31',
               '2082-11-30', '2082-12-31', '2083-01-31', '2083-02-28',
               '2083-03-31', '2083-04-30'],
              dtype='datetime64[ns]', length=1000, freq='M')

In [42]: index = pd.bdate_range('2012-1-1', periods=250)

In [43]: index
Out[43]: 
DatetimeIndex(['2012-01-02', '2012-01-03', '2012-01-04', '2012-01-05',
               '2012-01-06', '2012-01-09', '2012-01-10', '2012-01-11',
               '2012-01-12', '2012-01-13',
               ...
               '2012-12-03', '2012-12-04', '2012-12-05', '2012-12-06',
               '2012-12-07', '2012-12-10', '2012-12-11', '2012-12-12',
               '2012-12-13', '2012-12-14'],
              dtype='datetime64[ns]', length=250, freq='B')
</pre> <p>Convenience functions like <code>date_range</code> and <code>bdate_range</code> utilize a variety of frequency aliases. The default frequency for <code>date_range</code> is a <strong>calendar day</strong> while the default for <code>bdate_range</code> is a <strong>business day</strong></p> <pre data-language="python">In [44]: start = datetime(2011, 1, 1)

In [45]: end = datetime(2012, 1, 1)

In [46]: rng = pd.date_range(start, end)

In [47]: rng
Out[47]: 
DatetimeIndex(['2011-01-01', '2011-01-02', '2011-01-03', '2011-01-04',
               '2011-01-05', '2011-01-06', '2011-01-07', '2011-01-08',
               '2011-01-09', '2011-01-10',
               ...
               '2011-12-23', '2011-12-24', '2011-12-25', '2011-12-26',
               '2011-12-27', '2011-12-28', '2011-12-29', '2011-12-30',
               '2011-12-31', '2012-01-01'],
              dtype='datetime64[ns]', length=366, freq='D')

In [48]: rng = pd.bdate_range(start, end)

In [49]: rng
Out[49]: 
DatetimeIndex(['2011-01-03', '2011-01-04', '2011-01-05', '2011-01-06',
               '2011-01-07', '2011-01-10', '2011-01-11', '2011-01-12',
               '2011-01-13', '2011-01-14',
               ...
               '2011-12-19', '2011-12-20', '2011-12-21', '2011-12-22',
               '2011-12-23', '2011-12-26', '2011-12-27', '2011-12-28',
               '2011-12-29', '2011-12-30'],
              dtype='datetime64[ns]', length=260, freq='B')
</pre> <p><code>date_range</code> and <code>bdate_range</code> make it easy to generate a range of dates using various combinations of parameters like <code>start</code>, <code>end</code>, <code>periods</code>, and <code>freq</code>:</p> <pre data-language="python">In [50]: pd.date_range(start, end, freq='BM')
Out[50]: 
DatetimeIndex(['2011-01-31', '2011-02-28', '2011-03-31', '2011-04-29',
               '2011-05-31', '2011-06-30', '2011-07-29', '2011-08-31',
               '2011-09-30', '2011-10-31', '2011-11-30', '2011-12-30'],
              dtype='datetime64[ns]', freq='BM')

In [51]: pd.date_range(start, end, freq='W')
Out[51]: 
DatetimeIndex(['2011-01-02', '2011-01-09', '2011-01-16', '2011-01-23',
               '2011-01-30', '2011-02-06', '2011-02-13', '2011-02-20',
               '2011-02-27', '2011-03-06', '2011-03-13', '2011-03-20',
               '2011-03-27', '2011-04-03', '2011-04-10', '2011-04-17',
               '2011-04-24', '2011-05-01', '2011-05-08', '2011-05-15',
               '2011-05-22', '2011-05-29', '2011-06-05', '2011-06-12',
               '2011-06-19', '2011-06-26', '2011-07-03', '2011-07-10',
               '2011-07-17', '2011-07-24', '2011-07-31', '2011-08-07',
               '2011-08-14', '2011-08-21', '2011-08-28', '2011-09-04',
               '2011-09-11', '2011-09-18', '2011-09-25', '2011-10-02',
               '2011-10-09', '2011-10-16', '2011-10-23', '2011-10-30',
               '2011-11-06', '2011-11-13', '2011-11-20', '2011-11-27',
               '2011-12-04', '2011-12-11', '2011-12-18', '2011-12-25',
               '2012-01-01'],
              dtype='datetime64[ns]', freq='W-SUN')

In [52]: pd.bdate_range(end=end, periods=20)
Out[52]: 
DatetimeIndex(['2011-12-05', '2011-12-06', '2011-12-07', '2011-12-08',
               '2011-12-09', '2011-12-12', '2011-12-13', '2011-12-14',
               '2011-12-15', '2011-12-16', '2011-12-19', '2011-12-20',
               '2011-12-21', '2011-12-22', '2011-12-23', '2011-12-26',
               '2011-12-27', '2011-12-28', '2011-12-29', '2011-12-30'],
              dtype='datetime64[ns]', freq='B')

In [53]: pd.bdate_range(start=start, periods=20)
Out[53]: 
DatetimeIndex(['2011-01-03', '2011-01-04', '2011-01-05', '2011-01-06',
               '2011-01-07', '2011-01-10', '2011-01-11', '2011-01-12',
               '2011-01-13', '2011-01-14', '2011-01-17', '2011-01-18',
               '2011-01-19', '2011-01-20', '2011-01-21', '2011-01-24',
               '2011-01-25', '2011-01-26', '2011-01-27', '2011-01-28'],
              dtype='datetime64[ns]', freq='B')
</pre> <p>The start and end dates are strictly inclusive. So it will not generate any dates outside of those dates if specified.</p>   <h2 id="timeseries-timestamp-limits">Timestamp limitations</h2> <p id="timestamp-limitations">Since pandas represents timestamps in nanosecond resolution, the timespan that can be represented using a 64-bit integer is limited to approximately 584 years:</p> <pre data-language="python">In [54]: pd.Timestamp.min
Out[54]: Timestamp('1677-09-22 00:12:43.145225')

In [55]: pd.Timestamp.max
Out[55]: Timestamp('2262-04-11 23:47:16.854775807')
</pre> <p>See <a class="reference internal" href="#timeseries-oob">here</a> for ways to represent data outside these bound.</p>   <h2 id="timeseries-datetimeindex">DatetimeIndex</h2> <p id="datetimeindex">One of the main uses for <code>DatetimeIndex</code> is as an index for pandas objects. The <code>DatetimeIndex</code> class contains many timeseries related optimizations:</p>  <ul class="simple"> <li>A large range of dates for various offsets are pre-computed and cached under the hood in order to make generating subsequent date ranges very fast (just have to grab a slice)</li> <li>Fast shifting using the <code>shift</code> and <code>tshift</code> method on pandas objects</li> <li>Unioning of overlapping DatetimeIndex objects with the same frequency is very fast (important for fast data alignment)</li> <li>Quick access to date fields via properties such as <code>year</code>, <code>month</code>, etc.</li> <li>Regularization functions like <code>snap</code> and very fast <code>asof</code> logic</li> </ul>  <p>DatetimeIndex objects has all the basic functionality of regular Index objects and a smorgasbord of advanced timeseries-specific methods for easy frequency processing.</p> <div class="admonition seealso"> <p class="first admonition-title">See also</p> <p class="last"><a class="reference internal" href="../basics/#basics-reindexing">Reindexing methods</a></p> </div> <div class="admonition note"> <p class="first admonition-title">Note</p> <p class="last">While pandas does not force you to have a sorted date index, some of these methods may have unexpected or incorrect behavior if the dates are unsorted. So please be careful.</p> </div> <p><code>DatetimeIndex</code> can be used like a regular index and offers all of its intelligent functionality like selection, slicing, etc.</p> <pre data-language="python">In [56]: rng = pd.date_range(start, end, freq='BM')

In [57]: ts = pd.Series(np.random.randn(len(rng)), index=rng)

In [58]: ts.index
Out[58]: 
DatetimeIndex(['2011-01-31', '2011-02-28', '2011-03-31', '2011-04-29',
               '2011-05-31', '2011-06-30', '2011-07-29', '2011-08-31',
               '2011-09-30', '2011-10-31', '2011-11-30', '2011-12-30'],
              dtype='datetime64[ns]', freq='BM')

In [59]: ts[:5].index
Out[59]: 
DatetimeIndex(['2011-01-31', '2011-02-28', '2011-03-31', '2011-04-29',
               '2011-05-31'],
              dtype='datetime64[ns]', freq='BM')

In [60]: ts[::2].index
Out[60]: 
DatetimeIndex(['2011-01-31', '2011-03-31', '2011-05-31', '2011-07-29',
               '2011-09-30', '2011-11-30'],
              dtype='datetime64[ns]', freq='2BM')
</pre>  <h3 id="timeseries-partialindexing">DatetimeIndex Partial String Indexing</h3> <p id="datetimeindex-partial-string-indexing">You can pass in dates and strings that parse to dates as indexing parameters:</p> <pre data-language="python">In [61]: ts['1/31/2011']
Out[61]: -1.2812473076599531

In [62]: ts[datetime(2011, 12, 25):]
Out[62]: 
2011-12-30    0.687738
Freq: BM, dtype: float64

In [63]: ts['10/31/2011':'12/31/2011']
Out[63]: 
2011-10-31    0.149748
2011-11-30   -0.732339
2011-12-30    0.687738
Freq: BM, dtype: float64
</pre> <p>To provide convenience for accessing longer time series, you can also pass in the year or year and month as strings:</p> <pre data-language="python">In [64]: ts['2011']
Out[64]: 
2011-01-31   -1.281247
2011-02-28   -0.727707
2011-03-31   -0.121306
2011-04-29   -0.097883
2011-05-31    0.695775
2011-06-30    0.341734
2011-07-29    0.959726
2011-08-31   -1.110336
2011-09-30   -0.619976
2011-10-31    0.149748
2011-11-30   -0.732339
2011-12-30    0.687738
Freq: BM, dtype: float64

In [65]: ts['2011-6']
Out[65]: 
2011-06-30    0.341734
Freq: BM, dtype: float64
</pre> <p>This type of slicing will work on a DataFrame with a <code>DateTimeIndex</code> as well. Since the partial string selection is a form of label slicing, the endpoints <strong>will be</strong> included. This would include matching times on an included date. Here’s an example:</p> <pre data-language="python">In [66]: dft = pd.DataFrame(randn(100000,1),
   ....:                    columns=['A'],
   ....:                    index=pd.date_range('20130101',periods=100000,freq='T'))
   ....: 

In [67]: dft
Out[67]: 
                            A
2013-01-01 00:00:00  0.176444
2013-01-01 00:01:00  0.403310
2013-01-01 00:02:00 -0.154951
2013-01-01 00:03:00  0.301624
2013-01-01 00:04:00 -2.179861
2013-01-01 00:05:00 -1.369849
2013-01-01 00:06:00 -0.954208
...                       ...
2013-03-11 10:33:00 -0.293083
2013-03-11 10:34:00 -0.059881
2013-03-11 10:35:00  1.252450
2013-03-11 10:36:00  0.046611
2013-03-11 10:37:00  0.059478
2013-03-11 10:38:00 -0.286539
2013-03-11 10:39:00  0.841669

[100000 rows x 1 columns]

In [68]: dft['2013']
Out[68]: 
                            A
2013-01-01 00:00:00  0.176444
2013-01-01 00:01:00  0.403310
2013-01-01 00:02:00 -0.154951
2013-01-01 00:03:00  0.301624
2013-01-01 00:04:00 -2.179861
2013-01-01 00:05:00 -1.369849
2013-01-01 00:06:00 -0.954208
...                       ...
2013-03-11 10:33:00 -0.293083
2013-03-11 10:34:00 -0.059881
2013-03-11 10:35:00  1.252450
2013-03-11 10:36:00  0.046611
2013-03-11 10:37:00  0.059478
2013-03-11 10:38:00 -0.286539
2013-03-11 10:39:00  0.841669

[100000 rows x 1 columns]
</pre> <p>This starts on the very first time in the month, and includes the last date &amp; time for the month</p> <pre data-language="python">In [69]: dft['2013-1':'2013-2']
Out[69]: 
                            A
2013-01-01 00:00:00  0.176444
2013-01-01 00:01:00  0.403310
2013-01-01 00:02:00 -0.154951
2013-01-01 00:03:00  0.301624
2013-01-01 00:04:00 -2.179861
2013-01-01 00:05:00 -1.369849
2013-01-01 00:06:00 -0.954208
...                       ...
2013-02-28 23:53:00  0.103114
2013-02-28 23:54:00 -1.303422
2013-02-28 23:55:00  0.451943
2013-02-28 23:56:00  0.220534
2013-02-28 23:57:00 -1.624220
2013-02-28 23:58:00  0.093915
2013-02-28 23:59:00 -1.087454

[84960 rows x 1 columns]
</pre> <p>This specifies a stop time <strong>that includes all of the times on the last day</strong></p> <pre data-language="python">In [70]: dft['2013-1':'2013-2-28']
Out[70]: 
                            A
2013-01-01 00:00:00  0.176444
2013-01-01 00:01:00  0.403310
2013-01-01 00:02:00 -0.154951
2013-01-01 00:03:00  0.301624
2013-01-01 00:04:00 -2.179861
2013-01-01 00:05:00 -1.369849
2013-01-01 00:06:00 -0.954208
...                       ...
2013-02-28 23:53:00  0.103114
2013-02-28 23:54:00 -1.303422
2013-02-28 23:55:00  0.451943
2013-02-28 23:56:00  0.220534
2013-02-28 23:57:00 -1.624220
2013-02-28 23:58:00  0.093915
2013-02-28 23:59:00 -1.087454

[84960 rows x 1 columns]
</pre> <p>This specifies an <strong>exact</strong> stop time (and is not the same as the above)</p> <pre data-language="python">In [71]: dft['2013-1':'2013-2-28 00:00:00']
Out[71]: 
                            A
2013-01-01 00:00:00  0.176444
2013-01-01 00:01:00  0.403310
2013-01-01 00:02:00 -0.154951
2013-01-01 00:03:00  0.301624
2013-01-01 00:04:00 -2.179861
2013-01-01 00:05:00 -1.369849
2013-01-01 00:06:00 -0.954208
...                       ...
2013-02-27 23:54:00  0.897051
2013-02-27 23:55:00 -0.309230
2013-02-27 23:56:00  1.944713
2013-02-27 23:57:00  0.369265
2013-02-27 23:58:00  0.053071
2013-02-27 23:59:00 -0.019734
2013-02-28 00:00:00  1.388189

[83521 rows x 1 columns]
</pre> <p>We are stopping on the included end-point as it is part of the index</p> <pre data-language="python">In [72]: dft['2013-1-15':'2013-1-15 12:30:00']
Out[72]: 
                            A
2013-01-15 00:00:00  0.501288
2013-01-15 00:01:00 -0.605198
2013-01-15 00:02:00  0.215146
2013-01-15 00:03:00  0.924732
2013-01-15 00:04:00 -2.228519
2013-01-15 00:05:00  1.517331
2013-01-15 00:06:00 -1.188774
...                       ...
2013-01-15 12:24:00  1.358314
2013-01-15 12:25:00 -0.737727
2013-01-15 12:26:00  1.838323
2013-01-15 12:27:00 -0.774090
2013-01-15 12:28:00  0.622261
2013-01-15 12:29:00 -0.631649
2013-01-15 12:30:00  0.193284

[751 rows x 1 columns]
</pre> <div class="admonition warning"> <p class="first admonition-title">Warning</p> <p>The following selection will raise a <code>KeyError</code>; otherwise this selection methodology would be inconsistent with other selection methods in pandas (as this is not a <em>slice</em>, nor does it resolve to one)</p> <pre data-language="python">dft['2013-1-15 12:30:00']
</pre> <p>To select a single row, use <code>.loc</code></p> <pre data-language="python">In [73]: dft.loc['2013-1-15 12:30:00']
Out[73]: 
A    0.193284
Name: 2013-01-15 12:30:00, dtype: float64
</pre> </div> <div class="versionadded"> <p><span class="versionmodified">New in version 0.18.0.</span></p> </div> <p>DatetimeIndex Partial String Indexing also works on DataFrames with a <code>MultiIndex</code>. For example:</p> <pre data-language="python">In [74]: dft2 = pd.DataFrame(np.random.randn(20, 1),
   ....:                     columns=['A'],
   ....:                     index=pd.MultiIndex.from_product([pd.date_range('20130101',
   ....:                                                                     periods=10,
   ....:                                                                     freq='12H'),
   ....:                                                      ['a', 'b']]))
   ....: 

In [75]: dft2
Out[75]: 
                              A
2013-01-01 00:00:00 a -0.659574
                    b  1.494522
2013-01-01 12:00:00 a -0.778425
                    b -0.253355
2013-01-02 00:00:00 a -2.816159
                    b -1.210929
2013-01-02 12:00:00 a  0.144669
...                         ...
2013-01-04 00:00:00 b -1.624463
2013-01-04 12:00:00 a  0.056912
                    b  0.149867
2013-01-05 00:00:00 a -1.256173
                    b  2.324544
2013-01-05 12:00:00 a -1.067396
                    b -0.660996

[20 rows x 1 columns]

In [76]: dft2.loc['2013-01-05']
Out[76]: 
                              A
2013-01-05 00:00:00 a -1.256173
                    b  2.324544
2013-01-05 12:00:00 a -1.067396
                    b -0.660996

In [77]: idx = pd.IndexSlice

In [78]: dft2 = dft2.swaplevel(0, 1).sort_index()

In [79]: dft2.loc[idx[:, '2013-01-05'], :]
Out[79]: 
                              A
a 2013-01-05 00:00:00 -1.256173
  2013-01-05 12:00:00 -1.067396
b 2013-01-05 00:00:00  2.324544
  2013-01-05 12:00:00 -0.660996
</pre>   <h3 id="datetime-indexing">Datetime Indexing</h3> <p>Indexing a <code>DateTimeIndex</code> with a partial string depends on the “accuracy” of the period, in other words how specific the interval is in relation to the frequency of the index. In contrast, indexing with datetime objects is exact, because the objects have exact meaning. These also follow the semantics of <em>including both endpoints</em>.</p> <p>These <code>datetime</code> objects are specific <code>hours, minutes,</code> and <code>seconds</code> even though they were not explicitly specified (they are <code>0</code>).</p> <pre data-language="python">In [80]: dft[datetime(2013, 1, 1):datetime(2013,2,28)]
Out[80]: 
                            A
2013-01-01 00:00:00  0.176444
2013-01-01 00:01:00  0.403310
2013-01-01 00:02:00 -0.154951
2013-01-01 00:03:00  0.301624
2013-01-01 00:04:00 -2.179861
2013-01-01 00:05:00 -1.369849
2013-01-01 00:06:00 -0.954208
...                       ...
2013-02-27 23:54:00  0.897051
2013-02-27 23:55:00 -0.309230
2013-02-27 23:56:00  1.944713
2013-02-27 23:57:00  0.369265
2013-02-27 23:58:00  0.053071
2013-02-27 23:59:00 -0.019734
2013-02-28 00:00:00  1.388189

[83521 rows x 1 columns]
</pre> <p>With no defaults.</p> <pre data-language="python">In [81]: dft[datetime(2013, 1, 1, 10, 12, 0):datetime(2013, 2, 28, 10, 12, 0)]
Out[81]: 
                            A
2013-01-01 10:12:00 -0.246733
2013-01-01 10:13:00 -1.429225
2013-01-01 10:14:00 -1.265339
2013-01-01 10:15:00  0.710986
2013-01-01 10:16:00 -0.818200
2013-01-01 10:17:00  0.543542
2013-01-01 10:18:00  1.577713
...                       ...
2013-02-28 10:06:00  0.311249
2013-02-28 10:07:00  2.366080
2013-02-28 10:08:00 -0.490372
2013-02-28 10:09:00  0.373340
2013-02-28 10:10:00  0.638442
2013-02-28 10:11:00  1.330135
2013-02-28 10:12:00 -0.945450

[83521 rows x 1 columns]
</pre>   <h3 id="truncating-fancy-indexing">Truncating &amp; Fancy Indexing</h3> <p>A <code>truncate</code> convenience function is provided that is equivalent to slicing:</p> <pre data-language="python">In [82]: ts.truncate(before='10/31/2011', after='12/31/2011')
Out[82]: 
2011-10-31    0.149748
2011-11-30   -0.732339
2011-12-30    0.687738
Freq: BM, dtype: float64
</pre> <p>Even complicated fancy indexing that breaks the DatetimeIndex’s frequency regularity will result in a <code>DatetimeIndex</code> (but frequency is lost):</p> <pre data-language="python">In [83]: ts[[0, 2, 6]].index
Out[83]: DatetimeIndex(['2011-01-31', '2011-03-31', '2011-07-29'], dtype='datetime64[ns]', freq=None)
</pre>   <h3 id="timeseries-offsets">Time/Date Components</h3> <p id="time-date-components">There are several time/date properties that one can access from <code>Timestamp</code> or a collection of timestamps like a <code>DateTimeIndex</code>.</p> <table class="docutils">  <thead valign="bottom"> <tr class="row-odd">
<th class="head">Property</th> <th class="head">Description</th> </tr> </thead>  <tr class="row-even">
<td>year</td> <td>The year of the datetime</td> </tr> <tr class="row-odd">
<td>month</td> <td>The month of the datetime</td> </tr> <tr class="row-even">
<td>day</td> <td>The days of the datetime</td> </tr> <tr class="row-odd">
<td>hour</td> <td>The hour of the datetime</td> </tr> <tr class="row-even">
<td>minute</td> <td>The minutes of the datetime</td> </tr> <tr class="row-odd">
<td>second</td> <td>The seconds of the datetime</td> </tr> <tr class="row-even">
<td>microsecond</td> <td>The microseconds of the datetime</td> </tr> <tr class="row-odd">
<td>nanosecond</td> <td>The nanoseconds of the datetime</td> </tr> <tr class="row-even">
<td>date</td> <td>Returns datetime.date</td> </tr> <tr class="row-odd">
<td>time</td> <td>Returns datetime.time</td> </tr> <tr class="row-even">
<td>dayofyear</td> <td>The ordinal day of year</td> </tr> <tr class="row-odd">
<td>weekofyear</td> <td>The week ordinal of the year</td> </tr> <tr class="row-even">
<td>week</td> <td>The week ordinal of the year</td> </tr> <tr class="row-odd">
<td>dayofweek</td> <td>The numer of the day of the week with Monday=0, Sunday=6</td> </tr> <tr class="row-even">
<td>weekday</td> <td>The number of the day of the week with Monday=0, Sunday=6</td> </tr> <tr class="row-odd">
<td>weekday_name</td> <td>The name of the day in a week (ex: Friday)</td> </tr> <tr class="row-even">
<td>quarter</td> <td>Quarter of the date: Jan=Mar = 1, Apr-Jun = 2, etc.</td> </tr> <tr class="row-odd">
<td>days_in_month</td> <td>The number of days in the month of the datetime</td> </tr> <tr class="row-even">
<td>is_month_start</td> <td>Logical indicating if first day of month (defined by frequency)</td> </tr> <tr class="row-odd">
<td>is_month_end</td> <td>Logical indicating if last day of month (defined by frequency)</td> </tr> <tr class="row-even">
<td>is_quarter_start</td> <td>Logical indicating if first day of quarter (defined by frequency)</td> </tr> <tr class="row-odd">
<td>is_quarter_end</td> <td>Logical indicating if last day of quarter (defined by frequency)</td> </tr> <tr class="row-even">
<td>is_year_start</td> <td>Logical indicating if first day of year (defined by frequency)</td> </tr> <tr class="row-odd">
<td>is_year_end</td> <td>Logical indicating if last day of year (defined by frequency)</td> </tr>  </table> <p>Furthermore, if you have a <code>Series</code> with datetimelike values, then you can access these properties via the <code>.dt</code> accessor, see the <a class="reference internal" href="../basics/#basics-dt-accessors">docs</a></p>    <h2 id="dateoffset-objects">DateOffset objects</h2> <p>In the preceding examples, we created DatetimeIndex objects at various frequencies by passing in frequency strings like ‘M’, ‘W’, and ‘BM to the <code>freq</code> keyword. Under the hood, these frequency strings are being translated into an instance of pandas <code>DateOffset</code>, which represents a regular frequency increment. Specific offset logic like “month”, “business day”, or “one hour” is represented in its various subclasses.</p> <table class="docutils">  <thead valign="bottom"> <tr class="row-odd">
<th class="head">Class name</th> <th class="head">Description</th> </tr> </thead>  <tr class="row-even">
<td>DateOffset</td> <td>Generic offset class, defaults to 1 calendar day</td> </tr> <tr class="row-odd">
<td>BDay</td> <td>business day (weekday)</td> </tr> <tr class="row-even">
<td>CDay</td> <td>custom business day (experimental)</td> </tr> <tr class="row-odd">
<td>Week</td> <td>one week, optionally anchored on a day of the week</td> </tr> <tr class="row-even">
<td>WeekOfMonth</td> <td>the x-th day of the y-th week of each month</td> </tr> <tr class="row-odd">
<td>LastWeekOfMonth</td> <td>the x-th day of the last week of each month</td> </tr> <tr class="row-even">
<td>MonthEnd</td> <td>calendar month end</td> </tr> <tr class="row-odd">
<td>MonthBegin</td> <td>calendar month begin</td> </tr> <tr class="row-even">
<td>BMonthEnd</td> <td>business month end</td> </tr> <tr class="row-odd">
<td>BMonthBegin</td> <td>business month begin</td> </tr> <tr class="row-even">
<td>CBMonthEnd</td> <td>custom business month end</td> </tr> <tr class="row-odd">
<td>CBMonthBegin</td> <td>custom business month begin</td> </tr> <tr class="row-even">
<td>QuarterEnd</td> <td>calendar quarter end</td> </tr> <tr class="row-odd">
<td>QuarterBegin</td> <td>calendar quarter begin</td> </tr> <tr class="row-even">
<td>BQuarterEnd</td> <td>business quarter end</td> </tr> <tr class="row-odd">
<td>BQuarterBegin</td> <td>business quarter begin</td> </tr> <tr class="row-even">
<td>FY5253Quarter</td> <td>retail (aka 52-53 week) quarter</td> </tr> <tr class="row-odd">
<td>YearEnd</td> <td>calendar year end</td> </tr> <tr class="row-even">
<td>YearBegin</td> <td>calendar year begin</td> </tr> <tr class="row-odd">
<td>BYearEnd</td> <td>business year end</td> </tr> <tr class="row-even">
<td>BYearBegin</td> <td>business year begin</td> </tr> <tr class="row-odd">
<td>FY5253</td> <td>retail (aka 52-53 week) year</td> </tr> <tr class="row-even">
<td>BusinessHour</td> <td>business hour</td> </tr> <tr class="row-odd">
<td>CustomBusinessHour</td> <td>custom business hour</td> </tr> <tr class="row-even">
<td>Hour</td> <td>one hour</td> </tr> <tr class="row-odd">
<td>Minute</td> <td>one minute</td> </tr> <tr class="row-even">
<td>Second</td> <td>one second</td> </tr> <tr class="row-odd">
<td>Milli</td> <td>one millisecond</td> </tr> <tr class="row-even">
<td>Micro</td> <td>one microsecond</td> </tr> <tr class="row-odd">
<td>Nano</td> <td>one nanosecond</td> </tr>  </table> <p>The basic <code>DateOffset</code> takes the same arguments as <code>dateutil.relativedelta</code>, which works like:</p> <pre data-language="python">In [84]: d = datetime(2008, 8, 18, 9, 0)

In [85]: d + relativedelta(months=4, days=5)
Out[85]: datetime.datetime(2008, 12, 23, 9, 0)
</pre> <p>We could have done the same thing with <code>DateOffset</code>:</p> <pre data-language="python">In [86]: from pandas.tseries.offsets import *

In [87]: d + DateOffset(months=4, days=5)
Out[87]: Timestamp('2008-12-23 09:00:00')
</pre> <p>The key features of a <code>DateOffset</code> object are:</p>  <ul class="simple"> <li>it can be added / subtracted to/from a datetime object to obtain a shifted date</li> <li>it can be multiplied by an integer (positive or negative) so that the increment will be applied multiple times</li> <li>it has <code>rollforward</code> and <code>rollback</code> methods for moving a date forward or backward to the next or previous “offset date”</li> </ul>  <p>Subclasses of <code>DateOffset</code> define the <code>apply</code> function which dictates custom date increment logic, such as adding business days:</p> <pre data-language="python">class BDay(DateOffset):
    """DateOffset increments between business days"""
    def apply(self, other):
        ...
</pre> <pre data-language="python">In [88]: d - 5 * BDay()
Out[88]: Timestamp('2008-08-11 09:00:00')

In [89]: d + BMonthEnd()
Out[89]: Timestamp('2008-08-29 09:00:00')
</pre> <p>The <code>rollforward</code> and <code>rollback</code> methods do exactly what you would expect:</p> <pre data-language="python">In [90]: d
Out[90]: datetime.datetime(2008, 8, 18, 9, 0)

In [91]: offset = BMonthEnd()

In [92]: offset.rollforward(d)
Out[92]: Timestamp('2008-08-29 09:00:00')

In [93]: offset.rollback(d)
Out[93]: Timestamp('2008-07-31 09:00:00')
</pre> <p>It’s definitely worth exploring the <code>pandas.tseries.offsets</code> module and the various docstrings for the classes.</p> <p>These operations (<code>apply</code>, <code>rollforward</code> and <code>rollback</code>) preserves time (hour, minute, etc) information by default. To reset time, use <code>normalize=True</code> keyword when creating the offset instance. If <code>normalize=True</code>, result is normalized after the function is applied.</p> <pre data-language="python">In [94]: day = Day()

In [95]: day.apply(pd.Timestamp('2014-01-01 09:00'))
Out[95]: Timestamp('2014-01-02 09:00:00')

In [96]: day = Day(normalize=True)

In [97]: day.apply(pd.Timestamp('2014-01-01 09:00'))
Out[97]: Timestamp('2014-01-02 00:00:00')

In [98]: hour = Hour()

In [99]: hour.apply(pd.Timestamp('2014-01-01 22:00'))
Out[99]: Timestamp('2014-01-01 23:00:00')

In [100]: hour = Hour(normalize=True)

In [101]: hour.apply(pd.Timestamp('2014-01-01 22:00'))
Out[101]: Timestamp('2014-01-01 00:00:00')

In [102]: hour.apply(pd.Timestamp('2014-01-01 23:00'))
Out[102]: Timestamp('2014-01-02 00:00:00')
</pre>  <h3 id="parametric-offsets">Parametric offsets</h3> <p>Some of the offsets can be “parameterized” when created to result in different behaviors. For example, the <code>Week</code> offset for generating weekly data accepts a <code>weekday</code> parameter which results in the generated dates always lying on a particular day of the week:</p> <pre data-language="python">In [103]: d
Out[103]: datetime.datetime(2008, 8, 18, 9, 0)

In [104]: d + Week()
Out[104]: Timestamp('2008-08-25 09:00:00')

In [105]: d + Week(weekday=4)
Out[105]: Timestamp('2008-08-22 09:00:00')

In [106]: (d + Week(weekday=4)).weekday()
Out[106]: 4

In [107]: d - Week()
Out[107]: Timestamp('2008-08-11 09:00:00')
</pre> <p><code>normalize</code> option will be effective for addition and subtraction.</p> <pre data-language="python">In [108]: d + Week(normalize=True)
Out[108]: Timestamp('2008-08-25 00:00:00')

In [109]: d - Week(normalize=True)
Out[109]: Timestamp('2008-08-11 00:00:00')
</pre> <p>Another example is parameterizing <code>YearEnd</code> with the specific ending month:</p> <pre data-language="python">In [110]: d + YearEnd()
Out[110]: Timestamp('2008-12-31 09:00:00')

In [111]: d + YearEnd(month=6)
Out[111]: Timestamp('2009-06-30 09:00:00')
</pre>   <h3 id="timeseries-offsetseries">Using offsets with <code>Series</code> / <code>DatetimeIndex</code>
</h3> <p id="using-offsets-with-series-datetimeindex">Offsets can be used with either a <code>Series</code> or <code>DatetimeIndex</code> to apply the offset to each element.</p> <pre data-language="python">In [112]: rng = pd.date_range('2012-01-01', '2012-01-03')

In [113]: s = pd.Series(rng)

In [114]: rng
Out[114]: DatetimeIndex(['2012-01-01', '2012-01-02', '2012-01-03'], dtype='datetime64[ns]', freq='D')

In [115]: rng + DateOffset(months=2)
Out[115]: DatetimeIndex(['2012-03-01', '2012-03-02', '2012-03-03'], dtype='datetime64[ns]', freq='D')

In [116]: s + DateOffset(months=2)
Out[116]: 
0   2012-03-01
1   2012-03-02
2   2012-03-03
dtype: datetime64[ns]

In [117]: s - DateOffset(months=2)
Out[117]: 
0   2011-11-01
1   2011-11-02
2   2011-11-03
dtype: datetime64[ns]
</pre> <p>If the offset class maps directly to a <code>Timedelta</code> (<code>Day</code>, <code>Hour</code>, <code>Minute</code>, <code>Second</code>, <code>Micro</code>, <code>Milli</code>, <code>Nano</code>) it can be used exactly like a <code>Timedelta</code> - see the <a class="reference internal" href="../timedeltas/#timedeltas-operations">Timedelta section</a> for more examples.</p> <pre data-language="python">In [118]: s - Day(2)
Out[118]: 
0   2011-12-30
1   2011-12-31
2   2012-01-01
dtype: datetime64[ns]

In [119]: td = s - pd.Series(pd.date_range('2011-12-29', '2011-12-31'))

In [120]: td
Out[120]: 
0   3 days
1   3 days
2   3 days
dtype: timedelta64[ns]

In [121]: td + Minute(15)
Out[121]: 
0   3 days 00:15:00
1   3 days 00:15:00
2   3 days 00:15:00
dtype: timedelta64[ns]
</pre> <p>Note that some offsets (such as <code>BQuarterEnd</code>) do not have a vectorized implementation. They can still be used but may calculate significantly slower and will raise a <code>PerformanceWarning</code></p> <pre data-language="python">In [122]: rng + BQuarterEnd()
Out[122]: DatetimeIndex(['2012-03-30', '2012-03-30', '2012-03-30'], dtype='datetime64[ns]', freq=None)
</pre>   <h3 id="timeseries-alias">Custom Business Days (Experimental)</h3> <p id="custom-business-days-experimental">The <code>CDay</code> or <code>CustomBusinessDay</code> class provides a parametric <code>BusinessDay</code> class which can be used to create customized business day calendars which account for local holidays and local weekend conventions.</p> <p>As an interesting example, let’s look at Egypt where a Friday-Saturday weekend is observed.</p> <pre data-language="python">In [123]: from pandas.tseries.offsets import CustomBusinessDay

In [124]: weekmask_egypt = 'Sun Mon Tue Wed Thu'

# They also observe International Workers' Day so let's
# add that for a couple of years
In [125]: holidays = ['2012-05-01', datetime(2013, 5, 1), np.datetime64('2014-05-01')]

In [126]: bday_egypt = CustomBusinessDay(holidays=holidays, weekmask=weekmask_egypt)

In [127]: dt = datetime(2013, 4, 30)

In [128]: dt + 2 * bday_egypt
Out[128]: Timestamp('2013-05-05 00:00:00')
</pre> <p>Let’s map to the weekday names</p> <pre data-language="python">In [129]: dts = pd.date_range(dt, periods=5, freq=bday_egypt)

In [130]: pd.Series(dts.weekday, dts).map(pd.Series('Mon Tue Wed Thu Fri Sat Sun'.split()))
Out[130]: 
2013-04-30    Tue
2013-05-02    Thu
2013-05-05    Sun
2013-05-06    Mon
2013-05-07    Tue
Freq: C, dtype: object
</pre> <p>As of v0.14 holiday calendars can be used to provide the list of holidays. See the <a class="reference internal" href="#timeseries-holiday">holiday calendar</a> section for more information.</p> <pre data-language="python">In [131]: from pandas.tseries.holiday import USFederalHolidayCalendar

In [132]: bday_us = CustomBusinessDay(calendar=USFederalHolidayCalendar())

# Friday before MLK Day
In [133]: dt = datetime(2014, 1, 17)

# Tuesday after MLK Day (Monday is skipped because it's a holiday)
In [134]: dt + bday_us
Out[134]: Timestamp('2014-01-21 00:00:00')
</pre> <p>Monthly offsets that respect a certain holiday calendar can be defined in the usual way.</p> <pre data-language="python">In [135]: from pandas.tseries.offsets import CustomBusinessMonthBegin

In [136]: bmth_us = CustomBusinessMonthBegin(calendar=USFederalHolidayCalendar())

# Skip new years
In [137]: dt = datetime(2013, 12, 17)

In [138]: dt + bmth_us
Out[138]: Timestamp('2014-01-02 00:00:00')

# Define date index with custom offset
In [139]: pd.DatetimeIndex(start='20100101',end='20120101',freq=bmth_us)
Out[139]: 
DatetimeIndex(['2010-01-04', '2010-02-01', '2010-03-01', '2010-04-01',
               '2010-05-03', '2010-06-01', '2010-07-01', '2010-08-02',
               '2010-09-01', '2010-10-01', '2010-11-01', '2010-12-01',
               '2011-01-03', '2011-02-01', '2011-03-01', '2011-04-01',
               '2011-05-02', '2011-06-01', '2011-07-01', '2011-08-01',
               '2011-09-01', '2011-10-03', '2011-11-01', '2011-12-01'],
              dtype='datetime64[ns]', freq='CBMS')
</pre> <div class="admonition note"> <p class="first admonition-title">Note</p> <p class="last">The frequency string ‘C’ is used to indicate that a CustomBusinessDay DateOffset is used, it is important to note that since CustomBusinessDay is a parameterised type, instances of CustomBusinessDay may differ and this is not detectable from the ‘C’ frequency string. The user therefore needs to ensure that the ‘C’ frequency string is used consistently within the user’s application.</p> </div>   <h3 id="timeseries-businesshour">Business Hour</h3> <p id="business-hour">The <code>BusinessHour</code> class provides a business hour representation on <code>BusinessDay</code>, allowing to use specific start and end times.</p> <p>By default, <code>BusinessHour</code> uses 9:00 - 17:00 as business hours. Adding <code>BusinessHour</code> will increment <code>Timestamp</code> by hourly. If target <code>Timestamp</code> is out of business hours, move to the next business hour then increment it. If the result exceeds the business hours end, remaining is added to the next business day.</p> <pre data-language="python">In [140]: bh = BusinessHour()

In [141]: bh
Out[141]: &lt;BusinessHour: BH=09:00-17:00&gt;

# 2014-08-01 is Friday
In [142]: pd.Timestamp('2014-08-01 10:00').weekday()
Out[142]: 4

In [143]: pd.Timestamp('2014-08-01 10:00') + bh
Out[143]: Timestamp('2014-08-01 11:00:00')

# Below example is the same as: pd.Timestamp('2014-08-01 09:00') + bh
In [144]: pd.Timestamp('2014-08-01 08:00') + bh
Out[144]: Timestamp('2014-08-01 10:00:00')

# If the results is on the end time, move to the next business day
In [145]: pd.Timestamp('2014-08-01 16:00') + bh
Out[145]: Timestamp('2014-08-04 09:00:00')

# Remainings are added to the next day
In [146]: pd.Timestamp('2014-08-01 16:30') + bh
Out[146]: Timestamp('2014-08-04 09:30:00')

# Adding 2 business hours
In [147]: pd.Timestamp('2014-08-01 10:00') + BusinessHour(2)
Out[147]: Timestamp('2014-08-01 12:00:00')

# Subtracting 3 business hours
In [148]: pd.Timestamp('2014-08-01 10:00') + BusinessHour(-3)
Out[148]: Timestamp('2014-07-31 15:00:00')
</pre> <p>Also, you can specify <code>start</code> and <code>end</code> time by keywords. Argument must be <code>str</code> which has <code>hour:minute</code> representation or <code>datetime.time</code> instance. Specifying seconds, microseconds and nanoseconds as business hour results in <code>ValueError</code>.</p> <pre data-language="python">In [149]: bh = BusinessHour(start='11:00', end=time(20, 0))

In [150]: bh
Out[150]: &lt;BusinessHour: BH=11:00-20:00&gt;

In [151]: pd.Timestamp('2014-08-01 13:00') + bh
Out[151]: Timestamp('2014-08-01 14:00:00')

In [152]: pd.Timestamp('2014-08-01 09:00') + bh
Out[152]: Timestamp('2014-08-01 12:00:00')

In [153]: pd.Timestamp('2014-08-01 18:00') + bh
Out[153]: Timestamp('2014-08-01 19:00:00')
</pre> <p>Passing <code>start</code> time later than <code>end</code> represents midnight business hour. In this case, business hour exceeds midnight and overlap to the next day. Valid business hours are distinguished by whether it started from valid <code>BusinessDay</code>.</p> <pre data-language="python">In [154]: bh = BusinessHour(start='17:00', end='09:00')

In [155]: bh
Out[155]: &lt;BusinessHour: BH=17:00-09:00&gt;

In [156]: pd.Timestamp('2014-08-01 17:00') + bh
Out[156]: Timestamp('2014-08-01 18:00:00')

In [157]: pd.Timestamp('2014-08-01 23:00') + bh
Out[157]: Timestamp('2014-08-02 00:00:00')

# Although 2014-08-02 is Satuaday,
# it is valid because it starts from 08-01 (Friday).
In [158]: pd.Timestamp('2014-08-02 04:00') + bh
Out[158]: Timestamp('2014-08-02 05:00:00')

# Although 2014-08-04 is Monday,
# it is out of business hours because it starts from 08-03 (Sunday).
In [159]: pd.Timestamp('2014-08-04 04:00') + bh
Out[159]: Timestamp('2014-08-04 18:00:00')
</pre> <p>Applying <code>BusinessHour.rollforward</code> and <code>rollback</code> to out of business hours results in the next business hour start or previous day’s end. Different from other offsets, <code>BusinessHour.rollforward</code> may output different results from <code>apply</code> by definition.</p> <p>This is because one day’s business hour end is equal to next day’s business hour start. For example, under the default business hours (9:00 - 17:00), there is no gap (0 minutes) between <code>2014-08-01 17:00</code> and <code>2014-08-04 09:00</code>.</p> <pre data-language="python"># This adjusts a Timestamp to business hour edge
In [160]: BusinessHour().rollback(pd.Timestamp('2014-08-02 15:00'))
Out[160]: Timestamp('2014-08-01 17:00:00')

In [161]: BusinessHour().rollforward(pd.Timestamp('2014-08-02 15:00'))
Out[161]: Timestamp('2014-08-04 09:00:00')

# It is the same as BusinessHour().apply(pd.Timestamp('2014-08-01 17:00')).
# And it is the same as BusinessHour().apply(pd.Timestamp('2014-08-04 09:00'))
In [162]: BusinessHour().apply(pd.Timestamp('2014-08-02 15:00'))
Out[162]: Timestamp('2014-08-04 10:00:00')

# BusinessDay results (for reference)
In [163]: BusinessHour().rollforward(pd.Timestamp('2014-08-02'))
Out[163]: Timestamp('2014-08-04 09:00:00')

# It is the same as BusinessDay().apply(pd.Timestamp('2014-08-01'))
# The result is the same as rollworward because BusinessDay never overlap.
In [164]: BusinessHour().apply(pd.Timestamp('2014-08-02'))
Out[164]: Timestamp('2014-08-04 10:00:00')
</pre> <p><code>BusinessHour</code> regards Saturday and Sunday as holidays. To use arbitrary holidays, you can use <code>CustomBusinessHour</code> offset, see <a class="reference internal" href="#timeseries-custombusinesshour">Custom Business Hour</a>:</p>   <h3 id="timeseries-custombusinesshour">Custom Business Hour</h3> <div class="versionadded" id="custom-business-hour"> <p><span class="versionmodified">New in version 0.18.1.</span></p> </div> <p>The <code>CustomBusinessHour</code> is a mixture of <code>BusinessHour</code> and <code>CustomBusinessDay</code> which allows you to specify arbitrary holidays. <code>CustomBusinessHour</code> works as the same as <code>BusinessHour</code> except that it skips specified custom holidays.</p> <pre data-language="python">In [165]: from pandas.tseries.holiday import USFederalHolidayCalendar

In [166]: bhour_us = CustomBusinessHour(calendar=USFederalHolidayCalendar())

# Friday before MLK Day
In [167]: dt = datetime(2014, 1, 17, 15)

In [168]: dt + bhour_us
Out[168]: Timestamp('2014-01-17 16:00:00')

# Tuesday after MLK Day (Monday is skipped because it's a holiday)
In [169]: dt + bhour_us * 2
Out[169]: Timestamp('2014-01-21 09:00:00')
</pre> <p>You can use keyword arguments suported by either <code>BusinessHour</code> and <code>CustomBusinessDay</code>.</p> <pre data-language="python">In [170]: bhour_mon = CustomBusinessHour(start='10:00', weekmask='Tue Wed Thu Fri')

# Monday is skipped because it's a holiday, business hour starts from 10:00
In [171]: dt + bhour_mon * 2
Out[171]: Timestamp('2014-01-21 10:00:00')
</pre>   <h3 id="offset-aliases">Offset Aliases</h3> <p>A number of string aliases are given to useful common time series frequencies. We will refer to these aliases as <em>offset aliases</em> (referred to as <em>time rules</em> prior to v0.8.0).</p> <table class="docutils">  <thead valign="bottom"> <tr class="row-odd">
<th class="head">Alias</th> <th class="head">Description</th> </tr> </thead>  <tr class="row-even">
<td>B</td> <td>business day frequency</td> </tr> <tr class="row-odd">
<td>C</td> <td>custom business day frequency (experimental)</td> </tr> <tr class="row-even">
<td>D</td> <td>calendar day frequency</td> </tr> <tr class="row-odd">
<td>W</td> <td>weekly frequency</td> </tr> <tr class="row-even">
<td>M</td> <td>month end frequency</td> </tr> <tr class="row-odd">
<td>BM</td> <td>business month end frequency</td> </tr> <tr class="row-even">
<td>CBM</td> <td>custom business month end frequency</td> </tr> <tr class="row-odd">
<td>MS</td> <td>month start frequency</td> </tr> <tr class="row-even">
<td>BMS</td> <td>business month start frequency</td> </tr> <tr class="row-odd">
<td>CBMS</td> <td>custom business month start frequency</td> </tr> <tr class="row-even">
<td>Q</td> <td>quarter end frequency</td> </tr> <tr class="row-odd">
<td>BQ</td> <td>business quarter endfrequency</td> </tr> <tr class="row-even">
<td>QS</td> <td>quarter start frequency</td> </tr> <tr class="row-odd">
<td>BQS</td> <td>business quarter start frequency</td> </tr> <tr class="row-even">
<td>A</td> <td>year end frequency</td> </tr> <tr class="row-odd">
<td>BA</td> <td>business year end frequency</td> </tr> <tr class="row-even">
<td>AS</td> <td>year start frequency</td> </tr> <tr class="row-odd">
<td>BAS</td> <td>business year start frequency</td> </tr> <tr class="row-even">
<td>BH</td> <td>business hour frequency</td> </tr> <tr class="row-odd">
<td>H</td> <td>hourly frequency</td> </tr> <tr class="row-even">
<td>T, min</td> <td>minutely frequency</td> </tr> <tr class="row-odd">
<td>S</td> <td>secondly frequency</td> </tr> <tr class="row-even">
<td>L, ms</td> <td>milliseconds</td> </tr> <tr class="row-odd">
<td>U, us</td> <td>microseconds</td> </tr> <tr class="row-even">
<td>N</td> <td>nanoseconds</td> </tr>  </table>   <h3 id="combining-aliases">Combining Aliases</h3> <p>As we have seen previously, the alias and the offset instance are fungible in most functions:</p> <pre data-language="python">In [172]: pd.date_range(start, periods=5, freq='B')
Out[172]: 
DatetimeIndex(['2011-01-03', '2011-01-04', '2011-01-05', '2011-01-06',
               '2011-01-07'],
              dtype='datetime64[ns]', freq='B')

In [173]: pd.date_range(start, periods=5, freq=BDay())
Out[173]: 
DatetimeIndex(['2011-01-03', '2011-01-04', '2011-01-05', '2011-01-06',
               '2011-01-07'],
              dtype='datetime64[ns]', freq='B')
</pre> <p>You can combine together day and intraday offsets:</p> <pre data-language="python">In [174]: pd.date_range(start, periods=10, freq='2h20min')
Out[174]: 
DatetimeIndex(['2011-01-01 00:00:00', '2011-01-01 02:20:00',
               '2011-01-01 04:40:00', '2011-01-01 07:00:00',
               '2011-01-01 09:20:00', '2011-01-01 11:40:00',
               '2011-01-01 14:00:00', '2011-01-01 16:20:00',
               '2011-01-01 18:40:00', '2011-01-01 21:00:00'],
              dtype='datetime64[ns]', freq='140T')

In [175]: pd.date_range(start, periods=10, freq='1D10U')
Out[175]: 
DatetimeIndex([       '2011-01-01 00:00:00', '2011-01-02 00:00:00.000010',
               '2011-01-03 00:00:00.000020', '2011-01-04 00:00:00.000030',
               '2011-01-05 00:00:00.000040', '2011-01-06 00:00:00.000050',
               '2011-01-07 00:00:00.000060', '2011-01-08 00:00:00.000070',
               '2011-01-09 00:00:00.000080', '2011-01-10 00:00:00.000090'],
              dtype='datetime64[ns]', freq='86400000010U')
</pre>   <h3 id="anchored-offsets">Anchored Offsets</h3> <p>For some frequencies you can specify an anchoring suffix:</p> <table class="docutils">  <thead valign="bottom"> <tr class="row-odd">
<th class="head">Alias</th> <th class="head">Description</th> </tr> </thead>  <tr class="row-even">
<td>W-SUN</td> <td>weekly frequency (sundays). Same as ‘W’</td> </tr> <tr class="row-odd">
<td>W-MON</td> <td>weekly frequency (mondays)</td> </tr> <tr class="row-even">
<td>W-TUE</td> <td>weekly frequency (tuesdays)</td> </tr> <tr class="row-odd">
<td>W-WED</td> <td>weekly frequency (wednesdays)</td> </tr> <tr class="row-even">
<td>W-THU</td> <td>weekly frequency (thursdays)</td> </tr> <tr class="row-odd">
<td>W-FRI</td> <td>weekly frequency (fridays)</td> </tr> <tr class="row-even">
<td>W-SAT</td> <td>weekly frequency (saturdays)</td> </tr> <tr class="row-odd">
<td>(B)Q(S)-DEC</td> <td>quarterly frequency, year ends in December. Same as ‘Q’</td> </tr> <tr class="row-even">
<td>(B)Q(S)-JAN</td> <td>quarterly frequency, year ends in January</td> </tr> <tr class="row-odd">
<td>(B)Q(S)-FEB</td> <td>quarterly frequency, year ends in February</td> </tr> <tr class="row-even">
<td>(B)Q(S)-MAR</td> <td>quarterly frequency, year ends in March</td> </tr> <tr class="row-odd">
<td>(B)Q(S)-APR</td> <td>quarterly frequency, year ends in April</td> </tr> <tr class="row-even">
<td>(B)Q(S)-MAY</td> <td>quarterly frequency, year ends in May</td> </tr> <tr class="row-odd">
<td>(B)Q(S)-JUN</td> <td>quarterly frequency, year ends in June</td> </tr> <tr class="row-even">
<td>(B)Q(S)-JUL</td> <td>quarterly frequency, year ends in July</td> </tr> <tr class="row-odd">
<td>(B)Q(S)-AUG</td> <td>quarterly frequency, year ends in August</td> </tr> <tr class="row-even">
<td>(B)Q(S)-SEP</td> <td>quarterly frequency, year ends in September</td> </tr> <tr class="row-odd">
<td>(B)Q(S)-OCT</td> <td>quarterly frequency, year ends in October</td> </tr> <tr class="row-even">
<td>(B)Q(S)-NOV</td> <td>quarterly frequency, year ends in November</td> </tr> <tr class="row-odd">
<td>(B)A(S)-DEC</td> <td>annual frequency, anchored end of December. Same as ‘A’</td> </tr> <tr class="row-even">
<td>(B)A(S)-JAN</td> <td>annual frequency, anchored end of January</td> </tr> <tr class="row-odd">
<td>(B)A(S)-FEB</td> <td>annual frequency, anchored end of February</td> </tr> <tr class="row-even">
<td>(B)A(S)-MAR</td> <td>annual frequency, anchored end of March</td> </tr> <tr class="row-odd">
<td>(B)A(S)-APR</td> <td>annual frequency, anchored end of April</td> </tr> <tr class="row-even">
<td>(B)A(S)-MAY</td> <td>annual frequency, anchored end of May</td> </tr> <tr class="row-odd">
<td>(B)A(S)-JUN</td> <td>annual frequency, anchored end of June</td> </tr> <tr class="row-even">
<td>(B)A(S)-JUL</td> <td>annual frequency, anchored end of July</td> </tr> <tr class="row-odd">
<td>(B)A(S)-AUG</td> <td>annual frequency, anchored end of August</td> </tr> <tr class="row-even">
<td>(B)A(S)-SEP</td> <td>annual frequency, anchored end of September</td> </tr> <tr class="row-odd">
<td>(B)A(S)-OCT</td> <td>annual frequency, anchored end of October</td> </tr> <tr class="row-even">
<td>(B)A(S)-NOV</td> <td>annual frequency, anchored end of November</td> </tr>  </table> <p>These can be used as arguments to <code>date_range</code>, <code>bdate_range</code>, constructors for <code>DatetimeIndex</code>, as well as various other timeseries-related functions in pandas.</p>   <h3 id="anchored-offset-semantics">Anchored Offset Semantics</h3> <p>For those offsets that are anchored to the start or end of specific frequency (<code>MonthEnd</code>, <code>MonthBegin</code>, <code>WeekEnd</code>, etc) the following rules apply to rolling forward and backwards.</p> <p>When <code>n</code> is not 0, if the given date is not on an anchor point, it snapped to the next(previous) anchor point, and moved <code>|n|-1</code> additional steps forwards or backwards.</p> <pre data-language="python">In [176]: pd.Timestamp('2014-01-02') + MonthBegin(n=1)
Out[176]: Timestamp('2014-02-01 00:00:00')

In [177]: pd.Timestamp('2014-01-02') + MonthEnd(n=1)
Out[177]: Timestamp('2014-01-31 00:00:00')

In [178]: pd.Timestamp('2014-01-02') - MonthBegin(n=1)
Out[178]: Timestamp('2014-01-01 00:00:00')

In [179]: pd.Timestamp('2014-01-02') - MonthEnd(n=1)
Out[179]: Timestamp('2013-12-31 00:00:00')

In [180]: pd.Timestamp('2014-01-02') + MonthBegin(n=4)
Out[180]: Timestamp('2014-05-01 00:00:00')

In [181]: pd.Timestamp('2014-01-02') - MonthBegin(n=4)
Out[181]: Timestamp('2013-10-01 00:00:00')
</pre> <p>If the given date <em>is</em> on an anchor point, it is moved <code>|n|</code> points forwards or backwards.</p> <pre data-language="python">In [182]: pd.Timestamp('2014-01-01') + MonthBegin(n=1)
Out[182]: Timestamp('2014-02-01 00:00:00')

In [183]: pd.Timestamp('2014-01-31') + MonthEnd(n=1)
Out[183]: Timestamp('2014-02-28 00:00:00')

In [184]: pd.Timestamp('2014-01-01') - MonthBegin(n=1)
Out[184]: Timestamp('2013-12-01 00:00:00')

In [185]: pd.Timestamp('2014-01-31') - MonthEnd(n=1)
Out[185]: Timestamp('2013-12-31 00:00:00')

In [186]: pd.Timestamp('2014-01-01') + MonthBegin(n=4)
Out[186]: Timestamp('2014-05-01 00:00:00')

In [187]: pd.Timestamp('2014-01-31') - MonthBegin(n=4)
Out[187]: Timestamp('2013-10-01 00:00:00')
</pre> <p>For the case when <code>n=0</code>, the date is not moved if on an anchor point, otherwise it is rolled forward to the next anchor point.</p> <pre data-language="python">In [188]: pd.Timestamp('2014-01-02') + MonthBegin(n=0)
Out[188]: Timestamp('2014-02-01 00:00:00')

In [189]: pd.Timestamp('2014-01-02') + MonthEnd(n=0)
Out[189]: Timestamp('2014-01-31 00:00:00')

In [190]: pd.Timestamp('2014-01-01') + MonthBegin(n=0)
Out[190]: Timestamp('2014-01-01 00:00:00')

In [191]: pd.Timestamp('2014-01-31') + MonthEnd(n=0)
Out[191]: Timestamp('2014-01-31 00:00:00')
</pre>   <h3 id="timeseries-legacyaliases">Legacy Aliases</h3> <p id="legacy-aliases">Note that prior to v0.8.0, time rules had a slightly different look. These are deprecated in v0.17.0, and removed in future version.</p> <table class="docutils">  <thead valign="bottom"> <tr class="row-odd">
<th class="head">Legacy Time Rule</th> <th class="head">Offset Alias</th> </tr> </thead>  <tr class="row-even">
<td>WEEKDAY</td> <td>B</td> </tr> <tr class="row-odd">
<td>EOM</td> <td>BM</td> </tr> <tr class="row-even">
<td>W@MON</td> <td>W-MON</td> </tr> <tr class="row-odd">
<td>W@TUE</td> <td>W-TUE</td> </tr> <tr class="row-even">
<td>W@WED</td> <td>W-WED</td> </tr> <tr class="row-odd">
<td>W@THU</td> <td>W-THU</td> </tr> <tr class="row-even">
<td>W@FRI</td> <td>W-FRI</td> </tr> <tr class="row-odd">
<td>W@SAT</td> <td>W-SAT</td> </tr> <tr class="row-even">
<td>W@SUN</td> <td>W-SUN</td> </tr> <tr class="row-odd">
<td>Q@JAN</td> <td>BQ-JAN</td> </tr> <tr class="row-even">
<td>Q@FEB</td> <td>BQ-FEB</td> </tr> <tr class="row-odd">
<td>Q@MAR</td> <td>BQ-MAR</td> </tr> <tr class="row-even">
<td>A@JAN</td> <td>BA-JAN</td> </tr> <tr class="row-odd">
<td>A@FEB</td> <td>BA-FEB</td> </tr> <tr class="row-even">
<td>A@MAR</td> <td>BA-MAR</td> </tr> <tr class="row-odd">
<td>A@APR</td> <td>BA-APR</td> </tr> <tr class="row-even">
<td>A@MAY</td> <td>BA-MAY</td> </tr> <tr class="row-odd">
<td>A@JUN</td> <td>BA-JUN</td> </tr> <tr class="row-even">
<td>A@JUL</td> <td>BA-JUL</td> </tr> <tr class="row-odd">
<td>A@AUG</td> <td>BA-AUG</td> </tr> <tr class="row-even">
<td>A@SEP</td> <td>BA-SEP</td> </tr> <tr class="row-odd">
<td>A@OCT</td> <td>BA-OCT</td> </tr> <tr class="row-even">
<td>A@NOV</td> <td>BA-NOV</td> </tr> <tr class="row-odd">
<td>A@DEC</td> <td>BA-DEC</td> </tr>  </table> <p>As you can see, legacy quarterly and annual frequencies are business quarters and business year ends. Please also note the legacy time rule for milliseconds <code>ms</code> versus the new offset alias for month start <code>MS</code>. This means that offset alias parsing is case sensitive.</p>   <h3 id="timeseries-holiday">Holidays / Holiday Calendars</h3> <p id="holidays-holiday-calendars">Holidays and calendars provide a simple way to define holiday rules to be used with <code>CustomBusinessDay</code> or in other analysis that requires a predefined set of holidays. The <code>AbstractHolidayCalendar</code> class provides all the necessary methods to return a list of holidays and only <code>rules</code> need to be defined in a specific holiday calendar class. Further, <code>start_date</code> and <code>end_date</code> class attributes determine over what date range holidays are generated. These should be overwritten on the <code>AbstractHolidayCalendar</code> class to have the range apply to all calendar subclasses. <code>USFederalHolidayCalendar</code> is the only calendar that exists and primarily serves as an example for developing other calendars.</p> <p>For holidays that occur on fixed dates (e.g., US Memorial Day or July 4th) an observance rule determines when that holiday is observed if it falls on a weekend or some other non-observed day. Defined observance rules are:</p> <table class="docutils">  <thead valign="bottom"> <tr class="row-odd">
<th class="head">Rule</th> <th class="head">Description</th> </tr> </thead>  <tr class="row-even">
<td>nearest_workday</td> <td>move Saturday to Friday and Sunday to Monday</td> </tr> <tr class="row-odd">
<td>sunday_to_monday</td> <td>move Sunday to following Monday</td> </tr> <tr class="row-even">
<td>next_monday_or_tuesday</td> <td>move Saturday to Monday and Sunday/Monday to Tuesday</td> </tr> <tr class="row-odd">
<td>previous_friday</td> <td>move Saturday and Sunday to previous Friday”</td> </tr> <tr class="row-even">
<td>next_monday</td> <td>move Saturday and Sunday to following Monday</td> </tr>  </table> <p>An example of how holidays and holiday calendars are defined:</p> <pre data-language="python">In [192]: from pandas.tseries.holiday import Holiday, USMemorialDay,\
   .....:     AbstractHolidayCalendar, nearest_workday, MO
   .....: 

In [193]: class ExampleCalendar(AbstractHolidayCalendar):
   .....:     rules = [
   .....:         USMemorialDay,
   .....:         Holiday('July 4th', month=7, day=4, observance=nearest_workday),
   .....:         Holiday('Columbus Day', month=10, day=1,
   .....:             offset=DateOffset(weekday=MO(2))), #same as 2*Week(weekday=2)
   .....:         ]
   .....: 

In [194]: cal = ExampleCalendar()

In [195]: cal.holidays(datetime(2012, 1, 1), datetime(2012, 12, 31))
Out[195]: DatetimeIndex(['2012-05-28', '2012-07-04', '2012-10-08'], dtype='datetime64[ns]', freq=None)
</pre> <p>Using this calendar, creating an index or doing offset arithmetic skips weekends and holidays (i.e., Memorial Day/July 4th). For example, the below defines a custom business day offset using the <code>ExampleCalendar</code>. Like any other offset, it can be used to create a <code>DatetimeIndex</code> or added to <code>datetime</code> or <code>Timestamp</code> objects.</p> <pre data-language="python">In [196]: from pandas.tseries.offsets import CDay

In [197]: pd.DatetimeIndex(start='7/1/2012', end='7/10/2012',
   .....:     freq=CDay(calendar=cal)).to_pydatetime()
   .....: 
Out[197]: 
array([datetime.datetime(2012, 7, 2, 0, 0),
       datetime.datetime(2012, 7, 3, 0, 0),
       datetime.datetime(2012, 7, 5, 0, 0),
       datetime.datetime(2012, 7, 6, 0, 0),
       datetime.datetime(2012, 7, 9, 0, 0),
       datetime.datetime(2012, 7, 10, 0, 0)], dtype=object)

In [198]: offset = CustomBusinessDay(calendar=cal)

In [199]: datetime(2012, 5, 25) + offset
Out[199]: Timestamp('2012-05-29 00:00:00')

In [200]: datetime(2012, 7, 3) + offset
Out[200]: Timestamp('2012-07-05 00:00:00')

In [201]: datetime(2012, 7, 3) + 2 * offset
Out[201]: Timestamp('2012-07-06 00:00:00')

In [202]: datetime(2012, 7, 6) + offset
Out[202]: Timestamp('2012-07-09 00:00:00')
</pre> <p>Ranges are defined by the <code>start_date</code> and <code>end_date</code> class attributes of <code>AbstractHolidayCalendar</code>. The defaults are below.</p> <pre data-language="python">In [203]: AbstractHolidayCalendar.start_date
Out[203]: Timestamp('1970-01-01 00:00:00')

In [204]: AbstractHolidayCalendar.end_date
Out[204]: Timestamp('2030-12-31 00:00:00')
</pre> <p>These dates can be overwritten by setting the attributes as datetime/Timestamp/string.</p> <pre data-language="python">In [205]: AbstractHolidayCalendar.start_date = datetime(2012, 1, 1)

In [206]: AbstractHolidayCalendar.end_date = datetime(2012, 12, 31)

In [207]: cal.holidays()
Out[207]: DatetimeIndex(['2012-05-28', '2012-07-04', '2012-10-08'], dtype='datetime64[ns]', freq=None)
</pre> <p>Every calendar class is accessible by name using the <code>get_calendar</code> function which returns a holiday class instance. Any imported calendar class will automatically be available by this function. Also, <code>HolidayCalendarFactory</code> provides an easy interface to create calendars that are combinations of calendars or calendars with additional rules.</p> <pre data-language="python">In [208]: from pandas.tseries.holiday import get_calendar, HolidayCalendarFactory,\
   .....:     USLaborDay
   .....: 

In [209]: cal = get_calendar('ExampleCalendar')

In [210]: cal.rules
Out[210]: 
[Holiday: MemorialDay (month=5, day=31, offset=&lt;DateOffset: kwds={'weekday': MO(-1)}&gt;),
 Holiday: July 4th (month=7, day=4, observance=&lt;function nearest_workday at 0x12f657a28&gt;),
 Holiday: Columbus Day (month=10, day=1, offset=&lt;DateOffset: kwds={'weekday': MO(+2)}&gt;)]

In [211]: new_cal = HolidayCalendarFactory('NewExampleCalendar', cal, USLaborDay)

In [212]: new_cal.rules
Out[212]: 
[Holiday: Labor Day (month=9, day=1, offset=&lt;DateOffset: kwds={'weekday': MO(+1)}&gt;),
 Holiday: Columbus Day (month=10, day=1, offset=&lt;DateOffset: kwds={'weekday': MO(+2)}&gt;),
 Holiday: July 4th (month=7, day=4, observance=&lt;function nearest_workday at 0x12f657a28&gt;),
 Holiday: MemorialDay (month=5, day=31, offset=&lt;DateOffset: kwds={'weekday': MO(-1)}&gt;)]
</pre>    <h2 id="timeseries-advanced-datetime">Time series-related instance methods</h2>  <h3 id="time-series-related-instance-methods">Shifting / lagging</h3> <p>One may want to <em>shift</em> or <em>lag</em> the values in a time series back and forward in time. The method for this is <code>shift</code>, which is available on all of the pandas objects.</p> <pre data-language="python">In [213]: ts = ts[:5]

In [214]: ts.shift(1)
Out[214]: 
2011-01-31         NaN
2011-02-28   -1.281247
2011-03-31   -0.727707
2011-04-29   -0.121306
2011-05-31   -0.097883
Freq: BM, dtype: float64
</pre> <p>The shift method accepts an <code>freq</code> argument which can accept a <code>DateOffset</code> class or other <code>timedelta</code>-like object or also a <a class="reference internal" href="#timeseries-alias">offset alias</a>:</p> <pre data-language="python">In [215]: ts.shift(5, freq=datetools.bday)
Out[215]: 
2011-02-07   -1.281247
2011-03-07   -0.727707
2011-04-07   -0.121306
2011-05-06   -0.097883
2011-06-07    0.695775
dtype: float64

In [216]: ts.shift(5, freq='BM')
Out[216]: 
2011-06-30   -1.281247
2011-07-29   -0.727707
2011-08-31   -0.121306
2011-09-30   -0.097883
2011-10-31    0.695775
Freq: BM, dtype: float64
</pre> <p>Rather than changing the alignment of the data and the index, <code>DataFrame</code> and <code>Series</code> objects also have a <code>tshift</code> convenience method that changes all the dates in the index by a specified number of offsets:</p> <pre data-language="python">In [217]: ts.tshift(5, freq='D')
Out[217]: 
2011-02-05   -1.281247
2011-03-05   -0.727707
2011-04-05   -0.121306
2011-05-04   -0.097883
2011-06-05    0.695775
dtype: float64
</pre> <p>Note that with <code>tshift</code>, the leading entry is no longer NaN because the data is not being realigned.</p>   <h3 id="frequency-conversion">Frequency conversion</h3> <p>The primary function for changing frequencies is the <code>asfreq</code> function. For a <code>DatetimeIndex</code>, this is basically just a thin, but convenient wrapper around <code>reindex</code> which generates a <code>date_range</code> and calls <code>reindex</code>.</p> <pre data-language="python">In [218]: dr = pd.date_range('1/1/2010', periods=3, freq=3 * datetools.bday)

In [219]: ts = pd.Series(randn(3), index=dr)

In [220]: ts
Out[220]: 
2010-01-01    0.532005
2010-01-06    0.544874
2010-01-11   -1.001788
Freq: 3B, dtype: float64

In [221]: ts.asfreq(BDay())
Out[221]: 
2010-01-01    0.532005
2010-01-04         NaN
2010-01-05         NaN
2010-01-06    0.544874
2010-01-07         NaN
2010-01-08         NaN
2010-01-11   -1.001788
Freq: B, dtype: float64
</pre> <p><code>asfreq</code> provides a further convenience so you can specify an interpolation method for any gaps that may appear after the frequency conversion</p> <pre data-language="python">In [222]: ts.asfreq(BDay(), method='pad')
Out[222]: 
2010-01-01    0.532005
2010-01-04    0.532005
2010-01-05    0.532005
2010-01-06    0.544874
2010-01-07    0.544874
2010-01-08    0.544874
2010-01-11   -1.001788
Freq: B, dtype: float64
</pre>   <h3 id="filling-forward-backward">Filling forward / backward</h3> <p>Related to <code>asfreq</code> and <code>reindex</code> is the <code>fillna</code> function documented in the <a class="reference internal" href="../missing_data/#missing-data-fillna">missing data section</a>.</p>   <h3 id="converting-to-python-datetimes">Converting to Python datetimes</h3> <p><code>DatetimeIndex</code> can be converted to an array of Python native datetime.datetime objects using the <code>to_pydatetime</code> method.</p>    <h2 id="timeseries-resampling">Resampling</h2> <div class="admonition warning" id="resampling"> <p class="first admonition-title">Warning</p> <p class="last">The interface to <code>.resample</code> has changed in 0.18.0 to be more groupby-like and hence more flexible. See the <a class="reference internal" href="http://pandas.pydata.org/pandas-docs/version/0.18.1/whatsnew.html#whatsnew-0180-breaking-resample" target="_blank">whatsnew docs</a> for a comparison with prior versions.</p> </div> <p>Pandas has a simple, powerful, and efficient functionality for performing resampling operations during frequency conversion (e.g., converting secondly data into 5-minutely data). This is extremely common in, but not limited to, financial applications.</p> <p><code>resample</code> is a time-based groupby, followed by a reduction method on each of its groups.</p> <p>See some <a class="reference internal" href="../cookbook/#cookbook-resample">cookbook examples</a> for some advanced strategies</p> <pre data-language="python">In [223]: rng = pd.date_range('1/1/2012', periods=100, freq='S')

In [224]: ts = pd.Series(np.random.randint(0, 500, len(rng)), index=rng)

In [225]: ts.resample('5Min').sum()
Out[225]: 
2012-01-01    24390
Freq: 5T, dtype: int64
</pre> <p>The <code>resample</code> function is very flexible and allows you to specify many different parameters to control the frequency conversion and resampling operation.</p> <p>The <code>how</code> parameter can be a function name or numpy array function that takes an array and produces aggregated values:</p> <pre data-language="python">In [226]: ts.resample('5Min').mean()
Out[226]: 
2012-01-01    243.9
Freq: 5T, dtype: float64

In [227]: ts.resample('5Min').ohlc()
Out[227]: 
            open  high  low  close
2012-01-01   161   495    1    245

In [228]: ts.resample('5Min').max()
Out[228]: 
2012-01-01    495
Freq: 5T, dtype: int64
</pre> <p>Any function available via <a class="reference internal" href="../groupby/#groupby-dispatch">dispatching</a> can be given to the <code>how</code> parameter by name, including <code>sum</code>, <code>mean</code>, <code>std</code>, <code>sem</code>, <code>max</code>, <code>min</code>, <code>median</code>, <code>first</code>, <code>last</code>, <code>ohlc</code>.</p> <p>For downsampling, <code>closed</code> can be set to ‘left’ or ‘right’ to specify which end of the interval is closed:</p> <pre data-language="python">In [229]: ts.resample('5Min', closed='right').mean()
Out[229]: 
2011-12-31 23:55:00    161.000000
2012-01-01 00:00:00    244.737374
Freq: 5T, dtype: float64

In [230]: ts.resample('5Min', closed='left').mean()
Out[230]: 
2012-01-01    243.9
Freq: 5T, dtype: float64
</pre> <p>Parameters like <code>label</code> and <code>loffset</code> are used to manipulate the resulting labels. <code>label</code> specifies whether the result is labeled with the beginning or the end of the interval. <code>loffset</code> performs a time adjustment on the output labels.</p> <pre data-language="python">In [231]: ts.resample('5Min').mean() # by default label='right'
Out[231]: 
2012-01-01    243.9
Freq: 5T, dtype: float64

In [232]: ts.resample('5Min', label='left').mean()
Out[232]: 
2012-01-01    243.9
Freq: 5T, dtype: float64

In [233]: ts.resample('5Min', label='left', loffset='1s').mean()
Out[233]: 
2012-01-01 00:00:01    243.9
dtype: float64
</pre> <p>The <code>axis</code> parameter can be set to 0 or 1 and allows you to resample the specified axis for a DataFrame.</p> <p><code>kind</code> can be set to ‘timestamp’ or ‘period’ to convert the resulting index to/from time-stamp and time-span representations. By default <code>resample</code> retains the input representation.</p> <p><code>convention</code> can be set to ‘start’ or ‘end’ when resampling period data (detail below). It specifies how low frequency periods are converted to higher frequency periods.</p>  <h3 id="up-sampling">Up Sampling</h3> <p>For upsampling, you can specify a way to upsample and the <code>limit</code> parameter to interpolate over the gaps that are created:</p> <pre data-language="python"># from secondly to every 250 milliseconds
In [234]: ts[:2].resample('250L').asfreq()
Out[234]: 
2012-01-01 00:00:00.000    161.0
2012-01-01 00:00:00.250      NaN
2012-01-01 00:00:00.500      NaN
2012-01-01 00:00:00.750      NaN
2012-01-01 00:00:01.000    199.0
Freq: 250L, dtype: float64

In [235]: ts[:2].resample('250L').ffill()
Out[235]: 
2012-01-01 00:00:00.000    161
2012-01-01 00:00:00.250    161
2012-01-01 00:00:00.500    161
2012-01-01 00:00:00.750    161
2012-01-01 00:00:01.000    199
Freq: 250L, dtype: int64

In [236]: ts[:2].resample('250L').ffill(limit=2)
Out[236]: 
2012-01-01 00:00:00.000    161.0
2012-01-01 00:00:00.250    161.0
2012-01-01 00:00:00.500    161.0
2012-01-01 00:00:00.750      NaN
2012-01-01 00:00:01.000    199.0
Freq: 250L, dtype: float64
</pre>   <h3 id="sparse-resampling">Sparse Resampling</h3> <p>Sparse timeseries are ones where you have a lot fewer points relative to the amount of time you are looking to resample. Naively upsampling a sparse series can potentially generate lots of intermediate values. When you don’t want to use a method to fill these values, e.g. <code>fill_method</code> is <code>None</code>, then intermediate values will be filled with <code>NaN</code>.</p> <p>Since <code>resample</code> is a time-based groupby, the following is a method to efficiently resample only the groups that are not all <code>NaN</code></p> <pre data-language="python">In [237]: rng = pd.date_range('2014-1-1', periods=100, freq='D') + pd.Timedelta('1s')

In [238]: ts = pd.Series(range(100), index=rng)
</pre> <p>If we want to resample to the full range of the series</p> <pre data-language="python">In [239]: ts.resample('3T').sum()
Out[239]: 
2014-01-01 00:00:00     0.0
2014-01-01 00:03:00     NaN
2014-01-01 00:06:00     NaN
2014-01-01 00:09:00     NaN
2014-01-01 00:12:00     NaN
2014-01-01 00:15:00     NaN
2014-01-01 00:18:00     NaN
                       ... 
2014-04-09 23:42:00     NaN
2014-04-09 23:45:00     NaN
2014-04-09 23:48:00     NaN
2014-04-09 23:51:00     NaN
2014-04-09 23:54:00     NaN
2014-04-09 23:57:00     NaN
2014-04-10 00:00:00    99.0
Freq: 3T, dtype: float64
</pre> <p>We can instead only resample those groups where we have points as follows:</p> <pre data-language="python">In [240]: from functools import partial

In [241]: from pandas.tseries.frequencies import to_offset

In [242]: def round(t, freq):
   .....:     freq = to_offset(freq)
   .....:     return pd.Timestamp((t.value // freq.delta.value) * freq.delta.value)
   .....: 

In [243]: ts.groupby(partial(round, freq='3T')).sum()
Out[243]: 
2014-01-01     0
2014-01-02     1
2014-01-03     2
2014-01-04     3
2014-01-05     4
2014-01-06     5
2014-01-07     6
              ..
2014-04-04    93
2014-04-05    94
2014-04-06    95
2014-04-07    96
2014-04-08    97
2014-04-09    98
2014-04-10    99
dtype: int64
</pre>   <h3 id="aggregation">Aggregation</h3> <p>Similar to <a class="reference internal" href="../groupby/#groupby-aggregate">groupby aggregates</a> and the <a class="reference internal" href="../computation/#stats-aggregate">window functions</a>, a <code>Resampler</code> can be selectively resampled.</p> <p>Resampling a <code>DataFrame</code>, the default will be to act on all columns with the same function.</p> <pre data-language="python">In [244]: df = pd.DataFrame(np.random.randn(1000, 3),
   .....:                   index=pd.date_range('1/1/2012', freq='S', periods=1000),
   .....:                   columns=['A', 'B', 'C'])
   .....: 

In [245]: r = df.resample('3T')

In [246]: r.mean()
Out[246]: 
                            A         B         C
2012-01-01 00:00:00 -0.220339  0.034854 -0.073757
2012-01-01 00:03:00  0.037070  0.040013  0.053754
2012-01-01 00:06:00 -0.041597 -0.144562 -0.007614
2012-01-01 00:09:00  0.043127 -0.076432 -0.032570
2012-01-01 00:12:00 -0.027609  0.054618  0.056878
2012-01-01 00:15:00 -0.014181  0.043958  0.077734
</pre> <p>We can select a specific column or columns using standard getitem.</p> <pre data-language="python">In [247]: r['A'].mean()
Out[247]: 
2012-01-01 00:00:00   -0.220339
2012-01-01 00:03:00    0.037070
2012-01-01 00:06:00   -0.041597
2012-01-01 00:09:00    0.043127
2012-01-01 00:12:00   -0.027609
2012-01-01 00:15:00   -0.014181
Freq: 3T, Name: A, dtype: float64

In [248]: r[['A','B']].mean()
Out[248]: 
                            A         B
2012-01-01 00:00:00 -0.220339  0.034854
2012-01-01 00:03:00  0.037070  0.040013
2012-01-01 00:06:00 -0.041597 -0.144562
2012-01-01 00:09:00  0.043127 -0.076432
2012-01-01 00:12:00 -0.027609  0.054618
2012-01-01 00:15:00 -0.014181  0.043958
</pre> <p>You can pass a list or dict of functions to do aggregation with, outputting a DataFrame:</p> <pre data-language="python">In [249]: r['A'].agg([np.sum, np.mean, np.std])
Out[249]: 
                           sum      mean       std
2012-01-01 00:00:00 -39.660974 -0.220339  1.033912
2012-01-01 00:03:00   6.672559  0.037070  0.971503
2012-01-01 00:06:00  -7.487453 -0.041597  1.018418
2012-01-01 00:09:00   7.762901  0.043127  1.025842
2012-01-01 00:12:00  -4.969624 -0.027609  0.961649
2012-01-01 00:15:00  -1.418119 -0.014181  0.978847
</pre> <p>If a dict is passed, the keys will be used to name the columns. Otherwise the function’s name (stored in the function object) will be used.</p> <pre data-language="python">In [250]: r['A'].agg({'result1' : np.sum,
   .....:             'result2' : np.mean})
   .....: 
Out[250]: 
                      result2    result1
2012-01-01 00:00:00 -0.220339 -39.660974
2012-01-01 00:03:00  0.037070   6.672559
2012-01-01 00:06:00 -0.041597  -7.487453
2012-01-01 00:09:00  0.043127   7.762901
2012-01-01 00:12:00 -0.027609  -4.969624
2012-01-01 00:15:00 -0.014181  -1.418119
</pre> <p>On a resampled DataFrame, you can pass a list of functions to apply to each column, which produces an aggregated result with a hierarchical index:</p> <pre data-language="python">In [251]: r.agg([np.sum, np.mean])
Out[251]: 
                             A                    B                    C  \
                           sum      mean        sum      mean        sum   
2012-01-01 00:00:00 -39.660974 -0.220339   6.273786  0.034854 -13.276324   
2012-01-01 00:03:00   6.672559  0.037070   7.202361  0.040013   9.675632   
2012-01-01 00:06:00  -7.487453 -0.041597 -26.021155 -0.144562  -1.370600   
2012-01-01 00:09:00   7.762901  0.043127 -13.757837 -0.076432  -5.862640   
2012-01-01 00:12:00  -4.969624 -0.027609   9.831208  0.054618  10.237970   
2012-01-01 00:15:00  -1.418119 -0.014181   4.395766  0.043958   7.773442   

                               
                         mean  
2012-01-01 00:00:00 -0.073757  
2012-01-01 00:03:00  0.053754  
2012-01-01 00:06:00 -0.007614  
2012-01-01 00:09:00 -0.032570  
2012-01-01 00:12:00  0.056878  
2012-01-01 00:15:00  0.077734  
</pre> <p>By passing a dict to <code>aggregate</code> you can apply a different aggregation to the columns of a DataFrame:</p> <pre data-language="python">In [252]: r.agg({'A' : np.sum,
   .....:        'B' : lambda x: np.std(x, ddof=1)})
   .....: 
Out[252]: 
                             A         B
2012-01-01 00:00:00 -39.660974  1.004756
2012-01-01 00:03:00   6.672559  0.963559
2012-01-01 00:06:00  -7.487453  0.950766
2012-01-01 00:09:00   7.762901  0.949182
2012-01-01 00:12:00  -4.969624  1.093736
2012-01-01 00:15:00  -1.418119  1.028869
</pre> <p>The function names can also be strings. In order for a string to be valid it must be implemented on the Resampled object</p> <pre data-language="python">In [253]: r.agg({'A' : 'sum', 'B' : 'std'})
Out[253]: 
                             A         B
2012-01-01 00:00:00 -39.660974  1.004756
2012-01-01 00:03:00   6.672559  0.963559
2012-01-01 00:06:00  -7.487453  0.950766
2012-01-01 00:09:00   7.762901  0.949182
2012-01-01 00:12:00  -4.969624  1.093736
2012-01-01 00:15:00  -1.418119  1.028869
</pre> <p>Furthermore, you can also specify multiple aggregation functions for each column separately.</p> <pre data-language="python">In [254]: r.agg({'A' : ['sum','std'], 'B' : ['mean','std'] })
Out[254]: 
                             A                   B          
                           sum       std      mean       std
2012-01-01 00:00:00 -39.660974  1.033912  0.034854  1.004756
2012-01-01 00:03:00   6.672559  0.971503  0.040013  0.963559
2012-01-01 00:06:00  -7.487453  1.018418 -0.144562  0.950766
2012-01-01 00:09:00   7.762901  1.025842 -0.076432  0.949182
2012-01-01 00:12:00  -4.969624  0.961649  0.054618  1.093736
2012-01-01 00:15:00  -1.418119  0.978847  0.043958  1.028869
</pre>    <h2 id="timeseries-periods">Time Span Representation</h2> <p id="time-span-representation">Regular intervals of time are represented by <code>Period</code> objects in pandas while sequences of <code>Period</code> objects are collected in a <code>PeriodIndex</code>, which can be created with the convenience function <code>period_range</code>.</p>  <h3 id="period">Period</h3> <p>A <code>Period</code> represents a span of time (e.g., a day, a month, a quarter, etc). You can specify the span via <code>freq</code> keyword using a frequency alias like below. Because <code>freq</code> represents a span of <code>Period</code>, it cannot be negative like “-3D”.</p> <pre data-language="python">In [255]: pd.Period('2012', freq='A-DEC')
Out[255]: Period('2012', 'A-DEC')

In [256]: pd.Period('2012-1-1', freq='D')
Out[256]: Period('2012-01-01', 'D')

In [257]: pd.Period('2012-1-1 19:00', freq='H')
Out[257]: Period('2012-01-01 19:00', 'H')

In [258]: pd.Period('2012-1-1 19:00', freq='5H')
Out[258]: Period('2012-01-01 19:00', '5H')
</pre> <p>Adding and subtracting integers from periods shifts the period by its own frequency. Arithmetic is not allowed between <code>Period</code> with different <code>freq</code> (span).</p> <pre data-language="python">In [259]: p = pd.Period('2012', freq='A-DEC')

In [260]: p + 1
Out[260]: Period('2013', 'A-DEC')

In [261]: p - 3
Out[261]: Period('2009', 'A-DEC')

In [262]: p = pd.Period('2012-01', freq='2M')

In [263]: p + 2
Out[263]: Period('2012-05', '2M')

In [264]: p - 1
Out[264]: Period('2011-11', '2M')

In [265]: p == pd.Period('2012-01', freq='3M')
---------------------------------------------------------------------------
IncompatibleFrequency                     Traceback (most recent call last)
&lt;ipython-input-265-ff54ce3238f5&gt; in &lt;module&gt;()
----&gt; 1 p == pd.Period('2012-01', freq='3M')

/Users/tom.augspurger/miniconda3/envs/docs/lib/python2.7/site-packages/pandas/pandas/src/period.pyx in pandas._period.Period.__richcmp__ (pandas/src/period.c:12486)()
    769             if other.freq != self.freq:
    770                 msg = _DIFFERENT_FREQ.format(self.freqstr, other.freqstr)
--&gt; 771                 raise IncompatibleFrequency(msg)
    772             if self.ordinal == tslib.iNaT or other.ordinal == tslib.iNaT:
    773                 return _nat_scalar_rules[op]

IncompatibleFrequency: Input has different freq=3M from Period(freq=2M)
</pre> <p>If <code>Period</code> freq is daily or higher (<code>D</code>, <code>H</code>, <code>T</code>, <code>S</code>, <code>L</code>, <code>U</code>, <code>N</code>), <code>offsets</code> and <code>timedelta</code>-like can be added if the result can have the same freq. Otherwise, <code>ValueError</code> will be raised.</p> <pre data-language="python">In [266]: p = pd.Period('2014-07-01 09:00', freq='H')

In [267]: p + Hour(2)
Out[267]: Period('2014-07-01 11:00', 'H')

In [268]: p + timedelta(minutes=120)
Out[268]: Period('2014-07-01 11:00', 'H')

In [269]: p + np.timedelta64(7200, 's')
Out[269]: Period('2014-07-01 11:00', 'H')
</pre> <pre data-language="python">In [1]: p + Minute(5)
Traceback
   ...
ValueError: Input has different freq from Period(freq=H)
</pre> <p>If <code>Period</code> has other freqs, only the same <code>offsets</code> can be added. Otherwise, <code>ValueError</code> will be raised.</p> <pre data-language="python">In [270]: p = pd.Period('2014-07', freq='M')

In [271]: p + MonthEnd(3)
Out[271]: Period('2014-10', 'M')
</pre> <pre data-language="python">In [1]: p + MonthBegin(3)
Traceback
   ...
ValueError: Input has different freq from Period(freq=M)
</pre> <p>Taking the difference of <code>Period</code> instances with the same frequency will return the number of frequency units between them:</p> <pre data-language="python">In [272]: pd.Period('2012', freq='A-DEC') - pd.Period('2002', freq='A-DEC')
Out[272]: 10
</pre>   <h3 id="periodindex-and-period-range">PeriodIndex and period_range</h3> <p>Regular sequences of <code>Period</code> objects can be collected in a <code>PeriodIndex</code>, which can be constructed using the <code>period_range</code> convenience function:</p> <pre data-language="python">In [273]: prng = pd.period_range('1/1/2011', '1/1/2012', freq='M')

In [274]: prng
Out[274]: 
PeriodIndex(['2011-01', '2011-02', '2011-03', '2011-04', '2011-05', '2011-06',
             '2011-07', '2011-08', '2011-09', '2011-10', '2011-11', '2011-12',
             '2012-01'],
            dtype='int64', freq='M')
</pre> <p>The <code>PeriodIndex</code> constructor can also be used directly:</p> <pre data-language="python">In [275]: pd.PeriodIndex(['2011-1', '2011-2', '2011-3'], freq='M')
Out[275]: PeriodIndex(['2011-01', '2011-02', '2011-03'], dtype='int64', freq='M')
</pre> <p>Passing multiplied frequency outputs a sequence of <code>Period</code> which has multiplied span.</p> <pre data-language="python">In [276]: pd.PeriodIndex(start='2014-01', freq='3M', periods=4)
Out[276]: PeriodIndex(['2014-01', '2014-04', '2014-07', '2014-10'], dtype='int64', freq='3M')
</pre> <p>Just like <code>DatetimeIndex</code>, a <code>PeriodIndex</code> can also be used to index pandas objects:</p> <pre data-language="python">In [277]: ps = pd.Series(np.random.randn(len(prng)), prng)

In [278]: ps
Out[278]: 
2011-01   -1.022670
2011-02    1.371155
2011-03    1.035277
2011-04    1.694400
2011-05   -1.659733
2011-06    0.511432
2011-07    0.433176
2011-08   -0.317955
2011-09   -0.517114
2011-10   -0.310466
2011-11    0.543957
2011-12    0.492003
2012-01    0.193420
Freq: M, dtype: float64
</pre> <p><code>PeriodIndex</code> supports addition and subtraction with the same rule as <code>Period</code>.</p> <pre data-language="python">In [279]: idx = pd.period_range('2014-07-01 09:00', periods=5, freq='H')

In [280]: idx
Out[280]: 
PeriodIndex(['2014-07-01 09:00', '2014-07-01 10:00', '2014-07-01 11:00',
             '2014-07-01 12:00', '2014-07-01 13:00'],
            dtype='int64', freq='H')

In [281]: idx + Hour(2)
Out[281]: 
PeriodIndex(['2014-07-01 11:00', '2014-07-01 12:00', '2014-07-01 13:00',
             '2014-07-01 14:00', '2014-07-01 15:00'],
            dtype='int64', freq='H')

In [282]: idx = pd.period_range('2014-07', periods=5, freq='M')

In [283]: idx
Out[283]: PeriodIndex(['2014-07', '2014-08', '2014-09', '2014-10', '2014-11'], dtype='int64', freq='M')

In [284]: idx + MonthEnd(3)
Out[284]: PeriodIndex(['2014-10', '2014-11', '2014-12', '2015-01', '2015-02'], dtype='int64', freq='M')
</pre>   <h3 id="periodindex-partial-string-indexing">PeriodIndex Partial String Indexing</h3> <p>You can pass in dates and strings to <code>Series</code> and <code>DataFrame</code> with <code>PeriodIndex</code>, in the same manner as <code>DatetimeIndex</code>. For details, refer to <a class="reference internal" href="#timeseries-partialindexing">DatetimeIndex Partial String Indexing</a>.</p> <pre data-language="python">In [285]: ps['2011-01']
Out[285]: -1.022669594890105

In [286]: ps[datetime(2011, 12, 25):]
Out[286]: 
2011-12    0.492003
2012-01    0.193420
Freq: M, dtype: float64

In [287]: ps['10/31/2011':'12/31/2011']
Out[287]: 
2011-10   -0.310466
2011-11    0.543957
2011-12    0.492003
Freq: M, dtype: float64
</pre> <p>Passing a string representing a lower frequency than <code>PeriodIndex</code> returns partial sliced data.</p> <pre data-language="python">In [288]: ps['2011']
Out[288]: 
2011-01   -1.022670
2011-02    1.371155
2011-03    1.035277
2011-04    1.694400
2011-05   -1.659733
2011-06    0.511432
2011-07    0.433176
2011-08   -0.317955
2011-09   -0.517114
2011-10   -0.310466
2011-11    0.543957
2011-12    0.492003
Freq: M, dtype: float64

In [289]: dfp = pd.DataFrame(np.random.randn(600,1),
   .....:                    columns=['A'],
   .....:                    index=pd.period_range('2013-01-01 9:00', periods=600, freq='T'))
   .....: 

In [290]: dfp
Out[290]: 
                         A
2013-01-01 09:00  0.197720
2013-01-01 09:01 -0.284769
2013-01-01 09:02  0.061491
2013-01-01 09:03  1.630257
2013-01-01 09:04  2.042442
2013-01-01 09:05 -0.804392
2013-01-01 09:06  0.212760
...                    ...
2013-01-01 18:53  0.150586
2013-01-01 18:54 -0.679569
2013-01-01 18:55 -0.910216
2013-01-01 18:56 -0.413168
2013-01-01 18:57 -0.247752
2013-01-01 18:58  1.590875
2013-01-01 18:59 -2.005294

[600 rows x 1 columns]

In [291]: dfp['2013-01-01 10H']
Out[291]: 
                         A
2013-01-01 10:00 -0.569936
2013-01-01 10:01 -1.179183
2013-01-01 10:02 -0.838602
2013-01-01 10:03 -1.727539
2013-01-01 10:04  1.334027
2013-01-01 10:05  0.417423
2013-01-01 10:06 -0.221189
...                    ...
2013-01-01 10:53 -0.375925
2013-01-01 10:54  0.212750
2013-01-01 10:55 -0.592417
2013-01-01 10:56 -0.466064
2013-01-01 10:57 -1.715347
2013-01-01 10:58 -0.634913
2013-01-01 10:59 -0.809471

[60 rows x 1 columns]
</pre> <p>As with <code>DatetimeIndex</code>, the endpoints will be included in the result. The example below slices data starting from 10:00 to 11:59.</p> <pre data-language="python">In [292]: dfp['2013-01-01 10H':'2013-01-01 11H']
Out[292]: 
                         A
2013-01-01 10:00 -0.569936
2013-01-01 10:01 -1.179183
2013-01-01 10:02 -0.838602
2013-01-01 10:03 -1.727539
2013-01-01 10:04  1.334027
2013-01-01 10:05  0.417423
2013-01-01 10:06 -0.221189
...                    ...
2013-01-01 11:53  0.616198
2013-01-01 11:54  2.843156
2013-01-01 11:55  0.572537
2013-01-01 11:56  1.709706
2013-01-01 11:57 -0.205490
2013-01-01 11:58  1.759719
2013-01-01 11:59 -1.181485

[120 rows x 1 columns]
</pre>   <h3 id="frequency-conversion-and-resampling-with-periodindex">Frequency Conversion and Resampling with PeriodIndex</h3> <p>The frequency of <code>Period</code> and <code>PeriodIndex</code> can be converted via the <code>asfreq</code> method. Let’s start with the fiscal year 2011, ending in December:</p> <pre data-language="python">In [293]: p = pd.Period('2011', freq='A-DEC')

In [294]: p
Out[294]: Period('2011', 'A-DEC')
</pre> <p>We can convert it to a monthly frequency. Using the <code>how</code> parameter, we can specify whether to return the starting or ending month:</p> <pre data-language="python">In [295]: p.asfreq('M', how='start')
Out[295]: Period('2011-01', 'M')

In [296]: p.asfreq('M', how='end')
Out[296]: Period('2011-12', 'M')
</pre> <p>The shorthands ‘s’ and ‘e’ are provided for convenience:</p> <pre data-language="python">In [297]: p.asfreq('M', 's')
Out[297]: Period('2011-01', 'M')

In [298]: p.asfreq('M', 'e')
Out[298]: Period('2011-12', 'M')
</pre> <p>Converting to a “super-period” (e.g., annual frequency is a super-period of quarterly frequency) automatically returns the super-period that includes the input period:</p> <pre data-language="python">In [299]: p = pd.Period('2011-12', freq='M')

In [300]: p.asfreq('A-NOV')
Out[300]: Period('2012', 'A-NOV')
</pre> <p>Note that since we converted to an annual frequency that ends the year in November, the monthly period of December 2011 is actually in the 2012 A-NOV period.</p> <p id="timeseries-quarterly">Period conversions with anchored frequencies are particularly useful for working with various quarterly data common to economics, business, and other fields. Many organizations define quarters relative to the month in which their fiscal year starts and ends. Thus, first quarter of 2011 could start in 2010 or a few months into 2011. Via anchored frequencies, pandas works for all quarterly frequencies <code>Q-JAN</code> through <code>Q-DEC</code>.</p> <p><code>Q-DEC</code> define regular calendar quarters:</p> <pre data-language="python">In [301]: p = pd.Period('2012Q1', freq='Q-DEC')

In [302]: p.asfreq('D', 's')
Out[302]: Period('2012-01-01', 'D')

In [303]: p.asfreq('D', 'e')
Out[303]: Period('2012-03-31', 'D')
</pre> <p><code>Q-MAR</code> defines fiscal year end in March:</p> <pre data-language="python">In [304]: p = pd.Period('2011Q4', freq='Q-MAR')

In [305]: p.asfreq('D', 's')
Out[305]: Period('2011-01-01', 'D')

In [306]: p.asfreq('D', 'e')
Out[306]: Period('2011-03-31', 'D')
</pre>    <h2 id="timeseries-interchange">Converting between Representations</h2> <p id="converting-between-representations">Timestamped data can be converted to PeriodIndex-ed data using <code>to_period</code> and vice-versa using <code>to_timestamp</code>:</p> <pre data-language="python">In [307]: rng = pd.date_range('1/1/2012', periods=5, freq='M')

In [308]: ts = pd.Series(np.random.randn(len(rng)), index=rng)

In [309]: ts
Out[309]: 
2012-01-31    2.167674
2012-02-29   -1.505130
2012-03-31    1.005802
2012-04-30    0.481525
2012-05-31   -0.352151
Freq: M, dtype: float64

In [310]: ps = ts.to_period()

In [311]: ps
Out[311]: 
2012-01    2.167674
2012-02   -1.505130
2012-03    1.005802
2012-04    0.481525
2012-05   -0.352151
Freq: M, dtype: float64

In [312]: ps.to_timestamp()
Out[312]: 
2012-01-01    2.167674
2012-02-01   -1.505130
2012-03-01    1.005802
2012-04-01    0.481525
2012-05-01   -0.352151
Freq: MS, dtype: float64
</pre> <p>Remember that ‘s’ and ‘e’ can be used to return the timestamps at the start or end of the period:</p> <pre data-language="python">In [313]: ps.to_timestamp('D', how='s')
Out[313]: 
2012-01-01    2.167674
2012-02-01   -1.505130
2012-03-01    1.005802
2012-04-01    0.481525
2012-05-01   -0.352151
Freq: MS, dtype: float64
</pre> <p>Converting between period and timestamp enables some convenient arithmetic functions to be used. In the following example, we convert a quarterly frequency with year ending in November to 9am of the end of the month following the quarter end:</p> <pre data-language="python">In [314]: prng = pd.period_range('1990Q1', '2000Q4', freq='Q-NOV')

In [315]: ts = pd.Series(np.random.randn(len(prng)), prng)

In [316]: ts.index = (prng.asfreq('M', 'e') + 1).asfreq('H', 's') + 9

In [317]: ts.head()
Out[317]: 
1990-03-01 09:00   -0.608988
1990-06-01 09:00    0.412294
1990-09-01 09:00   -0.715938
1990-12-01 09:00    1.297773
1991-03-01 09:00   -2.260765
Freq: H, dtype: float64
</pre>   <h2 id="timeseries-oob">Representing out-of-bounds spans</h2> <p id="representing-out-of-bounds-spans">If you have data that is outside of the <code>Timestamp</code> bounds, see <a class="reference internal" href="#timeseries-timestamp-limits">Timestamp limitations</a>, then you can use a <code>PeriodIndex</code> and/or <code>Series</code> of <code>Periods</code> to do computations.</p> <pre data-language="python">In [318]: span = pd.period_range('1215-01-01', '1381-01-01', freq='D')

In [319]: span
Out[319]: 
PeriodIndex(['1215-01-01', '1215-01-02', '1215-01-03', '1215-01-04',
             '1215-01-05', '1215-01-06', '1215-01-07', '1215-01-08',
             '1215-01-09', '1215-01-10',
             ...
             '1380-12-23', '1380-12-24', '1380-12-25', '1380-12-26',
             '1380-12-27', '1380-12-28', '1380-12-29', '1380-12-30',
             '1380-12-31', '1381-01-01'],
            dtype='int64', length=60632, freq='D')
</pre> <p>To convert from a <code>int64</code> based YYYYMMDD representation.</p> <pre data-language="python">In [320]: s = pd.Series([20121231, 20141130, 99991231])

In [321]: s
Out[321]: 
0    20121231
1    20141130
2    99991231
dtype: int64

In [322]: def conv(x):
   .....:     return pd.Period(year = x // 10000, month = x//100 % 100, day = x%100, freq='D')
   .....: 

In [323]: s.apply(conv)
Out[323]: 
0   2012-12-31
1   2014-11-30
2   9999-12-31
dtype: object

In [324]: s.apply(conv)[2]
Out[324]: Period('9999-12-31', 'D')
</pre> <p>These can easily be converted to a <code>PeriodIndex</code></p> <pre data-language="python">In [325]: span = pd.PeriodIndex(s.apply(conv))

In [326]: span
Out[326]: PeriodIndex(['2012-12-31', '2014-11-30', '9999-12-31'], dtype='int64', freq='D')
</pre>   <h2 id="timeseries-timezone">Time Zone Handling</h2> <p id="time-zone-handling">Pandas provides rich support for working with timestamps in different time zones using <code>pytz</code> and <code>dateutil</code> libraries. <code>dateutil</code> support is new in 0.14.1 and currently only supported for fixed offset and tzfile zones. The default library is <code>pytz</code>. Support for <code>dateutil</code> is provided for compatibility with other applications e.g. if you use <code>dateutil</code> in other python packages.</p>  <h3 id="working-with-time-zones">Working with Time Zones</h3> <p>By default, pandas objects are time zone unaware:</p> <pre data-language="python">In [327]: rng = pd.date_range('3/6/2012 00:00', periods=15, freq='D')

In [328]: rng.tz is None
Out[328]: True
</pre> <p>To supply the time zone, you can use the <code>tz</code> keyword to <code>date_range</code> and other functions. Dateutil time zone strings are distinguished from <code>pytz</code> time zones by starting with <code>dateutil/</code>.</p> <ul class="simple"> <li>In <code>pytz</code> you can find a list of common (and less common) time zones using <code>from pytz import common_timezones, all_timezones</code>.</li> <li>
<code>dateutil</code> uses the OS timezones so there isn’t a fixed list available. For common zones, the names are the same as <code>pytz</code>.</li> </ul> <pre data-language="python"># pytz
In [329]: rng_pytz = pd.date_range('3/6/2012 00:00', periods=10, freq='D',
   .....:                          tz='Europe/London')
   .....: 

In [330]: rng_pytz.tz
Out[330]: &lt;DstTzInfo 'Europe/London' LMT-1 day, 23:59:00 STD&gt;

# dateutil
In [331]: rng_dateutil = pd.date_range('3/6/2012 00:00', periods=10, freq='D',
   .....:                              tz='dateutil/Europe/London')
   .....: 

In [332]: rng_dateutil.tz
Out[332]: tzfile('/usr/share/zoneinfo/Europe/London')

# dateutil - utc special case
In [333]: rng_utc = pd.date_range('3/6/2012 00:00', periods=10, freq='D',
   .....:                         tz=dateutil.tz.tzutc())
   .....: 

In [334]: rng_utc.tz
Out[334]: tzutc()
</pre> <p>Note that the <code>UTC</code> timezone is a special case in <code>dateutil</code> and should be constructed explicitly as an instance of <code>dateutil.tz.tzutc</code>. You can also construct other timezones explicitly first, which gives you more control over which time zone is used:</p> <pre data-language="python"># pytz
In [335]: tz_pytz = pytz.timezone('Europe/London')

In [336]: rng_pytz = pd.date_range('3/6/2012 00:00', periods=10, freq='D',
   .....:                          tz=tz_pytz)
   .....: 

In [337]: rng_pytz.tz == tz_pytz
Out[337]: True

# dateutil
In [338]: tz_dateutil = dateutil.tz.gettz('Europe/London')

In [339]: rng_dateutil = pd.date_range('3/6/2012 00:00', periods=10, freq='D',
   .....:                              tz=tz_dateutil)
   .....: 

In [340]: rng_dateutil.tz == tz_dateutil
Out[340]: True
</pre> <p>Timestamps, like Python’s <code>datetime.datetime</code> object can be either time zone naive or time zone aware. Naive time series and DatetimeIndex objects can be <em>localized</em> using <code>tz_localize</code>:</p> <pre data-language="python">In [341]: ts = pd.Series(np.random.randn(len(rng)), rng)

In [342]: ts_utc = ts.tz_localize('UTC')

In [343]: ts_utc
Out[343]: 
2012-03-06 00:00:00+00:00    0.679135
2012-03-07 00:00:00+00:00    0.345668
2012-03-08 00:00:00+00:00   -1.143903
2012-03-09 00:00:00+00:00    0.487087
2012-03-10 00:00:00+00:00   -1.421073
2012-03-11 00:00:00+00:00   -0.327463
2012-03-12 00:00:00+00:00    0.169899
2012-03-13 00:00:00+00:00    0.867568
2012-03-14 00:00:00+00:00   -0.834122
2012-03-15 00:00:00+00:00   -1.698494
2012-03-16 00:00:00+00:00    0.974717
2012-03-17 00:00:00+00:00    0.966771
2012-03-18 00:00:00+00:00   -0.754168
2012-03-19 00:00:00+00:00   -1.434246
2012-03-20 00:00:00+00:00    0.848935
Freq: D, dtype: float64
</pre> <p>Again, you can explicitly construct the timezone object first. You can use the <code>tz_convert</code> method to convert pandas objects to convert tz-aware data to another time zone:</p> <pre data-language="python">In [344]: ts_utc.tz_convert('US/Eastern')
Out[344]: 
2012-03-05 19:00:00-05:00    0.679135
2012-03-06 19:00:00-05:00    0.345668
2012-03-07 19:00:00-05:00   -1.143903
2012-03-08 19:00:00-05:00    0.487087
2012-03-09 19:00:00-05:00   -1.421073
2012-03-10 19:00:00-05:00   -0.327463
2012-03-11 20:00:00-04:00    0.169899
2012-03-12 20:00:00-04:00    0.867568
2012-03-13 20:00:00-04:00   -0.834122
2012-03-14 20:00:00-04:00   -1.698494
2012-03-15 20:00:00-04:00    0.974717
2012-03-16 20:00:00-04:00    0.966771
2012-03-17 20:00:00-04:00   -0.754168
2012-03-18 20:00:00-04:00   -1.434246
2012-03-19 20:00:00-04:00    0.848935
Freq: D, dtype: float64
</pre> <div class="admonition warning"> <p class="first admonition-title">Warning</p> <p class="last">Be wary of conversions between libraries. For some zones <code>pytz</code> and <code>dateutil</code> have different definitions of the zone. This is more of a problem for unusual timezones than for ‘standard’ zones like <code>US/Eastern</code>.</p> </div> <div class="admonition warning"> <p class="first admonition-title">Warning</p> <p class="last">Be aware that a timezone definition across versions of timezone libraries may not be considered equal. This may cause problems when working with stored data that is localized using one version and operated on with a different version. See <a class="reference internal" href="../io/#io-hdf5-notes">here</a> for how to handle such a situation.</p> </div> <div class="admonition warning"> <p class="first admonition-title">Warning</p> <p class="last">It is incorrect to pass a timezone directly into the <code>datetime.datetime</code> constructor (e.g., <code>datetime.datetime(2011, 1, 1, tz=timezone('US/Eastern'))</code>. Instead, the datetime needs to be localized using the the localize method on the timezone.</p> </div> <p>Under the hood, all timestamps are stored in UTC. Scalar values from a <code>DatetimeIndex</code> with a time zone will have their fields (day, hour, minute) localized to the time zone. However, timestamps with the same UTC value are still considered to be equal even if they are in different time zones:</p> <pre data-language="python">In [345]: rng_eastern = rng_utc.tz_convert('US/Eastern')

In [346]: rng_berlin = rng_utc.tz_convert('Europe/Berlin')

In [347]: rng_eastern[5]
Out[347]: Timestamp('2012-03-10 19:00:00-0500', tz='US/Eastern', offset='D')

In [348]: rng_berlin[5]
Out[348]: Timestamp('2012-03-11 01:00:00+0100', tz='Europe/Berlin', offset='D')

In [349]: rng_eastern[5] == rng_berlin[5]
Out[349]: True
</pre> <p>Like <code>Series</code>, <code>DataFrame</code>, and <code>DatetimeIndex</code>, <code>Timestamp``s can be converted to other time zones using ``tz_convert</code>:</p> <pre data-language="python">In [350]: rng_eastern[5]
Out[350]: Timestamp('2012-03-10 19:00:00-0500', tz='US/Eastern', offset='D')

In [351]: rng_berlin[5]
Out[351]: Timestamp('2012-03-11 01:00:00+0100', tz='Europe/Berlin', offset='D')

In [352]: rng_eastern[5].tz_convert('Europe/Berlin')
Out[352]: Timestamp('2012-03-11 01:00:00+0100', tz='Europe/Berlin')
</pre> <p>Localization of <code>Timestamp</code> functions just like <code>DatetimeIndex</code> and <code>Series</code>:</p> <pre data-language="python">In [353]: rng[5]
Out[353]: Timestamp('2012-03-11 00:00:00', offset='D')

In [354]: rng[5].tz_localize('Asia/Shanghai')
Out[354]: Timestamp('2012-03-11 00:00:00+0800', tz='Asia/Shanghai')
</pre> <p>Operations between Series in different time zones will yield UTC Series, aligning the data on the UTC timestamps:</p> <pre data-language="python">In [355]: eastern = ts_utc.tz_convert('US/Eastern')

In [356]: berlin = ts_utc.tz_convert('Europe/Berlin')

In [357]: result = eastern + berlin

In [358]: result
Out[358]: 
2012-03-06 00:00:00+00:00    1.358269
2012-03-07 00:00:00+00:00    0.691336
2012-03-08 00:00:00+00:00   -2.287805
2012-03-09 00:00:00+00:00    0.974174
2012-03-10 00:00:00+00:00   -2.842146
2012-03-11 00:00:00+00:00   -0.654926
2012-03-12 00:00:00+00:00    0.339798
2012-03-13 00:00:00+00:00    1.735136
2012-03-14 00:00:00+00:00   -1.668245
2012-03-15 00:00:00+00:00   -3.396988
2012-03-16 00:00:00+00:00    1.949435
2012-03-17 00:00:00+00:00    1.933541
2012-03-18 00:00:00+00:00   -1.508335
2012-03-19 00:00:00+00:00   -2.868493
2012-03-20 00:00:00+00:00    1.697870
Freq: D, dtype: float64

In [359]: result.index
Out[359]: 
DatetimeIndex(['2012-03-06', '2012-03-07', '2012-03-08', '2012-03-09',
               '2012-03-10', '2012-03-11', '2012-03-12', '2012-03-13',
               '2012-03-14', '2012-03-15', '2012-03-16', '2012-03-17',
               '2012-03-18', '2012-03-19', '2012-03-20'],
              dtype='datetime64[ns, UTC]', freq='D')
</pre> <p>To remove timezone from tz-aware <code>DatetimeIndex</code>, use <code>tz_localize(None)</code> or <code>tz_convert(None)</code>. <code>tz_localize(None)</code> will remove timezone holding local time representations. <code>tz_convert(None)</code> will remove timezone after converting to UTC time.</p> <pre data-language="python">In [360]: didx = pd.DatetimeIndex(start='2014-08-01 09:00', freq='H', periods=10, tz='US/Eastern')

In [361]: didx
Out[361]: 
DatetimeIndex(['2014-08-01 09:00:00-04:00', '2014-08-01 10:00:00-04:00',
               '2014-08-01 11:00:00-04:00', '2014-08-01 12:00:00-04:00',
               '2014-08-01 13:00:00-04:00', '2014-08-01 14:00:00-04:00',
               '2014-08-01 15:00:00-04:00', '2014-08-01 16:00:00-04:00',
               '2014-08-01 17:00:00-04:00', '2014-08-01 18:00:00-04:00'],
              dtype='datetime64[ns, US/Eastern]', freq='H')

In [362]: didx.tz_localize(None)
Out[362]: 
DatetimeIndex(['2014-08-01 09:00:00', '2014-08-01 10:00:00',
               '2014-08-01 11:00:00', '2014-08-01 12:00:00',
               '2014-08-01 13:00:00', '2014-08-01 14:00:00',
               '2014-08-01 15:00:00', '2014-08-01 16:00:00',
               '2014-08-01 17:00:00', '2014-08-01 18:00:00'],
              dtype='datetime64[ns]', freq='H')

In [363]: didx.tz_convert(None)
Out[363]: 
DatetimeIndex(['2014-08-01 13:00:00', '2014-08-01 14:00:00',
               '2014-08-01 15:00:00', '2014-08-01 16:00:00',
               '2014-08-01 17:00:00', '2014-08-01 18:00:00',
               '2014-08-01 19:00:00', '2014-08-01 20:00:00',
               '2014-08-01 21:00:00', '2014-08-01 22:00:00'],
              dtype='datetime64[ns]', freq='H')

# tz_convert(None) is identical with tz_convert('UTC').tz_localize(None)
In [364]: didx.tz_convert('UCT').tz_localize(None)
Out[364]: 
DatetimeIndex(['2014-08-01 13:00:00', '2014-08-01 14:00:00',
               '2014-08-01 15:00:00', '2014-08-01 16:00:00',
               '2014-08-01 17:00:00', '2014-08-01 18:00:00',
               '2014-08-01 19:00:00', '2014-08-01 20:00:00',
               '2014-08-01 21:00:00', '2014-08-01 22:00:00'],
              dtype='datetime64[ns]', freq='H')
</pre>   <h3 id="timeseries-timezone-ambiguous">Ambiguous Times when Localizing</h3> <p id="ambiguous-times-when-localizing">In some cases, localize cannot determine the DST and non-DST hours when there are duplicates. This often happens when reading files or database records that simply duplicate the hours. Passing <code>ambiguous='infer'</code> (<code>infer_dst</code> argument in prior releases) into <code>tz_localize</code> will attempt to determine the right offset. Below the top example will fail as it contains ambiguous times and the bottom will infer the right offset.</p> <pre data-language="python">In [365]: rng_hourly = pd.DatetimeIndex(['11/06/2011 00:00', '11/06/2011 01:00',
   .....:                                '11/06/2011 01:00', '11/06/2011 02:00',
   .....:                                '11/06/2011 03:00'])
   .....: 
</pre> <p>This will fail as there are ambiguous times</p> <pre data-language="python">In [2]: rng_hourly.tz_localize('US/Eastern')
AmbiguousTimeError: Cannot infer dst time from Timestamp('2011-11-06 01:00:00'), try using the 'ambiguous' argument
</pre> <p>Infer the ambiguous times</p> <pre data-language="python">In [366]: rng_hourly_eastern = rng_hourly.tz_localize('US/Eastern', ambiguous='infer')

In [367]: rng_hourly_eastern.tolist()
Out[367]: 
[Timestamp('2011-11-06 00:00:00-0400', tz='US/Eastern'),
 Timestamp('2011-11-06 01:00:00-0400', tz='US/Eastern'),
 Timestamp('2011-11-06 01:00:00-0500', tz='US/Eastern'),
 Timestamp('2011-11-06 02:00:00-0500', tz='US/Eastern'),
 Timestamp('2011-11-06 03:00:00-0500', tz='US/Eastern')]
</pre> <p>In addition to ‘infer’, there are several other arguments supported. Passing an array-like of bools or 0s/1s where True represents a DST hour and False a non-DST hour, allows for distinguishing more than one DST transition (e.g., if you have multiple records in a database each with their own DST transition). Or passing ‘NaT’ will fill in transition times with not-a-time values. These methods are available in the <code>DatetimeIndex</code> constructor as well as <code>tz_localize</code>.</p> <pre data-language="python">In [368]: rng_hourly_dst = np.array([1, 1, 0, 0, 0])

In [369]: rng_hourly.tz_localize('US/Eastern', ambiguous=rng_hourly_dst).tolist()
Out[369]: 
[Timestamp('2011-11-06 00:00:00-0400', tz='US/Eastern'),
 Timestamp('2011-11-06 01:00:00-0400', tz='US/Eastern'),
 Timestamp('2011-11-06 01:00:00-0500', tz='US/Eastern'),
 Timestamp('2011-11-06 02:00:00-0500', tz='US/Eastern'),
 Timestamp('2011-11-06 03:00:00-0500', tz='US/Eastern')]

In [370]: rng_hourly.tz_localize('US/Eastern', ambiguous='NaT').tolist()
Out[370]: 
[Timestamp('2011-11-06 00:00:00-0400', tz='US/Eastern'),
 NaT,
 NaT,
 Timestamp('2011-11-06 02:00:00-0500', tz='US/Eastern'),
 Timestamp('2011-11-06 03:00:00-0500', tz='US/Eastern')]

In [371]: didx = pd.DatetimeIndex(start='2014-08-01 09:00', freq='H', periods=10, tz='US/Eastern')

In [372]: didx
Out[372]: 
DatetimeIndex(['2014-08-01 09:00:00-04:00', '2014-08-01 10:00:00-04:00',
               '2014-08-01 11:00:00-04:00', '2014-08-01 12:00:00-04:00',
               '2014-08-01 13:00:00-04:00', '2014-08-01 14:00:00-04:00',
               '2014-08-01 15:00:00-04:00', '2014-08-01 16:00:00-04:00',
               '2014-08-01 17:00:00-04:00', '2014-08-01 18:00:00-04:00'],
              dtype='datetime64[ns, US/Eastern]', freq='H')

In [373]: didx.tz_localize(None)
Out[373]: 
DatetimeIndex(['2014-08-01 09:00:00', '2014-08-01 10:00:00',
               '2014-08-01 11:00:00', '2014-08-01 12:00:00',
               '2014-08-01 13:00:00', '2014-08-01 14:00:00',
               '2014-08-01 15:00:00', '2014-08-01 16:00:00',
               '2014-08-01 17:00:00', '2014-08-01 18:00:00'],
              dtype='datetime64[ns]', freq='H')

In [374]: didx.tz_convert(None)
Out[374]: 
DatetimeIndex(['2014-08-01 13:00:00', '2014-08-01 14:00:00',
               '2014-08-01 15:00:00', '2014-08-01 16:00:00',
               '2014-08-01 17:00:00', '2014-08-01 18:00:00',
               '2014-08-01 19:00:00', '2014-08-01 20:00:00',
               '2014-08-01 21:00:00', '2014-08-01 22:00:00'],
              dtype='datetime64[ns]', freq='H')

# tz_convert(None) is identical with tz_convert('UTC').tz_localize(None)
In [375]: didx.tz_convert('UCT').tz_localize(None)
Out[375]: 
DatetimeIndex(['2014-08-01 13:00:00', '2014-08-01 14:00:00',
               '2014-08-01 15:00:00', '2014-08-01 16:00:00',
               '2014-08-01 17:00:00', '2014-08-01 18:00:00',
               '2014-08-01 19:00:00', '2014-08-01 20:00:00',
               '2014-08-01 21:00:00', '2014-08-01 22:00:00'],
              dtype='datetime64[ns]', freq='H')
</pre>   <h3 id="timeseries-timezone-series">TZ aware Dtypes</h3> <div class="versionadded" id="tz-aware-dtypes"> <p><span class="versionmodified">New in version 0.17.0.</span></p> </div> <p><code>Series/DatetimeIndex</code> with a timezone <strong>naive</strong> value are represented with a dtype of <code>datetime64[ns]</code>.</p> <pre data-language="python">In [376]: s_naive = pd.Series(pd.date_range('20130101',periods=3))

In [377]: s_naive
Out[377]: 
0   2013-01-01
1   2013-01-02
2   2013-01-03
dtype: datetime64[ns]
</pre> <p><code>Series/DatetimeIndex</code> with a timezone <strong>aware</strong> value are represented with a dtype of <code>datetime64[ns, tz]</code>.</p> <pre data-language="python">In [378]: s_aware = pd.Series(pd.date_range('20130101',periods=3,tz='US/Eastern'))

In [379]: s_aware
Out[379]: 
0   2013-01-01 00:00:00-05:00
1   2013-01-02 00:00:00-05:00
2   2013-01-03 00:00:00-05:00
dtype: datetime64[ns, US/Eastern]
</pre> <p>Both of these <code>Series</code> can be manipulated via the <code>.dt</code> accessor, see <a class="reference internal" href="../basics/#basics-dt-accessors">here</a>.</p> <p>For example, to localize and convert a naive stamp to timezone aware.</p> <pre data-language="python">In [380]: s_naive.dt.tz_localize('UTC').dt.tz_convert('US/Eastern')
Out[380]: 
0   2012-12-31 19:00:00-05:00
1   2013-01-01 19:00:00-05:00
2   2013-01-02 19:00:00-05:00
dtype: datetime64[ns, US/Eastern]
</pre> <p>Further more you can <code>.astype(...)</code> timezone aware (and naive). This operation is effectively a localize AND convert on a naive stamp, and a convert on an aware stamp.</p> <pre data-language="python"># localize and convert a naive timezone
In [381]: s_naive.astype('datetime64[ns, US/Eastern]')
Out[381]: 
0   2012-12-31 19:00:00-05:00
1   2013-01-01 19:00:00-05:00
2   2013-01-02 19:00:00-05:00
dtype: datetime64[ns, US/Eastern]

# make an aware tz naive
In [382]: s_aware.astype('datetime64[ns]')
Out[382]: 
0   2013-01-01 05:00:00
1   2013-01-02 05:00:00
2   2013-01-03 05:00:00
dtype: datetime64[ns]

# convert to a new timezone
In [383]: s_aware.astype('datetime64[ns, CET]')
Out[383]: 
0   2013-01-01 06:00:00+01:00
1   2013-01-02 06:00:00+01:00
2   2013-01-03 06:00:00+01:00
dtype: datetime64[ns, CET]
</pre> <div class="admonition note"> <p class="first admonition-title">Note</p> <p>Using the <code>.values</code> accessor on a <code>Series</code>, returns an numpy array of the data. These values are converted to UTC, as numpy does not currently support timezones (even though it is <em>printing</em> in the local timezone!).</p> <pre data-language="python">In [384]: s_naive.values
Out[384]: 
array(['2012-12-31T18:00:00.000000000-0600',
       '2013-01-01T18:00:00.000000000-0600',
       '2013-01-02T18:00:00.000000000-0600'], dtype='datetime64[ns]')

In [385]: s_aware.values
Out[385]: 
array(['2012-12-31T23:00:00.000000000-0600',
       '2013-01-01T23:00:00.000000000-0600',
       '2013-01-02T23:00:00.000000000-0600'], dtype='datetime64[ns]')
</pre> <p>Further note that once converted to a numpy array these would lose the tz tenor.</p> <pre data-language="python">In [386]: pd.Series(s_aware.values)
Out[386]: 
0   2013-01-01 05:00:00
1   2013-01-02 05:00:00
2   2013-01-03 05:00:00
dtype: datetime64[ns]
</pre> <p>However, these can be easily converted</p> <pre data-language="python">In [387]: pd.Series(s_aware.values).dt.tz_localize('UTC').dt.tz_convert('US/Eastern')
Out[387]: 
0   2013-01-01 00:00:00-05:00
1   2013-01-02 00:00:00-05:00
2   2013-01-03 00:00:00-05:00
dtype: datetime64[ns, US/Eastern]
</pre> </div>
<div class="_attribution">
  <p class="_attribution-p">
    © 2011–2012 Lambda Foundry, Inc. and PyData Development Team<br>© 2008–2011 AQR Capital Management, LLC<br>© 2008–2014 the pandas development team<br>Licensed under the 3-clause BSD License.<br>
    <a href="http://pandas.pydata.org/pandas-docs/version/0.18.1/timeseries.html" class="_attribution-link" target="_blank">http://pandas.pydata.org/pandas-docs/version/0.18.1/timeseries.html</a>
  </p>
</div>

			</div>
		</div>
	</section>

	</div>
</body>
</html>
