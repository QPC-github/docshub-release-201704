
<!DOCTYPE HTML>

<html lang="en">

<head>
  <meta charset="utf-8">
  <title>Neural Network - TensorFlow Python - W3cubDocs</title>
  
  <meta name="description" content="The activation ops provide different types of nonlinearities for use in neural networks. These include smooth nonlinearities (sigmoid, tanh, elu, &hellip;">
  <meta name="keywords" content="neural, network, -, tensorflow, python, tensorflow~python">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="http://docs.w3cub.com/tensorflow~python/nn/">
  <link href="/favicon.png" rel="icon">
  <link type="text/css" rel="stylesheet" href="/assets/application-50364fff564ce3b6327021805f3f00e2957b441cf27f576a7dd4ff63bbc47047.css">
  <script type="text/javascript" src="/assets/application-db64bfd54ceb42be11af7995804cf4902548419ceb79d509b0b7d62c22d98e6f.js"></script>
  <script src="/json/tensorflow~python.js"></script>
  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-71174418-1']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>


</head>

<body>
	<div class="_app">
	<header class="_header">
  
  <form class="_search">
    <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
    <a class="_search-clear"></a>
    <div class="_search-tag"></div>
  </form>
  
  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/tensorflow~python/" class="_nav-link" title="" style="margin-left:0;">TensorFlow Python</a></span>
  
  <nav class="_nav">
    <a href="/app/" class="_nav-link ">App</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		<div class="_list">
			
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<div class="_page _tensorflow">
				
<h1 itemprop="name" class="devsite-page-title"> Neural Network </h1>     <blockquote class="note">
<strong>Note:</strong><span> Functions taking <code>Tensor</code> arguments can also take anything accepted by <a href="https://www.tensorflow.org/api_docs/python/tf/convert_to_tensor" target="_blank"><code>tf.convert_to_tensor</code></a>.</span>
</blockquote> <h2 id="Activation_Functions">Activation Functions</h2> <p>The activation ops provide different types of nonlinearities for use in neural networks. These include smooth nonlinearities (<code>sigmoid</code>, <code>tanh</code>, <code>elu</code>, <code>softplus</code>, and <code>softsign</code>), continuous but not everywhere differentiable functions (<code>relu</code>, <code>relu6</code>, <code>crelu</code> and <code>relu_x</code>), and random regularization (<code>dropout</code>).</p> <p>All activation ops apply componentwise, and produce a tensor of the same shape as the input tensor.</p> <ul> <li><a href="https://www.tensorflow.org/api_docs/python/tf/nn/relu" target="_blank"><code>tf.nn.relu</code></a></li> <li><a href="https://www.tensorflow.org/api_docs/python/tf/nn/relu6" target="_blank"><code>tf.nn.relu6</code></a></li> <li><a href="https://www.tensorflow.org/api_docs/python/tf/nn/crelu" target="_blank"><code>tf.nn.crelu</code></a></li> <li><a href="https://www.tensorflow.org/api_docs/python/tf/nn/elu" target="_blank"><code>tf.nn.elu</code></a></li> <li><a href="https://www.tensorflow.org/api_docs/python/tf/nn/softplus" target="_blank"><code>tf.nn.softplus</code></a></li> <li><a href="https://www.tensorflow.org/api_docs/python/tf/nn/softsign" target="_blank"><code>tf.nn.softsign</code></a></li> <li><a href="https://www.tensorflow.org/api_docs/python/tf/nn/dropout" target="_blank"><code>tf.nn.dropout</code></a></li> <li><a href="https://www.tensorflow.org/api_docs/python/tf/nn/bias_add" target="_blank"><code>tf.nn.bias_add</code></a></li> <li><a href="https://www.tensorflow.org/api_docs/python/tf/sigmoid" target="_blank"><code>tf.sigmoid</code></a></li> <li><a href="https://www.tensorflow.org/api_docs/python/tf/tanh" target="_blank"><code>tf.tanh</code></a></li> </ul> <h2 id="Convolution">Convolution</h2> <p>The convolution ops sweep a 2-D filter over a batch of images, applying the filter to each window of each image of the appropriate size. The different ops trade off between generic vs. specific filters:</p> <ul> <li>
<code>conv2d</code>: Arbitrary filters that can mix channels together.</li> <li>
<code>depthwise_conv2d</code>: Filters that operate on each channel independently.</li> <li>
<code>separable_conv2d</code>: A depthwise spatial filter followed by a pointwise filter.</li> </ul> <p>Note that although these ops are called "convolution", they are strictly speaking "cross-correlation" since the filter is combined with an input window without reversing the filter. For details, see <a href="https://en.wikipedia.org/wiki/Cross-correlation#Properties" target="_blank">the properties of cross-correlation</a>.</p> <p>The filter is applied to image patches of the same size as the filter and strided according to the <code>strides</code> argument. <code>strides = [1, 1, 1, 1]</code> applies the filter to a patch at every offset, <code>strides = [1, 2, 2, 1]</code> applies the filter to every other image patch in each dimension, etc.</p> <p>Ignoring channels for the moment, and assume that the 4-D <code>input</code> has shape <code>[batch, in_height, in_width, ...]</code> and the 4-D <code>filter</code> has shape <code>[filter_height, filter_width, ...]</code>, then the spatial semantics of the convolution ops are as follows: first, according to the padding scheme chosen as <code>'SAME'</code> or <code>'VALID'</code>, the output size and the padding pixels are computed. For the <code>'SAME'</code> padding, the output height and width are computed as:</p> <pre class="prettyprint notranslate" translate="no" data-language="python">out_height = ceil(float(in_height) / float(strides[1]))
out_width  = ceil(float(in_width) / float(strides[2]))
</pre> <p>and the padding on the top and left are computed as:</p> <pre class="prettyprint notranslate" translate="no" data-language="python">pad_along_height = max((out_height - 1) * strides[1] +
                    filter_height - in_height, 0)
pad_along_width = max((out_width - 1) * strides[2] +
                   filter_width - in_width, 0)
pad_top = pad_along_height // 2
pad_bottom = pad_along_height - pad_top
pad_left = pad_along_width // 2
pad_right = pad_along_width - pad_left
</pre> <p>Note that the division by 2 means that there might be cases when the padding on both sides (top vs bottom, right vs left) are off by one. In this case, the bottom and right sides always get the one additional padded pixel. For example, when <code>pad_along_height</code> is 5, we pad 2 pixels at the top and 3 pixels at the bottom. Note that this is different from existing libraries such as cuDNN and Caffe, which explicitly specify the number of padded pixels and always pad the same number of pixels on both sides.</p> <p>For the <code>'VALID</code>' padding, the output height and width are computed as:</p> <pre class="prettyprint notranslate" translate="no" data-language="python">out_height = ceil(float(in_height - filter_height + 1) / float(strides[1]))
out_width  = ceil(float(in_width - filter_width + 1) / float(strides[2]))
</pre> <p>and the padding values are always zero. The output is then computed as</p> <pre class="prettyprint notranslate" translate="no" data-language="python">output[b, i, j, :] =
    sum_{di, dj} input[b, strides[1] * i + di - pad_top,
                       strides[2] * j + dj - pad_left, ...] *
                 filter[di, dj, ...]
</pre> <p>where any value outside the original input image region are considered zero ( i.e. we pad zero values around the border of the image).</p> <p>Since <code>input</code> is 4-D, each <code>input[b, i, j, :]</code> is a vector. For <code>conv2d</code>, these vectors are multiplied by the <code>filter[di, dj, :, :]</code> matrices to produce new vectors. For <code>depthwise_conv_2d</code>, each scalar component <code>input[b, i, j, k]</code> is multiplied by a vector <code>filter[di, dj, k]</code>, and all the vectors are concatenated.</p> <ul> <li><a href="https://www.tensorflow.org/api_docs/python/tf/nn/convolution" target="_blank"><code>tf.nn.convolution</code></a></li> <li><a href="https://www.tensorflow.org/api_docs/python/tf/nn/conv2d" target="_blank"><code>tf.nn.conv2d</code></a></li> <li><a href="https://www.tensorflow.org/api_docs/python/tf/nn/depthwise_conv2d" target="_blank"><code>tf.nn.depthwise_conv2d</code></a></li> <li><a href="https://www.tensorflow.org/api_docs/python/tf/nn/depthwise_conv2d_native" target="_blank"><code>tf.nn.depthwise_conv2d_native</code></a></li> <li><a href="https://www.tensorflow.org/api_docs/python/tf/nn/separable_conv2d" target="_blank"><code>tf.nn.separable_conv2d</code></a></li> <li><a href="https://www.tensorflow.org/api_docs/python/tf/nn/atrous_conv2d" target="_blank"><code>tf.nn.atrous_conv2d</code></a></li> <li><a href="https://www.tensorflow.org/api_docs/python/tf/nn/atrous_conv2d_transpose" target="_blank"><code>tf.nn.atrous_conv2d_transpose</code></a></li> <li><a href="https://www.tensorflow.org/api_docs/python/tf/nn/conv2d_transpose" target="_blank"><code>tf.nn.conv2d_transpose</code></a></li> <li><a href="https://www.tensorflow.org/api_docs/python/tf/nn/conv1d" target="_blank"><code>tf.nn.conv1d</code></a></li> <li><a href="https://www.tensorflow.org/api_docs/python/tf/nn/conv3d" target="_blank"><code>tf.nn.conv3d</code></a></li> <li><a href="https://www.tensorflow.org/api_docs/python/tf/nn/conv3d_transpose" target="_blank"><code>tf.nn.conv3d_transpose</code></a></li> <li><a href="https://www.tensorflow.org/api_docs/python/tf/nn/conv2d_backprop_filter" target="_blank"><code>tf.nn.conv2d_backprop_filter</code></a></li> <li><a href="https://www.tensorflow.org/api_docs/python/tf/nn/conv2d_backprop_input" target="_blank"><code>tf.nn.conv2d_backprop_input</code></a></li> <li><a href="https://www.tensorflow.org/api_docs/python/tf/nn/conv3d_backprop_filter_v2" target="_blank"><code>tf.nn.conv3d_backprop_filter_v2</code></a></li> <li><a href="https://www.tensorflow.org/api_docs/python/tf/nn/depthwise_conv2d_native_backprop_filter" target="_blank"><code>tf.nn.depthwise_conv2d_native_backprop_filter</code></a></li> <li><a href="https://www.tensorflow.org/api_docs/python/tf/nn/depthwise_conv2d_native_backprop_input" target="_blank"><code>tf.nn.depthwise_conv2d_native_backprop_input</code></a></li> </ul> <h2 id="Pooling">Pooling</h2> <p>The pooling ops sweep a rectangular window over the input tensor, computing a reduction operation for each window (average, max, or max with argmax). Each pooling op uses rectangular windows of size <code>ksize</code> separated by offset <code>strides</code>. For example, if <code>strides</code> is all ones every window is used, if <code>strides</code> is all twos every other window is used in each dimension, etc.</p> <p>In detail, the output is</p> <pre class="prettyprint notranslate" translate="no" data-language="python">output[i] = reduce(value[strides * i:strides * i + ksize])
</pre> <p>where the indices also take into consideration the padding values. Please refer to the <code>Convolution</code> section for details about the padding calculation.</p> <ul> <li><a href="https://www.tensorflow.org/api_docs/python/tf/nn/avg_pool" target="_blank"><code>tf.nn.avg_pool</code></a></li> <li><a href="https://www.tensorflow.org/api_docs/python/tf/nn/max_pool" target="_blank"><code>tf.nn.max_pool</code></a></li> <li><a href="https://www.tensorflow.org/api_docs/python/tf/nn/max_pool_with_argmax" target="_blank"><code>tf.nn.max_pool_with_argmax</code></a></li> <li><a href="https://www.tensorflow.org/api_docs/python/tf/nn/avg_pool3d" target="_blank"><code>tf.nn.avg_pool3d</code></a></li> <li><a href="https://www.tensorflow.org/api_docs/python/tf/nn/max_pool3d" target="_blank"><code>tf.nn.max_pool3d</code></a></li> <li><a href="https://www.tensorflow.org/api_docs/python/tf/nn/fractional_avg_pool" target="_blank"><code>tf.nn.fractional_avg_pool</code></a></li> <li><a href="https://www.tensorflow.org/api_docs/python/tf/nn/fractional_max_pool" target="_blank"><code>tf.nn.fractional_max_pool</code></a></li> <li><a href="https://www.tensorflow.org/api_docs/python/tf/nn/pool" target="_blank"><code>tf.nn.pool</code></a></li> </ul> <h2 id="Morphological_filtering">Morphological filtering</h2> <p>Morphological operators are non-linear filters used in image processing.</p> <p><a href="https://en.wikipedia.org/wiki/Dilation_(morphology)" target="_blank">Greyscale morphological dilation </a> is the max-sum counterpart of standard sum-product convolution:</p> <pre class="prettyprint notranslate" translate="no" data-language="python">output[b, y, x, c] =
    max_{dy, dx} input[b,
                       strides[1] * y + rates[1] * dy,
                       strides[2] * x + rates[2] * dx,
                       c] +
                 filter[dy, dx, c]
</pre> <p>The <code>filter</code> is usually called structuring function. Max-pooling is a special case of greyscale morphological dilation when the filter assumes all-zero values (a.k.a. flat structuring function).</p> <p><a href="https://en.wikipedia.org/wiki/Erosion_(morphology)" target="_blank">Greyscale morphological erosion </a> is the min-sum counterpart of standard sum-product convolution:</p> <pre class="prettyprint notranslate" translate="no" data-language="python">output[b, y, x, c] =
    min_{dy, dx} input[b,
                       strides[1] * y - rates[1] * dy,
                       strides[2] * x - rates[2] * dx,
                       c] -
                 filter[dy, dx, c]
</pre> <p>Dilation and erosion are dual to each other. The dilation of the input signal <code>f</code> by the structuring signal <code>g</code> is equal to the negation of the erosion of <code>-f</code> by the reflected <code>g</code>, and vice versa.</p> <p>Striding and padding is carried out in exactly the same way as in standard convolution. Please refer to the <code>Convolution</code> section for details.</p> <ul> <li><a href="https://www.tensorflow.org/api_docs/python/tf/nn/dilation2d" target="_blank"><code>tf.nn.dilation2d</code></a></li> <li><a href="https://www.tensorflow.org/api_docs/python/tf/nn/erosion2d" target="_blank"><code>tf.nn.erosion2d</code></a></li> <li><a href="https://www.tensorflow.org/api_docs/python/tf/nn/with_space_to_batch" target="_blank"><code>tf.nn.with_space_to_batch</code></a></li> </ul> <h2 id="Normalization">Normalization</h2> <p>Normalization is useful to prevent neurons from saturating when inputs may have varying scale, and to aid generalization.</p> <ul> <li><a href="https://www.tensorflow.org/api_docs/python/tf/nn/l2_normalize" target="_blank"><code>tf.nn.l2_normalize</code></a></li> <li><a href="https://www.tensorflow.org/api_docs/python/tf/nn/local_response_normalization" target="_blank"><code>tf.nn.local_response_normalization</code></a></li> <li><a href="https://www.tensorflow.org/api_docs/python/tf/nn/sufficient_statistics" target="_blank"><code>tf.nn.sufficient_statistics</code></a></li> <li><a href="https://www.tensorflow.org/api_docs/python/tf/nn/normalize_moments" target="_blank"><code>tf.nn.normalize_moments</code></a></li> <li><a href="https://www.tensorflow.org/api_docs/python/tf/nn/moments" target="_blank"><code>tf.nn.moments</code></a></li> <li><a href="https://www.tensorflow.org/api_docs/python/tf/nn/weighted_moments" target="_blank"><code>tf.nn.weighted_moments</code></a></li> <li><a href="https://www.tensorflow.org/api_docs/python/tf/nn/fused_batch_norm" target="_blank"><code>tf.nn.fused_batch_norm</code></a></li> <li><a href="https://www.tensorflow.org/api_docs/python/tf/nn/batch_normalization" target="_blank"><code>tf.nn.batch_normalization</code></a></li> <li><a href="https://www.tensorflow.org/api_docs/python/tf/nn/batch_norm_with_global_normalization" target="_blank"><code>tf.nn.batch_norm_with_global_normalization</code></a></li> </ul> <h2 id="Losses">Losses</h2> <p>The loss ops measure error between two tensors, or between a tensor and zero. These can be used for measuring accuracy of a network in a regression task or for regularization purposes (weight decay).</p> <ul> <li><a href="https://www.tensorflow.org/api_docs/python/tf/nn/l2_loss" target="_blank"><code>tf.nn.l2_loss</code></a></li> <li><a href="https://www.tensorflow.org/api_docs/python/tf/nn/log_poisson_loss" target="_blank"><code>tf.nn.log_poisson_loss</code></a></li> </ul> <h2 id="Classification">Classification</h2> <p>TensorFlow provides several operations that help you perform classification.</p> <ul> <li><a href="https://www.tensorflow.org/api_docs/python/tf/nn/sigmoid_cross_entropy_with_logits" target="_blank"><code>tf.nn.sigmoid_cross_entropy_with_logits</code></a></li> <li><a href="https://www.tensorflow.org/api_docs/python/tf/nn/softmax" target="_blank"><code>tf.nn.softmax</code></a></li> <li><a href="https://www.tensorflow.org/api_docs/python/tf/nn/log_softmax" target="_blank"><code>tf.nn.log_softmax</code></a></li> <li><a href="https://www.tensorflow.org/api_docs/python/tf/nn/softmax_cross_entropy_with_logits" target="_blank"><code>tf.nn.softmax_cross_entropy_with_logits</code></a></li> <li><a href="https://www.tensorflow.org/api_docs/python/tf/nn/sparse_softmax_cross_entropy_with_logits" target="_blank"><code>tf.nn.sparse_softmax_cross_entropy_with_logits</code></a></li> <li><a href="https://www.tensorflow.org/api_docs/python/tf/nn/weighted_cross_entropy_with_logits" target="_blank"><code>tf.nn.weighted_cross_entropy_with_logits</code></a></li> </ul> <h2 id="Embeddings">Embeddings</h2> <p>TensorFlow provides library support for looking up values in embedding tensors.</p> <ul> <li><a href="https://www.tensorflow.org/api_docs/python/tf/nn/embedding_lookup" target="_blank"><code>tf.nn.embedding_lookup</code></a></li> <li><a href="https://www.tensorflow.org/api_docs/python/tf/nn/embedding_lookup_sparse" target="_blank"><code>tf.nn.embedding_lookup_sparse</code></a></li> </ul> <h2 id="Recurrent_Neural_Networks">Recurrent Neural Networks</h2> <p>TensorFlow provides a number of methods for constructing Recurrent Neural Networks. Most accept an <code>RNNCell</code>-subclassed object (see the documentation for <code>tf.contrib.rnn</code>).</p> <ul> <li><a href="https://www.tensorflow.org/api_docs/python/tf/nn/dynamic_rnn" target="_blank"><code>tf.nn.dynamic_rnn</code></a></li> <li><a href="https://www.tensorflow.org/api_docs/python/tf/nn/bidirectional_dynamic_rnn" target="_blank"><code>tf.nn.bidirectional_dynamic_rnn</code></a></li> <li><a href="https://www.tensorflow.org/api_docs/python/tf/nn/raw_rnn" target="_blank"><code>tf.nn.raw_rnn</code></a></li> </ul> <h2 id="Connectionist_Temporal_Classification_CTC_">Connectionist Temporal Classification (CTC)</h2> <ul> <li><a href="https://www.tensorflow.org/api_docs/python/tf/nn/ctc_loss" target="_blank"><code>tf.nn.ctc_loss</code></a></li> <li><a href="https://www.tensorflow.org/api_docs/python/tf/nn/ctc_greedy_decoder" target="_blank"><code>tf.nn.ctc_greedy_decoder</code></a></li> <li><a href="https://www.tensorflow.org/api_docs/python/tf/nn/ctc_beam_search_decoder" target="_blank"><code>tf.nn.ctc_beam_search_decoder</code></a></li> </ul> <h2 id="Evaluation">Evaluation</h2> <p>The evaluation ops are useful for measuring the performance of a network. They are typically used at evaluation time.</p> <ul> <li><a href="https://www.tensorflow.org/api_docs/python/tf/nn/top_k" target="_blank"><code>tf.nn.top_k</code></a></li> <li><a href="https://www.tensorflow.org/api_docs/python/tf/nn/in_top_k" target="_blank"><code>tf.nn.in_top_k</code></a></li> </ul> <h2 id="Candidate_Sampling">Candidate Sampling</h2> <p>Do you want to train a multiclass or multilabel model with thousands or millions of output classes (for example, a language model with a large vocabulary)? Training with a full Softmax is slow in this case, since all of the classes are evaluated for every training example. Candidate Sampling training algorithms can speed up your step times by only considering a small randomly-chosen subset of contrastive classes (called candidates) for each batch of training examples.</p> <p>See our <a href="https://www.tensorflow.org/extras/candidate_sampling.pdf" target="_blank">Candidate Sampling Algorithms Reference</a></p> <h3 id="sampled_loss_functions">Sampled Loss Functions</h3> <p>TensorFlow provides the following sampled loss functions for faster training.</p> <ul> <li><a href="https://www.tensorflow.org/api_docs/python/tf/nn/nce_loss" target="_blank"><code>tf.nn.nce_loss</code></a></li> <li><a href="https://www.tensorflow.org/api_docs/python/tf/nn/sampled_softmax_loss" target="_blank"><code>tf.nn.sampled_softmax_loss</code></a></li> </ul> <h3 id="candidate_samplers">Candidate Samplers</h3> <p>TensorFlow provides the following samplers for randomly sampling candidate classes when using one of the sampled loss functions above.</p> <ul> <li><a href="https://www.tensorflow.org/api_docs/python/tf/nn/uniform_candidate_sampler" target="_blank"><code>tf.nn.uniform_candidate_sampler</code></a></li> <li><a href="https://www.tensorflow.org/api_docs/python/tf/nn/log_uniform_candidate_sampler" target="_blank"><code>tf.nn.log_uniform_candidate_sampler</code></a></li> <li><a href="https://www.tensorflow.org/api_docs/python/tf/nn/learned_unigram_candidate_sampler" target="_blank"><code>tf.nn.learned_unigram_candidate_sampler</code></a></li> <li><a href="https://www.tensorflow.org/api_docs/python/tf/nn/fixed_unigram_candidate_sampler" target="_blank"><code>tf.nn.fixed_unigram_candidate_sampler</code></a></li> </ul> <h3 id="miscellaneous_candidate_sampling_utilities">Miscellaneous candidate sampling utilities</h3> <ul> <li><a href="https://www.tensorflow.org/api_docs/python/tf/nn/compute_accidental_hits" target="_blank"><code>tf.nn.compute_accidental_hits</code></a></li> </ul> <h3 id="quantization_ops">Quantization ops</h3> <ul> <li><a href="https://www.tensorflow.org/api_docs/python/tf/nn/quantized_conv2d" target="_blank"><code>tf.nn.quantized_conv2d</code></a></li> <li><a href="https://www.tensorflow.org/api_docs/python/tf/nn/quantized_relu_x" target="_blank"><code>tf.nn.quantized_relu_x</code></a></li> <li><a href="https://www.tensorflow.org/api_docs/python/tf/nn/quantized_max_pool" target="_blank"><code>tf.nn.quantized_max_pool</code></a></li> <li><a href="https://www.tensorflow.org/api_docs/python/tf/nn/quantized_avg_pool" target="_blank"><code>tf.nn.quantized_avg_pool</code></a></li> </ul>
<div class="_attribution">
  <p class="_attribution-p">
    © 2017 The TensorFlow Authors. All rights reserved.<br>Licensed under the Creative Commons Attribution License 3.0.<br>Code samples licensed under the Apache 2.0 License.<br>
    <a href="https://www.tensorflow.org/api_guides/python/nn" class="_attribution-link" target="_blank">https://www.tensorflow.org/api_guides/python/nn</a>
  </p>
</div>

			</div>
		</div>
	</section>

	</div>
</body>
</html>
