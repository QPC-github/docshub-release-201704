
<!DOCTYPE HTML>

<html lang="en">

<head>
  <meta charset="utf-8">
  <title>contrib.linalg.LinearOperatorIdentity - TensorFlow Python - W3cubDocs</title>
  
  <meta name="description" content=" See the guide&#58; Linear Algebra (contrib) &#62; LinearOperator ">
  <meta name="keywords" content="tf, contrib, linalg, linearoperatoridentity, -, tensorflow, python, tensorflow~python">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="http://docs.w3cub.com/tensorflow~python/tf/contrib/linalg/linearoperatoridentity/">
  <link href="/favicon.png" rel="icon">
  <link type="text/css" rel="stylesheet" href="/assets/application-50364fff564ce3b6327021805f3f00e2957b441cf27f576a7dd4ff63bbc47047.css">
  <script type="text/javascript" src="/assets/application-db64bfd54ceb42be11af7995804cf4902548419ceb79d509b0b7d62c22d98e6f.js"></script>
  <script src="/json/tensorflow~python.js"></script>
  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-71174418-1']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>


</head>

<body>
	<div class="_app">
	<header class="_header">
  
  <form class="_search">
    <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
    <a class="_search-clear"></a>
    <div class="_search-tag"></div>
  </form>
  
  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/tensorflow~python/" class="_nav-link" title="" style="margin-left:0;">TensorFlow Python</a></span>
  
  <nav class="_nav">
    <a href="/app/" class="_nav-link ">App</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		<div class="_list">
			
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<div class="_page _tensorflow">
				
<h1 itemprop="name" class="devsite-page-title"> tf.contrib.linalg.LinearOperatorIdentity </h1>    <h3 id="class_tfcontriblinalglinearoperatoridentity"><code>class tf.contrib.linalg.LinearOperatorIdentity</code></h3> <p>See the guide: <a href="https://www.tensorflow.org/api_guides/python/contrib.linalg#_LinearOperator_" target="_blank">Linear Algebra (contrib) &gt; <code>LinearOperator</code></a></p> <p><code>LinearOperator</code> acting like a [batch] square identity matrix.</p> <p>This operator acts like a [batch] identity matrix <code>A</code> with shape <code>[B1,...,Bb, N, N]</code> for some <code>b &gt;= 0</code>. The first <code>b</code> indices index a batch member. For every batch index <code>(i1,...,ib)</code>, <code>A[i1,...,ib, : :]</code> is an <code>N x N</code> matrix. This matrix <code>A</code> is not materialized, but for purposes of broadcasting this shape will be relevant.</p> <p><code>LinearOperatorIdentity</code> is initialized with <code>num_rows</code>, and optionally <code>batch_shape</code>, and <code>dtype</code> arguments. If <code>batch_shape</code> is <code>None</code>, this operator efficiently passes through all arguments. If <code>batch_shape</code> is provided, broadcasting may occur, which will require making copies.</p> <pre class="prettyprint lang-python" data-language="python"># Create a 2 x 2 identity matrix.
operator = LinearOperatorIdentity(num_rows=2, dtype=tf.float32)

operator.to_dense()
==&gt; [[1., 0.]
     [0., 1.]]

operator.shape
==&gt; [2, 2]

operator.log_determinant()
==&gt; 0.

x = ... Shape [2, 4] Tensor
operator.apply(x)
==&gt; Shape [2, 4] Tensor, same as x.

y = tf.random_normal(shape=[3, 2, 4])
# Note that y.shape is compatible with operator.shape because operator.shape
# is broadcast to [3, 2, 2].
# This broadcast does NOT require copying data, since we can infer that y
# will be passed through without changing shape.  We are always able to infer
# this if the operator has no batch_shape.
x = operator.solve(y)
==&gt; Shape [3, 2, 4] Tensor, same as y.

# Create a 2-batch of 2x2 identity matrices
operator = LinearOperatorIdentity(num_rows=2, batch_shape=[2])
operator.to_dense()
==&gt; [[[1., 0.]
      [0., 1.]],
     [[1., 0.]
      [0., 1.]]]

# Here, even though the operator has a batch shape, the input is the same as
# the output, so x can be passed through without a copy.  The operator is able
# to detect that no broadcast is necessary because both x and the operator
# have statically defined shape.
x = ... Shape [2, 2, 3]
operator.apply(x)
==&gt; Shape [2, 2, 3] Tensor, same as x

# Here the operator and x have different batch_shape, and are broadcast.
# This requires a copy, since the output is different size than the input.
x = ... Shape [1, 2, 3]
operator.apply(x)
==&gt; Shape [2, 2, 3] Tensor, equal to [x, x]
</pre> <h3 id="shape_compatibility">Shape compatibility</h3> <p>This operator acts on [batch] matrix with compatible shape. <code>x</code> is a batch matrix with compatible shape for <code>apply</code> and <code>solve</code> if</p> <pre class="prettyprint" data-language="python">operator.shape = [B1,...,Bb] + [N, N],  with b &gt;= 0
x.shape =   [C1,...,Cc] + [N, R],
and [C1,...,Cc] broadcasts with [B1,...,Bb] to [D1,...,Dd]
</pre> <h3 id="performance">Performance</h3> <p>If <code>batch_shape</code> initialization arg is <code>None</code>:</p> <ul> <li>
<code>operator.apply(x)</code> is <code>O(1)</code>
</li> <li>
<code>operator.solve(x)</code> is <code>O(1)</code>
</li> <li>
<code>operator.determinant()</code> is <code>O(1)</code>
</li> </ul> <p>If <code>batch_shape</code> initialization arg is provided, and static checks cannot rule out the need to broadcast:</p> <ul> <li>
<code>operator.apply(x)</code> is <code>O(D1*...*Dd*N*R)</code>
</li> <li>
<code>operator.solve(x)</code> is <code>O(D1*...*Dd*N*R)</code>
</li> <li>
<code>operator.determinant()</code> is <code>O(B1*...*Bb)</code>
</li> </ul> <h4 id="matrix_property_hints">Matrix property hints</h4> <p>This <code>LinearOperator</code> is initialized with boolean flags of the form <code>is_X</code>, for <code>X = non_singular, self_adjoint, positive_definite</code>. These have the following meaning <em> If <code>is_X == True</code>, callers should expect the operator to have the property <code>X</code>. This is a promise that should be fulfilled, but is </em>not<em> a runtime assert. For example, finite floating point precision may result in these promises being violated. </em> If <code>is_X == False</code>, callers should expect the operator to not have <code>X</code>. * If <code>is_X == None</code> (the default), callers should have no expectation either way.</p> <h2 id="properties">Properties</h2> <h3 id="batch_shape"><code>batch_shape</code></h3> <p><code>TensorShape</code> of batch dimensions of this <code>LinearOperator</code>.</p> <p>If this operator acts like the batch matrix <code>A</code> with <code>A.shape = [B1,...,Bb, M, N]</code>, then this returns <code>TensorShape([B1,...,Bb])</code>, equivalent to <code>A.get_shape()[:-2]</code></p> <h4 id="returns">Returns:</h4> <p><code>TensorShape</code>, statically determined, may be undefined.</p> <h3 id="domain_dimension"><code>domain_dimension</code></h3> <p>Dimension (in the sense of vector spaces) of the domain of this operator.</p> <p>If this operator acts like the batch matrix <code>A</code> with <code>A.shape = [B1,...,Bb, M, N]</code>, then this returns <code>N</code>.</p> <h4 id="returns_1">Returns:</h4> <p><code>Dimension</code> object.</p> <h3 id="dtype"><code>dtype</code></h3> <p>The <code>DType</code> of <code>Tensor</code>s handled by this <code>LinearOperator</code>.</p> <h3 id="graph_parents"><code>graph_parents</code></h3> <p>List of graph dependencies of this <code>LinearOperator</code>.</p> <h3 id="is_non_singular"><code>is_non_singular</code></h3> <h3 id="is_positive_definite"><code>is_positive_definite</code></h3> <h3 id="is_self_adjoint"><code>is_self_adjoint</code></h3> <h3 id="name"><code>name</code></h3> <p>Name prepended to all ops created by this <code>LinearOperator</code>.</p> <h3 id="range_dimension"><code>range_dimension</code></h3> <p>Dimension (in the sense of vector spaces) of the range of this operator.</p> <p>If this operator acts like the batch matrix <code>A</code> with <code>A.shape = [B1,...,Bb, M, N]</code>, then this returns <code>M</code>.</p> <h4 id="returns_2">Returns:</h4> <p><code>Dimension</code> object.</p> <h3 id="shape"><code>shape</code></h3> <p><code>TensorShape</code> of this <code>LinearOperator</code>.</p> <p>If this operator acts like the batch matrix <code>A</code> with <code>A.shape = [B1,...,Bb, M, N]</code>, then this returns <code>TensorShape([B1,...,Bb, M, N])</code>, equivalent to <code>A.get_shape()</code>.</p> <h4 id="returns_3">Returns:</h4> <p><code>TensorShape</code>, statically determined, may be undefined.</p> <h3 id="tensor_rank"><code>tensor_rank</code></h3> <p>Rank (in the sense of tensors) of matrix corresponding to this operator.</p> <p>If this operator acts like the batch matrix <code>A</code> with <code>A.shape = [B1,...,Bb, M, N]</code>, then this returns <code>b + 2</code>.</p> <h4 id="args">Args:</h4> <ul> <li>
<b><code>name</code></b>: A name for this `Op.</li> </ul> <h4 id="returns_4">Returns:</h4> <p>Python integer, or None if the tensor rank is undefined.</p> <h2 id="methods">Methods</h2> <h3 id="__init__"><code>__init__(num_rows, batch_shape=None, dtype=None, is_non_singular=True, is_self_adjoint=True, is_positive_definite=True, assert_proper_shapes=False, name='LinearOperatorIdentity')</code></h3> <p>Initialize a <code>LinearOperatorIdentity</code>.</p> <p>The <code>LinearOperatorIdentity</code> is initialized with arguments defining <code>dtype</code> and shape.</p> <p>This operator is able to broadcast the leading (batch) dimensions, which sometimes requires copying data. If <code>batch_shape</code> is <code>None</code>, the operator can take arguments of any batch shape without copying. See examples.</p> <h4 id="args_1">Args:</h4> <ul> <li>
<b><code>num_rows</code></b>: Scalar non-negative integer <code>Tensor</code>. Number of rows in the corresponding identity matrix.</li> <li>
<b><code>batch_shape</code></b>: Optional <code>1-D</code> integer <code>Tensor</code>. The shape of the leading dimensions. If <code>None</code>, this operator has no leading dimensions.</li> <li>
<b><code>dtype</code></b>: Data type of the matrix that this operator represents.</li> <li>
<b><code>is_non_singular</code></b>: Expect that this operator is non-singular.</li> <li>
<b><code>is_self_adjoint</code></b>: Expect that this operator is equal to its hermitian transpose.</li> <li>
<b><code>is_positive_definite</code></b>: Expect that this operator is positive definite.</li> <li>
<b><code>assert_proper_shapes</code></b>: Python <code>bool</code>. If <code>False</code>, only perform static checks that initialization and method arguments have proper shape. If <code>True</code>, and static checks are inconclusive, add asserts to the graph.</li> <li>
<b><code>name</code></b>: A name for this <code>LinearOperator</code>
</li> </ul> <h4 id="raises">Raises:</h4> <ul> <li>
<b><code>ValueError</code></b>: If <code>num_rows</code> is determined statically to be non-scalar, or negative.</li> <li>
<b><code>ValueError</code></b>: If <code>batch_shape</code> is determined statically to not be 1-D, or negative.</li> <li>
<b><code>ValueError</code></b>: If any of the following is not <code>True</code>: <code>{is_self_adjoint, is_non_singular, is_positive_definite}</code>.</li> </ul> <h3 id="add_to_tensor"><code>add_to_tensor(mat, name='add_to_tensor')</code></h3> <p>Add matrix represented by this operator to <code>mat</code>. Equiv to <code>I + mat</code>.</p> <h4 id="args_2">Args:</h4> <ul> <li>
<b><code>mat</code></b>: <code>Tensor</code> with same <code>dtype</code> and shape broadcastable to <code>self</code>.</li> <li>
<b><code>name</code></b>: A name to give this <code>Op</code>.</li> </ul> <h4 id="returns_5">Returns:</h4> <p>A <code>Tensor</code> with broadcast shape and same <code>dtype</code> as <code>self</code>.</p> <h3 id="apply"><code>apply(x, adjoint=False, name='apply')</code></h3> <p>Transform <code>x</code> with left multiplication: <code>x --&gt; Ax</code>.</p> <h4 id="args_3">Args:</h4> <ul> <li>
<b><code>x</code></b>: <code>Tensor</code> with compatible shape and same <code>dtype</code> as <code>self</code>. See class docstring for definition of compatibility.</li> <li>
<b><code>adjoint</code></b>: Python <code>bool</code>. If <code>True</code>, left multiply by the adjoint.</li> <li>
<b><code>name</code></b>: A name for this `Op.</li> </ul> <h4 id="returns_6">Returns:</h4> <p>A <code>Tensor</code> with shape <code>[..., M, R]</code> and same <code>dtype</code> as <code>self</code>.</p> <h3 id="assert_non_singular"><code>assert_non_singular(name='assert_non_singular')</code></h3> <p>Returns an <code>Op</code> that asserts this operator is non singular.</p> <h3 id="assert_positive_definite"><code>assert_positive_definite(name='assert_positive_definite')</code></h3> <p>Returns an <code>Op</code> that asserts this operator is positive definite.</p> <p>Here, positive definite means the real part of all eigenvalues is positive. We do not require the operator to be self-adjoint.</p> <h4 id="args_4">Args:</h4> <ul> <li>
<b><code>name</code></b>: A name to give this <code>Op</code>.</li> </ul> <h4 id="returns_7">Returns:</h4> <p>An <code>Op</code> that asserts this operator is positive definite.</p> <h3 id="assert_self_adjoint"><code>assert_self_adjoint(name='assert_self_adjoint')</code></h3> <p>Returns an <code>Op</code> that asserts this operator is self-adjoint.</p> <h3 id="batch_shape_dynamic"><code>batch_shape_dynamic(name='batch_shape_dynamic')</code></h3> <p>Shape of batch dimensions of this operator, determined at runtime.</p> <p>If this operator acts like the batch matrix <code>A</code> with <code>A.shape = [B1,...,Bb, M, N]</code>, then this returns a <code>Tensor</code> holding <code>[B1,...,Bb]</code>.</p> <h4 id="args_5">Args:</h4> <ul> <li>
<b><code>name</code></b>: A name for this `Op.</li> </ul> <h4 id="returns_8">Returns:</h4> <p><code>int32</code> <code>Tensor</code></p> <h3 id="determinant"><code>determinant(name='det')</code></h3> <p>Determinant for every batch member.</p> <h4 id="args_6">Args:</h4> <ul> <li>
<b><code>name</code></b>: A name for this `Op.</li> </ul> <h4 id="returns_9">Returns:</h4> <p><code>Tensor</code> with shape <code>self.batch_shape</code> and same <code>dtype</code> as <code>self</code>.</p> <h3 id="domain_dimension_dynamic"><code>domain_dimension_dynamic(name='domain_dimension_dynamic')</code></h3> <p>Dimension (in the sense of vector spaces) of the domain of this operator.</p> <p>Determined at runtime.</p> <p>If this operator acts like the batch matrix <code>A</code> with <code>A.shape = [B1,...,Bb, M, N]</code>, then this returns <code>N</code>.</p> <h4 id="args_7">Args:</h4> <ul> <li>
<b><code>name</code></b>: A name for this <code>Op</code>.</li> </ul> <h4 id="returns_10">Returns:</h4> <p><code>int32</code> <code>Tensor</code></p> <h3 id="log_abs_determinant"><code>log_abs_determinant(name='log_abs_det')</code></h3> <p>Log absolute value of determinant for every batch member.</p> <h4 id="args_8">Args:</h4> <ul> <li>
<b><code>name</code></b>: A name for this `Op.</li> </ul> <h4 id="returns_11">Returns:</h4> <p><code>Tensor</code> with shape <code>self.batch_shape</code> and same <code>dtype</code> as <code>self</code>.</p> <h3 id="range_dimension_dynamic"><code>range_dimension_dynamic(name='range_dimension_dynamic')</code></h3> <p>Dimension (in the sense of vector spaces) of the range of this operator.</p> <p>Determined at runtime.</p> <p>If this operator acts like the batch matrix <code>A</code> with <code>A.shape = [B1,...,Bb, M, N]</code>, then this returns <code>M</code>.</p> <h4 id="args_9">Args:</h4> <ul> <li>
<b><code>name</code></b>: A name for this <code>Op</code>.</li> </ul> <h4 id="returns_12">Returns:</h4> <p><code>int32</code> <code>Tensor</code></p> <h3 id="shape_dynamic"><code>shape_dynamic(name='shape_dynamic')</code></h3> <p>Shape of this <code>LinearOperator</code>, determined at runtime.</p> <p>If this operator acts like the batch matrix <code>A</code> with <code>A.shape = [B1,...,Bb, M, N]</code>, then this returns a <code>Tensor</code> holding <code>[B1,...,Bb, M, N]</code>, equivalent to <code>tf.shape(A)</code>.</p> <h4 id="args_10">Args:</h4> <ul> <li>
<b><code>name</code></b>: A name for this `Op.</li> </ul> <h4 id="returns_13">Returns:</h4> <p><code>int32</code> <code>Tensor</code></p> <h3 id="solve"><code>solve(rhs, adjoint=False, name='solve')</code></h3> <p>Solve <code>R</code> (batch) systems of equations exactly: <code>A X = rhs</code>.</p> <p>Examples:</p> <pre class="prettyprint lang-python" data-language="python"># Create an operator acting like a 10 x 2 x 2 matrix.
operator = LinearOperator(...)
operator.shape # = 10 x 2 x 2

# Solve one linear system (R = 1) for every member of the length 10 batch.
RHS = ... # shape 10 x 2 x 1
X = operator.solve(RHS)  # shape 10 x 2 x 1

# Solve five linear systems (R = 5) for every member of the length 10 batch.
RHS = ... # shape 10 x 2 x 5
X = operator.solve(RHS)
X[3, :, 2]  # Solution to the linear system A[3, :, :] X = RHS[3, :, 2]
</pre> <h4 id="args_11">Args:</h4> <ul> <li>
<b><code>rhs</code></b>: <code>Tensor</code> with same <code>dtype</code> as this operator and compatible shape. See class docstring for definition of compatibility.</li> <li>
<b><code>adjoint</code></b>: Python <code>bool</code>. If <code>True</code>, solve the system involving the adjoint of this <code>LinearOperator</code>.</li> <li>
<b><code>name</code></b>: A name scope to use for ops added by this method.</li> </ul> <h4 id="returns_14">Returns:</h4> <p><code>Tensor</code> with shape <code>[...,N, R]</code> and same <code>dtype</code> as <code>rhs</code>.</p> <h4 id="raises_1">Raises:</h4> <ul> <li>
<b><code>ValueError</code></b>: If self.is_non_singular is False.</li> </ul> <h3 id="tensor_rank_dynamic"><code>tensor_rank_dynamic(name='tensor_rank_dynamic')</code></h3> <p>Rank (in the sense of tensors) of matrix corresponding to this operator.</p> <p>If this operator acts like the batch matrix <code>A</code> with <code>A.shape = [B1,...,Bb, M, N]</code>, then this returns <code>b + 2</code>.</p> <h4 id="args_12">Args:</h4> <ul> <li>
<b><code>name</code></b>: A name for this `Op.</li> </ul> <h4 id="returns_15">Returns:</h4> <p><code>int32</code> <code>Tensor</code>, determined at runtime.</p> <h3 id="to_dense"><code>to_dense(name='to_dense')</code></h3> <p>Return a dense (batch) matrix representing this operator.</p> <p>Defined in <a href="https://www.tensorflow.org/code/tensorflow/contrib/linalg/python/ops/linear_operator_identity.py" target="_blank"><code>tensorflow/contrib/linalg/python/ops/linear_operator_identity.py</code></a>.</p>
<div class="_attribution">
  <p class="_attribution-p">
    © 2017 The TensorFlow Authors. All rights reserved.<br>Licensed under the Creative Commons Attribution License 3.0.<br>Code samples licensed under the Apache 2.0 License.<br>
    <a href="https://www.tensorflow.org/api_docs/python/tf/contrib/linalg/LinearOperatorIdentity" class="_attribution-link" target="_blank">https://www.tensorflow.org/api_docs/python/tf/contrib/linalg/LinearOperatorIdentity</a>
  </p>
</div>

			</div>
		</div>
	</section>

	</div>
</body>
</html>
