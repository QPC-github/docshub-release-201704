
<!DOCTYPE HTML>

<html lang="en">

<head>
  <meta charset="utf-8">
  <title>FlatList - React Native - W3cubDocs</title>
  
  <meta name="description" content=" A performant interface for rendering simple, flat lists, supporting the most handy features&#58; ">
  <meta name="keywords" content="flatlist, -, react, native, react_native">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="http://docs.w3cub.com/react_native/flatlist/">
  <link href="/favicon.png" rel="icon">
  <link type="text/css" rel="stylesheet" href="/assets/application-50364fff564ce3b6327021805f3f00e2957b441cf27f576a7dd4ff63bbc47047.css">
  <script type="text/javascript" src="/assets/application-db64bfd54ceb42be11af7995804cf4902548419ceb79d509b0b7d62c22d98e6f.js"></script>
  <script src="/json/react_native.js"></script>
  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-71174418-1']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>


</head>

<body>
	<div class="_app">
	<header class="_header">
  
  <form class="_search">
    <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
    <a class="_search-clear"></a>
    <div class="_search-tag"></div>
  </form>
  
  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/react_native/" class="_nav-link" title="" style="margin-left:0;">React Native</a></span>
  
  <nav class="_nav">
    <a href="/app/" class="_nav-link ">App</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		<div class="_list">
			
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<div class="_page _react">
				
<h1 id="flatlist">
FlatList </h1>
<p>A performant interface for rendering simple, flat lists, supporting the most handy features:</p>
<ul>
<li>Fully cross-platform.</li>
<li>Optional horizontal mode.</li>
<li>Configurable viewability callbacks.</li>
<li>Header support.</li>
<li>Footer support.</li>
<li>Separator support.</li>
<li>Pull to Refresh.</li>
<li>Scroll loading.</li>
</ul>
<p>If you need section support, use <a href="../sectionlist/"><code>&lt;SectionList&gt;</code></a>.</p>
<p>Minimal Example:</p>
<pre class="prism language-javascript" data-language="javascript">&lt;FlatList
  data={[{key: 'a'}, {key: 'b'}]}
  renderItem={({item}) =&gt; &lt;Text&gt;{item.key}&lt;/Text&gt;}
/&gt;</pre>
<p>This is a convenience wrapper around <a href="../virtualizedlist/"><code>&lt;VirtualizedList&gt;</code></a>, and thus inherits the following caveats:</p>
<ul>
<li>Internal state is not preserved when content scrolls out of the render window. Make sure all your data is captured in the item data or external stores like Flux, Redux, or Relay.</li>
<li>This is a <code>PureComponent</code> which means that it will not re-render if <code>props</code> remain shallow- equal. Make sure that everything your <code>renderItem</code> function depends on is passed as a prop that is not <code>===</code> after updates, otherwise your UI may not update on changes. This includes the <code>data</code> prop and parent component state.</li>
<li>In order to constrain memory and enable smooth scrolling, content is rendered asynchronously offscreen. This means it's possible to scroll faster than the fill rate ands momentarily see blank content. This is a tradeoff that can be adjusted to suit the needs of each application, and we are working on improving it behind the scenes.</li>
<li>By default, the list looks for a <code>key</code> prop on each item and uses that for the React key. Alternatively, you can provide a custom <code>keyExtractor</code> prop.</li>
</ul>
<h2 id="props">
Props </h2>
<h3 class="propTitle" id="itemseparatorcomponent">
ItemSeparatorComponent?: <code class="propType"><code>?ReactClass&lt;any&gt;</code></code> </h3>
<div><p>Rendered in between each item, but not at the top or bottom.</p></div>
<h3 class="propTitle" id="listfootercomponent">
ListFooterComponent?: <code class="propType"><code>?ReactClass&lt;any&gt;</code></code> </h3>
<div><p>Rendered at the bottom of all the items.</p></div>
<h3 class="propTitle" id="listheadercomponent">
ListHeaderComponent?: <code class="propType"><code>?ReactClass&lt;any&gt;</code></code> </h3>
<div><p>Rendered at the top of all the items.</p></div>
<h3 class="propTitle" id="columnwrapperstyle">
columnWrapperStyle?: <code class="propType"><code>StyleObj</code></code> </h3>
<div><p>Optional custom style for multi-item rows generated when numColumns &gt; 1</p></div>
<h3 class="propTitle" id="data">
data: <code class="propType"><code>?Array&lt;ItemT&gt;</code></code> </h3>
<div><p>For simplicity, data is just a plain array. If you want to use something else, like an immutable list, use the underlying <code>VirtualizedList</code> directly.</p></div>
<h3 class="propTitle" id="getitem">
getItem?: </h3>
<h3 class="propTitle" id="getitemcount">
getItemCount?: </h3>
<h3 class="propTitle" id="getitemlayout">
getItemLayout?: <code class="propType"><code>(data: ?Array&lt;ItemT&gt;, index: number) =&gt;
  {length: number, offset: number, index: number}</code></code> </h3>
<div>
<p><code>getItemLayout</code> is an optional optimizations that let us skip measurement of dynamic content if you know the height of items a priori. <code>getItemLayout</code> is the most efficient, and is easy to use if you have fixed height items, for example:</p>
<pre class="prism language-javascript" data-language="javascript">getItemLayout={(data, index) =&gt; (
  {length: ITEM_HEIGHT, offset: ITEM_HEIGHT * index, index}
)}</pre>
<p>Remember to include separator length (height or width) in your offset calculation if you specify <code>ItemSeparatorComponent</code>.</p>
</div>
<h3 class="propTitle" id="horizontal">
horizontal?: <code class="propType"><code>?boolean</code></code> </h3>
<div><p>If true, renders items next to each other horizontally instead of stacked vertically.</p></div>
<h3 class="propTitle" id="keyextractor">
keyExtractor: <code class="propType"><code>(item: ItemT, index: number) =&gt; string</code></code> </h3>
<div><p>Used to extract a unique key for a given item at the specified index. Key is used for caching and as the react key to track item re-ordering. The default extractor checks <code>item.key</code>, then falls back to using the index, like React does.</p></div>
<h3 class="propTitle" id="legacyimplementation">
legacyImplementation?: <code class="propType"><code>?boolean</code></code> </h3>
<h3 class="propTitle" id="numcolumns">
numColumns: <code class="propType"><code>number</code></code> </h3>
<div><p>Multiple columns can only be rendered with <code>horizontal={false}`` and will zig-zag like a</code>flexWrap` layout. Items should all be the same height - masonry layouts are not supported.</p></div>
<h3 class="propTitle" id="onendreached">
onEndReached?: <code class="propType"><code>?(info: {distanceFromEnd: number}) =&gt; void</code></code> </h3>
<div><p>Called once when the scroll position gets within <code>onEndReachedThreshold</code> of the rendered content.</p></div>
<h3 class="propTitle" id="onendreachedthreshold">
onEndReachedThreshold?: <code class="propType"><code>?number</code></code> </h3>
<h3 class="propTitle" id="onrefresh">
onRefresh?: <code class="propType"><code>?() =&gt; void</code></code> </h3>
<div><p>If provided, a standard RefreshControl will be added for "Pull to Refresh" functionality. Make sure to also set the <code>refreshing</code> prop correctly.</p></div>
<h3 class="propTitle" id="onviewableitemschanged">
onViewableItemsChanged?: <code class="propType"><code>?(info: {viewableItems: Array&lt;ViewToken&gt;, changed: Array&lt;ViewToken&gt;}) =&gt; void</code></code> </h3>
<div><p>Called when the viewability of rows changes, as defined by the <code>viewablePercentThreshold</code> prop.</p></div>
<h3 class="propTitle" id="refreshing">
refreshing?: <code class="propType"><code>?boolean</code></code> </h3>
<div><p>Set this true while waiting for new data from a refresh.</p></div>
<h3 class="propTitle" id="renderitem">
renderItem: <code class="propType"><code>(info: {item: ItemT, index: number}) =&gt; ?React.Element&lt;any&gt;</code></code> </h3>
<div>
<p>Takes an item from <code>data</code> and renders it into the list. Typical usage:</p>
<pre class="prism language-javascript" data-language="javascript">_renderItem = ({item}) =&gt; (
  &lt;TouchableOpacity onPress={() =&gt; this._onPress(item)}&gt;
    &lt;Text&gt;{item.title}}&lt;/Text&gt;
  &lt;TouchableOpacity/&gt;
);
...
&lt;FlatList data={[{title: 'Title Text', key: 'item1'}]} renderItem={this._renderItem} /&gt;</pre>
<p>Provides additional metadata like <code>index</code> if you need it.</p>
</div>
<h3 class="propTitle" id="viewabilityconfig">
viewabilityConfig?: <code class="propType"><code>ViewabilityConfig</code></code> </h3>
<div><p>See <code>ViewabilityHelper</code> for flow type and further documentation.</p></div>
<h2 id="methods">
Methods </h2>
<h3 class="methodTitle" id="scrolltoend">
scrollToEnd<span class="methodType">(params?: object)</span> </h3>
<div><p>Scrolls to the end of the content. May be janky without <code>getItemLayout</code> prop.</p></div>
<h3 class="methodTitle" id="scrolltoindex">
scrollToIndex<span class="methodType">(params: object)</span> </h3>
<div>
<p>Scrolls to the item at a the specified index such that it is positioned in the viewable area such that <code>viewPosition</code> 0 places it at the top, 1 at the bottom, and 0.5 centered in the middle.</p>
<p>May be janky without <code>getItemLayout</code> prop.</p>
</div>
<h3 class="methodTitle" id="scrolltoitem">
scrollToItem<span class="methodType">(params: object)</span> </h3>
<div><p>Requires linear scan through data - use <code>scrollToIndex</code> instead if possible. May be janky without <code>getItemLayout</code> prop.</p></div>
<h3 class="methodTitle" id="scrolltooffset">
scrollToOffset<span class="methodType">(params: object)</span> </h3>
<div><p>Scroll to a specific content pixel offset, like a normal <code>ScrollView</code>.</p></div>
<h3 class="methodTitle" id="recordinteraction">
recordInteraction<span class="methodType">()</span> </h3>
<div><p>Tells the list an interaction has occured, which should trigger viewability calculations, e.g. if <code>waitForInteractions</code> is true and the user has not scrolled. This is typically called by taps on items or by navigation actions.</p></div>
<h3 id="examples">
Examples </h3>
<div class="example-container"><pre class="prism language-javascript" data-language="javascript">'use strict';

const React = require('react');
const ReactNative = require('react-native');
const {
  Animated,
  FlatList,
  StyleSheet,
  View,
} = ReactNative;

const UIExplorerPage = require('./UIExplorerPage');

const infoLog = require('infoLog');

const {
  FooterComponent,
  HeaderComponent,
  ItemComponent,
  PlainInput,
  SeparatorComponent,
  genItemData,
  getItemLayout,
  pressItem,
  renderSmallSwitchOption,
} = require('./ListExampleShared');

const AnimatedFlatList = Animated.createAnimatedComponent(FlatList);

const VIEWABILITY_CONFIG = {
  minimumViewTime: 3000,
  viewAreaCoveragePercentThreshold: 100,
  waitForInteraction: true,
};

class FlatListExample extends React.PureComponent {
  static title = '&lt;FlatList&gt;';
  static description = 'Performant, scrollable list of data.';

  state = {
    data: genItemData(1000),
    debug: false,
    horizontal: false,
    filterText: '',
    fixedHeight: true,
    logViewable: false,
    virtualized: true,
  };

  _onChangeFilterText = (filterText) =&gt; {
    this.setState({filterText});
  };

  _onChangeScrollToIndex = (text) =&gt; {
    this._listRef.getNode().scrollToIndex({viewPosition: 0.5, index: Number(text)});
  };

  _scrollPos = new Animated.Value(0);
  _scrollSinkX = Animated.event(
    [{nativeEvent: { contentOffset: { x: this._scrollPos } }}],
    {useNativeDriver: true},
  );
  _scrollSinkY = Animated.event(
    [{nativeEvent: { contentOffset: { y: this._scrollPos } }}],
    {useNativeDriver: true},
  );

  componentDidUpdate() {
    this._listRef.getNode().recordInteraction(); // e.g. flipping logViewable switch
  }

  render() {
    const filterRegex = new RegExp(String(this.state.filterText), 'i');
    const filter = (item) =&gt; (
      filterRegex.test(item.text) || filterRegex.test(item.title)
    );
    const filteredData = this.state.data.filter(filter);
    return (
      &lt;UIExplorerPage
        noSpacer={true}
        noScroll={true}&gt;
        &lt;View style={styles.searchRow}&gt;
          &lt;View style={styles.options}&gt;
            &lt;PlainInput
              onChangeText={this._onChangeFilterText}
              placeholder="Search..."
              value={this.state.filterText}
            /&gt;
            &lt;PlainInput
              onChangeText={this._onChangeScrollToIndex}
              placeholder="scrollToIndex..."
            /&gt;
          &lt;/View&gt;
          &lt;View style={styles.options}&gt;
            {renderSmallSwitchOption(this, 'virtualized')}
            {renderSmallSwitchOption(this, 'horizontal')}
            {renderSmallSwitchOption(this, 'fixedHeight')}
            {renderSmallSwitchOption(this, 'logViewable')}
            {renderSmallSwitchOption(this, 'debug')}
            &lt;Animated.View style={[styles.spindicator, {
              transform: [
                {rotate: this._scrollPos.interpolate({
                  inputRange: [0, 5000],
                  outputRange: ['0deg', '360deg'],
                  extrapolate: 'extend',
                })}
              ]
            }]} /&gt;
          &lt;/View&gt;
        &lt;/View&gt;
        &lt;SeparatorComponent /&gt;
        &lt;AnimatedFlatList
          ItemSeparatorComponent={SeparatorComponent}
          ListHeaderComponent={HeaderComponent}
          ListFooterComponent={FooterComponent}
          data={filteredData}
          debug={this.state.debug}
          disableVirtualization={!this.state.virtualized}
          getItemLayout={this.state.fixedHeight ?
            this._getItemLayout :
            undefined
          }
          horizontal={this.state.horizontal}
          key={(this.state.horizontal ? 'h' : 'v') +
            (this.state.fixedHeight ? 'f' : 'd')
          }
          legacyImplementation={false}
          numColumns={1}
          onRefresh={this._onRefresh}
          onScroll={this.state.horizontal ? this._scrollSinkX : this._scrollSinkY}
          onViewableItemsChanged={this._onViewableItemsChanged}
          ref={this._captureRef}
          refreshing={false}
          renderItem={this._renderItemComponent}
          shouldItemUpdate={this._shouldItemUpdate}
          viewabilityConfig={VIEWABILITY_CONFIG}
        /&gt;
      &lt;/UIExplorerPage&gt;
    );
  }
  _captureRef = (ref) =&gt; { this._listRef = ref; };
  _getItemLayout = (data: any, index: number) =&gt; {
    return getItemLayout(data, index, this.state.horizontal);
  };
  _onRefresh = () =&gt; alert('onRefresh: nothing to refresh :P');
  _renderItemComponent = ({item}) =&gt; {
    return (
      &lt;ItemComponent
        item={item}
        horizontal={this.state.horizontal}
        fixedHeight={this.state.fixedHeight}
        onPress={this._pressItem}
      /&gt;
    );
  };
  _shouldItemUpdate(prev, next) {
    /**
     * Note that this does not check state.horizontal or state.fixedheight
     * because we blow away the whole list by changing the key in those cases.
     * Make sure that you do the same in your code, or incorporate all relevant
     * data into the item data, or skip this optimization entirely.
     */
    return prev.item !== next.item;
  }
  // This is called when items change viewability by scrolling into or out of
  // the viewable area.
  _onViewableItemsChanged = (info: {
      changed: Array&lt;{
        key: string,
        isViewable: boolean,
        item: any,
        index: ?number,
        section?: any,
      }&gt;
    }
  ) =&gt; {
    // Impressions can be logged here
    if (this.state.logViewable) {
      infoLog(
        'onViewableItemsChanged: ',
        info.changed.map((v) =&gt; ({...v, item: '...'})),
      );
    }
  };
  _pressItem = (key: number) =&gt; {
    this._listRef.getNode().recordInteraction();
    pressItem(this, key);
  };
  _listRef: FlatList&lt;*&gt;;
}


const styles = StyleSheet.create({
  options: {
    flexDirection: 'row',
    flexWrap: 'wrap',
    alignItems: 'center',
  },
  searchRow: {
    paddingHorizontal: 10,
  },
  spindicator: {
    marginLeft: 'auto',
    width: 2,
    height: 16,
    backgroundColor: 'darkgray',
  },
});

module.exports = FlatListExample;</pre></div>
<div class="_attribution">
  <p class="_attribution-p">
    © 2015–2017 Facebook Inc.<br>Licensed under the Creative Commons Attribution 4.0 International Public License.<br>
    <a href="https://facebook.github.io/react-native/docs/flatlist.html" class="_attribution-link" target="_blank">https://facebook.github.io/react-native/docs/flatlist.html</a>
  </p>
</div>

			</div>
		</div>
	</section>

	</div>
</body>
</html>
