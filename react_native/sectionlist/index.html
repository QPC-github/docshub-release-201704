
<!DOCTYPE HTML>

<html lang="en">

<head>
  <meta charset="utf-8">
  <title>SectionList - React Native - W3cubDocs</title>
  
  <meta name="description" content=" A performant interface for rendering sectioned lists, supporting the most handy features&#58; ">
  <meta name="keywords" content="sectionlist, -, react, native, react_native">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="http://docs.w3cub.com/react_native/sectionlist/">
  <link href="/favicon.png" rel="icon">
  <link type="text/css" rel="stylesheet" href="/assets/application-50364fff564ce3b6327021805f3f00e2957b441cf27f576a7dd4ff63bbc47047.css">
  <script type="text/javascript" src="/assets/application-db64bfd54ceb42be11af7995804cf4902548419ceb79d509b0b7d62c22d98e6f.js"></script>
  <script src="/json/react_native.js"></script>
  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-71174418-1']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>


</head>

<body>
	<div class="_app">
	<header class="_header">
  
  <form class="_search">
    <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
    <a class="_search-clear"></a>
    <div class="_search-tag"></div>
  </form>
  
  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/react_native/" class="_nav-link" title="" style="margin-left:0;">React Native</a></span>
  
  <nav class="_nav">
    <a href="/app/" class="_nav-link ">App</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		<div class="_list">
			
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<div class="_page _react">
				
<h1 id="sectionlist">
SectionList </h1>
<p>A performant interface for rendering sectioned lists, supporting the most handy features:</p>
<ul>
<li>Fully cross-platform.</li>
<li>Configurable viewability callbacks.</li>
<li>List header support.</li>
<li>List footer support.</li>
<li>Item separator support.</li>
<li>Section header support.</li>
<li>Section separator support.</li>
<li>Heterogeneous data and item rendering support.</li>
<li>Pull to Refresh.</li>
<li>Scroll loading.</li>
</ul>
<p>If you don't need section support and want a simpler interface, use <a href="../flatlist/"><code>&lt;FlatList&gt;</code></a>.</p>
<p>If you need <em>sticky</em> section header support, use <code>ListView</code> for now.</p>
<p>Simple Examples:</p>
<pre class="prism language-javascript" data-language="javascript">&lt;SectionList
  renderItem={({item}) =&gt; &lt;ListItem title={item.title}}
  renderSectionHeader={({section}) =&gt; &lt;H1 title={section.key} /&gt;}
  sections={[ // homogenous rendering between sections
    {data: [...], key: ...},
    {data: [...], key: ...},
    {data: [...], key: ...},
  ]}
/&gt;

&lt;SectionList
  sections={[ // heterogeneous rendering between sections
    {data: [...], key: ..., renderItem: ...},
    {data: [...], key: ..., renderItem: ...},
    {data: [...], key: ..., renderItem: ...},
  ]}
/&gt;</pre>
<p>This is a convenience wrapper around <a href="../virtualizedlist/"><code>&lt;VirtualizedList&gt;</code></a>, and thus inherits the following caveats:</p>
<ul>
<li>Internal state is not preserved when content scrolls out of the render window. Make sure all your data is captured in the item data or external stores like Flux, Redux, or Relay.</li>
<li>This is a <code>PureComponent</code> which means that it will not re-render if <code>props</code> remain shallow- equal. Make sure that everything your <code>renderItem</code> function depends on is passed as a prop that is not <code>===</code> after updates, otherwise your UI may not update on changes. This includes the <code>data</code> prop and parent component state.</li>
<li>In order to constrain memory and enable smooth scrolling, content is rendered asynchronously offscreen. This means it's possible to scroll faster than the fill rate ands momentarily see blank content. This is a tradeoff that can be adjusted to suit the needs of each application, and we are working on improving it behind the scenes.</li>
<li>By default, the list looks for a <code>key</code> prop on each item and uses that for the React key. Alternatively, you can provide a custom <code>keyExtractor</code> prop.</li>
</ul>
<h2 id="props">
Props </h2>
<h3 class="propTitle" id="itemseparatorcomponent">
ItemSeparatorComponent?: <code class="propType"><code>?ReactClass&lt;any&gt;</code></code> </h3>
<div><p>Rendered in between adjacent Items within each section.</p></div>
<h3 class="propTitle" id="listfootercomponent">
ListFooterComponent?: <code class="propType"><code>?ReactClass&lt;any&gt;</code></code> </h3>
<div><p>Rendered at the very end of the list.</p></div>
<h3 class="propTitle" id="listheadercomponent">
ListHeaderComponent?: <code class="propType"><code>?ReactClass&lt;any&gt;</code></code> </h3>
<div><p>Rendered at the very beginning of the list.</p></div>
<h3 class="propTitle" id="sectionseparatorcomponent">
SectionSeparatorComponent?: <code class="propType"><code>?ReactClass&lt;any&gt;</code></code> </h3>
<div><p>Rendered in between each section.</p></div>
<h3 class="propTitle" id="keyextractor">
keyExtractor: <code class="propType"><code>(item: Item, index: number) =&gt; string</code></code> </h3>
<div><p>Used to extract a unique key for a given item at the specified index. Key is used for caching and as the react key to track item re-ordering. The default extractor checks item.key, then falls back to using the index, like react does.</p></div>
<h3 class="propTitle" id="onendreached">
onEndReached?: <code class="propType"><code>?(info: {distanceFromEnd: number}) =&gt; void</code></code> </h3>
<h3 class="propTitle" id="onrefresh">
onRefresh?: <code class="propType"><code>?() =&gt; void</code></code> </h3>
<div><p>If provided, a standard RefreshControl will be added for "Pull to Refresh" functionality. Make sure to also set the <code>refreshing</code> prop correctly.</p></div>
<h3 class="propTitle" id="onviewableitemschanged">
onViewableItemsChanged?: <code class="propType"><code>?(info: {viewableItems: Array&lt;ViewToken&gt;, changed: Array&lt;ViewToken&gt;}) =&gt; void</code></code> </h3>
<div><p>Called when the viewability of rows changes, as defined by the <code>viewabilityConfig</code> prop.</p></div>
<h3 class="propTitle" id="refreshing">
refreshing?: <code class="propType"><code>?boolean</code></code> </h3>
<div><p>Set this true while waiting for new data from a refresh.</p></div>
<h3 class="propTitle" id="renderitem">
renderItem: <code class="propType"><code>(info: {item: Item, index: number}) =&gt; ?React.Element&lt;any&gt;</code></code> </h3>
<div><p>Default renderer for every item in every section. Can be over-ridden on a per-section basis.</p></div>
<h3 class="propTitle" id="rendersectionheader">
renderSectionHeader?: <code class="propType"><code>?(info: {section: SectionT}) =&gt; ?React.Element&lt;any&gt;</code></code> </h3>
<div><p>Rendered at the top of each section. Sticky headers are not yet supported.</p></div>
<h3 class="propTitle" id="sections">
sections: <code class="propType"><code>Array&lt;SectionT&gt;</code></code> </h3>
<h3 class="propTitle" id="shoulditemupdate">
shouldItemUpdate: <code class="propType"><code>(
  prevProps: {item: Item, index: number},
  nextProps: {item: Item, index: number}
) =&gt; boolean</code></code> </h3>
<div><p>This is an optional optimization to minimize re-rendering items.</p></div>
<h3 id="examples">
Examples </h3>
<div class="example-container"><pre class="prism language-javascript" data-language="javascript">'use strict';

const React = require('react');
const ReactNative = require('react-native');
const {
  SectionList,
  StyleSheet,
  Text,
  View,
} = ReactNative;

const UIExplorerPage = require('./UIExplorerPage');

const infoLog = require('infoLog');

const {
  HeaderComponent,
  FooterComponent,
  ItemComponent,
  PlainInput,
  SeparatorComponent,
  genItemData,
  pressItem,
  renderSmallSwitchOption,
  renderStackedItem,
} = require('./ListExampleShared');

const VIEWABILITY_CONFIG = {
  minimumViewTime: 3000,
  viewAreaCoveragePercentThreshold: 100,
  waitForInteraction: true,
};

const renderSectionHeader = ({section}) =&gt; (
  &lt;View&gt;
    &lt;Text style={styles.headerText}&gt;SECTION HEADER: {section.key}&lt;/Text&gt;
    &lt;SeparatorComponent /&gt;
  &lt;/View&gt;
);

const CustomSeparatorComponent = ({text}) =&gt; (
  &lt;View&gt;
    &lt;SeparatorComponent /&gt;
    &lt;Text style={styles.separatorText}&gt;{text}&lt;/Text&gt;
    &lt;SeparatorComponent /&gt;
  &lt;/View&gt;
);

class SectionListExample extends React.PureComponent {
  static title = '&lt;SectionList&gt;';
  static description = 'Performant, scrollable list of data.';

  state = {
    data: genItemData(1000),
    filterText: '',
    logViewable: false,
    virtualized: true,
  };
  render() {
    const filterRegex = new RegExp(String(this.state.filterText), 'i');
    const filter = (item) =&gt; (
      filterRegex.test(item.text) || filterRegex.test(item.title)
    );
    const filteredData = this.state.data.filter(filter);
    return (
      &lt;UIExplorerPage
        noSpacer={true}
        noScroll={true}&gt;
        &lt;View style={styles.searchRow}&gt;
          &lt;PlainInput
            onChangeText={filterText =&gt; {
              this.setState(() =&gt; ({filterText}));
            }}
            placeholder="Search..."
            value={this.state.filterText}
          /&gt;
          &lt;View style={styles.optionSection}&gt;
            {renderSmallSwitchOption(this, 'virtualized')}
            {renderSmallSwitchOption(this, 'logViewable')}
          &lt;/View&gt;
        &lt;/View&gt;
        &lt;SeparatorComponent /&gt;
        &lt;SectionList
          ListHeaderComponent={HeaderComponent}
          ListFooterComponent={FooterComponent}
          SectionSeparatorComponent={() =&gt;
            &lt;CustomSeparatorComponent text="SECTION SEPARATOR" /&gt;
          }
          ItemSeparatorComponent={() =&gt;
            &lt;CustomSeparatorComponent text="ITEM SEPARATOR" /&gt;
          }
          enableVirtualization={this.state.virtualized}
          onRefresh={() =&gt; alert('onRefresh: nothing to refresh :P')}
          onViewableItemsChanged={this._onViewableItemsChanged}
          refreshing={false}
          renderItem={this._renderItemComponent}
          renderSectionHeader={renderSectionHeader}
          sections={[
            {renderItem: renderStackedItem, key: 's1', data: [
              {title: 'Item In Header Section', text: 'Section s1', key: '0'},
            ]},
            {key: 's2', data: [
              {noImage: true, title: '1st item', text: 'Section s2', key: '0'},
              {noImage: true, title: '2nd item', text: 'Section s2', key: '1'},
            ]},
            {key: 'Filtered Items', data: filteredData},
          ]}
          viewabilityConfig={VIEWABILITY_CONFIG}
        /&gt;
      &lt;/UIExplorerPage&gt;
    );
  }
  _renderItemComponent = ({item}) =&gt; (
    &lt;ItemComponent item={item} onPress={this._pressItem} /&gt;
  );
  // This is called when items change viewability by scrolling into our out of
  // the viewable area.
  _onViewableItemsChanged = (info: {
    changed: Array&lt;{
      key: string,
      isViewable: boolean,
      item: {columns: Array&lt;*&gt;},
      index: ?number,
      section?: any
    }&gt;},
  ) =&gt; {
    // Impressions can be logged here
    if (this.state.logViewable) {
      infoLog('onViewableItemsChanged: ', info.changed.map((v: Object) =&gt; (
        {...v, item: '...', section: v.section.key}
      )));
    }
  };
  _pressItem = (index: number) =&gt; {
    pressItem(this, index);
  };
}

const styles = StyleSheet.create({
  headerText: {
    padding: 4,
  },
  optionSection: {
    flexDirection: 'row',
  },
  searchRow: {
    paddingHorizontal: 10,
  },
  separatorText: {
    color: 'gray',
    alignSelf: 'center',
    padding: 4,
    fontSize: 9,
  },
});

module.exports = SectionListExample;</pre></div>
<div class="_attribution">
  <p class="_attribution-p">
    © 2015–2017 Facebook Inc.<br>Licensed under the Creative Commons Attribution 4.0 International Public License.<br>
    <a href="https://facebook.github.io/react-native/docs/sectionlist.html" class="_attribution-link" target="_blank">https://facebook.github.io/react-native/docs/sectionlist.html</a>
  </p>
</div>

			</div>
		</div>
	</section>

	</div>
</body>
</html>
