
<!DOCTYPE HTML>

<html lang="en">

<head>
  <meta charset="utf-8">
  <title>email.contentmanager&#58; Managing MIME Content - Python 3.5 - W3cubDocs</title>
  
  <meta name="description" content=" New in version 3.4&#58; as a provisional module. ">
  <meta name="keywords" content="email, contentmanager, managing, mime, content, -, python, python~3.5">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="http://docs.w3cub.com/python~3.5/library/email.contentmanager/">
  <link href="/favicon.png" rel="icon">
  <link type="text/css" rel="stylesheet" href="/assets/application-50364fff564ce3b6327021805f3f00e2957b441cf27f576a7dd4ff63bbc47047.css">
  <script type="text/javascript" src="/assets/application-db64bfd54ceb42be11af7995804cf4902548419ceb79d509b0b7d62c22d98e6f.js"></script>
  <script src="/json/python~3.5.js"></script>
  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-71174418-1']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>


</head>

<body>
	<div class="_app">
	<header class="_header">
  
  <form class="_search">
    <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
    <a class="_search-clear"></a>
    <div class="_search-tag"></div>
  </form>
  
  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/python~3.5/" class="_nav-link" title="" style="margin-left:0;">Python 3.5</a></span>
  
  <nav class="_nav">
    <a href="/app/" class="_nav-link ">App</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		<div class="_list">
			
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<div class="_page _sphinx">
				
<h1 id="email-contentmanager-managing-mime-content"> email.contentmanager: Managing MIME Content</h1> <div class="versionadded" id="module-email.contentmanager"> <p><span class="versionmodified">New in version 3.4: </span>as a <a class="reference internal" href="https://docs.python.org/3.5/glossary.html#term-provisional-package" target="_blank"><span class="xref std std-term">provisional module</span></a>.</p> </div> <p><strong>Source code:</strong> <a class="reference external" href="https://hg.python.org/cpython/file/3.5/Lib/email/contentmanager.py" target="_blank">Lib/email/contentmanager.py</a></p> <div class="admonition note"> <p class="first admonition-title">Note</p> <p class="last">The contentmanager module has been included in the standard library on a <a class="reference internal" href="https://docs.python.org/3.5/glossary.html#term-provisional-package" target="_blank"><span class="xref std std-term">provisional basis</span></a>. Backwards incompatible changes (up to and including removal of the module) may occur if deemed necessary by the core developers.</p> </div>  <p>The <a class="reference internal" href="../email.message/#module-email.message" title="email.message: The base class representing email messages."><code>message</code></a> module provides a class that can represent an arbitrary email message. That basic message model has a useful and flexible API, but it provides only a lower-level API for interacting with the generic parts of a message (the headers, generic header parameters, and the payload, which may be a list of sub-parts). This module provides classes and tools that provide an enhanced and extensible API for dealing with various specific types of content, including the ability to retrieve the content of the message as a specialized object type rather than as a simple bytes object. The module automatically takes care of the RFC-specified MIME details (required headers and parameters, etc.) for the certain common content types content properties, and support for additional types can be added by an application using the extension mechanisms.</p> <p>This module defines the eponymous “Content Manager” classes. The base <a class="reference internal" href="#email.contentmanager.ContentManager" title="email.contentmanager.ContentManager"><code>ContentManager</code></a> class defines an API for registering content management functions which extract data from <code>Message</code> objects or insert data and headers into <code>Message</code> objects, thus providing a way of converting between <code>Message</code> objects containing data and other representations of that data (Python data types, specialized Python objects, external files, etc). The module also defines one concrete content manager: <a class="reference internal" href="#email.contentmanager.raw_data_manager" title="email.contentmanager.raw_data_manager"><code>raw_data_manager</code></a> converts between MIME content types and <code>str</code> or <code>bytes</code> data. It also provides a convenient API for managing the MIME parameters when inserting content into <code>Message</code>s. It also handles inserting and extracting <code>Message</code> objects when dealing with the <code>message/rfc822</code> content type.</p> <p>Another part of the enhanced interface is subclasses of <a class="reference internal" href="../email.message/#email.message.Message" title="email.message.Message"><code>Message</code></a> that provide new convenience API functions, including convenience methods for calling the Content Managers derived from this module.</p> <div class="admonition note"> <p class="first admonition-title">Note</p> <p class="last">Although <a class="reference internal" href="#email.message.EmailMessage" title="email.message.EmailMessage"><code>EmailMessage</code></a> and <a class="reference internal" href="#email.message.MIMEPart" title="email.message.MIMEPart"><code>MIMEPart</code></a> are currently documented in this module because of the provisional nature of the code, the implementation lives in the <a class="reference internal" href="../email.message/#module-email.message" title="email.message: The base class representing email messages."><code>email.message</code></a> module.</p> </div> <dl class="class"> <dt id="email.message.EmailMessage">
<code>class email.message.EmailMessage(policy=default)</code> </dt> <dd>
<p>If <em>policy</em> is specified (it must be an instance of a <a class="reference internal" href="../email.policy/#module-email.policy" title="email.policy: Controlling the parsing and generating of messages"><code>policy</code></a> class) use the rules it specifies to udpate and serialize the representation of the message. If <em>policy</em> is not set, use the <a class="reference internal" href="../email.policy/#email.policy.default" title="email.policy.default"><code>default</code></a> policy, which follows the rules of the email RFCs except for line endings (instead of the RFC mandated <code>\r\n</code>, it uses the Python standard <code>\n</code> line endings). For more information see the <a class="reference internal" href="../email.policy/#module-email.policy" title="email.policy: Controlling the parsing and generating of messages"><code>policy</code></a> documentation.</p> <p>This class is a subclass of <a class="reference internal" href="../email.message/#email.message.Message" title="email.message.Message"><code>Message</code></a>. It adds the following methods:</p> <dl class="method"> <dt id="email.message.EmailMessage.is_attachment">
<code>is_attachment()</code> </dt> <dd>
<p>Return <code>True</code> if there is a <em class="mailheader">Content-Disposition</em> header and its (case insensitive) value is <code>attachment</code>, <code>False</code> otherwise.</p> <div class="versionchanged"> <p><span class="versionmodified">Changed in version 3.4.2: </span>is_attachment is now a method instead of a property, for consistency with <a class="reference internal" href="../email.message/#email.message.Message.is_multipart" title="email.message.Message.is_multipart"><code>is_multipart()</code></a>.</p> </div> </dd>
</dl> <dl class="method"> <dt id="email.message.EmailMessage.get_body">
<code>get_body(preferencelist=('related', 'html', 'plain'))</code> </dt> <dd>
<p>Return the MIME part that is the best candidate to be the “body” of the message.</p> <p><em>preferencelist</em> must be a sequence of strings from the set <code>related</code>, <code>html</code>, and <code>plain</code>, and indicates the order of preference for the content type of the part returned.</p> <p>Start looking for candidate matches with the object on which the <code>get_body</code> method is called.</p> <p>If <code>related</code> is not included in <em>preferencelist</em>, consider the root part (or subpart of the root part) of any related encountered as a candidate if the (sub-)part matches a preference.</p> <p>When encountering a <code>multipart/related</code>, check the <code>start</code> parameter and if a part with a matching <em class="mailheader">Content-ID</em> is found, consider only it when looking for candidate matches. Otherwise consider only the first (default root) part of the <code>multipart/related</code>.</p> <p>If a part has a <em class="mailheader">Content-Disposition</em> header, only consider the part a candidate match if the value of the header is <code>inline</code>.</p> <p>If none of the candidates matches any of the preferences in <em>preferneclist</em>, return <code>None</code>.</p> <p>Notes: (1) For most applications the only <em>preferencelist</em> combinations that really make sense are <code>('plain',)</code>, <code>('html', 'plain')</code>, and the default, <code>('related', 'html', 'plain')</code>. (2) Because matching starts with the object on which <code>get_body</code> is called, calling <code>get_body</code> on a <code>multipart/related</code> will return the object itself unless <em>preferencelist</em> has a non-default value. (3) Messages (or message parts) that do not specify a <em class="mailheader">Content-Type</em> or whose <em class="mailheader">Content-Type</em> header is invalid will be treated as if they are of type <code>text/plain</code>, which may occasionally cause <code>get_body</code> to return unexpected results.</p> </dd>
</dl> <dl class="method"> <dt id="email.message.EmailMessage.iter_attachments">
<code>iter_attachments()</code> </dt> <dd>
<p>Return an iterator over all of the parts of the message that are not candidate “body” parts. That is, skip the first occurrence of each of <code>text/plain</code>, <code>text/html</code>, <code>multipart/related</code>, or <code>multipart/alternative</code> (unless they are explicitly marked as attachments via <em class="mailheader">Content-Disposition: attachment</em>), and return all remaining parts. When applied directly to a <code>multipart/related</code>, return an iterator over the all the related parts except the root part (ie: the part pointed to by the <code>start</code> parameter, or the first part if there is no <code>start</code> parameter or the <code>start</code> parameter doesn’t match the <em class="mailheader">Content-ID</em> of any of the parts). When applied directly to a <code>multipart/alternative</code> or a non-<code>multipart</code>, return an empty iterator.</p> </dd>
</dl> <dl class="method"> <dt id="email.message.EmailMessage.iter_parts">
<code>iter_parts()</code> </dt> <dd>
<p>Return an iterator over all of the immediate sub-parts of the message, which will be empty for a non-<code>multipart</code>. (See also <code>walk()</code>.)</p> </dd>
</dl> <dl class="method"> <dt id="email.message.EmailMessage.get_content">
<code>get_content(*args, content_manager=None, **kw)</code> </dt> <dd>
<p>Call the <code>get_content</code> method of the <em>content_manager</em>, passing self as the message object, and passing along any other arguments or keywords as additional arguments. If <em>content_manager</em> is not specified, use the <code>content_manager</code> specified by the current <a class="reference internal" href="../email.policy/#module-email.policy" title="email.policy: Controlling the parsing and generating of messages"><code>policy</code></a>.</p> </dd>
</dl> <dl class="method"> <dt id="email.message.EmailMessage.set_content">
<code>set_content(*args, content_manager=None, **kw)</code> </dt> <dd>
<p>Call the <code>set_content</code> method of the <em>content_manager</em>, passing self as the message object, and passing along any other arguments or keywords as additional arguments. If <em>content_manager</em> is not specified, use the <code>content_manager</code> specified by the current <a class="reference internal" href="../email.policy/#module-email.policy" title="email.policy: Controlling the parsing and generating of messages"><code>policy</code></a>.</p> </dd>
</dl> <dl class="method"> <dt id="email.message.EmailMessage.make_related">
<code>make_related(boundary=None)</code> </dt> <dd>
<p>Convert a non-<code>multipart</code> message into a <code>multipart/related</code> message, moving any existing <em class="mailheader">Content-</em> headers and payload into a (new) first part of the <code>multipart</code>. If <em>boundary</em> is specified, use it as the boundary string in the multipart, otherwise leave the boundary to be automatically created when it is needed (for example, when the message is serialized).</p> </dd>
</dl> <dl class="method"> <dt id="email.message.EmailMessage.make_alternative">
<code>make_alternative(boundary=None)</code> </dt> <dd>
<p>Convert a non-<code>multipart</code> or a <code>multipart/related</code> into a <code>multipart/alternative</code>, moving any existing <em class="mailheader">Content-</em> headers and payload into a (new) first part of the <code>multipart</code>. If <em>boundary</em> is specified, use it as the boundary string in the multipart, otherwise leave the boundary to be automatically created when it is needed (for example, when the message is serialized).</p> </dd>
</dl> <dl class="method"> <dt id="email.message.EmailMessage.make_mixed">
<code>make_mixed(boundary=None)</code> </dt> <dd>
<p>Convert a non-<code>multipart</code>, a <code>multipart/related</code>, or a <code>multipart-alternative</code> into a <code>multipart/mixed</code>, moving any existing <em class="mailheader">Content-</em> headers and payload into a (new) first part of the <code>multipart</code>. If <em>boundary</em> is specified, use it as the boundary string in the multipart, otherwise leave the boundary to be automatically created when it is needed (for example, when the message is serialized).</p> </dd>
</dl> <dl class="method"> <dt id="email.message.EmailMessage.add_related">
<code>add_related(*args, content_manager=None, **kw)</code> </dt> <dd>
<p>If the message is a <code>multipart/related</code>, create a new message object, pass all of the arguments to its <a class="reference internal" href="#email.message.EmailMessage.set_content" title="email.message.EmailMessage.set_content"><code>set_content()</code></a> method, and <a class="reference internal" href="../email.message/#email.message.Message.attach" title="email.message.Message.attach"><code>attach()</code></a> it to the <code>multipart</code>. If the message is a non-<code>multipart</code>, call <a class="reference internal" href="#email.message.EmailMessage.make_related" title="email.message.EmailMessage.make_related"><code>make_related()</code></a> and then proceed as above. If the message is any other type of <code>multipart</code>, raise a <a class="reference internal" href="../exceptions/#TypeError" title="TypeError"><code>TypeError</code></a>. If <em>content_manager</em> is not specified, use the <code>content_manager</code> specified by the current <a class="reference internal" href="../email.policy/#module-email.policy" title="email.policy: Controlling the parsing and generating of messages"><code>policy</code></a>. If the added part has no <em class="mailheader">Content-Disposition</em> header, add one with the value <code>inline</code>.</p> </dd>
</dl> <dl class="method"> <dt id="email.message.EmailMessage.add_alternative">
<code>add_alternative(*args, content_manager=None, **kw)</code> </dt> <dd>
<p>If the message is a <code>multipart/alternative</code>, create a new message object, pass all of the arguments to its <a class="reference internal" href="#email.message.EmailMessage.set_content" title="email.message.EmailMessage.set_content"><code>set_content()</code></a> method, and <a class="reference internal" href="../email.message/#email.message.Message.attach" title="email.message.Message.attach"><code>attach()</code></a> it to the <code>multipart</code>. If the message is a non-<code>multipart</code> or <code>multipart/related</code>, call <a class="reference internal" href="#email.message.EmailMessage.make_alternative" title="email.message.EmailMessage.make_alternative"><code>make_alternative()</code></a> and then proceed as above. If the message is any other type of <code>multipart</code>, raise a <a class="reference internal" href="../exceptions/#TypeError" title="TypeError"><code>TypeError</code></a>. If <em>content_manager</em> is not specified, use the <code>content_manager</code> specified by the current <a class="reference internal" href="../email.policy/#module-email.policy" title="email.policy: Controlling the parsing and generating of messages"><code>policy</code></a>.</p> </dd>
</dl> <dl class="method"> <dt id="email.message.EmailMessage.add_attachment">
<code>add_attachment(*args, content_manager=None, **kw)</code> </dt> <dd>
<p>If the message is a <code>multipart/mixed</code>, create a new message object, pass all of the arguments to its <a class="reference internal" href="#email.message.EmailMessage.set_content" title="email.message.EmailMessage.set_content"><code>set_content()</code></a> method, and <a class="reference internal" href="../email.message/#email.message.Message.attach" title="email.message.Message.attach"><code>attach()</code></a> it to the <code>multipart</code>. If the message is a non-<code>multipart</code>, <code>multipart/related</code>, or <code>multipart/alternative</code>, call <a class="reference internal" href="#email.message.EmailMessage.make_mixed" title="email.message.EmailMessage.make_mixed"><code>make_mixed()</code></a> and then proceed as above. If <em>content_manager</em> is not specified, use the <code>content_manager</code> specified by the current <a class="reference internal" href="../email.policy/#module-email.policy" title="email.policy: Controlling the parsing and generating of messages"><code>policy</code></a>. If the added part has no <em class="mailheader">Content-Disposition</em> header, add one with the value <code>attachment</code>. This method can be used both for explicit attachments (<em class="mailheader">Content-Disposition: attachment</em> and <code>inline</code> attachments (<em class="mailheader">Content-Disposition: inline</em>), by passing appropriate options to the <code>content_manager</code>.</p> </dd>
</dl> <dl class="method"> <dt id="email.message.EmailMessage.clear">
<code>clear()</code> </dt> <dd>
<p>Remove the payload and all of the headers.</p> </dd>
</dl> <dl class="method"> <dt id="email.message.EmailMessage.clear_content">
<code>clear_content()</code> </dt> <dd>
<p>Remove the payload and all of the <code>Content-</code> headers, leaving all other headers intact and in their original order.</p> </dd>
</dl> </dd>
</dl> <dl class="class"> <dt id="email.message.MIMEPart">
<code>class email.message.MIMEPart(policy=default)</code> </dt> <dd>
<p>This class represents a subpart of a MIME message. It is identical to <a class="reference internal" href="#email.message.EmailMessage" title="email.message.EmailMessage"><code>EmailMessage</code></a>, except that no <em class="mailheader">MIME-Version</em> headers are added when <a class="reference internal" href="#email.message.EmailMessage.set_content" title="email.message.EmailMessage.set_content"><code>set_content()</code></a> is called, since sub-parts do not need their own <em class="mailheader">MIME-Version</em> headers.</p> </dd>
</dl> <dl class="class"> <dt id="email.contentmanager.ContentManager">
<code>class email.contentmanager.ContentManager</code> </dt> <dd>
<p>Base class for content managers. Provides the standard registry mechanisms to register converters between MIME content and other representations, as well as the <code>get_content</code> and <code>set_content</code> dispatch methods.</p> <dl class="method"> <dt id="email.contentmanager.ContentManager.get_content">
<code>get_content(msg, *args, **kw)</code> </dt> <dd>
<p>Look up a handler function based on the <code>mimetype</code> of <em>msg</em> (see next paragraph), call it, passing through all arguments, and return the result of the call. The expectation is that the handler will extract the payload from <em>msg</em> and return an object that encodes information about the extracted data.</p> <p>To find the handler, look for the following keys in the registry, stopping with the first one found:</p>  <ul class="simple"> <li>the string representing the full MIME type (<code>maintype/subtype</code>)</li> <li>the string representing the <code>maintype</code>
</li> <li>the empty string</li> </ul>  <p>If none of these keys produce a handler, raise a <a class="reference internal" href="../exceptions/#KeyError" title="KeyError"><code>KeyError</code></a> for the full MIME type.</p> </dd>
</dl> <dl class="method"> <dt id="email.contentmanager.ContentManager.set_content">
<code>set_content(msg, obj, *args, **kw)</code> </dt> <dd>
<p>If the <code>maintype</code> is <code>multipart</code>, raise a <a class="reference internal" href="../exceptions/#TypeError" title="TypeError"><code>TypeError</code></a>; otherwise look up a handler function based on the type of <em>obj</em> (see next paragraph), call <a class="reference internal" href="#email.message.EmailMessage.clear_content" title="email.message.EmailMessage.clear_content"><code>clear_content()</code></a> on the <em>msg</em>, and call the handler function, passing through all arguments. The expectation is that the handler will transform and store <em>obj</em> into <em>msg</em>, possibly making other changes to <em>msg</em> as well, such as adding various MIME headers to encode information needed to interpret the stored data.</p> <p>To find the handler, obtain the type of <em>obj</em> (<code>typ = type(obj)</code>), and look for the following keys in the registry, stopping with the first one found:</p>  <ul class="simple"> <li>the type itself (<code>typ</code>)</li> <li>the type’s fully qualified name (<code>typ.__module__ + '.' +
typ.__qualname__</code>).</li> <li>the type’s qualname (<code>typ.__qualname__</code>)</li> <li>the type’s name (<code>typ.__name__</code>).</li> </ul>  <p>If none of the above match, repeat all of the checks above for each of the types in the <a class="reference internal" href="https://docs.python.org/3.5/glossary.html#term-mro" target="_blank"><span class="xref std std-term">MRO</span></a> (<code>typ.__mro__</code>). Finally, if no other key yields a handler, check for a handler for the key <code>None</code>. If there is no handler for <code>None</code>, raise a <a class="reference internal" href="../exceptions/#KeyError" title="KeyError"><code>KeyError</code></a> for the fully qualified name of the type.</p> <p>Also add a <em class="mailheader">MIME-Version</em> header if one is not present (see also <a class="reference internal" href="#email.message.MIMEPart" title="email.message.MIMEPart"><code>MIMEPart</code></a>).</p> </dd>
</dl> <dl class="method"> <dt id="email.contentmanager.ContentManager.add_get_handler">
<code>add_get_handler(key, handler)</code> </dt> <dd>
<p>Record the function <em>handler</em> as the handler for <em>key</em>. For the possible values of <em>key</em>, see <a class="reference internal" href="#email.contentmanager.get_content" title="email.contentmanager.get_content"><code>get_content()</code></a>.</p> </dd>
</dl> <dl class="method"> <dt id="email.contentmanager.ContentManager.add_set_handler">
<code>add_set_handler(typekey, handler)</code> </dt> <dd>
<p>Record <em>handler</em> as the function to call when an object of a type matching <em>typekey</em> is passed to <a class="reference internal" href="#email.contentmanager.set_content" title="email.contentmanager.set_content"><code>set_content()</code></a>. For the possible values of <em>typekey</em>, see <a class="reference internal" href="#email.contentmanager.set_content" title="email.contentmanager.set_content"><code>set_content()</code></a>.</p> </dd>
</dl> </dd>
</dl>  <h2 id="content-manager-instances">1. Content Manager Instances</h2> <p>Currently the email package provides only one concrete content manager, <a class="reference internal" href="#email.contentmanager.raw_data_manager" title="email.contentmanager.raw_data_manager"><code>raw_data_manager</code></a>, although more may be added in the future. <a class="reference internal" href="#email.contentmanager.raw_data_manager" title="email.contentmanager.raw_data_manager"><code>raw_data_manager</code></a> is the <a class="reference internal" href="../email.policy/#email.policy.EmailPolicy.content_manager" title="email.policy.EmailPolicy.content_manager"><code>content_manager</code></a> provided by <a class="reference internal" href="../email.policy/#email.policy.EmailPolicy" title="email.policy.EmailPolicy"><code>EmailPolicy</code></a> and its derivatives.</p> <dl class="data"> <dt id="email.contentmanager.raw_data_manager">
<code>email.contentmanager.raw_data_manager</code> </dt> <dd>
<p>This content manager provides only a minimum interface beyond that provided by <a class="reference internal" href="../email.message/#email.message.Message" title="email.message.Message"><code>Message</code></a> itself: it deals only with text, raw byte strings, and <a class="reference internal" href="../email.message/#email.message.Message" title="email.message.Message"><code>Message</code></a> objects. Nevertheless, it provides significant advantages compared to the base API: <code>get_content</code> on a text part will return a unicode string without the application needing to manually decode it, <code>set_content</code> provides a rich set of options for controlling the headers added to a part and controlling the content transfer encoding, and it enables the use of the various <code>add_</code> methods, thereby simplifying the creation of multipart messages.</p> <dl class="method"> <dt id="email.contentmanager.get_content">
<code>email.contentmanager.get_content(msg, errors='replace')</code> </dt> <dd>
<p>Return the payload of the part as either a string (for <code>text</code> parts), an <a class="reference internal" href="#email.message.EmailMessage" title="email.message.EmailMessage"><code>EmailMessage</code></a> object (for <code>message/rfc822</code> parts), or a <code>bytes</code> object (for all other non-multipart types). Raise a <a class="reference internal" href="../exceptions/#KeyError" title="KeyError"><code>KeyError</code></a> if called on a <code>multipart</code>. If the part is a <code>text</code> part and <em>errors</em> is specified, use it as the error handler when decoding the payload to unicode. The default error handler is <code>replace</code>.</p> </dd>
</dl> <dl class="method"> <dt id="email.contentmanager.set_content">
<code>email.contentmanager.set_content(msg, &lt;'str'&gt;, subtype="plain", charset='utf-8' cte=None, disposition=None, filename=None, cid=None, params=None, headers=None)</code> </dt> <dt>
<code>email.contentmanager.set_content(msg, &lt;'bytes'&gt;, maintype, subtype, cte="base64", disposition=None, filename=None, cid=None, params=None, headers=None)</code> </dt> <dt>
<code>email.contentmanager.set_content(msg, &lt;'Message'&gt;, cte=None, disposition=None, filename=None, cid=None, params=None, headers=None)</code> </dt> <dt>
<code>email.contentmanager.set_content(msg, &lt;'list'&gt;, subtype='mixed', disposition=None, filename=None, cid=None, params=None, headers=None)</code> </dt> <dd>
<p>Add headers and payload to <em>msg</em>:</p> <p>Add a <em class="mailheader">Content-Type</em> header with a <code>maintype/subtype</code> value.</p>  <ul class="simple"> <li>For <code>str</code>, set the MIME <code>maintype</code> to <code>text</code>, and set the subtype to <em>subtype</em> if it is specified, or <code>plain</code> if it is not.</li> <li>For <code>bytes</code>, use the specified <em>maintype</em> and <em>subtype</em>, or raise a <a class="reference internal" href="../exceptions/#TypeError" title="TypeError"><code>TypeError</code></a> if they are not specified.</li> <li>For <a class="reference internal" href="../email.message/#email.message.Message" title="email.message.Message"><code>Message</code></a> objects, set the maintype to <code>message</code>, and set the subtype to <em>subtype</em> if it is specified or <code>rfc822</code> if it is not. If <em>subtype</em> is <code>partial</code>, raise an error (<code>bytes</code> objects must be used to construct <code>message/partial</code> parts).</li> <li>For <em>&lt;’list’&gt;</em>, which should be a list of <a class="reference internal" href="../email.message/#email.message.Message" title="email.message.Message"><code>Message</code></a> objects, set the <code>maintype</code> to <code>multipart</code>, and the <code>subtype</code> to <em>subtype</em> if it is specified, and <code>mixed</code> if it is not. If the message parts in the <em>&lt;’list’&gt;</em> have <em class="mailheader">MIME-Version</em> headers, remove them.</li> </ul>  <p>If <em>charset</em> is provided (which is valid only for <code>str</code>), encode the string to bytes using the specified character set. The default is <code>utf-8</code>. If the specified <em>charset</em> is a known alias for a standard MIME charset name, use the standard charset instead.</p> <p>If <em>cte</em> is set, encode the payload using the specified content transfer encoding, and set the <em class="mailheader">Content-Transfer-Endcoding</em> header to that value. For <code>str</code> objects, if it is not set use heuristics to determine the most compact encoding. Possible values for <em>cte</em> are <code>quoted-printable</code>, <code>base64</code>, <code>7bit</code>, <code>8bit</code>, and <code>binary</code>. If the input cannot be encoded in the specified encoding (eg: <code>7bit</code>), raise a <a class="reference internal" href="../exceptions/#ValueError" title="ValueError"><code>ValueError</code></a>. For <a class="reference internal" href="../email.message/#email.message.Message" title="email.message.Message"><code>Message</code></a>, per <a class="rfc reference external" href="https://tools.ietf.org/html/rfc2046.html" id="index-0" target="_blank"><strong>RFC 2046</strong></a>, raise an error if a <em>cte</em> of <code>quoted-printable</code> or <code>base64</code> is requested for <em>subtype</em> <code>rfc822</code>, and for any <em>cte</em> other than <code>7bit</code> for <em>subtype</em> <code>external-body</code>. For <code>message/rfc822</code>, use <code>8bit</code> if <em>cte</em> is not specified. For all other values of <em>subtype</em>, use <code>7bit</code>.</p> <div class="admonition note"> <p class="first admonition-title">Note</p> <p class="last">A <em>cte</em> of <code>binary</code> does not actually work correctly yet. The <code>Message</code> object as modified by <code>set_content</code> is correct, but <a class="reference internal" href="../email.generator/#email.generator.BytesGenerator" title="email.generator.BytesGenerator"><code>BytesGenerator</code></a> does not serialize it correctly.</p> </div> <p>If <em>disposition</em> is set, use it as the value of the <em class="mailheader">Content-Disposition</em> header. If not specified, and <em>filename</em> is specified, add the header with the value <code>attachment</code>. If it is not specified and <em>filename</em> is also not specified, do not add the header. The only valid values for <em>disposition</em> are <code>attachment</code> and <code>inline</code>.</p> <p>If <em>filename</em> is specified, use it as the value of the <code>filename</code> parameter of the <em class="mailheader">Content-Disposition</em> header. There is no default.</p> <p>If <em>cid</em> is specified, add a <em class="mailheader">Content-ID</em> header with <em>cid</em> as its value.</p> <p>If <em>params</em> is specified, iterate its <code>items</code> method and use the resulting <code>(key, value)</code> pairs to set additional parameters on the <em class="mailheader">Content-Type</em> header.</p> <p>If <em>headers</em> is specified and is a list of strings of the form <code>headername: headervalue</code> or a list of <code>header</code> objects (distinguished from strings by having a <code>name</code> attribute), add the headers to <em>msg</em>.</p> </dd>
</dl> </dd>
</dl>
<div class="_attribution">
  <p class="_attribution-p">
    © 2001–2017 Python Software Foundation<br>Licensed under the PSF License.<br>
    <a href="https://docs.python.org/3.5/library/email.contentmanager.html" class="_attribution-link" target="_blank">https://docs.python.org/3.5/library/email.contentmanager.html</a>
  </p>
</div>

			</div>
		</div>
	</section>

	</div>
</body>
</html>
