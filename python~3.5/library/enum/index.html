
<!DOCTYPE HTML>

<html lang="en">

<head>
  <meta charset="utf-8">
  <title>Enum - Python 3.5 - W3cubDocs</title>
  
  <meta name="description" content=" New in version 3.4. ">
  <meta name="keywords" content="enum, —, support, for, enumerations, -, python, python~3.5">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="http://docs.w3cub.com/python~3.5/library/enum/">
  <link href="/favicon.png" rel="icon">
  <link type="text/css" rel="stylesheet" href="/assets/application-50364fff564ce3b6327021805f3f00e2957b441cf27f576a7dd4ff63bbc47047.css">
  <script type="text/javascript" src="/assets/application-db64bfd54ceb42be11af7995804cf4902548419ceb79d509b0b7d62c22d98e6f.js"></script>
  <script src="/json/python~3.5.js"></script>
  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-71174418-1']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>


</head>

<body>
	<div class="_app">
	<header class="_header">
  
  <form class="_search">
    <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
    <a class="_search-clear"></a>
    <div class="_search-tag"></div>
  </form>
  
  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/python~3.5/" class="_nav-link" title="" style="margin-left:0;">Python 3.5</a></span>
  
  <nav class="_nav">
    <a href="/app/" class="_nav-link ">App</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		<div class="_list">
			
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<div class="_page _sphinx">
				
<h1 id="enum-support-for-enumerations"> enum — Support for enumerations</h1> <div class="versionadded" id="module-enum"> <p><span class="versionmodified">New in version 3.4.</span></p> </div> <p><strong>Source code:</strong> <a class="reference external" href="https://hg.python.org/cpython/file/3.5/Lib/enum.py" target="_blank">Lib/enum.py</a></p>  <p>An enumeration is a set of symbolic names (members) bound to unique, constant values. Within an enumeration, the members can be compared by identity, and the enumeration itself can be iterated over.</p>  <h2 id="module-contents">1. Module Contents</h2> <p>This module defines two enumeration classes that can be used to define unique sets of names and values: <a class="reference internal" href="#enum.Enum" title="enum.Enum"><code>Enum</code></a> and <a class="reference internal" href="#enum.IntEnum" title="enum.IntEnum"><code>IntEnum</code></a>. It also defines one decorator, <a class="reference internal" href="#enum.unique" title="enum.unique"><code>unique()</code></a>.</p> <dl class="class"> <dt id="enum.Enum">
<code>class enum.Enum</code> </dt> <dd>
<p>Base class for creating enumerated constants. See section <a class="reference internal" href="#functional-api">Functional API</a> for an alternate construction syntax.</p> </dd>
</dl> <dl class="class"> <dt id="enum.IntEnum">
<code>class enum.IntEnum</code> </dt> <dd>
<p>Base class for creating enumerated constants that are also subclasses of <a class="reference internal" href="../functions/#int" title="int"><code>int</code></a>.</p> </dd>
</dl> <dl class="function"> <dt id="enum.unique">
<code>enum.unique()</code> </dt> <dd>
<p>Enum class decorator that ensures only one name is bound to any one value.</p> </dd>
</dl>   <h2 id="creating-an-enum">2. Creating an Enum</h2> <p>Enumerations are created using the <a class="reference internal" href="https://docs.python.org/3.5/reference/compound_stmts.html#class" target="_blank"><code>class</code></a> syntax, which makes them easy to read and write. An alternative creation method is described in <a class="reference internal" href="#functional-api">Functional API</a>. To define an enumeration, subclass <a class="reference internal" href="#enum.Enum" title="enum.Enum"><code>Enum</code></a> as follows:</p> <pre data-language="python">&gt;&gt;&gt; from enum import Enum
&gt;&gt;&gt; class Color(Enum):
...     red = 1
...     green = 2
...     blue = 3
...
</pre> <div class="admonition note"> <p class="first admonition-title">Note</p> <p>Nomenclature</p> <ul class="last simple"> <li>The class <code>Color</code> is an <em>enumeration</em> (or <em>enum</em>)</li> <li>The attributes <code>Color.red</code>, <code>Color.green</code>, etc., are <em>enumeration members</em> (or <em>enum members</em>).</li> <li>The enum members have <em>names</em> and <em>values</em> (the name of <code>Color.red</code> is <code>red</code>, the value of <code>Color.blue</code> is <code>3</code>, etc.)</li> </ul> </div> <div class="admonition note"> <p class="first admonition-title">Note</p> <p class="last">Even though we use the <a class="reference internal" href="https://docs.python.org/3.5/reference/compound_stmts.html#class" target="_blank"><code>class</code></a> syntax to create Enums, Enums are not normal Python classes. See <a class="reference internal" href="#how-are-enums-different">How are Enums different?</a> for more details.</p> </div> <p>Enumeration members have human readable string representations:</p> <pre data-language="python">&gt;&gt;&gt; print(Color.red)
Color.red
</pre> <p>...while their <code>repr</code> has more information:</p> <pre data-language="python">&gt;&gt;&gt; print(repr(Color.red))
&lt;Color.red: 1&gt;
</pre> <p>The <em>type</em> of an enumeration member is the enumeration it belongs to:</p> <pre data-language="python">&gt;&gt;&gt; type(Color.red)
&lt;enum 'Color'&gt;
&gt;&gt;&gt; isinstance(Color.green, Color)
True
&gt;&gt;&gt;
</pre> <p>Enum members also have a property that contains just their item name:</p> <pre data-language="python">&gt;&gt;&gt; print(Color.red.name)
red
</pre> <p>Enumerations support iteration, in definition order:</p> <pre data-language="python">&gt;&gt;&gt; class Shake(Enum):
...     vanilla = 7
...     chocolate = 4
...     cookies = 9
...     mint = 3
...
&gt;&gt;&gt; for shake in Shake:
...     print(shake)
...
Shake.vanilla
Shake.chocolate
Shake.cookies
Shake.mint
</pre> <p>Enumeration members are hashable, so they can be used in dictionaries and sets:</p> <pre data-language="python">&gt;&gt;&gt; apples = {}
&gt;&gt;&gt; apples[Color.red] = 'red delicious'
&gt;&gt;&gt; apples[Color.green] = 'granny smith'
&gt;&gt;&gt; apples == {Color.red: 'red delicious', Color.green: 'granny smith'}
True
</pre>   <h2 id="programmatic-access-to-enumeration-members-and-their-attributes">3. Programmatic access to enumeration members and their attributes</h2> <p>Sometimes it’s useful to access members in enumerations programmatically (i.e. situations where <code>Color.red</code> won’t do because the exact color is not known at program-writing time). <code>Enum</code> allows such access:</p> <pre data-language="python">&gt;&gt;&gt; Color(1)
&lt;Color.red: 1&gt;
&gt;&gt;&gt; Color(3)
&lt;Color.blue: 3&gt;
</pre> <p>If you want to access enum members by <em>name</em>, use item access:</p> <pre data-language="python">&gt;&gt;&gt; Color['red']
&lt;Color.red: 1&gt;
&gt;&gt;&gt; Color['green']
&lt;Color.green: 2&gt;
</pre> <p>If you have an enum member and need its <code>name</code> or <code>value</code>:</p> <pre data-language="python">&gt;&gt;&gt; member = Color.red
&gt;&gt;&gt; member.name
'red'
&gt;&gt;&gt; member.value
1
</pre>   <h2 id="duplicating-enum-members-and-values">4. Duplicating enum members and values</h2> <p>Having two enum members with the same name is invalid:</p> <pre data-language="python">&gt;&gt;&gt; class Shape(Enum):
...     square = 2
...     square = 3
...
Traceback (most recent call last):
...
TypeError: Attempted to reuse key: 'square'
</pre> <p>However, two enum members are allowed to have the same value. Given two members A and B with the same value (and A defined first), B is an alias to A. By-value lookup of the value of A and B will return A. By-name lookup of B will also return A:</p> <pre data-language="python">&gt;&gt;&gt; class Shape(Enum):
...     square = 2
...     diamond = 1
...     circle = 3
...     alias_for_square = 2
...
&gt;&gt;&gt; Shape.square
&lt;Shape.square: 2&gt;
&gt;&gt;&gt; Shape.alias_for_square
&lt;Shape.square: 2&gt;
&gt;&gt;&gt; Shape(2)
&lt;Shape.square: 2&gt;
</pre> <div class="admonition note"> <p class="first admonition-title">Note</p> <p class="last">Attempting to create a member with the same name as an already defined attribute (another member, a method, etc.) or attempting to create an attribute with the same name as a member is not allowed.</p> </div>   <h2 id="ensuring-unique-enumeration-values">5. Ensuring unique enumeration values</h2> <p>By default, enumerations allow multiple names as aliases for the same value. When this behavior isn’t desired, the following decorator can be used to ensure each value is used only once in the enumeration:</p> <dl class="function"> <dt>
<code>@enum.unique</code> </dt> 
</dl> <p>A <a class="reference internal" href="https://docs.python.org/3.5/reference/compound_stmts.html#class" target="_blank"><code>class</code></a> decorator specifically for enumerations. It searches an enumeration’s <code>__members__</code> gathering any aliases it finds; if any are found <a class="reference internal" href="../exceptions/#ValueError" title="ValueError"><code>ValueError</code></a> is raised with the details:</p> <pre data-language="python">&gt;&gt;&gt; from enum import Enum, unique
&gt;&gt;&gt; @unique
... class Mistake(Enum):
...     one = 1
...     two = 2
...     three = 3
...     four = 3
...
Traceback (most recent call last):
...
ValueError: duplicate values found in &lt;enum 'Mistake'&gt;: four -&gt; three
</pre>   <h2 id="iteration">6. Iteration</h2> <p>Iterating over the members of an enum does not provide the aliases:</p> <pre data-language="python">&gt;&gt;&gt; list(Shape)
[&lt;Shape.square: 2&gt;, &lt;Shape.diamond: 1&gt;, &lt;Shape.circle: 3&gt;]
</pre> <p>The special attribute <code>__members__</code> is an ordered dictionary mapping names to members. It includes all names defined in the enumeration, including the aliases:</p> <pre data-language="python">&gt;&gt;&gt; for name, member in Shape.__members__.items():
...     name, member
...
('square', &lt;Shape.square: 2&gt;)
('diamond', &lt;Shape.diamond: 1&gt;)
('circle', &lt;Shape.circle: 3&gt;)
('alias_for_square', &lt;Shape.square: 2&gt;)
</pre> <p>The <code>__members__</code> attribute can be used for detailed programmatic access to the enumeration members. For example, finding all the aliases:</p> <pre data-language="python">&gt;&gt;&gt; [name for name, member in Shape.__members__.items() if member.name != name]
['alias_for_square']
</pre>   <h2 id="comparisons">7. Comparisons</h2> <p>Enumeration members are compared by identity:</p> <pre data-language="python">&gt;&gt;&gt; Color.red is Color.red
True
&gt;&gt;&gt; Color.red is Color.blue
False
&gt;&gt;&gt; Color.red is not Color.blue
True
</pre> <p>Ordered comparisons between enumeration values are <em>not</em> supported. Enum members are not integers (but see <a class="reference internal" href="#intenum">IntEnum</a> below):</p> <pre data-language="python">&gt;&gt;&gt; Color.red &lt; Color.blue
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
TypeError: unorderable types: Color() &lt; Color()
</pre> <p>Equality comparisons are defined though:</p> <pre data-language="python">&gt;&gt;&gt; Color.blue == Color.red
False
&gt;&gt;&gt; Color.blue != Color.red
True
&gt;&gt;&gt; Color.blue == Color.blue
True
</pre> <p>Comparisons against non-enumeration values will always compare not equal (again, <a class="reference internal" href="#enum.IntEnum" title="enum.IntEnum"><code>IntEnum</code></a> was explicitly designed to behave differently, see below):</p> <pre data-language="python">&gt;&gt;&gt; Color.blue == 2
False
</pre>   <h2 id="allowed-members-and-attributes-of-enumerations">8. Allowed members and attributes of enumerations</h2> <p>The examples above use integers for enumeration values. Using integers is short and handy (and provided by default by the <a class="reference internal" href="#functional-api">Functional API</a>), but not strictly enforced. In the vast majority of use-cases, one doesn’t care what the actual value of an enumeration is. But if the value <em>is</em> important, enumerations can have arbitrary values.</p> <p>Enumerations are Python classes, and can have methods and special methods as usual. If we have this enumeration:</p> <pre data-language="python">&gt;&gt;&gt; class Mood(Enum):
...     funky = 1
...     happy = 3
...
...     def describe(self):
...         # self is the member here
...         return self.name, self.value
...
...     def __str__(self):
...         return 'my custom str! {0}'.format(self.value)
...
...     @classmethod
...     def favorite_mood(cls):
...         # cls here is the enumeration
...         return cls.happy
...
</pre> <p>Then:</p> <pre data-language="python">&gt;&gt;&gt; Mood.favorite_mood()
&lt;Mood.happy: 3&gt;
&gt;&gt;&gt; Mood.happy.describe()
('happy', 3)
&gt;&gt;&gt; str(Mood.funky)
'my custom str! 1'
</pre> <p>The rules for what is allowed are as follows: names that start and end with a single underscore are reserved by enum and cannot be used; all other attributes defined within an enumeration will become members of this enumeration, with the exception of special methods (<a class="reference internal" href="https://docs.python.org/3.5/reference/datamodel.html#object.__str__" title="object.__str__" target="_blank"><code>__str__()</code></a>, <a class="reference internal" href="https://docs.python.org/3.5/reference/datamodel.html#object.__add__" title="object.__add__" target="_blank"><code>__add__()</code></a>, etc.) and descriptors (methods are also descriptors).</p> <p>Note: if your enumeration defines <a class="reference internal" href="https://docs.python.org/3.5/reference/datamodel.html#object.__new__" title="object.__new__" target="_blank"><code>__new__()</code></a> and/or <a class="reference internal" href="https://docs.python.org/3.5/reference/datamodel.html#object.__init__" title="object.__init__" target="_blank"><code>__init__()</code></a> then whatever value(s) were given to the enum member will be passed into those methods. See <a class="reference internal" href="#planet">Planet</a> for an example.</p>   <h2 id="restricted-subclassing-of-enumerations">9. Restricted subclassing of enumerations</h2> <p>Subclassing an enumeration is allowed only if the enumeration does not define any members. So this is forbidden:</p> <pre data-language="python">&gt;&gt;&gt; class MoreColor(Color):
...     pink = 17
...
Traceback (most recent call last):
...
TypeError: Cannot extend enumerations
</pre> <p>But this is allowed:</p> <pre data-language="python">&gt;&gt;&gt; class Foo(Enum):
...     def some_behavior(self):
...         pass
...
&gt;&gt;&gt; class Bar(Foo):
...     happy = 1
...     sad = 2
...
</pre> <p>Allowing subclassing of enums that define members would lead to a violation of some important invariants of types and instances. On the other hand, it makes sense to allow sharing some common behavior between a group of enumerations. (See <a class="reference internal" href="#orderedenum">OrderedEnum</a> for an example.)</p>   <h2 id="pickling">10. Pickling</h2> <p>Enumerations can be pickled and unpickled:</p> <pre data-language="python">&gt;&gt;&gt; from test.test_enum import Fruit
&gt;&gt;&gt; from pickle import dumps, loads
&gt;&gt;&gt; Fruit.tomato is loads(dumps(Fruit.tomato))
True
</pre> <p>The usual restrictions for pickling apply: picklable enums must be defined in the top level of a module, since unpickling requires them to be importable from that module.</p> <div class="admonition note"> <p class="first admonition-title">Note</p> <p class="last">With pickle protocol version 4 it is possible to easily pickle enums nested in other classes.</p> </div> <p>It is possible to modify how Enum members are pickled/unpickled by defining <a class="reference internal" href="../pickle/#object.__reduce_ex__" title="object.__reduce_ex__"><code>__reduce_ex__()</code></a> in the enumeration class.</p>   <h2 id="functional-api">11. Functional API</h2> <p>The <a class="reference internal" href="#enum.Enum" title="enum.Enum"><code>Enum</code></a> class is callable, providing the following functional API:</p> <pre data-language="python">&gt;&gt;&gt; Animal = Enum('Animal', 'ant bee cat dog')
&gt;&gt;&gt; Animal
&lt;enum 'Animal'&gt;
&gt;&gt;&gt; Animal.ant
&lt;Animal.ant: 1&gt;
&gt;&gt;&gt; Animal.ant.value
1
&gt;&gt;&gt; list(Animal)
[&lt;Animal.ant: 1&gt;, &lt;Animal.bee: 2&gt;, &lt;Animal.cat: 3&gt;, &lt;Animal.dog: 4&gt;]
</pre> <p>The semantics of this API resemble <a class="reference internal" href="../collections/#collections.namedtuple" title="collections.namedtuple"><code>namedtuple</code></a>. The first argument of the call to <a class="reference internal" href="#enum.Enum" title="enum.Enum"><code>Enum</code></a> is the name of the enumeration.</p> <p>The second argument is the <em>source</em> of enumeration member names. It can be a whitespace-separated string of names, a sequence of names, a sequence of 2-tuples with key/value pairs, or a mapping (e.g. dictionary) of names to values. The last two options enable assigning arbitrary values to enumerations; the others auto-assign increasing integers starting with 1 (use the <code>start</code> parameter to specify a different starting value). A new class derived from <a class="reference internal" href="#enum.Enum" title="enum.Enum"><code>Enum</code></a> is returned. In other words, the above assignment to <code>Animal</code> is equivalent to:</p> <pre data-language="python">&gt;&gt;&gt; class Animal(Enum):
...     ant = 1
...     bee = 2
...     cat = 3
...     dog = 4
...
</pre> <p>The reason for defaulting to <code>1</code> as the starting number and not <code>0</code> is that <code>0</code> is <code>False</code> in a boolean sense, but enum members all evaluate to <code>True</code>.</p> <p>Pickling enums created with the functional API can be tricky as frame stack implementation details are used to try and figure out which module the enumeration is being created in (e.g. it will fail if you use a utility function in separate module, and also may not work on IronPython or Jython). The solution is to specify the module name explicitly as follows:</p> <pre data-language="python">&gt;&gt;&gt; Animal = Enum('Animal', 'ant bee cat dog', module=__name__)
</pre> <div class="admonition warning"> <p class="first admonition-title">Warning</p> <p class="last">If <code>module</code> is not supplied, and Enum cannot determine what it is, the new Enum members will not be unpicklable; to keep errors closer to the source, pickling will be disabled.</p> </div> <p>The new pickle protocol 4 also, in some circumstances, relies on <a class="reference internal" href="../stdtypes/#definition.__qualname__" title="definition.__qualname__"><code>__qualname__</code></a> being set to the location where pickle will be able to find the class. For example, if the class was made available in class SomeData in the global scope:</p> <pre data-language="python">&gt;&gt;&gt; Animal = Enum('Animal', 'ant bee cat dog', qualname='SomeData.Animal')
</pre> <p>The complete signature is:</p> <pre data-language="python">Enum(value='NewEnumName', names=&lt;...&gt;, *, module='...', qualname='...', type=&lt;mixed-in class&gt;, start=1)
</pre> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr class="field-odd field">
<th class="field-name">value:</th>
<td class="field-body">
<p class="first">What the new Enum class will record as its name.</p> </td> </tr> <tr class="field-even field">
<th class="field-name">names:</th>
<td class="field-body">
<p class="first">The Enum members. This can be a whitespace or comma separated string (values will start at 1 unless otherwise specified):</p> <pre data-language="python">'red green blue' | 'red,green,blue' | 'red, green, blue'
</pre> <p>or an iterator of names:</p> <pre data-language="python">['red', 'green', 'blue']
</pre> <p>or an iterator of (name, value) pairs:</p> <pre data-language="python">[('cyan', 4), ('magenta', 5), ('yellow', 6)]
</pre> <p>or a mapping:</p> <pre data-language="python">{'chartreuse': 7, 'sea_green': 11, 'rosemary': 42}
</pre> </td> </tr> <tr class="field-odd field">
<th class="field-name">module:</th>
<td class="field-body">
<p class="first">name of module where new Enum class can be found.</p> </td> </tr> <tr class="field-even field">
<th class="field-name">qualname:</th>
<td class="field-body">
<p class="first">where in module new Enum class can be found.</p> </td> </tr> <tr class="field-odd field">
<th class="field-name">type:</th>
<td class="field-body">
<p class="first">type to mix in to new Enum class.</p> </td> </tr> <tr class="field-even field">
<th class="field-name">start:</th>
<td class="field-body">
<p class="first last">number to start counting at if only names are passed in.</p> </td> </tr>  </table> <div class="versionchanged"> <p><span class="versionmodified">Changed in version 3.5: </span>The <em>start</em> parameter was added.</p> </div>   <h2 id="derived-enumerations">12. Derived Enumerations</h2>  <h3 id="intenum">12.1. IntEnum</h3> <p>A variation of <a class="reference internal" href="#enum.Enum" title="enum.Enum"><code>Enum</code></a> is provided which is also a subclass of <a class="reference internal" href="../functions/#int" title="int"><code>int</code></a>. Members of an <a class="reference internal" href="#enum.IntEnum" title="enum.IntEnum"><code>IntEnum</code></a> can be compared to integers; by extension, integer enumerations of different types can also be compared to each other:</p> <pre data-language="python">&gt;&gt;&gt; from enum import IntEnum
&gt;&gt;&gt; class Shape(IntEnum):
...     circle = 1
...     square = 2
...
&gt;&gt;&gt; class Request(IntEnum):
...     post = 1
...     get = 2
...
&gt;&gt;&gt; Shape == 1
False
&gt;&gt;&gt; Shape.circle == 1
True
&gt;&gt;&gt; Shape.circle == Request.post
True
</pre> <p>However, they still can’t be compared to standard <a class="reference internal" href="#enum.Enum" title="enum.Enum"><code>Enum</code></a> enumerations:</p> <pre data-language="python">&gt;&gt;&gt; class Shape(IntEnum):
...     circle = 1
...     square = 2
...
&gt;&gt;&gt; class Color(Enum):
...     red = 1
...     green = 2
...
&gt;&gt;&gt; Shape.circle == Color.red
False
</pre> <p><a class="reference internal" href="#enum.IntEnum" title="enum.IntEnum"><code>IntEnum</code></a> values behave like integers in other ways you’d expect:</p> <pre data-language="python">&gt;&gt;&gt; int(Shape.circle)
1
&gt;&gt;&gt; ['a', 'b', 'c'][Shape.circle]
'b'
&gt;&gt;&gt; [i for i in range(Shape.square)]
[0, 1]
</pre> <p>For the vast majority of code, <a class="reference internal" href="#enum.Enum" title="enum.Enum"><code>Enum</code></a> is strongly recommended, since <a class="reference internal" href="#enum.IntEnum" title="enum.IntEnum"><code>IntEnum</code></a> breaks some semantic promises of an enumeration (by being comparable to integers, and thus by transitivity to other unrelated enumerations). It should be used only in special cases where there’s no other choice; for example, when integer constants are replaced with enumerations and backwards compatibility is required with code that still expects integers.</p>   <h3 id="others">12.2. Others</h3> <p>While <a class="reference internal" href="#enum.IntEnum" title="enum.IntEnum"><code>IntEnum</code></a> is part of the <a class="reference internal" href="#module-enum" title="enum: Implementation of an enumeration class."><code>enum</code></a> module, it would be very simple to implement independently:</p> <pre data-language="python">class IntEnum(int, Enum):
    pass
</pre> <p>This demonstrates how similar derived enumerations can be defined; for example a <code>StrEnum</code> that mixes in <a class="reference internal" href="../stdtypes/#str" title="str"><code>str</code></a> instead of <a class="reference internal" href="../functions/#int" title="int"><code>int</code></a>.</p> <p>Some rules:</p> <ol class="arabic simple"> <li>When subclassing <a class="reference internal" href="#enum.Enum" title="enum.Enum"><code>Enum</code></a>, mix-in types must appear before <a class="reference internal" href="#enum.Enum" title="enum.Enum"><code>Enum</code></a> itself in the sequence of bases, as in the <a class="reference internal" href="#enum.IntEnum" title="enum.IntEnum"><code>IntEnum</code></a> example above.</li> <li>While <a class="reference internal" href="#enum.Enum" title="enum.Enum"><code>Enum</code></a> can have members of any type, once you mix in an additional type, all the members must have values of that type, e.g. <a class="reference internal" href="../functions/#int" title="int"><code>int</code></a> above. This restriction does not apply to mix-ins which only add methods and don’t specify another data type such as <a class="reference internal" href="../functions/#int" title="int"><code>int</code></a> or <a class="reference internal" href="../stdtypes/#str" title="str"><code>str</code></a>.</li> <li>When another data type is mixed in, the <code>value</code> attribute is <em>not the same</em> as the enum member itself, although it is equivalent and will compare equal.</li> <li>%-style formatting: <code>%s</code> and <code>%r</code> call the <a class="reference internal" href="#enum.Enum" title="enum.Enum"><code>Enum</code></a> class’s <a class="reference internal" href="https://docs.python.org/3.5/reference/datamodel.html#object.__str__" title="object.__str__" target="_blank"><code>__str__()</code></a> and <a class="reference internal" href="https://docs.python.org/3.5/reference/datamodel.html#object.__repr__" title="object.__repr__" target="_blank"><code>__repr__()</code></a> respectively; other codes (such as <code>%i</code> or <code>%h</code> for IntEnum) treat the enum member as its mixed-in type.</li> <li>
<a class="reference internal" href="../stdtypes/#str.format" title="str.format"><code>str.format()</code></a> (or <a class="reference internal" href="../functions/#format" title="format"><code>format()</code></a>) will use the mixed-in type’s <a class="reference internal" href="https://docs.python.org/3.5/reference/datamodel.html#object.__format__" title="object.__format__" target="_blank"><code>__format__()</code></a>. If the <a class="reference internal" href="#enum.Enum" title="enum.Enum"><code>Enum</code></a> class’s <a class="reference internal" href="../stdtypes/#str" title="str"><code>str()</code></a> or <a class="reference internal" href="../functions/#repr" title="repr"><code>repr()</code></a> is desired, use the <code>!s</code> or <code>!r</code> format codes.</li> </ol>    <h2 id="interesting-examples">13. Interesting examples</h2> <p>While <a class="reference internal" href="#enum.Enum" title="enum.Enum"><code>Enum</code></a> and <a class="reference internal" href="#enum.IntEnum" title="enum.IntEnum"><code>IntEnum</code></a> are expected to cover the majority of use-cases, they cannot cover them all. Here are recipes for some different types of enumerations that can be used directly, or as examples for creating one’s own.</p>  <h3 id="autonumber">13.1. AutoNumber</h3> <p>Avoids having to specify the value for each enumeration member:</p> <pre data-language="python">&gt;&gt;&gt; class AutoNumber(Enum):
...     def __new__(cls):
...         value = len(cls.__members__) + 1
...         obj = object.__new__(cls)
...         obj._value_ = value
...         return obj
...
&gt;&gt;&gt; class Color(AutoNumber):
...     red = ()
...     green = ()
...     blue = ()
...
&gt;&gt;&gt; Color.green.value == 2
True
</pre> <div class="admonition note"> <p class="first admonition-title">Note</p> <p class="last">The <a class="reference internal" href="https://docs.python.org/3.5/reference/datamodel.html#object.__new__" title="object.__new__" target="_blank"><code>__new__()</code></a> method, if defined, is used during creation of the Enum members; it is then replaced by Enum’s <a class="reference internal" href="https://docs.python.org/3.5/reference/datamodel.html#object.__new__" title="object.__new__" target="_blank"><code>__new__()</code></a> which is used after class creation for lookup of existing members.</p> </div>   <h3 id="orderedenum">13.2. OrderedEnum</h3> <p>An ordered enumeration that is not based on <a class="reference internal" href="#enum.IntEnum" title="enum.IntEnum"><code>IntEnum</code></a> and so maintains the normal <a class="reference internal" href="#enum.Enum" title="enum.Enum"><code>Enum</code></a> invariants (such as not being comparable to other enumerations):</p> <pre data-language="python">&gt;&gt;&gt; class OrderedEnum(Enum):
...     def __ge__(self, other):
...         if self.__class__ is other.__class__:
...             return self.value &gt;= other.value
...         return NotImplemented
...     def __gt__(self, other):
...         if self.__class__ is other.__class__:
...             return self.value &gt; other.value
...         return NotImplemented
...     def __le__(self, other):
...         if self.__class__ is other.__class__:
...             return self.value &lt;= other.value
...         return NotImplemented
...     def __lt__(self, other):
...         if self.__class__ is other.__class__:
...             return self.value &lt; other.value
...         return NotImplemented
...
&gt;&gt;&gt; class Grade(OrderedEnum):
...     A = 5
...     B = 4
...     C = 3
...     D = 2
...     F = 1
...
&gt;&gt;&gt; Grade.C &lt; Grade.A
True
</pre>   <h3 id="duplicatefreeenum">13.3. DuplicateFreeEnum</h3> <p>Raises an error if a duplicate member name is found instead of creating an alias:</p> <pre data-language="python">&gt;&gt;&gt; class DuplicateFreeEnum(Enum):
...     def __init__(self, *args):
...         cls = self.__class__
...         if any(self.value == e.value for e in cls):
...             a = self.name
...             e = cls(self.value).name
...             raise ValueError(
...                 "aliases not allowed in DuplicateFreeEnum:  %r --&gt; %r"
...                 % (a, e))
...
&gt;&gt;&gt; class Color(DuplicateFreeEnum):
...     red = 1
...     green = 2
...     blue = 3
...     grene = 2
...
Traceback (most recent call last):
...
ValueError: aliases not allowed in DuplicateFreeEnum:  'grene' --&gt; 'green'
</pre> <div class="admonition note"> <p class="first admonition-title">Note</p> <p class="last">This is a useful example for subclassing Enum to add or change other behaviors as well as disallowing aliases. If the only desired change is disallowing aliases, the <a class="reference internal" href="#enum.unique" title="enum.unique"><code>unique()</code></a> decorator can be used instead.</p> </div>   <h3 id="planet">13.4. Planet</h3> <p>If <a class="reference internal" href="https://docs.python.org/3.5/reference/datamodel.html#object.__new__" title="object.__new__" target="_blank"><code>__new__()</code></a> or <a class="reference internal" href="https://docs.python.org/3.5/reference/datamodel.html#object.__init__" title="object.__init__" target="_blank"><code>__init__()</code></a> is defined the value of the enum member will be passed to those methods:</p> <pre data-language="python">&gt;&gt;&gt; class Planet(Enum):
...     MERCURY = (3.303e+23, 2.4397e6)
...     VENUS   = (4.869e+24, 6.0518e6)
...     EARTH   = (5.976e+24, 6.37814e6)
...     MARS    = (6.421e+23, 3.3972e6)
...     JUPITER = (1.9e+27,   7.1492e7)
...     SATURN  = (5.688e+26, 6.0268e7)
...     URANUS  = (8.686e+25, 2.5559e7)
...     NEPTUNE = (1.024e+26, 2.4746e7)
...     def __init__(self, mass, radius):
...         self.mass = mass       # in kilograms
...         self.radius = radius   # in meters
...     @property
...     def surface_gravity(self):
...         # universal gravitational constant  (m3 kg-1 s-2)
...         G = 6.67300E-11
...         return G * self.mass / (self.radius * self.radius)
...
&gt;&gt;&gt; Planet.EARTH.value
(5.976e+24, 6378140.0)
&gt;&gt;&gt; Planet.EARTH.surface_gravity
9.802652743337129
</pre>    <h2 id="how-are-enums-different">14. How are Enums different?</h2> <p>Enums have a custom metaclass that affects many aspects of both derived Enum classes and their instances (members).</p>  <h3 id="enum-classes">14.1. Enum Classes</h3> <p>The <code>EnumMeta</code> metaclass is responsible for providing the <a class="reference internal" href="https://docs.python.org/3.5/reference/datamodel.html#object.__contains__" title="object.__contains__" target="_blank"><code>__contains__()</code></a>, <a class="reference internal" href="https://docs.python.org/3.5/reference/datamodel.html#object.__dir__" title="object.__dir__" target="_blank"><code>__dir__()</code></a>, <a class="reference internal" href="https://docs.python.org/3.5/reference/datamodel.html#object.__iter__" title="object.__iter__" target="_blank"><code>__iter__()</code></a> and other methods that allow one to do things with an <a class="reference internal" href="#enum.Enum" title="enum.Enum"><code>Enum</code></a> class that fail on a typical class, such as <code>list(Color)</code> or <code>some_var in Color</code>. <code>EnumMeta</code> is responsible for ensuring that various other methods on the final <a class="reference internal" href="#enum.Enum" title="enum.Enum"><code>Enum</code></a> class are correct (such as <a class="reference internal" href="https://docs.python.org/3.5/reference/datamodel.html#object.__new__" title="object.__new__" target="_blank"><code>__new__()</code></a>, <a class="reference internal" href="../pickle/#object.__getnewargs__" title="object.__getnewargs__"><code>__getnewargs__()</code></a>, <a class="reference internal" href="https://docs.python.org/3.5/reference/datamodel.html#object.__str__" title="object.__str__" target="_blank"><code>__str__()</code></a> and <a class="reference internal" href="https://docs.python.org/3.5/reference/datamodel.html#object.__repr__" title="object.__repr__" target="_blank"><code>__repr__()</code></a>).</p>   <h3 id="enum-members-aka-instances">14.2. Enum Members (aka instances)</h3> <p>The most interesting thing about Enum members is that they are singletons. <code>EnumMeta</code> creates them all while it is creating the <a class="reference internal" href="#enum.Enum" title="enum.Enum"><code>Enum</code></a> class itself, and then puts a custom <a class="reference internal" href="https://docs.python.org/3.5/reference/datamodel.html#object.__new__" title="object.__new__" target="_blank"><code>__new__()</code></a> in place to ensure that no new ones are ever instantiated by returning only the existing member instances.</p>   <h3 id="finer-points">14.3. Finer Points</h3> <p><a class="reference internal" href="#enum.Enum" title="enum.Enum"><code>Enum</code></a> members are instances of an <a class="reference internal" href="#enum.Enum" title="enum.Enum"><code>Enum</code></a> class, and even though they are accessible as <code>EnumClass.member</code>, they should not be accessed directly from the member as that lookup may fail or, worse, return something besides the <a class="reference internal" href="#enum.Enum" title="enum.Enum"><code>Enum</code></a> member you looking for:</p> <pre data-language="python">&gt;&gt;&gt; class FieldTypes(Enum):
...     name = 0
...     value = 1
...     size = 2
...
&gt;&gt;&gt; FieldTypes.value.size
&lt;FieldTypes.size: 2&gt;
&gt;&gt;&gt; FieldTypes.size.value
2
</pre> <div class="versionchanged"> <p><span class="versionmodified">Changed in version 3.5.</span></p> </div> <p>The <code>__members__</code> attribute is only available on the class.</p> <p>If you give your <a class="reference internal" href="#enum.Enum" title="enum.Enum"><code>Enum</code></a> subclass extra methods, like the <a class="reference internal" href="#planet">Planet</a> class above, those methods will show up in a <a class="reference internal" href="../functions/#dir" title="dir"><code>dir()</code></a> of the member, but not of the class:</p> <pre data-language="python">&gt;&gt;&gt; dir(Planet)
['EARTH', 'JUPITER', 'MARS', 'MERCURY', 'NEPTUNE', 'SATURN', 'URANUS', 'VENUS', '__class__', '__doc__', '__members__', '__module__']
&gt;&gt;&gt; dir(Planet.EARTH)
['__class__', '__doc__', '__module__', 'name', 'surface_gravity', 'value']
</pre> <p>The <a class="reference internal" href="https://docs.python.org/3.5/reference/datamodel.html#object.__new__" title="object.__new__" target="_blank"><code>__new__()</code></a> method will only be used for the creation of the <a class="reference internal" href="#enum.Enum" title="enum.Enum"><code>Enum</code></a> members – after that it is replaced. Any custom <a class="reference internal" href="https://docs.python.org/3.5/reference/datamodel.html#object.__new__" title="object.__new__" target="_blank"><code>__new__()</code></a> method must create the object and set the <code>_value_</code> attribute appropriately.</p> <p>If you wish to change how <a class="reference internal" href="#enum.Enum" title="enum.Enum"><code>Enum</code></a> members are looked up you should either write a helper function or a <a class="reference internal" href="../functions/#classmethod" title="classmethod"><code>classmethod()</code></a> for the <a class="reference internal" href="#enum.Enum" title="enum.Enum"><code>Enum</code></a> subclass.</p>
<div class="_attribution">
  <p class="_attribution-p">
    © 2001–2017 Python Software Foundation<br>Licensed under the PSF License.<br>
    <a href="https://docs.python.org/3.5/library/enum.html" class="_attribution-link" target="_blank">https://docs.python.org/3.5/library/enum.html</a>
  </p>
</div>

			</div>
		</div>
	</section>

	</div>
</body>
</html>
