
<!DOCTYPE HTML>

<html lang="en">

<head>
  <meta charset="utf-8">
  <title>std&#58;&#58;net&#58;&#58;UdpSocket - Rust - W3cubDocs</title>
  
  <meta name="description" content=" A User Datagram Protocol socket. ">
  <meta name="keywords" content="struct, std, net, udpsocket, -, rust">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="http://docs.w3cub.com/rust/std/net/struct.udpsocket/">
  <link href="/favicon.png" rel="icon">
  <link type="text/css" rel="stylesheet" href="/assets/application-50364fff564ce3b6327021805f3f00e2957b441cf27f576a7dd4ff63bbc47047.css">
  <script type="text/javascript" src="/assets/application-db64bfd54ceb42be11af7995804cf4902548419ceb79d509b0b7d62c22d98e6f.js"></script>
  <script src="/json/rust.js"></script>
  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-71174418-1']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>


</head>

<body>
	<div class="_app">
	<header class="_header">
  
  <form class="_search">
    <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
    <a class="_search-clear"></a>
    <div class="_search-tag"></div>
  </form>
  
  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/rust/" class="_nav-link" title="" style="margin-left:0;">Rust</a></span>
  
  <nav class="_nav">
    <a href="/app/" class="_nav-link ">App</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		<div class="_list">
			
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<div class="_page _rust">
				
<h1 class="fqn">Struct std::net::UdpSocket</h1> <pre class="rust struct" data-language="rust">pub struct UdpSocket(_);</pre>
<p>A User Datagram Protocol socket.</p> <p>This is an implementation of a bound UDP socket. This supports both IPv4 and IPv6 addresses, and there is no corresponding notion of a server because UDP is a datagram protocol.</p> <h4 id="examples" class="section-header">Examples</h4> <pre class="rust rust-example-rendered" data-language="rust">
use std::net::UdpSocket;

{
    let mut socket = UdpSocket::bind("127.0.0.1:34254")?;

    // read from the socket
    let mut buf = [0; 10];
    let (amt, src) = socket.recv_from(&amp;mut buf)?;

    // send a reply to the socket we received data from
    let buf = &amp;mut buf[..amt];
    buf.reverse();
    socket.send_to(buf, &amp;src)?;
} // the socket is closed here</pre> <h2 id="methods">Methods</h2>
<h3 class="impl">
<span class="in-band"><code>impl <a class="struct" href="../struct.udpsocket/" title="std::net::UdpSocket">UdpSocket</a></code></span><span class="out-of-band">
<a class="srclink" href="https://doc.rust-lang.org/src/std/net/udp.rs.html#48-599" title="goto source code" target="_blank">[src]</a></span>
</h3> <h4 id="method.bind" class="method"><span id="bind.v" class="invisible"><code>fn <a href="#method.bind" class="fnname">bind</a>&lt;A: <a class="trait" href="../trait.tosocketaddrs/" title="std::net::ToSocketAddrs">ToSocketAddrs</a>&gt;(addr: A) -&gt; <a class="type" href="../../io/type.result/" title="std::io::Result">Result</a>&lt;<a class="struct" href="../struct.udpsocket/" title="std::net::UdpSocket">UdpSocket</a>&gt;</code></span></h4> <div class="docblock">
<p>Creates a UDP socket from the given address.</p> <p>The address type can be any implementor of <a href="../trait.tosocketaddrs/"><code>ToSocketAddrs</code></a> trait. See its documentation for concrete examples.</p> <h4 id="examples-1" class="section-header">Examples</h4> <pre class="rust rust-example-rendered" data-language="rust">
use std::net::UdpSocket;

let socket = UdpSocket::bind("127.0.0.1:34254").expect("couldn't bind to address");</pre> </div>
<h4 id="method.recv_from" class="method"><span id="recv_from.v" class="invisible"><code>fn <a href="#method.recv_from" class="fnname">recv_from</a>(&amp;self, buf: <a class="primitive" href="../../primitive.slice/">&amp;mut [</a><a class="primitive" href="../../primitive.u8/">u8</a><a class="primitive" href="../../primitive.slice/">]</a>) -&gt; <a class="type" href="../../io/type.result/" title="std::io::Result">Result</a>&lt;<a class="primitive" href="../../primitive.tuple/">(</a><a class="primitive" href="../../primitive.usize/">usize</a>, <a class="enum" href="../enum.socketaddr/" title="std::net::SocketAddr">SocketAddr</a><a class="primitive" href="../../primitive.tuple/">)</a>&gt;</code></span></h4> <div class="docblock">
<p>Receives data from the socket. On success, returns the number of bytes read and the address from whence the data came.</p> <h4 id="examples-2" class="section-header">Examples</h4> <pre class="rust rust-example-rendered" data-language="rust">
use std::net::UdpSocket;

let socket = UdpSocket::bind("127.0.0.1:34254").expect("couldn't bind to address");
let mut buf = [0; 10];
let (number_of_bytes, src_addr) = socket.recv_from(&amp;mut buf)
                                        .expect("Didn't receive data");</pre> </div>
<h4 id="method.send_to" class="method"><span id="send_to.v" class="invisible"><code>fn <a href="#method.send_to" class="fnname">send_to</a>&lt;A: <a class="trait" href="../trait.tosocketaddrs/" title="std::net::ToSocketAddrs">ToSocketAddrs</a>&gt;(&amp;self, buf: <a class="primitive" href="../../primitive.slice/">&amp;[</a><a class="primitive" href="../../primitive.u8/">u8</a><a class="primitive" href="../../primitive.slice/">]</a>, addr: A) -&gt; <a class="type" href="../../io/type.result/" title="std::io::Result">Result</a>&lt;<a class="primitive" href="../../primitive.usize/">usize</a>&gt;</code></span></h4> <div class="docblock">
<p>Sends data on the socket to the given address. On success, returns the number of bytes written.</p> <p>Address type can be any implementor of <a href="../trait.tosocketaddrs/"><code>ToSocketAddrs</code></a> trait. See its documentation for concrete examples.</p> <p>This will return an error when the IP version of the local socket does not match that returned from <a href="../trait.tosocketaddrs/"><code>ToSocketAddrs</code></a>.</p> <p>See <a href="https://github.com/rust-lang/rust/issues/34202" target="_blank">https://github.com/rust-lang/rust/issues/34202</a> for more details.</p> <h4 id="examples-3" class="section-header">Examples</h4> <pre class="rust rust-example-rendered" data-language="rust">
use std::net::UdpSocket;

let socket = UdpSocket::bind("127.0.0.1:34254").expect("couldn't bind to address");
socket.send_to(&amp;[0; 10], "127.0.0.1:4242").expect("couldn't send data");</pre> </div>
<h4 id="method.local_addr" class="method"><span id="local_addr.v" class="invisible"><code>fn <a href="#method.local_addr" class="fnname">local_addr</a>(&amp;self) -&gt; <a class="type" href="../../io/type.result/" title="std::io::Result">Result</a>&lt;<a class="enum" href="../enum.socketaddr/" title="std::net::SocketAddr">SocketAddr</a>&gt;</code></span></h4> <div class="docblock">
<p>Returns the socket address that this socket was created from.</p> <h4 id="examples-4" class="section-header">Examples</h4> <pre class="rust rust-example-rendered" data-language="rust">
use std::net::{Ipv4Addr, SocketAddr, SocketAddrV4, UdpSocket};

let socket = UdpSocket::bind("127.0.0.1:34254").expect("couldn't bind to address");
assert_eq!(socket.local_addr().unwrap(),
           SocketAddr::V4(SocketAddrV4::new(Ipv4Addr::new(127, 0, 0, 1), 34254)));</pre> </div>
<h4 id="method.try_clone" class="method"><span id="try_clone.v" class="invisible"><code>fn <a href="#method.try_clone" class="fnname">try_clone</a>(&amp;self) -&gt; <a class="type" href="../../io/type.result/" title="std::io::Result">Result</a>&lt;<a class="struct" href="../struct.udpsocket/" title="std::net::UdpSocket">UdpSocket</a>&gt;</code></span></h4> <div class="docblock">
<p>Creates a new independently owned handle to the underlying socket.</p> <p>The returned <code>UdpSocket</code> is a reference to the same socket that this object references. Both handles will read and write the same port, and options set on one socket will be propagated to the other.</p> <h4 id="examples-5" class="section-header">Examples</h4> <pre class="rust rust-example-rendered" data-language="rust">
use std::net::UdpSocket;

let socket = UdpSocket::bind("127.0.0.1:34254").expect("couldn't bind to address");
let socket_clone = socket.try_clone().expect("couldn't clone the socket");</pre> </div>
<h4 id="method.set_read_timeout" class="method"><span id="set_read_timeout.v" class="invisible"><code>fn <a href="#method.set_read_timeout" class="fnname">set_read_timeout</a>(&amp;self, dur: <a class="enum" href="../../option/enum.option/" title="std::option::Option">Option</a>&lt;<a class="struct" href="../../time/struct.duration/" title="std::time::Duration">Duration</a>&gt;) -&gt; <a class="type" href="../../io/type.result/" title="std::io::Result">Result</a>&lt;<a class="primitive" href="../../primitive.tuple/">()</a>&gt;</code><div class="since" title="Stable since Rust version 1.4.0">1.4.0</div></span></h4> <div class="docblock">
<p>Sets the read timeout to the timeout specified.</p> <p>If the value specified is <a href="../../option/enum.option/#variant.None"><code>None</code></a>, then <a href="../../io/trait.read/#tymethod.read"><code>read()</code></a> calls will block indefinitely. It is an error to pass the zero <a href="../../time/struct.duration/"><code>Duration</code></a> to this method.</p> <h4 id="note" class="section-header">Note</h4> <p>Platforms may return a different error code whenever a read times out as a result of setting this option. For example Unix typically returns an error of the kind <a href="../../io/enum.errorkind/#variant.WouldBlock"><code>WouldBlock</code></a>, but Windows may return <a href="../../io/enum.errorkind/#variant.TimedOut"><code>TimedOut</code></a>.</p> <h4 id="examples-6" class="section-header">Examples</h4> <pre class="rust rust-example-rendered" data-language="rust">
use std::net::UdpSocket;

let socket = UdpSocket::bind("127.0.0.1:34254").expect("couldn't bind to address");
socket.set_read_timeout(None).expect("set_read_timeout call failed");</pre> </div>
<h4 id="method.set_write_timeout" class="method"><span id="set_write_timeout.v" class="invisible"><code>fn <a href="#method.set_write_timeout" class="fnname">set_write_timeout</a>(&amp;self, dur: <a class="enum" href="../../option/enum.option/" title="std::option::Option">Option</a>&lt;<a class="struct" href="../../time/struct.duration/" title="std::time::Duration">Duration</a>&gt;) -&gt; <a class="type" href="../../io/type.result/" title="std::io::Result">Result</a>&lt;<a class="primitive" href="../../primitive.tuple/">()</a>&gt;</code><div class="since" title="Stable since Rust version 1.4.0">1.4.0</div></span></h4> <div class="docblock">
<p>Sets the write timeout to the timeout specified.</p> <p>If the value specified is <a href="../../option/enum.option/#variant.None"><code>None</code></a>, then <a href="../../io/trait.write/#tymethod.write"><code>write()</code></a> calls will block indefinitely. It is an error to pass the zero <a href="../../time/struct.duration/"><code>Duration</code></a> to this method.</p> <h4 id="note-1" class="section-header">Note</h4> <p>Platforms may return a different error code whenever a write times out as a result of setting this option. For example Unix typically returns an error of the kind <a href="../../io/enum.errorkind/#variant.WouldBlock"><code>WouldBlock</code></a>, but Windows may return <a href="../../io/enum.errorkind/#variant.TimedOut"><code>TimedOut</code></a>.</p> <h4 id="examples-7" class="section-header">Examples</h4> <pre class="rust rust-example-rendered" data-language="rust">
use std::net::UdpSocket;

let socket = UdpSocket::bind("127.0.0.1:34254").expect("couldn't bind to address");
socket.set_write_timeout(None).expect("set_write_timeout call failed");</pre> </div>
<h4 id="method.read_timeout" class="method"><span id="read_timeout.v" class="invisible"><code>fn <a href="#method.read_timeout" class="fnname">read_timeout</a>(&amp;self) -&gt; <a class="type" href="../../io/type.result/" title="std::io::Result">Result</a>&lt;<a class="enum" href="../../option/enum.option/" title="std::option::Option">Option</a>&lt;<a class="struct" href="../../time/struct.duration/" title="std::time::Duration">Duration</a>&gt;&gt;</code><div class="since" title="Stable since Rust version 1.4.0">1.4.0</div></span></h4> <div class="docblock">
<p>Returns the read timeout of this socket.</p> <p>If the timeout is <a href="../../option/enum.option/#variant.None"><code>None</code></a>, then <a href="../../io/trait.read/#tymethod.read"><code>read()</code></a> calls will block indefinitely.</p> <h4 id="examples-8" class="section-header">Examples</h4> <pre class="rust rust-example-rendered" data-language="rust">
use std::net::UdpSocket;

let socket = UdpSocket::bind("127.0.0.1:34254").expect("couldn't bind to address");
socket.set_read_timeout(None).expect("set_read_timeout call failed");
assert_eq!(socket.read_timeout().unwrap(), None);</pre> </div>
<h4 id="method.write_timeout" class="method"><span id="write_timeout.v" class="invisible"><code>fn <a href="#method.write_timeout" class="fnname">write_timeout</a>(&amp;self) -&gt; <a class="type" href="../../io/type.result/" title="std::io::Result">Result</a>&lt;<a class="enum" href="../../option/enum.option/" title="std::option::Option">Option</a>&lt;<a class="struct" href="../../time/struct.duration/" title="std::time::Duration">Duration</a>&gt;&gt;</code><div class="since" title="Stable since Rust version 1.4.0">1.4.0</div></span></h4> <div class="docblock">
<p>Returns the write timeout of this socket.</p> <p>If the timeout is <a href="../../option/enum.option/#variant.None"><code>None</code></a>, then <a href="../../io/trait.write/#tymethod.write"><code>write()</code></a> calls will block indefinitely.</p> <h4 id="examples-9" class="section-header">Examples</h4> <pre class="rust rust-example-rendered" data-language="rust">
use std::net::UdpSocket;

let socket = UdpSocket::bind("127.0.0.1:34254").expect("couldn't bind to address");
socket.set_write_timeout(None).expect("set_write_timeout call failed");
assert_eq!(socket.write_timeout().unwrap(), None);</pre> </div>
<h4 id="method.set_broadcast" class="method"><span id="set_broadcast.v" class="invisible"><code>fn <a href="#method.set_broadcast" class="fnname">set_broadcast</a>(&amp;self, broadcast: <a class="primitive" href="../../primitive.bool/">bool</a>) -&gt; <a class="type" href="../../io/type.result/" title="std::io::Result">Result</a>&lt;<a class="primitive" href="../../primitive.tuple/">()</a>&gt;</code><div class="since" title="Stable since Rust version 1.9.0">1.9.0</div></span></h4> <div class="docblock">
<p>Sets the value of the <code>SO_BROADCAST</code> option for this socket.</p> <p>When enabled, this socket is allowed to send packets to a broadcast address.</p> <h4 id="examples-10" class="section-header">Examples</h4> <pre class="rust rust-example-rendered" data-language="rust">
use std::net::UdpSocket;

let socket = UdpSocket::bind("127.0.0.1:34254").expect("couldn't bind to address");
socket.set_broadcast(false).expect("set_broadcast call failed");</pre> </div>
<h4 id="method.broadcast" class="method"><span id="broadcast.v" class="invisible"><code>fn <a href="#method.broadcast" class="fnname">broadcast</a>(&amp;self) -&gt; <a class="type" href="../../io/type.result/" title="std::io::Result">Result</a>&lt;<a class="primitive" href="../../primitive.bool/">bool</a>&gt;</code><div class="since" title="Stable since Rust version 1.9.0">1.9.0</div></span></h4> <div class="docblock">
<p>Gets the value of the <code>SO_BROADCAST</code> option for this socket.</p> <p>For more information about this option, see <a href="#method.set_broadcast"><code>set_broadcast</code></a>.</p> <h4 id="examples-11" class="section-header">Examples</h4> <pre class="rust rust-example-rendered" data-language="rust">
use std::net::UdpSocket;

let socket = UdpSocket::bind("127.0.0.1:34254").expect("couldn't bind to address");
socket.set_broadcast(false).expect("set_broadcast call failed");
assert_eq!(socket.broadcast().unwrap(), false);</pre> </div>
<h4 id="method.set_multicast_loop_v4" class="method"><span id="set_multicast_loop_v4.v" class="invisible"><code>fn <a href="#method.set_multicast_loop_v4" class="fnname">set_multicast_loop_v4</a>(&amp;self, multicast_loop_v4: <a class="primitive" href="../../primitive.bool/">bool</a>) -&gt; <a class="type" href="../../io/type.result/" title="std::io::Result">Result</a>&lt;<a class="primitive" href="../../primitive.tuple/">()</a>&gt;</code><div class="since" title="Stable since Rust version 1.9.0">1.9.0</div></span></h4> <div class="docblock">
<p>Sets the value of the <code>IP_MULTICAST_LOOP</code> option for this socket.</p> <p>If enabled, multicast packets will be looped back to the local socket. Note that this may not have any affect on IPv6 sockets.</p> <h4 id="examples-12" class="section-header">Examples</h4> <pre class="rust rust-example-rendered" data-language="rust">
use std::net::UdpSocket;

let socket = UdpSocket::bind("127.0.0.1:34254").expect("couldn't bind to address");
socket.set_multicast_loop_v4(false).expect("set_multicast_loop_v4 call failed");</pre> </div>
<h4 id="method.multicast_loop_v4" class="method"><span id="multicast_loop_v4.v" class="invisible"><code>fn <a href="#method.multicast_loop_v4" class="fnname">multicast_loop_v4</a>(&amp;self) -&gt; <a class="type" href="../../io/type.result/" title="std::io::Result">Result</a>&lt;<a class="primitive" href="../../primitive.bool/">bool</a>&gt;</code><div class="since" title="Stable since Rust version 1.9.0">1.9.0</div></span></h4> <div class="docblock">
<p>Gets the value of the <code>IP_MULTICAST_LOOP</code> option for this socket.</p> <p>For more information about this option, see <a href="#method.set_multicast_loop_v4"><code>set_multicast_loop_v4</code></a>.</p> <h4 id="examples-13" class="section-header">Examples</h4> <pre class="rust rust-example-rendered" data-language="rust">
use std::net::UdpSocket;

let socket = UdpSocket::bind("127.0.0.1:34254").expect("couldn't bind to address");
socket.set_multicast_loop_v4(false).expect("set_multicast_loop_v4 call failed");
assert_eq!(socket.multicast_loop_v4().unwrap(), false);</pre> </div>
<h4 id="method.set_multicast_ttl_v4" class="method"><span id="set_multicast_ttl_v4.v" class="invisible"><code>fn <a href="#method.set_multicast_ttl_v4" class="fnname">set_multicast_ttl_v4</a>(&amp;self, multicast_ttl_v4: <a class="primitive" href="../../primitive.u32/">u32</a>) -&gt; <a class="type" href="../../io/type.result/" title="std::io::Result">Result</a>&lt;<a class="primitive" href="../../primitive.tuple/">()</a>&gt;</code><div class="since" title="Stable since Rust version 1.9.0">1.9.0</div></span></h4> <div class="docblock">
<p>Sets the value of the <code>IP_MULTICAST_TTL</code> option for this socket.</p> <p>Indicates the time-to-live value of outgoing multicast packets for this socket. The default value is 1 which means that multicast packets don't leave the local network unless explicitly requested.</p> <p>Note that this may not have any affect on IPv6 sockets.</p> <h4 id="examples-14" class="section-header">Examples</h4> <pre class="rust rust-example-rendered" data-language="rust">
use std::net::UdpSocket;

let socket = UdpSocket::bind("127.0.0.1:34254").expect("couldn't bind to address");
socket.set_multicast_ttl_v4(42).expect("set_multicast_ttl_v4 call failed");</pre> </div>
<h4 id="method.multicast_ttl_v4" class="method"><span id="multicast_ttl_v4.v" class="invisible"><code>fn <a href="#method.multicast_ttl_v4" class="fnname">multicast_ttl_v4</a>(&amp;self) -&gt; <a class="type" href="../../io/type.result/" title="std::io::Result">Result</a>&lt;<a class="primitive" href="../../primitive.u32/">u32</a>&gt;</code><div class="since" title="Stable since Rust version 1.9.0">1.9.0</div></span></h4> <div class="docblock">
<p>Gets the value of the <code>IP_MULTICAST_TTL</code> option for this socket.</p> <p>For more information about this option, see <a href="#method.set_multicast_ttl_v4"><code>set_multicast_ttl_v4</code></a>.</p> <h4 id="examples-15" class="section-header">Examples</h4> <pre class="rust rust-example-rendered" data-language="rust">
use std::net::UdpSocket;

let socket = UdpSocket::bind("127.0.0.1:34254").expect("couldn't bind to address");
socket.set_multicast_ttl_v4(42).expect("set_multicast_ttl_v4 call failed");
assert_eq!(socket.multicast_ttl_v4().unwrap(), 42);</pre> </div>
<h4 id="method.set_multicast_loop_v6" class="method"><span id="set_multicast_loop_v6.v" class="invisible"><code>fn <a href="#method.set_multicast_loop_v6" class="fnname">set_multicast_loop_v6</a>(&amp;self, multicast_loop_v6: <a class="primitive" href="../../primitive.bool/">bool</a>) -&gt; <a class="type" href="../../io/type.result/" title="std::io::Result">Result</a>&lt;<a class="primitive" href="../../primitive.tuple/">()</a>&gt;</code><div class="since" title="Stable since Rust version 1.9.0">1.9.0</div></span></h4> <div class="docblock">
<p>Sets the value of the <code>IPV6_MULTICAST_LOOP</code> option for this socket.</p> <p>Controls whether this socket sees the multicast packets it sends itself. Note that this may not have any affect on IPv4 sockets.</p> <h4 id="examples-16" class="section-header">Examples</h4> <pre class="rust rust-example-rendered" data-language="rust">
use std::net::UdpSocket;

let socket = UdpSocket::bind("127.0.0.1:34254").expect("couldn't bind to address");
socket.set_multicast_loop_v6(false).expect("set_multicast_loop_v6 call failed");</pre> </div>
<h4 id="method.multicast_loop_v6" class="method"><span id="multicast_loop_v6.v" class="invisible"><code>fn <a href="#method.multicast_loop_v6" class="fnname">multicast_loop_v6</a>(&amp;self) -&gt; <a class="type" href="../../io/type.result/" title="std::io::Result">Result</a>&lt;<a class="primitive" href="../../primitive.bool/">bool</a>&gt;</code><div class="since" title="Stable since Rust version 1.9.0">1.9.0</div></span></h4> <div class="docblock">
<p>Gets the value of the <code>IPV6_MULTICAST_LOOP</code> option for this socket.</p> <p>For more information about this option, see <a href="#method.set_multicast_loop_v6"><code>set_multicast_loop_v6</code></a>.</p> <h4 id="examples-17" class="section-header">Examples</h4> <pre class="rust rust-example-rendered" data-language="rust">
use std::net::UdpSocket;

let socket = UdpSocket::bind("127.0.0.1:34254").expect("couldn't bind to address");
socket.set_multicast_loop_v6(false).expect("set_multicast_loop_v6 call failed");
assert_eq!(socket.multicast_loop_v6().unwrap(), false);</pre> </div>
<h4 id="method.set_ttl" class="method"><span id="set_ttl.v" class="invisible"><code>fn <a href="#method.set_ttl" class="fnname">set_ttl</a>(&amp;self, ttl: <a class="primitive" href="../../primitive.u32/">u32</a>) -&gt; <a class="type" href="../../io/type.result/" title="std::io::Result">Result</a>&lt;<a class="primitive" href="../../primitive.tuple/">()</a>&gt;</code><div class="since" title="Stable since Rust version 1.9.0">1.9.0</div></span></h4> <div class="docblock">
<p>Sets the value for the <code>IP_TTL</code> option on this socket.</p> <p>This value sets the time-to-live field that is used in every packet sent from this socket.</p> <h4 id="examples-18" class="section-header">Examples</h4> <pre class="rust rust-example-rendered" data-language="rust">
use std::net::UdpSocket;

let socket = UdpSocket::bind("127.0.0.1:34254").expect("couldn't bind to address");
socket.set_ttl(42).expect("set_ttl call failed");</pre> </div>
<h4 id="method.ttl" class="method"><span id="ttl.v" class="invisible"><code>fn <a href="#method.ttl" class="fnname">ttl</a>(&amp;self) -&gt; <a class="type" href="../../io/type.result/" title="std::io::Result">Result</a>&lt;<a class="primitive" href="../../primitive.u32/">u32</a>&gt;</code><div class="since" title="Stable since Rust version 1.9.0">1.9.0</div></span></h4> <div class="docblock">
<p>Gets the value of the <code>IP_TTL</code> option for this socket.</p> <p>For more information about this option, see <a href="#method.set_ttl"><code>set_ttl</code></a>.</p> <h4 id="examples-19" class="section-header">Examples</h4> <pre class="rust rust-example-rendered" data-language="rust">
use std::net::UdpSocket;

let socket = UdpSocket::bind("127.0.0.1:34254").expect("couldn't bind to address");
socket.set_ttl(42).expect("set_ttl call failed");
assert_eq!(socket.ttl().unwrap(), 42);</pre> </div>
<h4 id="method.join_multicast_v4" class="method"><span id="join_multicast_v4.v" class="invisible"><code>fn <a href="#method.join_multicast_v4" class="fnname">join_multicast_v4</a>(&amp;self,<br>                     multiaddr: &amp;<a class="struct" href="../struct.ipv4addr/" title="std::net::Ipv4Addr">Ipv4Addr</a>,<br>                     interface: &amp;<a class="struct" href="../struct.ipv4addr/" title="std::net::Ipv4Addr">Ipv4Addr</a>)<br>                     -&gt; <a class="type" href="../../io/type.result/" title="std::io::Result">Result</a>&lt;<a class="primitive" href="../../primitive.tuple/">()</a>&gt;</code><div class="since" title="Stable since Rust version 1.9.0">1.9.0</div></span></h4> <div class="docblock">
<p>Executes an operation of the <code>IP_ADD_MEMBERSHIP</code> type.</p> <p>This function specifies a new multicast group for this socket to join. The address must be a valid multicast address, and <code>interface</code> is the address of the local interface with which the system should join the multicast group. If it's equal to <code>INADDR_ANY</code> then an appropriate interface is chosen by the system.</p> </div>
<h4 id="method.join_multicast_v6" class="method"><span id="join_multicast_v6.v" class="invisible"><code>fn <a href="#method.join_multicast_v6" class="fnname">join_multicast_v6</a>(&amp;self, multiaddr: &amp;<a class="struct" href="../struct.ipv6addr/" title="std::net::Ipv6Addr">Ipv6Addr</a>, interface: <a class="primitive" href="../../primitive.u32/">u32</a>) -&gt; <a class="type" href="../../io/type.result/" title="std::io::Result">Result</a>&lt;<a class="primitive" href="../../primitive.tuple/">()</a>&gt;</code><div class="since" title="Stable since Rust version 1.9.0">1.9.0</div></span></h4> <div class="docblock">
<p>Executes an operation of the <code>IPV6_ADD_MEMBERSHIP</code> type.</p> <p>This function specifies a new multicast group for this socket to join. The address must be a valid multicast address, and <code>interface</code> is the index of the interface to join/leave (or 0 to indicate any interface).</p> </div>
<h4 id="method.leave_multicast_v4" class="method"><span id="leave_multicast_v4.v" class="invisible"><code>fn <a href="#method.leave_multicast_v4" class="fnname">leave_multicast_v4</a>(&amp;self,<br>                      multiaddr: &amp;<a class="struct" href="../struct.ipv4addr/" title="std::net::Ipv4Addr">Ipv4Addr</a>,<br>                      interface: &amp;<a class="struct" href="../struct.ipv4addr/" title="std::net::Ipv4Addr">Ipv4Addr</a>)<br>                      -&gt; <a class="type" href="../../io/type.result/" title="std::io::Result">Result</a>&lt;<a class="primitive" href="../../primitive.tuple/">()</a>&gt;</code><div class="since" title="Stable since Rust version 1.9.0">1.9.0</div></span></h4> <div class="docblock">
<p>Executes an operation of the <code>IP_DROP_MEMBERSHIP</code> type.</p> <p>For more information about this option, see <a href="#method.join_multicast_v4"><code>join_multicast_v4</code></a>.</p> </div>
<h4 id="method.leave_multicast_v6" class="method"><span id="leave_multicast_v6.v" class="invisible"><code>fn <a href="#method.leave_multicast_v6" class="fnname">leave_multicast_v6</a>(&amp;self, multiaddr: &amp;<a class="struct" href="../struct.ipv6addr/" title="std::net::Ipv6Addr">Ipv6Addr</a>, interface: <a class="primitive" href="../../primitive.u32/">u32</a>) -&gt; <a class="type" href="../../io/type.result/" title="std::io::Result">Result</a>&lt;<a class="primitive" href="../../primitive.tuple/">()</a>&gt;</code><div class="since" title="Stable since Rust version 1.9.0">1.9.0</div></span></h4> <div class="docblock">
<p>Executes an operation of the <code>IPV6_DROP_MEMBERSHIP</code> type.</p> <p>For more information about this option, see <a href="#method.join_multicast_v6"><code>join_multicast_v6</code></a>.</p> </div>
<h4 id="method.take_error" class="method"><span id="take_error.v" class="invisible"><code>fn <a href="#method.take_error" class="fnname">take_error</a>(&amp;self) -&gt; <a class="type" href="../../io/type.result/" title="std::io::Result">Result</a>&lt;<a class="enum" href="../../option/enum.option/" title="std::option::Option">Option</a>&lt;<a class="struct" href="../../io/struct.error/" title="std::io::Error">Error</a>&gt;&gt;</code><div class="since" title="Stable since Rust version 1.9.0">1.9.0</div></span></h4> <div class="docblock">
<p>Get the value of the <code>SO_ERROR</code> option on this socket.</p> <p>This will retrieve the stored error in the underlying socket, clearing the field in the process. This can be useful for checking errors between calls.</p> <h4 id="examples-20" class="section-header">Examples</h4> <pre class="rust rust-example-rendered" data-language="rust">
use std::net::UdpSocket;

let socket = UdpSocket::bind("127.0.0.1:34254").expect("couldn't bind to address");
match socket.take_error() {
    Ok(Some(error)) =&gt; println!("UdpSocket error: {:?}", error),
    Ok(None) =&gt; println!("No error"),
    Err(error) =&gt; println!("UdpSocket.take_error failed: {:?}", error),
}</pre> </div>
<h4 id="method.connect" class="method"><span id="connect.v" class="invisible"><code>fn <a href="#method.connect" class="fnname">connect</a>&lt;A: <a class="trait" href="../trait.tosocketaddrs/" title="std::net::ToSocketAddrs">ToSocketAddrs</a>&gt;(&amp;self, addr: A) -&gt; <a class="type" href="../../io/type.result/" title="std::io::Result">Result</a>&lt;<a class="primitive" href="../../primitive.tuple/">()</a>&gt;</code><div class="since" title="Stable since Rust version 1.9.0">1.9.0</div></span></h4> <div class="docblock">
<p>Connects this UDP socket to a remote address, allowing the <code>send</code> and <code>recv</code> syscalls to be used to send data and also applies filters to only receive data from the specified address.</p> <h4 id="examples-21" class="section-header">Examples</h4> <pre class="rust rust-example-rendered" data-language="rust">
use std::net::UdpSocket;

let socket = UdpSocket::bind("127.0.0.1:34254").expect("couldn't bind to address");
socket.connect("127.0.0.1:8080").expect("connect function failed");</pre> </div>
<h4 id="method.send" class="method"><span id="send.v" class="invisible"><code>fn <a href="#method.send" class="fnname">send</a>(&amp;self, buf: <a class="primitive" href="../../primitive.slice/">&amp;[</a><a class="primitive" href="../../primitive.u8/">u8</a><a class="primitive" href="../../primitive.slice/">]</a>) -&gt; <a class="type" href="../../io/type.result/" title="std::io::Result">Result</a>&lt;<a class="primitive" href="../../primitive.usize/">usize</a>&gt;</code><div class="since" title="Stable since Rust version 1.9.0">1.9.0</div></span></h4> <div class="docblock">
<p>Sends data on the socket to the remote address to which it is connected.</p> <p>The <a href="#method.connect"><code>connect()</code></a> method will connect this socket to a remote address. This method will fail if the socket is not connected.</p> <h4 id="examples-22" class="section-header">Examples</h4> <pre class="rust rust-example-rendered" data-language="rust">
use std::net::UdpSocket;

let socket = UdpSocket::bind("127.0.0.1:34254").expect("couldn't bind to address");
socket.connect("127.0.0.1:8080").expect("connect function failed");
socket.send(&amp;[0, 1, 2]).expect("couldn't send message");</pre> </div>
<h4 id="method.recv" class="method"><span id="recv.v" class="invisible"><code>fn <a href="#method.recv" class="fnname">recv</a>(&amp;self, buf: <a class="primitive" href="../../primitive.slice/">&amp;mut [</a><a class="primitive" href="../../primitive.u8/">u8</a><a class="primitive" href="../../primitive.slice/">]</a>) -&gt; <a class="type" href="../../io/type.result/" title="std::io::Result">Result</a>&lt;<a class="primitive" href="../../primitive.usize/">usize</a>&gt;</code><div class="since" title="Stable since Rust version 1.9.0">1.9.0</div></span></h4> <div class="docblock">
<p>Receives data on the socket from the remote address to which it is connected.</p> <p>The <code>connect</code> method will connect this socket to a remote address. This method will fail if the socket is not connected.</p> <h4 id="examples-23" class="section-header">Examples</h4> <pre class="rust rust-example-rendered" data-language="rust">
use std::net::UdpSocket;

let socket = UdpSocket::bind("127.0.0.1:34254").expect("couldn't bind to address");
socket.connect("127.0.0.1:8080").expect("connect function failed");
let mut buf = [0; 10];
match socket.recv(&amp;mut buf) {
    Ok(received) =&gt; println!("received {} bytes", received),
    Err(e) =&gt; println!("recv function failed: {:?}", e),
}</pre> </div>
<h4 id="method.set_nonblocking" class="method"><span id="set_nonblocking.v" class="invisible"><code>fn <a href="#method.set_nonblocking" class="fnname">set_nonblocking</a>(&amp;self, nonblocking: <a class="primitive" href="../../primitive.bool/">bool</a>) -&gt; <a class="type" href="../../io/type.result/" title="std::io::Result">Result</a>&lt;<a class="primitive" href="../../primitive.tuple/">()</a>&gt;</code><div class="since" title="Stable since Rust version 1.9.0">1.9.0</div></span></h4> <div class="docblock">
<p>Moves this UDP socket into or out of nonblocking mode.</p> <p>On Unix this corresponds to calling fcntl, and on Windows this corresponds to calling ioctlsocket.</p> <h4 id="examples-24" class="section-header">Examples</h4> <pre class="rust rust-example-rendered" data-language="rust">
use std::net::UdpSocket;

let socket = UdpSocket::bind("127.0.0.1:34254").expect("couldn't bind to address");
socket.set_nonblocking(true).expect("set_nonblocking call failed");</pre> </div>
<h2 id="implementations">Trait Implementations</h2>
<h3 class="impl">
<span class="in-band"><code>impl <a class="trait" href="../../fmt/trait.debug/" title="std::fmt::Debug">Debug</a> for <a class="struct" href="../struct.udpsocket/" title="std::net::UdpSocket">UdpSocket</a></code></span><span class="out-of-band">
<a class="srclink" href="https://doc.rust-lang.org/src/std/net/udp.rs.html#614-618" title="goto source code" target="_blank">[src]</a></span>
</h3> <h4 id="method.fmt" class="method"><span id="fmt.v" class="invisible"><code>fn <a href="../../fmt/trait.debug/#tymethod.fmt" class="fnname">fmt</a>(&amp;self, f: &amp;mut <a class="struct" href="../../fmt/struct.formatter/" title="std::fmt::Formatter">Formatter</a>) -&gt; <a class="type" href="../../fmt/type.result/" title="std::fmt::Result">Result</a></code></span></h4> <div class="docblock">
<p>Formats the value using the given formatter.</p> </div>
<h3 class="impl">
<span class="in-band"><code>impl <a class="trait" href="../../os/unix/io/trait.asrawfd/" title="std::os::unix::io::AsRawFd">AsRawFd</a> for <a class="struct" href="../struct.udpsocket/" title="std::net::UdpSocket">UdpSocket</a></code></span><span class="out-of-band">
<a class="srclink" href="https://doc.rust-lang.org/src/std/sys/unix/ext/io.rs.html#103-105" title="goto source code" target="_blank">[src]</a></span>
</h3> <h4 id="method.as_raw_fd" class="method"><span id="as_raw_fd.v" class="invisible"><code>fn <a href="../../os/unix/io/trait.asrawfd/#tymethod.as_raw_fd" class="fnname">as_raw_fd</a>(&amp;self) -&gt; <a class="type" href="../../os/unix/io/type.rawfd/" title="std::os::unix::io::RawFd">RawFd</a></code></span></h4> <div class="docblock">
<p>Extracts the raw file descriptor. <a href="../../os/unix/io/trait.asrawfd/#tymethod.as_raw_fd">Read more</a></p> </div>
<h3 class="impl">
<span class="in-band"><code>impl <a class="trait" href="../../os/unix/io/trait.fromrawfd/" title="std::os::unix::io::FromRawFd">FromRawFd</a> for <a class="struct" href="../struct.udpsocket/" title="std::net::UdpSocket">UdpSocket</a></code></span><span class="out-of-band">
<div class="since" title="Stable since Rust version 1.1.0">1.1.0</div>
<a class="srclink" href="https://doc.rust-lang.org/src/std/sys/unix/ext/io.rs.html#122-127" title="goto source code" target="_blank">[src]</a></span>
</h3> <h4 id="method.from_raw_fd" class="method"><span id="from_raw_fd.v" class="invisible"><code>unsafe fn <a href="../../os/unix/io/trait.fromrawfd/#tymethod.from_raw_fd" class="fnname">from_raw_fd</a>(fd: <a class="type" href="../../os/unix/io/type.rawfd/" title="std::os::unix::io::RawFd">RawFd</a>) -&gt; <a class="struct" href="../struct.udpsocket/" title="std::net::UdpSocket">UdpSocket</a></code></span></h4> <div class="docblock">
<p>Constructs a new instance of <code>Self</code> from the given raw file descriptor. <a href="../../os/unix/io/trait.fromrawfd/#tymethod.from_raw_fd">Read more</a></p> </div>
<h3 class="impl">
<span class="in-band"><code>impl <a class="trait" href="../../os/unix/io/trait.intorawfd/" title="std::os::unix::io::IntoRawFd">IntoRawFd</a> for <a class="struct" href="../struct.udpsocket/" title="std::net::UdpSocket">UdpSocket</a></code></span><span class="out-of-band">
<div class="since" title="Stable since Rust version 1.4.0">1.4.0</div>
<a class="srclink" href="https://doc.rust-lang.org/src/std/sys/unix/ext/io.rs.html#142-146" title="goto source code" target="_blank">[src]</a></span>
</h3> <h4 id="method.into_raw_fd" class="method"><span id="into_raw_fd.v" class="invisible"><code>fn <a href="../../os/unix/io/trait.intorawfd/#tymethod.into_raw_fd" class="fnname">into_raw_fd</a>(self) -&gt; <a class="type" href="../../os/unix/io/type.rawfd/" title="std::os::unix::io::RawFd">RawFd</a></code></span></h4> <div class="docblock">
<p>Consumes this object, returning the raw underlying file descriptor. <a href="../../os/unix/io/trait.intorawfd/#tymethod.into_raw_fd">Read more</a></p> </div>
<div class="_attribution">
  <p class="_attribution-p">
    © 2010 The Rust Project Developers<br>Licensed under the Apache License, Version 2.0 or the MIT license, at your option.<br>
    <a href="https://doc.rust-lang.org/std/net/struct.UdpSocket.html" class="_attribution-link" target="_blank">https://doc.rust-lang.org/std/net/struct.UdpSocket.html</a>
  </p>
</div>

			</div>
		</div>
	</section>

	</div>
</body>
</html>
