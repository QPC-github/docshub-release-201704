
<!DOCTYPE HTML>

<html lang="en">

<head>
  <meta charset="utf-8">
  <title>std&#58;&#58;collections&#58;&#58;binary_heap&#58;&#58;BinaryHeap - Rust - W3cubDocs</title>
  
  <meta name="description" content=" A priority queue implemented with a binary heap. ">
  <meta name="keywords" content="struct, std, collections, binary, heap, binaryheap, -, rust">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="http://docs.w3cub.com/rust/std/collections/binary_heap/struct.binaryheap/">
  <link href="/favicon.png" rel="icon">
  <link type="text/css" rel="stylesheet" href="/assets/application-50364fff564ce3b6327021805f3f00e2957b441cf27f576a7dd4ff63bbc47047.css">
  <script type="text/javascript" src="/assets/application-db64bfd54ceb42be11af7995804cf4902548419ceb79d509b0b7d62c22d98e6f.js"></script>
  <script src="/json/rust.js"></script>
  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-71174418-1']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>


</head>

<body>
	<div class="_app">
	<header class="_header">
  
  <form class="_search">
    <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
    <a class="_search-clear"></a>
    <div class="_search-tag"></div>
  </form>
  
  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/rust/" class="_nav-link" title="" style="margin-left:0;">Rust</a></span>
  
  <nav class="_nav">
    <a href="/app/" class="_nav-link ">App</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		<div class="_list">
			
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<div class="_page _rust">
				
<h1 class="fqn">Struct std::collections::binary_heap::BinaryHeap</h1> <pre class="rust struct" data-language="rust">pub struct BinaryHeap&lt;T&gt; { /* fields omitted */ }</pre>
<p>A priority queue implemented with a binary heap.</p> <p>This will be a max-heap.</p> <p>It is a logic error for an item to be modified in such a way that the item's ordering relative to any other item, as determined by the <code>Ord</code> trait, changes while it is in the heap. This is normally only possible through <code>Cell</code>, <code>RefCell</code>, global state, I/O, or unsafe code.</p> <h4 id="examples" class="section-header">Examples</h4> <pre class="rust rust-example-rendered" data-language="rust">
use std::collections::BinaryHeap;

// Type inference lets us omit an explicit type signature (which
// would be `BinaryHeap&lt;i32&gt;` in this example).
let mut heap = BinaryHeap::new();

// We can use peek to look at the next item in the heap. In this case,
// there's no items in there yet so we get None.
assert_eq!(heap.peek(), None);

// Let's add some scores...
heap.push(1);
heap.push(5);
heap.push(2);

// Now peek shows the most important item in the heap.
assert_eq!(heap.peek(), Some(&amp;5));

// We can check the length of a heap.
assert_eq!(heap.len(), 3);

// We can iterate over the items in the heap, although they are returned in
// a random order.
for x in &amp;heap {
    println!("{}", x);
}

// If we instead pop these scores, they should come back in order.
assert_eq!(heap.pop(), Some(5));
assert_eq!(heap.pop(), Some(2));
assert_eq!(heap.pop(), Some(1));
assert_eq!(heap.pop(), None);

// We can clear the heap of any remaining items.
heap.clear();

// The heap should now be empty.
assert!(heap.is_empty())</pre> <h2 id="methods">Methods</h2>
<h3 class="impl">
<span class="in-band"><code>impl&lt;T&gt; <a class="struct" href="../struct.binaryheap/" title="std::collections::binary_heap::BinaryHeap">BinaryHeap</a>&lt;T&gt; <span class="where fmt-newline">where T: <a class="trait" href="../../../cmp/trait.ord/" title="std::cmp::Ord">Ord</a></span></code></span><span class="out-of-band">
<a class="srclink" href="https://doc.rust-lang.org/src/collections/binary_heap.rs.html#292-891" title="goto source code" target="_blank">[src]</a></span>
</h3> <h4 id="method.new" class="method"><span id="new.v" class="invisible"><code>fn <a href="#method.new" class="fnname">new</a>() -&gt; <a class="struct" href="../struct.binaryheap/" title="std::collections::binary_heap::BinaryHeap">BinaryHeap</a>&lt;T&gt;</code></span></h4> <div class="docblock">
<p>Creates an empty <code>BinaryHeap</code> as a max-heap.</p> <h4 id="examples-1" class="section-header">Examples</h4> <p>Basic usage:</p> <pre class="rust rust-example-rendered" data-language="rust">
use std::collections::BinaryHeap;
let mut heap = BinaryHeap::new();
heap.push(4);</pre> </div>
<h4 id="method.with_capacity" class="method"><span id="with_capacity.v" class="invisible"><code>fn <a href="#method.with_capacity" class="fnname">with_capacity</a>(capacity: <a class="primitive" href="../../../primitive.usize/">usize</a>) -&gt; <a class="struct" href="../struct.binaryheap/" title="std::collections::binary_heap::BinaryHeap">BinaryHeap</a>&lt;T&gt;</code></span></h4> <div class="docblock">
<p>Creates an empty <code>BinaryHeap</code> with a specific capacity. This preallocates enough memory for <code>capacity</code> elements, so that the <code>BinaryHeap</code> does not have to be reallocated until it contains at least that many values.</p> <h4 id="examples-2" class="section-header">Examples</h4> <p>Basic usage:</p> <pre class="rust rust-example-rendered" data-language="rust">
use std::collections::BinaryHeap;
let mut heap = BinaryHeap::with_capacity(10);
heap.push(4);</pre> </div>
<h4 id="method.iter" class="method"><span id="iter.v" class="invisible"><code>fn <a href="#method.iter" class="fnname">iter</a>(&amp;self) -&gt; <a class="struct" href="../struct.iter/" title="std::collections::binary_heap::Iter">Iter</a>&lt;T&gt;</code></span></h4> <div class="docblock">
<p>Returns an iterator visiting all values in the underlying vector, in arbitrary order.</p> <h4 id="examples-3" class="section-header">Examples</h4> <p>Basic usage:</p> <pre class="rust rust-example-rendered" data-language="rust">
use std::collections::BinaryHeap;
let heap = BinaryHeap::from(vec![1, 2, 3, 4]);

// Print 1, 2, 3, 4 in arbitrary order
for x in heap.iter() {
    println!("{}", x);
}</pre> </div>
<h4 id="method.peek" class="method"><span id="peek.v" class="invisible"><code>fn <a href="#method.peek" class="fnname">peek</a>(&amp;self) -&gt; <a class="enum" href="../../../option/enum.option/" title="std::option::Option">Option</a>&lt;&amp;T&gt;</code></span></h4> <div class="docblock">
<p>Returns the greatest item in the binary heap, or <code>None</code> if it is empty.</p> <h4 id="examples-4" class="section-header">Examples</h4> <p>Basic usage:</p> <pre class="rust rust-example-rendered" data-language="rust">
use std::collections::BinaryHeap;
let mut heap = BinaryHeap::new();
assert_eq!(heap.peek(), None);

heap.push(1);
heap.push(5);
heap.push(2);
assert_eq!(heap.peek(), Some(&amp;5));
</pre> </div>
<h4 id="method.peek_mut" class="method"><span id="peek_mut.v" class="invisible"><code>fn <a href="#method.peek_mut" class="fnname">peek_mut</a>(&amp;mut self) -&gt; <a class="enum" href="../../../option/enum.option/" title="std::option::Option">Option</a>&lt;<a class="struct" href="../struct.peekmut/" title="std::collections::binary_heap::PeekMut">PeekMut</a>&lt;T&gt;&gt;</code><div class="since" title="Stable since Rust version 1.12.0">1.12.0</div></span></h4> <div class="docblock">
<p>Returns a mutable reference to the greatest item in the binary heap, or <code>None</code> if it is empty.</p> <p>Note: If the <code>PeekMut</code> value is leaked, the heap may be in an inconsistent state.</p> <h4 id="examples-5" class="section-header">Examples</h4> <p>Basic usage:</p> <pre class="rust rust-example-rendered" data-language="rust">
use std::collections::BinaryHeap;
let mut heap = BinaryHeap::new();
assert!(heap.peek_mut().is_none());

heap.push(1);
heap.push(5);
heap.push(2);
{
    let mut val = heap.peek_mut().unwrap();
    *val = 0;
}
assert_eq!(heap.peek(), Some(&amp;2));</pre> </div>
<h4 id="method.capacity" class="method"><span id="capacity.v" class="invisible"><code>fn <a href="#method.capacity" class="fnname">capacity</a>(&amp;self) -&gt; <a class="primitive" href="../../../primitive.usize/">usize</a></code></span></h4> <div class="docblock">
<p>Returns the number of elements the binary heap can hold without reallocating.</p> <h4 id="examples-6" class="section-header">Examples</h4> <p>Basic usage:</p> <pre class="rust rust-example-rendered" data-language="rust">
use std::collections::BinaryHeap;
let mut heap = BinaryHeap::with_capacity(100);
assert!(heap.capacity() &gt;= 100);
heap.push(4);</pre> </div>
<h4 id="method.reserve_exact" class="method"><span id="reserve_exact.v" class="invisible"><code>fn <a href="#method.reserve_exact" class="fnname">reserve_exact</a>(&amp;mut self, additional: <a class="primitive" href="../../../primitive.usize/">usize</a>)</code></span></h4> <div class="docblock">
<p>Reserves the minimum capacity for exactly <code>additional</code> more elements to be inserted in the given <code>BinaryHeap</code>. Does nothing if the capacity is already sufficient.</p> <p>Note that the allocator may give the collection more space than it requests. Therefore capacity can not be relied upon to be precisely minimal. Prefer <code>reserve</code> if future insertions are expected.</p> <h4 id="panics" class="section-header">Panics</h4> <p>Panics if the new capacity overflows <code>usize</code>.</p> <h4 id="examples-7" class="section-header">Examples</h4> <p>Basic usage:</p> <pre class="rust rust-example-rendered" data-language="rust">
use std::collections::BinaryHeap;
let mut heap = BinaryHeap::new();
heap.reserve_exact(100);
assert!(heap.capacity() &gt;= 100);
heap.push(4);</pre> </div>
<h4 id="method.reserve" class="method"><span id="reserve.v" class="invisible"><code>fn <a href="#method.reserve" class="fnname">reserve</a>(&amp;mut self, additional: <a class="primitive" href="../../../primitive.usize/">usize</a>)</code></span></h4> <div class="docblock">
<p>Reserves capacity for at least <code>additional</code> more elements to be inserted in the <code>BinaryHeap</code>. The collection may reserve more space to avoid frequent reallocations.</p> <h4 id="panics-1" class="section-header">Panics</h4> <p>Panics if the new capacity overflows <code>usize</code>.</p> <h4 id="examples-8" class="section-header">Examples</h4> <p>Basic usage:</p> <pre class="rust rust-example-rendered" data-language="rust">
use std::collections::BinaryHeap;
let mut heap = BinaryHeap::new();
heap.reserve(100);
assert!(heap.capacity() &gt;= 100);
heap.push(4);</pre> </div>
<h4 id="method.shrink_to_fit" class="method"><span id="shrink_to_fit.v" class="invisible"><code>fn <a href="#method.shrink_to_fit" class="fnname">shrink_to_fit</a>(&amp;mut self)</code></span></h4> <div class="docblock">
<p>Discards as much additional capacity as possible.</p> <h4 id="examples-9" class="section-header">Examples</h4> <p>Basic usage:</p> <pre class="rust rust-example-rendered" data-language="rust">
use std::collections::BinaryHeap;
let mut heap: BinaryHeap&lt;i32&gt; = BinaryHeap::with_capacity(100);

assert!(heap.capacity() &gt;= 100);
heap.shrink_to_fit();
assert!(heap.capacity() == 0);</pre> </div>
<h4 id="method.pop" class="method"><span id="pop.v" class="invisible"><code>fn <a href="#method.pop" class="fnname">pop</a>(&amp;mut self) -&gt; <a class="enum" href="../../../option/enum.option/" title="std::option::Option">Option</a>&lt;T&gt;</code></span></h4> <div class="docblock">
<p>Removes the greatest item from the binary heap and returns it, or <code>None</code> if it is empty.</p> <h4 id="examples-10" class="section-header">Examples</h4> <p>Basic usage:</p> <pre class="rust rust-example-rendered" data-language="rust">
use std::collections::BinaryHeap;
let mut heap = BinaryHeap::from(vec![1, 3]);

assert_eq!(heap.pop(), Some(3));
assert_eq!(heap.pop(), Some(1));
assert_eq!(heap.pop(), None);</pre> </div>
<h4 id="method.push" class="method"><span id="push.v" class="invisible"><code>fn <a href="#method.push" class="fnname">push</a>(&amp;mut self, item: T)</code></span></h4> <div class="docblock">
<p>Pushes an item onto the binary heap.</p> <h4 id="examples-11" class="section-header">Examples</h4> <p>Basic usage:</p> <pre class="rust rust-example-rendered" data-language="rust">
use std::collections::BinaryHeap;
let mut heap = BinaryHeap::new();
heap.push(3);
heap.push(5);
heap.push(1);

assert_eq!(heap.len(), 3);
assert_eq!(heap.peek(), Some(&amp;5));</pre> </div>
<h4 id="method.push_pop" class="method"><span id="push_pop.v" class="invisible"><code>fn <a href="#method.push_pop" class="fnname">push_pop</a>(&amp;mut self, item: T) -&gt; T</code></span></h4> <div class="stability">
<span class="stab deprecated">Deprecated since 1.13.0: use peek_mut instead </span><span class="stab unstable">🔬 This is a nightly-only experimental API. (binary_heap_extras #28147)needs to be audited </span>
</div>
<div class="docblock">
<p>Pushes an item onto the binary heap, then pops the greatest item off the queue in an optimized fashion.</p> <h4 id="examples-12" class="section-header">Examples</h4> <p>Basic usage:</p> <pre class="rust rust-example-rendered" data-language="rust">
#![feature(binary_heap_extras)]
#![allow(deprecated)]

use std::collections::BinaryHeap;
let mut heap = BinaryHeap::new();
heap.push(1);
heap.push(5);

assert_eq!(heap.push_pop(3), 5);
assert_eq!(heap.push_pop(9), 9);
assert_eq!(heap.len(), 2);
assert_eq!(heap.peek(), Some(&amp;3));</pre> </div>
<h4 id="method.replace" class="method"><span id="replace.v" class="invisible"><code>fn <a href="#method.replace" class="fnname">replace</a>(&amp;mut self, item: T) -&gt; <a class="enum" href="../../../option/enum.option/" title="std::option::Option">Option</a>&lt;T&gt;</code></span></h4> <div class="stability">
<span class="stab deprecated">Deprecated since 1.13.0: use peek_mut instead </span><span class="stab unstable">🔬 This is a nightly-only experimental API. (binary_heap_extras #28147)needs to be audited </span>
</div>
<div class="docblock">
<p>Pops the greatest item off the binary heap, then pushes an item onto the queue in an optimized fashion. The push is done regardless of whether the binary heap was empty.</p> <h4 id="examples-13" class="section-header">Examples</h4> <p>Basic usage:</p> <pre class="rust rust-example-rendered" data-language="rust">
#![feature(binary_heap_extras)]
#![allow(deprecated)]

use std::collections::BinaryHeap;
let mut heap = BinaryHeap::new();

assert_eq!(heap.replace(1), None);
assert_eq!(heap.replace(3), Some(1));
assert_eq!(heap.len(), 1);
assert_eq!(heap.peek(), Some(&amp;3));</pre> </div>
<h4 id="method.into_vec" class="method"><span id="into_vec.v" class="invisible"><code>fn <a href="#method.into_vec" class="fnname">into_vec</a>(self) -&gt; <a class="struct" href="../../../vec/struct.vec/" title="std::vec::Vec">Vec</a>&lt;T&gt;</code><div class="since" title="Stable since Rust version 1.5.0">1.5.0</div></span></h4> <div class="docblock">
<p>Consumes the <code>BinaryHeap</code> and returns the underlying vector in arbitrary order.</p> <h4 id="examples-14" class="section-header">Examples</h4> <p>Basic usage:</p> <pre class="rust rust-example-rendered" data-language="rust">
use std::collections::BinaryHeap;
let heap = BinaryHeap::from(vec![1, 2, 3, 4, 5, 6, 7]);
let vec = heap.into_vec();

// Will print in some order
for x in vec {
    println!("{}", x);
}</pre> </div>
<h4 id="method.into_sorted_vec" class="method"><span id="into_sorted_vec.v" class="invisible"><code>fn <a href="#method.into_sorted_vec" class="fnname">into_sorted_vec</a>(self) -&gt; <a class="struct" href="../../../vec/struct.vec/" title="std::vec::Vec">Vec</a>&lt;T&gt;</code><div class="since" title="Stable since Rust version 1.5.0">1.5.0</div></span></h4> <div class="docblock">
<p>Consumes the <code>BinaryHeap</code> and returns a vector in sorted (ascending) order.</p> <h4 id="examples-15" class="section-header">Examples</h4> <p>Basic usage:</p> <pre class="rust rust-example-rendered" data-language="rust">
use std::collections::BinaryHeap;

let mut heap = BinaryHeap::from(vec![1, 2, 4, 5, 7]);
heap.push(6);
heap.push(3);

let vec = heap.into_sorted_vec();
assert_eq!(vec, [1, 2, 3, 4, 5, 6, 7]);</pre> </div>
<h4 id="method.len" class="method"><span id="len.v" class="invisible"><code>fn <a href="#method.len" class="fnname">len</a>(&amp;self) -&gt; <a class="primitive" href="../../../primitive.usize/">usize</a></code></span></h4> <div class="docblock">
<p>Returns the length of the binary heap.</p> <h4 id="examples-16" class="section-header">Examples</h4> <p>Basic usage:</p> <pre class="rust rust-example-rendered" data-language="rust">
use std::collections::BinaryHeap;
let heap = BinaryHeap::from(vec![1, 3]);

assert_eq!(heap.len(), 2);</pre> </div>
<h4 id="method.is_empty" class="method"><span id="is_empty.v" class="invisible"><code>fn <a href="#method.is_empty" class="fnname">is_empty</a>(&amp;self) -&gt; <a class="primitive" href="../../../primitive.bool/">bool</a></code></span></h4> <div class="docblock">
<p>Checks if the binary heap is empty.</p> <h4 id="examples-17" class="section-header">Examples</h4> <p>Basic usage:</p> <pre class="rust rust-example-rendered" data-language="rust">
use std::collections::BinaryHeap;
let mut heap = BinaryHeap::new();

assert!(heap.is_empty());

heap.push(3);
heap.push(5);
heap.push(1);

assert!(!heap.is_empty());</pre> </div>
<h4 id="method.drain" class="method"><span id="drain.v" class="invisible"><code>fn <a href="#method.drain" class="fnname">drain</a>(&amp;mut self) -&gt; <a class="struct" href="../struct.drain/" title="std::collections::binary_heap::Drain">Drain</a>&lt;T&gt;</code><div class="since" title="Stable since Rust version 1.6.0">1.6.0</div></span></h4> <div class="docblock">
<p>Clears the binary heap, returning an iterator over the removed elements.</p> <p>The elements are removed in arbitrary order.</p> <h4 id="examples-18" class="section-header">Examples</h4> <p>Basic usage:</p> <pre class="rust rust-example-rendered" data-language="rust">
use std::collections::BinaryHeap;
let mut heap = BinaryHeap::from(vec![1, 3]);

assert!(!heap.is_empty());

for x in heap.drain() {
    println!("{}", x);
}

assert!(heap.is_empty());</pre> </div>
<h4 id="method.clear" class="method"><span id="clear.v" class="invisible"><code>fn <a href="#method.clear" class="fnname">clear</a>(&amp;mut self)</code></span></h4> <div class="docblock">
<p>Drops all items from the binary heap.</p> <h4 id="examples-19" class="section-header">Examples</h4> <p>Basic usage:</p> <pre class="rust rust-example-rendered" data-language="rust">
use std::collections::BinaryHeap;
let mut heap = BinaryHeap::from(vec![1, 3]);

assert!(!heap.is_empty());

heap.clear();

assert!(heap.is_empty());</pre> </div>
<h4 id="method.append" class="method"><span id="append.v" class="invisible"><code>fn <a href="#method.append" class="fnname">append</a>(&amp;mut self, other: &amp;mut <a class="struct" href="../struct.binaryheap/" title="std::collections::binary_heap::BinaryHeap">BinaryHeap</a>&lt;T&gt;)</code><div class="since" title="Stable since Rust version 1.11.0">1.11.0</div></span></h4> <div class="docblock">
<p>Moves all the elements of <code>other</code> into <code>self</code>, leaving <code>other</code> empty.</p> <h4 id="examples-20" class="section-header">Examples</h4> <p>Basic usage:</p> <pre class="rust rust-example-rendered" data-language="rust">
use std::collections::BinaryHeap;

let v = vec![-10, 1, 2, 3, 3];
let mut a = BinaryHeap::from(v);

let v = vec![-20, 5, 43];
let mut b = BinaryHeap::from(v);

a.append(&amp;mut b);

assert_eq!(a.into_sorted_vec(), [-20, -10, 1, 2, 3, 3, 5, 43]);
assert!(b.is_empty());</pre> </div>
<h2 id="implementations">Trait Implementations</h2>
<h3 class="impl">
<span class="in-band"><code>impl&lt;T&gt; <a class="trait" href="../../../iter/trait.extend/" title="std::iter::Extend">Extend</a>&lt;T&gt; for <a class="struct" href="../struct.binaryheap/" title="std::collections::binary_heap::BinaryHeap">BinaryHeap</a>&lt;T&gt; <span class="where fmt-newline">where T: <a class="trait" href="../../../cmp/trait.ord/" title="std::cmp::Ord">Ord</a></span></code></span><span class="out-of-band">
<a class="srclink" href="https://doc.rust-lang.org/src/collections/binary_heap.rs.html#1155-1160" title="goto source code" target="_blank">[src]</a></span>
</h3> <h4 id="method.extend" class="method"><span id="extend.v" class="invisible"><code>fn <a href="../../../iter/trait.extend/#tymethod.extend" class="fnname">extend</a>&lt;I&gt;(&amp;mut self, iter: I) <span class="where fmt-newline">where I: <a class="trait" href="../../../iter/trait.intoiterator/" title="std::iter::IntoIterator">IntoIterator</a>&lt;Item=T&gt;</span></code></span></h4> <div class="docblock">
<p>Extends a collection with the contents of an iterator. <a href="../../../iter/trait.extend/#tymethod.extend">Read more</a></p> </div>
<h3 class="impl">
<span class="in-band"><code>impl&lt;'a, T&gt; <a class="trait" href="../../../iter/trait.extend/" title="std::iter::Extend">Extend</a>&lt;&amp;'a T&gt; for <a class="struct" href="../struct.binaryheap/" title="std::collections::binary_heap::BinaryHeap">BinaryHeap</a>&lt;T&gt; <span class="where fmt-newline">where T: 'a + <a class="trait" href="../../../marker/trait.copy/" title="std::marker::Copy">Copy</a> + <a class="trait" href="../../../cmp/trait.ord/" title="std::cmp::Ord">Ord</a></span></code></span><span class="out-of-band">
<div class="since" title="Stable since Rust version 1.2.0">1.2.0</div>
<a class="srclink" href="https://doc.rust-lang.org/src/collections/binary_heap.rs.html#1188-1192" title="goto source code" target="_blank">[src]</a></span>
</h3> <h4 id="method.extend-1" class="method"><span id="extend.v-1" class="invisible"><code>fn <a href="../../../iter/trait.extend/#tymethod.extend" class="fnname">extend</a>&lt;I&gt;(&amp;mut self, iter: I) <span class="where fmt-newline">where I: <a class="trait" href="../../../iter/trait.intoiterator/" title="std::iter::IntoIterator">IntoIterator</a>&lt;Item=&amp;'a T&gt;</span></code></span></h4> <div class="docblock">
<p>Extends a collection with the contents of an iterator. <a href="../../../iter/trait.extend/#tymethod.extend">Read more</a></p> </div>
<h3 class="impl">
<span class="in-band"><code>impl&lt;T&gt; <a class="trait" href="../../../convert/trait.from/" title="std::convert::From">From</a>&lt;<a class="struct" href="../../../vec/struct.vec/" title="std::vec::Vec">Vec</a>&lt;T&gt;&gt; for <a class="struct" href="../struct.binaryheap/" title="std::collections::binary_heap::BinaryHeap">BinaryHeap</a>&lt;T&gt; <span class="where fmt-newline">where T: <a class="trait" href="../../../cmp/trait.ord/" title="std::cmp::Ord">Ord</a></span></code></span><span class="out-of-band">
<a class="srclink" href="https://doc.rust-lang.org/src/collections/binary_heap.rs.html#1092-1098" title="goto source code" target="_blank">[src]</a></span>
</h3> <h4 id="method.from" class="method"><span id="from.v" class="invisible"><code>fn <a href="../../../convert/trait.from/#tymethod.from" class="fnname">from</a>(vec: <a class="struct" href="../../../vec/struct.vec/" title="std::vec::Vec">Vec</a>&lt;T&gt;) -&gt; <a class="struct" href="../struct.binaryheap/" title="std::collections::binary_heap::BinaryHeap">BinaryHeap</a>&lt;T&gt;</code></span></h4> <div class="docblock">
<p>Performs the conversion.</p> </div>
<h3 class="impl">
<span class="in-band"><code>impl&lt;T&gt; <a class="trait" href="../../../iter/trait.intoiterator/" title="std::iter::IntoIterator">IntoIterator</a> for <a class="struct" href="../struct.binaryheap/" title="std::collections::binary_heap::BinaryHeap">BinaryHeap</a>&lt;T&gt; <span class="where fmt-newline">where T: <a class="trait" href="../../../cmp/trait.ord/" title="std::cmp::Ord">Ord</a></span></code></span><span class="out-of-band">
<a class="srclink" href="https://doc.rust-lang.org/src/collections/binary_heap.rs.html#1115-1140" title="goto source code" target="_blank">[src]</a></span>
</h3> <h4 id="associatedtype.Item" class="type"><span id="Item.t" class="invisible"><code>type <a href="../../../iter/trait.intoiterator/#associatedtype.Item" class="type">Item</a> = T</code></span></h4> <div class="docblock">
<p>The type of the elements being iterated over.</p> </div>
<h4 id="associatedtype.IntoIter" class="type"><span id="IntoIter.t" class="invisible"><code>type <a href="../../../iter/trait.intoiterator/#associatedtype.IntoIter" class="type">IntoIter</a> = <a class="struct" href="../struct.intoiter/" title="std::collections::binary_heap::IntoIter">IntoIter</a>&lt;T&gt;</code></span></h4> <div class="docblock">
<p>Which kind of iterator are we turning this into?</p> </div>
<h4 id="method.into_iter" class="method"><span id="into_iter.v" class="invisible"><code>fn <a href="../../../iter/trait.intoiterator/#tymethod.into_iter" class="fnname">into_iter</a>(self) -&gt; <a class="struct" href="../struct.intoiter/" title="std::collections::binary_heap::IntoIter">IntoIter</a>&lt;T&gt;</code></span></h4> <div class="docblock">
<p>Creates a consuming iterator, that is, one that moves each value out of the binary heap in arbitrary order. The binary heap cannot be used after calling this.</p> <h4 id="examples-21" class="section-header">Examples</h4> <p>Basic usage:</p> <pre class="rust rust-example-rendered" data-language="rust">
use std::collections::BinaryHeap;
let heap = BinaryHeap::from(vec![1, 2, 3, 4]);

// Print 1, 2, 3, 4 in arbitrary order
for x in heap.into_iter() {
    // x has type i32, not &amp;i32
    println!("{}", x);
}</pre> </div>
<h3 class="impl">
<span class="in-band"><code>impl&lt;'a, T&gt; <a class="trait" href="../../../iter/trait.intoiterator/" title="std::iter::IntoIterator">IntoIterator</a> for &amp;'a <a class="struct" href="../struct.binaryheap/" title="std::collections::binary_heap::BinaryHeap">BinaryHeap</a>&lt;T&gt; <span class="where fmt-newline">where T: <a class="trait" href="../../../cmp/trait.ord/" title="std::cmp::Ord">Ord</a></span></code></span><span class="out-of-band">
<a class="srclink" href="https://doc.rust-lang.org/src/collections/binary_heap.rs.html#1143-1152" title="goto source code" target="_blank">[src]</a></span>
</h3> <h4 id="associatedtype.Item-1" class="type"><span id="Item.t-1" class="invisible"><code>type <a href="../../../iter/trait.intoiterator/#associatedtype.Item" class="type">Item</a> = &amp;'a T</code></span></h4> <div class="docblock">
<p>The type of the elements being iterated over.</p> </div>
<h4 id="associatedtype.IntoIter-1" class="type"><span id="IntoIter.t-1" class="invisible"><code>type <a href="../../../iter/trait.intoiterator/#associatedtype.IntoIter" class="type">IntoIter</a> = <a class="struct" href="../struct.iter/" title="std::collections::binary_heap::Iter">Iter</a>&lt;'a, T&gt;</code></span></h4> <div class="docblock">
<p>Which kind of iterator are we turning this into?</p> </div>
<h4 id="method.into_iter-1" class="method"><span id="into_iter.v-1" class="invisible"><code>fn <a href="../../../iter/trait.intoiterator/#tymethod.into_iter" class="fnname">into_iter</a>(self) -&gt; <a class="struct" href="../struct.iter/" title="std::collections::binary_heap::Iter">Iter</a>&lt;'a, T&gt;</code></span></h4> <div class="docblock">
<p>Creates an iterator from a value. <a href="../../../iter/trait.intoiterator/#tymethod.into_iter">Read more</a></p> </div>
<h3 class="impl">
<span class="in-band"><code>impl&lt;T&gt; <a class="trait" href="../../../clone/trait.clone/" title="std::clone::Clone">Clone</a> for <a class="struct" href="../struct.binaryheap/" title="std::collections::binary_heap::BinaryHeap">BinaryHeap</a>&lt;T&gt; <span class="where fmt-newline">where T: <a class="trait" href="../../../clone/trait.clone/" title="std::clone::Clone">Clone</a></span></code></span><span class="out-of-band">
<a class="srclink" href="https://doc.rust-lang.org/src/collections/binary_heap.rs.html#266-274" title="goto source code" target="_blank">[src]</a></span>
</h3> <h4 id="method.clone" class="method"><span id="clone.v" class="invisible"><code>fn <a href="../../../clone/trait.clone/#tymethod.clone" class="fnname">clone</a>(&amp;self) -&gt; <a class="struct" href="../struct.binaryheap/" title="std::collections::binary_heap::BinaryHeap">BinaryHeap</a>&lt;T&gt;</code></span></h4> <div class="docblock">
<p>Returns a copy of the value. <a href="../../../clone/trait.clone/#tymethod.clone">Read more</a></p> </div>
<h4 id="method.clone_from" class="method"><span id="clone_from.v" class="invisible"><code>fn <a href="../../../clone/trait.clone/#method.clone_from" class="fnname">clone_from</a>(&amp;mut self, source: &amp;<a class="struct" href="../struct.binaryheap/" title="std::collections::binary_heap::BinaryHeap">BinaryHeap</a>&lt;T&gt;)</code></span></h4> <div class="docblock">
<p>Performs copy-assignment from <code>source</code>. <a href="../../../clone/trait.clone/#method.clone_from">Read more</a></p> </div>
<h3 class="impl">
<span class="in-band"><code>impl&lt;'a, T&gt; <a class="trait" href="../../../ops/trait.placer/" title="std::ops::Placer">Placer</a>&lt;T&gt; for &amp;'a mut <a class="struct" href="../struct.binaryheap/" title="std::collections::binary_heap::BinaryHeap">BinaryHeap</a>&lt;T&gt; <span class="where fmt-newline">where T: 'a + <a class="trait" href="../../../clone/trait.clone/" title="std::clone::Clone">Clone</a> + <a class="trait" href="../../../cmp/trait.ord/" title="std::cmp::Ord">Ord</a></span></code></span><span class="out-of-band">
<a class="srclink" href="https://doc.rust-lang.org/src/collections/binary_heap.rs.html#1206-1218" title="goto source code" target="_blank">[src]</a></span>
</h3> <h4 id="associatedtype.Place" class="type"><span id="Place.t" class="invisible"><code>type <a href="../../../ops/trait.placer/#associatedtype.Place" class="type">Place</a> = <a class="struct" href="../struct.binaryheapplace/" title="std::collections::binary_heap::BinaryHeapPlace">BinaryHeapPlace</a>&lt;'a, T&gt;</code></span></h4> <div class="stability"><span class="stab unstable">🔬 This is a nightly-only experimental API. (placement_new_protocol #27779)</span></div>
<div class="docblock">
<p><code>Place</code> is the intermedate agent guarding the uninitialized state for <code>Data</code>. <a href="../../../ops/trait.placer/#associatedtype.Place">Read more</a></p> </div>
<h4 id="method.make_place" class="method"><span id="make_place.v" class="invisible"><code>fn <a href="../../../ops/trait.placer/#tymethod.make_place" class="fnname">make_place</a>(self) -&gt; &amp;'a mut <a class="struct" href="../struct.binaryheap/" title="std::collections::binary_heap::BinaryHeap">BinaryHeap</a>&lt;T&gt;::<a class="trait" href="../../../ops/trait.placer/" title="std::ops::Placer">Place</a></code></span></h4> <div class="stability"><span class="stab unstable">🔬 This is a nightly-only experimental API. (placement_new_protocol #27779)</span></div>
<div class="docblock">
<p>Creates a fresh place from <code>self</code>.</p> </div>
<h3 class="impl">
<span class="in-band"><code>impl&lt;T&gt; <a class="trait" href="../../../fmt/trait.debug/" title="std::fmt::Debug">Debug</a> for <a class="struct" href="../struct.binaryheap/" title="std::collections::binary_heap::BinaryHeap">BinaryHeap</a>&lt;T&gt; <span class="where fmt-newline">where T: <a class="trait" href="../../../cmp/trait.ord/" title="std::cmp::Ord">Ord</a> + <a class="trait" href="../../../fmt/trait.debug/" title="std::fmt::Debug">Debug</a></span></code></span><span class="out-of-band">
<div class="since" title="Stable since Rust version 1.4.0">1.4.0</div>
<a class="srclink" href="https://doc.rust-lang.org/src/collections/binary_heap.rs.html#286-290" title="goto source code" target="_blank">[src]</a></span>
</h3> <h4 id="method.fmt" class="method"><span id="fmt.v" class="invisible"><code>fn <a href="../../../fmt/trait.debug/#tymethod.fmt" class="fnname">fmt</a>(&amp;self, f: &amp;mut <a class="struct" href="../../../fmt/struct.formatter/" title="std::fmt::Formatter">Formatter</a>) -&gt; <a class="enum" href="../../../result/enum.result/" title="std::result::Result">Result</a>&lt;<a class="primitive" href="../../../primitive.tuple/">()</a>, <a class="struct" href="../../../fmt/struct.error/" title="std::fmt::Error">Error</a>&gt;</code></span></h4> <div class="docblock">
<p>Formats the value using the given formatter.</p> </div>
<h3 class="impl">
<span class="in-band"><code>impl&lt;T&gt; <a class="trait" href="../../../default/trait.default/" title="std::default::Default">Default</a> for <a class="struct" href="../struct.binaryheap/" title="std::collections::binary_heap::BinaryHeap">BinaryHeap</a>&lt;T&gt; <span class="where fmt-newline">where T: <a class="trait" href="../../../cmp/trait.ord/" title="std::cmp::Ord">Ord</a></span></code></span><span class="out-of-band">
<a class="srclink" href="https://doc.rust-lang.org/src/collections/binary_heap.rs.html#277-283" title="goto source code" target="_blank">[src]</a></span>
</h3> <h4 id="method.default" class="method"><span id="default.v" class="invisible"><code>fn <a href="../../../default/trait.default/#tymethod.default" class="fnname">default</a>() -&gt; <a class="struct" href="../struct.binaryheap/" title="std::collections::binary_heap::BinaryHeap">BinaryHeap</a>&lt;T&gt;</code></span></h4> <div class="docblock">
<p>Creates an empty <code>BinaryHeap&lt;T&gt;</code>.</p> </div>
<h3 class="impl">
<span class="in-band"><code>impl&lt;T&gt; <a class="trait" href="../../../iter/trait.fromiterator/" title="std::iter::FromIterator">FromIterator</a>&lt;T&gt; for <a class="struct" href="../struct.binaryheap/" title="std::collections::binary_heap::BinaryHeap">BinaryHeap</a>&lt;T&gt; <span class="where fmt-newline">where T: <a class="trait" href="../../../cmp/trait.ord/" title="std::cmp::Ord">Ord</a></span></code></span><span class="out-of-band">
<a class="srclink" href="https://doc.rust-lang.org/src/collections/binary_heap.rs.html#1108-1112" title="goto source code" target="_blank">[src]</a></span>
</h3> <h4 id="method.from_iter" class="method"><span id="from_iter.v" class="invisible"><code>fn <a href="../../../iter/trait.fromiterator/#tymethod.from_iter" class="fnname">from_iter</a>&lt;I&gt;(iter: I) -&gt; <a class="struct" href="../struct.binaryheap/" title="std::collections::binary_heap::BinaryHeap">BinaryHeap</a>&lt;T&gt; <span class="where fmt-newline">where I: <a class="trait" href="../../../iter/trait.intoiterator/" title="std::iter::IntoIterator">IntoIterator</a>&lt;Item=T&gt;</span></code></span></h4> <div class="docblock">
<p>Creates a value from an iterator. <a href="../../../iter/trait.fromiterator/#tymethod.from_iter">Read more</a></p> </div>
<div class="_attribution">
  <p class="_attribution-p">
    © 2010 The Rust Project Developers<br>Licensed under the Apache License, Version 2.0 or the MIT license, at your option.<br>
    <a href="https://doc.rust-lang.org/std/collections/binary_heap/struct.BinaryHeap.html" class="_attribution-link" target="_blank">https://doc.rust-lang.org/std/collections/binary_heap/struct.BinaryHeap.html</a>
  </p>
</div>

			</div>
		</div>
	</section>

	</div>
</body>
</html>
