
<!DOCTYPE HTML>

<html lang="en">

<head>
  <meta charset="utf-8">
  <title>std&#58;&#58;string&#58;&#58;String - Rust - W3cubDocs</title>
  
  <meta name="description" content=" A UTF-8 encoded, growable string. ">
  <meta name="keywords" content="struct, std, string, -, rust">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="http://docs.w3cub.com/rust/std/string/struct.string/">
  <link href="/favicon.png" rel="icon">
  <link type="text/css" rel="stylesheet" href="/assets/application-50364fff564ce3b6327021805f3f00e2957b441cf27f576a7dd4ff63bbc47047.css">
  <script type="text/javascript" src="/assets/application-db64bfd54ceb42be11af7995804cf4902548419ceb79d509b0b7d62c22d98e6f.js"></script>
  <script src="/json/rust.js"></script>
  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-71174418-1']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>


</head>

<body>
	<div class="_app">
	<header class="_header">
  
  <form class="_search">
    <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
    <a class="_search-clear"></a>
    <div class="_search-tag"></div>
  </form>
  
  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/rust/" class="_nav-link" title="" style="margin-left:0;">Rust</a></span>
  
  <nav class="_nav">
    <a href="/app/" class="_nav-link ">App</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		<div class="_list">
			
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<div class="_page _rust">
				
<h1 class="fqn">Struct std::string::String</h1> <pre class="rust struct" data-language="rust">pub struct String { /* fields omitted */ }</pre>
<p>A UTF-8 encoded, growable string.</p> <p>The <code>String</code> type is the most common string type that has ownership over the contents of the string. It has a close relationship with its borrowed counterpart, the primitive <a href="../../primitive.str/"><code>str</code></a>.</p> <h4 id="examples" class="section-header">Examples</h4> <p>You can create a <code>String</code> from a literal string with <code>String::from</code>:</p> <pre class="rust rust-example-rendered" data-language="rust">
let hello = String::from("Hello, world!");</pre> <p>You can append a <a href="../../primitive.char/"><code>char</code></a> to a <code>String</code> with the <a href="#method.push"><code>push()</code></a> method, and append a <a href="../../primitive.str/"><code>&amp;str</code></a> with the <a href="#method.push_str"><code>push_str()</code></a> method:</p> <pre class="rust rust-example-rendered" data-language="rust">
let mut hello = String::from("Hello, ");

hello.push('w');
hello.push_str("orld!");</pre> <p>If you have a vector of UTF-8 bytes, you can create a <code>String</code> from it with the <a href="#method.from_utf8"><code>from_utf8()</code></a> method:</p> <pre class="rust rust-example-rendered" data-language="rust">
// some bytes, in a vector
let sparkle_heart = vec![240, 159, 146, 150];

// We know these bytes are valid, so we'll use `unwrap()`.
let sparkle_heart = String::from_utf8(sparkle_heart).unwrap();

assert_eq!("💖", sparkle_heart);</pre> <h4 id="utf-8" class="section-header">UTF-8</h4> <p><code>String</code>s are always valid UTF-8. This has a few implications, the first of which is that if you need a non-UTF-8 string, consider <a href="../../ffi/struct.osstring/"><code>OsString</code></a>. It is similar, but without the UTF-8 constraint. The second implication is that you cannot index into a <code>String</code>:</p> <pre class="rust rust-example-rendered" data-language="rust">
let s = "hello";

println!("The first letter of s is {}", s[0]); // ERROR!!!</pre> <p>Indexing is intended to be a constant-time operation, but UTF-8 encoding does not allow us to do this. Furthermore, it's not clear what sort of thing the index should return: a byte, a codepoint, or a grapheme cluster. The <a href="#method.bytes"><code>bytes()</code></a> and <a href="#method.chars"><code>chars()</code></a> methods return iterators over the first two, respectively.</p> <h4 id="deref" class="section-header">Deref</h4> <p><code>String</code>s implement <a href="../../ops/trait.deref/"><code>Deref</code></a><code>&lt;Target=str&gt;</code>, and so inherit all of <a href="../../primitive.str/"><code>str</code></a>'s methods. In addition, this means that you can pass a <code>String</code> to any function which takes a <a href="../../primitive.str/"><code>&amp;str</code></a> by using an ampersand (<code>&amp;</code>):</p> <pre class="rust rust-example-rendered" data-language="rust">
fn takes_str(s: &amp;str) { }

let s = String::from("Hello");

takes_str(&amp;s);</pre> <p>This will create a <a href="../../primitive.str/"><code>&amp;str</code></a> from the <code>String</code> and pass it in. This conversion is very inexpensive, and so generally, functions will accept <a href="../../primitive.str/"><code>&amp;str</code></a>s as arguments unless they need a <code>String</code> for some specific reason.</p> <h4 id="representation" class="section-header">Representation</h4> <p>A <code>String</code> is made up of three components: a pointer to some bytes, a length, and a capacity. The pointer points to an internal buffer <code>String</code> uses to store its data. The length is the number of bytes currently stored in the buffer, and the capacity is the size of the buffer in bytes. As such, the length will always be less than or equal to the capacity.</p> <p>This buffer is always stored on the heap.</p> <p>You can look at these with the <a href="#method.as_ptr"><code>as_ptr()</code></a>, <a href="#method.len"><code>len()</code></a>, and <a href="#method.capacity"><code>capacity()</code></a> methods:</p> <pre class="rust rust-example-rendered" data-language="rust">
use std::mem;

let story = String::from("Once upon a time...");

let ptr = story.as_ptr();
let len = story.len();
let capacity = story.capacity();

// story has nineteen bytes
assert_eq!(19, len);

// Now that we have our parts, we throw the story away.
mem::forget(story);

// We can re-build a String out of ptr, len, and capacity. This is all
// unsafe because we are responsible for making sure the components are
// valid:
let s = unsafe { String::from_raw_parts(ptr as *mut _, len, capacity) } ;

assert_eq!(String::from("Once upon a time..."), s);</pre> <p>If a <code>String</code> has enough capacity, adding elements to it will not re-allocate. For example, consider this program:</p> <pre class="rust rust-example-rendered" data-language="rust">
let mut s = String::new();

println!("{}", s.capacity());

for _ in 0..5 {
    s.push_str("hello");
    println!("{}", s.capacity());
}</pre> <p>This will output the following:</p> <pre>0
5
10
20
20
40
</pre> <p>At first, we have no memory allocated at all, but as we append to the string, it increases its capacity appropriately. If we instead use the <a href="#method.with_capacity"><code>with_capacity()</code></a> method to allocate the correct capacity initially:</p> <pre class="rust rust-example-rendered" data-language="rust">
let mut s = String::with_capacity(25);

println!("{}", s.capacity());

for _ in 0..5 {
    s.push_str("hello");
    println!("{}", s.capacity());
}</pre> <p>We end up with a different output:</p> <pre>25
25
25
25
25
25
</pre> <p>Here, there's no need to allocate more memory inside the loop.</p> <h2 id="methods">Methods</h2>
<h3 class="impl">
<span class="in-band"><code>impl <a class="struct" href="../struct.string/" title="std::string::String">String</a></code></span><span class="out-of-band">
<a class="srclink" href="https://doc.rust-lang.org/src/collections/string.rs.html#331-1392" title="goto source code" target="_blank">[src]</a></span>
</h3> <h4 id="method.new" class="method"><span id="new.v" class="invisible"><code>fn <a href="#method.new" class="fnname">new</a>() -&gt; <a class="struct" href="../struct.string/" title="std::string::String">String</a></code></span></h4> <div class="docblock">
<p>Creates a new empty <code>String</code>.</p> <p>Given that the <code>String</code> is empty, this will not allocate any initial buffer. While that means that this initial operation is very inexpensive, but may cause excessive allocation later, when you add data. If you have an idea of how much data the <code>String</code> will hold, consider the <a href="#method.with_capacity"><code>with_capacity()</code></a> method to prevent excessive re-allocation.</p> <h4 id="examples-1" class="section-header">Examples</h4> <p>Basic usage:</p> <pre class="rust rust-example-rendered" data-language="rust">
let s = String::new();</pre> </div>
<h4 id="method.with_capacity" class="method"><span id="with_capacity.v" class="invisible"><code>fn <a href="#method.with_capacity" class="fnname">with_capacity</a>(capacity: <a class="primitive" href="../../primitive.usize/">usize</a>) -&gt; <a class="struct" href="../struct.string/" title="std::string::String">String</a></code></span></h4> <div class="docblock">
<p>Creates a new empty <code>String</code> with a particular capacity.</p> <p><code>String</code>s have an internal buffer to hold their data. The capacity is the length of that buffer, and can be queried with the <a href="#method.capacity"><code>capacity()</code></a> method. This method creates an empty <code>String</code>, but one with an initial buffer that can hold <code>capacity</code> bytes. This is useful when you may be appending a bunch of data to the <code>String</code>, reducing the number of reallocations it needs to do.</p> <p>If the given capacity is <code>0</code>, no allocation will occur, and this method is identical to the <a href="#method.new"><code>new()</code></a> method.</p> <h4 id="examples-2" class="section-header">Examples</h4> <p>Basic usage:</p> <pre class="rust rust-example-rendered" data-language="rust">
let mut s = String::with_capacity(10);

// The String contains no chars, even though it has capacity for more
assert_eq!(s.len(), 0);

// These are all done without reallocating...
let cap = s.capacity();
for i in 0..10 {
    s.push('a');
}

assert_eq!(s.capacity(), cap);

// ...but this may make the vector reallocate
s.push('a');</pre> </div>
<h4 id="method.from_utf8" class="method"><span id="from_utf8.v" class="invisible"><code>fn <a href="#method.from_utf8" class="fnname">from_utf8</a>(vec: <a class="struct" href="../../vec/struct.vec/" title="std::vec::Vec">Vec</a>&lt;<a class="primitive" href="../../primitive.u8/">u8</a>&gt;) -&gt; <a class="enum" href="../../result/enum.result/" title="std::result::Result">Result</a>&lt;<a class="struct" href="../struct.string/" title="std::string::String">String</a>, <a class="struct" href="../struct.fromutf8error/" title="std::string::FromUtf8Error">FromUtf8Error</a>&gt;</code></span></h4> <div class="docblock">
<p>Converts a vector of bytes to a <code>String</code>.</p> <p>A string slice (<a href="../../primitive.str/"><code>&amp;str</code></a>) is made of bytes (<a href="../../primitive.u8/"><code>u8</code></a>), and a vector of bytes (<a href="../../vec/struct.vec/"><code>Vec&lt;u8&gt;</code></a>) is made of bytes, so this function converts between the two. Not all byte slices are valid <code>String</code>s, however: <code>String</code> requires that it is valid UTF-8. <code>from_utf8()</code> checks to ensure that the bytes are valid UTF-8, and then does the conversion.</p> <p>If you are sure that the byte slice is valid UTF-8, and you don't want to incur the overhead of the validity check, there is an unsafe version of this function, <a href="../struct.string/#method.from_utf8_unchecked"><code>from_utf8_unchecked()</code></a>, which has the same behavior but skips the check.</p> <p>This method will take care to not copy the vector, for efficiency's sake.</p> <p>If you need a <code>&amp;str</code> instead of a <code>String</code>, consider <a href="../../str/fn.from_utf8/"><code>str::from_utf8()</code></a>.</p> <h4 id="errors" class="section-header">Errors</h4> <p>Returns <code>Err</code> if the slice is not UTF-8 with a description as to why the provided bytes are not UTF-8. The vector you moved in is also included.</p> <h4 id="examples-3" class="section-header">Examples</h4> <p>Basic usage:</p> <pre class="rust rust-example-rendered" data-language="rust">
// some bytes, in a vector
let sparkle_heart = vec![240, 159, 146, 150];

// We know these bytes are valid, so we'll use `unwrap()`.
let sparkle_heart = String::from_utf8(sparkle_heart).unwrap();

assert_eq!("💖", sparkle_heart);</pre> <p>Incorrect bytes:</p> <pre class="rust rust-example-rendered" data-language="rust">
// some invalid bytes, in a vector
let sparkle_heart = vec![0, 159, 146, 150];

assert!(String::from_utf8(sparkle_heart).is_err());</pre> <p>See the docs for <a href="../struct.fromutf8error/"><code>FromUtf8Error</code></a> for more details on what you can do with this error.</p> </div>
<h4 id="method.from_utf8_lossy" class="method"><span id="from_utf8_lossy.v" class="invisible"><code>fn <a href="#method.from_utf8_lossy" class="fnname">from_utf8_lossy</a>(v: <a class="primitive" href="../../primitive.slice/">&amp;'a [</a><a class="primitive" href="../../primitive.u8/">u8</a><a class="primitive" href="../../primitive.slice/">]</a>) -&gt; <a class="enum" href="../../borrow/enum.cow/" title="std::borrow::Cow">Cow</a>&lt;'a, <a class="primitive" href="../../primitive.str/">str</a>&gt;</code></span></h4> <div class="docblock">
<p>Converts a slice of bytes to a string, including invalid characters.</p> <p>Strings are made of bytes (<a href="../../primitive.u8/"><code>u8</code></a>), and a slice of bytes (<a href="../../primitive.slice/"><code>&amp;[u8]</code></a>) is made of bytes, so this function converts between the two. Not all byte slices are valid strings, however: strings are required to be valid UTF-8. During this conversion, <code>from_utf8_lossy()</code> will replace any invalid UTF-8 sequences with <code>U+FFFD REPLACEMENT CHARACTER</code>, which looks like this: �</p> <p>If you are sure that the byte slice is valid UTF-8, and you don't want to incur the overhead of the conversion, there is an unsafe version of this function, <a href="../struct.string/#method.from_utf8_unchecked"><code>from_utf8_unchecked()</code></a>, which has the same behavior but skips the checks.</p> <p>This function returns a <a href="../../borrow/enum.cow/"><code>Cow&lt;'a, str&gt;</code></a>. If our byte slice is invalid UTF-8, then we need to insert the replacement characters, which will change the size of the string, and hence, require a <code>String</code>. But if it's already valid UTF-8, we don't need a new allocation. This return type allows us to handle both cases.</p> <h4 id="examples-4" class="section-header">Examples</h4> <p>Basic usage:</p> <pre class="rust rust-example-rendered" data-language="rust">
// some bytes, in a vector
let sparkle_heart = vec![240, 159, 146, 150];

let sparkle_heart = String::from_utf8_lossy(&amp;sparkle_heart);

assert_eq!("💖", sparkle_heart);</pre> <p>Incorrect bytes:</p> <pre class="rust rust-example-rendered" data-language="rust">
// some invalid bytes
let input = b"Hello \xF0\x90\x80World";
let output = String::from_utf8_lossy(input);

assert_eq!("Hello �World", output);</pre> </div>
<h4 id="method.from_utf16" class="method"><span id="from_utf16.v" class="invisible"><code>fn <a href="#method.from_utf16" class="fnname">from_utf16</a>(v: <a class="primitive" href="../../primitive.slice/">&amp;[</a><a class="primitive" href="../../primitive.u16/">u16</a><a class="primitive" href="../../primitive.slice/">]</a>) -&gt; <a class="enum" href="../../result/enum.result/" title="std::result::Result">Result</a>&lt;<a class="struct" href="../struct.string/" title="std::string::String">String</a>, <a class="struct" href="../struct.fromutf16error/" title="std::string::FromUtf16Error">FromUtf16Error</a>&gt;</code></span></h4> <div class="docblock">
<p>Decode a UTF-16 encoded vector <code>v</code> into a <code>String</code>, returning <code>Err</code> if <code>v</code> contains any invalid data.</p> <h4 id="examples-5" class="section-header">Examples</h4> <p>Basic usage:</p> <pre class="rust rust-example-rendered" data-language="rust">
// 𝄞music
let v = &amp;[0xD834, 0xDD1E, 0x006d, 0x0075,
          0x0073, 0x0069, 0x0063];
assert_eq!(String::from("𝄞music"),
           String::from_utf16(v).unwrap());

// 𝄞mu&lt;invalid&gt;ic
let v = &amp;[0xD834, 0xDD1E, 0x006d, 0x0075,
          0xD800, 0x0069, 0x0063];
assert!(String::from_utf16(v).is_err());</pre> </div>
<h4 id="method.from_utf16_lossy" class="method"><span id="from_utf16_lossy.v" class="invisible"><code>fn <a href="#method.from_utf16_lossy" class="fnname">from_utf16_lossy</a>(v: <a class="primitive" href="../../primitive.slice/">&amp;[</a><a class="primitive" href="../../primitive.u16/">u16</a><a class="primitive" href="../../primitive.slice/">]</a>) -&gt; <a class="struct" href="../struct.string/" title="std::string::String">String</a></code></span></h4> <div class="docblock">
<p>Decode a UTF-16 encoded vector <code>v</code> into a string, replacing invalid data with the replacement character (U+FFFD).</p> <h4 id="examples-6" class="section-header">Examples</h4> <p>Basic usage:</p> <pre class="rust rust-example-rendered" data-language="rust">
// 𝄞mus&lt;invalid&gt;ic&lt;invalid&gt;
let v = &amp;[0xD834, 0xDD1E, 0x006d, 0x0075,
          0x0073, 0xDD1E, 0x0069, 0x0063,
          0xD834];

assert_eq!(String::from("𝄞mus\u{FFFD}ic\u{FFFD}"),
           String::from_utf16_lossy(v));</pre> </div>
<h4 id="method.from_raw_parts" class="method"><span id="from_raw_parts.v" class="invisible"><code>unsafe fn <a href="#method.from_raw_parts" class="fnname">from_raw_parts</a>(buf: <a class="primitive" href="../../primitive.pointer/">*mut </a><a class="primitive" href="../../primitive.u8/">u8</a>, length: <a class="primitive" href="../../primitive.usize/">usize</a>, capacity: <a class="primitive" href="../../primitive.usize/">usize</a>) -&gt; <a class="struct" href="../struct.string/" title="std::string::String">String</a></code></span></h4> <div class="docblock">
<p>Creates a new <code>String</code> from a length, capacity, and pointer.</p> <h4 id="safety" class="section-header">Safety</h4> <p>This is highly unsafe, due to the number of invariants that aren't checked:</p> <ul> <li>The memory at <code>ptr</code> needs to have been previously allocated by the same allocator the standard library uses.</li> <li>
<code>length</code> needs to be less than or equal to <code>capacity</code>.</li> <li>
<code>capacity</code> needs to be the correct value.</li> </ul> <p>Violating these may cause problems like corrupting the allocator's internal datastructures.</p> <p>The ownership of <code>ptr</code> is effectively transferred to the <code>String</code> which may then deallocate, reallocate or change the contents of memory pointed to by the pointer at will. Ensure that nothing else uses the pointer after calling this function.</p> <h4 id="examples-7" class="section-header">Examples</h4> <p>Basic usage:</p> <pre class="rust rust-example-rendered" data-language="rust">
use std::mem;

unsafe {
    let s = String::from("hello");
    let ptr = s.as_ptr();
    let len = s.len();
    let capacity = s.capacity();

    mem::forget(s);

    let s = String::from_raw_parts(ptr as *mut _, len, capacity);

    assert_eq!(String::from("hello"), s);
}</pre> </div>
<h4 id="method.from_utf8_unchecked" class="method"><span id="from_utf8_unchecked.v" class="invisible"><code>unsafe fn <a href="#method.from_utf8_unchecked" class="fnname">from_utf8_unchecked</a>(bytes: <a class="struct" href="../../vec/struct.vec/" title="std::vec::Vec">Vec</a>&lt;<a class="primitive" href="../../primitive.u8/">u8</a>&gt;) -&gt; <a class="struct" href="../struct.string/" title="std::string::String">String</a></code></span></h4> <div class="docblock">
<p>Converts a vector of bytes to a <code>String</code> without checking that the string contains valid UTF-8.</p> <p>See the safe version, <a href="../struct.string/#method.from_utf8"><code>from_utf8()</code></a>, for more details.</p> <h4 id="safety-1" class="section-header">Safety</h4> <p>This function is unsafe because it does not check that the bytes passed to it are valid UTF-8. If this constraint is violated, it may cause memory unsafety issues with future users of the <code>String</code>, as the rest of the standard library assumes that <code>String</code>s are valid UTF-8.</p> <h4 id="examples-8" class="section-header">Examples</h4> <p>Basic usage:</p> <pre class="rust rust-example-rendered" data-language="rust">
// some bytes, in a vector
let sparkle_heart = vec![240, 159, 146, 150];

let sparkle_heart = unsafe {
    String::from_utf8_unchecked(sparkle_heart)
};

assert_eq!("💖", sparkle_heart);</pre> </div>
<h4 id="method.into_bytes" class="method"><span id="into_bytes.v" class="invisible"><code>fn <a href="#method.into_bytes" class="fnname">into_bytes</a>(self) -&gt; <a class="struct" href="../../vec/struct.vec/" title="std::vec::Vec">Vec</a>&lt;<a class="primitive" href="../../primitive.u8/">u8</a>&gt;</code></span></h4> <div class="docblock">
<p>Converts a <code>String</code> into a byte vector.</p> <p>This consumes the <code>String</code>, so we do not need to copy its contents.</p> <h4 id="examples-9" class="section-header">Examples</h4> <p>Basic usage:</p> <pre class="rust rust-example-rendered" data-language="rust">
let s = String::from("hello");
let bytes = s.into_bytes();

assert_eq!(&amp;[104, 101, 108, 108, 111][..], &amp;bytes[..]);</pre> </div>
<h4 id="method.as_str" class="method"><span id="as_str.v" class="invisible"><code>fn <a href="#method.as_str" class="fnname">as_str</a>(&amp;self) -&gt; &amp;<a class="primitive" href="../../primitive.str/">str</a></code><div class="since" title="Stable since Rust version 1.7.0">1.7.0</div></span></h4> <div class="docblock">
<p>Extracts a string slice containing the entire string.</p> </div>
<h4 id="method.as_mut_str" class="method"><span id="as_mut_str.v" class="invisible"><code>fn <a href="#method.as_mut_str" class="fnname">as_mut_str</a>(&amp;mut self) -&gt; &amp;mut <a class="primitive" href="../../primitive.str/">str</a></code><div class="since" title="Stable since Rust version 1.7.0">1.7.0</div></span></h4> <div class="docblock">
<p>Extracts a string slice containing the entire string.</p> </div>
<h4 id="method.push_str" class="method"><span id="push_str.v" class="invisible"><code>fn <a href="#method.push_str" class="fnname">push_str</a>(&amp;mut self, string: &amp;<a class="primitive" href="../../primitive.str/">str</a>)</code></span></h4> <div class="docblock">
<p>Appends a given string slice onto the end of this <code>String</code>.</p> <h4 id="examples-10" class="section-header">Examples</h4> <p>Basic usage:</p> <pre class="rust rust-example-rendered" data-language="rust">
let mut s = String::from("foo");

s.push_str("bar");

assert_eq!("foobar", s);</pre> </div>
<h4 id="method.capacity" class="method"><span id="capacity.v" class="invisible"><code>fn <a href="#method.capacity" class="fnname">capacity</a>(&amp;self) -&gt; <a class="primitive" href="../../primitive.usize/">usize</a></code></span></h4> <div class="docblock">
<p>Returns this <code>String</code>'s capacity, in bytes.</p> <h4 id="examples-11" class="section-header">Examples</h4> <p>Basic usage:</p> <pre class="rust rust-example-rendered" data-language="rust">
let s = String::with_capacity(10);

assert!(s.capacity() &gt;= 10);</pre> </div>
<h4 id="method.reserve" class="method"><span id="reserve.v" class="invisible"><code>fn <a href="#method.reserve" class="fnname">reserve</a>(&amp;mut self, additional: <a class="primitive" href="../../primitive.usize/">usize</a>)</code></span></h4> <div class="docblock">
<p>Ensures that this <code>String</code>'s capacity is at least <code>additional</code> bytes larger than its length.</p> <p>The capacity may be increased by more than <code>additional</code> bytes if it chooses, to prevent frequent reallocations.</p> <p>If you do not want this "at least" behavior, see the <a href="#method.reserve_exact"><code>reserve_exact()</code></a> method.</p> <h4 id="panics" class="section-header">Panics</h4> <p>Panics if the new capacity overflows <code>usize</code>.</p> <h4 id="examples-12" class="section-header">Examples</h4> <p>Basic usage:</p> <pre class="rust rust-example-rendered" data-language="rust">
let mut s = String::new();

s.reserve(10);

assert!(s.capacity() &gt;= 10);</pre> <p>This may not actually increase the capacity:</p> <pre class="rust rust-example-rendered" data-language="rust">
let mut s = String::with_capacity(10);
s.push('a');
s.push('b');

// s now has a length of 2 and a capacity of 10
assert_eq!(2, s.len());
assert_eq!(10, s.capacity());

// Since we already have an extra 8 capacity, calling this...
s.reserve(8);

// ... doesn't actually increase.
assert_eq!(10, s.capacity());</pre> </div>
<h4 id="method.reserve_exact" class="method"><span id="reserve_exact.v" class="invisible"><code>fn <a href="#method.reserve_exact" class="fnname">reserve_exact</a>(&amp;mut self, additional: <a class="primitive" href="../../primitive.usize/">usize</a>)</code></span></h4> <div class="docblock">
<p>Ensures that this <code>String</code>'s capacity is <code>additional</code> bytes larger than its length.</p> <p>Consider using the <a href="#method.reserve"><code>reserve()</code></a> method unless you absolutely know better than the allocator.</p> <h4 id="panics-1" class="section-header">Panics</h4> <p>Panics if the new capacity overflows <code>usize</code>.</p> <h4 id="examples-13" class="section-header">Examples</h4> <p>Basic usage:</p> <pre class="rust rust-example-rendered" data-language="rust">
let mut s = String::new();

s.reserve_exact(10);

assert!(s.capacity() &gt;= 10);</pre> <p>This may not actually increase the capacity:</p> <pre class="rust rust-example-rendered" data-language="rust">
let mut s = String::with_capacity(10);
s.push('a');
s.push('b');

// s now has a length of 2 and a capacity of 10
assert_eq!(2, s.len());
assert_eq!(10, s.capacity());

// Since we already have an extra 8 capacity, calling this...
s.reserve_exact(8);

// ... doesn't actually increase.
assert_eq!(10, s.capacity());</pre> </div>
<h4 id="method.shrink_to_fit" class="method"><span id="shrink_to_fit.v" class="invisible"><code>fn <a href="#method.shrink_to_fit" class="fnname">shrink_to_fit</a>(&amp;mut self)</code></span></h4> <div class="docblock">
<p>Shrinks the capacity of this <code>String</code> to match its length.</p> <h4 id="examples-14" class="section-header">Examples</h4> <p>Basic usage:</p> <pre class="rust rust-example-rendered" data-language="rust">
let mut s = String::from("foo");

s.reserve(100);
assert!(s.capacity() &gt;= 100);

s.shrink_to_fit();
assert_eq!(3, s.capacity());</pre> </div>
<h4 id="method.push" class="method"><span id="push.v" class="invisible"><code>fn <a href="#method.push" class="fnname">push</a>(&amp;mut self, ch: <a class="primitive" href="../../primitive.char/">char</a>)</code></span></h4> <div class="docblock">
<p>Appends the given <code>char</code> to the end of this <code>String</code>.</p> <h4 id="examples-15" class="section-header">Examples</h4> <p>Basic usage:</p> <pre class="rust rust-example-rendered" data-language="rust">
let mut s = String::from("abc");

s.push('1');
s.push('2');
s.push('3');

assert_eq!("abc123", s);</pre> </div>
<h4 id="method.as_bytes" class="method"><span id="as_bytes.v" class="invisible"><code>fn <a href="#method.as_bytes" class="fnname">as_bytes</a>(&amp;self) -&gt; <a class="primitive" href="../../primitive.slice/">&amp;[</a><a class="primitive" href="../../primitive.u8/">u8</a><a class="primitive" href="../../primitive.slice/">]</a></code></span></h4> <div class="docblock">
<p>Returns a byte slice of this <code>String</code>'s contents.</p> <h4 id="examples-16" class="section-header">Examples</h4> <p>Basic usage:</p> <pre class="rust rust-example-rendered" data-language="rust">
let s = String::from("hello");

assert_eq!(&amp;[104, 101, 108, 108, 111], s.as_bytes());</pre> </div>
<h4 id="method.truncate" class="method"><span id="truncate.v" class="invisible"><code>fn <a href="#method.truncate" class="fnname">truncate</a>(&amp;mut self, new_len: <a class="primitive" href="../../primitive.usize/">usize</a>)</code></span></h4> <div class="docblock">
<p>Shortens this <code>String</code> to the specified length.</p> <p>If <code>new_len</code> is greater than the string's current length, this has no effect.</p> <h4 id="panics-2" class="section-header">Panics</h4> <p>Panics if <code>new_len</code> does not lie on a <a href="../../primitive.char/"><code>char</code></a> boundary.</p> <h4 id="examples-17" class="section-header">Examples</h4> <p>Basic usage:</p> <pre class="rust rust-example-rendered" data-language="rust">
let mut s = String::from("hello");

s.truncate(2);

assert_eq!("he", s);</pre> </div>
<h4 id="method.pop" class="method"><span id="pop.v" class="invisible"><code>fn <a href="#method.pop" class="fnname">pop</a>(&amp;mut self) -&gt; <a class="enum" href="../../option/enum.option/" title="std::option::Option">Option</a>&lt;<a class="primitive" href="../../primitive.char/">char</a>&gt;</code></span></h4> <div class="docblock">
<p>Removes the last character from the string buffer and returns it.</p> <p>Returns <code>None</code> if this <code>String</code> is empty.</p> <h4 id="examples-18" class="section-header">Examples</h4> <p>Basic usage:</p> <pre class="rust rust-example-rendered" data-language="rust">
let mut s = String::from("foo");

assert_eq!(s.pop(), Some('o'));
assert_eq!(s.pop(), Some('o'));
assert_eq!(s.pop(), Some('f'));

assert_eq!(s.pop(), None);</pre> </div>
<h4 id="method.remove" class="method"><span id="remove.v" class="invisible"><code>fn <a href="#method.remove" class="fnname">remove</a>(&amp;mut self, idx: <a class="primitive" href="../../primitive.usize/">usize</a>) -&gt; <a class="primitive" href="../../primitive.char/">char</a></code></span></h4> <div class="docblock">
<p>Removes a <code>char</code> from this <code>String</code> at a byte position and returns it.</p> <p>This is an <code>O(n)</code> operation, as it requires copying every element in the buffer.</p> <h4 id="panics-3" class="section-header">Panics</h4> <p>Panics if <code>idx</code> is larger than or equal to the <code>String</code>'s length, or if it does not lie on a <a href="../../primitive.char/"><code>char</code></a> boundary.</p> <h4 id="examples-19" class="section-header">Examples</h4> <p>Basic usage:</p> <pre class="rust rust-example-rendered" data-language="rust">
let mut s = String::from("foo");

assert_eq!(s.remove(0), 'f');
assert_eq!(s.remove(1), 'o');
assert_eq!(s.remove(0), 'o');</pre> </div>
<h4 id="method.insert" class="method"><span id="insert.v" class="invisible"><code>fn <a href="#method.insert" class="fnname">insert</a>(&amp;mut self, idx: <a class="primitive" href="../../primitive.usize/">usize</a>, ch: <a class="primitive" href="../../primitive.char/">char</a>)</code></span></h4> <div class="docblock">
<p>Inserts a character into this <code>String</code> at a byte position.</p> <p>This is an <code>O(n)</code> operation as it requires copying every element in the buffer.</p> <h4 id="panics-4" class="section-header">Panics</h4> <p>Panics if <code>idx</code> is larger than the <code>String</code>'s length, or if it does not lie on a <a href="../../primitive.char/"><code>char</code></a> boundary.</p> <h4 id="examples-20" class="section-header">Examples</h4> <p>Basic usage:</p> <pre class="rust rust-example-rendered" data-language="rust">
let mut s = String::with_capacity(3);

s.insert(0, 'f');
s.insert(1, 'o');
s.insert(2, 'o');

assert_eq!("foo", s);</pre> </div>
<h4 id="method.insert_str" class="method"><span id="insert_str.v" class="invisible"><code>fn <a href="#method.insert_str" class="fnname">insert_str</a>(&amp;mut self, idx: <a class="primitive" href="../../primitive.usize/">usize</a>, string: &amp;<a class="primitive" href="../../primitive.str/">str</a>)</code><div class="since" title="Stable since Rust version 1.16.0">1.16.0</div></span></h4> <div class="docblock">
<p>Inserts a string slice into this <code>String</code> at a byte position.</p> <p>This is an <code>O(n)</code> operation as it requires copying every element in the buffer.</p> <h4 id="panics-5" class="section-header">Panics</h4> <p>Panics if <code>idx</code> is larger than the <code>String</code>'s length, or if it does not lie on a <a href="../../primitive.char/"><code>char</code></a> boundary.</p> <h4 id="examples-21" class="section-header">Examples</h4> <p>Basic usage:</p> <pre class="rust rust-example-rendered" data-language="rust">
let mut s = String::from("bar");

s.insert_str(0, "foo");

assert_eq!("foobar", s);</pre> </div>
<h4 id="method.as_mut_vec" class="method"><span id="as_mut_vec.v" class="invisible"><code>unsafe fn <a href="#method.as_mut_vec" class="fnname">as_mut_vec</a>(&amp;mut self) -&gt; &amp;mut <a class="struct" href="../../vec/struct.vec/" title="std::vec::Vec">Vec</a>&lt;<a class="primitive" href="../../primitive.u8/">u8</a>&gt;</code></span></h4> <div class="docblock">
<p>Returns a mutable reference to the contents of this <code>String</code>.</p> <h4 id="safety-2" class="section-header">Safety</h4> <p>This function is unsafe because it does not check that the bytes passed to it are valid UTF-8. If this constraint is violated, it may cause memory unsafety issues with future users of the <code>String</code>, as the rest of the standard library assumes that <code>String</code>s are valid UTF-8.</p> <h4 id="examples-22" class="section-header">Examples</h4> <p>Basic usage:</p> <pre class="rust rust-example-rendered" data-language="rust">
let mut s = String::from("hello");

unsafe {
    let vec = s.as_mut_vec();
    assert_eq!(&amp;[104, 101, 108, 108, 111][..], &amp;vec[..]);

    vec.reverse();
}
assert_eq!(s, "olleh");</pre> </div>
<h4 id="method.len" class="method"><span id="len.v" class="invisible"><code>fn <a href="#method.len" class="fnname">len</a>(&amp;self) -&gt; <a class="primitive" href="../../primitive.usize/">usize</a></code></span></h4> <div class="docblock">
<p>Returns the length of this <code>String</code>, in bytes.</p> <h4 id="examples-23" class="section-header">Examples</h4> <p>Basic usage:</p> <pre class="rust rust-example-rendered" data-language="rust">
let a = String::from("foo");

assert_eq!(a.len(), 3);</pre> </div>
<h4 id="method.is_empty" class="method"><span id="is_empty.v" class="invisible"><code>fn <a href="#method.is_empty" class="fnname">is_empty</a>(&amp;self) -&gt; <a class="primitive" href="../../primitive.bool/">bool</a></code></span></h4> <div class="docblock">
<p>Returns <code>true</code> if this <code>String</code> has a length of zero.</p> <p>Returns <code>false</code> otherwise.</p> <h4 id="examples-24" class="section-header">Examples</h4> <p>Basic usage:</p> <pre class="rust rust-example-rendered" data-language="rust">
let mut v = String::new();
assert!(v.is_empty());

v.push('a');
assert!(!v.is_empty());</pre> </div>
<h4 id="method.split_off" class="method"><span id="split_off.v" class="invisible"><code>fn <a href="#method.split_off" class="fnname">split_off</a>(&amp;mut self, mid: <a class="primitive" href="../../primitive.usize/">usize</a>) -&gt; <a class="struct" href="../struct.string/" title="std::string::String">String</a></code><div class="since" title="Stable since Rust version 1.16.0">1.16.0</div></span></h4> <div class="docblock">
<p>Divide one string into two at an index.</p> <p>The argument, <code>mid</code>, should be a byte offset from the start of the string. It must also be on the boundary of a UTF-8 code point.</p> <p>The two strings returned go from the start of the string to <code>mid</code>, and from <code>mid</code> to the end of the string.</p> <h4 id="panics-6" class="section-header">Panics</h4> <p>Panics if <code>mid</code> is not on a <code>UTF-8</code> code point boundary, or if it is beyond the last code point of the string.</p> <h4 id="examples-25" class="section-header">Examples</h4> <pre class="rust rust-example-rendered" data-language="rust">
let mut hello = String::from("Hello, World!");
let world = hello.split_off(7);
assert_eq!(hello, "Hello, ");
assert_eq!(world, "World!");</pre> </div>
<h4 id="method.clear" class="method"><span id="clear.v" class="invisible"><code>fn <a href="#method.clear" class="fnname">clear</a>(&amp;mut self)</code></span></h4> <div class="docblock">
<p>Truncates this <code>String</code>, removing all contents.</p> <p>While this means the <code>String</code> will have a length of zero, it does not touch its capacity.</p> <h4 id="examples-26" class="section-header">Examples</h4> <p>Basic usage:</p> <pre class="rust rust-example-rendered" data-language="rust">
let mut s = String::from("foo");

s.clear();

assert!(s.is_empty());
assert_eq!(0, s.len());
assert_eq!(3, s.capacity());</pre> </div>
<h4 id="method.drain" class="method"><span id="drain.v" class="invisible"><code>fn <a href="#method.drain" class="fnname">drain</a>&lt;R&gt;(&amp;mut self, range: R) -&gt; <a class="struct" href="../struct.drain/" title="std::string::Drain">Drain</a> <span class="where fmt-newline">where R: <a class="trait" href="../../collections/range/trait.rangeargument/" title="std::collections::range::RangeArgument">RangeArgument</a>&lt;<a class="primitive" href="../../primitive.usize/">usize</a>&gt;</span></code><div class="since" title="Stable since Rust version 1.6.0">1.6.0</div></span></h4> <div class="docblock">
<p>Create a draining iterator that removes the specified range in the string and yields the removed chars.</p> <p>Note: The element range is removed even if the iterator is not consumed until the end.</p> <h4 id="panics-7" class="section-header">Panics</h4> <p>Panics if the starting point or end point do not lie on a <a href="../../primitive.char/"><code>char</code></a> boundary, or if they're out of bounds.</p> <h4 id="examples-27" class="section-header">Examples</h4> <p>Basic usage:</p> <pre class="rust rust-example-rendered" data-language="rust">
let mut s = String::from("α is alpha, β is beta");
let beta_offset = s.find('β').unwrap_or(s.len());

// Remove the range up until the β from the string
let t: String = s.drain(..beta_offset).collect();
assert_eq!(t, "α is alpha, ");
assert_eq!(s, "β is beta");

// A full range clears the string
s.drain(..);
assert_eq!(s, "");</pre> </div>
<h4 id="method.into_boxed_str" class="method"><span id="into_boxed_str.v" class="invisible"><code>fn <a href="#method.into_boxed_str" class="fnname">into_boxed_str</a>(self) -&gt; <a class="struct" href="../../boxed/struct.box/" title="std::boxed::Box">Box</a>&lt;<a class="primitive" href="../../primitive.str/">str</a>&gt;</code><div class="since" title="Stable since Rust version 1.4.0">1.4.0</div></span></h4> <div class="docblock">
<p>Converts this <code>String</code> into a <code>Box&lt;str&gt;</code>.</p> <p>This will drop any excess capacity.</p> <h4 id="examples-28" class="section-header">Examples</h4> <p>Basic usage:</p> <pre class="rust rust-example-rendered" data-language="rust">
let s = String::from("hello");

let b = s.into_boxed_str();</pre> </div>
<h2 id="deref-methods">Methods from Deref&lt;Target=str&gt;</h2>
<h4 id="method.len-1" class="method"><span id="len.v-1" class="invisible"><code>fn <a href="#method.len-1" class="fnname">len</a>(&amp;self) -&gt; <a class="primitive" href="../../primitive.usize/">usize</a></code></span></h4> <div class="docblock">
<p>Returns the length of <code>self</code>.</p> <p>This length is in bytes, not <a href="../primitive.char/"><code>char</code></a>s or graphemes. In other words, it may not be what a human considers the length of the string.</p> <h4 id="examples-29" class="section-header">Examples</h4> <p>Basic usage:</p> <pre class="rust rust-example-rendered" data-language="rust">
let len = "foo".len();
assert_eq!(3, len);

let len = "ƒoo".len(); // fancy f!
assert_eq!(4, len);</pre> </div>
<h4 id="method.is_empty-1" class="method"><span id="is_empty.v-1" class="invisible"><code>fn <a href="#method.is_empty-1" class="fnname">is_empty</a>(&amp;self) -&gt; <a class="primitive" href="../../primitive.bool/">bool</a></code></span></h4> <div class="docblock">
<p>Returns true if this slice has a length of zero bytes.</p> <h4 id="examples-30" class="section-header">Examples</h4> <p>Basic usage:</p> <pre class="rust rust-example-rendered" data-language="rust">
let s = "";
assert!(s.is_empty());

let s = "not empty";
assert!(!s.is_empty());</pre> </div>
<h4 id="method.is_char_boundary" class="method"><span id="is_char_boundary.v" class="invisible"><code>fn <a href="#method.is_char_boundary" class="fnname">is_char_boundary</a>(&amp;self, index: <a class="primitive" href="../../primitive.usize/">usize</a>) -&gt; <a class="primitive" href="../../primitive.bool/">bool</a></code><div class="since" title="Stable since Rust version 1.9.0">1.9.0</div></span></h4> <div class="docblock">
<p>Checks that <code>index</code>-th byte lies at the start and/or end of a UTF-8 code point sequence.</p> <p>The start and end of the string (when <code>index == self.len()</code>) are considered to be boundaries.</p> <p>Returns <code>false</code> if <code>index</code> is greater than <code>self.len()</code>.</p> <h4 id="examples-31" class="section-header">Examples</h4> <pre class="rust rust-example-rendered" data-language="rust">
let s = "Löwe 老虎 Léopard";
assert!(s.is_char_boundary(0));
// start of `老`
assert!(s.is_char_boundary(6));
assert!(s.is_char_boundary(s.len()));

// second byte of `ö`
assert!(!s.is_char_boundary(2));

// third byte of `老`
assert!(!s.is_char_boundary(8));</pre> </div>
<h4 id="method.as_bytes-1" class="method"><span id="as_bytes.v-1" class="invisible"><code>fn <a href="#method.as_bytes-1" class="fnname">as_bytes</a>(&amp;self) -&gt; <a class="primitive" href="../../primitive.slice/">&amp;[</a><a class="primitive" href="../../primitive.u8/">u8</a><a class="primitive" href="../../primitive.slice/">]</a></code></span></h4> <div class="docblock">
<p>Converts a string slice to a byte slice.</p> <h4 id="examples-32" class="section-header">Examples</h4> <p>Basic usage:</p> <pre class="rust rust-example-rendered" data-language="rust">
let bytes = "bors".as_bytes();
assert_eq!(b"bors", bytes);</pre> </div>
<h4 id="method.as_ptr" class="method"><span id="as_ptr.v" class="invisible"><code>fn <a href="#method.as_ptr" class="fnname">as_ptr</a>(&amp;self) -&gt; <a class="primitive" href="../../primitive.pointer/">*const </a><a class="primitive" href="../../primitive.u8/">u8</a></code></span></h4> <div class="docblock">
<p>Converts a string slice to a raw pointer.</p> <p>As string slices are a slice of bytes, the raw pointer points to a <a href="../primitive.u8/"><code>u8</code></a>. This pointer will be pointing to the first byte of the string slice.</p> <h4 id="examples-33" class="section-header">Examples</h4> <p>Basic usage:</p> <pre class="rust rust-example-rendered" data-language="rust">
let s = "Hello";
let ptr = s.as_ptr();</pre> </div>
<h4 id="method.slice_unchecked" class="method"><span id="slice_unchecked.v" class="invisible"><code>unsafe fn <a href="#method.slice_unchecked" class="fnname">slice_unchecked</a>(&amp;self, begin: <a class="primitive" href="../../primitive.usize/">usize</a>, end: <a class="primitive" href="../../primitive.usize/">usize</a>) -&gt; &amp;<a class="primitive" href="../../primitive.str/">str</a></code></span></h4> <div class="docblock">
<p>Creates a string slice from another string slice, bypassing safety checks.</p> <p>This new slice goes from <code>begin</code> to <code>end</code>, including <code>begin</code> but excluding <code>end</code>.</p> <p>To get a mutable string slice instead, see the <a href="#method.slice_mut_unchecked"><code>slice_mut_unchecked()</code></a> method.</p> <h4 id="safety-3" class="section-header">Safety</h4> <p>Callers of this function are responsible that three preconditions are satisfied:</p> <ul> <li>
<code>begin</code> must come before <code>end</code>.</li> <li>
<code>begin</code> and <code>end</code> must be byte positions within the string slice.</li> <li>
<code>begin</code> and <code>end</code> must lie on UTF-8 sequence boundaries.</li> </ul> <h4 id="examples-34" class="section-header">Examples</h4> <p>Basic usage:</p> <pre class="rust rust-example-rendered" data-language="rust">
let s = "Löwe 老虎 Léopard";

unsafe {
    assert_eq!("Löwe 老虎 Léopard", s.slice_unchecked(0, 21));
}

let s = "Hello, world!";

unsafe {
    assert_eq!("world", s.slice_unchecked(7, 12));
}</pre> </div>
<h4 id="method.slice_mut_unchecked" class="method"><span id="slice_mut_unchecked.v" class="invisible"><code>unsafe fn <a href="#method.slice_mut_unchecked" class="fnname">slice_mut_unchecked</a>(&amp;mut self, begin: <a class="primitive" href="../../primitive.usize/">usize</a>, end: <a class="primitive" href="../../primitive.usize/">usize</a>) -&gt; &amp;mut <a class="primitive" href="../../primitive.str/">str</a></code><div class="since" title="Stable since Rust version 1.5.0">1.5.0</div></span></h4> <div class="docblock">
<p>Creates a string slice from another string slice, bypassing safety checks.</p> <p>This new slice goes from <code>begin</code> to <code>end</code>, including <code>begin</code> but excluding <code>end</code>.</p> <p>To get an immutable string slice instead, see the <a href="#method.slice_unchecked"><code>slice_unchecked()</code></a> method.</p> <h4 id="safety-4" class="section-header">Safety</h4> <p>Callers of this function are responsible that three preconditions are satisfied:</p> <ul> <li>
<code>begin</code> must come before <code>end</code>.</li> <li>
<code>begin</code> and <code>end</code> must be byte positions within the string slice.</li> <li>
<code>begin</code> and <code>end</code> must lie on UTF-8 sequence boundaries.</li> </ul> </div>
<h4 id="method.split_at" class="method"><span id="split_at.v" class="invisible"><code>fn <a href="#method.split_at" class="fnname">split_at</a>(&amp;self, mid: <a class="primitive" href="../../primitive.usize/">usize</a>) -&gt; <a class="primitive" href="../../primitive.tuple/">(</a>&amp;<a class="primitive" href="../../primitive.str/">str</a>, &amp;<a class="primitive" href="../../primitive.str/">str</a><a class="primitive" href="../../primitive.tuple/">)</a></code><div class="since" title="Stable since Rust version 1.4.0">1.4.0</div></span></h4> <div class="docblock">
<p>Divide one string slice into two at an index.</p> <p>The argument, <code>mid</code>, should be a byte offset from the start of the string. It must also be on the boundary of a UTF-8 code point.</p> <p>The two slices returned go from the start of the string slice to <code>mid</code>, and from <code>mid</code> to the end of the string slice.</p> <p>To get mutable string slices instead, see the <a href="#method.split_at_mut"><code>split_at_mut()</code></a> method.</p> <h4 id="panics-8" class="section-header">Panics</h4> <p>Panics if <code>mid</code> is not on a UTF-8 code point boundary, or if it is beyond the last code point of the string slice.</p> <h4 id="examples-35" class="section-header">Examples</h4> <p>Basic usage:</p> <pre class="rust rust-example-rendered" data-language="rust">
let s = "Per Martin-Löf";

let (first, last) = s.split_at(3);

assert_eq!("Per", first);
assert_eq!(" Martin-Löf", last);</pre> </div>
<h4 id="method.split_at_mut" class="method"><span id="split_at_mut.v" class="invisible"><code>fn <a href="#method.split_at_mut" class="fnname">split_at_mut</a>(&amp;mut self, mid: <a class="primitive" href="../../primitive.usize/">usize</a>) -&gt; <a class="primitive" href="../../primitive.tuple/">(</a>&amp;mut <a class="primitive" href="../../primitive.str/">str</a>, &amp;mut <a class="primitive" href="../../primitive.str/">str</a><a class="primitive" href="../../primitive.tuple/">)</a></code><div class="since" title="Stable since Rust version 1.4.0">1.4.0</div></span></h4> <div class="docblock">
<p>Divide one mutable string slice into two at an index.</p> <p>The argument, <code>mid</code>, should be a byte offset from the start of the string. It must also be on the boundary of a UTF-8 code point.</p> <p>The two slices returned go from the start of the string slice to <code>mid</code>, and from <code>mid</code> to the end of the string slice.</p> <p>To get immutable string slices instead, see the <a href="#method.split_at"><code>split_at()</code></a> method.</p> <h4 id="panics-9" class="section-header">Panics</h4> <p>Panics if <code>mid</code> is not on a UTF-8 code point boundary, or if it is beyond the last code point of the string slice.</p> <h4 id="examples-36" class="section-header">Examples</h4> <p>Basic usage:</p> <pre class="rust rust-example-rendered" data-language="rust">
let mut s = "Per Martin-Löf".to_string();

let (first, last) = s.split_at_mut(3);

assert_eq!("Per", first);
assert_eq!(" Martin-Löf", last);</pre> </div>
<h4 id="method.chars" class="method"><span id="chars.v" class="invisible"><code>fn <a href="#method.chars" class="fnname">chars</a>(&amp;self) -&gt; <a class="struct" href="../../str/struct.chars/" title="std::str::Chars">Chars</a></code></span></h4> <div class="docblock">
<p>Returns an iterator over the <code>char</code>s of a string slice.</p> <p>As a string slice consists of valid UTF-8, we can iterate through a string slice by <a href="../primitive.char/"><code>char</code></a>. This method returns such an iterator.</p> <p>It's important to remember that <a href="../primitive.char/"><code>char</code></a> represents a Unicode Scalar Value, and may not match your idea of what a 'character' is. Iteration over grapheme clusters may be what you actually want.</p> <h4 id="examples-37" class="section-header">Examples</h4> <p>Basic usage:</p> <pre class="rust rust-example-rendered" data-language="rust">
let word = "goodbye";

let count = word.chars().count();
assert_eq!(7, count);

let mut chars = word.chars();

assert_eq!(Some('g'), chars.next());
assert_eq!(Some('o'), chars.next());
assert_eq!(Some('o'), chars.next());
assert_eq!(Some('d'), chars.next());
assert_eq!(Some('b'), chars.next());
assert_eq!(Some('y'), chars.next());
assert_eq!(Some('e'), chars.next());

assert_eq!(None, chars.next());</pre> <p>Remember, <a href="../primitive.char/"><code>char</code></a>s may not match your human intuition about characters:</p> <pre class="rust rust-example-rendered" data-language="rust">
let y = "y̆";

let mut chars = y.chars();

assert_eq!(Some('y'), chars.next()); // not 'y̆'
assert_eq!(Some('\u{0306}'), chars.next());

assert_eq!(None, chars.next());</pre> </div>
<h4 id="method.char_indices" class="method"><span id="char_indices.v" class="invisible"><code>fn <a href="#method.char_indices" class="fnname">char_indices</a>(&amp;self) -&gt; <a class="struct" href="../../str/struct.charindices/" title="std::str::CharIndices">CharIndices</a></code></span></h4> <div class="docblock">
<p>Returns an iterator over the <a href="../primitive.char/"><code>char</code></a>s of a string slice, and their positions.</p> <p>As a string slice consists of valid UTF-8, we can iterate through a string slice by <a href="../primitive.char/"><code>char</code></a>. This method returns an iterator of both these <a href="../primitive.char/"><code>char</code></a>s, as well as their byte positions.</p> <p>The iterator yields tuples. The position is first, the <a href="../primitive.char/"><code>char</code></a> is second.</p> <h4 id="examples-38" class="section-header">Examples</h4> <p>Basic usage:</p> <pre class="rust rust-example-rendered" data-language="rust">
let word = "goodbye";

let count = word.char_indices().count();
assert_eq!(7, count);

let mut char_indices = word.char_indices();

assert_eq!(Some((0, 'g')), char_indices.next());
assert_eq!(Some((1, 'o')), char_indices.next());
assert_eq!(Some((2, 'o')), char_indices.next());
assert_eq!(Some((3, 'd')), char_indices.next());
assert_eq!(Some((4, 'b')), char_indices.next());
assert_eq!(Some((5, 'y')), char_indices.next());
assert_eq!(Some((6, 'e')), char_indices.next());

assert_eq!(None, char_indices.next());</pre> <p>Remember, <a href="../primitive.char/"><code>char</code></a>s may not match your human intuition about characters:</p> <pre class="rust rust-example-rendered" data-language="rust">
let y = "y̆";

let mut char_indices = y.char_indices();

assert_eq!(Some((0, 'y')), char_indices.next()); // not (0, 'y̆')
assert_eq!(Some((1, '\u{0306}')), char_indices.next());

assert_eq!(None, char_indices.next());</pre> </div>
<h4 id="method.bytes" class="method"><span id="bytes.v" class="invisible"><code>fn <a href="#method.bytes" class="fnname">bytes</a>(&amp;self) -&gt; <a class="struct" href="../../str/struct.bytes/" title="std::str::Bytes">Bytes</a></code></span></h4> <div class="docblock">
<p>An iterator over the bytes of a string slice.</p> <p>As a string slice consists of a sequence of bytes, we can iterate through a string slice by byte. This method returns such an iterator.</p> <h4 id="examples-39" class="section-header">Examples</h4> <p>Basic usage:</p> <pre class="rust rust-example-rendered" data-language="rust">
let mut bytes = "bors".bytes();

assert_eq!(Some(b'b'), bytes.next());
assert_eq!(Some(b'o'), bytes.next());
assert_eq!(Some(b'r'), bytes.next());
assert_eq!(Some(b's'), bytes.next());

assert_eq!(None, bytes.next());</pre> </div>
<h4 id="method.split_whitespace" class="method"><span id="split_whitespace.v" class="invisible"><code>fn <a href="#method.split_whitespace" class="fnname">split_whitespace</a>(&amp;self) -&gt; <a class="struct" href="../../str/struct.splitwhitespace/" title="std::str::SplitWhitespace">SplitWhitespace</a></code><div class="since" title="Stable since Rust version 1.1.0">1.1.0</div></span></h4> <div class="docblock">
<p>Split a string slice by whitespace.</p> <p>The iterator returned will return string slices that are sub-slices of the original string slice, separated by any amount of whitespace.</p> <p>'Whitespace' is defined according to the terms of the Unicode Derived Core Property <code>White_Space</code>.</p> <h4 id="examples-40" class="section-header">Examples</h4> <p>Basic usage:</p> <pre class="rust rust-example-rendered" data-language="rust">
let mut iter = "A few words".split_whitespace();

assert_eq!(Some("A"), iter.next());
assert_eq!(Some("few"), iter.next());
assert_eq!(Some("words"), iter.next());

assert_eq!(None, iter.next());</pre> <p>All kinds of whitespace are considered:</p> <pre class="rust rust-example-rendered" data-language="rust">
let mut iter = " Mary   had\ta\u{2009}little  \n\t lamb".split_whitespace();
assert_eq!(Some("Mary"), iter.next());
assert_eq!(Some("had"), iter.next());
assert_eq!(Some("a"), iter.next());
assert_eq!(Some("little"), iter.next());
assert_eq!(Some("lamb"), iter.next());

assert_eq!(None, iter.next());</pre> </div>
<h4 id="method.lines" class="method"><span id="lines.v" class="invisible"><code>fn <a href="#method.lines" class="fnname">lines</a>(&amp;self) -&gt; <a class="struct" href="../../str/struct.lines/" title="std::str::Lines">Lines</a></code></span></h4> <div class="docblock">
<p>An iterator over the lines of a string, as string slices.</p> <p>Lines are ended with either a newline (<code>\n</code>) or a carriage return with a line feed (<code>\r\n</code>).</p> <p>The final line ending is optional.</p> <h4 id="examples-41" class="section-header">Examples</h4> <p>Basic usage:</p> <pre class="rust rust-example-rendered" data-language="rust">
let text = "foo\r\nbar\n\nbaz\n";
let mut lines = text.lines();

assert_eq!(Some("foo"), lines.next());
assert_eq!(Some("bar"), lines.next());
assert_eq!(Some(""), lines.next());
assert_eq!(Some("baz"), lines.next());

assert_eq!(None, lines.next());</pre> <p>The final line ending isn't required:</p> <pre class="rust rust-example-rendered" data-language="rust">
let text = "foo\nbar\n\r\nbaz";
let mut lines = text.lines();

assert_eq!(Some("foo"), lines.next());
assert_eq!(Some("bar"), lines.next());
assert_eq!(Some(""), lines.next());
assert_eq!(Some("baz"), lines.next());

assert_eq!(None, lines.next());</pre> </div>
<h4 id="method.lines_any" class="method"><span id="lines_any.v" class="invisible"><code>fn <a href="#method.lines_any" class="fnname">lines_any</a>(&amp;self) -&gt; <a class="struct" href="../../str/struct.linesany/" title="std::str::LinesAny">LinesAny</a></code></span></h4> <div class="stability"><span class="stab deprecated">Deprecated since 1.4.0: use lines() instead now </span></div>
<div class="docblock">
<p>An iterator over the lines of a string.</p> </div>
<h4 id="method.encode_utf16" class="method"><span id="encode_utf16.v" class="invisible"><code>fn <a href="#method.encode_utf16" class="fnname">encode_utf16</a>(&amp;self) -&gt; <a class="struct" href="../../str/struct.encodeutf16/" title="std::str::EncodeUtf16">EncodeUtf16</a></code><div class="since" title="Stable since Rust version 1.8.0">1.8.0</div></span></h4> <div class="docblock">
<p>Returns an iterator of <code>u16</code> over the string encoded as UTF-16.</p> </div>
<h4 id="method.contains" class="method"><span id="contains.v" class="invisible"><code>fn <a href="#method.contains" class="fnname">contains</a>&lt;'a, P&gt;(&amp;'a self, pat: P) -&gt; <a class="primitive" href="../../primitive.bool/">bool</a> <span class="where fmt-newline">where P: <a class="trait" href="../../str/pattern/trait.pattern/" title="std::str::pattern::Pattern">Pattern</a>&lt;'a&gt;</span></code></span></h4> <div class="docblock">
<p>Returns <code>true</code> if the given pattern matches a sub-slice of this string slice.</p> <p>Returns <code>false</code> if it does not.</p> <h4 id="examples-42" class="section-header">Examples</h4> <p>Basic usage:</p> <pre class="rust rust-example-rendered" data-language="rust">
let bananas = "bananas";

assert!(bananas.contains("nana"));
assert!(!bananas.contains("apples"));</pre> </div>
<h4 id="method.starts_with" class="method"><span id="starts_with.v" class="invisible"><code>fn <a href="#method.starts_with" class="fnname">starts_with</a>&lt;'a, P&gt;(&amp;'a self, pat: P) -&gt; <a class="primitive" href="../../primitive.bool/">bool</a> <span class="where fmt-newline">where P: <a class="trait" href="../../str/pattern/trait.pattern/" title="std::str::pattern::Pattern">Pattern</a>&lt;'a&gt;</span></code></span></h4> <div class="docblock">
<p>Returns <code>true</code> if the given pattern matches a prefix of this string slice.</p> <p>Returns <code>false</code> if it does not.</p> <h4 id="examples-43" class="section-header">Examples</h4> <p>Basic usage:</p> <pre class="rust rust-example-rendered" data-language="rust">
let bananas = "bananas";

assert!(bananas.starts_with("bana"));
assert!(!bananas.starts_with("nana"));</pre> </div>
<h4 id="method.ends_with" class="method"><span id="ends_with.v" class="invisible"><code>fn <a href="#method.ends_with" class="fnname">ends_with</a>&lt;'a, P&gt;(&amp;'a self, pat: P) -&gt; <a class="primitive" href="../../primitive.bool/">bool</a> <span class="where fmt-newline">where P: <a class="trait" href="../../str/pattern/trait.pattern/" title="std::str::pattern::Pattern">Pattern</a>&lt;'a&gt;, P::<a class="trait" href="../../str/pattern/trait.pattern/" title="std::str::pattern::Pattern">Searcher</a>: <a class="trait" href="../../str/pattern/trait.reversesearcher/" title="std::str::pattern::ReverseSearcher">ReverseSearcher</a>&lt;'a&gt;</span></code></span></h4> <div class="docblock">
<p>Returns <code>true</code> if the given pattern matches a suffix of this string slice.</p> <p>Returns <code>false</code> if it does not.</p> <h4 id="examples-44" class="section-header">Examples</h4> <p>Basic usage:</p> <pre class="rust rust-example-rendered" data-language="rust">
let bananas = "bananas";

assert!(bananas.ends_with("anas"));
assert!(!bananas.ends_with("nana"));</pre> </div>
<h4 id="method.find" class="method"><span id="find.v" class="invisible"><code>fn <a href="#method.find" class="fnname">find</a>&lt;'a, P&gt;(&amp;'a self, pat: P) -&gt; <a class="enum" href="../../option/enum.option/" title="std::option::Option">Option</a>&lt;<a class="primitive" href="../../primitive.usize/">usize</a>&gt; <span class="where fmt-newline">where P: <a class="trait" href="../../str/pattern/trait.pattern/" title="std::str::pattern::Pattern">Pattern</a>&lt;'a&gt;</span></code></span></h4> <div class="docblock">
<p>Returns the byte index of the first character of this string slice that matches the pattern.</p> <p>Returns <a href="../option/enum.option/#variant.None"><code>None</code></a> if the pattern doesn't match.</p> <p>The pattern can be a <code>&amp;str</code>, <a href="../primitive.char/"><code>char</code></a>, or a closure that determines if a character matches.</p> <h4 id="examples-45" class="section-header">Examples</h4> <p>Simple patterns:</p> <pre class="rust rust-example-rendered" data-language="rust">
let s = "Löwe 老虎 Léopard";

assert_eq!(s.find('L'), Some(0));
assert_eq!(s.find('é'), Some(14));
assert_eq!(s.find("Léopard"), Some(13));</pre> <p>More complex patterns with closures:</p> <pre class="rust rust-example-rendered" data-language="rust">
let s = "Löwe 老虎 Léopard";

assert_eq!(s.find(char::is_whitespace), Some(5));
assert_eq!(s.find(char::is_lowercase), Some(1));</pre> <p>Not finding the pattern:</p> <pre class="rust rust-example-rendered" data-language="rust">
let s = "Löwe 老虎 Léopard";
let x: &amp;[_] = &amp;['1', '2'];

assert_eq!(s.find(x), None);</pre> </div>
<h4 id="method.rfind" class="method"><span id="rfind.v" class="invisible"><code>fn <a href="#method.rfind" class="fnname">rfind</a>&lt;'a, P&gt;(&amp;'a self, pat: P) -&gt; <a class="enum" href="../../option/enum.option/" title="std::option::Option">Option</a>&lt;<a class="primitive" href="../../primitive.usize/">usize</a>&gt; <span class="where fmt-newline">where P: <a class="trait" href="../../str/pattern/trait.pattern/" title="std::str::pattern::Pattern">Pattern</a>&lt;'a&gt;, P::<a class="trait" href="../../str/pattern/trait.pattern/" title="std::str::pattern::Pattern">Searcher</a>: <a class="trait" href="../../str/pattern/trait.reversesearcher/" title="std::str::pattern::ReverseSearcher">ReverseSearcher</a>&lt;'a&gt;</span></code></span></h4> <div class="docblock">
<p>Returns the byte index of the last character of this string slice that matches the pattern.</p> <p>Returns <a href="../option/enum.option/#variant.None"><code>None</code></a> if the pattern doesn't match.</p> <p>The pattern can be a <code>&amp;str</code>, <a href="../primitive.char/"><code>char</code></a>, or a closure that determines if a character matches.</p> <h4 id="examples-46" class="section-header">Examples</h4> <p>Simple patterns:</p> <pre class="rust rust-example-rendered" data-language="rust">
let s = "Löwe 老虎 Léopard";

assert_eq!(s.rfind('L'), Some(13));
assert_eq!(s.rfind('é'), Some(14));</pre> <p>More complex patterns with closures:</p> <pre class="rust rust-example-rendered" data-language="rust">
let s = "Löwe 老虎 Léopard";

assert_eq!(s.rfind(char::is_whitespace), Some(12));
assert_eq!(s.rfind(char::is_lowercase), Some(20));</pre> <p>Not finding the pattern:</p> <pre class="rust rust-example-rendered" data-language="rust">
let s = "Löwe 老虎 Léopard";
let x: &amp;[_] = &amp;['1', '2'];

assert_eq!(s.rfind(x), None);</pre> </div>
<h4 id="method.split" class="method"><span id="split.v" class="invisible"><code>fn <a href="#method.split" class="fnname">split</a>&lt;'a, P&gt;(&amp;'a self, pat: P) -&gt; <a class="struct" href="../../str/struct.split/" title="std::str::Split">Split</a>&lt;'a, P&gt; <span class="where fmt-newline">where P: <a class="trait" href="../../str/pattern/trait.pattern/" title="std::str::pattern::Pattern">Pattern</a>&lt;'a&gt;</span></code></span></h4> <div class="docblock">
<p>An iterator over substrings of this string slice, separated by characters matched by a pattern.</p> <p>The pattern can be a <code>&amp;str</code>, <a href="../primitive.char/"><code>char</code></a>, or a closure that determines the split.</p> <h4 id="iterator-behavior" class="section-header">Iterator behavior</h4> <p>The returned iterator will be a <a href="../iter/trait.doubleendediterator/"><code>DoubleEndedIterator</code></a> if the pattern allows a reverse search and forward/reverse search yields the same elements. This is true for, eg, <a href="../primitive.char/"><code>char</code></a> but not for <code>&amp;str</code>.</p> <p>If the pattern allows a reverse search but its results might differ from a forward search, the <a href="#method.rsplit"><code>rsplit()</code></a> method can be used.</p> <h4 id="examples-47" class="section-header">Examples</h4> <p>Simple patterns:</p> <pre class="rust rust-example-rendered" data-language="rust">
let v: Vec&lt;&amp;str&gt; = "Mary had a little lamb".split(' ').collect();
assert_eq!(v, ["Mary", "had", "a", "little", "lamb"]);

let v: Vec&lt;&amp;str&gt; = "".split('X').collect();
assert_eq!(v, [""]);

let v: Vec&lt;&amp;str&gt; = "lionXXtigerXleopard".split('X').collect();
assert_eq!(v, ["lion", "", "tiger", "leopard"]);

let v: Vec&lt;&amp;str&gt; = "lion::tiger::leopard".split("::").collect();
assert_eq!(v, ["lion", "tiger", "leopard"]);

let v: Vec&lt;&amp;str&gt; = "abc1def2ghi".split(char::is_numeric).collect();
assert_eq!(v, ["abc", "def", "ghi"]);

let v: Vec&lt;&amp;str&gt; = "lionXtigerXleopard".split(char::is_uppercase).collect();
assert_eq!(v, ["lion", "tiger", "leopard"]);</pre> <p>A more complex pattern, using a closure:</p> <pre class="rust rust-example-rendered" data-language="rust">
let v: Vec&lt;&amp;str&gt; = "abc1defXghi".split(|c| c == '1' || c == 'X').collect();
assert_eq!(v, ["abc", "def", "ghi"]);</pre> <p>If a string contains multiple contiguous separators, you will end up with empty strings in the output:</p> <pre class="rust rust-example-rendered" data-language="rust">
let x = "||||a||b|c".to_string();
let d: Vec&lt;_&gt; = x.split('|').collect();

assert_eq!(d, &amp;["", "", "", "", "a", "", "b", "c"]);</pre> <p>Contiguous separators are separated by the empty string.</p> <pre class="rust rust-example-rendered" data-language="rust">
let x = "(///)".to_string();
let d: Vec&lt;_&gt; = x.split('/').collect();;

assert_eq!(d, &amp;["(", "", "", ")"]);</pre> <p>Separators at the start or end of a string are neighbored by empty strings.</p> <pre class="rust rust-example-rendered" data-language="rust">
let d: Vec&lt;_&gt; = "010".split("0").collect();
assert_eq!(d, &amp;["", "1", ""]);</pre> <p>When the empty string is used as a separator, it separates every character in the string, along with the beginning and end of the string.</p> <pre class="rust rust-example-rendered" data-language="rust">
let f: Vec&lt;_&gt; = "rust".split("").collect();
assert_eq!(f, &amp;["", "r", "u", "s", "t", ""]);</pre> <p>Contiguous separators can lead to possibly surprising behavior when whitespace is used as the separator. This code is correct:</p> <pre class="rust rust-example-rendered" data-language="rust">
let x = "    a  b c".to_string();
let d: Vec&lt;_&gt; = x.split(' ').collect();

assert_eq!(d, &amp;["", "", "", "", "a", "", "b", "c"]);</pre> <p>It does <em>not</em> give you:</p> <pre class="rust rust-example-rendered" data-language="rust">
assert_eq!(d, &amp;["a", "b", "c"]);</pre> <p>Use <a href="#method.split_whitespace"><code>split_whitespace()</code></a> for this behavior.</p> </div>
<h4 id="method.rsplit" class="method"><span id="rsplit.v" class="invisible"><code>fn <a href="#method.rsplit" class="fnname">rsplit</a>&lt;'a, P&gt;(&amp;'a self, pat: P) -&gt; <a class="struct" href="../../str/struct.rsplit/" title="std::str::RSplit">RSplit</a>&lt;'a, P&gt; <span class="where fmt-newline">where P: <a class="trait" href="../../str/pattern/trait.pattern/" title="std::str::pattern::Pattern">Pattern</a>&lt;'a&gt;, P::<a class="trait" href="../../str/pattern/trait.pattern/" title="std::str::pattern::Pattern">Searcher</a>: <a class="trait" href="../../str/pattern/trait.reversesearcher/" title="std::str::pattern::ReverseSearcher">ReverseSearcher</a>&lt;'a&gt;</span></code></span></h4> <div class="docblock">
<p>An iterator over substrings of the given string slice, separated by characters matched by a pattern and yielded in reverse order.</p> <p>The pattern can be a <code>&amp;str</code>, <a href="../primitive.char/"><code>char</code></a>, or a closure that determines the split.</p> <h4 id="iterator-behavior-1" class="section-header">Iterator behavior</h4> <p>The returned iterator requires that the pattern supports a reverse search, and it will be a <a href="../iter/trait.doubleendediterator/"><code>DoubleEndedIterator</code></a> if a forward/reverse search yields the same elements.</p> <p>For iterating from the front, the <a href="#method.split"><code>split()</code></a> method can be used.</p> <h4 id="examples-48" class="section-header">Examples</h4> <p>Simple patterns:</p> <pre class="rust rust-example-rendered" data-language="rust">
let v: Vec&lt;&amp;str&gt; = "Mary had a little lamb".rsplit(' ').collect();
assert_eq!(v, ["lamb", "little", "a", "had", "Mary"]);

let v: Vec&lt;&amp;str&gt; = "".rsplit('X').collect();
assert_eq!(v, [""]);

let v: Vec&lt;&amp;str&gt; = "lionXXtigerXleopard".rsplit('X').collect();
assert_eq!(v, ["leopard", "tiger", "", "lion"]);

let v: Vec&lt;&amp;str&gt; = "lion::tiger::leopard".rsplit("::").collect();
assert_eq!(v, ["leopard", "tiger", "lion"]);</pre> <p>A more complex pattern, using a closure:</p> <pre class="rust rust-example-rendered" data-language="rust">
let v: Vec&lt;&amp;str&gt; = "abc1defXghi".rsplit(|c| c == '1' || c == 'X').collect();
assert_eq!(v, ["ghi", "def", "abc"]);</pre> </div>
<h4 id="method.split_terminator" class="method"><span id="split_terminator.v" class="invisible"><code>fn <a href="#method.split_terminator" class="fnname">split_terminator</a>&lt;'a, P&gt;(&amp;'a self, pat: P) -&gt; <a class="struct" href="../../str/struct.splitterminator/" title="std::str::SplitTerminator">SplitTerminator</a>&lt;'a, P&gt; <span class="where fmt-newline">where P: <a class="trait" href="../../str/pattern/trait.pattern/" title="std::str::pattern::Pattern">Pattern</a>&lt;'a&gt;</span></code></span></h4> <div class="docblock">
<p>An iterator over substrings of the given string slice, separated by characters matched by a pattern.</p> <p>The pattern can be a <code>&amp;str</code>, <a href="../primitive.char/"><code>char</code></a>, or a closure that determines the split.</p> <p>Equivalent to <a href="#method.split"><code>split()</code></a>, except that the trailing substring is skipped if empty.</p> <p>This method can be used for string data that is <em>terminated</em>, rather than <em>separated</em> by a pattern.</p> <h4 id="iterator-behavior-2" class="section-header">Iterator behavior</h4> <p>The returned iterator will be a <a href="../iter/trait.doubleendediterator/"><code>DoubleEndedIterator</code></a> if the pattern allows a reverse search and forward/reverse search yields the same elements. This is true for, eg, <a href="../primitive.char/"><code>char</code></a> but not for <code>&amp;str</code>.</p> <p>If the pattern allows a reverse search but its results might differ from a forward search, the <a href="#method.rsplit_terminator"><code>rsplit_terminator()</code></a> method can be used.</p> <h4 id="examples-49" class="section-header">Examples</h4> <p>Basic usage:</p> <pre class="rust rust-example-rendered" data-language="rust">
let v: Vec&lt;&amp;str&gt; = "A.B.".split_terminator('.').collect();
assert_eq!(v, ["A", "B"]);

let v: Vec&lt;&amp;str&gt; = "A..B..".split_terminator(".").collect();
assert_eq!(v, ["A", "", "B", ""]);</pre> </div>
<h4 id="method.rsplit_terminator" class="method"><span id="rsplit_terminator.v" class="invisible"><code>fn <a href="#method.rsplit_terminator" class="fnname">rsplit_terminator</a>&lt;'a, P&gt;(&amp;'a self, pat: P) -&gt; <a class="struct" href="../../str/struct.rsplitterminator/" title="std::str::RSplitTerminator">RSplitTerminator</a>&lt;'a, P&gt; <span class="where fmt-newline">where P: <a class="trait" href="../../str/pattern/trait.pattern/" title="std::str::pattern::Pattern">Pattern</a>&lt;'a&gt;, P::<a class="trait" href="../../str/pattern/trait.pattern/" title="std::str::pattern::Pattern">Searcher</a>: <a class="trait" href="../../str/pattern/trait.reversesearcher/" title="std::str::pattern::ReverseSearcher">ReverseSearcher</a>&lt;'a&gt;</span></code></span></h4> <div class="docblock">
<p>An iterator over substrings of <code>self</code>, separated by characters matched by a pattern and yielded in reverse order.</p> <p>The pattern can be a simple <code>&amp;str</code>, <a href="../primitive.char/"><code>char</code></a>, or a closure that determines the split. Additional libraries might provide more complex patterns like regular expressions.</p> <p>Equivalent to <a href="#method.split"><code>split()</code></a>, except that the trailing substring is skipped if empty.</p> <p>This method can be used for string data that is <em>terminated</em>, rather than <em>separated</em> by a pattern.</p> <h4 id="iterator-behavior-3" class="section-header">Iterator behavior</h4> <p>The returned iterator requires that the pattern supports a reverse search, and it will be double ended if a forward/reverse search yields the same elements.</p> <p>For iterating from the front, the <a href="#method.split_terminator"><code>split_terminator()</code></a> method can be used.</p> <h4 id="examples-50" class="section-header">Examples</h4> <pre class="rust rust-example-rendered" data-language="rust">
let v: Vec&lt;&amp;str&gt; = "A.B.".rsplit_terminator('.').collect();
assert_eq!(v, ["B", "A"]);

let v: Vec&lt;&amp;str&gt; = "A..B..".rsplit_terminator(".").collect();
assert_eq!(v, ["", "B", "", "A"]);</pre> </div>
<h4 id="method.splitn" class="method"><span id="splitn.v" class="invisible"><code>fn <a href="#method.splitn" class="fnname">splitn</a>&lt;'a, P&gt;(&amp;'a self, n: <a class="primitive" href="../../primitive.usize/">usize</a>, pat: P) -&gt; <a class="struct" href="../../str/struct.splitn/" title="std::str::SplitN">SplitN</a>&lt;'a, P&gt; <span class="where fmt-newline">where P: <a class="trait" href="../../str/pattern/trait.pattern/" title="std::str::pattern::Pattern">Pattern</a>&lt;'a&gt;</span></code></span></h4> <div class="docblock">
<p>An iterator over substrings of the given string slice, separated by a pattern, restricted to returning at most <code>n</code> items.</p> <p>If <code>n</code> substrings are returned, the last substring (the <code>n</code>th substring) will contain the remainder of the string.</p> <p>The pattern can be a <code>&amp;str</code>, <a href="../primitive.char/"><code>char</code></a>, or a closure that determines the split.</p> <h4 id="iterator-behavior-4" class="section-header">Iterator behavior</h4> <p>The returned iterator will not be double ended, because it is not efficient to support.</p> <p>If the pattern allows a reverse search, the <a href="#method.rsplitn"><code>rsplitn()</code></a> method can be used.</p> <h4 id="examples-51" class="section-header">Examples</h4> <p>Simple patterns:</p> <pre class="rust rust-example-rendered" data-language="rust">
let v: Vec&lt;&amp;str&gt; = "Mary had a little lambda".splitn(3, ' ').collect();
assert_eq!(v, ["Mary", "had", "a little lambda"]);

let v: Vec&lt;&amp;str&gt; = "lionXXtigerXleopard".splitn(3, "X").collect();
assert_eq!(v, ["lion", "", "tigerXleopard"]);

let v: Vec&lt;&amp;str&gt; = "abcXdef".splitn(1, 'X').collect();
assert_eq!(v, ["abcXdef"]);

let v: Vec&lt;&amp;str&gt; = "".splitn(1, 'X').collect();
assert_eq!(v, [""]);</pre> <p>A more complex pattern, using a closure:</p> <pre class="rust rust-example-rendered" data-language="rust">
let v: Vec&lt;&amp;str&gt; = "abc1defXghi".splitn(2, |c| c == '1' || c == 'X').collect();
assert_eq!(v, ["abc", "defXghi"]);</pre> </div>
<h4 id="method.rsplitn" class="method"><span id="rsplitn.v" class="invisible"><code>fn <a href="#method.rsplitn" class="fnname">rsplitn</a>&lt;'a, P&gt;(&amp;'a self, n: <a class="primitive" href="../../primitive.usize/">usize</a>, pat: P) -&gt; <a class="struct" href="../../str/struct.rsplitn/" title="std::str::RSplitN">RSplitN</a>&lt;'a, P&gt; <span class="where fmt-newline">where P: <a class="trait" href="../../str/pattern/trait.pattern/" title="std::str::pattern::Pattern">Pattern</a>&lt;'a&gt;, P::<a class="trait" href="../../str/pattern/trait.pattern/" title="std::str::pattern::Pattern">Searcher</a>: <a class="trait" href="../../str/pattern/trait.reversesearcher/" title="std::str::pattern::ReverseSearcher">ReverseSearcher</a>&lt;'a&gt;</span></code></span></h4> <div class="docblock">
<p>An iterator over substrings of this string slice, separated by a pattern, starting from the end of the string, restricted to returning at most <code>n</code> items.</p> <p>If <code>n</code> substrings are returned, the last substring (the <code>n</code>th substring) will contain the remainder of the string.</p> <p>The pattern can be a <code>&amp;str</code>, <a href="../primitive.char/"><code>char</code></a>, or a closure that determines the split.</p> <h4 id="iterator-behavior-5" class="section-header">Iterator behavior</h4> <p>The returned iterator will not be double ended, because it is not efficient to support.</p> <p>For splitting from the front, the <a href="#method.splitn"><code>splitn()</code></a> method can be used.</p> <h4 id="examples-52" class="section-header">Examples</h4> <p>Simple patterns:</p> <pre class="rust rust-example-rendered" data-language="rust">
let v: Vec&lt;&amp;str&gt; = "Mary had a little lamb".rsplitn(3, ' ').collect();
assert_eq!(v, ["lamb", "little", "Mary had a"]);

let v: Vec&lt;&amp;str&gt; = "lionXXtigerXleopard".rsplitn(3, 'X').collect();
assert_eq!(v, ["leopard", "tiger", "lionX"]);

let v: Vec&lt;&amp;str&gt; = "lion::tiger::leopard".rsplitn(2, "::").collect();
assert_eq!(v, ["leopard", "lion::tiger"]);</pre> <p>A more complex pattern, using a closure:</p> <pre class="rust rust-example-rendered" data-language="rust">
let v: Vec&lt;&amp;str&gt; = "abc1defXghi".rsplitn(2, |c| c == '1' || c == 'X').collect();
assert_eq!(v, ["ghi", "abc1def"]);</pre> </div>
<h4 id="method.matches" class="method"><span id="matches.v" class="invisible"><code>fn <a href="#method.matches" class="fnname">matches</a>&lt;'a, P&gt;(&amp;'a self, pat: P) -&gt; <a class="struct" href="../../str/struct.matches/" title="std::str::Matches">Matches</a>&lt;'a, P&gt; <span class="where fmt-newline">where P: <a class="trait" href="../../str/pattern/trait.pattern/" title="std::str::pattern::Pattern">Pattern</a>&lt;'a&gt;</span></code><div class="since" title="Stable since Rust version 1.2.0">1.2.0</div></span></h4> <div class="docblock">
<p>An iterator over the matches of a pattern within the given string slice.</p> <p>The pattern can be a <code>&amp;str</code>, <a href="../primitive.char/"><code>char</code></a>, or a closure that determines if a character matches.</p> <h4 id="iterator-behavior-6" class="section-header">Iterator behavior</h4> <p>The returned iterator will be a <a href="../iter/trait.doubleendediterator/"><code>DoubleEndedIterator</code></a> if the pattern allows a reverse search and forward/reverse search yields the same elements. This is true for, eg, <a href="../primitive.char/"><code>char</code></a> but not for <code>&amp;str</code>.</p> <p>If the pattern allows a reverse search but its results might differ from a forward search, the <a href="#method.rmatches"><code>rmatches()</code></a> method can be used.</p> <h4 id="examples-53" class="section-header">Examples</h4> <p>Basic usage:</p> <pre class="rust rust-example-rendered" data-language="rust">
let v: Vec&lt;&amp;str&gt; = "abcXXXabcYYYabc".matches("abc").collect();
assert_eq!(v, ["abc", "abc", "abc"]);

let v: Vec&lt;&amp;str&gt; = "1abc2abc3".matches(char::is_numeric).collect();
assert_eq!(v, ["1", "2", "3"]);</pre> </div>
<h4 id="method.rmatches" class="method"><span id="rmatches.v" class="invisible"><code>fn <a href="#method.rmatches" class="fnname">rmatches</a>&lt;'a, P&gt;(&amp;'a self, pat: P) -&gt; <a class="struct" href="../../str/struct.rmatches/" title="std::str::RMatches">RMatches</a>&lt;'a, P&gt; <span class="where fmt-newline">where P: <a class="trait" href="../../str/pattern/trait.pattern/" title="std::str::pattern::Pattern">Pattern</a>&lt;'a&gt;, P::<a class="trait" href="../../str/pattern/trait.pattern/" title="std::str::pattern::Pattern">Searcher</a>: <a class="trait" href="../../str/pattern/trait.reversesearcher/" title="std::str::pattern::ReverseSearcher">ReverseSearcher</a>&lt;'a&gt;</span></code><div class="since" title="Stable since Rust version 1.2.0">1.2.0</div></span></h4> <div class="docblock">
<p>An iterator over the matches of a pattern within this string slice, yielded in reverse order.</p> <p>The pattern can be a <code>&amp;str</code>, <a href="../primitive.char/"><code>char</code></a>, or a closure that determines if a character matches.</p> <h4 id="iterator-behavior-7" class="section-header">Iterator behavior</h4> <p>The returned iterator requires that the pattern supports a reverse search, and it will be a <a href="../iter/trait.doubleendediterator/"><code>DoubleEndedIterator</code></a> if a forward/reverse search yields the same elements.</p> <p>For iterating from the front, the <a href="#method.matches"><code>matches()</code></a> method can be used.</p> <h4 id="examples-54" class="section-header">Examples</h4> <p>Basic usage:</p> <pre class="rust rust-example-rendered" data-language="rust">
let v: Vec&lt;&amp;str&gt; = "abcXXXabcYYYabc".rmatches("abc").collect();
assert_eq!(v, ["abc", "abc", "abc"]);

let v: Vec&lt;&amp;str&gt; = "1abc2abc3".rmatches(char::is_numeric).collect();
assert_eq!(v, ["3", "2", "1"]);</pre> </div>
<h4 id="method.match_indices" class="method"><span id="match_indices.v" class="invisible"><code>fn <a href="#method.match_indices" class="fnname">match_indices</a>&lt;'a, P&gt;(&amp;'a self, pat: P) -&gt; <a class="struct" href="../../str/struct.matchindices/" title="std::str::MatchIndices">MatchIndices</a>&lt;'a, P&gt; <span class="where fmt-newline">where P: <a class="trait" href="../../str/pattern/trait.pattern/" title="std::str::pattern::Pattern">Pattern</a>&lt;'a&gt;</span></code><div class="since" title="Stable since Rust version 1.5.0">1.5.0</div></span></h4> <div class="docblock">
<p>An iterator over the disjoint matches of a pattern within this string slice as well as the index that the match starts at.</p> <p>For matches of <code>pat</code> within <code>self</code> that overlap, only the indices corresponding to the first match are returned.</p> <p>The pattern can be a <code>&amp;str</code>, <a href="../primitive.char/"><code>char</code></a>, or a closure that determines if a character matches.</p> <h4 id="iterator-behavior-8" class="section-header">Iterator behavior</h4> <p>The returned iterator will be a <a href="../iter/trait.doubleendediterator/"><code>DoubleEndedIterator</code></a> if the pattern allows a reverse search and forward/reverse search yields the same elements. This is true for, eg, <a href="../primitive.char/"><code>char</code></a> but not for <code>&amp;str</code>.</p> <p>If the pattern allows a reverse search but its results might differ from a forward search, the <a href="#method.rmatch_indices"><code>rmatch_indices()</code></a> method can be used.</p> <h4 id="examples-55" class="section-header">Examples</h4> <p>Basic usage:</p> <pre class="rust rust-example-rendered" data-language="rust">
let v: Vec&lt;_&gt; = "abcXXXabcYYYabc".match_indices("abc").collect();
assert_eq!(v, [(0, "abc"), (6, "abc"), (12, "abc")]);

let v: Vec&lt;_&gt; = "1abcabc2".match_indices("abc").collect();
assert_eq!(v, [(1, "abc"), (4, "abc")]);

let v: Vec&lt;_&gt; = "ababa".match_indices("aba").collect();
assert_eq!(v, [(0, "aba")]); // only the first `aba`</pre> </div>
<h4 id="method.rmatch_indices" class="method"><span id="rmatch_indices.v" class="invisible"><code>fn <a href="#method.rmatch_indices" class="fnname">rmatch_indices</a>&lt;'a, P&gt;(&amp;'a self, pat: P) -&gt; <a class="struct" href="../../str/struct.rmatchindices/" title="std::str::RMatchIndices">RMatchIndices</a>&lt;'a, P&gt; <span class="where fmt-newline">where P: <a class="trait" href="../../str/pattern/trait.pattern/" title="std::str::pattern::Pattern">Pattern</a>&lt;'a&gt;, P::<a class="trait" href="../../str/pattern/trait.pattern/" title="std::str::pattern::Pattern">Searcher</a>: <a class="trait" href="../../str/pattern/trait.reversesearcher/" title="std::str::pattern::ReverseSearcher">ReverseSearcher</a>&lt;'a&gt;</span></code><div class="since" title="Stable since Rust version 1.5.0">1.5.0</div></span></h4> <div class="docblock">
<p>An iterator over the disjoint matches of a pattern within <code>self</code>, yielded in reverse order along with the index of the match.</p> <p>For matches of <code>pat</code> within <code>self</code> that overlap, only the indices corresponding to the last match are returned.</p> <p>The pattern can be a <code>&amp;str</code>, <a href="../primitive.char/"><code>char</code></a>, or a closure that determines if a character matches.</p> <h4 id="iterator-behavior-9" class="section-header">Iterator behavior</h4> <p>The returned iterator requires that the pattern supports a reverse search, and it will be a <a href="../iter/trait.doubleendediterator/"><code>DoubleEndedIterator</code></a> if a forward/reverse search yields the same elements.</p> <p>For iterating from the front, the <a href="#method.match_indices"><code>match_indices()</code></a> method can be used.</p> <h4 id="examples-56" class="section-header">Examples</h4> <p>Basic usage:</p> <pre class="rust rust-example-rendered" data-language="rust">
let v: Vec&lt;_&gt; = "abcXXXabcYYYabc".rmatch_indices("abc").collect();
assert_eq!(v, [(12, "abc"), (6, "abc"), (0, "abc")]);

let v: Vec&lt;_&gt; = "1abcabc2".rmatch_indices("abc").collect();
assert_eq!(v, [(4, "abc"), (1, "abc")]);

let v: Vec&lt;_&gt; = "ababa".rmatch_indices("aba").collect();
assert_eq!(v, [(2, "aba")]); // only the last `aba`</pre> </div>
<h4 id="method.trim" class="method"><span id="trim.v" class="invisible"><code>fn <a href="#method.trim" class="fnname">trim</a>(&amp;self) -&gt; &amp;<a class="primitive" href="../../primitive.str/">str</a></code></span></h4> <div class="docblock">
<p>Returns a string slice with leading and trailing whitespace removed.</p> <p>'Whitespace' is defined according to the terms of the Unicode Derived Core Property <code>White_Space</code>.</p> <h4 id="examples-57" class="section-header">Examples</h4> <p>Basic usage:</p> <pre class="rust rust-example-rendered" data-language="rust">
let s = " Hello\tworld\t";

assert_eq!("Hello\tworld", s.trim());</pre> </div>
<h4 id="method.trim_left" class="method"><span id="trim_left.v" class="invisible"><code>fn <a href="#method.trim_left" class="fnname">trim_left</a>(&amp;self) -&gt; &amp;<a class="primitive" href="../../primitive.str/">str</a></code></span></h4> <div class="docblock">
<p>Returns a string slice with leading whitespace removed.</p> <p>'Whitespace' is defined according to the terms of the Unicode Derived Core Property <code>White_Space</code>.</p> <h4 id="text-directionality" class="section-header">Text directionality</h4> <p>A string is a sequence of bytes. 'Left' in this context means the first position of that byte string; for a language like Arabic or Hebrew which are 'right to left' rather than 'left to right', this will be the <em>right</em> side, not the left.</p> <h4 id="examples-58" class="section-header">Examples</h4> <p>Basic usage:</p> <pre class="rust rust-example-rendered" data-language="rust">
let s = " Hello\tworld\t";

assert_eq!("Hello\tworld\t", s.trim_left());</pre> <p>Directionality:</p> <pre class="rust rust-example-rendered" data-language="rust">
let s = "  English";
assert!(Some('E') == s.trim_left().chars().next());

let s = "  עברית";
assert!(Some('ע') == s.trim_left().chars().next());</pre> </div>
<h4 id="method.trim_right" class="method"><span id="trim_right.v" class="invisible"><code>fn <a href="#method.trim_right" class="fnname">trim_right</a>(&amp;self) -&gt; &amp;<a class="primitive" href="../../primitive.str/">str</a></code></span></h4> <div class="docblock">
<p>Returns a string slice with trailing whitespace removed.</p> <p>'Whitespace' is defined according to the terms of the Unicode Derived Core Property <code>White_Space</code>.</p> <h4 id="text-directionality-1" class="section-header">Text directionality</h4> <p>A string is a sequence of bytes. 'Right' in this context means the last position of that byte string; for a language like Arabic or Hebrew which are 'right to left' rather than 'left to right', this will be the <em>left</em> side, not the right.</p> <h4 id="examples-59" class="section-header">Examples</h4> <p>Basic usage:</p> <pre class="rust rust-example-rendered" data-language="rust">
let s = " Hello\tworld\t";

assert_eq!(" Hello\tworld", s.trim_right());</pre> <p>Directionality:</p> <pre class="rust rust-example-rendered" data-language="rust">
let s = "English  ";
assert!(Some('h') == s.trim_right().chars().rev().next());

let s = "עברית  ";
assert!(Some('ת') == s.trim_right().chars().rev().next());</pre> </div>
<h4 id="method.trim_matches" class="method"><span id="trim_matches.v" class="invisible"><code>fn <a href="#method.trim_matches" class="fnname">trim_matches</a>&lt;'a, P&gt;(&amp;'a self, pat: P) -&gt; &amp;'a <a class="primitive" href="../../primitive.str/">str</a> <span class="where fmt-newline">where P: <a class="trait" href="../../str/pattern/trait.pattern/" title="std::str::pattern::Pattern">Pattern</a>&lt;'a&gt;, P::<a class="trait" href="../../str/pattern/trait.pattern/" title="std::str::pattern::Pattern">Searcher</a>: <a class="trait" href="../../str/pattern/trait.doubleendedsearcher/" title="std::str::pattern::DoubleEndedSearcher">DoubleEndedSearcher</a>&lt;'a&gt;</span></code></span></h4> <div class="docblock">
<p>Returns a string slice with all prefixes and suffixes that match a pattern repeatedly removed.</p> <p>The pattern can be a <a href="../primitive.char/"><code>char</code></a> or a closure that determines if a character matches.</p> <h4 id="examples-60" class="section-header">Examples</h4> <p>Simple patterns:</p> <pre class="rust rust-example-rendered" data-language="rust">
assert_eq!("11foo1bar11".trim_matches('1'), "foo1bar");
assert_eq!("123foo1bar123".trim_matches(char::is_numeric), "foo1bar");

let x: &amp;[_] = &amp;['1', '2'];
assert_eq!("12foo1bar12".trim_matches(x), "foo1bar");</pre> <p>A more complex pattern, using a closure:</p> <pre class="rust rust-example-rendered" data-language="rust">
assert_eq!("1foo1barXX".trim_matches(|c| c == '1' || c == 'X'), "foo1bar");</pre> </div>
<h4 id="method.trim_left_matches" class="method"><span id="trim_left_matches.v" class="invisible"><code>fn <a href="#method.trim_left_matches" class="fnname">trim_left_matches</a>&lt;'a, P&gt;(&amp;'a self, pat: P) -&gt; &amp;'a <a class="primitive" href="../../primitive.str/">str</a> <span class="where fmt-newline">where P: <a class="trait" href="../../str/pattern/trait.pattern/" title="std::str::pattern::Pattern">Pattern</a>&lt;'a&gt;</span></code></span></h4> <div class="docblock">
<p>Returns a string slice with all prefixes that match a pattern repeatedly removed.</p> <p>The pattern can be a <code>&amp;str</code>, <a href="../primitive.char/"><code>char</code></a>, or a closure that determines if a character matches.</p> <h4 id="text-directionality-2" class="section-header">Text directionality</h4> <p>A string is a sequence of bytes. 'Left' in this context means the first position of that byte string; for a language like Arabic or Hebrew which are 'right to left' rather than 'left to right', this will be the <em>right</em> side, not the left.</p> <h4 id="examples-61" class="section-header">Examples</h4> <p>Basic usage:</p> <pre class="rust rust-example-rendered" data-language="rust">
assert_eq!("11foo1bar11".trim_left_matches('1'), "foo1bar11");
assert_eq!("123foo1bar123".trim_left_matches(char::is_numeric), "foo1bar123");

let x: &amp;[_] = &amp;['1', '2'];
assert_eq!("12foo1bar12".trim_left_matches(x), "foo1bar12");</pre> </div>
<h4 id="method.trim_right_matches" class="method"><span id="trim_right_matches.v" class="invisible"><code>fn <a href="#method.trim_right_matches" class="fnname">trim_right_matches</a>&lt;'a, P&gt;(&amp;'a self, pat: P) -&gt; &amp;'a <a class="primitive" href="../../primitive.str/">str</a> <span class="where fmt-newline">where P: <a class="trait" href="../../str/pattern/trait.pattern/" title="std::str::pattern::Pattern">Pattern</a>&lt;'a&gt;, P::<a class="trait" href="../../str/pattern/trait.pattern/" title="std::str::pattern::Pattern">Searcher</a>: <a class="trait" href="../../str/pattern/trait.reversesearcher/" title="std::str::pattern::ReverseSearcher">ReverseSearcher</a>&lt;'a&gt;</span></code></span></h4> <div class="docblock">
<p>Returns a string slice with all suffixes that match a pattern repeatedly removed.</p> <p>The pattern can be a <code>&amp;str</code>, <a href="../primitive.char/"><code>char</code></a>, or a closure that determines if a character matches.</p> <h4 id="text-directionality-3" class="section-header">Text directionality</h4> <p>A string is a sequence of bytes. 'Right' in this context means the last position of that byte string; for a language like Arabic or Hebrew which are 'right to left' rather than 'left to right', this will be the <em>left</em> side, not the right.</p> <h4 id="examples-62" class="section-header">Examples</h4> <p>Simple patterns:</p> <pre class="rust rust-example-rendered" data-language="rust">
assert_eq!("11foo1bar11".trim_right_matches('1'), "11foo1bar");
assert_eq!("123foo1bar123".trim_right_matches(char::is_numeric), "123foo1bar");

let x: &amp;[_] = &amp;['1', '2'];
assert_eq!("12foo1bar12".trim_right_matches(x), "12foo1bar");</pre> <p>A more complex pattern, using a closure:</p> <pre class="rust rust-example-rendered" data-language="rust">
assert_eq!("1fooX".trim_left_matches(|c| c == '1' || c == 'X'), "fooX");</pre> </div>
<h4 id="method.parse" class="method"><span id="parse.v" class="invisible"><code>fn <a href="#method.parse" class="fnname">parse</a>&lt;F&gt;(&amp;self) -&gt; <a class="enum" href="../../result/enum.result/" title="std::result::Result">Result</a>&lt;F, F::<a class="trait" href="../../str/trait.fromstr/" title="std::str::FromStr">Err</a>&gt; <span class="where fmt-newline">where F: <a class="trait" href="../../str/trait.fromstr/" title="std::str::FromStr">FromStr</a></span></code></span></h4> <div class="docblock">
<p>Parses this string slice into another type.</p> <p>Because <code>parse()</code> is so general, it can cause problems with type inference. As such, <code>parse()</code> is one of the few times you'll see the syntax affectionately known as the 'turbofish': <code>::&lt;&gt;</code>. This helps the inference algorithm understand specifically which type you're trying to parse into.</p> <p><code>parse()</code> can parse any type that implements the <a href="../str/trait.fromstr/"><code>FromStr</code></a> trait.</p> <h4 id="errors-1" class="section-header">Errors</h4> <p>Will return <a href="../str/trait.fromstr/#associatedtype.Err"><code>Err</code></a> if it's not possible to parse this string slice into the desired type.</p> <h4 id="example" class="section-header">Example</h4> <p>Basic usage</p> <pre class="rust rust-example-rendered" data-language="rust">
let four: u32 = "4".parse().unwrap();

assert_eq!(4, four);</pre> <p>Using the 'turbofish' instead of annotating <code>four</code>:</p> <pre class="rust rust-example-rendered" data-language="rust">
let four = "4".parse::&lt;u32&gt;();

assert_eq!(Ok(4), four);</pre> <p>Failing to parse:</p> <pre class="rust rust-example-rendered" data-language="rust">
let nope = "j".parse::&lt;u32&gt;();

assert!(nope.is_err());</pre> </div>
<h4 id="method.replace" class="method"><span id="replace.v" class="invisible"><code>fn <a href="#method.replace" class="fnname">replace</a>&lt;'a, P&gt;(&amp;'a self, from: P, to: &amp;<a class="primitive" href="../../primitive.str/">str</a>) -&gt; <a class="struct" href="../struct.string/" title="std::string::String">String</a> <span class="where fmt-newline">where P: <a class="trait" href="../../str/pattern/trait.pattern/" title="std::str::pattern::Pattern">Pattern</a>&lt;'a&gt;</span></code></span></h4> <div class="docblock">
<p>Replaces all matches of a pattern with another string.</p> <p><code>replace</code> creates a new <a href="../string/struct.string/"><code>String</code></a>, and copies the data from this string slice into it. While doing so, it attempts to find matches of a pattern. If it finds any, it replaces them with the replacement string slice.</p> <h4 id="examples-63" class="section-header">Examples</h4> <p>Basic usage:</p> <pre class="rust rust-example-rendered" data-language="rust">
let s = "this is old";

assert_eq!("this is new", s.replace("old", "new"));</pre> <p>When the pattern doesn't match:</p> <pre class="rust rust-example-rendered" data-language="rust">
let s = "this is old";
assert_eq!(s, s.replace("cookie monster", "little lamb"));</pre> </div>
<h4 id="method.replacen" class="method"><span id="replacen.v" class="invisible"><code>fn <a href="#method.replacen" class="fnname">replacen</a>&lt;'a, P&gt;(&amp;'a self, pat: P, to: &amp;<a class="primitive" href="../../primitive.str/">str</a>, count: <a class="primitive" href="../../primitive.usize/">usize</a>) -&gt; <a class="struct" href="../struct.string/" title="std::string::String">String</a> <span class="where fmt-newline">where P: <a class="trait" href="../../str/pattern/trait.pattern/" title="std::str::pattern::Pattern">Pattern</a>&lt;'a&gt;</span></code><div class="since" title="Stable since Rust version 1.16.0">1.16.0</div></span></h4> <div class="docblock">
<p>Replaces first N matches of a pattern with another string.</p> <p><code>replacen</code> creates a new <a href="../string/struct.string/"><code>String</code></a>, and copies the data from this string slice into it. While doing so, it attempts to find matches of a pattern. If it finds any, it replaces them with the replacement string slice at most <code>N</code> times.</p> <h4 id="examples-64" class="section-header">Examples</h4> <p>Basic usage:</p> <pre class="rust rust-example-rendered" data-language="rust">
let s = "foo foo 123 foo";
assert_eq!("new new 123 foo", s.replacen("foo", "new", 2));
assert_eq!("faa fao 123 foo", s.replacen('o', "a", 3));
assert_eq!("foo foo new23 foo", s.replacen(char::is_numeric, "new", 1));</pre> <p>When the pattern doesn't match:</p> <pre class="rust rust-example-rendered" data-language="rust">
let s = "this is old";
assert_eq!(s, s.replacen("cookie monster", "little lamb", 10));</pre> </div>
<h4 id="method.to_lowercase" class="method"><span id="to_lowercase.v" class="invisible"><code>fn <a href="#method.to_lowercase" class="fnname">to_lowercase</a>(&amp;self) -&gt; <a class="struct" href="../struct.string/" title="std::string::String">String</a></code><div class="since" title="Stable since Rust version 1.2.0">1.2.0</div></span></h4> <div class="docblock">
<p>Returns the lowercase equivalent of this string slice, as a new <a href="../string/struct.string/"><code>String</code></a>.</p> <p>'Lowercase' is defined according to the terms of the Unicode Derived Core Property <code>Lowercase</code>.</p> <h4 id="examples-65" class="section-header">Examples</h4> <p>Basic usage:</p> <pre class="rust rust-example-rendered" data-language="rust">
let s = "HELLO";

assert_eq!("hello", s.to_lowercase());</pre> <p>A tricky example, with sigma:</p> <pre class="rust rust-example-rendered" data-language="rust">
let sigma = "Σ";

assert_eq!("σ", sigma.to_lowercase());

// but at the end of a word, it's ς, not σ:
let odysseus = "ὈΔΥΣΣΕΎΣ";

assert_eq!("ὀδυσσεύς", odysseus.to_lowercase());</pre> <p>Languages without case are not changed:</p> <pre class="rust rust-example-rendered" data-language="rust">
let new_year = "农历新年";

assert_eq!(new_year, new_year.to_lowercase());</pre> </div>
<h4 id="method.to_uppercase" class="method"><span id="to_uppercase.v" class="invisible"><code>fn <a href="#method.to_uppercase" class="fnname">to_uppercase</a>(&amp;self) -&gt; <a class="struct" href="../struct.string/" title="std::string::String">String</a></code><div class="since" title="Stable since Rust version 1.2.0">1.2.0</div></span></h4> <div class="docblock">
<p>Returns the uppercase equivalent of this string slice, as a new <a href="../string/struct.string/"><code>String</code></a>.</p> <p>'Uppercase' is defined according to the terms of the Unicode Derived Core Property <code>Uppercase</code>.</p> <h4 id="examples-66" class="section-header">Examples</h4> <p>Basic usage:</p> <pre class="rust rust-example-rendered" data-language="rust">
let s = "hello";

assert_eq!("HELLO", s.to_uppercase());</pre> <p>Scripts without case are not changed:</p> <pre class="rust rust-example-rendered" data-language="rust">
let new_year = "农历新年";

assert_eq!(new_year, new_year.to_uppercase());</pre> </div>
<h4 id="method.escape_debug" class="method"><span id="escape_debug.v" class="invisible"><code>fn <a href="#method.escape_debug" class="fnname">escape_debug</a>(&amp;self) -&gt; <a class="struct" href="../struct.string/" title="std::string::String">String</a></code></span></h4> <div class="stability"><span class="stab unstable">🔬 This is a nightly-only experimental API. (str_escape #27791)return type may change to be an iterator </span></div>
<div class="docblock">
<p>Escapes each char in <code>s</code> with <code>char::escape_debug</code>.</p> </div>
<h4 id="method.escape_default" class="method"><span id="escape_default.v" class="invisible"><code>fn <a href="#method.escape_default" class="fnname">escape_default</a>(&amp;self) -&gt; <a class="struct" href="../struct.string/" title="std::string::String">String</a></code></span></h4> <div class="stability"><span class="stab unstable">🔬 This is a nightly-only experimental API. (str_escape #27791)return type may change to be an iterator </span></div>
<div class="docblock">
<p>Escapes each char in <code>s</code> with <code>char::escape_default</code>.</p> </div>
<h4 id="method.escape_unicode" class="method"><span id="escape_unicode.v" class="invisible"><code>fn <a href="#method.escape_unicode" class="fnname">escape_unicode</a>(&amp;self) -&gt; <a class="struct" href="../struct.string/" title="std::string::String">String</a></code></span></h4> <div class="stability"><span class="stab unstable">🔬 This is a nightly-only experimental API. (str_escape #27791)return type may change to be an iterator </span></div>
<div class="docblock">
<p>Escapes each char in <code>s</code> with <code>char::escape_unicode</code>.</p> </div>
<h4 id="method.into_string" class="method"><span id="into_string.v" class="invisible"><code>fn <a href="#method.into_string" class="fnname">into_string</a>(self: <a class="struct" href="../../boxed/struct.box/" title="std::boxed::Box">Box</a>&lt;<a class="primitive" href="../../primitive.str/">str</a>&gt;) -&gt; <a class="struct" href="../struct.string/" title="std::string::String">String</a></code><div class="since" title="Stable since Rust version 1.4.0">1.4.0</div></span></h4> <div class="docblock">
<p>Converts a <code>Box&lt;str&gt;</code> into a <a href="../string/struct.string/"><code>String</code></a> without copying or allocating.</p> <h4 id="examples-67" class="section-header">Examples</h4> <p>Basic usage:</p> <pre class="rust rust-example-rendered" data-language="rust">
let string = String::from("birthday gift");
let boxed_str = string.clone().into_boxed_str();

assert_eq!(boxed_str.into_string(), string);</pre> </div>
<h4 id="method.repeat" class="method"><span id="repeat.v" class="invisible"><code>fn <a href="#method.repeat" class="fnname">repeat</a>(&amp;self, n: <a class="primitive" href="../../primitive.usize/">usize</a>) -&gt; <a class="struct" href="../struct.string/" title="std::string::String">String</a></code><div class="since" title="Stable since Rust version 1.16.0">1.16.0</div></span></h4> <div class="docblock">
<p>Create a <a href="../string/struct.string/"><code>String</code></a> by repeating a string <code>n</code> times.</p> <h4 id="examples-68" class="section-header">Examples</h4> <p>Basic usage:</p> <pre class="rust rust-example-rendered" data-language="rust">
assert_eq!("abc".repeat(4), String::from("abcabcabcabc"));</pre> </div>
<h2 id="implementations">Trait Implementations</h2>
<h3 class="impl">
<span class="in-band"><code>impl <a class="trait" href="../../iter/trait.extend/" title="std::iter::Extend">Extend</a>&lt;<a class="primitive" href="../../primitive.char/">char</a>&gt; for <a class="struct" href="../struct.string/" title="std::string::String">String</a></code></span><span class="out-of-band">
<a class="srclink" href="https://doc.rust-lang.org/src/collections/string.rs.html#1502-1511" title="goto source code" target="_blank">[src]</a></span>
</h3> <h4 id="method.extend" class="method"><span id="extend.v" class="invisible"><code>fn <a href="../../iter/trait.extend/#tymethod.extend" class="fnname">extend</a>&lt;I&gt;(&amp;mut self, iter: I) <span class="where fmt-newline">where I: <a class="trait" href="../../iter/trait.intoiterator/" title="std::iter::IntoIterator">IntoIterator</a>&lt;Item=<a class="primitive" href="../../primitive.char/">char</a>&gt;</span></code></span></h4> <div class="docblock">
<p>Extends a collection with the contents of an iterator. <a href="../../iter/trait.extend/#tymethod.extend">Read more</a></p> </div>
<h3 class="impl">
<span class="in-band"><code>impl&lt;'a&gt; <a class="trait" href="../../iter/trait.extend/" title="std::iter::Extend">Extend</a>&lt;&amp;'a <a class="primitive" href="../../primitive.char/">char</a>&gt; for <a class="struct" href="../struct.string/" title="std::string::String">String</a></code></span><span class="out-of-band">
<div class="since" title="Stable since Rust version 1.2.0">1.2.0</div>
<a class="srclink" href="https://doc.rust-lang.org/src/collections/string.rs.html#1514-1518" title="goto source code" target="_blank">[src]</a></span>
</h3> <h4 id="method.extend-1" class="method"><span id="extend.v-1" class="invisible"><code>fn <a href="../../iter/trait.extend/#tymethod.extend" class="fnname">extend</a>&lt;I&gt;(&amp;mut self, iter: I) <span class="where fmt-newline">where I: <a class="trait" href="../../iter/trait.intoiterator/" title="std::iter::IntoIterator">IntoIterator</a>&lt;Item=&amp;'a <a class="primitive" href="../../primitive.char/">char</a>&gt;</span></code></span></h4> <div class="docblock">
<p>Extends a collection with the contents of an iterator. <a href="../../iter/trait.extend/#tymethod.extend">Read more</a></p> </div>
<h3 class="impl">
<span class="in-band"><code>impl&lt;'a&gt; <a class="trait" href="../../iter/trait.extend/" title="std::iter::Extend">Extend</a>&lt;&amp;'a <a class="primitive" href="../../primitive.str/">str</a>&gt; for <a class="struct" href="../struct.string/" title="std::string::String">String</a></code></span><span class="out-of-band">
<a class="srclink" href="https://doc.rust-lang.org/src/collections/string.rs.html#1521-1527" title="goto source code" target="_blank">[src]</a></span>
</h3> <h4 id="method.extend-2" class="method"><span id="extend.v-2" class="invisible"><code>fn <a href="../../iter/trait.extend/#tymethod.extend" class="fnname">extend</a>&lt;I&gt;(&amp;mut self, iter: I) <span class="where fmt-newline">where I: <a class="trait" href="../../iter/trait.intoiterator/" title="std::iter::IntoIterator">IntoIterator</a>&lt;Item=&amp;'a <a class="primitive" href="../../primitive.str/">str</a>&gt;</span></code></span></h4> <div class="docblock">
<p>Extends a collection with the contents of an iterator. <a href="../../iter/trait.extend/#tymethod.extend">Read more</a></p> </div>
<h3 class="impl">
<span class="in-band"><code>impl <a class="trait" href="../../iter/trait.extend/" title="std::iter::Extend">Extend</a>&lt;<a class="struct" href="../struct.string/" title="std::string::String">String</a>&gt; for <a class="struct" href="../struct.string/" title="std::string::String">String</a></code></span><span class="out-of-band">
<div class="since" title="Stable since Rust version 1.4.0">1.4.0</div>
<a class="srclink" href="https://doc.rust-lang.org/src/collections/string.rs.html#1530-1536" title="goto source code" target="_blank">[src]</a></span>
</h3> <h4 id="method.extend-3" class="method"><span id="extend.v-3" class="invisible"><code>fn <a href="../../iter/trait.extend/#tymethod.extend" class="fnname">extend</a>&lt;I&gt;(&amp;mut self, iter: I) <span class="where fmt-newline">where I: <a class="trait" href="../../iter/trait.intoiterator/" title="std::iter::IntoIterator">IntoIterator</a>&lt;Item=<a class="struct" href="../struct.string/" title="std::string::String">String</a>&gt;</span></code></span></h4> <div class="docblock">
<p>Extends a collection with the contents of an iterator. <a href="../../iter/trait.extend/#tymethod.extend">Read more</a></p> </div>
<h3 class="impl">
<span class="in-band"><code>impl <a class="trait" href="../../fmt/trait.display/" title="std::fmt::Display">Display</a> for <a class="struct" href="../struct.string/" title="std::string::String">String</a></code></span><span class="out-of-band">
<a class="srclink" href="https://doc.rust-lang.org/src/collections/string.rs.html#1609-1614" title="goto source code" target="_blank">[src]</a></span>
</h3> <h4 id="method.fmt" class="method"><span id="fmt.v" class="invisible"><code>fn <a href="../../fmt/trait.display/#tymethod.fmt" class="fnname">fmt</a>(&amp;self, f: &amp;mut <a class="struct" href="../../fmt/struct.formatter/" title="std::fmt::Formatter">Formatter</a>) -&gt; <a class="enum" href="../../result/enum.result/" title="std::result::Result">Result</a>&lt;<a class="primitive" href="../../primitive.tuple/">()</a>, <a class="struct" href="../../fmt/struct.error/" title="std::fmt::Error">Error</a>&gt;</code></span></h4> <div class="docblock">
<p>Formats the value using the given formatter.</p> </div>
<h3 class="impl">
<span class="in-band"><code>impl <a class="trait" href="../../ops/trait.derefmut/" title="std::ops::DerefMut">DerefMut</a> for <a class="struct" href="../struct.string/" title="std::string::String">String</a></code></span><span class="out-of-band">
<div class="since" title="Stable since Rust version 1.2.0">1.2.0</div>
<a class="srclink" href="https://doc.rust-lang.org/src/collections/string.rs.html#1760-1765" title="goto source code" target="_blank">[src]</a></span>
</h3> <h4 id="method.deref_mut" class="method"><span id="deref_mut.v" class="invisible"><code>fn <a href="../../ops/trait.derefmut/#tymethod.deref_mut" class="fnname">deref_mut</a>(&amp;mut self) -&gt; &amp;mut <a class="primitive" href="../../primitive.str/">str</a></code></span></h4> <div class="docblock">
<p>The method called to mutably dereference a value</p> </div>
<h3 class="impl">
<span class="in-band"><code>impl <a class="trait" href="../../cmp/trait.partialord/" title="std::cmp::PartialOrd">PartialOrd</a>&lt;<a class="struct" href="../struct.string/" title="std::string::String">String</a>&gt; for <a class="struct" href="../struct.string/" title="std::string::String">String</a></code></span><span class="out-of-band">
<a class="srclink" href="https://doc.rust-lang.org/src/collections/string.rs.html#261" title="goto source code" target="_blank">[src]</a></span>
</h3> <h4 id="method.partial_cmp" class="method"><span id="partial_cmp.v" class="invisible"><code>fn <a href="../../cmp/trait.partialord/#tymethod.partial_cmp" class="fnname">partial_cmp</a>(&amp;self, __arg_0: &amp;<a class="struct" href="../struct.string/" title="std::string::String">String</a>) -&gt; <a class="enum" href="../../option/enum.option/" title="std::option::Option">Option</a>&lt;<a class="enum" href="../../cmp/enum.ordering/" title="std::cmp::Ordering">Ordering</a>&gt;</code></span></h4> <div class="docblock">
<p>This method returns an ordering between <code>self</code> and <code>other</code> values if one exists. <a href="../../cmp/trait.partialord/#tymethod.partial_cmp">Read more</a></p> </div>
<h4 id="method.lt" class="method"><span id="lt.v" class="invisible"><code>fn <a href="../../cmp/trait.partialord/#method.lt" class="fnname">lt</a>(&amp;self, __arg_0: &amp;<a class="struct" href="../struct.string/" title="std::string::String">String</a>) -&gt; <a class="primitive" href="../../primitive.bool/">bool</a></code></span></h4> <div class="docblock">
<p>This method tests less than (for <code>self</code> and <code>other</code>) and is used by the <code>&lt;</code> operator. <a href="../../cmp/trait.partialord/#method.lt">Read more</a></p> </div>
<h4 id="method.le" class="method"><span id="le.v" class="invisible"><code>fn <a href="../../cmp/trait.partialord/#method.le" class="fnname">le</a>(&amp;self, __arg_0: &amp;<a class="struct" href="../struct.string/" title="std::string::String">String</a>) -&gt; <a class="primitive" href="../../primitive.bool/">bool</a></code></span></h4> <div class="docblock">
<p>This method tests less than or equal to (for <code>self</code> and <code>other</code>) and is used by the <code>&lt;=</code> operator. <a href="../../cmp/trait.partialord/#method.le">Read more</a></p> </div>
<h4 id="method.gt" class="method"><span id="gt.v" class="invisible"><code>fn <a href="../../cmp/trait.partialord/#method.gt" class="fnname">gt</a>(&amp;self, __arg_0: &amp;<a class="struct" href="../struct.string/" title="std::string::String">String</a>) -&gt; <a class="primitive" href="../../primitive.bool/">bool</a></code></span></h4> <div class="docblock">
<p>This method tests greater than (for <code>self</code> and <code>other</code>) and is used by the <code>&gt;</code> operator. <a href="../../cmp/trait.partialord/#method.gt">Read more</a></p> </div>
<h4 id="method.ge" class="method"><span id="ge.v" class="invisible"><code>fn <a href="../../cmp/trait.partialord/#method.ge" class="fnname">ge</a>(&amp;self, __arg_0: &amp;<a class="struct" href="../struct.string/" title="std::string::String">String</a>) -&gt; <a class="primitive" href="../../primitive.bool/">bool</a></code></span></h4> <div class="docblock">
<p>This method tests greater than or equal to (for <code>self</code> and <code>other</code>) and is used by the <code>&gt;=</code> operator. <a href="../../cmp/trait.partialord/#method.ge">Read more</a></p> </div>
<h3 class="impl">
<span class="in-band"><code>impl <a class="trait" href="../../hash/trait.hash/" title="std::hash::Hash">Hash</a> for <a class="struct" href="../struct.string/" title="std::string::String">String</a></code></span><span class="out-of-band">
<a class="srclink" href="https://doc.rust-lang.org/src/collections/string.rs.html#1625-1630" title="goto source code" target="_blank">[src]</a></span>
</h3> <h4 id="method.hash" class="method"><span id="hash.v" class="invisible"><code>fn <a href="../../hash/trait.hash/#tymethod.hash" class="fnname">hash</a>&lt;H&gt;(&amp;self, hasher: &amp;mut H) <span class="where fmt-newline">where H: <a class="trait" href="../../hash/trait.hasher/" title="std::hash::Hasher">Hasher</a></span></code></span></h4> <div class="docblock">
<p>Feeds this value into the state given, updating the hasher as necessary.</p> </div>
<h4 id="method.hash_slice" class="method"><span id="hash_slice.v" class="invisible"><code>fn <a href="../../hash/trait.hash/#method.hash_slice" class="fnname">hash_slice</a>&lt;H&gt;(data: <a class="primitive" href="../../primitive.slice/">&amp;[Self]</a>, state: &amp;mut H) <span class="where fmt-newline">where H: <a class="trait" href="../../hash/trait.hasher/" title="std::hash::Hasher">Hasher</a></span></code><div class="since" title="Stable since Rust version 1.3.0">1.3.0</div></span></h4> <div class="docblock">
<p>Feeds a slice of this type into the state provided.</p> </div>
<h3 class="impl">
<span class="in-band"><code>impl <a class="trait" href="../../cmp/trait.eq/" title="std::cmp::Eq">Eq</a> for <a class="struct" href="../struct.string/" title="std::string::String">String</a></code></span><span class="out-of-band">
<a class="srclink" href="https://doc.rust-lang.org/src/collections/string.rs.html#261" title="goto source code" target="_blank">[src]</a></span>
</h3> <h3 class="impl">
<span class="in-band"><code>impl <a class="trait" href="../../str/trait.fromstr/" title="std::str::FromStr">FromStr</a> for <a class="struct" href="../struct.string/" title="std::string::String">String</a></code></span><span class="out-of-band">
<a class="srclink" href="https://doc.rust-lang.org/src/collections/string.rs.html#1784-1790" title="goto source code" target="_blank">[src]</a></span>
</h3> <h4 id="associatedtype.Err" class="type"><span id="Err.t" class="invisible"><code>type <a href="../../str/trait.fromstr/#associatedtype.Err" class="type">Err</a> = <a class="enum" href="../enum.parseerror/" title="std::string::ParseError">ParseError</a></code></span></h4> <div class="docblock">
<p>The associated error which can be returned from parsing.</p> </div>
<h4 id="method.from_str" class="method"><span id="from_str.v" class="invisible"><code>fn <a href="../../str/trait.fromstr/#tymethod.from_str" class="fnname">from_str</a>(s: &amp;<a class="primitive" href="../../primitive.str/">str</a>) -&gt; <a class="enum" href="../../result/enum.result/" title="std::result::Result">Result</a>&lt;<a class="struct" href="../struct.string/" title="std::string::String">String</a>, <a class="enum" href="../enum.parseerror/" title="std::string::ParseError">ParseError</a>&gt;</code></span></h4> <div class="docblock">
<p>Parses a string <code>s</code> to return a value of this type. <a href="../../str/trait.fromstr/#tymethod.from_str">Read more</a></p> </div>
<h3 class="impl">
<span class="in-band"><code>impl&lt;'a&gt; <a class="trait" href="../../convert/trait.from/" title="std::convert::From">From</a>&lt;&amp;'a <a class="primitive" href="../../primitive.str/">str</a>&gt; for <a class="struct" href="../struct.string/" title="std::string::String">String</a></code></span><span class="out-of-band">
<a class="srclink" href="https://doc.rust-lang.org/src/collections/string.rs.html#1886-1890" title="goto source code" target="_blank">[src]</a></span>
</h3> <h4 id="method.from" class="method"><span id="from.v" class="invisible"><code>fn <a href="../../convert/trait.from/#tymethod.from" class="fnname">from</a>(s: &amp;'a <a class="primitive" href="../../primitive.str/">str</a>) -&gt; <a class="struct" href="../struct.string/" title="std::string::String">String</a></code></span></h4> <div class="docblock">
<p>Performs the conversion.</p> </div>
<h3 class="impl">
<span class="in-band"><code>impl&lt;'a&gt; <a class="trait" href="../../convert/trait.from/" title="std::convert::From">From</a>&lt;<a class="enum" href="../../borrow/enum.cow/" title="std::borrow::Cow">Cow</a>&lt;'a, <a class="primitive" href="../../primitive.str/">str</a>&gt;&gt; for <a class="struct" href="../struct.string/" title="std::string::String">String</a></code></span><span class="out-of-band">
<div class="since" title="Stable since Rust version 1.14.0">1.14.0</div>
<a class="srclink" href="https://doc.rust-lang.org/src/collections/string.rs.html#1893-1897" title="goto source code" target="_blank">[src]</a></span>
</h3> <h4 id="method.from-1" class="method"><span id="from.v-1" class="invisible"><code>fn <a href="../../convert/trait.from/#tymethod.from" class="fnname">from</a>(s: <a class="enum" href="../../borrow/enum.cow/" title="std::borrow::Cow">Cow</a>&lt;'a, <a class="primitive" href="../../primitive.str/">str</a>&gt;) -&gt; <a class="struct" href="../struct.string/" title="std::string::String">String</a></code></span></h4> <div class="docblock">
<p>Performs the conversion.</p> </div>
<h3 class="impl">
<span class="in-band"><code>impl <a class="trait" href="../../cmp/trait.ord/" title="std::cmp::Ord">Ord</a> for <a class="struct" href="../struct.string/" title="std::string::String">String</a></code></span><span class="out-of-band">
<a class="srclink" href="https://doc.rust-lang.org/src/collections/string.rs.html#261" title="goto source code" target="_blank">[src]</a></span>
</h3> <h4 id="method.cmp" class="method"><span id="cmp.v" class="invisible"><code>fn <a href="../../cmp/trait.ord/#tymethod.cmp" class="fnname">cmp</a>(&amp;self, __arg_0: &amp;<a class="struct" href="../struct.string/" title="std::string::String">String</a>) -&gt; <a class="enum" href="../../cmp/enum.ordering/" title="std::cmp::Ordering">Ordering</a></code></span></h4> <div class="docblock">
<p>This method returns an <code>Ordering</code> between <code>self</code> and <code>other</code>. <a href="../../cmp/trait.ord/#tymethod.cmp">Read more</a></p> </div>
<h3 class="impl">
<span class="in-band"><code>impl <a class="trait" href="../../convert/trait.asref/" title="std::convert::AsRef">AsRef</a>&lt;<a class="primitive" href="../../primitive.str/">str</a>&gt; for <a class="struct" href="../struct.string/" title="std::string::String">String</a></code></span><span class="out-of-band">
<a class="srclink" href="https://doc.rust-lang.org/src/collections/string.rs.html#1870-1875" title="goto source code" target="_blank">[src]</a></span>
</h3> <h4 id="method.as_ref" class="method"><span id="as_ref.v" class="invisible"><code>fn <a href="../../convert/trait.asref/#tymethod.as_ref" class="fnname">as_ref</a>(&amp;self) -&gt; &amp;<a class="primitive" href="../../primitive.str/">str</a></code></span></h4> <div class="docblock">
<p>Performs the conversion.</p> </div>
<h3 class="impl">
<span class="in-band"><code>impl <a class="trait" href="../../convert/trait.asref/" title="std::convert::AsRef">AsRef</a>&lt;<a class="primitive" href="../../primitive.slice/">[</a><a class="primitive" href="../../primitive.u8/">u8</a><a class="primitive" href="../../primitive.slice/">]</a>&gt; for <a class="struct" href="../struct.string/" title="std::string::String">String</a></code></span><span class="out-of-band">
<a class="srclink" href="https://doc.rust-lang.org/src/collections/string.rs.html#1878-1883" title="goto source code" target="_blank">[src]</a></span>
</h3> <h4 id="method.as_ref-1" class="method"><span id="as_ref.v-1" class="invisible"><code>fn <a href="../../convert/trait.asref/#tymethod.as_ref" class="fnname">as_ref</a>(&amp;self) -&gt; <a class="primitive" href="../../primitive.slice/">&amp;[</a><a class="primitive" href="../../primitive.u8/">u8</a><a class="primitive" href="../../primitive.slice/">]</a></code></span></h4> <div class="docblock">
<p>Performs the conversion.</p> </div>
<h3 class="impl">
<span class="in-band"><code>impl <a class="trait" href="../../ops/trait.indexmut/" title="std::ops::IndexMut">IndexMut</a>&lt;<a class="struct" href="../../ops/struct.range/" title="std::ops::Range">Range</a>&lt;<a class="primitive" href="../../primitive.usize/">usize</a>&gt;&gt; for <a class="struct" href="../struct.string/" title="std::string::String">String</a></code></span><span class="out-of-band">
<div class="since" title="Stable since Rust version 1.2.0">1.2.0</div>
<a class="srclink" href="https://doc.rust-lang.org/src/collections/string.rs.html#1707-1712" title="goto source code" target="_blank">[src]</a></span>
</h3> <h4 id="method.index_mut" class="method"><span id="index_mut.v" class="invisible"><code>fn <a href="../../ops/trait.indexmut/#tymethod.index_mut" class="fnname">index_mut</a>(&amp;mut self, index: <a class="struct" href="../../ops/struct.range/" title="std::ops::Range">Range</a>&lt;<a class="primitive" href="../../primitive.usize/">usize</a>&gt;) -&gt; &amp;mut <a class="primitive" href="../../primitive.str/">str</a></code></span></h4> <div class="docblock">
<p>The method for the mutable indexing (<code>container[index]</code>) operation</p> </div>
<h3 class="impl">
<span class="in-band"><code>impl <a class="trait" href="../../ops/trait.indexmut/" title="std::ops::IndexMut">IndexMut</a>&lt;<a class="struct" href="../../ops/struct.rangeto/" title="std::ops::RangeTo">RangeTo</a>&lt;<a class="primitive" href="../../primitive.usize/">usize</a>&gt;&gt; for <a class="struct" href="../struct.string/" title="std::string::String">String</a></code></span><span class="out-of-band">
<div class="since" title="Stable since Rust version 1.2.0">1.2.0</div>
<a class="srclink" href="https://doc.rust-lang.org/src/collections/string.rs.html#1714-1719" title="goto source code" target="_blank">[src]</a></span>
</h3> <h4 id="method.index_mut-1" class="method"><span id="index_mut.v-1" class="invisible"><code>fn <a href="../../ops/trait.indexmut/#tymethod.index_mut" class="fnname">index_mut</a>(&amp;mut self, index: <a class="struct" href="../../ops/struct.rangeto/" title="std::ops::RangeTo">RangeTo</a>&lt;<a class="primitive" href="../../primitive.usize/">usize</a>&gt;) -&gt; &amp;mut <a class="primitive" href="../../primitive.str/">str</a></code></span></h4> <div class="docblock">
<p>The method for the mutable indexing (<code>container[index]</code>) operation</p> </div>
<h3 class="impl">
<span class="in-band"><code>impl <a class="trait" href="../../ops/trait.indexmut/" title="std::ops::IndexMut">IndexMut</a>&lt;<a class="struct" href="../../ops/struct.rangefrom/" title="std::ops::RangeFrom">RangeFrom</a>&lt;<a class="primitive" href="../../primitive.usize/">usize</a>&gt;&gt; for <a class="struct" href="../struct.string/" title="std::string::String">String</a></code></span><span class="out-of-band">
<div class="since" title="Stable since Rust version 1.2.0">1.2.0</div>
<a class="srclink" href="https://doc.rust-lang.org/src/collections/string.rs.html#1721-1726" title="goto source code" target="_blank">[src]</a></span>
</h3> <h4 id="method.index_mut-2" class="method"><span id="index_mut.v-2" class="invisible"><code>fn <a href="../../ops/trait.indexmut/#tymethod.index_mut" class="fnname">index_mut</a>(&amp;mut self, index: <a class="struct" href="../../ops/struct.rangefrom/" title="std::ops::RangeFrom">RangeFrom</a>&lt;<a class="primitive" href="../../primitive.usize/">usize</a>&gt;) -&gt; &amp;mut <a class="primitive" href="../../primitive.str/">str</a></code></span></h4> <div class="docblock">
<p>The method for the mutable indexing (<code>container[index]</code>) operation</p> </div>
<h3 class="impl">
<span class="in-band"><code>impl <a class="trait" href="../../ops/trait.indexmut/" title="std::ops::IndexMut">IndexMut</a>&lt;<a class="struct" href="../../ops/struct.rangefull/" title="std::ops::RangeFull">RangeFull</a>&gt; for <a class="struct" href="../struct.string/" title="std::string::String">String</a></code></span><span class="out-of-band">
<div class="since" title="Stable since Rust version 1.2.0">1.2.0</div>
<a class="srclink" href="https://doc.rust-lang.org/src/collections/string.rs.html#1728-1733" title="goto source code" target="_blank">[src]</a></span>
</h3> <h4 id="method.index_mut-3" class="method"><span id="index_mut.v-3" class="invisible"><code>fn <a href="../../ops/trait.indexmut/#tymethod.index_mut" class="fnname">index_mut</a>(&amp;mut self, _index: <a class="struct" href="../../ops/struct.rangefull/" title="std::ops::RangeFull">RangeFull</a>) -&gt; &amp;mut <a class="primitive" href="../../primitive.str/">str</a></code></span></h4> <div class="docblock">
<p>The method for the mutable indexing (<code>container[index]</code>) operation</p> </div>
<h3 class="impl">
<span class="in-band"><code>impl <a class="trait" href="../../ops/trait.indexmut/" title="std::ops::IndexMut">IndexMut</a>&lt;<a class="enum" href="../../ops/enum.rangeinclusive/" title="std::ops::RangeInclusive">RangeInclusive</a>&lt;<a class="primitive" href="../../primitive.usize/">usize</a>&gt;&gt; for <a class="struct" href="../struct.string/" title="std::string::String">String</a></code></span><span class="out-of-band">
<a class="srclink" href="https://doc.rust-lang.org/src/collections/string.rs.html#1735-1740" title="goto source code" target="_blank">[src]</a></span>
</h3> <h4 id="method.index_mut-4" class="method"><span id="index_mut.v-4" class="invisible"><code>fn <a href="../../ops/trait.indexmut/#tymethod.index_mut" class="fnname">index_mut</a>(&amp;mut self, index: <a class="enum" href="../../ops/enum.rangeinclusive/" title="std::ops::RangeInclusive">RangeInclusive</a>&lt;<a class="primitive" href="../../primitive.usize/">usize</a>&gt;) -&gt; &amp;mut <a class="primitive" href="../../primitive.str/">str</a></code></span></h4> <div class="docblock">
<p>The method for the mutable indexing (<code>container[index]</code>) operation</p> </div>
<h3 class="impl">
<span class="in-band"><code>impl <a class="trait" href="../../ops/trait.indexmut/" title="std::ops::IndexMut">IndexMut</a>&lt;<a class="struct" href="../../ops/struct.rangetoinclusive/" title="std::ops::RangeToInclusive">RangeToInclusive</a>&lt;<a class="primitive" href="../../primitive.usize/">usize</a>&gt;&gt; for <a class="struct" href="../struct.string/" title="std::string::String">String</a></code></span><span class="out-of-band">
<a class="srclink" href="https://doc.rust-lang.org/src/collections/string.rs.html#1742-1747" title="goto source code" target="_blank">[src]</a></span>
</h3> <h4 id="method.index_mut-5" class="method"><span id="index_mut.v-5" class="invisible"><code>fn <a href="../../ops/trait.indexmut/#tymethod.index_mut" class="fnname">index_mut</a>(&amp;mut self, index: <a class="struct" href="../../ops/struct.rangetoinclusive/" title="std::ops::RangeToInclusive">RangeToInclusive</a>&lt;<a class="primitive" href="../../primitive.usize/">usize</a>&gt;) -&gt; &amp;mut <a class="primitive" href="../../primitive.str/">str</a></code></span></h4> <div class="docblock">
<p>The method for the mutable indexing (<code>container[index]</code>) operation</p> </div>
<h3 class="impl">
<span class="in-band"><code>impl <a class="trait" href="../../clone/trait.clone/" title="std::clone::Clone">Clone</a> for <a class="struct" href="../struct.string/" title="std::string::String">String</a></code></span><span class="out-of-band">
<a class="srclink" href="https://doc.rust-lang.org/src/collections/string.rs.html#1464-1472" title="goto source code" target="_blank">[src]</a></span>
</h3> <h4 id="method.clone" class="method"><span id="clone.v" class="invisible"><code>fn <a href="../../clone/trait.clone/#tymethod.clone" class="fnname">clone</a>(&amp;self) -&gt; <a class="struct" href="../struct.string/" title="std::string::String">String</a></code></span></h4> <div class="docblock">
<p>Returns a copy of the value. <a href="../../clone/trait.clone/#tymethod.clone">Read more</a></p> </div>
<h4 id="method.clone_from" class="method"><span id="clone_from.v" class="invisible"><code>fn <a href="../../clone/trait.clone/#method.clone_from" class="fnname">clone_from</a>(&amp;mut self, source: &amp;<a class="struct" href="../struct.string/" title="std::string::String">String</a>)</code></span></h4> <div class="docblock">
<p>Performs copy-assignment from <code>source</code>. <a href="../../clone/trait.clone/#method.clone_from">Read more</a></p> </div>
<h3 class="impl">
<span class="in-band"><code>impl&lt;'a&gt; <a class="trait" href="../../ops/trait.add/" title="std::ops::Add">Add</a>&lt;&amp;'a <a class="primitive" href="../../primitive.str/">str</a>&gt; for <a class="struct" href="../struct.string/" title="std::string::String">String</a></code></span><span class="out-of-band">
<a class="srclink" href="https://doc.rust-lang.org/src/collections/string.rs.html#1633-1641" title="goto source code" target="_blank">[src]</a></span>
</h3> <h4 id="associatedtype.Output" class="type"><span id="Output.t" class="invisible"><code>type <a href="../../ops/trait.add/#associatedtype.Output" class="type">Output</a> = <a class="struct" href="../struct.string/" title="std::string::String">String</a></code></span></h4> <div class="docblock">
<p>The resulting type after applying the <code>+</code> operator</p> </div>
<h4 id="method.add" class="method"><span id="add.v" class="invisible"><code>fn <a href="../../ops/trait.add/#tymethod.add" class="fnname">add</a>(self, other: &amp;<a class="primitive" href="../../primitive.str/">str</a>) -&gt; <a class="struct" href="../struct.string/" title="std::string::String">String</a></code></span></h4> <div class="docblock">
<p>The method for the <code>+</code> operator</p> </div>
<h3 class="impl">
<span class="in-band"><code>impl&lt;'a, 'b&gt; <a class="trait" href="../../str/pattern/trait.pattern/" title="std::str::pattern::Pattern">Pattern</a>&lt;'a&gt; for &amp;'b <a class="struct" href="../struct.string/" title="std::string::String">String</a></code></span><span class="out-of-band">
<a class="srclink" href="https://doc.rust-lang.org/src/collections/string.rs.html#1542-1558" title="goto source code" target="_blank">[src]</a></span>
</h3> <p>A convenience impl that delegates to the impl for <code>&amp;str</code></p> <h4 id="associatedtype.Searcher" class="type"><span id="Searcher.t" class="invisible"><code>type <a href="../../str/pattern/trait.pattern/#associatedtype.Searcher" class="type">Searcher</a> = &amp;'b <a class="primitive" href="../../primitive.str/">str</a>::<a class="trait" href="../../str/pattern/trait.pattern/" title="std::str::pattern::Pattern">Searcher</a></code></span></h4> <div class="stability"><span class="stab unstable">🔬 This is a nightly-only experimental API. (pattern #27721)API not fully fleshed out and ready to be stabilized </span></div>
<div class="docblock">
<p>Associated searcher for this pattern</p> </div>
<h4 id="method.into_searcher" class="method"><span id="into_searcher.v" class="invisible"><code>fn <a href="../../str/pattern/trait.pattern/#tymethod.into_searcher" class="fnname">into_searcher</a>(self, haystack: &amp;'a <a class="primitive" href="../../primitive.str/">str</a>) -&gt; &amp;'b <a class="primitive" href="../../primitive.str/">str</a>::<a class="trait" href="../../str/pattern/trait.pattern/" title="std::str::pattern::Pattern">Searcher</a></code></span></h4> <div class="stability"><span class="stab unstable">🔬 This is a nightly-only experimental API. (pattern #27721)API not fully fleshed out and ready to be stabilized </span></div>
<div class="docblock">
<p>Constructs the associated searcher from <code>self</code> and the <code>haystack</code> to search in. <a href="../../str/pattern/trait.pattern/#tymethod.into_searcher">Read more</a></p> </div>
<h4 id="method.is_contained_in" class="method"><span id="is_contained_in.v" class="invisible"><code>fn <a href="../../str/pattern/trait.pattern/#method.is_contained_in" class="fnname">is_contained_in</a>(self, haystack: &amp;'a <a class="primitive" href="../../primitive.str/">str</a>) -&gt; <a class="primitive" href="../../primitive.bool/">bool</a></code></span></h4> <div class="stability"><span class="stab unstable">🔬 This is a nightly-only experimental API. (pattern #27721)API not fully fleshed out and ready to be stabilized </span></div>
<div class="docblock">
<p>Checks whether the pattern matches anywhere in the haystack</p> </div>
<h4 id="method.is_prefix_of" class="method"><span id="is_prefix_of.v" class="invisible"><code>fn <a href="../../str/pattern/trait.pattern/#method.is_prefix_of" class="fnname">is_prefix_of</a>(self, haystack: &amp;'a <a class="primitive" href="../../primitive.str/">str</a>) -&gt; <a class="primitive" href="../../primitive.bool/">bool</a></code></span></h4> <div class="stability"><span class="stab unstable">🔬 This is a nightly-only experimental API. (pattern #27721)API not fully fleshed out and ready to be stabilized </span></div>
<div class="docblock">
<p>Checks whether the pattern matches at the front of the haystack</p> </div>
<h4 id="method.is_suffix_of" class="method"><span id="is_suffix_of.v" class="invisible"><code>fn <a href="../../str/pattern/trait.pattern/#method.is_suffix_of" class="fnname">is_suffix_of</a>(self, haystack: &amp;'a <a class="primitive" href="../../primitive.str/">str</a>) -&gt; <a class="primitive" href="../../primitive.bool/">bool</a> <span class="where fmt-newline">where Self::<a class="trait" href="../../str/pattern/trait.pattern/" title="std::str::pattern::Pattern">Searcher</a>: <a class="trait" href="../../str/pattern/trait.reversesearcher/" title="std::str::pattern::ReverseSearcher">ReverseSearcher</a>&lt;'a&gt;</span></code></span></h4> <div class="stability"><span class="stab unstable">🔬 This is a nightly-only experimental API. (pattern #27721)API not fully fleshed out and ready to be stabilized </span></div>
<div class="docblock">
<p>Checks whether the pattern matches at the back of the haystack</p> </div>
<h3 class="impl">
<span class="in-band"><code>impl <a class="trait" href="../../fmt/trait.debug/" title="std::fmt::Debug">Debug</a> for <a class="struct" href="../struct.string/" title="std::string::String">String</a></code></span><span class="out-of-band">
<a class="srclink" href="https://doc.rust-lang.org/src/collections/string.rs.html#1617-1622" title="goto source code" target="_blank">[src]</a></span>
</h3> <h4 id="method.fmt-1" class="method"><span id="fmt.v-1" class="invisible"><code>fn <a href="../../fmt/trait.debug/#tymethod.fmt" class="fnname">fmt</a>(&amp;self, f: &amp;mut <a class="struct" href="../../fmt/struct.formatter/" title="std::fmt::Formatter">Formatter</a>) -&gt; <a class="enum" href="../../result/enum.result/" title="std::result::Result">Result</a>&lt;<a class="primitive" href="../../primitive.tuple/">()</a>, <a class="struct" href="../../fmt/struct.error/" title="std::fmt::Error">Error</a>&gt;</code></span></h4> <div class="docblock">
<p>Formats the value using the given formatter.</p> </div>
<h3 class="impl">
<span class="in-band"><code>impl <a class="trait" href="../../default/trait.default/" title="std::default::Default">Default</a> for <a class="struct" href="../struct.string/" title="std::string::String">String</a></code></span><span class="out-of-band">
<a class="srclink" href="https://doc.rust-lang.org/src/collections/string.rs.html#1600-1606" title="goto source code" target="_blank">[src]</a></span>
</h3> <h4 id="method.default" class="method"><span id="default.v" class="invisible"><code>fn <a href="../../default/trait.default/#tymethod.default" class="fnname">default</a>() -&gt; <a class="struct" href="../struct.string/" title="std::string::String">String</a></code></span></h4> <div class="docblock">
<p>Creates an empty <code>String</code>.</p> </div>
<h3 class="impl">
<span class="in-band"><code>impl <a class="trait" href="../../iter/trait.fromiterator/" title="std::iter::FromIterator">FromIterator</a>&lt;<a class="primitive" href="../../primitive.char/">char</a>&gt; for <a class="struct" href="../struct.string/" title="std::string::String">String</a></code></span><span class="out-of-band">
<a class="srclink" href="https://doc.rust-lang.org/src/collections/string.rs.html#1475-1481" title="goto source code" target="_blank">[src]</a></span>
</h3> <h4 id="method.from_iter" class="method"><span id="from_iter.v" class="invisible"><code>fn <a href="../../iter/trait.fromiterator/#tymethod.from_iter" class="fnname">from_iter</a>&lt;I&gt;(iter: I) -&gt; <a class="struct" href="../struct.string/" title="std::string::String">String</a> <span class="where fmt-newline">where I: <a class="trait" href="../../iter/trait.intoiterator/" title="std::iter::IntoIterator">IntoIterator</a>&lt;Item=<a class="primitive" href="../../primitive.char/">char</a>&gt;</span></code></span></h4> <div class="docblock">
<p>Creates a value from an iterator. <a href="../../iter/trait.fromiterator/#tymethod.from_iter">Read more</a></p> </div>
<h3 class="impl">
<span class="in-band"><code>impl&lt;'a&gt; <a class="trait" href="../../iter/trait.fromiterator/" title="std::iter::FromIterator">FromIterator</a>&lt;&amp;'a <a class="primitive" href="../../primitive.str/">str</a>&gt; for <a class="struct" href="../struct.string/" title="std::string::String">String</a></code></span><span class="out-of-band">
<a class="srclink" href="https://doc.rust-lang.org/src/collections/string.rs.html#1484-1490" title="goto source code" target="_blank">[src]</a></span>
</h3> <h4 id="method.from_iter-1" class="method"><span id="from_iter.v-1" class="invisible"><code>fn <a href="../../iter/trait.fromiterator/#tymethod.from_iter" class="fnname">from_iter</a>&lt;I&gt;(iter: I) -&gt; <a class="struct" href="../struct.string/" title="std::string::String">String</a> <span class="where fmt-newline">where I: <a class="trait" href="../../iter/trait.intoiterator/" title="std::iter::IntoIterator">IntoIterator</a>&lt;Item=&amp;'a <a class="primitive" href="../../primitive.str/">str</a>&gt;</span></code></span></h4> <div class="docblock">
<p>Creates a value from an iterator. <a href="../../iter/trait.fromiterator/#tymethod.from_iter">Read more</a></p> </div>
<h3 class="impl">
<span class="in-band"><code>impl <a class="trait" href="../../iter/trait.fromiterator/" title="std::iter::FromIterator">FromIterator</a>&lt;<a class="struct" href="../struct.string/" title="std::string::String">String</a>&gt; for <a class="struct" href="../struct.string/" title="std::string::String">String</a></code></span><span class="out-of-band">
<div class="since" title="Stable since Rust version 1.4.0">1.4.0</div>
<a class="srclink" href="https://doc.rust-lang.org/src/collections/string.rs.html#1493-1499" title="goto source code" target="_blank">[src]</a></span>
</h3> <h4 id="method.from_iter-2" class="method"><span id="from_iter.v-2" class="invisible"><code>fn <a href="../../iter/trait.fromiterator/#tymethod.from_iter" class="fnname">from_iter</a>&lt;I&gt;(iter: I) -&gt; <a class="struct" href="../struct.string/" title="std::string::String">String</a> <span class="where fmt-newline">where I: <a class="trait" href="../../iter/trait.intoiterator/" title="std::iter::IntoIterator">IntoIterator</a>&lt;Item=<a class="struct" href="../struct.string/" title="std::string::String">String</a>&gt;</span></code></span></h4> <div class="docblock">
<p>Creates a value from an iterator. <a href="../../iter/trait.fromiterator/#tymethod.from_iter">Read more</a></p> </div>
<h3 class="impl">
<span class="in-band"><code>impl <a class="trait" href="../../ops/trait.deref/" title="std::ops::Deref">Deref</a> for <a class="struct" href="../struct.string/" title="std::string::String">String</a></code></span><span class="out-of-band">
<a class="srclink" href="https://doc.rust-lang.org/src/collections/string.rs.html#1750-1757" title="goto source code" target="_blank">[src]</a></span>
</h3> <h4 id="associatedtype.Target" class="type"><span id="Target.t" class="invisible"><code>type <a href="../../ops/trait.deref/#associatedtype.Target" class="type">Target</a> = <a class="primitive" href="../../primitive.str/">str</a></code></span></h4> <div class="docblock">
<p>The resulting type after dereferencing</p> </div>
<h4 id="method.deref" class="method"><span id="deref.v" class="invisible"><code>fn <a href="../../ops/trait.deref/#tymethod.deref" class="fnname">deref</a>(&amp;self) -&gt; &amp;<a class="primitive" href="../../primitive.str/">str</a></code></span></h4> <div class="docblock">
<p>The method called to dereference a value</p> </div>
<h3 class="impl">
<span class="in-band"><code>impl <a class="trait" href="../../ops/trait.index/" title="std::ops::Index">Index</a>&lt;<a class="struct" href="../../ops/struct.range/" title="std::ops::Range">Range</a>&lt;<a class="primitive" href="../../primitive.usize/">usize</a>&gt;&gt; for <a class="struct" href="../struct.string/" title="std::string::String">String</a></code></span><span class="out-of-band">
<a class="srclink" href="https://doc.rust-lang.org/src/collections/string.rs.html#1652-1659" title="goto source code" target="_blank">[src]</a></span>
</h3> <h4 id="associatedtype.Output-1" class="type"><span id="Output.t-1" class="invisible"><code>type <a href="../../ops/trait.index/#associatedtype.Output" class="type">Output</a> = <a class="primitive" href="../../primitive.str/">str</a></code></span></h4> <div class="docblock">
<p>The returned type after indexing</p> </div>
<h4 id="method.index" class="method"><span id="index.v" class="invisible"><code>fn <a href="../../ops/trait.index/#tymethod.index" class="fnname">index</a>(&amp;self, index: <a class="struct" href="../../ops/struct.range/" title="std::ops::Range">Range</a>&lt;<a class="primitive" href="../../primitive.usize/">usize</a>&gt;) -&gt; &amp;<a class="primitive" href="../../primitive.str/">str</a></code></span></h4> <div class="docblock">
<p>The method for the indexing (<code>container[index]</code>) operation</p> </div>
<h3 class="impl">
<span class="in-band"><code>impl <a class="trait" href="../../ops/trait.index/" title="std::ops::Index">Index</a>&lt;<a class="struct" href="../../ops/struct.rangeto/" title="std::ops::RangeTo">RangeTo</a>&lt;<a class="primitive" href="../../primitive.usize/">usize</a>&gt;&gt; for <a class="struct" href="../struct.string/" title="std::string::String">String</a></code></span><span class="out-of-band">
<a class="srclink" href="https://doc.rust-lang.org/src/collections/string.rs.html#1661-1668" title="goto source code" target="_blank">[src]</a></span>
</h3> <h4 id="associatedtype.Output-2" class="type"><span id="Output.t-2" class="invisible"><code>type <a href="../../ops/trait.index/#associatedtype.Output" class="type">Output</a> = <a class="primitive" href="../../primitive.str/">str</a></code></span></h4> <div class="docblock">
<p>The returned type after indexing</p> </div>
<h4 id="method.index-1" class="method"><span id="index.v-1" class="invisible"><code>fn <a href="../../ops/trait.index/#tymethod.index" class="fnname">index</a>(&amp;self, index: <a class="struct" href="../../ops/struct.rangeto/" title="std::ops::RangeTo">RangeTo</a>&lt;<a class="primitive" href="../../primitive.usize/">usize</a>&gt;) -&gt; &amp;<a class="primitive" href="../../primitive.str/">str</a></code></span></h4> <div class="docblock">
<p>The method for the indexing (<code>container[index]</code>) operation</p> </div>
<h3 class="impl">
<span class="in-band"><code>impl <a class="trait" href="../../ops/trait.index/" title="std::ops::Index">Index</a>&lt;<a class="struct" href="../../ops/struct.rangefrom/" title="std::ops::RangeFrom">RangeFrom</a>&lt;<a class="primitive" href="../../primitive.usize/">usize</a>&gt;&gt; for <a class="struct" href="../struct.string/" title="std::string::String">String</a></code></span><span class="out-of-band">
<a class="srclink" href="https://doc.rust-lang.org/src/collections/string.rs.html#1670-1677" title="goto source code" target="_blank">[src]</a></span>
</h3> <h4 id="associatedtype.Output-3" class="type"><span id="Output.t-3" class="invisible"><code>type <a href="../../ops/trait.index/#associatedtype.Output" class="type">Output</a> = <a class="primitive" href="../../primitive.str/">str</a></code></span></h4> <div class="docblock">
<p>The returned type after indexing</p> </div>
<h4 id="method.index-2" class="method"><span id="index.v-2" class="invisible"><code>fn <a href="../../ops/trait.index/#tymethod.index" class="fnname">index</a>(&amp;self, index: <a class="struct" href="../../ops/struct.rangefrom/" title="std::ops::RangeFrom">RangeFrom</a>&lt;<a class="primitive" href="../../primitive.usize/">usize</a>&gt;) -&gt; &amp;<a class="primitive" href="../../primitive.str/">str</a></code></span></h4> <div class="docblock">
<p>The method for the indexing (<code>container[index]</code>) operation</p> </div>
<h3 class="impl">
<span class="in-band"><code>impl <a class="trait" href="../../ops/trait.index/" title="std::ops::Index">Index</a>&lt;<a class="struct" href="../../ops/struct.rangefull/" title="std::ops::RangeFull">RangeFull</a>&gt; for <a class="struct" href="../struct.string/" title="std::string::String">String</a></code></span><span class="out-of-band">
<a class="srclink" href="https://doc.rust-lang.org/src/collections/string.rs.html#1679-1686" title="goto source code" target="_blank">[src]</a></span>
</h3> <h4 id="associatedtype.Output-4" class="type"><span id="Output.t-4" class="invisible"><code>type <a href="../../ops/trait.index/#associatedtype.Output" class="type">Output</a> = <a class="primitive" href="../../primitive.str/">str</a></code></span></h4> <div class="docblock">
<p>The returned type after indexing</p> </div>
<h4 id="method.index-3" class="method"><span id="index.v-3" class="invisible"><code>fn <a href="../../ops/trait.index/#tymethod.index" class="fnname">index</a>(&amp;self, _index: <a class="struct" href="../../ops/struct.rangefull/" title="std::ops::RangeFull">RangeFull</a>) -&gt; &amp;<a class="primitive" href="../../primitive.str/">str</a></code></span></h4> <div class="docblock">
<p>The method for the indexing (<code>container[index]</code>) operation</p> </div>
<h3 class="impl">
<span class="in-band"><code>impl <a class="trait" href="../../ops/trait.index/" title="std::ops::Index">Index</a>&lt;<a class="enum" href="../../ops/enum.rangeinclusive/" title="std::ops::RangeInclusive">RangeInclusive</a>&lt;<a class="primitive" href="../../primitive.usize/">usize</a>&gt;&gt; for <a class="struct" href="../struct.string/" title="std::string::String">String</a></code></span><span class="out-of-band">
<a class="srclink" href="https://doc.rust-lang.org/src/collections/string.rs.html#1688-1695" title="goto source code" target="_blank">[src]</a></span>
</h3> <h4 id="associatedtype.Output-5" class="type"><span id="Output.t-5" class="invisible"><code>type <a href="../../ops/trait.index/#associatedtype.Output" class="type">Output</a> = <a class="primitive" href="../../primitive.str/">str</a></code></span></h4> <div class="docblock">
<p>The returned type after indexing</p> </div>
<h4 id="method.index-4" class="method"><span id="index.v-4" class="invisible"><code>fn <a href="../../ops/trait.index/#tymethod.index" class="fnname">index</a>(&amp;self, index: <a class="enum" href="../../ops/enum.rangeinclusive/" title="std::ops::RangeInclusive">RangeInclusive</a>&lt;<a class="primitive" href="../../primitive.usize/">usize</a>&gt;) -&gt; &amp;<a class="primitive" href="../../primitive.str/">str</a></code></span></h4> <div class="docblock">
<p>The method for the indexing (<code>container[index]</code>) operation</p> </div>
<h3 class="impl">
<span class="in-band"><code>impl <a class="trait" href="../../ops/trait.index/" title="std::ops::Index">Index</a>&lt;<a class="struct" href="../../ops/struct.rangetoinclusive/" title="std::ops::RangeToInclusive">RangeToInclusive</a>&lt;<a class="primitive" href="../../primitive.usize/">usize</a>&gt;&gt; for <a class="struct" href="../struct.string/" title="std::string::String">String</a></code></span><span class="out-of-band">
<a class="srclink" href="https://doc.rust-lang.org/src/collections/string.rs.html#1697-1704" title="goto source code" target="_blank">[src]</a></span>
</h3> <h4 id="associatedtype.Output-6" class="type"><span id="Output.t-6" class="invisible"><code>type <a href="../../ops/trait.index/#associatedtype.Output" class="type">Output</a> = <a class="primitive" href="../../primitive.str/">str</a></code></span></h4> <div class="docblock">
<p>The returned type after indexing</p> </div>
<h4 id="method.index-5" class="method"><span id="index.v-5" class="invisible"><code>fn <a href="../../ops/trait.index/#tymethod.index" class="fnname">index</a>(&amp;self, index: <a class="struct" href="../../ops/struct.rangetoinclusive/" title="std::ops::RangeToInclusive">RangeToInclusive</a>&lt;<a class="primitive" href="../../primitive.usize/">usize</a>&gt;) -&gt; &amp;<a class="primitive" href="../../primitive.str/">str</a></code></span></h4> <div class="docblock">
<p>The method for the indexing (<code>container[index]</code>) operation</p> </div>
<h3 class="impl">
<span class="in-band"><code>impl&lt;'a&gt; <a class="trait" href="../../ops/trait.addassign/" title="std::ops::AddAssign">AddAssign</a>&lt;&amp;'a <a class="primitive" href="../../primitive.str/">str</a>&gt; for <a class="struct" href="../struct.string/" title="std::string::String">String</a></code></span><span class="out-of-band">
<div class="since" title="Stable since Rust version 1.12.0">1.12.0</div>
<a class="srclink" href="https://doc.rust-lang.org/src/collections/string.rs.html#1644-1649" title="goto source code" target="_blank">[src]</a></span>
</h3> <h4 id="method.add_assign" class="method"><span id="add_assign.v" class="invisible"><code>fn <a href="../../ops/trait.addassign/#tymethod.add_assign" class="fnname">add_assign</a>(&amp;mut self, other: &amp;<a class="primitive" href="../../primitive.str/">str</a>)</code></span></h4> <div class="docblock">
<p>The method for the <code>+=</code> operator</p> </div>
<h3 class="impl">
<span class="in-band"><code>impl <a class="trait" href="../../cmp/trait.partialeq/" title="std::cmp::PartialEq">PartialEq</a>&lt;<a class="struct" href="../struct.string/" title="std::string::String">String</a>&gt; for <a class="struct" href="../struct.string/" title="std::string::String">String</a></code></span><span class="out-of-band">
<a class="srclink" href="https://doc.rust-lang.org/src/collections/string.rs.html#1561-1570" title="goto source code" target="_blank">[src]</a></span>
</h3> <h4 id="method.eq" class="method"><span id="eq.v" class="invisible"><code>fn <a href="../../cmp/trait.partialeq/#tymethod.eq" class="fnname">eq</a>(&amp;self, other: &amp;<a class="struct" href="../struct.string/" title="std::string::String">String</a>) -&gt; <a class="primitive" href="../../primitive.bool/">bool</a></code></span></h4> <div class="docblock">
<p>This method tests for <code>self</code> and <code>other</code> values to be equal, and is used by <code>==</code>. <a href="../../cmp/trait.partialeq/#tymethod.eq">Read more</a></p> </div>
<h4 id="method.ne" class="method"><span id="ne.v" class="invisible"><code>fn <a href="../../cmp/trait.partialeq/#method.ne" class="fnname">ne</a>(&amp;self, other: &amp;<a class="struct" href="../struct.string/" title="std::string::String">String</a>) -&gt; <a class="primitive" href="../../primitive.bool/">bool</a></code></span></h4> <div class="docblock">
<p>This method tests for <code>!=</code>.</p> </div>
<h3 class="impl">
<span class="in-band"><code>impl&lt;'a, 'b&gt; <a class="trait" href="../../cmp/trait.partialeq/" title="std::cmp::PartialEq">PartialEq</a>&lt;<a class="primitive" href="../../primitive.str/">str</a>&gt; for <a class="struct" href="../struct.string/" title="std::string::String">String</a></code></span><span class="out-of-band">
<a class="srclink" href="https://doc.rust-lang.org/src/collections/string.rs.html#1575-1580" title="goto source code" target="_blank">[src]</a></span>
</h3> <h4 id="method.eq-1" class="method"><span id="eq.v-1" class="invisible"><code>fn <a href="../../cmp/trait.partialeq/#tymethod.eq" class="fnname">eq</a>(&amp;self, other: &amp;<a class="primitive" href="../../primitive.str/">str</a>) -&gt; <a class="primitive" href="../../primitive.bool/">bool</a></code></span></h4> <div class="docblock">
<p>This method tests for <code>self</code> and <code>other</code> values to be equal, and is used by <code>==</code>. <a href="../../cmp/trait.partialeq/#tymethod.eq">Read more</a></p> </div>
<h4 id="method.ne-1" class="method"><span id="ne.v-1" class="invisible"><code>fn <a href="../../cmp/trait.partialeq/#method.ne" class="fnname">ne</a>(&amp;self, other: &amp;<a class="primitive" href="../../primitive.str/">str</a>) -&gt; <a class="primitive" href="../../primitive.bool/">bool</a></code></span></h4> <div class="docblock">
<p>This method tests for <code>!=</code>.</p> </div>
<h3 class="impl">
<span class="in-band"><code>impl&lt;'a, 'b&gt; <a class="trait" href="../../cmp/trait.partialeq/" title="std::cmp::PartialEq">PartialEq</a>&lt;&amp;'a <a class="primitive" href="../../primitive.str/">str</a>&gt; for <a class="struct" href="../struct.string/" title="std::string::String">String</a></code></span><span class="out-of-band">
<a class="srclink" href="https://doc.rust-lang.org/src/collections/string.rs.html#1575-1580" title="goto source code" target="_blank">[src]</a></span>
</h3> <h4 id="method.eq-2" class="method"><span id="eq.v-2" class="invisible"><code>fn <a href="../../cmp/trait.partialeq/#tymethod.eq" class="fnname">eq</a>(&amp;self, other: &amp;&amp;'a <a class="primitive" href="../../primitive.str/">str</a>) -&gt; <a class="primitive" href="../../primitive.bool/">bool</a></code></span></h4> <div class="docblock">
<p>This method tests for <code>self</code> and <code>other</code> values to be equal, and is used by <code>==</code>. <a href="../../cmp/trait.partialeq/#tymethod.eq">Read more</a></p> </div>
<h4 id="method.ne-2" class="method"><span id="ne.v-2" class="invisible"><code>fn <a href="../../cmp/trait.partialeq/#method.ne" class="fnname">ne</a>(&amp;self, other: &amp;&amp;'a <a class="primitive" href="../../primitive.str/">str</a>) -&gt; <a class="primitive" href="../../primitive.bool/">bool</a></code></span></h4> <div class="docblock">
<p>This method tests for <code>!=</code>.</p> </div>
<h3 class="impl">
<span class="in-band"><code>impl&lt;'a, 'b&gt; <a class="trait" href="../../cmp/trait.partialeq/" title="std::cmp::PartialEq">PartialEq</a>&lt;<a class="enum" href="../../borrow/enum.cow/" title="std::borrow::Cow">Cow</a>&lt;'a, <a class="primitive" href="../../primitive.str/">str</a>&gt;&gt; for <a class="struct" href="../struct.string/" title="std::string::String">String</a></code></span><span class="out-of-band">
<a class="srclink" href="https://doc.rust-lang.org/src/collections/string.rs.html#1583-1588" title="goto source code" target="_blank">[src]</a></span>
</h3> <h4 id="method.eq-3" class="method"><span id="eq.v-3" class="invisible"><code>fn <a href="../../cmp/trait.partialeq/#tymethod.eq" class="fnname">eq</a>(&amp;self, other: &amp;<a class="enum" href="../../borrow/enum.cow/" title="std::borrow::Cow">Cow</a>&lt;'a, <a class="primitive" href="../../primitive.str/">str</a>&gt;) -&gt; <a class="primitive" href="../../primitive.bool/">bool</a></code></span></h4> <div class="docblock">
<p>This method tests for <code>self</code> and <code>other</code> values to be equal, and is used by <code>==</code>. <a href="../../cmp/trait.partialeq/#tymethod.eq">Read more</a></p> </div>
<h4 id="method.ne-3" class="method"><span id="ne.v-3" class="invisible"><code>fn <a href="../../cmp/trait.partialeq/#method.ne" class="fnname">ne</a>(&amp;self, other: &amp;<a class="enum" href="../../borrow/enum.cow/" title="std::borrow::Cow">Cow</a>&lt;'a, <a class="primitive" href="../../primitive.str/">str</a>&gt;) -&gt; <a class="primitive" href="../../primitive.bool/">bool</a></code></span></h4> <div class="docblock">
<p>This method tests for <code>!=</code>.</p> </div>
<h3 class="impl">
<span class="in-band"><code>impl <a class="trait" href="../../fmt/trait.write/" title="std::fmt::Write">Write</a> for <a class="struct" href="../struct.string/" title="std::string::String">String</a></code></span><span class="out-of-band">
<a class="srclink" href="https://doc.rust-lang.org/src/collections/string.rs.html#1944-1956" title="goto source code" target="_blank">[src]</a></span>
</h3> <h4 id="method.write_str" class="method"><span id="write_str.v" class="invisible"><code>fn <a href="../../fmt/trait.write/#tymethod.write_str" class="fnname">write_str</a>(&amp;mut self, s: &amp;<a class="primitive" href="../../primitive.str/">str</a>) -&gt; <a class="enum" href="../../result/enum.result/" title="std::result::Result">Result</a>&lt;<a class="primitive" href="../../primitive.tuple/">()</a>, <a class="struct" href="../../fmt/struct.error/" title="std::fmt::Error">Error</a>&gt;</code></span></h4> <div class="docblock">
<p>Writes a slice of bytes into this writer, returning whether the write succeeded. <a href="../../fmt/trait.write/#tymethod.write_str">Read more</a></p> </div>
<h4 id="method.write_char" class="method"><span id="write_char.v" class="invisible"><code>fn <a href="../../fmt/trait.write/#method.write_char" class="fnname">write_char</a>(&amp;mut self, c: <a class="primitive" href="../../primitive.char/">char</a>) -&gt; <a class="enum" href="../../result/enum.result/" title="std::result::Result">Result</a>&lt;<a class="primitive" href="../../primitive.tuple/">()</a>, <a class="struct" href="../../fmt/struct.error/" title="std::fmt::Error">Error</a>&gt;</code></span></h4> <div class="docblock">
<p>Writes a <code>char</code> into this writer, returning whether the write succeeded. <a href="../../fmt/trait.write/#method.write_char">Read more</a></p> </div>
<h4 id="method.write_fmt" class="method"><span id="write_fmt.v" class="invisible"><code>fn <a href="../../fmt/trait.write/#method.write_fmt" class="fnname">write_fmt</a>(&amp;mut self, args: <a class="struct" href="../../fmt/struct.arguments/" title="std::fmt::Arguments">Arguments</a>) -&gt; <a class="enum" href="../../result/enum.result/" title="std::result::Result">Result</a>&lt;<a class="primitive" href="../../primitive.tuple/">()</a>, <a class="struct" href="../../fmt/struct.error/" title="std::fmt::Error">Error</a>&gt;</code></span></h4> <div class="docblock">
<p>Glue for usage of the <code>write!</code> macro with implementors of this trait. <a href="../../fmt/trait.write/#method.write_fmt">Read more</a></p> </div>
<h3 class="impl">
<span class="in-band"><code>impl <a class="trait" href="../../borrow/trait.borrow/" title="std::borrow::Borrow">Borrow</a>&lt;<a class="primitive" href="../../primitive.str/">str</a>&gt; for <a class="struct" href="../struct.string/" title="std::string::String">String</a></code></span><span class="out-of-band">
<a class="srclink" href="https://doc.rust-lang.org/src/collections/str.rs.html#156-161" title="goto source code" target="_blank">[src]</a></span>
</h3> <h4 id="method.borrow" class="method"><span id="borrow.v" class="invisible"><code>fn <a href="../../borrow/trait.borrow/#tymethod.borrow" class="fnname">borrow</a>(&amp;self) -&gt; &amp;<a class="primitive" href="../../primitive.str/">str</a></code></span></h4> <div class="docblock">
<p>Immutably borrows from an owned value. <a href="../../borrow/trait.borrow/#tymethod.borrow">Read more</a></p> </div>
<h3 class="impl">
<span class="in-band"><code>impl <a class="trait" href="../../convert/trait.asref/" title="std::convert::AsRef">AsRef</a>&lt;<a class="struct" href="../../ffi/struct.osstr/" title="std::ffi::OsStr">OsStr</a>&gt; for <a class="struct" href="../struct.string/" title="std::string::String">String</a></code></span><span class="out-of-band">
<a class="srclink" href="https://doc.rust-lang.org/src/std/ffi/os_str.rs.html#600-604" title="goto source code" target="_blank">[src]</a></span>
</h3> <h4 id="method.as_ref-2" class="method"><span id="as_ref.v-2" class="invisible"><code>fn <a href="../../convert/trait.asref/#tymethod.as_ref" class="fnname">as_ref</a>(&amp;self) -&gt; &amp;<a class="struct" href="../../ffi/struct.osstr/" title="std::ffi::OsStr">OsStr</a></code></span></h4> <div class="docblock">
<p>Performs the conversion.</p> </div>
<h3 class="impl">
<span class="in-band"><code>impl <a class="trait" href="../../net/trait.tosocketaddrs/" title="std::net::ToSocketAddrs">ToSocketAddrs</a> for <a class="struct" href="../struct.string/" title="std::string::String">String</a></code></span><span class="out-of-band">
<div class="since" title="Stable since Rust version 1.16.0">1.16.0</div>
<a class="srclink" href="https://doc.rust-lang.org/src/std/net/addr.rs.html#760-765" title="goto source code" target="_blank">[src]</a></span>
</h3> <h4 id="associatedtype.Iter" class="type"><span id="Iter.t" class="invisible"><code>type <a href="../../net/trait.tosocketaddrs/#associatedtype.Iter" class="type">Iter</a> = <a class="struct" href="../../vec/struct.intoiter/" title="std::vec::IntoIter">IntoIter</a>&lt;<a class="enum" href="../../net/enum.socketaddr/" title="std::net::SocketAddr">SocketAddr</a>&gt;</code></span></h4> <div class="docblock">
<p>Returned iterator over socket addresses which this type may correspond to. <a href="../../net/trait.tosocketaddrs/#associatedtype.Iter">Read more</a></p> </div>
<h4 id="method.to_socket_addrs" class="method"><span id="to_socket_addrs.v" class="invisible"><code>fn <a href="../../net/trait.tosocketaddrs/#tymethod.to_socket_addrs" class="fnname">to_socket_addrs</a>(&amp;self) -&gt; <a class="type" href="../../io/type.result/" title="std::io::Result">Result</a>&lt;<a class="struct" href="../../vec/struct.intoiter/" title="std::vec::IntoIter">IntoIter</a>&lt;<a class="enum" href="../../net/enum.socketaddr/" title="std::net::SocketAddr">SocketAddr</a>&gt;&gt;</code></span></h4> <div class="docblock">
<p>Converts this object to an iterator of resolved <code>SocketAddr</code>s. <a href="../../net/trait.tosocketaddrs/#tymethod.to_socket_addrs">Read more</a></p> </div>
<h3 class="impl">
<span class="in-band"><code>impl <a class="trait" href="../../convert/trait.asref/" title="std::convert::AsRef">AsRef</a>&lt;<a class="struct" href="../../path/struct.path/" title="std::path::Path">Path</a>&gt; for <a class="struct" href="../struct.string/" title="std::string::String">String</a></code></span><span class="out-of-band">
<a class="srclink" href="https://doc.rust-lang.org/src/std/path.rs.html#2168-2172" title="goto source code" target="_blank">[src]</a></span>
</h3> <h4 id="method.as_ref-3" class="method"><span id="as_ref.v-3" class="invisible"><code>fn <a href="../../convert/trait.asref/#tymethod.as_ref" class="fnname">as_ref</a>(&amp;self) -&gt; &amp;<a class="struct" href="../../path/struct.path/" title="std::path::Path">Path</a></code></span></h4> <div class="docblock">
<p>Performs the conversion.</p> </div>
<div class="_attribution">
  <p class="_attribution-p">
    © 2010 The Rust Project Developers<br>Licensed under the Apache License, Version 2.0 or the MIT license, at your option.<br>
    <a href="https://doc.rust-lang.org/std/string/struct.String.html" class="_attribution-link" target="_blank">https://doc.rust-lang.org/std/string/struct.String.html</a>
  </p>
</div>

			</div>
		</div>
	</section>

	</div>
</body>
</html>
