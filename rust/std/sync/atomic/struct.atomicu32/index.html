
<!DOCTYPE HTML>

<html lang="en">

<head>
  <meta charset="utf-8">
  <title>std&#58;&#58;sync&#58;&#58;atomic&#58;&#58;AtomicU32 - Rust - W3cubDocs</title>
  
  <meta name="description" content=" An integer type which can be safely shared between threads. ">
  <meta name="keywords" content="struct, std, sync, atomic, atomicu, -, rust">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="http://docs.w3cub.com/rust/std/sync/atomic/struct.atomicu32/">
  <link href="/favicon.png" rel="icon">
  <link type="text/css" rel="stylesheet" href="/assets/application-50364fff564ce3b6327021805f3f00e2957b441cf27f576a7dd4ff63bbc47047.css">
  <script type="text/javascript" src="/assets/application-db64bfd54ceb42be11af7995804cf4902548419ceb79d509b0b7d62c22d98e6f.js"></script>
  <script src="/json/rust.js"></script>
  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-71174418-1']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>


</head>

<body>
	<div class="_app">
	<header class="_header">
  
  <form class="_search">
    <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
    <a class="_search-clear"></a>
    <div class="_search-tag"></div>
  </form>
  
  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/rust/" class="_nav-link" title="" style="margin-left:0;">Rust</a></span>
  
  <nav class="_nav">
    <a href="/app/" class="_nav-link ">App</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		<div class="_list">
			
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<div class="_page _rust">
				
<h1 class="fqn">Struct std::sync::atomic::AtomicU32</h1> <pre class="rust struct" data-language="rust">pub struct AtomicU32 { /* fields omitted */ }</pre>
<div class="stability"><span class="stab unstable">ðŸ”¬ This is a nightly-only experimental API. (integer_atomics #32976)</span></div>
<p>An integer type which can be safely shared between threads.</p> <p>This type has the same in-memory representation as the underlying integer type.</p> <h2 id="methods">Methods</h2>
<h3 class="impl">
<span class="in-band"><code>impl <a class="struct" href="../struct.atomicu32/" title="std::sync::atomic::AtomicU32">AtomicU32</a></code></span><span class="out-of-band">
<a class="srclink" href="https://doc.rust-lang.org/src/core/sync/atomic.rs.html#907-1253" title="goto source code" target="_blank">[src]</a></span>
</h3> <h4 id="method.new" class="method"><span id="new.v" class="invisible"><code>fn <a href="#method.new" class="fnname">new</a>(v: <a class="primitive" href="../../../primitive.u32/">u32</a>) -&gt; <a class="struct" href="../struct.atomicu32/" title="std::sync::atomic::AtomicU32">AtomicU32</a></code></span></h4> <div class="stability"><span class="stab unstable">ðŸ”¬ This is a nightly-only experimental API. (integer_atomics #32976)</span></div>
<div class="docblock">
<p>Creates a new atomic integer.</p> <h4 id="examples" class="section-header">Examples</h4> <pre class="rust rust-example-rendered" data-language="rust">
use std::sync::atomic::AtomicIsize;

let atomic_forty_two  = AtomicIsize::new(42);</pre> </div>
<h4 id="method.get_mut" class="method"><span id="get_mut.v" class="invisible"><code>fn <a href="#method.get_mut" class="fnname">get_mut</a>(&amp;mut self) -&gt; &amp;mut <a class="primitive" href="../../../primitive.u32/">u32</a></code></span></h4> <div class="stability"><span class="stab unstable">ðŸ”¬ This is a nightly-only experimental API. (integer_atomics #32976)</span></div>
<div class="docblock">
<p>Returns a mutable reference to the underlying integer.</p> <p>This is safe because the mutable reference guarantees that no other threads are concurrently accessing the atomic data.</p> <h4 id="examples-1" class="section-header">Examples</h4> <pre class="rust rust-example-rendered" data-language="rust">
use std::sync::atomic::{AtomicIsize, Ordering};

let mut some_isize = AtomicIsize::new(10);
assert_eq!(*some_isize.get_mut(), 10);
*some_isize.get_mut() = 5;
assert_eq!(some_isize.load(Ordering::SeqCst), 5);</pre> </div>
<h4 id="method.into_inner" class="method"><span id="into_inner.v" class="invisible"><code>fn <a href="#method.into_inner" class="fnname">into_inner</a>(self) -&gt; <a class="primitive" href="../../../primitive.u32/">u32</a></code></span></h4> <div class="stability"><span class="stab unstable">ðŸ”¬ This is a nightly-only experimental API. (integer_atomics #32976)</span></div>
<div class="docblock">
<p>Consumes the atomic and returns the contained value.</p> <p>This is safe because passing <code>self</code> by value guarantees that no other threads are concurrently accessing the atomic data.</p> <h4 id="examples-2" class="section-header">Examples</h4> <pre class="rust rust-example-rendered" data-language="rust">
use std::sync::atomic::AtomicIsize;

let some_isize = AtomicIsize::new(5);
assert_eq!(some_isize.into_inner(), 5);</pre> </div>
<h4 id="method.load" class="method"><span id="load.v" class="invisible"><code>fn <a href="#method.load" class="fnname">load</a>(&amp;self, order: <a class="enum" href="../enum.ordering/" title="std::sync::atomic::Ordering">Ordering</a>) -&gt; <a class="primitive" href="../../../primitive.u32/">u32</a></code></span></h4> <div class="stability"><span class="stab unstable">ðŸ”¬ This is a nightly-only experimental API. (integer_atomics #32976)</span></div>
<div class="docblock">
<p>Loads a value from the atomic integer.</p> <p><code>load</code> takes an <a href="../enum.ordering/"><code>Ordering</code></a> argument which describes the memory ordering of this operation.</p> <h4 id="panics" class="section-header">Panics</h4> <p>Panics if <code>order</code> is <a href="../enum.ordering/#variant.Release"><code>Release</code></a> or <a href="../enum.ordering/#variant.AcqRel"><code>AcqRel</code></a>.</p> <h4 id="examples-3" class="section-header">Examples</h4> <pre class="rust rust-example-rendered" data-language="rust">
use std::sync::atomic::{AtomicIsize, Ordering};

let some_isize = AtomicIsize::new(5);

assert_eq!(some_isize.load(Ordering::Relaxed), 5);</pre> </div>
<h4 id="method.store" class="method"><span id="store.v" class="invisible"><code>fn <a href="#method.store" class="fnname">store</a>(&amp;self, val: <a class="primitive" href="../../../primitive.u32/">u32</a>, order: <a class="enum" href="../enum.ordering/" title="std::sync::atomic::Ordering">Ordering</a>)</code></span></h4> <div class="stability"><span class="stab unstable">ðŸ”¬ This is a nightly-only experimental API. (integer_atomics #32976)</span></div>
<div class="docblock">
<p>Stores a value into the atomic integer.</p> <p><code>store</code> takes an <a href="../enum.ordering/"><code>Ordering</code></a> argument which describes the memory ordering of this operation.</p> <h4 id="examples-4" class="section-header">Examples</h4> <pre class="rust rust-example-rendered" data-language="rust">
use std::sync::atomic::{AtomicIsize, Ordering};

let some_isize = AtomicIsize::new(5);

some_isize.store(10, Ordering::Relaxed);
assert_eq!(some_isize.load(Ordering::Relaxed), 10);</pre> <h4 id="panics-1" class="section-header">Panics</h4> <p>Panics if <code>order</code> is <code>Acquire</code> or <code>AcqRel</code>.</p> </div>
<h4 id="method.swap" class="method"><span id="swap.v" class="invisible"><code>fn <a href="#method.swap" class="fnname">swap</a>(&amp;self, val: <a class="primitive" href="../../../primitive.u32/">u32</a>, order: <a class="enum" href="../enum.ordering/" title="std::sync::atomic::Ordering">Ordering</a>) -&gt; <a class="primitive" href="../../../primitive.u32/">u32</a></code></span></h4> <div class="stability"><span class="stab unstable">ðŸ”¬ This is a nightly-only experimental API. (integer_atomics #32976)</span></div>
<div class="docblock">
<p>Stores a value into the atomic integer, returning the old value.</p> <p><code>swap</code> takes an <a href="../enum.ordering/"><code>Ordering</code></a> argument which describes the memory ordering of this operation.</p> <h4 id="examples-5" class="section-header">Examples</h4> <pre class="rust rust-example-rendered" data-language="rust">
use std::sync::atomic::{AtomicIsize, Ordering};

let some_isize = AtomicIsize::new(5);

assert_eq!(some_isize.swap(10, Ordering::Relaxed), 5);</pre> </div>
<h4 id="method.compare_and_swap" class="method"><span id="compare_and_swap.v" class="invisible"><code>fn <a href="#method.compare_and_swap" class="fnname">compare_and_swap</a>(&amp;self, current: <a class="primitive" href="../../../primitive.u32/">u32</a>, new: <a class="primitive" href="../../../primitive.u32/">u32</a>, order: <a class="enum" href="../enum.ordering/" title="std::sync::atomic::Ordering">Ordering</a>) -&gt; <a class="primitive" href="../../../primitive.u32/">u32</a></code></span></h4> <div class="stability"><span class="stab unstable">ðŸ”¬ This is a nightly-only experimental API. (integer_atomics #32976)</span></div>
<div class="docblock">
<p>Stores a value into the atomic integer if the current value is the same as the <code>current</code> value.</p> <p>The return value is always the previous value. If it is equal to <code>current</code>, then the value was updated.</p> <p><code>compare_and_swap</code> also takes an <a href="../enum.ordering/"><code>Ordering</code></a> argument which describes the memory ordering of this operation.</p> <h4 id="examples-6" class="section-header">Examples</h4> <pre class="rust rust-example-rendered" data-language="rust">
use std::sync::atomic::{AtomicIsize, Ordering};

let some_isize = AtomicIsize::new(5);

assert_eq!(some_isize.compare_and_swap(5, 10, Ordering::Relaxed), 5);
assert_eq!(some_isize.load(Ordering::Relaxed), 10);

assert_eq!(some_isize.compare_and_swap(6, 12, Ordering::Relaxed), 10);
assert_eq!(some_isize.load(Ordering::Relaxed), 10);</pre> </div>
<h4 id="method.compare_exchange" class="method"><span id="compare_exchange.v" class="invisible"><code>fn <a href="#method.compare_exchange" class="fnname">compare_exchange</a>(&amp;self,<br>Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â  current: <a class="primitive" href="../../../primitive.u32/">u32</a>,<br>Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â  new: <a class="primitive" href="../../../primitive.u32/">u32</a>,<br>Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â  success: <a class="enum" href="../enum.ordering/" title="std::sync::atomic::Ordering">Ordering</a>,<br>Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â  failure: <a class="enum" href="../enum.ordering/" title="std::sync::atomic::Ordering">Ordering</a>)<br>Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â  -&gt; <a class="enum" href="../../../result/enum.result/" title="std::result::Result">Result</a>&lt;<a class="primitive" href="../../../primitive.u32/">u32</a>, <a class="primitive" href="../../../primitive.u32/">u32</a>&gt;</code></span></h4> <div class="stability"><span class="stab unstable">ðŸ”¬ This is a nightly-only experimental API. (integer_atomics #32976)</span></div>
<div class="docblock">
<p>Stores a value into the atomic integer if the current value is the same as the <code>current</code> value.</p> <p>The return value is a result indicating whether the new value was written and containing the previous value. On success this value is guaranteed to be equal to <code>current</code>.</p> <p><code>compare_exchange</code> takes two <a href="../enum.ordering/"><code>Ordering</code></a> arguments to describe the memory ordering of this operation. The first describes the required ordering if the operation succeeds while the second describes the required ordering when the operation fails. The failure ordering can't be <a href="../enum.ordering/#variant.Release"><code>Release</code></a> or <a href="../enum.ordering/#variant.AcqRel"><code>AcqRel</code></a> and must be equivalent or weaker than the success ordering.</p> <h4 id="examples-7" class="section-header">Examples</h4> <pre class="rust rust-example-rendered" data-language="rust">
use std::sync::atomic::{AtomicIsize, Ordering};

let some_isize = AtomicIsize::new(5);

assert_eq!(some_isize.compare_exchange(5, 10,
                                       Ordering::Acquire,
                                       Ordering::Relaxed),
           Ok(5));
assert_eq!(some_isize.load(Ordering::Relaxed), 10);

assert_eq!(some_isize.compare_exchange(6, 12,
                                       Ordering::SeqCst,
                                       Ordering::Acquire),
           Err(10));
assert_eq!(some_isize.load(Ordering::Relaxed), 10);</pre> </div>
<h4 id="method.compare_exchange_weak" class="method"><span id="compare_exchange_weak.v" class="invisible"><code>fn <a href="#method.compare_exchange_weak" class="fnname">compare_exchange_weak</a>(&amp;self,<br>Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â  current: <a class="primitive" href="../../../primitive.u32/">u32</a>,<br>Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â  new: <a class="primitive" href="../../../primitive.u32/">u32</a>,<br>Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â  success: <a class="enum" href="../enum.ordering/" title="std::sync::atomic::Ordering">Ordering</a>,<br>Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â  failure: <a class="enum" href="../enum.ordering/" title="std::sync::atomic::Ordering">Ordering</a>)<br>Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â  -&gt; <a class="enum" href="../../../result/enum.result/" title="std::result::Result">Result</a>&lt;<a class="primitive" href="../../../primitive.u32/">u32</a>, <a class="primitive" href="../../../primitive.u32/">u32</a>&gt;</code></span></h4> <div class="stability"><span class="stab unstable">ðŸ”¬ This is a nightly-only experimental API. (integer_atomics #32976)</span></div>
<div class="docblock">
<p>Stores a value into the atomic integer if the current value is the same as the <code>current</code> value.</p> <p>Unlike <a href="#method.compare_exchange"><code>compare_exchange</code></a>, this function is allowed to spuriously fail even when the comparison succeeds, which can result in more efficient code on some platforms. The return value is a result indicating whether the new value was written and containing the previous value.</p> <p><code>compare_exchange_weak</code> takes two <a href="../enum.ordering/"><code>Ordering</code></a> arguments to describe the memory ordering of this operation. The first describes the required ordering if the operation succeeds while the second describes the required ordering when the operation fails. The failure ordering can't be <a href="../enum.ordering/#variant.Release"><code>Release</code></a> or <a href="../enum.ordering/#variant.AcqRel"><code>AcqRel</code></a> and must be equivalent or weaker than the success ordering.</p> <h4 id="examples-8" class="section-header">Examples</h4> <pre class="rust rust-example-rendered" data-language="rust">
use std::sync::atomic::{AtomicIsize, Ordering};

let val = AtomicIsize::new(4);

let mut old = val.load(Ordering::Relaxed);
loop {
    let new = old * 2;
    match val.compare_exchange_weak(old, new, Ordering::SeqCst, Ordering::Relaxed) {
        Ok(_) =&gt; break,
        Err(x) =&gt; old = x,
    }
}</pre> </div>
<h4 id="method.fetch_add" class="method"><span id="fetch_add.v" class="invisible"><code>fn <a href="#method.fetch_add" class="fnname">fetch_add</a>(&amp;self, val: <a class="primitive" href="../../../primitive.u32/">u32</a>, order: <a class="enum" href="../enum.ordering/" title="std::sync::atomic::Ordering">Ordering</a>) -&gt; <a class="primitive" href="../../../primitive.u32/">u32</a></code></span></h4> <div class="stability"><span class="stab unstable">ðŸ”¬ This is a nightly-only experimental API. (integer_atomics #32976)</span></div>
<div class="docblock">
<p>Add to the current value, returning the previous value.</p> <h4 id="examples-9" class="section-header">Examples</h4> <pre class="rust rust-example-rendered" data-language="rust">
use std::sync::atomic::{AtomicIsize, Ordering};

let foo = AtomicIsize::new(0);
assert_eq!(foo.fetch_add(10, Ordering::SeqCst), 0);
assert_eq!(foo.load(Ordering::SeqCst), 10);</pre> </div>
<h4 id="method.fetch_sub" class="method"><span id="fetch_sub.v" class="invisible"><code>fn <a href="#method.fetch_sub" class="fnname">fetch_sub</a>(&amp;self, val: <a class="primitive" href="../../../primitive.u32/">u32</a>, order: <a class="enum" href="../enum.ordering/" title="std::sync::atomic::Ordering">Ordering</a>) -&gt; <a class="primitive" href="../../../primitive.u32/">u32</a></code></span></h4> <div class="stability"><span class="stab unstable">ðŸ”¬ This is a nightly-only experimental API. (integer_atomics #32976)</span></div>
<div class="docblock">
<p>Subtract from the current value, returning the previous value.</p> <h4 id="examples-10" class="section-header">Examples</h4> <pre class="rust rust-example-rendered" data-language="rust">
use std::sync::atomic::{AtomicIsize, Ordering};

let foo = AtomicIsize::new(0);
assert_eq!(foo.fetch_sub(10, Ordering::SeqCst), 0);
assert_eq!(foo.load(Ordering::SeqCst), -10);</pre> </div>
<h4 id="method.fetch_and" class="method"><span id="fetch_and.v" class="invisible"><code>fn <a href="#method.fetch_and" class="fnname">fetch_and</a>(&amp;self, val: <a class="primitive" href="../../../primitive.u32/">u32</a>, order: <a class="enum" href="../enum.ordering/" title="std::sync::atomic::Ordering">Ordering</a>) -&gt; <a class="primitive" href="../../../primitive.u32/">u32</a></code></span></h4> <div class="stability"><span class="stab unstable">ðŸ”¬ This is a nightly-only experimental API. (integer_atomics #32976)</span></div>
<div class="docblock">
<p>Bitwise and with the current value, returning the previous value.</p> <h4 id="examples-11" class="section-header">Examples</h4> <pre class="rust rust-example-rendered" data-language="rust">
use std::sync::atomic::{AtomicIsize, Ordering};

let foo = AtomicIsize::new(0b101101);
assert_eq!(foo.fetch_and(0b110011, Ordering::SeqCst), 0b101101);
assert_eq!(foo.load(Ordering::SeqCst), 0b100001);</pre> </div>
<h4 id="method.fetch_or" class="method"><span id="fetch_or.v" class="invisible"><code>fn <a href="#method.fetch_or" class="fnname">fetch_or</a>(&amp;self, val: <a class="primitive" href="../../../primitive.u32/">u32</a>, order: <a class="enum" href="../enum.ordering/" title="std::sync::atomic::Ordering">Ordering</a>) -&gt; <a class="primitive" href="../../../primitive.u32/">u32</a></code></span></h4> <div class="stability"><span class="stab unstable">ðŸ”¬ This is a nightly-only experimental API. (integer_atomics #32976)</span></div>
<div class="docblock">
<p>Bitwise or with the current value, returning the previous value.</p> <h4 id="examples-12" class="section-header">Examples</h4> <pre class="rust rust-example-rendered" data-language="rust">
use std::sync::atomic::{AtomicIsize, Ordering};

let foo = AtomicIsize::new(0b101101);
assert_eq!(foo.fetch_or(0b110011, Ordering::SeqCst), 0b101101);
assert_eq!(foo.load(Ordering::SeqCst), 0b111111);</pre> </div>
<h4 id="method.fetch_xor" class="method"><span id="fetch_xor.v" class="invisible"><code>fn <a href="#method.fetch_xor" class="fnname">fetch_xor</a>(&amp;self, val: <a class="primitive" href="../../../primitive.u32/">u32</a>, order: <a class="enum" href="../enum.ordering/" title="std::sync::atomic::Ordering">Ordering</a>) -&gt; <a class="primitive" href="../../../primitive.u32/">u32</a></code></span></h4> <div class="stability"><span class="stab unstable">ðŸ”¬ This is a nightly-only experimental API. (integer_atomics #32976)</span></div>
<div class="docblock">
<p>Bitwise xor with the current value, returning the previous value.</p> <h4 id="examples-13" class="section-header">Examples</h4> <pre class="rust rust-example-rendered" data-language="rust">
use std::sync::atomic::{AtomicIsize, Ordering};

let foo = AtomicIsize::new(0b101101);
assert_eq!(foo.fetch_xor(0b110011, Ordering::SeqCst), 0b101101);
assert_eq!(foo.load(Ordering::SeqCst), 0b011110);</pre> </div>
<h2 id="implementations">Trait Implementations</h2>
<h3 class="impl">
<span class="in-band"><code>impl <a class="trait" href="../../../marker/trait.sync/" title="std::marker::Sync">Sync</a> for <a class="struct" href="../struct.atomicu32/" title="std::sync::atomic::AtomicU32">AtomicU32</a></code></span><span class="out-of-band">
<a class="srclink" href="https://doc.rust-lang.org/src/core/sync/atomic.rs.html#905" title="goto source code" target="_blank">[src]</a></span>
</h3> <h3 class="impl">
<span class="in-band"><code>impl <a class="trait" href="../../../default/trait.default/" title="std::default::Default">Default</a> for <a class="struct" href="../struct.atomicu32/" title="std::sync::atomic::AtomicU32">AtomicU32</a></code></span><span class="out-of-band">
<a class="srclink" href="https://doc.rust-lang.org/src/core/sync/atomic.rs.html#888-892" title="goto source code" target="_blank">[src]</a></span>
</h3> <h4 id="method.default" class="method"><span id="default.v" class="invisible"><code>fn <a href="../../../default/trait.default/#tymethod.default" class="fnname">default</a>() -&gt; <a class="struct" href="../struct.atomicu32/" title="std::sync::atomic::AtomicU32">AtomicU32</a></code></span></h4> <div class="docblock">
<p>Returns the "default value" for a type. <a href="../../../default/trait.default/#tymethod.default">Read more</a></p> </div>
<h3 class="impl">
<span class="in-band"><code>impl <a class="trait" href="../../../fmt/trait.debug/" title="std::fmt::Debug">Debug</a> for <a class="struct" href="../struct.atomicu32/" title="std::sync::atomic::AtomicU32">AtomicU32</a></code></span><span class="out-of-band">
<a class="srclink" href="https://doc.rust-lang.org/src/core/sync/atomic.rs.html#895-901" title="goto source code" target="_blank">[src]</a></span>
</h3> <h4 id="method.fmt" class="method"><span id="fmt.v" class="invisible"><code>fn <a href="../../../fmt/trait.debug/#tymethod.fmt" class="fnname">fmt</a>(&amp;self, f: &amp;mut <a class="struct" href="../../../fmt/struct.formatter/" title="std::fmt::Formatter">Formatter</a>) -&gt; <a class="enum" href="../../../result/enum.result/" title="std::result::Result">Result</a>&lt;<a class="primitive" href="../../../primitive.tuple/">()</a>, <a class="struct" href="../../../fmt/struct.error/" title="std::fmt::Error">Error</a>&gt;</code></span></h4> <div class="docblock">
<p>Formats the value using the given formatter.</p> </div>
<h3 class="impl">
<span class="in-band"><code>impl <a class="trait" href="../../../panic/trait.refunwindsafe/" title="std::panic::RefUnwindSafe">RefUnwindSafe</a> for <a class="struct" href="../struct.atomicu32/" title="std::sync::atomic::AtomicU32">AtomicU32</a></code></span><span class="out-of-band">
<a class="srclink" href="https://doc.rust-lang.org/src/std/panic.rs.html#262" title="goto source code" target="_blank">[src]</a></span>
</h3>
<div class="_attribution">
  <p class="_attribution-p">
    Â© 2010 The Rust Project Developers<br>Licensed under the Apache License, Version 2.0 or the MIT license, at your option.<br>
    <a href="https://doc.rust-lang.org/std/sync/atomic/struct.AtomicU32.html" class="_attribution-link" target="_blank">https://doc.rust-lang.org/std/sync/atomic/struct.AtomicU32.html</a>
  </p>
</div>

			</div>
		</div>
	</section>

	</div>
</body>
</html>
