
<!DOCTYPE HTML>

<html lang="en">

<head>
  <meta charset="utf-8">
  <title>std&#58;&#58;sync&#58;&#58;atomic&#58;&#58;AtomicPtr - Rust - W3cubDocs</title>
  
  <meta name="description" content=" A raw pointer type which can be safely shared between threads. ">
  <meta name="keywords" content="struct, std, sync, atomic, atomicptr, -, rust">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="http://docs.w3cub.com/rust/std/sync/atomic/struct.atomicptr/">
  <link href="/favicon.png" rel="icon">
  <link type="text/css" rel="stylesheet" href="/assets/application-50364fff564ce3b6327021805f3f00e2957b441cf27f576a7dd4ff63bbc47047.css">
  <script type="text/javascript" src="/assets/application-db64bfd54ceb42be11af7995804cf4902548419ceb79d509b0b7d62c22d98e6f.js"></script>
  <script src="/json/rust.js"></script>
  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-71174418-1']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>


</head>

<body>
	<div class="_app">
	<header class="_header">
  
  <form class="_search">
    <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
    <a class="_search-clear"></a>
    <div class="_search-tag"></div>
  </form>
  
  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/rust/" class="_nav-link" title="" style="margin-left:0;">Rust</a></span>
  
  <nav class="_nav">
    <a href="/app/" class="_nav-link ">App</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		<div class="_list">
			
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<div class="_page _rust">
				
<h1 class="fqn">Struct std::sync::atomic::AtomicPtr</h1> <pre class="rust struct" data-language="rust">pub struct AtomicPtr&lt;T&gt; { /* fields omitted */ }</pre>
<p>A raw pointer type which can be safely shared between threads.</p> <p>This type has the same in-memory representation as a <code>*mut T</code>.</p> <h2 id="methods">Methods</h2>
<h3 class="impl">
<span class="in-band"><code>impl&lt;T&gt; <a class="struct" href="../struct.atomicptr/" title="std::sync::atomic::AtomicPtr">AtomicPtr</a>&lt;T&gt;</code></span><span class="out-of-band">
<a class="srclink" href="https://doc.rust-lang.org/src/core/sync/atomic.rs.html#590-867" title="goto source code" target="_blank">[src]</a></span>
</h3> <h4 id="method.new" class="method"><span id="new.v" class="invisible"><code>fn <a href="#method.new" class="fnname">new</a>(p: <a class="primitive" href="../../../primitive.pointer/">*mut T</a>) -&gt; <a class="struct" href="../struct.atomicptr/" title="std::sync::atomic::AtomicPtr">AtomicPtr</a>&lt;T&gt;</code></span></h4> <div class="docblock">
<p>Creates a new <code>AtomicPtr</code>.</p> <h4 id="examples" class="section-header">Examples</h4> <pre class="rust rust-example-rendered" data-language="rust">
use std::sync::atomic::AtomicPtr;

let ptr = &amp;mut 5;
let atomic_ptr  = AtomicPtr::new(ptr);</pre> </div>
<h4 id="method.get_mut" class="method"><span id="get_mut.v" class="invisible"><code>fn <a href="#method.get_mut" class="fnname">get_mut</a>(&amp;mut self) -&gt; &amp;mut <a class="primitive" href="../../../primitive.pointer/">*mut T</a></code><div class="since" title="Stable since Rust version 1.15.0">1.15.0</div></span></h4> <div class="docblock">
<p>Returns a mutable reference to the underlying pointer.</p> <p>This is safe because the mutable reference guarantees that no other threads are concurrently accessing the atomic data.</p> <h4 id="examples-1" class="section-header">Examples</h4> <pre class="rust rust-example-rendered" data-language="rust">
use std::sync::atomic::{AtomicPtr, Ordering};

let mut atomic_ptr = AtomicPtr::new(&amp;mut 10);
*atomic_ptr.get_mut() = &amp;mut 5;
assert_eq!(unsafe { *atomic_ptr.load(Ordering::SeqCst) }, 5);</pre> </div>
<h4 id="method.into_inner" class="method"><span id="into_inner.v" class="invisible"><code>fn <a href="#method.into_inner" class="fnname">into_inner</a>(self) -&gt; <a class="primitive" href="../../../primitive.pointer/">*mut T</a></code><div class="since" title="Stable since Rust version 1.15.0">1.15.0</div></span></h4> <div class="docblock">
<p>Consumes the atomic and returns the contained value.</p> <p>This is safe because passing <code>self</code> by value guarantees that no other threads are concurrently accessing the atomic data.</p> <h4 id="examples-2" class="section-header">Examples</h4> <pre class="rust rust-example-rendered" data-language="rust">
use std::sync::atomic::AtomicPtr;

let atomic_ptr = AtomicPtr::new(&amp;mut 5);
assert_eq!(unsafe { *atomic_ptr.into_inner() }, 5);</pre> </div>
<h4 id="method.load" class="method"><span id="load.v" class="invisible"><code>fn <a href="#method.load" class="fnname">load</a>(&amp;self, order: <a class="enum" href="../enum.ordering/" title="std::sync::atomic::Ordering">Ordering</a>) -&gt; <a class="primitive" href="../../../primitive.pointer/">*mut T</a></code></span></h4> <div class="docblock">
<p>Loads a value from the pointer.</p> <p><code>load</code> takes an <a href="../enum.ordering/"><code>Ordering</code></a> argument which describes the memory ordering of this operation.</p> <h4 id="panics" class="section-header">Panics</h4> <p>Panics if <code>order</code> is <a href="../enum.ordering/#variant.Release"><code>Release</code></a> or <a href="../enum.ordering/#variant.AcqRel"><code>AcqRel</code></a>.</p> <h4 id="examples-3" class="section-header">Examples</h4> <pre class="rust rust-example-rendered" data-language="rust">
use std::sync::atomic::{AtomicPtr, Ordering};

let ptr = &amp;mut 5;
let some_ptr  = AtomicPtr::new(ptr);

let value = some_ptr.load(Ordering::Relaxed);</pre> </div>
<h4 id="method.store" class="method"><span id="store.v" class="invisible"><code>fn <a href="#method.store" class="fnname">store</a>(&amp;self, ptr: <a class="primitive" href="../../../primitive.pointer/">*mut T</a>, order: <a class="enum" href="../enum.ordering/" title="std::sync::atomic::Ordering">Ordering</a>)</code></span></h4> <div class="docblock">
<p>Stores a value into the pointer.</p> <p><code>store</code> takes an <a href="../enum.ordering/"><code>Ordering</code></a> argument which describes the memory ordering of this operation.</p> <h4 id="examples-4" class="section-header">Examples</h4> <pre class="rust rust-example-rendered" data-language="rust">
use std::sync::atomic::{AtomicPtr, Ordering};

let ptr = &amp;mut 5;
let some_ptr  = AtomicPtr::new(ptr);

let other_ptr = &amp;mut 10;

some_ptr.store(other_ptr, Ordering::Relaxed);</pre> <h4 id="panics-1" class="section-header">Panics</h4> <p>Panics if <code>order</code> is <code>Acquire</code> or <code>AcqRel</code>.</p> </div>
<h4 id="method.swap" class="method"><span id="swap.v" class="invisible"><code>fn <a href="#method.swap" class="fnname">swap</a>(&amp;self, ptr: <a class="primitive" href="../../../primitive.pointer/">*mut T</a>, order: <a class="enum" href="../enum.ordering/" title="std::sync::atomic::Ordering">Ordering</a>) -&gt; <a class="primitive" href="../../../primitive.pointer/">*mut T</a></code></span></h4> <div class="docblock">
<p>Stores a value into the pointer, returning the old value.</p> <p><code>swap</code> takes an <a href="../enum.ordering/"><code>Ordering</code></a> argument which describes the memory ordering of this operation.</p> <h4 id="examples-5" class="section-header">Examples</h4> <pre class="rust rust-example-rendered" data-language="rust">
use std::sync::atomic::{AtomicPtr, Ordering};

let ptr = &amp;mut 5;
let some_ptr  = AtomicPtr::new(ptr);

let other_ptr = &amp;mut 10;

let value = some_ptr.swap(other_ptr, Ordering::Relaxed);</pre> </div>
<h4 id="method.compare_and_swap" class="method"><span id="compare_and_swap.v" class="invisible"><code>fn <a href="#method.compare_and_swap" class="fnname">compare_and_swap</a>(&amp;self,<br>                    current: <a class="primitive" href="../../../primitive.pointer/">*mut T</a>,<br>                    new: <a class="primitive" href="../../../primitive.pointer/">*mut T</a>,<br>                    order: <a class="enum" href="../enum.ordering/" title="std::sync::atomic::Ordering">Ordering</a>)<br>                    -&gt; <a class="primitive" href="../../../primitive.pointer/">*mut T</a></code></span></h4> <div class="docblock">
<p>Stores a value into the pointer if the current value is the same as the <code>current</code> value.</p> <p>The return value is always the previous value. If it is equal to <code>current</code>, then the value was updated.</p> <p><code>compare_and_swap</code> also takes an <a href="../enum.ordering/"><code>Ordering</code></a> argument which describes the memory ordering of this operation.</p> <h4 id="examples-6" class="section-header">Examples</h4> <pre class="rust rust-example-rendered" data-language="rust">
use std::sync::atomic::{AtomicPtr, Ordering};

let ptr = &amp;mut 5;
let some_ptr  = AtomicPtr::new(ptr);

let other_ptr   = &amp;mut 10;
let another_ptr = &amp;mut 10;

let value = some_ptr.compare_and_swap(other_ptr, another_ptr, Ordering::Relaxed);</pre> </div>
<h4 id="method.compare_exchange" class="method"><span id="compare_exchange.v" class="invisible"><code>fn <a href="#method.compare_exchange" class="fnname">compare_exchange</a>(&amp;self,<br>                    current: <a class="primitive" href="../../../primitive.pointer/">*mut T</a>,<br>                    new: <a class="primitive" href="../../../primitive.pointer/">*mut T</a>,<br>                    success: <a class="enum" href="../enum.ordering/" title="std::sync::atomic::Ordering">Ordering</a>,<br>                    failure: <a class="enum" href="../enum.ordering/" title="std::sync::atomic::Ordering">Ordering</a>)<br>                    -&gt; <a class="enum" href="../../../result/enum.result/" title="std::result::Result">Result</a>&lt;<a class="primitive" href="../../../primitive.pointer/">*mut T</a>, <a class="primitive" href="../../../primitive.pointer/">*mut T</a>&gt;</code><div class="since" title="Stable since Rust version 1.10.0">1.10.0</div></span></h4> <div class="docblock">
<p>Stores a value into the pointer if the current value is the same as the <code>current</code> value.</p> <p>The return value is a result indicating whether the new value was written and containing the previous value. On success this value is guaranteed to be equal to <code>current</code>.</p> <p><code>compare_exchange</code> takes two <a href="../enum.ordering/"><code>Ordering</code></a> arguments to describe the memory ordering of this operation. The first describes the required ordering if the operation succeeds while the second describes the required ordering when the operation fails. The failure ordering can't be <a href="../enum.ordering/#variant.Release"><code>Release</code></a> or <a href="../enum.ordering/#variant.AcqRel"><code>AcqRel</code></a> and must be equivalent or weaker than the success ordering.</p> <h4 id="examples-7" class="section-header">Examples</h4> <pre class="rust rust-example-rendered" data-language="rust">
use std::sync::atomic::{AtomicPtr, Ordering};

let ptr = &amp;mut 5;
let some_ptr  = AtomicPtr::new(ptr);

let other_ptr   = &amp;mut 10;
let another_ptr = &amp;mut 10;

let value = some_ptr.compare_exchange(other_ptr, another_ptr,
                                      Ordering::SeqCst, Ordering::Relaxed);</pre> </div>
<h4 id="method.compare_exchange_weak" class="method"><span id="compare_exchange_weak.v" class="invisible"><code>fn <a href="#method.compare_exchange_weak" class="fnname">compare_exchange_weak</a>(&amp;self,<br>                         current: <a class="primitive" href="../../../primitive.pointer/">*mut T</a>,<br>                         new: <a class="primitive" href="../../../primitive.pointer/">*mut T</a>,<br>                         success: <a class="enum" href="../enum.ordering/" title="std::sync::atomic::Ordering">Ordering</a>,<br>                         failure: <a class="enum" href="../enum.ordering/" title="std::sync::atomic::Ordering">Ordering</a>)<br>                         -&gt; <a class="enum" href="../../../result/enum.result/" title="std::result::Result">Result</a>&lt;<a class="primitive" href="../../../primitive.pointer/">*mut T</a>, <a class="primitive" href="../../../primitive.pointer/">*mut T</a>&gt;</code><div class="since" title="Stable since Rust version 1.10.0">1.10.0</div></span></h4> <div class="docblock">
<p>Stores a value into the pointer if the current value is the same as the <code>current</code> value.</p> <p>Unlike <a href="#method.compare_exchange"><code>compare_exchange</code></a>, this function is allowed to spuriously fail even when the comparison succeeds, which can result in more efficient code on some platforms. The return value is a result indicating whether the new value was written and containing the previous value.</p> <p><code>compare_exchange_weak</code> takes two <a href="../enum.ordering/"><code>Ordering</code></a> arguments to describe the memory ordering of this operation. The first describes the required ordering if the operation succeeds while the second describes the required ordering when the operation fails. The failure ordering can't be <a href="../enum.ordering/#variant.Release"><code>Release</code></a> or <a href="../enum.ordering/#variant.AcqRel"><code>AcqRel</code></a> and must be equivalent or weaker than the success ordering.</p> <h4 id="examples-8" class="section-header">Examples</h4> <pre class="rust rust-example-rendered" data-language="rust">
use std::sync::atomic::{AtomicPtr, Ordering};

let some_ptr = AtomicPtr::new(&amp;mut 5);

let new = &amp;mut 10;
let mut old = some_ptr.load(Ordering::Relaxed);
loop {
    match some_ptr.compare_exchange_weak(old, new, Ordering::SeqCst, Ordering::Relaxed) {
        Ok(_) =&gt; break,
        Err(x) =&gt; old = x,
    }
}</pre> </div>
<h2 id="implementations">Trait Implementations</h2>
<h3 class="impl">
<span class="in-band"><code>impl&lt;T&gt; <a class="trait" href="../../../marker/trait.sync/" title="std::marker::Sync">Sync</a> for <a class="struct" href="../struct.atomicptr/" title="std::sync::atomic::AtomicPtr">AtomicPtr</a>&lt;T&gt;</code></span><span class="out-of-band">
<a class="srclink" href="https://doc.rust-lang.org/src/core/sync/atomic.rs.html#133" title="goto source code" target="_blank">[src]</a></span>
</h3> <h3 class="impl">
<span class="in-band"><code>impl&lt;T&gt; <a class="trait" href="../../../default/trait.default/" title="std::default::Default">Default</a> for <a class="struct" href="../struct.atomicptr/" title="std::sync::atomic::AtomicPtr">AtomicPtr</a>&lt;T&gt;</code></span><span class="out-of-band">
<a class="srclink" href="https://doc.rust-lang.org/src/core/sync/atomic.rs.html#121-126" title="goto source code" target="_blank">[src]</a></span>
</h3> <h4 id="method.default" class="method"><span id="default.v" class="invisible"><code>fn <a href="../../../default/trait.default/#tymethod.default" class="fnname">default</a>() -&gt; <a class="struct" href="../struct.atomicptr/" title="std::sync::atomic::AtomicPtr">AtomicPtr</a>&lt;T&gt;</code></span></h4> <div class="docblock">
<p>Creates a null <code>AtomicPtr&lt;T&gt;</code>.</p> </div>
<h3 class="impl">
<span class="in-band"><code>impl&lt;T&gt; <a class="trait" href="../../../marker/trait.send/" title="std::marker::Send">Send</a> for <a class="struct" href="../struct.atomicptr/" title="std::sync::atomic::AtomicPtr">AtomicPtr</a>&lt;T&gt;</code></span><span class="out-of-band">
<a class="srclink" href="https://doc.rust-lang.org/src/core/sync/atomic.rs.html#130" title="goto source code" target="_blank">[src]</a></span>
</h3> <h3 class="impl">
<span class="in-band"><code>impl&lt;T&gt; <a class="trait" href="../../../fmt/trait.debug/" title="std::fmt::Debug">Debug</a> for <a class="struct" href="../struct.atomicptr/" title="std::sync::atomic::AtomicPtr">AtomicPtr</a>&lt;T&gt;</code></span><span class="out-of-band">
<div class="since" title="Stable since Rust version 1.3.0">1.3.0</div>
<a class="srclink" href="https://doc.rust-lang.org/src/core/sync/atomic.rs.html#1553-1557" title="goto source code" target="_blank">[src]</a></span>
</h3> <h4 id="method.fmt" class="method"><span id="fmt.v" class="invisible"><code>fn <a href="../../../fmt/trait.debug/#tymethod.fmt" class="fnname">fmt</a>(&amp;self, f: &amp;mut <a class="struct" href="../../../fmt/struct.formatter/" title="std::fmt::Formatter">Formatter</a>) -&gt; <a class="enum" href="../../../result/enum.result/" title="std::result::Result">Result</a>&lt;<a class="primitive" href="../../../primitive.tuple/">()</a>, <a class="struct" href="../../../fmt/struct.error/" title="std::fmt::Error">Error</a>&gt;</code></span></h4> <div class="docblock">
<p>Formats the value using the given formatter.</p> </div>
<h3 class="impl">
<span class="in-band"><code>impl&lt;T&gt; <a class="trait" href="../../../panic/trait.refunwindsafe/" title="std::panic::RefUnwindSafe">RefUnwindSafe</a> for <a class="struct" href="../struct.atomicptr/" title="std::sync::atomic::AtomicPtr">AtomicPtr</a>&lt;T&gt;</code></span><span class="out-of-band">
<div class="since" title="Stable since Rust version 1.14.0">1.14.0</div>
<a class="srclink" href="https://doc.rust-lang.org/src/std/panic.rs.html#273" title="goto source code" target="_blank">[src]</a></span>
</h3>
<div class="_attribution">
  <p class="_attribution-p">
    © 2010 The Rust Project Developers<br>Licensed under the Apache License, Version 2.0 or the MIT license, at your option.<br>
    <a href="https://doc.rust-lang.org/std/sync/atomic/struct.AtomicPtr.html" class="_attribution-link" target="_blank">https://doc.rust-lang.org/std/sync/atomic/struct.AtomicPtr.html</a>
  </p>
</div>

			</div>
		</div>
	</section>

	</div>
</body>
</html>
