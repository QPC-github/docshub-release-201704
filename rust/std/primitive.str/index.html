
<!DOCTYPE HTML>

<html lang="en">

<head>
  <meta charset="utf-8">
  <title>Std&#58;&#58;str - Rust - W3cubDocs</title>
  
  <meta name="description" content=" String slices. ">
  <meta name="keywords" content="primitive, type, str, std, -, rust">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="http://docs.w3cub.com/rust/std/primitive.str/">
  <link href="/favicon.png" rel="icon">
  <link type="text/css" rel="stylesheet" href="/assets/application-50364fff564ce3b6327021805f3f00e2957b441cf27f576a7dd4ff63bbc47047.css">
  <script type="text/javascript" src="/assets/application-db64bfd54ceb42be11af7995804cf4902548419ceb79d509b0b7d62c22d98e6f.js"></script>
  <script src="/json/rust.js"></script>
  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-71174418-1']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>


</head>

<body>
	<div class="_app">
	<header class="_header">
  
  <form class="_search">
    <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
    <a class="_search-clear"></a>
    <div class="_search-tag"></div>
  </form>
  
  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/rust/" class="_nav-link" title="" style="margin-left:0;">Rust</a></span>
  
  <nav class="_nav">
    <a href="/app/" class="_nav-link ">App</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		<div class="_list">
			
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<div class="_page _rust">
				
<h1 class="fqn">Primitive Type str</h1> <p>String slices.</p> <p>The <code>str</code> type, also called a 'string slice', is the most primitive string type. It is usually seen in its borrowed form, <code>&amp;str</code>. It is also the type of string literals, <code>&amp;'static str</code>.</p> <p>Strings slices are always valid UTF-8.</p> <p>This documentation describes a number of methods and trait implementations on the <code>str</code> type. For technical reasons, there is additional, separate documentation in <a href="../str/">the <code>std::str</code> module</a> as well.</p> <h4 id="examples" class="section-header">Examples</h4> <p>String literals are string slices:</p> <pre class="rust rust-example-rendered" data-language="rust">
let hello = "Hello, world!";

// with an explicit type annotation
let hello: &amp;'static str = "Hello, world!";</pre> <p>They are <code>'static</code> because they're stored directly in the final binary, and so will be valid for the <code>'static</code> duration.</p> <h4 id="representation" class="section-header">Representation</h4> <p>A <code>&amp;str</code> is made up of two components: a pointer to some bytes, and a length. You can look at these with the <a href="#method.as_ptr"><code>.as_ptr()</code></a> and <a href="#method.len"><code>len()</code></a> methods:</p> <pre class="rust rust-example-rendered" data-language="rust">
use std::slice;
use std::str;

let story = "Once upon a time...";

let ptr = story.as_ptr();
let len = story.len();

// story has nineteen bytes
assert_eq!(19, len);

// We can re-build a str out of ptr and len. This is all unsafe because
// we are responsible for making sure the two components are valid:
let s = unsafe {
    // First, we build a &amp;[u8]...
    let slice = slice::from_raw_parts(ptr, len);

    // ... and then convert that slice into a string slice
    str::from_utf8(slice)
};

assert_eq!(s, Ok(story));</pre> <p>Note: This example shows the internals of <code>&amp;str</code>. <code>unsafe</code> should not be used to get a string slice under normal circumstances. Use <code>.as_slice()</code> instead.</p> <h2 id="methods">Methods</h2>
<h3 class="impl">
<span class="in-band"><code>impl <a class="primitive" href="../primitive.str/">str</a></code></span><span class="out-of-band">
<a class="srclink" href="https://doc.rust-lang.org/src/collections/str.rs.html#174-1802" title="goto source code" target="_blank">[src]</a></span>
</h3> <p>Methods for string slices.</p> <h4 id="method.len" class="method"><span id="len.v" class="invisible"><code>fn <a href="#method.len" class="fnname">len</a>(&amp;self) -&gt; <a class="primitive" href="../primitive.usize/">usize</a></code></span></h4> <div class="docblock">
<p>Returns the length of <code>self</code>.</p> <p>This length is in bytes, not <a href="../primitive.char/"><code>char</code></a>s or graphemes. In other words, it may not be what a human considers the length of the string.</p> <h4 id="examples-1" class="section-header">Examples</h4> <p>Basic usage:</p> <pre class="rust rust-example-rendered" data-language="rust">
let len = "foo".len();
assert_eq!(3, len);

let len = "ƒoo".len(); // fancy f!
assert_eq!(4, len);</pre> </div>
<h4 id="method.is_empty" class="method"><span id="is_empty.v" class="invisible"><code>fn <a href="#method.is_empty" class="fnname">is_empty</a>(&amp;self) -&gt; <a class="primitive" href="../primitive.bool/">bool</a></code></span></h4> <div class="docblock">
<p>Returns true if this slice has a length of zero bytes.</p> <h4 id="examples-2" class="section-header">Examples</h4> <p>Basic usage:</p> <pre class="rust rust-example-rendered" data-language="rust">
let s = "";
assert!(s.is_empty());

let s = "not empty";
assert!(!s.is_empty());</pre> </div>
<h4 id="method.is_char_boundary" class="method"><span id="is_char_boundary.v" class="invisible"><code>fn <a href="#method.is_char_boundary" class="fnname">is_char_boundary</a>(&amp;self, index: <a class="primitive" href="../primitive.usize/">usize</a>) -&gt; <a class="primitive" href="../primitive.bool/">bool</a></code><div class="since" title="Stable since Rust version 1.9.0">1.9.0</div></span></h4> <div class="docblock">
<p>Checks that <code>index</code>-th byte lies at the start and/or end of a UTF-8 code point sequence.</p> <p>The start and end of the string (when <code>index == self.len()</code>) are considered to be boundaries.</p> <p>Returns <code>false</code> if <code>index</code> is greater than <code>self.len()</code>.</p> <h4 id="examples-3" class="section-header">Examples</h4> <pre class="rust rust-example-rendered" data-language="rust">
let s = "Löwe 老虎 Léopard";
assert!(s.is_char_boundary(0));
// start of `老`
assert!(s.is_char_boundary(6));
assert!(s.is_char_boundary(s.len()));

// second byte of `ö`
assert!(!s.is_char_boundary(2));

// third byte of `老`
assert!(!s.is_char_boundary(8));</pre> </div>
<h4 id="method.as_bytes" class="method"><span id="as_bytes.v" class="invisible"><code>fn <a href="#method.as_bytes" class="fnname">as_bytes</a>(&amp;self) -&gt; <a class="primitive" href="../primitive.slice/">&amp;[</a><a class="primitive" href="../primitive.u8/">u8</a><a class="primitive" href="../primitive.slice/">]</a></code></span></h4> <div class="docblock">
<p>Converts a string slice to a byte slice.</p> <h4 id="examples-4" class="section-header">Examples</h4> <p>Basic usage:</p> <pre class="rust rust-example-rendered" data-language="rust">
let bytes = "bors".as_bytes();
assert_eq!(b"bors", bytes);</pre> </div>
<h4 id="method.as_ptr" class="method"><span id="as_ptr.v" class="invisible"><code>fn <a href="#method.as_ptr" class="fnname">as_ptr</a>(&amp;self) -&gt; <a class="primitive" href="../primitive.pointer/">*const </a><a class="primitive" href="../primitive.u8/">u8</a></code></span></h4> <div class="docblock">
<p>Converts a string slice to a raw pointer.</p> <p>As string slices are a slice of bytes, the raw pointer points to a <a href="../primitive.u8/"><code>u8</code></a>. This pointer will be pointing to the first byte of the string slice.</p> <h4 id="examples-5" class="section-header">Examples</h4> <p>Basic usage:</p> <pre class="rust rust-example-rendered" data-language="rust">
let s = "Hello";
let ptr = s.as_ptr();</pre> </div>
<h4 id="method.slice_unchecked" class="method"><span id="slice_unchecked.v" class="invisible"><code>unsafe fn <a href="#method.slice_unchecked" class="fnname">slice_unchecked</a>(&amp;self, begin: <a class="primitive" href="../primitive.usize/">usize</a>, end: <a class="primitive" href="../primitive.usize/">usize</a>) -&gt; &amp;<a class="primitive" href="../primitive.str/">str</a></code></span></h4> <div class="docblock">
<p>Creates a string slice from another string slice, bypassing safety checks.</p> <p>This new slice goes from <code>begin</code> to <code>end</code>, including <code>begin</code> but excluding <code>end</code>.</p> <p>To get a mutable string slice instead, see the <a href="#method.slice_mut_unchecked"><code>slice_mut_unchecked()</code></a> method.</p> <h4 id="safety" class="section-header">Safety</h4> <p>Callers of this function are responsible that three preconditions are satisfied:</p> <ul> <li>
<code>begin</code> must come before <code>end</code>.</li> <li>
<code>begin</code> and <code>end</code> must be byte positions within the string slice.</li> <li>
<code>begin</code> and <code>end</code> must lie on UTF-8 sequence boundaries.</li> </ul> <h4 id="examples-6" class="section-header">Examples</h4> <p>Basic usage:</p> <pre class="rust rust-example-rendered" data-language="rust">
let s = "Löwe 老虎 Léopard";

unsafe {
    assert_eq!("Löwe 老虎 Léopard", s.slice_unchecked(0, 21));
}

let s = "Hello, world!";

unsafe {
    assert_eq!("world", s.slice_unchecked(7, 12));
}</pre> </div>
<h4 id="method.slice_mut_unchecked" class="method"><span id="slice_mut_unchecked.v" class="invisible"><code>unsafe fn <a href="#method.slice_mut_unchecked" class="fnname">slice_mut_unchecked</a>(&amp;mut self, begin: <a class="primitive" href="../primitive.usize/">usize</a>, end: <a class="primitive" href="../primitive.usize/">usize</a>) -&gt; &amp;mut <a class="primitive" href="../primitive.str/">str</a></code><div class="since" title="Stable since Rust version 1.5.0">1.5.0</div></span></h4> <div class="docblock">
<p>Creates a string slice from another string slice, bypassing safety checks.</p> <p>This new slice goes from <code>begin</code> to <code>end</code>, including <code>begin</code> but excluding <code>end</code>.</p> <p>To get an immutable string slice instead, see the <a href="#method.slice_unchecked"><code>slice_unchecked()</code></a> method.</p> <h4 id="safety-1" class="section-header">Safety</h4> <p>Callers of this function are responsible that three preconditions are satisfied:</p> <ul> <li>
<code>begin</code> must come before <code>end</code>.</li> <li>
<code>begin</code> and <code>end</code> must be byte positions within the string slice.</li> <li>
<code>begin</code> and <code>end</code> must lie on UTF-8 sequence boundaries.</li> </ul> </div>
<h4 id="method.split_at" class="method"><span id="split_at.v" class="invisible"><code>fn <a href="#method.split_at" class="fnname">split_at</a>(&amp;self, mid: <a class="primitive" href="../primitive.usize/">usize</a>) -&gt; <a class="primitive" href="../primitive.tuple/">(</a>&amp;<a class="primitive" href="../primitive.str/">str</a>, &amp;<a class="primitive" href="../primitive.str/">str</a><a class="primitive" href="../primitive.tuple/">)</a></code><div class="since" title="Stable since Rust version 1.4.0">1.4.0</div></span></h4> <div class="docblock">
<p>Divide one string slice into two at an index.</p> <p>The argument, <code>mid</code>, should be a byte offset from the start of the string. It must also be on the boundary of a UTF-8 code point.</p> <p>The two slices returned go from the start of the string slice to <code>mid</code>, and from <code>mid</code> to the end of the string slice.</p> <p>To get mutable string slices instead, see the <a href="#method.split_at_mut"><code>split_at_mut()</code></a> method.</p> <h4 id="panics" class="section-header">Panics</h4> <p>Panics if <code>mid</code> is not on a UTF-8 code point boundary, or if it is beyond the last code point of the string slice.</p> <h4 id="examples-7" class="section-header">Examples</h4> <p>Basic usage:</p> <pre class="rust rust-example-rendered" data-language="rust">
let s = "Per Martin-Löf";

let (first, last) = s.split_at(3);

assert_eq!("Per", first);
assert_eq!(" Martin-Löf", last);</pre> </div>
<h4 id="method.split_at_mut" class="method"><span id="split_at_mut.v" class="invisible"><code>fn <a href="#method.split_at_mut" class="fnname">split_at_mut</a>(&amp;mut self, mid: <a class="primitive" href="../primitive.usize/">usize</a>) -&gt; <a class="primitive" href="../primitive.tuple/">(</a>&amp;mut <a class="primitive" href="../primitive.str/">str</a>, &amp;mut <a class="primitive" href="../primitive.str/">str</a><a class="primitive" href="../primitive.tuple/">)</a></code><div class="since" title="Stable since Rust version 1.4.0">1.4.0</div></span></h4> <div class="docblock">
<p>Divide one mutable string slice into two at an index.</p> <p>The argument, <code>mid</code>, should be a byte offset from the start of the string. It must also be on the boundary of a UTF-8 code point.</p> <p>The two slices returned go from the start of the string slice to <code>mid</code>, and from <code>mid</code> to the end of the string slice.</p> <p>To get immutable string slices instead, see the <a href="#method.split_at"><code>split_at()</code></a> method.</p> <h4 id="panics-1" class="section-header">Panics</h4> <p>Panics if <code>mid</code> is not on a UTF-8 code point boundary, or if it is beyond the last code point of the string slice.</p> <h4 id="examples-8" class="section-header">Examples</h4> <p>Basic usage:</p> <pre class="rust rust-example-rendered" data-language="rust">
let mut s = "Per Martin-Löf".to_string();

let (first, last) = s.split_at_mut(3);

assert_eq!("Per", first);
assert_eq!(" Martin-Löf", last);</pre> </div>
<h4 id="method.chars" class="method"><span id="chars.v" class="invisible"><code>fn <a href="#method.chars" class="fnname">chars</a>(&amp;self) -&gt; <a class="struct" href="../str/struct.chars/" title="std::str::Chars">Chars</a></code></span></h4> <div class="docblock">
<p>Returns an iterator over the <code>char</code>s of a string slice.</p> <p>As a string slice consists of valid UTF-8, we can iterate through a string slice by <a href="../primitive.char/"><code>char</code></a>. This method returns such an iterator.</p> <p>It's important to remember that <a href="../primitive.char/"><code>char</code></a> represents a Unicode Scalar Value, and may not match your idea of what a 'character' is. Iteration over grapheme clusters may be what you actually want.</p> <h4 id="examples-9" class="section-header">Examples</h4> <p>Basic usage:</p> <pre class="rust rust-example-rendered" data-language="rust">
let word = "goodbye";

let count = word.chars().count();
assert_eq!(7, count);

let mut chars = word.chars();

assert_eq!(Some('g'), chars.next());
assert_eq!(Some('o'), chars.next());
assert_eq!(Some('o'), chars.next());
assert_eq!(Some('d'), chars.next());
assert_eq!(Some('b'), chars.next());
assert_eq!(Some('y'), chars.next());
assert_eq!(Some('e'), chars.next());

assert_eq!(None, chars.next());</pre> <p>Remember, <a href="../primitive.char/"><code>char</code></a>s may not match your human intuition about characters:</p> <pre class="rust rust-example-rendered" data-language="rust">
let y = "y̆";

let mut chars = y.chars();

assert_eq!(Some('y'), chars.next()); // not 'y̆'
assert_eq!(Some('\u{0306}'), chars.next());

assert_eq!(None, chars.next());</pre> </div>
<h4 id="method.char_indices" class="method"><span id="char_indices.v" class="invisible"><code>fn <a href="#method.char_indices" class="fnname">char_indices</a>(&amp;self) -&gt; <a class="struct" href="../str/struct.charindices/" title="std::str::CharIndices">CharIndices</a></code></span></h4> <div class="docblock">
<p>Returns an iterator over the <a href="../primitive.char/"><code>char</code></a>s of a string slice, and their positions.</p> <p>As a string slice consists of valid UTF-8, we can iterate through a string slice by <a href="../primitive.char/"><code>char</code></a>. This method returns an iterator of both these <a href="../primitive.char/"><code>char</code></a>s, as well as their byte positions.</p> <p>The iterator yields tuples. The position is first, the <a href="../primitive.char/"><code>char</code></a> is second.</p> <h4 id="examples-10" class="section-header">Examples</h4> <p>Basic usage:</p> <pre class="rust rust-example-rendered" data-language="rust">
let word = "goodbye";

let count = word.char_indices().count();
assert_eq!(7, count);

let mut char_indices = word.char_indices();

assert_eq!(Some((0, 'g')), char_indices.next());
assert_eq!(Some((1, 'o')), char_indices.next());
assert_eq!(Some((2, 'o')), char_indices.next());
assert_eq!(Some((3, 'd')), char_indices.next());
assert_eq!(Some((4, 'b')), char_indices.next());
assert_eq!(Some((5, 'y')), char_indices.next());
assert_eq!(Some((6, 'e')), char_indices.next());

assert_eq!(None, char_indices.next());</pre> <p>Remember, <a href="../primitive.char/"><code>char</code></a>s may not match your human intuition about characters:</p> <pre class="rust rust-example-rendered" data-language="rust">
let y = "y̆";

let mut char_indices = y.char_indices();

assert_eq!(Some((0, 'y')), char_indices.next()); // not (0, 'y̆')
assert_eq!(Some((1, '\u{0306}')), char_indices.next());

assert_eq!(None, char_indices.next());</pre> </div>
<h4 id="method.bytes" class="method"><span id="bytes.v" class="invisible"><code>fn <a href="#method.bytes" class="fnname">bytes</a>(&amp;self) -&gt; <a class="struct" href="../str/struct.bytes/" title="std::str::Bytes">Bytes</a></code></span></h4> <div class="docblock">
<p>An iterator over the bytes of a string slice.</p> <p>As a string slice consists of a sequence of bytes, we can iterate through a string slice by byte. This method returns such an iterator.</p> <h4 id="examples-11" class="section-header">Examples</h4> <p>Basic usage:</p> <pre class="rust rust-example-rendered" data-language="rust">
let mut bytes = "bors".bytes();

assert_eq!(Some(b'b'), bytes.next());
assert_eq!(Some(b'o'), bytes.next());
assert_eq!(Some(b'r'), bytes.next());
assert_eq!(Some(b's'), bytes.next());

assert_eq!(None, bytes.next());</pre> </div>
<h4 id="method.split_whitespace" class="method"><span id="split_whitespace.v" class="invisible"><code>fn <a href="#method.split_whitespace" class="fnname">split_whitespace</a>(&amp;self) -&gt; <a class="struct" href="../str/struct.splitwhitespace/" title="std::str::SplitWhitespace">SplitWhitespace</a></code><div class="since" title="Stable since Rust version 1.1.0">1.1.0</div></span></h4> <div class="docblock">
<p>Split a string slice by whitespace.</p> <p>The iterator returned will return string slices that are sub-slices of the original string slice, separated by any amount of whitespace.</p> <p>'Whitespace' is defined according to the terms of the Unicode Derived Core Property <code>White_Space</code>.</p> <h4 id="examples-12" class="section-header">Examples</h4> <p>Basic usage:</p> <pre class="rust rust-example-rendered" data-language="rust">
let mut iter = "A few words".split_whitespace();

assert_eq!(Some("A"), iter.next());
assert_eq!(Some("few"), iter.next());
assert_eq!(Some("words"), iter.next());

assert_eq!(None, iter.next());</pre> <p>All kinds of whitespace are considered:</p> <pre class="rust rust-example-rendered" data-language="rust">
let mut iter = " Mary   had\ta\u{2009}little  \n\t lamb".split_whitespace();
assert_eq!(Some("Mary"), iter.next());
assert_eq!(Some("had"), iter.next());
assert_eq!(Some("a"), iter.next());
assert_eq!(Some("little"), iter.next());
assert_eq!(Some("lamb"), iter.next());

assert_eq!(None, iter.next());</pre> </div>
<h4 id="method.lines" class="method"><span id="lines.v" class="invisible"><code>fn <a href="#method.lines" class="fnname">lines</a>(&amp;self) -&gt; <a class="struct" href="../str/struct.lines/" title="std::str::Lines">Lines</a></code></span></h4> <div class="docblock">
<p>An iterator over the lines of a string, as string slices.</p> <p>Lines are ended with either a newline (<code>\n</code>) or a carriage return with a line feed (<code>\r\n</code>).</p> <p>The final line ending is optional.</p> <h4 id="examples-13" class="section-header">Examples</h4> <p>Basic usage:</p> <pre class="rust rust-example-rendered" data-language="rust">
let text = "foo\r\nbar\n\nbaz\n";
let mut lines = text.lines();

assert_eq!(Some("foo"), lines.next());
assert_eq!(Some("bar"), lines.next());
assert_eq!(Some(""), lines.next());
assert_eq!(Some("baz"), lines.next());

assert_eq!(None, lines.next());</pre> <p>The final line ending isn't required:</p> <pre class="rust rust-example-rendered" data-language="rust">
let text = "foo\nbar\n\r\nbaz";
let mut lines = text.lines();

assert_eq!(Some("foo"), lines.next());
assert_eq!(Some("bar"), lines.next());
assert_eq!(Some(""), lines.next());
assert_eq!(Some("baz"), lines.next());

assert_eq!(None, lines.next());</pre> </div>
<h4 id="method.lines_any" class="method"><span id="lines_any.v" class="invisible"><code>fn <a href="#method.lines_any" class="fnname">lines_any</a>(&amp;self) -&gt; <a class="struct" href="../str/struct.linesany/" title="std::str::LinesAny">LinesAny</a></code></span></h4> <div class="stability"><span class="stab deprecated">Deprecated since 1.4.0: use lines() instead now </span></div>
<div class="docblock">
<p>An iterator over the lines of a string.</p> </div>
<h4 id="method.encode_utf16" class="method"><span id="encode_utf16.v" class="invisible"><code>fn <a href="#method.encode_utf16" class="fnname">encode_utf16</a>(&amp;self) -&gt; <a class="struct" href="../str/struct.encodeutf16/" title="std::str::EncodeUtf16">EncodeUtf16</a></code><div class="since" title="Stable since Rust version 1.8.0">1.8.0</div></span></h4> <div class="docblock">
<p>Returns an iterator of <code>u16</code> over the string encoded as UTF-16.</p> </div>
<h4 id="method.contains" class="method"><span id="contains.v" class="invisible"><code>fn <a href="#method.contains" class="fnname">contains</a>&lt;'a, P&gt;(&amp;'a self, pat: P) -&gt; <a class="primitive" href="../primitive.bool/">bool</a> <span class="where fmt-newline">where P: <a class="trait" href="../str/pattern/trait.pattern/" title="std::str::pattern::Pattern">Pattern</a>&lt;'a&gt;</span></code></span></h4> <div class="docblock">
<p>Returns <code>true</code> if the given pattern matches a sub-slice of this string slice.</p> <p>Returns <code>false</code> if it does not.</p> <h4 id="examples-14" class="section-header">Examples</h4> <p>Basic usage:</p> <pre class="rust rust-example-rendered" data-language="rust">
let bananas = "bananas";

assert!(bananas.contains("nana"));
assert!(!bananas.contains("apples"));</pre> </div>
<h4 id="method.starts_with" class="method"><span id="starts_with.v" class="invisible"><code>fn <a href="#method.starts_with" class="fnname">starts_with</a>&lt;'a, P&gt;(&amp;'a self, pat: P) -&gt; <a class="primitive" href="../primitive.bool/">bool</a> <span class="where fmt-newline">where P: <a class="trait" href="../str/pattern/trait.pattern/" title="std::str::pattern::Pattern">Pattern</a>&lt;'a&gt;</span></code></span></h4> <div class="docblock">
<p>Returns <code>true</code> if the given pattern matches a prefix of this string slice.</p> <p>Returns <code>false</code> if it does not.</p> <h4 id="examples-15" class="section-header">Examples</h4> <p>Basic usage:</p> <pre class="rust rust-example-rendered" data-language="rust">
let bananas = "bananas";

assert!(bananas.starts_with("bana"));
assert!(!bananas.starts_with("nana"));</pre> </div>
<h4 id="method.ends_with" class="method"><span id="ends_with.v" class="invisible"><code>fn <a href="#method.ends_with" class="fnname">ends_with</a>&lt;'a, P&gt;(&amp;'a self, pat: P) -&gt; <a class="primitive" href="../primitive.bool/">bool</a> <span class="where fmt-newline">where P: <a class="trait" href="../str/pattern/trait.pattern/" title="std::str::pattern::Pattern">Pattern</a>&lt;'a&gt;, P::<a class="trait" href="../str/pattern/trait.pattern/" title="std::str::pattern::Pattern">Searcher</a>: <a class="trait" href="../str/pattern/trait.reversesearcher/" title="std::str::pattern::ReverseSearcher">ReverseSearcher</a>&lt;'a&gt;</span></code></span></h4> <div class="docblock">
<p>Returns <code>true</code> if the given pattern matches a suffix of this string slice.</p> <p>Returns <code>false</code> if it does not.</p> <h4 id="examples-16" class="section-header">Examples</h4> <p>Basic usage:</p> <pre class="rust rust-example-rendered" data-language="rust">
let bananas = "bananas";

assert!(bananas.ends_with("anas"));
assert!(!bananas.ends_with("nana"));</pre> </div>
<h4 id="method.find" class="method"><span id="find.v" class="invisible"><code>fn <a href="#method.find" class="fnname">find</a>&lt;'a, P&gt;(&amp;'a self, pat: P) -&gt; <a class="enum" href="../option/enum.option/" title="std::option::Option">Option</a>&lt;<a class="primitive" href="../primitive.usize/">usize</a>&gt; <span class="where fmt-newline">where P: <a class="trait" href="../str/pattern/trait.pattern/" title="std::str::pattern::Pattern">Pattern</a>&lt;'a&gt;</span></code></span></h4> <div class="docblock">
<p>Returns the byte index of the first character of this string slice that matches the pattern.</p> <p>Returns <a href="../option/enum.option/#variant.None"><code>None</code></a> if the pattern doesn't match.</p> <p>The pattern can be a <code>&amp;str</code>, <a href="../primitive.char/"><code>char</code></a>, or a closure that determines if a character matches.</p> <h4 id="examples-17" class="section-header">Examples</h4> <p>Simple patterns:</p> <pre class="rust rust-example-rendered" data-language="rust">
let s = "Löwe 老虎 Léopard";

assert_eq!(s.find('L'), Some(0));
assert_eq!(s.find('é'), Some(14));
assert_eq!(s.find("Léopard"), Some(13));</pre> <p>More complex patterns with closures:</p> <pre class="rust rust-example-rendered" data-language="rust">
let s = "Löwe 老虎 Léopard";

assert_eq!(s.find(char::is_whitespace), Some(5));
assert_eq!(s.find(char::is_lowercase), Some(1));</pre> <p>Not finding the pattern:</p> <pre class="rust rust-example-rendered" data-language="rust">
let s = "Löwe 老虎 Léopard";
let x: &amp;[_] = &amp;['1', '2'];

assert_eq!(s.find(x), None);</pre> </div>
<h4 id="method.rfind" class="method"><span id="rfind.v" class="invisible"><code>fn <a href="#method.rfind" class="fnname">rfind</a>&lt;'a, P&gt;(&amp;'a self, pat: P) -&gt; <a class="enum" href="../option/enum.option/" title="std::option::Option">Option</a>&lt;<a class="primitive" href="../primitive.usize/">usize</a>&gt; <span class="where fmt-newline">where P: <a class="trait" href="../str/pattern/trait.pattern/" title="std::str::pattern::Pattern">Pattern</a>&lt;'a&gt;, P::<a class="trait" href="../str/pattern/trait.pattern/" title="std::str::pattern::Pattern">Searcher</a>: <a class="trait" href="../str/pattern/trait.reversesearcher/" title="std::str::pattern::ReverseSearcher">ReverseSearcher</a>&lt;'a&gt;</span></code></span></h4> <div class="docblock">
<p>Returns the byte index of the last character of this string slice that matches the pattern.</p> <p>Returns <a href="../option/enum.option/#variant.None"><code>None</code></a> if the pattern doesn't match.</p> <p>The pattern can be a <code>&amp;str</code>, <a href="../primitive.char/"><code>char</code></a>, or a closure that determines if a character matches.</p> <h4 id="examples-18" class="section-header">Examples</h4> <p>Simple patterns:</p> <pre class="rust rust-example-rendered" data-language="rust">
let s = "Löwe 老虎 Léopard";

assert_eq!(s.rfind('L'), Some(13));
assert_eq!(s.rfind('é'), Some(14));</pre> <p>More complex patterns with closures:</p> <pre class="rust rust-example-rendered" data-language="rust">
let s = "Löwe 老虎 Léopard";

assert_eq!(s.rfind(char::is_whitespace), Some(12));
assert_eq!(s.rfind(char::is_lowercase), Some(20));</pre> <p>Not finding the pattern:</p> <pre class="rust rust-example-rendered" data-language="rust">
let s = "Löwe 老虎 Léopard";
let x: &amp;[_] = &amp;['1', '2'];

assert_eq!(s.rfind(x), None);</pre> </div>
<h4 id="method.split" class="method"><span id="split.v" class="invisible"><code>fn <a href="#method.split" class="fnname">split</a>&lt;'a, P&gt;(&amp;'a self, pat: P) -&gt; <a class="struct" href="../str/struct.split/" title="std::str::Split">Split</a>&lt;'a, P&gt; <span class="where fmt-newline">where P: <a class="trait" href="../str/pattern/trait.pattern/" title="std::str::pattern::Pattern">Pattern</a>&lt;'a&gt;</span></code></span></h4> <div class="docblock">
<p>An iterator over substrings of this string slice, separated by characters matched by a pattern.</p> <p>The pattern can be a <code>&amp;str</code>, <a href="../primitive.char/"><code>char</code></a>, or a closure that determines the split.</p> <h4 id="iterator-behavior" class="section-header">Iterator behavior</h4> <p>The returned iterator will be a <a href="../iter/trait.doubleendediterator/"><code>DoubleEndedIterator</code></a> if the pattern allows a reverse search and forward/reverse search yields the same elements. This is true for, eg, <a href="../primitive.char/"><code>char</code></a> but not for <code>&amp;str</code>.</p> <p>If the pattern allows a reverse search but its results might differ from a forward search, the <a href="#method.rsplit"><code>rsplit()</code></a> method can be used.</p> <h4 id="examples-19" class="section-header">Examples</h4> <p>Simple patterns:</p> <pre class="rust rust-example-rendered" data-language="rust">
let v: Vec&lt;&amp;str&gt; = "Mary had a little lamb".split(' ').collect();
assert_eq!(v, ["Mary", "had", "a", "little", "lamb"]);

let v: Vec&lt;&amp;str&gt; = "".split('X').collect();
assert_eq!(v, [""]);

let v: Vec&lt;&amp;str&gt; = "lionXXtigerXleopard".split('X').collect();
assert_eq!(v, ["lion", "", "tiger", "leopard"]);

let v: Vec&lt;&amp;str&gt; = "lion::tiger::leopard".split("::").collect();
assert_eq!(v, ["lion", "tiger", "leopard"]);

let v: Vec&lt;&amp;str&gt; = "abc1def2ghi".split(char::is_numeric).collect();
assert_eq!(v, ["abc", "def", "ghi"]);

let v: Vec&lt;&amp;str&gt; = "lionXtigerXleopard".split(char::is_uppercase).collect();
assert_eq!(v, ["lion", "tiger", "leopard"]);</pre> <p>A more complex pattern, using a closure:</p> <pre class="rust rust-example-rendered" data-language="rust">
let v: Vec&lt;&amp;str&gt; = "abc1defXghi".split(|c| c == '1' || c == 'X').collect();
assert_eq!(v, ["abc", "def", "ghi"]);</pre> <p>If a string contains multiple contiguous separators, you will end up with empty strings in the output:</p> <pre class="rust rust-example-rendered" data-language="rust">
let x = "||||a||b|c".to_string();
let d: Vec&lt;_&gt; = x.split('|').collect();

assert_eq!(d, &amp;["", "", "", "", "a", "", "b", "c"]);</pre> <p>Contiguous separators are separated by the empty string.</p> <pre class="rust rust-example-rendered" data-language="rust">
let x = "(///)".to_string();
let d: Vec&lt;_&gt; = x.split('/').collect();;

assert_eq!(d, &amp;["(", "", "", ")"]);</pre> <p>Separators at the start or end of a string are neighbored by empty strings.</p> <pre class="rust rust-example-rendered" data-language="rust">
let d: Vec&lt;_&gt; = "010".split("0").collect();
assert_eq!(d, &amp;["", "1", ""]);</pre> <p>When the empty string is used as a separator, it separates every character in the string, along with the beginning and end of the string.</p> <pre class="rust rust-example-rendered" data-language="rust">
let f: Vec&lt;_&gt; = "rust".split("").collect();
assert_eq!(f, &amp;["", "r", "u", "s", "t", ""]);</pre> <p>Contiguous separators can lead to possibly surprising behavior when whitespace is used as the separator. This code is correct:</p> <pre class="rust rust-example-rendered" data-language="rust">
let x = "    a  b c".to_string();
let d: Vec&lt;_&gt; = x.split(' ').collect();

assert_eq!(d, &amp;["", "", "", "", "a", "", "b", "c"]);</pre> <p>It does <em>not</em> give you:</p> <pre class="rust rust-example-rendered" data-language="rust">
assert_eq!(d, &amp;["a", "b", "c"]);</pre> <p>Use <a href="#method.split_whitespace"><code>split_whitespace()</code></a> for this behavior.</p> </div>
<h4 id="method.rsplit" class="method"><span id="rsplit.v" class="invisible"><code>fn <a href="#method.rsplit" class="fnname">rsplit</a>&lt;'a, P&gt;(&amp;'a self, pat: P) -&gt; <a class="struct" href="../str/struct.rsplit/" title="std::str::RSplit">RSplit</a>&lt;'a, P&gt; <span class="where fmt-newline">where P: <a class="trait" href="../str/pattern/trait.pattern/" title="std::str::pattern::Pattern">Pattern</a>&lt;'a&gt;, P::<a class="trait" href="../str/pattern/trait.pattern/" title="std::str::pattern::Pattern">Searcher</a>: <a class="trait" href="../str/pattern/trait.reversesearcher/" title="std::str::pattern::ReverseSearcher">ReverseSearcher</a>&lt;'a&gt;</span></code></span></h4> <div class="docblock">
<p>An iterator over substrings of the given string slice, separated by characters matched by a pattern and yielded in reverse order.</p> <p>The pattern can be a <code>&amp;str</code>, <a href="../primitive.char/"><code>char</code></a>, or a closure that determines the split.</p> <h4 id="iterator-behavior-1" class="section-header">Iterator behavior</h4> <p>The returned iterator requires that the pattern supports a reverse search, and it will be a <a href="../iter/trait.doubleendediterator/"><code>DoubleEndedIterator</code></a> if a forward/reverse search yields the same elements.</p> <p>For iterating from the front, the <a href="#method.split"><code>split()</code></a> method can be used.</p> <h4 id="examples-20" class="section-header">Examples</h4> <p>Simple patterns:</p> <pre class="rust rust-example-rendered" data-language="rust">
let v: Vec&lt;&amp;str&gt; = "Mary had a little lamb".rsplit(' ').collect();
assert_eq!(v, ["lamb", "little", "a", "had", "Mary"]);

let v: Vec&lt;&amp;str&gt; = "".rsplit('X').collect();
assert_eq!(v, [""]);

let v: Vec&lt;&amp;str&gt; = "lionXXtigerXleopard".rsplit('X').collect();
assert_eq!(v, ["leopard", "tiger", "", "lion"]);

let v: Vec&lt;&amp;str&gt; = "lion::tiger::leopard".rsplit("::").collect();
assert_eq!(v, ["leopard", "tiger", "lion"]);</pre> <p>A more complex pattern, using a closure:</p> <pre class="rust rust-example-rendered" data-language="rust">
let v: Vec&lt;&amp;str&gt; = "abc1defXghi".rsplit(|c| c == '1' || c == 'X').collect();
assert_eq!(v, ["ghi", "def", "abc"]);</pre> </div>
<h4 id="method.split_terminator" class="method"><span id="split_terminator.v" class="invisible"><code>fn <a href="#method.split_terminator" class="fnname">split_terminator</a>&lt;'a, P&gt;(&amp;'a self, pat: P) -&gt; <a class="struct" href="../str/struct.splitterminator/" title="std::str::SplitTerminator">SplitTerminator</a>&lt;'a, P&gt; <span class="where fmt-newline">where P: <a class="trait" href="../str/pattern/trait.pattern/" title="std::str::pattern::Pattern">Pattern</a>&lt;'a&gt;</span></code></span></h4> <div class="docblock">
<p>An iterator over substrings of the given string slice, separated by characters matched by a pattern.</p> <p>The pattern can be a <code>&amp;str</code>, <a href="../primitive.char/"><code>char</code></a>, or a closure that determines the split.</p> <p>Equivalent to <a href="#method.split"><code>split()</code></a>, except that the trailing substring is skipped if empty.</p> <p>This method can be used for string data that is <em>terminated</em>, rather than <em>separated</em> by a pattern.</p> <h4 id="iterator-behavior-2" class="section-header">Iterator behavior</h4> <p>The returned iterator will be a <a href="../iter/trait.doubleendediterator/"><code>DoubleEndedIterator</code></a> if the pattern allows a reverse search and forward/reverse search yields the same elements. This is true for, eg, <a href="../primitive.char/"><code>char</code></a> but not for <code>&amp;str</code>.</p> <p>If the pattern allows a reverse search but its results might differ from a forward search, the <a href="#method.rsplit_terminator"><code>rsplit_terminator()</code></a> method can be used.</p> <h4 id="examples-21" class="section-header">Examples</h4> <p>Basic usage:</p> <pre class="rust rust-example-rendered" data-language="rust">
let v: Vec&lt;&amp;str&gt; = "A.B.".split_terminator('.').collect();
assert_eq!(v, ["A", "B"]);

let v: Vec&lt;&amp;str&gt; = "A..B..".split_terminator(".").collect();
assert_eq!(v, ["A", "", "B", ""]);</pre> </div>
<h4 id="method.rsplit_terminator" class="method"><span id="rsplit_terminator.v" class="invisible"><code>fn <a href="#method.rsplit_terminator" class="fnname">rsplit_terminator</a>&lt;'a, P&gt;(&amp;'a self, pat: P) -&gt; <a class="struct" href="../str/struct.rsplitterminator/" title="std::str::RSplitTerminator">RSplitTerminator</a>&lt;'a, P&gt; <span class="where fmt-newline">where P: <a class="trait" href="../str/pattern/trait.pattern/" title="std::str::pattern::Pattern">Pattern</a>&lt;'a&gt;, P::<a class="trait" href="../str/pattern/trait.pattern/" title="std::str::pattern::Pattern">Searcher</a>: <a class="trait" href="../str/pattern/trait.reversesearcher/" title="std::str::pattern::ReverseSearcher">ReverseSearcher</a>&lt;'a&gt;</span></code></span></h4> <div class="docblock">
<p>An iterator over substrings of <code>self</code>, separated by characters matched by a pattern and yielded in reverse order.</p> <p>The pattern can be a simple <code>&amp;str</code>, <a href="../primitive.char/"><code>char</code></a>, or a closure that determines the split. Additional libraries might provide more complex patterns like regular expressions.</p> <p>Equivalent to <a href="#method.split"><code>split()</code></a>, except that the trailing substring is skipped if empty.</p> <p>This method can be used for string data that is <em>terminated</em>, rather than <em>separated</em> by a pattern.</p> <h4 id="iterator-behavior-3" class="section-header">Iterator behavior</h4> <p>The returned iterator requires that the pattern supports a reverse search, and it will be double ended if a forward/reverse search yields the same elements.</p> <p>For iterating from the front, the <a href="#method.split_terminator"><code>split_terminator()</code></a> method can be used.</p> <h4 id="examples-22" class="section-header">Examples</h4> <pre class="rust rust-example-rendered" data-language="rust">
let v: Vec&lt;&amp;str&gt; = "A.B.".rsplit_terminator('.').collect();
assert_eq!(v, ["B", "A"]);

let v: Vec&lt;&amp;str&gt; = "A..B..".rsplit_terminator(".").collect();
assert_eq!(v, ["", "B", "", "A"]);</pre> </div>
<h4 id="method.splitn" class="method"><span id="splitn.v" class="invisible"><code>fn <a href="#method.splitn" class="fnname">splitn</a>&lt;'a, P&gt;(&amp;'a self, n: <a class="primitive" href="../primitive.usize/">usize</a>, pat: P) -&gt; <a class="struct" href="../str/struct.splitn/" title="std::str::SplitN">SplitN</a>&lt;'a, P&gt; <span class="where fmt-newline">where P: <a class="trait" href="../str/pattern/trait.pattern/" title="std::str::pattern::Pattern">Pattern</a>&lt;'a&gt;</span></code></span></h4> <div class="docblock">
<p>An iterator over substrings of the given string slice, separated by a pattern, restricted to returning at most <code>n</code> items.</p> <p>If <code>n</code> substrings are returned, the last substring (the <code>n</code>th substring) will contain the remainder of the string.</p> <p>The pattern can be a <code>&amp;str</code>, <a href="../primitive.char/"><code>char</code></a>, or a closure that determines the split.</p> <h4 id="iterator-behavior-4" class="section-header">Iterator behavior</h4> <p>The returned iterator will not be double ended, because it is not efficient to support.</p> <p>If the pattern allows a reverse search, the <a href="#method.rsplitn"><code>rsplitn()</code></a> method can be used.</p> <h4 id="examples-23" class="section-header">Examples</h4> <p>Simple patterns:</p> <pre class="rust rust-example-rendered" data-language="rust">
let v: Vec&lt;&amp;str&gt; = "Mary had a little lambda".splitn(3, ' ').collect();
assert_eq!(v, ["Mary", "had", "a little lambda"]);

let v: Vec&lt;&amp;str&gt; = "lionXXtigerXleopard".splitn(3, "X").collect();
assert_eq!(v, ["lion", "", "tigerXleopard"]);

let v: Vec&lt;&amp;str&gt; = "abcXdef".splitn(1, 'X').collect();
assert_eq!(v, ["abcXdef"]);

let v: Vec&lt;&amp;str&gt; = "".splitn(1, 'X').collect();
assert_eq!(v, [""]);</pre> <p>A more complex pattern, using a closure:</p> <pre class="rust rust-example-rendered" data-language="rust">
let v: Vec&lt;&amp;str&gt; = "abc1defXghi".splitn(2, |c| c == '1' || c == 'X').collect();
assert_eq!(v, ["abc", "defXghi"]);</pre> </div>
<h4 id="method.rsplitn" class="method"><span id="rsplitn.v" class="invisible"><code>fn <a href="#method.rsplitn" class="fnname">rsplitn</a>&lt;'a, P&gt;(&amp;'a self, n: <a class="primitive" href="../primitive.usize/">usize</a>, pat: P) -&gt; <a class="struct" href="../str/struct.rsplitn/" title="std::str::RSplitN">RSplitN</a>&lt;'a, P&gt; <span class="where fmt-newline">where P: <a class="trait" href="../str/pattern/trait.pattern/" title="std::str::pattern::Pattern">Pattern</a>&lt;'a&gt;, P::<a class="trait" href="../str/pattern/trait.pattern/" title="std::str::pattern::Pattern">Searcher</a>: <a class="trait" href="../str/pattern/trait.reversesearcher/" title="std::str::pattern::ReverseSearcher">ReverseSearcher</a>&lt;'a&gt;</span></code></span></h4> <div class="docblock">
<p>An iterator over substrings of this string slice, separated by a pattern, starting from the end of the string, restricted to returning at most <code>n</code> items.</p> <p>If <code>n</code> substrings are returned, the last substring (the <code>n</code>th substring) will contain the remainder of the string.</p> <p>The pattern can be a <code>&amp;str</code>, <a href="../primitive.char/"><code>char</code></a>, or a closure that determines the split.</p> <h4 id="iterator-behavior-5" class="section-header">Iterator behavior</h4> <p>The returned iterator will not be double ended, because it is not efficient to support.</p> <p>For splitting from the front, the <a href="#method.splitn"><code>splitn()</code></a> method can be used.</p> <h4 id="examples-24" class="section-header">Examples</h4> <p>Simple patterns:</p> <pre class="rust rust-example-rendered" data-language="rust">
let v: Vec&lt;&amp;str&gt; = "Mary had a little lamb".rsplitn(3, ' ').collect();
assert_eq!(v, ["lamb", "little", "Mary had a"]);

let v: Vec&lt;&amp;str&gt; = "lionXXtigerXleopard".rsplitn(3, 'X').collect();
assert_eq!(v, ["leopard", "tiger", "lionX"]);

let v: Vec&lt;&amp;str&gt; = "lion::tiger::leopard".rsplitn(2, "::").collect();
assert_eq!(v, ["leopard", "lion::tiger"]);</pre> <p>A more complex pattern, using a closure:</p> <pre class="rust rust-example-rendered" data-language="rust">
let v: Vec&lt;&amp;str&gt; = "abc1defXghi".rsplitn(2, |c| c == '1' || c == 'X').collect();
assert_eq!(v, ["ghi", "abc1def"]);</pre> </div>
<h4 id="method.matches" class="method"><span id="matches.v" class="invisible"><code>fn <a href="#method.matches" class="fnname">matches</a>&lt;'a, P&gt;(&amp;'a self, pat: P) -&gt; <a class="struct" href="../str/struct.matches/" title="std::str::Matches">Matches</a>&lt;'a, P&gt; <span class="where fmt-newline">where P: <a class="trait" href="../str/pattern/trait.pattern/" title="std::str::pattern::Pattern">Pattern</a>&lt;'a&gt;</span></code><div class="since" title="Stable since Rust version 1.2.0">1.2.0</div></span></h4> <div class="docblock">
<p>An iterator over the matches of a pattern within the given string slice.</p> <p>The pattern can be a <code>&amp;str</code>, <a href="../primitive.char/"><code>char</code></a>, or a closure that determines if a character matches.</p> <h4 id="iterator-behavior-6" class="section-header">Iterator behavior</h4> <p>The returned iterator will be a <a href="../iter/trait.doubleendediterator/"><code>DoubleEndedIterator</code></a> if the pattern allows a reverse search and forward/reverse search yields the same elements. This is true for, eg, <a href="../primitive.char/"><code>char</code></a> but not for <code>&amp;str</code>.</p> <p>If the pattern allows a reverse search but its results might differ from a forward search, the <a href="#method.rmatches"><code>rmatches()</code></a> method can be used.</p> <h4 id="examples-25" class="section-header">Examples</h4> <p>Basic usage:</p> <pre class="rust rust-example-rendered" data-language="rust">
let v: Vec&lt;&amp;str&gt; = "abcXXXabcYYYabc".matches("abc").collect();
assert_eq!(v, ["abc", "abc", "abc"]);

let v: Vec&lt;&amp;str&gt; = "1abc2abc3".matches(char::is_numeric).collect();
assert_eq!(v, ["1", "2", "3"]);</pre> </div>
<h4 id="method.rmatches" class="method"><span id="rmatches.v" class="invisible"><code>fn <a href="#method.rmatches" class="fnname">rmatches</a>&lt;'a, P&gt;(&amp;'a self, pat: P) -&gt; <a class="struct" href="../str/struct.rmatches/" title="std::str::RMatches">RMatches</a>&lt;'a, P&gt; <span class="where fmt-newline">where P: <a class="trait" href="../str/pattern/trait.pattern/" title="std::str::pattern::Pattern">Pattern</a>&lt;'a&gt;, P::<a class="trait" href="../str/pattern/trait.pattern/" title="std::str::pattern::Pattern">Searcher</a>: <a class="trait" href="../str/pattern/trait.reversesearcher/" title="std::str::pattern::ReverseSearcher">ReverseSearcher</a>&lt;'a&gt;</span></code><div class="since" title="Stable since Rust version 1.2.0">1.2.0</div></span></h4> <div class="docblock">
<p>An iterator over the matches of a pattern within this string slice, yielded in reverse order.</p> <p>The pattern can be a <code>&amp;str</code>, <a href="../primitive.char/"><code>char</code></a>, or a closure that determines if a character matches.</p> <h4 id="iterator-behavior-7" class="section-header">Iterator behavior</h4> <p>The returned iterator requires that the pattern supports a reverse search, and it will be a <a href="../iter/trait.doubleendediterator/"><code>DoubleEndedIterator</code></a> if a forward/reverse search yields the same elements.</p> <p>For iterating from the front, the <a href="#method.matches"><code>matches()</code></a> method can be used.</p> <h4 id="examples-26" class="section-header">Examples</h4> <p>Basic usage:</p> <pre class="rust rust-example-rendered" data-language="rust">
let v: Vec&lt;&amp;str&gt; = "abcXXXabcYYYabc".rmatches("abc").collect();
assert_eq!(v, ["abc", "abc", "abc"]);

let v: Vec&lt;&amp;str&gt; = "1abc2abc3".rmatches(char::is_numeric).collect();
assert_eq!(v, ["3", "2", "1"]);</pre> </div>
<h4 id="method.match_indices" class="method"><span id="match_indices.v" class="invisible"><code>fn <a href="#method.match_indices" class="fnname">match_indices</a>&lt;'a, P&gt;(&amp;'a self, pat: P) -&gt; <a class="struct" href="../str/struct.matchindices/" title="std::str::MatchIndices">MatchIndices</a>&lt;'a, P&gt; <span class="where fmt-newline">where P: <a class="trait" href="../str/pattern/trait.pattern/" title="std::str::pattern::Pattern">Pattern</a>&lt;'a&gt;</span></code><div class="since" title="Stable since Rust version 1.5.0">1.5.0</div></span></h4> <div class="docblock">
<p>An iterator over the disjoint matches of a pattern within this string slice as well as the index that the match starts at.</p> <p>For matches of <code>pat</code> within <code>self</code> that overlap, only the indices corresponding to the first match are returned.</p> <p>The pattern can be a <code>&amp;str</code>, <a href="../primitive.char/"><code>char</code></a>, or a closure that determines if a character matches.</p> <h4 id="iterator-behavior-8" class="section-header">Iterator behavior</h4> <p>The returned iterator will be a <a href="../iter/trait.doubleendediterator/"><code>DoubleEndedIterator</code></a> if the pattern allows a reverse search and forward/reverse search yields the same elements. This is true for, eg, <a href="../primitive.char/"><code>char</code></a> but not for <code>&amp;str</code>.</p> <p>If the pattern allows a reverse search but its results might differ from a forward search, the <a href="#method.rmatch_indices"><code>rmatch_indices()</code></a> method can be used.</p> <h4 id="examples-27" class="section-header">Examples</h4> <p>Basic usage:</p> <pre class="rust rust-example-rendered" data-language="rust">
let v: Vec&lt;_&gt; = "abcXXXabcYYYabc".match_indices("abc").collect();
assert_eq!(v, [(0, "abc"), (6, "abc"), (12, "abc")]);

let v: Vec&lt;_&gt; = "1abcabc2".match_indices("abc").collect();
assert_eq!(v, [(1, "abc"), (4, "abc")]);

let v: Vec&lt;_&gt; = "ababa".match_indices("aba").collect();
assert_eq!(v, [(0, "aba")]); // only the first `aba`</pre> </div>
<h4 id="method.rmatch_indices" class="method"><span id="rmatch_indices.v" class="invisible"><code>fn <a href="#method.rmatch_indices" class="fnname">rmatch_indices</a>&lt;'a, P&gt;(&amp;'a self, pat: P) -&gt; <a class="struct" href="../str/struct.rmatchindices/" title="std::str::RMatchIndices">RMatchIndices</a>&lt;'a, P&gt; <span class="where fmt-newline">where P: <a class="trait" href="../str/pattern/trait.pattern/" title="std::str::pattern::Pattern">Pattern</a>&lt;'a&gt;, P::<a class="trait" href="../str/pattern/trait.pattern/" title="std::str::pattern::Pattern">Searcher</a>: <a class="trait" href="../str/pattern/trait.reversesearcher/" title="std::str::pattern::ReverseSearcher">ReverseSearcher</a>&lt;'a&gt;</span></code><div class="since" title="Stable since Rust version 1.5.0">1.5.0</div></span></h4> <div class="docblock">
<p>An iterator over the disjoint matches of a pattern within <code>self</code>, yielded in reverse order along with the index of the match.</p> <p>For matches of <code>pat</code> within <code>self</code> that overlap, only the indices corresponding to the last match are returned.</p> <p>The pattern can be a <code>&amp;str</code>, <a href="../primitive.char/"><code>char</code></a>, or a closure that determines if a character matches.</p> <h4 id="iterator-behavior-9" class="section-header">Iterator behavior</h4> <p>The returned iterator requires that the pattern supports a reverse search, and it will be a <a href="../iter/trait.doubleendediterator/"><code>DoubleEndedIterator</code></a> if a forward/reverse search yields the same elements.</p> <p>For iterating from the front, the <a href="#method.match_indices"><code>match_indices()</code></a> method can be used.</p> <h4 id="examples-28" class="section-header">Examples</h4> <p>Basic usage:</p> <pre class="rust rust-example-rendered" data-language="rust">
let v: Vec&lt;_&gt; = "abcXXXabcYYYabc".rmatch_indices("abc").collect();
assert_eq!(v, [(12, "abc"), (6, "abc"), (0, "abc")]);

let v: Vec&lt;_&gt; = "1abcabc2".rmatch_indices("abc").collect();
assert_eq!(v, [(4, "abc"), (1, "abc")]);

let v: Vec&lt;_&gt; = "ababa".rmatch_indices("aba").collect();
assert_eq!(v, [(2, "aba")]); // only the last `aba`</pre> </div>
<h4 id="method.trim" class="method"><span id="trim.v" class="invisible"><code>fn <a href="#method.trim" class="fnname">trim</a>(&amp;self) -&gt; &amp;<a class="primitive" href="../primitive.str/">str</a></code></span></h4> <div class="docblock">
<p>Returns a string slice with leading and trailing whitespace removed.</p> <p>'Whitespace' is defined according to the terms of the Unicode Derived Core Property <code>White_Space</code>.</p> <h4 id="examples-29" class="section-header">Examples</h4> <p>Basic usage:</p> <pre class="rust rust-example-rendered" data-language="rust">
let s = " Hello\tworld\t";

assert_eq!("Hello\tworld", s.trim());</pre> </div>
<h4 id="method.trim_left" class="method"><span id="trim_left.v" class="invisible"><code>fn <a href="#method.trim_left" class="fnname">trim_left</a>(&amp;self) -&gt; &amp;<a class="primitive" href="../primitive.str/">str</a></code></span></h4> <div class="docblock">
<p>Returns a string slice with leading whitespace removed.</p> <p>'Whitespace' is defined according to the terms of the Unicode Derived Core Property <code>White_Space</code>.</p> <h4 id="text-directionality" class="section-header">Text directionality</h4> <p>A string is a sequence of bytes. 'Left' in this context means the first position of that byte string; for a language like Arabic or Hebrew which are 'right to left' rather than 'left to right', this will be the <em>right</em> side, not the left.</p> <h4 id="examples-30" class="section-header">Examples</h4> <p>Basic usage:</p> <pre class="rust rust-example-rendered" data-language="rust">
let s = " Hello\tworld\t";

assert_eq!("Hello\tworld\t", s.trim_left());</pre> <p>Directionality:</p> <pre class="rust rust-example-rendered" data-language="rust">
let s = "  English";
assert!(Some('E') == s.trim_left().chars().next());

let s = "  עברית";
assert!(Some('ע') == s.trim_left().chars().next());</pre> </div>
<h4 id="method.trim_right" class="method"><span id="trim_right.v" class="invisible"><code>fn <a href="#method.trim_right" class="fnname">trim_right</a>(&amp;self) -&gt; &amp;<a class="primitive" href="../primitive.str/">str</a></code></span></h4> <div class="docblock">
<p>Returns a string slice with trailing whitespace removed.</p> <p>'Whitespace' is defined according to the terms of the Unicode Derived Core Property <code>White_Space</code>.</p> <h4 id="text-directionality-1" class="section-header">Text directionality</h4> <p>A string is a sequence of bytes. 'Right' in this context means the last position of that byte string; for a language like Arabic or Hebrew which are 'right to left' rather than 'left to right', this will be the <em>left</em> side, not the right.</p> <h4 id="examples-31" class="section-header">Examples</h4> <p>Basic usage:</p> <pre class="rust rust-example-rendered" data-language="rust">
let s = " Hello\tworld\t";

assert_eq!(" Hello\tworld", s.trim_right());</pre> <p>Directionality:</p> <pre class="rust rust-example-rendered" data-language="rust">
let s = "English  ";
assert!(Some('h') == s.trim_right().chars().rev().next());

let s = "עברית  ";
assert!(Some('ת') == s.trim_right().chars().rev().next());</pre> </div>
<h4 id="method.trim_matches" class="method"><span id="trim_matches.v" class="invisible"><code>fn <a href="#method.trim_matches" class="fnname">trim_matches</a>&lt;'a, P&gt;(&amp;'a self, pat: P) -&gt; &amp;'a <a class="primitive" href="../primitive.str/">str</a> <span class="where fmt-newline">where P: <a class="trait" href="../str/pattern/trait.pattern/" title="std::str::pattern::Pattern">Pattern</a>&lt;'a&gt;, P::<a class="trait" href="../str/pattern/trait.pattern/" title="std::str::pattern::Pattern">Searcher</a>: <a class="trait" href="../str/pattern/trait.doubleendedsearcher/" title="std::str::pattern::DoubleEndedSearcher">DoubleEndedSearcher</a>&lt;'a&gt;</span></code></span></h4> <div class="docblock">
<p>Returns a string slice with all prefixes and suffixes that match a pattern repeatedly removed.</p> <p>The pattern can be a <a href="../primitive.char/"><code>char</code></a> or a closure that determines if a character matches.</p> <h4 id="examples-32" class="section-header">Examples</h4> <p>Simple patterns:</p> <pre class="rust rust-example-rendered" data-language="rust">
assert_eq!("11foo1bar11".trim_matches('1'), "foo1bar");
assert_eq!("123foo1bar123".trim_matches(char::is_numeric), "foo1bar");

let x: &amp;[_] = &amp;['1', '2'];
assert_eq!("12foo1bar12".trim_matches(x), "foo1bar");</pre> <p>A more complex pattern, using a closure:</p> <pre class="rust rust-example-rendered" data-language="rust">
assert_eq!("1foo1barXX".trim_matches(|c| c == '1' || c == 'X'), "foo1bar");</pre> </div>
<h4 id="method.trim_left_matches" class="method"><span id="trim_left_matches.v" class="invisible"><code>fn <a href="#method.trim_left_matches" class="fnname">trim_left_matches</a>&lt;'a, P&gt;(&amp;'a self, pat: P) -&gt; &amp;'a <a class="primitive" href="../primitive.str/">str</a> <span class="where fmt-newline">where P: <a class="trait" href="../str/pattern/trait.pattern/" title="std::str::pattern::Pattern">Pattern</a>&lt;'a&gt;</span></code></span></h4> <div class="docblock">
<p>Returns a string slice with all prefixes that match a pattern repeatedly removed.</p> <p>The pattern can be a <code>&amp;str</code>, <a href="../primitive.char/"><code>char</code></a>, or a closure that determines if a character matches.</p> <h4 id="text-directionality-2" class="section-header">Text directionality</h4> <p>A string is a sequence of bytes. 'Left' in this context means the first position of that byte string; for a language like Arabic or Hebrew which are 'right to left' rather than 'left to right', this will be the <em>right</em> side, not the left.</p> <h4 id="examples-33" class="section-header">Examples</h4> <p>Basic usage:</p> <pre class="rust rust-example-rendered" data-language="rust">
assert_eq!("11foo1bar11".trim_left_matches('1'), "foo1bar11");
assert_eq!("123foo1bar123".trim_left_matches(char::is_numeric), "foo1bar123");

let x: &amp;[_] = &amp;['1', '2'];
assert_eq!("12foo1bar12".trim_left_matches(x), "foo1bar12");</pre> </div>
<h4 id="method.trim_right_matches" class="method"><span id="trim_right_matches.v" class="invisible"><code>fn <a href="#method.trim_right_matches" class="fnname">trim_right_matches</a>&lt;'a, P&gt;(&amp;'a self, pat: P) -&gt; &amp;'a <a class="primitive" href="../primitive.str/">str</a> <span class="where fmt-newline">where P: <a class="trait" href="../str/pattern/trait.pattern/" title="std::str::pattern::Pattern">Pattern</a>&lt;'a&gt;, P::<a class="trait" href="../str/pattern/trait.pattern/" title="std::str::pattern::Pattern">Searcher</a>: <a class="trait" href="../str/pattern/trait.reversesearcher/" title="std::str::pattern::ReverseSearcher">ReverseSearcher</a>&lt;'a&gt;</span></code></span></h4> <div class="docblock">
<p>Returns a string slice with all suffixes that match a pattern repeatedly removed.</p> <p>The pattern can be a <code>&amp;str</code>, <a href="../primitive.char/"><code>char</code></a>, or a closure that determines if a character matches.</p> <h4 id="text-directionality-3" class="section-header">Text directionality</h4> <p>A string is a sequence of bytes. 'Right' in this context means the last position of that byte string; for a language like Arabic or Hebrew which are 'right to left' rather than 'left to right', this will be the <em>left</em> side, not the right.</p> <h4 id="examples-34" class="section-header">Examples</h4> <p>Simple patterns:</p> <pre class="rust rust-example-rendered" data-language="rust">
assert_eq!("11foo1bar11".trim_right_matches('1'), "11foo1bar");
assert_eq!("123foo1bar123".trim_right_matches(char::is_numeric), "123foo1bar");

let x: &amp;[_] = &amp;['1', '2'];
assert_eq!("12foo1bar12".trim_right_matches(x), "12foo1bar");</pre> <p>A more complex pattern, using a closure:</p> <pre class="rust rust-example-rendered" data-language="rust">
assert_eq!("1fooX".trim_left_matches(|c| c == '1' || c == 'X'), "fooX");</pre> </div>
<h4 id="method.parse" class="method"><span id="parse.v" class="invisible"><code>fn <a href="#method.parse" class="fnname">parse</a>&lt;F&gt;(&amp;self) -&gt; <a class="enum" href="../result/enum.result/" title="std::result::Result">Result</a>&lt;F, F::<a class="trait" href="../str/trait.fromstr/" title="std::str::FromStr">Err</a>&gt; <span class="where fmt-newline">where F: <a class="trait" href="../str/trait.fromstr/" title="std::str::FromStr">FromStr</a></span></code></span></h4> <div class="docblock">
<p>Parses this string slice into another type.</p> <p>Because <code>parse()</code> is so general, it can cause problems with type inference. As such, <code>parse()</code> is one of the few times you'll see the syntax affectionately known as the 'turbofish': <code>::&lt;&gt;</code>. This helps the inference algorithm understand specifically which type you're trying to parse into.</p> <p><code>parse()</code> can parse any type that implements the <a href="../str/trait.fromstr/"><code>FromStr</code></a> trait.</p> <h4 id="errors" class="section-header">Errors</h4> <p>Will return <a href="../str/trait.fromstr/#associatedtype.Err"><code>Err</code></a> if it's not possible to parse this string slice into the desired type.</p> <h4 id="example" class="section-header">Example</h4> <p>Basic usage</p> <pre class="rust rust-example-rendered" data-language="rust">
let four: u32 = "4".parse().unwrap();

assert_eq!(4, four);</pre> <p>Using the 'turbofish' instead of annotating <code>four</code>:</p> <pre class="rust rust-example-rendered" data-language="rust">
let four = "4".parse::&lt;u32&gt;();

assert_eq!(Ok(4), four);</pre> <p>Failing to parse:</p> <pre class="rust rust-example-rendered" data-language="rust">
let nope = "j".parse::&lt;u32&gt;();

assert!(nope.is_err());</pre> </div>
<h4 id="method.replace" class="method"><span id="replace.v" class="invisible"><code>fn <a href="#method.replace" class="fnname">replace</a>&lt;'a, P&gt;(&amp;'a self, from: P, to: &amp;<a class="primitive" href="../primitive.str/">str</a>) -&gt; <a class="struct" href="../string/struct.string/" title="std::string::String">String</a> <span class="where fmt-newline">where P: <a class="trait" href="../str/pattern/trait.pattern/" title="std::str::pattern::Pattern">Pattern</a>&lt;'a&gt;</span></code></span></h4> <div class="docblock">
<p>Replaces all matches of a pattern with another string.</p> <p><code>replace</code> creates a new <a href="../string/struct.string/"><code>String</code></a>, and copies the data from this string slice into it. While doing so, it attempts to find matches of a pattern. If it finds any, it replaces them with the replacement string slice.</p> <h4 id="examples-35" class="section-header">Examples</h4> <p>Basic usage:</p> <pre class="rust rust-example-rendered" data-language="rust">
let s = "this is old";

assert_eq!("this is new", s.replace("old", "new"));</pre> <p>When the pattern doesn't match:</p> <pre class="rust rust-example-rendered" data-language="rust">
let s = "this is old";
assert_eq!(s, s.replace("cookie monster", "little lamb"));</pre> </div>
<h4 id="method.replacen" class="method"><span id="replacen.v" class="invisible"><code>fn <a href="#method.replacen" class="fnname">replacen</a>&lt;'a, P&gt;(&amp;'a self, pat: P, to: &amp;<a class="primitive" href="../primitive.str/">str</a>, count: <a class="primitive" href="../primitive.usize/">usize</a>) -&gt; <a class="struct" href="../string/struct.string/" title="std::string::String">String</a> <span class="where fmt-newline">where P: <a class="trait" href="../str/pattern/trait.pattern/" title="std::str::pattern::Pattern">Pattern</a>&lt;'a&gt;</span></code><div class="since" title="Stable since Rust version 1.16.0">1.16.0</div></span></h4> <div class="docblock">
<p>Replaces first N matches of a pattern with another string.</p> <p><code>replacen</code> creates a new <a href="../string/struct.string/"><code>String</code></a>, and copies the data from this string slice into it. While doing so, it attempts to find matches of a pattern. If it finds any, it replaces them with the replacement string slice at most <code>N</code> times.</p> <h4 id="examples-36" class="section-header">Examples</h4> <p>Basic usage:</p> <pre class="rust rust-example-rendered" data-language="rust">
let s = "foo foo 123 foo";
assert_eq!("new new 123 foo", s.replacen("foo", "new", 2));
assert_eq!("faa fao 123 foo", s.replacen('o', "a", 3));
assert_eq!("foo foo new23 foo", s.replacen(char::is_numeric, "new", 1));</pre> <p>When the pattern doesn't match:</p> <pre class="rust rust-example-rendered" data-language="rust">
let s = "this is old";
assert_eq!(s, s.replacen("cookie monster", "little lamb", 10));</pre> </div>
<h4 id="method.to_lowercase" class="method"><span id="to_lowercase.v" class="invisible"><code>fn <a href="#method.to_lowercase" class="fnname">to_lowercase</a>(&amp;self) -&gt; <a class="struct" href="../string/struct.string/" title="std::string::String">String</a></code><div class="since" title="Stable since Rust version 1.2.0">1.2.0</div></span></h4> <div class="docblock">
<p>Returns the lowercase equivalent of this string slice, as a new <a href="../string/struct.string/"><code>String</code></a>.</p> <p>'Lowercase' is defined according to the terms of the Unicode Derived Core Property <code>Lowercase</code>.</p> <h4 id="examples-37" class="section-header">Examples</h4> <p>Basic usage:</p> <pre class="rust rust-example-rendered" data-language="rust">
let s = "HELLO";

assert_eq!("hello", s.to_lowercase());</pre> <p>A tricky example, with sigma:</p> <pre class="rust rust-example-rendered" data-language="rust">
let sigma = "Σ";

assert_eq!("σ", sigma.to_lowercase());

// but at the end of a word, it's ς, not σ:
let odysseus = "ὈΔΥΣΣΕΎΣ";

assert_eq!("ὀδυσσεύς", odysseus.to_lowercase());</pre> <p>Languages without case are not changed:</p> <pre class="rust rust-example-rendered" data-language="rust">
let new_year = "农历新年";

assert_eq!(new_year, new_year.to_lowercase());</pre> </div>
<h4 id="method.to_uppercase" class="method"><span id="to_uppercase.v" class="invisible"><code>fn <a href="#method.to_uppercase" class="fnname">to_uppercase</a>(&amp;self) -&gt; <a class="struct" href="../string/struct.string/" title="std::string::String">String</a></code><div class="since" title="Stable since Rust version 1.2.0">1.2.0</div></span></h4> <div class="docblock">
<p>Returns the uppercase equivalent of this string slice, as a new <a href="../string/struct.string/"><code>String</code></a>.</p> <p>'Uppercase' is defined according to the terms of the Unicode Derived Core Property <code>Uppercase</code>.</p> <h4 id="examples-38" class="section-header">Examples</h4> <p>Basic usage:</p> <pre class="rust rust-example-rendered" data-language="rust">
let s = "hello";

assert_eq!("HELLO", s.to_uppercase());</pre> <p>Scripts without case are not changed:</p> <pre class="rust rust-example-rendered" data-language="rust">
let new_year = "农历新年";

assert_eq!(new_year, new_year.to_uppercase());</pre> </div>
<h4 id="method.escape_debug" class="method"><span id="escape_debug.v" class="invisible"><code>fn <a href="#method.escape_debug" class="fnname">escape_debug</a>(&amp;self) -&gt; <a class="struct" href="../string/struct.string/" title="std::string::String">String</a></code></span></h4> <div class="stability"><span class="stab unstable">🔬 This is a nightly-only experimental API. (str_escape #27791)return type may change to be an iterator </span></div>
<div class="docblock">
<p>Escapes each char in <code>s</code> with <code>char::escape_debug</code>.</p> </div>
<h4 id="method.escape_default" class="method"><span id="escape_default.v" class="invisible"><code>fn <a href="#method.escape_default" class="fnname">escape_default</a>(&amp;self) -&gt; <a class="struct" href="../string/struct.string/" title="std::string::String">String</a></code></span></h4> <div class="stability"><span class="stab unstable">🔬 This is a nightly-only experimental API. (str_escape #27791)return type may change to be an iterator </span></div>
<div class="docblock">
<p>Escapes each char in <code>s</code> with <code>char::escape_default</code>.</p> </div>
<h4 id="method.escape_unicode" class="method"><span id="escape_unicode.v" class="invisible"><code>fn <a href="#method.escape_unicode" class="fnname">escape_unicode</a>(&amp;self) -&gt; <a class="struct" href="../string/struct.string/" title="std::string::String">String</a></code></span></h4> <div class="stability"><span class="stab unstable">🔬 This is a nightly-only experimental API. (str_escape #27791)return type may change to be an iterator </span></div>
<div class="docblock">
<p>Escapes each char in <code>s</code> with <code>char::escape_unicode</code>.</p> </div>
<h4 id="method.into_string" class="method"><span id="into_string.v" class="invisible"><code>fn <a href="#method.into_string" class="fnname">into_string</a>(self: <a class="struct" href="../boxed/struct.box/" title="std::boxed::Box">Box</a>&lt;<a class="primitive" href="../primitive.str/">str</a>&gt;) -&gt; <a class="struct" href="../string/struct.string/" title="std::string::String">String</a></code><div class="since" title="Stable since Rust version 1.4.0">1.4.0</div></span></h4> <div class="docblock">
<p>Converts a <code>Box&lt;str&gt;</code> into a <a href="../string/struct.string/"><code>String</code></a> without copying or allocating.</p> <h4 id="examples-39" class="section-header">Examples</h4> <p>Basic usage:</p> <pre class="rust rust-example-rendered" data-language="rust">
let string = String::from("birthday gift");
let boxed_str = string.clone().into_boxed_str();

assert_eq!(boxed_str.into_string(), string);</pre> </div>
<h4 id="method.repeat" class="method"><span id="repeat.v" class="invisible"><code>fn <a href="#method.repeat" class="fnname">repeat</a>(&amp;self, n: <a class="primitive" href="../primitive.usize/">usize</a>) -&gt; <a class="struct" href="../string/struct.string/" title="std::string::String">String</a></code><div class="since" title="Stable since Rust version 1.16.0">1.16.0</div></span></h4> <div class="docblock">
<p>Create a <a href="../string/struct.string/"><code>String</code></a> by repeating a string <code>n</code> times.</p> <h4 id="examples-40" class="section-header">Examples</h4> <p>Basic usage:</p> <pre class="rust rust-example-rendered" data-language="rust">
assert_eq!("abc".repeat(4), String::from("abcabcabcabc"));</pre> </div>
<h2 id="implementations">Trait Implementations</h2>
<h3 class="impl">
<span class="in-band"><code>impl <a class="trait" href="../string/trait.tostring/" title="std::string::ToString">ToString</a> for <a class="primitive" href="../primitive.str/">str</a></code></span><span class="out-of-band">
<div class="since" title="Stable since Rust version 1.9.0">1.9.0</div>
<a class="srclink" href="https://doc.rust-lang.org/src/collections/string.rs.html#1862-1867" title="goto source code" target="_blank">[src]</a></span>
</h3> <h4 id="method.to_string" class="method"><span id="to_string.v" class="invisible"><code>fn <a href="../string/trait.tostring/#tymethod.to_string" class="fnname">to_string</a>(&amp;self) -&gt; <a class="struct" href="../string/struct.string/" title="std::string::String">String</a></code></span></h4> <div class="docblock">
<p>Converts the given value to a <code>String</code>. <a href="../string/trait.tostring/#tymethod.to_string">Read more</a></p> </div>
<h3 class="impl">
<span class="in-band"><code>impl <a class="trait" href="../borrow/trait.toowned/" title="std::borrow::ToOwned">ToOwned</a> for <a class="primitive" href="../primitive.str/">str</a></code></span><span class="out-of-band">
<a class="srclink" href="https://doc.rust-lang.org/src/collections/str.rs.html#164-169" title="goto source code" target="_blank">[src]</a></span>
</h3> <h4 id="associatedtype.Owned" class="type"><span id="Owned.t" class="invisible"><code>type <a href="../borrow/trait.toowned/#associatedtype.Owned" class="type">Owned</a> = <a class="struct" href="../string/struct.string/" title="std::string::String">String</a></code></span></h4> <h4 id="method.to_owned" class="method"><span id="to_owned.v" class="invisible"><code>fn <a href="../borrow/trait.toowned/#tymethod.to_owned" class="fnname">to_owned</a>(&amp;self) -&gt; <a class="struct" href="../string/struct.string/" title="std::string::String">String</a></code></span></h4> <div class="docblock">
<p>Creates owned data from borrowed data, usually by cloning. <a href="../borrow/trait.toowned/#tymethod.to_owned">Read more</a></p> </div>
<h3 class="impl">
<span class="in-band"><code>impl&lt;'a, 'b&gt; <a class="trait" href="../cmp/trait.partialeq/" title="std::cmp::PartialEq">PartialEq</a>&lt;<a class="struct" href="../string/struct.string/" title="std::string::String">String</a>&gt; for <a class="primitive" href="../primitive.str/">str</a></code></span><span class="out-of-band">
<a class="srclink" href="https://doc.rust-lang.org/src/collections/string.rs.html#1583-1588" title="goto source code" target="_blank">[src]</a></span>
</h3> <h4 id="method.eq" class="method"><span id="eq.v" class="invisible"><code>fn <a href="../cmp/trait.partialeq/#tymethod.eq" class="fnname">eq</a>(&amp;self, other: &amp;<a class="struct" href="../string/struct.string/" title="std::string::String">String</a>) -&gt; <a class="primitive" href="../primitive.bool/">bool</a></code></span></h4> <div class="docblock">
<p>This method tests for <code>self</code> and <code>other</code> values to be equal, and is used by <code>==</code>. <a href="../cmp/trait.partialeq/#tymethod.eq">Read more</a></p> </div>
<h4 id="method.ne" class="method"><span id="ne.v" class="invisible"><code>fn <a href="../cmp/trait.partialeq/#method.ne" class="fnname">ne</a>(&amp;self, other: &amp;<a class="struct" href="../string/struct.string/" title="std::string::String">String</a>) -&gt; <a class="primitive" href="../primitive.bool/">bool</a></code></span></h4> <div class="docblock">
<p>This method tests for <code>!=</code>.</p> </div>
<h3 class="impl">
<span class="in-band"><code>impl&lt;'a, 'b&gt; <a class="trait" href="../cmp/trait.partialeq/" title="std::cmp::PartialEq">PartialEq</a>&lt;<a class="struct" href="../string/struct.string/" title="std::string::String">String</a>&gt; for &amp;'a <a class="primitive" href="../primitive.str/">str</a></code></span><span class="out-of-band">
<a class="srclink" href="https://doc.rust-lang.org/src/collections/string.rs.html#1583-1588" title="goto source code" target="_blank">[src]</a></span>
</h3> <h4 id="method.eq-1" class="method"><span id="eq.v-1" class="invisible"><code>fn <a href="../cmp/trait.partialeq/#tymethod.eq" class="fnname">eq</a>(&amp;self, other: &amp;<a class="struct" href="../string/struct.string/" title="std::string::String">String</a>) -&gt; <a class="primitive" href="../primitive.bool/">bool</a></code></span></h4> <div class="docblock">
<p>This method tests for <code>self</code> and <code>other</code> values to be equal, and is used by <code>==</code>. <a href="../cmp/trait.partialeq/#tymethod.eq">Read more</a></p> </div>
<h4 id="method.ne-1" class="method"><span id="ne.v-1" class="invisible"><code>fn <a href="../cmp/trait.partialeq/#method.ne" class="fnname">ne</a>(&amp;self, other: &amp;<a class="struct" href="../string/struct.string/" title="std::string::String">String</a>) -&gt; <a class="primitive" href="../primitive.bool/">bool</a></code></span></h4> <div class="docblock">
<p>This method tests for <code>!=</code>.</p> </div>
<h3 class="impl">
<span class="in-band"><code>impl&lt;'a, 'b&gt; <a class="trait" href="../cmp/trait.partialeq/" title="std::cmp::PartialEq">PartialEq</a>&lt;<a class="enum" href="../borrow/enum.cow/" title="std::borrow::Cow">Cow</a>&lt;'a, <a class="primitive" href="../primitive.str/">str</a>&gt;&gt; for <a class="primitive" href="../primitive.str/">str</a></code></span><span class="out-of-band">
<a class="srclink" href="https://doc.rust-lang.org/src/collections/string.rs.html#1583-1588" title="goto source code" target="_blank">[src]</a></span>
</h3> <h4 id="method.eq-2" class="method"><span id="eq.v-2" class="invisible"><code>fn <a href="../cmp/trait.partialeq/#tymethod.eq" class="fnname">eq</a>(&amp;self, other: &amp;<a class="enum" href="../borrow/enum.cow/" title="std::borrow::Cow">Cow</a>&lt;'a, <a class="primitive" href="../primitive.str/">str</a>&gt;) -&gt; <a class="primitive" href="../primitive.bool/">bool</a></code></span></h4> <div class="docblock">
<p>This method tests for <code>self</code> and <code>other</code> values to be equal, and is used by <code>==</code>. <a href="../cmp/trait.partialeq/#tymethod.eq">Read more</a></p> </div>
<h4 id="method.ne-2" class="method"><span id="ne.v-2" class="invisible"><code>fn <a href="../cmp/trait.partialeq/#method.ne" class="fnname">ne</a>(&amp;self, other: &amp;<a class="enum" href="../borrow/enum.cow/" title="std::borrow::Cow">Cow</a>&lt;'a, <a class="primitive" href="../primitive.str/">str</a>&gt;) -&gt; <a class="primitive" href="../primitive.bool/">bool</a></code></span></h4> <div class="docblock">
<p>This method tests for <code>!=</code>.</p> </div>
<h3 class="impl">
<span class="in-band"><code>impl&lt;'a, 'b&gt; <a class="trait" href="../cmp/trait.partialeq/" title="std::cmp::PartialEq">PartialEq</a>&lt;<a class="enum" href="../borrow/enum.cow/" title="std::borrow::Cow">Cow</a>&lt;'a, <a class="primitive" href="../primitive.str/">str</a>&gt;&gt; for &amp;'b <a class="primitive" href="../primitive.str/">str</a></code></span><span class="out-of-band">
<a class="srclink" href="https://doc.rust-lang.org/src/collections/string.rs.html#1583-1588" title="goto source code" target="_blank">[src]</a></span>
</h3> <h4 id="method.eq-3" class="method"><span id="eq.v-3" class="invisible"><code>fn <a href="../cmp/trait.partialeq/#tymethod.eq" class="fnname">eq</a>(&amp;self, other: &amp;<a class="enum" href="../borrow/enum.cow/" title="std::borrow::Cow">Cow</a>&lt;'a, <a class="primitive" href="../primitive.str/">str</a>&gt;) -&gt; <a class="primitive" href="../primitive.bool/">bool</a></code></span></h4> <div class="docblock">
<p>This method tests for <code>self</code> and <code>other</code> values to be equal, and is used by <code>==</code>. <a href="../cmp/trait.partialeq/#tymethod.eq">Read more</a></p> </div>
<h4 id="method.ne-3" class="method"><span id="ne.v-3" class="invisible"><code>fn <a href="../cmp/trait.partialeq/#method.ne" class="fnname">ne</a>(&amp;self, other: &amp;<a class="enum" href="../borrow/enum.cow/" title="std::borrow::Cow">Cow</a>&lt;'a, <a class="primitive" href="../primitive.str/">str</a>&gt;) -&gt; <a class="primitive" href="../primitive.bool/">bool</a></code></span></h4> <div class="docblock">
<p>This method tests for <code>!=</code>.</p> </div>
<h3 class="impl">
<span class="in-band"><code>impl <a class="trait" href="../ops/trait.index/" title="std::ops::Index">Index</a>&lt;<a class="struct" href="../ops/struct.range/" title="std::ops::Range">Range</a>&lt;<a class="primitive" href="../primitive.usize/">usize</a>&gt;&gt; for <a class="primitive" href="../primitive.str/">str</a></code></span><span class="out-of-band">
<a class="srclink" href="https://doc.rust-lang.org/src/core/str/mod.rs.html#1431-1444" title="goto source code" target="_blank">[src]</a></span>
</h3> <p>Implements substring slicing with syntax <code>&amp;self[begin .. end]</code>.</p> <p>Returns a slice of the given string from the byte range [<code>begin</code>..<code>end</code>).</p> <p>This operation is <code>O(1)</code>.</p> <h4 id="panics-2" class="section-header">Panics</h4> <p>Panics if <code>begin</code> or <code>end</code> does not point to the starting byte offset of a character (as defined by <code>is_char_boundary</code>). Requires that <code>begin &lt;= end</code> and <code>end &lt;= len</code> where <code>len</code> is the length of the string.</p> <h4 id="examples-41" class="section-header">Examples</h4> <pre class="rust rust-example-rendered" data-language="rust">
let s = "Löwe 老虎 Léopard";
assert_eq!(&amp;s[0 .. 1], "L");

assert_eq!(&amp;s[1 .. 9], "öwe 老");

// these will panic:
// byte 2 lies within `ö`:
// &amp;s[2 ..3];

// byte 8 lies within `老`
// &amp;s[1 .. 8];

// byte 100 is outside the string
// &amp;s[3 .. 100];</pre> <h4 id="associatedtype.Output" class="type"><span id="Output.t" class="invisible"><code>type <a href="../ops/trait.index/#associatedtype.Output" class="type">Output</a> = <a class="primitive" href="../primitive.str/">str</a></code></span></h4> <div class="docblock">
<p>The returned type after indexing</p> </div>
<h4 id="method.index" class="method"><span id="index.v" class="invisible"><code>fn <a href="../ops/trait.index/#tymethod.index" class="fnname">index</a>(&amp;self, index: <a class="struct" href="../ops/struct.range/" title="std::ops::Range">Range</a>&lt;<a class="primitive" href="../primitive.usize/">usize</a>&gt;) -&gt; &amp;<a class="primitive" href="../primitive.str/">str</a></code></span></h4> <div class="docblock">
<p>The method for the indexing (<code>container[index]</code>) operation</p> </div>
<h3 class="impl">
<span class="in-band"><code>impl <a class="trait" href="../ops/trait.index/" title="std::ops::Index">Index</a>&lt;<a class="struct" href="../ops/struct.rangeto/" title="std::ops::RangeTo">RangeTo</a>&lt;<a class="primitive" href="../primitive.usize/">usize</a>&gt;&gt; for <a class="primitive" href="../primitive.str/">str</a></code></span><span class="out-of-band">
<a class="srclink" href="https://doc.rust-lang.org/src/core/str/mod.rs.html#1482-1494" title="goto source code" target="_blank">[src]</a></span>
</h3> <p>Implements substring slicing with syntax <code>&amp;self[.. end]</code>.</p> <p>Returns a slice of the string from the beginning to byte offset <code>end</code>.</p> <p>Equivalent to <code>&amp;self[0 .. end]</code>.</p> <h4 id="associatedtype.Output-1" class="type"><span id="Output.t-1" class="invisible"><code>type <a href="../ops/trait.index/#associatedtype.Output" class="type">Output</a> = <a class="primitive" href="../primitive.str/">str</a></code></span></h4> <div class="docblock">
<p>The returned type after indexing</p> </div>
<h4 id="method.index-1" class="method"><span id="index.v-1" class="invisible"><code>fn <a href="../ops/trait.index/#tymethod.index" class="fnname">index</a>(&amp;self, index: <a class="struct" href="../ops/struct.rangeto/" title="std::ops::RangeTo">RangeTo</a>&lt;<a class="primitive" href="../primitive.usize/">usize</a>&gt;) -&gt; &amp;<a class="primitive" href="../primitive.str/">str</a></code></span></h4> <div class="docblock">
<p>The method for the indexing (<code>container[index]</code>) operation</p> </div>
<h3 class="impl">
<span class="in-band"><code>impl <a class="trait" href="../ops/trait.index/" title="std::ops::Index">Index</a>&lt;<a class="struct" href="../ops/struct.rangefrom/" title="std::ops::RangeFrom">RangeFrom</a>&lt;<a class="primitive" href="../primitive.usize/">usize</a>&gt;&gt; for <a class="primitive" href="../primitive.str/">str</a></code></span><span class="out-of-band">
<a class="srclink" href="https://doc.rust-lang.org/src/core/str/mod.rs.html#1522-1534" title="goto source code" target="_blank">[src]</a></span>
</h3> <p>Implements substring slicing with syntax <code>&amp;self[begin ..]</code>.</p> <p>Returns a slice of the string from byte offset <code>begin</code> to the end of the string.</p> <p>Equivalent to <code>&amp;self[begin .. len]</code>.</p> <h4 id="associatedtype.Output-2" class="type"><span id="Output.t-2" class="invisible"><code>type <a href="../ops/trait.index/#associatedtype.Output" class="type">Output</a> = <a class="primitive" href="../primitive.str/">str</a></code></span></h4> <div class="docblock">
<p>The returned type after indexing</p> </div>
<h4 id="method.index-2" class="method"><span id="index.v-2" class="invisible"><code>fn <a href="../ops/trait.index/#tymethod.index" class="fnname">index</a>(&amp;self, index: <a class="struct" href="../ops/struct.rangefrom/" title="std::ops::RangeFrom">RangeFrom</a>&lt;<a class="primitive" href="../primitive.usize/">usize</a>&gt;) -&gt; &amp;<a class="primitive" href="../primitive.str/">str</a></code></span></h4> <div class="docblock">
<p>The method for the indexing (<code>container[index]</code>) operation</p> </div>
<h3 class="impl">
<span class="in-band"><code>impl <a class="trait" href="../ops/trait.index/" title="std::ops::Index">Index</a>&lt;<a class="struct" href="../ops/struct.rangefull/" title="std::ops::RangeFull">RangeFull</a>&gt; for <a class="primitive" href="../primitive.str/">str</a></code></span><span class="out-of-band">
<a class="srclink" href="https://doc.rust-lang.org/src/core/str/mod.rs.html#1563-1570" title="goto source code" target="_blank">[src]</a></span>
</h3> <p>Implements substring slicing with syntax <code>&amp;self[..]</code>.</p> <p>Returns a slice of the whole string. This operation can never panic.</p> <p>Equivalent to <code>&amp;self[0 .. len]</code>.</p> <h4 id="associatedtype.Output-3" class="type"><span id="Output.t-3" class="invisible"><code>type <a href="../ops/trait.index/#associatedtype.Output" class="type">Output</a> = <a class="primitive" href="../primitive.str/">str</a></code></span></h4> <div class="docblock">
<p>The returned type after indexing</p> </div>
<h4 id="method.index-3" class="method"><span id="index.v-3" class="invisible"><code>fn <a href="../ops/trait.index/#tymethod.index" class="fnname">index</a>(&amp;self, _index: <a class="struct" href="../ops/struct.rangefull/" title="std::ops::RangeFull">RangeFull</a>) -&gt; &amp;<a class="primitive" href="../primitive.str/">str</a></code></span></h4> <div class="docblock">
<p>The method for the indexing (<code>container[index]</code>) operation</p> </div>
<h3 class="impl">
<span class="in-band"><code>impl <a class="trait" href="../ops/trait.index/" title="std::ops::Index">Index</a>&lt;<a class="enum" href="../ops/enum.rangeinclusive/" title="std::ops::RangeInclusive">RangeInclusive</a>&lt;<a class="primitive" href="../primitive.usize/">usize</a>&gt;&gt; for <a class="primitive" href="../primitive.str/">str</a></code></span><span class="out-of-band">
<a class="srclink" href="https://doc.rust-lang.org/src/core/str/mod.rs.html#1589-1602" title="goto source code" target="_blank">[src]</a></span>
</h3> <h4 id="associatedtype.Output-4" class="type"><span id="Output.t-4" class="invisible"><code>type <a href="../ops/trait.index/#associatedtype.Output" class="type">Output</a> = <a class="primitive" href="../primitive.str/">str</a></code></span></h4> <div class="docblock">
<p>The returned type after indexing</p> </div>
<h4 id="method.index-4" class="method"><span id="index.v-4" class="invisible"><code>fn <a href="../ops/trait.index/#tymethod.index" class="fnname">index</a>(&amp;self, index: <a class="enum" href="../ops/enum.rangeinclusive/" title="std::ops::RangeInclusive">RangeInclusive</a>&lt;<a class="primitive" href="../primitive.usize/">usize</a>&gt;) -&gt; &amp;<a class="primitive" href="../primitive.str/">str</a></code></span></h4> <div class="docblock">
<p>The method for the indexing (<code>container[index]</code>) operation</p> </div>
<h3 class="impl">
<span class="in-band"><code>impl <a class="trait" href="../ops/trait.index/" title="std::ops::Index">Index</a>&lt;<a class="struct" href="../ops/struct.rangetoinclusive/" title="std::ops::RangeToInclusive">RangeToInclusive</a>&lt;<a class="primitive" href="../primitive.usize/">usize</a>&gt;&gt; for <a class="primitive" href="../primitive.str/">str</a></code></span><span class="out-of-band">
<a class="srclink" href="https://doc.rust-lang.org/src/core/str/mod.rs.html#1606-1613" title="goto source code" target="_blank">[src]</a></span>
</h3> <h4 id="associatedtype.Output-5" class="type"><span id="Output.t-5" class="invisible"><code>type <a href="../ops/trait.index/#associatedtype.Output" class="type">Output</a> = <a class="primitive" href="../primitive.str/">str</a></code></span></h4> <div class="docblock">
<p>The returned type after indexing</p> </div>
<h4 id="method.index-5" class="method"><span id="index.v-5" class="invisible"><code>fn <a href="../ops/trait.index/#tymethod.index" class="fnname">index</a>(&amp;self, index: <a class="struct" href="../ops/struct.rangetoinclusive/" title="std::ops::RangeToInclusive">RangeToInclusive</a>&lt;<a class="primitive" href="../primitive.usize/">usize</a>&gt;) -&gt; &amp;<a class="primitive" href="../primitive.str/">str</a></code></span></h4> <div class="docblock">
<p>The method for the indexing (<code>container[index]</code>) operation</p> </div>
<h3 class="impl">
<span class="in-band"><code>impl <a class="trait" href="../cmp/trait.partialeq/" title="std::cmp::PartialEq">PartialEq</a>&lt;<a class="primitive" href="../primitive.str/">str</a>&gt; for <a class="primitive" href="../primitive.str/">str</a></code></span><span class="out-of-band">
<a class="srclink" href="https://doc.rust-lang.org/src/core/str/mod.rs.html#1378-1385" title="goto source code" target="_blank">[src]</a></span>
</h3> <h4 id="method.eq-4" class="method"><span id="eq.v-4" class="invisible"><code>fn <a href="../cmp/trait.partialeq/#tymethod.eq" class="fnname">eq</a>(&amp;self, other: &amp;<a class="primitive" href="../primitive.str/">str</a>) -&gt; <a class="primitive" href="../primitive.bool/">bool</a></code></span></h4> <div class="docblock">
<p>This method tests for <code>self</code> and <code>other</code> values to be equal, and is used by <code>==</code>. <a href="../cmp/trait.partialeq/#tymethod.eq">Read more</a></p> </div>
<h4 id="method.ne-4" class="method"><span id="ne.v-4" class="invisible"><code>fn <a href="../cmp/trait.partialeq/#method.ne" class="fnname">ne</a>(&amp;self, other: &amp;<a class="primitive" href="../primitive.str/">str</a>) -&gt; <a class="primitive" href="../primitive.bool/">bool</a></code></span></h4> <div class="docblock">
<p>This method tests for <code>!=</code>.</p> </div>
<h3 class="impl">
<span class="in-band"><code>impl&lt;'a&gt; <a class="trait" href="../default/trait.default/" title="std::default::Default">Default</a> for &amp;'a <a class="primitive" href="../primitive.str/">str</a></code></span><span class="out-of-band">
<a class="srclink" href="https://doc.rust-lang.org/src/core/str/mod.rs.html#2039-2042" title="goto source code" target="_blank">[src]</a></span>
</h3> <h4 id="method.default" class="method"><span id="default.v" class="invisible"><code>fn <a href="../default/trait.default/#tymethod.default" class="fnname">default</a>() -&gt; &amp;'a <a class="primitive" href="../primitive.str/">str</a></code></span></h4> <div class="docblock">
<p>Creates an empty str</p> </div>
<h3 class="impl">
<span class="in-band"><code>impl <a class="trait" href="../fmt/trait.display/" title="std::fmt::Display">Display</a> for <a class="primitive" href="../primitive.str/">str</a></code></span><span class="out-of-band">
<a class="srclink" href="https://doc.rust-lang.org/src/core/fmt/mod.rs.html#1411-1415" title="goto source code" target="_blank">[src]</a></span>
</h3> <h4 id="method.fmt" class="method"><span id="fmt.v" class="invisible"><code>fn <a href="../fmt/trait.display/#tymethod.fmt" class="fnname">fmt</a>(&amp;self, f: &amp;mut <a class="struct" href="../fmt/struct.formatter/" title="std::fmt::Formatter">Formatter</a>) -&gt; <a class="enum" href="../result/enum.result/" title="std::result::Result">Result</a>&lt;<a class="primitive" href="../primitive.tuple/">()</a>, <a class="struct" href="../fmt/struct.error/" title="std::fmt::Error">Error</a>&gt;</code></span></h4> <div class="docblock">
<p>Formats the value using the given formatter.</p> </div>
<h3 class="impl">
<span class="in-band"><code>impl <a class="trait" href="../cmp/trait.eq/" title="std::cmp::Eq">Eq</a> for <a class="primitive" href="../primitive.str/">str</a></code></span><span class="out-of-band">
<a class="srclink" href="https://doc.rust-lang.org/src/core/str/mod.rs.html#1388" title="goto source code" target="_blank">[src]</a></span>
</h3> <h3 class="impl">
<span class="in-band"><code>impl&lt;'a, 'b&gt; <a class="trait" href="../str/pattern/trait.pattern/" title="std::str::pattern::Pattern">Pattern</a>&lt;'a&gt; for &amp;'b <a class="primitive" href="../primitive.str/">str</a></code></span><span class="out-of-band">
<a class="srclink" href="https://doc.rust-lang.org/src/core/str/pattern.rs.html#517-539" title="goto source code" target="_blank">[src]</a></span>
</h3> <p>Non-allocating substring search.</p> <p>Will handle the pattern <code>""</code> as returning empty matches at each character boundary.</p> <h4 id="associatedtype.Searcher" class="type"><span id="Searcher.t" class="invisible"><code>type <a href="../str/pattern/trait.pattern/#associatedtype.Searcher" class="type">Searcher</a> = <a class="struct" href="../str/pattern/struct.strsearcher/" title="std::str::pattern::StrSearcher">StrSearcher</a>&lt;'a, 'b&gt;</code></span></h4> <div class="stability"><span class="stab unstable">🔬 This is a nightly-only experimental API. (pattern #27721)API not fully fleshed out and ready to be stabilized </span></div>
<div class="docblock">
<p>Associated searcher for this pattern</p> </div>
<h4 id="method.into_searcher" class="method"><span id="into_searcher.v" class="invisible"><code>fn <a href="../str/pattern/trait.pattern/#tymethod.into_searcher" class="fnname">into_searcher</a>(self, haystack: &amp;'a <a class="primitive" href="../primitive.str/">str</a>) -&gt; <a class="struct" href="../str/pattern/struct.strsearcher/" title="std::str::pattern::StrSearcher">StrSearcher</a>&lt;'a, 'b&gt;</code></span></h4> <div class="stability"><span class="stab unstable">🔬 This is a nightly-only experimental API. (pattern #27721)API not fully fleshed out and ready to be stabilized </span></div>
<div class="docblock">
<p>Constructs the associated searcher from <code>self</code> and the <code>haystack</code> to search in. <a href="../str/pattern/trait.pattern/#tymethod.into_searcher">Read more</a></p> </div>
<h4 id="method.is_prefix_of" class="method"><span id="is_prefix_of.v" class="invisible"><code>fn <a href="../str/pattern/trait.pattern/#method.is_prefix_of" class="fnname">is_prefix_of</a>(self, haystack: &amp;'a <a class="primitive" href="../primitive.str/">str</a>) -&gt; <a class="primitive" href="../primitive.bool/">bool</a></code></span></h4> <div class="stability"><span class="stab unstable">🔬 This is a nightly-only experimental API. (pattern #27721)API not fully fleshed out and ready to be stabilized </span></div>
<div class="docblock">
<p>Checks whether the pattern matches at the front of the haystack</p> </div>
<h4 id="method.is_suffix_of" class="method"><span id="is_suffix_of.v" class="invisible"><code>fn <a href="../str/pattern/trait.pattern/#method.is_suffix_of" class="fnname">is_suffix_of</a>(self, haystack: &amp;'a <a class="primitive" href="../primitive.str/">str</a>) -&gt; <a class="primitive" href="../primitive.bool/">bool</a></code></span></h4> <div class="stability"><span class="stab unstable">🔬 This is a nightly-only experimental API. (pattern #27721)API not fully fleshed out and ready to be stabilized </span></div>
<div class="docblock">
<p>Checks whether the pattern matches at the back of the haystack</p> </div>
<h4 id="method.is_contained_in" class="method"><span id="is_contained_in.v" class="invisible"><code>fn <a href="../str/pattern/trait.pattern/#method.is_contained_in" class="fnname">is_contained_in</a>(self, haystack: &amp;'a <a class="primitive" href="../primitive.str/">str</a>) -&gt; <a class="primitive" href="../primitive.bool/">bool</a></code></span></h4> <div class="stability"><span class="stab unstable">🔬 This is a nightly-only experimental API. (pattern #27721)API not fully fleshed out and ready to be stabilized </span></div>
<div class="docblock">
<p>Checks whether the pattern matches anywhere in the haystack</p> </div>
<h3 class="impl">
<span class="in-band"><code>impl <a class="trait" href="../convert/trait.asref/" title="std::convert::AsRef">AsRef</a>&lt;<a class="primitive" href="../primitive.str/">str</a>&gt; for <a class="primitive" href="../primitive.str/">str</a></code></span><span class="out-of-band">
<a class="srclink" href="https://doc.rust-lang.org/src/core/convert.rs.html#319-324" title="goto source code" target="_blank">[src]</a></span>
</h3> <h4 id="method.as_ref" class="method"><span id="as_ref.v" class="invisible"><code>fn <a href="../convert/trait.asref/#tymethod.as_ref" class="fnname">as_ref</a>(&amp;self) -&gt; &amp;<a class="primitive" href="../primitive.str/">str</a></code></span></h4> <div class="docblock">
<p>Performs the conversion.</p> </div>
<h3 class="impl">
<span class="in-band"><code>impl <a class="trait" href="../convert/trait.asref/" title="std::convert::AsRef">AsRef</a>&lt;<a class="primitive" href="../primitive.slice/">[</a><a class="primitive" href="../primitive.u8/">u8</a><a class="primitive" href="../primitive.slice/">]</a>&gt; for <a class="primitive" href="../primitive.str/">str</a></code></span><span class="out-of-band">
<a class="srclink" href="https://doc.rust-lang.org/src/core/str/mod.rs.html#2031-2036" title="goto source code" target="_blank">[src]</a></span>
</h3> <h4 id="method.as_ref-1" class="method"><span id="as_ref.v-1" class="invisible"><code>fn <a href="../convert/trait.asref/#tymethod.as_ref" class="fnname">as_ref</a>(&amp;self) -&gt; <a class="primitive" href="../primitive.slice/">&amp;[</a><a class="primitive" href="../primitive.u8/">u8</a><a class="primitive" href="../primitive.slice/">]</a></code></span></h4> <div class="docblock">
<p>Performs the conversion.</p> </div>
<h3 class="impl">
<span class="in-band"><code>impl <a class="trait" href="../fmt/trait.debug/" title="std::fmt::Debug">Debug</a> for <a class="primitive" href="../primitive.str/">str</a></code></span><span class="out-of-band">
<a class="srclink" href="https://doc.rust-lang.org/src/core/fmt/mod.rs.html#1390-1408" title="goto source code" target="_blank">[src]</a></span>
</h3> <h4 id="method.fmt-1" class="method"><span id="fmt.v-1" class="invisible"><code>fn <a href="../fmt/trait.debug/#tymethod.fmt" class="fnname">fmt</a>(&amp;self, f: &amp;mut <a class="struct" href="../fmt/struct.formatter/" title="std::fmt::Formatter">Formatter</a>) -&gt; <a class="enum" href="../result/enum.result/" title="std::result::Result">Result</a>&lt;<a class="primitive" href="../primitive.tuple/">()</a>, <a class="struct" href="../fmt/struct.error/" title="std::fmt::Error">Error</a>&gt;</code></span></h4> <div class="docblock">
<p>Formats the value using the given formatter.</p> </div>
<h3 class="impl">
<span class="in-band"><code>impl <a class="trait" href="../cmp/trait.ord/" title="std::cmp::Ord">Ord</a> for <a class="primitive" href="../primitive.str/">str</a></code></span><span class="out-of-band">
<a class="srclink" href="https://doc.rust-lang.org/src/core/str/mod.rs.html#1370-1375" title="goto source code" target="_blank">[src]</a></span>
</h3> <h4 id="method.cmp" class="method"><span id="cmp.v" class="invisible"><code>fn <a href="../cmp/trait.ord/#tymethod.cmp" class="fnname">cmp</a>(&amp;self, other: &amp;<a class="primitive" href="../primitive.str/">str</a>) -&gt; <a class="enum" href="../cmp/enum.ordering/" title="std::cmp::Ordering">Ordering</a></code></span></h4> <div class="docblock">
<p>This method returns an <code>Ordering</code> between <code>self</code> and <code>other</code>. <a href="../cmp/trait.ord/#tymethod.cmp">Read more</a></p> </div>
<h3 class="impl">
<span class="in-band"><code>impl <a class="trait" href="../hash/trait.hash/" title="std::hash::Hash">Hash</a> for <a class="primitive" href="../primitive.str/">str</a></code></span><span class="out-of-band">
<a class="srclink" href="https://doc.rust-lang.org/src/core/hash/mod.rs.html#401-406" title="goto source code" target="_blank">[src]</a></span>
</h3> <h4 id="method.hash" class="method"><span id="hash.v" class="invisible"><code>fn <a href="../hash/trait.hash/#tymethod.hash" class="fnname">hash</a>&lt;H&gt;(&amp;self, state: &amp;mut H) <span class="where fmt-newline">where H: <a class="trait" href="../hash/trait.hasher/" title="std::hash::Hasher">Hasher</a></span></code></span></h4> <div class="docblock">
<p>Feeds this value into the state given, updating the hasher as necessary.</p> </div>
<h4 id="method.hash_slice" class="method"><span id="hash_slice.v" class="invisible"><code>fn <a href="../hash/trait.hash/#method.hash_slice" class="fnname">hash_slice</a>&lt;H&gt;(data: <a class="primitive" href="../primitive.slice/">&amp;[Self]</a>, state: &amp;mut H) <span class="where fmt-newline">where H: <a class="trait" href="../hash/trait.hasher/" title="std::hash::Hasher">Hasher</a></span></code><div class="since" title="Stable since Rust version 1.3.0">1.3.0</div></span></h4> <div class="docblock">
<p>Feeds a slice of this type into the state provided.</p> </div>
<h3 class="impl">
<span class="in-band"><code>impl <a class="trait" href="../cmp/trait.partialord/" title="std::cmp::PartialOrd">PartialOrd</a>&lt;<a class="primitive" href="../primitive.str/">str</a>&gt; for <a class="primitive" href="../primitive.str/">str</a></code></span><span class="out-of-band">
<a class="srclink" href="https://doc.rust-lang.org/src/core/str/mod.rs.html#1391-1396" title="goto source code" target="_blank">[src]</a></span>
</h3> <h4 id="method.partial_cmp" class="method"><span id="partial_cmp.v" class="invisible"><code>fn <a href="../cmp/trait.partialord/#tymethod.partial_cmp" class="fnname">partial_cmp</a>(&amp;self, other: &amp;<a class="primitive" href="../primitive.str/">str</a>) -&gt; <a class="enum" href="../option/enum.option/" title="std::option::Option">Option</a>&lt;<a class="enum" href="../cmp/enum.ordering/" title="std::cmp::Ordering">Ordering</a>&gt;</code></span></h4> <div class="docblock">
<p>This method returns an ordering between <code>self</code> and <code>other</code> values if one exists. <a href="../cmp/trait.partialord/#tymethod.partial_cmp">Read more</a></p> </div>
<h4 id="method.lt" class="method"><span id="lt.v" class="invisible"><code>fn <a href="../cmp/trait.partialord/#method.lt" class="fnname">lt</a>(&amp;self, other: &amp;Rhs) -&gt; <a class="primitive" href="../primitive.bool/">bool</a></code></span></h4> <div class="docblock">
<p>This method tests less than (for <code>self</code> and <code>other</code>) and is used by the <code>&lt;</code> operator. <a href="../cmp/trait.partialord/#method.lt">Read more</a></p> </div>
<h4 id="method.le" class="method"><span id="le.v" class="invisible"><code>fn <a href="../cmp/trait.partialord/#method.le" class="fnname">le</a>(&amp;self, other: &amp;Rhs) -&gt; <a class="primitive" href="../primitive.bool/">bool</a></code></span></h4> <div class="docblock">
<p>This method tests less than or equal to (for <code>self</code> and <code>other</code>) and is used by the <code>&lt;=</code> operator. <a href="../cmp/trait.partialord/#method.le">Read more</a></p> </div>
<h4 id="method.gt" class="method"><span id="gt.v" class="invisible"><code>fn <a href="../cmp/trait.partialord/#method.gt" class="fnname">gt</a>(&amp;self, other: &amp;Rhs) -&gt; <a class="primitive" href="../primitive.bool/">bool</a></code></span></h4> <div class="docblock">
<p>This method tests greater than (for <code>self</code> and <code>other</code>) and is used by the <code>&gt;</code> operator. <a href="../cmp/trait.partialord/#method.gt">Read more</a></p> </div>
<h4 id="method.ge" class="method"><span id="ge.v" class="invisible"><code>fn <a href="../cmp/trait.partialord/#method.ge" class="fnname">ge</a>(&amp;self, other: &amp;Rhs) -&gt; <a class="primitive" href="../primitive.bool/">bool</a></code></span></h4> <div class="docblock">
<p>This method tests greater than or equal to (for <code>self</code> and <code>other</code>) and is used by the <code>&gt;=</code> operator. <a href="../cmp/trait.partialord/#method.ge">Read more</a></p> </div>
<h3 class="impl">
<span class="in-band"><code>impl <a class="trait" href="../ops/trait.indexmut/" title="std::ops::IndexMut">IndexMut</a>&lt;<a class="struct" href="../ops/struct.range/" title="std::ops::Range">Range</a>&lt;<a class="primitive" href="../primitive.usize/">usize</a>&gt;&gt; for <a class="primitive" href="../primitive.str/">str</a></code></span><span class="out-of-band">
<div class="since" title="Stable since Rust version 1.2.0">1.2.0</div>
<a class="srclink" href="https://doc.rust-lang.org/src/core/str/mod.rs.html#1461-1473" title="goto source code" target="_blank">[src]</a></span>
</h3> <p>Implements mutable substring slicing with syntax <code>&amp;mut self[begin .. end]</code>.</p> <p>Returns a mutable slice of the given string from the byte range [<code>begin</code>..<code>end</code>).</p> <p>This operation is <code>O(1)</code>.</p> <h4 id="panics-3" class="section-header">Panics</h4> <p>Panics if <code>begin</code> or <code>end</code> does not point to the starting byte offset of a character (as defined by <code>is_char_boundary</code>). Requires that <code>begin &lt;= end</code> and <code>end &lt;= len</code> where <code>len</code> is the length of the string.</p> <h4 id="method.index_mut" class="method"><span id="index_mut.v" class="invisible"><code>fn <a href="../ops/trait.indexmut/#tymethod.index_mut" class="fnname">index_mut</a>(&amp;mut self, index: <a class="struct" href="../ops/struct.range/" title="std::ops::Range">Range</a>&lt;<a class="primitive" href="../primitive.usize/">usize</a>&gt;) -&gt; &amp;mut <a class="primitive" href="../primitive.str/">str</a></code></span></h4> <div class="docblock">
<p>The method for the mutable indexing (<code>container[index]</code>) operation</p> </div>
<h3 class="impl">
<span class="in-band"><code>impl <a class="trait" href="../ops/trait.indexmut/" title="std::ops::IndexMut">IndexMut</a>&lt;<a class="struct" href="../ops/struct.rangeto/" title="std::ops::RangeTo">RangeTo</a>&lt;<a class="primitive" href="../primitive.usize/">usize</a>&gt;&gt; for <a class="primitive" href="../primitive.str/">str</a></code></span><span class="out-of-band">
<div class="since" title="Stable since Rust version 1.2.0">1.2.0</div>
<a class="srclink" href="https://doc.rust-lang.org/src/core/str/mod.rs.html#1503-1513" title="goto source code" target="_blank">[src]</a></span>
</h3> <p>Implements mutable substring slicing with syntax <code>&amp;mut self[.. end]</code>.</p> <p>Returns a mutable slice of the string from the beginning to byte offset <code>end</code>.</p> <p>Equivalent to <code>&amp;mut self[0 .. end]</code>.</p> <h4 id="method.index_mut-1" class="method"><span id="index_mut.v-1" class="invisible"><code>fn <a href="../ops/trait.indexmut/#tymethod.index_mut" class="fnname">index_mut</a>(&amp;mut self, index: <a class="struct" href="../ops/struct.rangeto/" title="std::ops::RangeTo">RangeTo</a>&lt;<a class="primitive" href="../primitive.usize/">usize</a>&gt;) -&gt; &amp;mut <a class="primitive" href="../primitive.str/">str</a></code></span></h4> <div class="docblock">
<p>The method for the mutable indexing (<code>container[index]</code>) operation</p> </div>
<h3 class="impl">
<span class="in-band"><code>impl <a class="trait" href="../ops/trait.indexmut/" title="std::ops::IndexMut">IndexMut</a>&lt;<a class="struct" href="../ops/struct.rangefrom/" title="std::ops::RangeFrom">RangeFrom</a>&lt;<a class="primitive" href="../primitive.usize/">usize</a>&gt;&gt; for <a class="primitive" href="../primitive.str/">str</a></code></span><span class="out-of-band">
<div class="since" title="Stable since Rust version 1.2.0">1.2.0</div>
<a class="srclink" href="https://doc.rust-lang.org/src/core/str/mod.rs.html#1543-1554" title="goto source code" target="_blank">[src]</a></span>
</h3> <p>Implements mutable substring slicing with syntax <code>&amp;mut self[begin ..]</code>.</p> <p>Returns a mutable slice of the string from byte offset <code>begin</code> to the end of the string.</p> <p>Equivalent to <code>&amp;mut self[begin .. len]</code>.</p> <h4 id="method.index_mut-2" class="method"><span id="index_mut.v-2" class="invisible"><code>fn <a href="../ops/trait.indexmut/#tymethod.index_mut" class="fnname">index_mut</a>(&amp;mut self, index: <a class="struct" href="../ops/struct.rangefrom/" title="std::ops::RangeFrom">RangeFrom</a>&lt;<a class="primitive" href="../primitive.usize/">usize</a>&gt;) -&gt; &amp;mut <a class="primitive" href="../primitive.str/">str</a></code></span></h4> <div class="docblock">
<p>The method for the mutable indexing (<code>container[index]</code>) operation</p> </div>
<h3 class="impl">
<span class="in-band"><code>impl <a class="trait" href="../ops/trait.indexmut/" title="std::ops::IndexMut">IndexMut</a>&lt;<a class="struct" href="../ops/struct.rangefull/" title="std::ops::RangeFull">RangeFull</a>&gt; for <a class="primitive" href="../primitive.str/">str</a></code></span><span class="out-of-band">
<div class="since" title="Stable since Rust version 1.2.0">1.2.0</div>
<a class="srclink" href="https://doc.rust-lang.org/src/core/str/mod.rs.html#1579-1584" title="goto source code" target="_blank">[src]</a></span>
</h3> <p>Implements mutable substring slicing with syntax <code>&amp;mut self[..]</code>.</p> <p>Returns a mutable slice of the whole string. This operation can never panic.</p> <p>Equivalent to <code>&amp;mut self[0 .. len]</code>.</p> <h4 id="method.index_mut-3" class="method"><span id="index_mut.v-3" class="invisible"><code>fn <a href="../ops/trait.indexmut/#tymethod.index_mut" class="fnname">index_mut</a>(&amp;mut self, _index: <a class="struct" href="../ops/struct.rangefull/" title="std::ops::RangeFull">RangeFull</a>) -&gt; &amp;mut <a class="primitive" href="../primitive.str/">str</a></code></span></h4> <div class="docblock">
<p>The method for the mutable indexing (<code>container[index]</code>) operation</p> </div>
<h3 class="impl">
<span class="in-band"><code>impl <a class="trait" href="../ops/trait.indexmut/" title="std::ops::IndexMut">IndexMut</a>&lt;<a class="enum" href="../ops/enum.rangeinclusive/" title="std::ops::RangeInclusive">RangeInclusive</a>&lt;<a class="primitive" href="../primitive.usize/">usize</a>&gt;&gt; for <a class="primitive" href="../primitive.str/">str</a></code></span><span class="out-of-band">
<a class="srclink" href="https://doc.rust-lang.org/src/core/str/mod.rs.html#1618-1629" title="goto source code" target="_blank">[src]</a></span>
</h3> <h4 id="method.index_mut-4" class="method"><span id="index_mut.v-4" class="invisible"><code>fn <a href="../ops/trait.indexmut/#tymethod.index_mut" class="fnname">index_mut</a>(&amp;mut self, index: <a class="enum" href="../ops/enum.rangeinclusive/" title="std::ops::RangeInclusive">RangeInclusive</a>&lt;<a class="primitive" href="../primitive.usize/">usize</a>&gt;) -&gt; &amp;mut <a class="primitive" href="../primitive.str/">str</a></code></span></h4> <div class="docblock">
<p>The method for the mutable indexing (<code>container[index]</code>) operation</p> </div>
<h3 class="impl">
<span class="in-band"><code>impl <a class="trait" href="../ops/trait.indexmut/" title="std::ops::IndexMut">IndexMut</a>&lt;<a class="struct" href="../ops/struct.rangetoinclusive/" title="std::ops::RangeToInclusive">RangeToInclusive</a>&lt;<a class="primitive" href="../primitive.usize/">usize</a>&gt;&gt; for <a class="primitive" href="../primitive.str/">str</a></code></span><span class="out-of-band">
<a class="srclink" href="https://doc.rust-lang.org/src/core/str/mod.rs.html#1633-1638" title="goto source code" target="_blank">[src]</a></span>
</h3> <h4 id="method.index_mut-5" class="method"><span id="index_mut.v-5" class="invisible"><code>fn <a href="../ops/trait.indexmut/#tymethod.index_mut" class="fnname">index_mut</a>(&amp;mut self, index: <a class="struct" href="../ops/struct.rangetoinclusive/" title="std::ops::RangeToInclusive">RangeToInclusive</a>&lt;<a class="primitive" href="../primitive.usize/">usize</a>&gt;) -&gt; &amp;mut <a class="primitive" href="../primitive.str/">str</a></code></span></h4> <div class="docblock">
<p>The method for the mutable indexing (<code>container[index]</code>) operation</p> </div>
<h3 class="impl">
<span class="in-band"><code>impl <a class="trait" href="https://doc.rust-lang.org/std_unicode/u_str/trait.UnicodeStr.html" title="std_unicode::u_str::UnicodeStr" target="_blank">UnicodeStr</a> for <a class="primitive" href="../primitive.str/">str</a></code></span><span class="out-of-band">
<a class="srclink" href="https://doc.rust-lang.org/src/std_unicode/u_str.rs.html#38-78" title="goto source code" target="_blank">[src]</a></span>
</h3> <h4 id="method.split_whitespace-1" class="method"><span id="split_whitespace.v-1" class="invisible"><code>fn <a href="https://doc.rust-lang.org/std_unicode/u_str/trait.UnicodeStr.html#tymethod.split_whitespace" class="fnname" target="_blank">split_whitespace</a>(&amp;self) -&gt; <a class="struct" href="../str/struct.splitwhitespace/" title="std::str::SplitWhitespace">SplitWhitespace</a></code></span></h4> <div class="stability"><span class="stab unstable">🔬 This is a nightly-only experimental API. (unicode #27783)</span></div>
<h4 id="method.is_whitespace" class="method"><span id="is_whitespace.v" class="invisible"><code>fn <a href="https://doc.rust-lang.org/std_unicode/u_str/trait.UnicodeStr.html#tymethod.is_whitespace" class="fnname" target="_blank">is_whitespace</a>(&amp;self) -&gt; <a class="primitive" href="../primitive.bool/">bool</a></code></span></h4> <div class="stability"><span class="stab unstable">🔬 This is a nightly-only experimental API. (unicode #27783)</span></div>
<h4 id="method.is_alphanumeric" class="method"><span id="is_alphanumeric.v" class="invisible"><code>fn <a href="https://doc.rust-lang.org/std_unicode/u_str/trait.UnicodeStr.html#tymethod.is_alphanumeric" class="fnname" target="_blank">is_alphanumeric</a>(&amp;self) -&gt; <a class="primitive" href="../primitive.bool/">bool</a></code></span></h4> <div class="stability"><span class="stab unstable">🔬 This is a nightly-only experimental API. (unicode #27783)</span></div>
<h4 id="method.trim-1" class="method"><span id="trim.v-1" class="invisible"><code>fn <a href="https://doc.rust-lang.org/std_unicode/u_str/trait.UnicodeStr.html#tymethod.trim" class="fnname" target="_blank">trim</a>(&amp;self) -&gt; &amp;<a class="primitive" href="../primitive.str/">str</a></code></span></h4> <div class="stability"><span class="stab unstable">🔬 This is a nightly-only experimental API. (unicode #27783)</span></div>
<h4 id="method.trim_left-1" class="method"><span id="trim_left.v-1" class="invisible"><code>fn <a href="https://doc.rust-lang.org/std_unicode/u_str/trait.UnicodeStr.html#tymethod.trim_left" class="fnname" target="_blank">trim_left</a>(&amp;self) -&gt; &amp;<a class="primitive" href="../primitive.str/">str</a></code></span></h4> <div class="stability"><span class="stab unstable">🔬 This is a nightly-only experimental API. (unicode #27783)</span></div>
<h4 id="method.trim_right-1" class="method"><span id="trim_right.v-1" class="invisible"><code>fn <a href="https://doc.rust-lang.org/std_unicode/u_str/trait.UnicodeStr.html#tymethod.trim_right" class="fnname" target="_blank">trim_right</a>(&amp;self) -&gt; &amp;<a class="primitive" href="../primitive.str/">str</a></code></span></h4> <div class="stability"><span class="stab unstable">🔬 This is a nightly-only experimental API. (unicode #27783)</span></div>
<h3 class="impl">
<span class="in-band"><code>impl <a class="trait" href="../ascii/trait.asciiext/" title="std::ascii::AsciiExt">AsciiExt</a> for <a class="primitive" href="../primitive.str/">str</a></code></span><span class="out-of-band">
<a class="srclink" href="https://doc.rust-lang.org/src/std/ascii.rs.html#190-228" title="goto source code" target="_blank">[src]</a></span>
</h3> <h4 id="associatedtype.Owned-1" class="type"><span id="Owned.t-1" class="invisible"><code>type <a href="../ascii/trait.asciiext/#associatedtype.Owned" class="type">Owned</a> = <a class="struct" href="../string/struct.string/" title="std::string::String">String</a></code></span></h4> <div class="docblock">
<p>Container type for copied ASCII characters.</p> </div>
<h4 id="method.is_ascii" class="method"><span id="is_ascii.v" class="invisible"><code>fn <a href="../ascii/trait.asciiext/#tymethod.is_ascii" class="fnname">is_ascii</a>(&amp;self) -&gt; <a class="primitive" href="../primitive.bool/">bool</a></code></span></h4> <div class="docblock">
<p>Checks if the value is within the ASCII range. <a href="../ascii/trait.asciiext/#tymethod.is_ascii">Read more</a></p> </div>
<h4 id="method.to_ascii_uppercase" class="method"><span id="to_ascii_uppercase.v" class="invisible"><code>fn <a href="../ascii/trait.asciiext/#tymethod.to_ascii_uppercase" class="fnname">to_ascii_uppercase</a>(&amp;self) -&gt; <a class="struct" href="../string/struct.string/" title="std::string::String">String</a></code></span></h4> <div class="docblock">
<p>Makes a copy of the string in ASCII upper case. <a href="../ascii/trait.asciiext/#tymethod.to_ascii_uppercase">Read more</a></p> </div>
<h4 id="method.to_ascii_lowercase" class="method"><span id="to_ascii_lowercase.v" class="invisible"><code>fn <a href="../ascii/trait.asciiext/#tymethod.to_ascii_lowercase" class="fnname">to_ascii_lowercase</a>(&amp;self) -&gt; <a class="struct" href="../string/struct.string/" title="std::string::String">String</a></code></span></h4> <div class="docblock">
<p>Makes a copy of the string in ASCII lower case. <a href="../ascii/trait.asciiext/#tymethod.to_ascii_lowercase">Read more</a></p> </div>
<h4 id="method.eq_ignore_ascii_case" class="method"><span id="eq_ignore_ascii_case.v" class="invisible"><code>fn <a href="../ascii/trait.asciiext/#tymethod.eq_ignore_ascii_case" class="fnname">eq_ignore_ascii_case</a>(&amp;self, other: &amp;<a class="primitive" href="../primitive.str/">str</a>) -&gt; <a class="primitive" href="../primitive.bool/">bool</a></code></span></h4> <div class="docblock">
<p>Checks that two strings are an ASCII case-insensitive match. <a href="../ascii/trait.asciiext/#tymethod.eq_ignore_ascii_case">Read more</a></p> </div>
<h4 id="method.make_ascii_uppercase" class="method"><span id="make_ascii_uppercase.v" class="invisible"><code>fn <a href="../ascii/trait.asciiext/#tymethod.make_ascii_uppercase" class="fnname">make_ascii_uppercase</a>(&amp;mut self)</code></span></h4> <div class="docblock">
<p>Converts this type to its ASCII upper case equivalent in-place. <a href="../ascii/trait.asciiext/#tymethod.make_ascii_uppercase">Read more</a></p> </div>
<h4 id="method.make_ascii_lowercase" class="method"><span id="make_ascii_lowercase.v" class="invisible"><code>fn <a href="../ascii/trait.asciiext/#tymethod.make_ascii_lowercase" class="fnname">make_ascii_lowercase</a>(&amp;mut self)</code></span></h4> <div class="docblock">
<p>Converts this type to its ASCII lower case equivalent in-place. <a href="../ascii/trait.asciiext/#tymethod.make_ascii_lowercase">Read more</a></p> </div>
<h3 class="impl">
<span class="in-band"><code>impl <a class="trait" href="../cmp/trait.partialeq/" title="std::cmp::PartialEq">PartialEq</a>&lt;<a class="struct" href="../ffi/struct.osstring/" title="std::ffi::OsString">OsString</a>&gt; for <a class="primitive" href="../primitive.str/">str</a></code></span><span class="out-of-band">
<a class="srclink" href="https://doc.rust-lang.org/src/std/ffi/os_str.rs.html#274-278" title="goto source code" target="_blank">[src]</a></span>
</h3> <h4 id="method.eq-5" class="method"><span id="eq.v-5" class="invisible"><code>fn <a href="../cmp/trait.partialeq/#tymethod.eq" class="fnname">eq</a>(&amp;self, other: &amp;<a class="struct" href="../ffi/struct.osstring/" title="std::ffi::OsString">OsString</a>) -&gt; <a class="primitive" href="../primitive.bool/">bool</a></code></span></h4> <div class="docblock">
<p>This method tests for <code>self</code> and <code>other</code> values to be equal, and is used by <code>==</code>. <a href="../cmp/trait.partialeq/#tymethod.eq">Read more</a></p> </div>
<h4 id="method.ne-5" class="method"><span id="ne.v-5" class="invisible"><code>fn <a href="../cmp/trait.partialeq/#method.ne" class="fnname">ne</a>(&amp;self, other: &amp;Rhs) -&gt; <a class="primitive" href="../primitive.bool/">bool</a></code></span></h4> <div class="docblock">
<p>This method tests for <code>!=</code>.</p> </div>
<h3 class="impl">
<span class="in-band"><code>impl <a class="trait" href="../cmp/trait.partialeq/" title="std::cmp::PartialEq">PartialEq</a>&lt;<a class="struct" href="../ffi/struct.osstr/" title="std::ffi::OsStr">OsStr</a>&gt; for <a class="primitive" href="../primitive.str/">str</a></code></span><span class="out-of-band">
<a class="srclink" href="https://doc.rust-lang.org/src/std/ffi/os_str.rs.html#472-476" title="goto source code" target="_blank">[src]</a></span>
</h3> <h4 id="method.eq-6" class="method"><span id="eq.v-6" class="invisible"><code>fn <a href="../cmp/trait.partialeq/#tymethod.eq" class="fnname">eq</a>(&amp;self, other: &amp;<a class="struct" href="../ffi/struct.osstr/" title="std::ffi::OsStr">OsStr</a>) -&gt; <a class="primitive" href="../primitive.bool/">bool</a></code></span></h4> <div class="docblock">
<p>This method tests for <code>self</code> and <code>other</code> values to be equal, and is used by <code>==</code>. <a href="../cmp/trait.partialeq/#tymethod.eq">Read more</a></p> </div>
<h4 id="method.ne-6" class="method"><span id="ne.v-6" class="invisible"><code>fn <a href="../cmp/trait.partialeq/#method.ne" class="fnname">ne</a>(&amp;self, other: &amp;Rhs) -&gt; <a class="primitive" href="../primitive.bool/">bool</a></code></span></h4> <div class="docblock">
<p>This method tests for <code>!=</code>.</p> </div>
<h3 class="impl">
<span class="in-band"><code>impl <a class="trait" href="../convert/trait.asref/" title="std::convert::AsRef">AsRef</a>&lt;<a class="struct" href="../ffi/struct.osstr/" title="std::ffi::OsStr">OsStr</a>&gt; for <a class="primitive" href="../primitive.str/">str</a></code></span><span class="out-of-band">
<a class="srclink" href="https://doc.rust-lang.org/src/std/ffi/os_str.rs.html#593-597" title="goto source code" target="_blank">[src]</a></span>
</h3> <h4 id="method.as_ref-2" class="method"><span id="as_ref.v-2" class="invisible"><code>fn <a href="../convert/trait.asref/#tymethod.as_ref" class="fnname">as_ref</a>(&amp;self) -&gt; &amp;<a class="struct" href="../ffi/struct.osstr/" title="std::ffi::OsStr">OsStr</a></code></span></h4> <div class="docblock">
<p>Performs the conversion.</p> </div>
<h3 class="impl">
<span class="in-band"><code>impl <a class="trait" href="../net/trait.tosocketaddrs/" title="std::net::ToSocketAddrs">ToSocketAddrs</a> for <a class="primitive" href="../primitive.str/">str</a></code></span><span class="out-of-band">
<a class="srclink" href="https://doc.rust-lang.org/src/std/net/addr.rs.html#715-740" title="goto source code" target="_blank">[src]</a></span>
</h3> <h4 id="associatedtype.Iter" class="type"><span id="Iter.t" class="invisible"><code>type <a href="../net/trait.tosocketaddrs/#associatedtype.Iter" class="type">Iter</a> = <a class="struct" href="../vec/struct.intoiter/" title="std::vec::IntoIter">IntoIter</a>&lt;<a class="enum" href="../net/enum.socketaddr/" title="std::net::SocketAddr">SocketAddr</a>&gt;</code></span></h4> <div class="docblock">
<p>Returned iterator over socket addresses which this type may correspond to. <a href="../net/trait.tosocketaddrs/#associatedtype.Iter">Read more</a></p> </div>
<h4 id="method.to_socket_addrs" class="method"><span id="to_socket_addrs.v" class="invisible"><code>fn <a href="../net/trait.tosocketaddrs/#tymethod.to_socket_addrs" class="fnname">to_socket_addrs</a>(&amp;self) -&gt; <a class="type" href="../io/type.result/" title="std::io::Result">Result</a>&lt;<a class="struct" href="../vec/struct.intoiter/" title="std::vec::IntoIter">IntoIter</a>&lt;<a class="enum" href="../net/enum.socketaddr/" title="std::net::SocketAddr">SocketAddr</a>&gt;&gt;</code></span></h4> <div class="docblock">
<p>Converts this object to an iterator of resolved <code>SocketAddr</code>s. <a href="../net/trait.tosocketaddrs/#tymethod.to_socket_addrs">Read more</a></p> </div>
<h3 class="impl">
<span class="in-band"><code>impl <a class="trait" href="../convert/trait.asref/" title="std::convert::AsRef">AsRef</a>&lt;<a class="struct" href="../path/struct.path/" title="std::path::Path">Path</a>&gt; for <a class="primitive" href="../primitive.str/">str</a></code></span><span class="out-of-band">
<a class="srclink" href="https://doc.rust-lang.org/src/std/path.rs.html#2161-2165" title="goto source code" target="_blank">[src]</a></span>
</h3> <h4 id="method.as_ref-3" class="method"><span id="as_ref.v-3" class="invisible"><code>fn <a href="../convert/trait.asref/#tymethod.as_ref" class="fnname">as_ref</a>(&amp;self) -&gt; &amp;<a class="struct" href="../path/struct.path/" title="std::path::Path">Path</a></code></span></h4> <div class="docblock">
<p>Performs the conversion.</p> </div>
<div class="_attribution">
  <p class="_attribution-p">
    © 2010 The Rust Project Developers<br>Licensed under the Apache License, Version 2.0 or the MIT license, at your option.<br>
    <a href="https://doc.rust-lang.org/std/primitive.str.html" class="_attribution-link" target="_blank">https://doc.rust-lang.org/std/primitive.str.html</a>
  </p>
</div>

			</div>
		</div>
	</section>

	</div>
</body>
</html>
