
<!DOCTYPE HTML>

<html lang="en">

<head>
  <meta charset="utf-8">
  <title>Reference - Rust - W3cubDocs</title>
  
  <meta name="description" content=" This document is the primary reference for the Rust programming language. It provides three kinds of material&#58; ">
  <meta name="keywords" content="rust, reference, -">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="http://docs.w3cub.com/rust/reference/">
  <link href="/favicon.png" rel="icon">
  <link type="text/css" rel="stylesheet" href="/assets/application-50364fff564ce3b6327021805f3f00e2957b441cf27f576a7dd4ff63bbc47047.css">
  <script type="text/javascript" src="/assets/application-db64bfd54ceb42be11af7995804cf4902548419ceb79d509b0b7d62c22d98e6f.js"></script>
  <script src="/json/rust.js"></script>
  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-71174418-1']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>


</head>

<body>
	<div class="_app">
	<header class="_header">
  
  <form class="_search">
    <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
    <a class="_search-clear"></a>
    <div class="_search-tag"></div>
  </form>
  
  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/rust/" class="_nav-link" title="" style="margin-left:0;">Rust</a></span>
  
  <nav class="_nav">
    <a href="/app/" class="_nav-link ">App</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		<div class="_list">
			
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<div class="_page _rust">
				
<h1 class="title">The Rust Reference</h1> <nav id="TOC"><ul> <li>
<a href="#introduction">1 Introduction</a>
</li> <li>
<a href="#notation">2 Notation</a><ul> <li>
<a href="#unicode-productions">2.1 Unicode productions</a>
</li> <li>
<a href="#string-table-productions">2.2 String table productions</a>
</li>
</ul>
</li> <li>
<a href="#lexical-structure">3 Lexical structure</a><ul> <li>
<a href="#input-format">3.1 Input format</a>
</li> <li>
<a href="#identifiers">3.2 Identifiers</a>
</li> <li>
<a href="#comments">3.3 Comments</a>
</li> <li>
<a href="#whitespace">3.4 Whitespace</a>
</li> <li>
<a href="#tokens">3.5 Tokens</a><ul> <li>
<a href="#literals">3.5.1 Literals</a><ul> <li>
<a href="#examples">3.5.1.1 Examples</a><ul> <li>
<a href="#characters-and-strings">3.5.1.1.1 Characters and strings</a>
</li> <li>
<a href="#byte-escapes">3.5.1.1.2 Byte escapes</a>
</li> <li>
<a href="#unicode-escapes">3.5.1.1.3 Unicode escapes</a>
</li> <li>
<a href="#quote-escapes">3.5.1.1.4 Quote escapes</a>
</li> <li>
<a href="#numbers">3.5.1.1.5 Numbers</a>
</li> <li>
<a href="#suffixes">3.5.1.1.6 Suffixes</a>
</li>
</ul>
</li> <li>
<a href="#character-and-string-literals">3.5.1.2 Character and string literals</a><ul> <li>
<a href="#character-literals">3.5.1.2.1 Character literals</a>
</li> <li>
<a href="#string-literals">3.5.1.2.2 String literals</a>
</li> <li>
<a href="#character-escapes">3.5.1.2.3 Character escapes</a>
</li> <li>
<a href="#raw-string-literals">3.5.1.2.4 Raw string literals</a>
</li>
</ul>
</li> <li>
<a href="#byte-and-byte-string-literals">3.5.1.3 Byte and byte string literals</a><ul> <li>
<a href="#byte-literals">3.5.1.3.1 Byte literals</a>
</li> <li>
<a href="#byte-string-literals">3.5.1.3.2 Byte string literals</a>
</li> <li>
<a href="#raw-byte-string-literals">3.5.1.3.3 Raw byte string literals</a>
</li>
</ul>
</li> <li>
<a href="#number-literals">3.5.1.4 Number literals</a><ul> <li>
<a href="#integer-literals">3.5.1.4.1 Integer literals</a>
</li> <li>
<a href="#floating-point-literals">3.5.1.4.2 Floating-point literals</a>
</li>
</ul>
</li> <li>
<a href="#boolean-literals">3.5.1.5 Boolean literals</a>
</li>
</ul>
</li> <li>
<a href="#symbols">3.5.2 Symbols</a>
</li>
</ul>
</li> <li>
<a href="#paths">3.6 Paths</a>
</li>
</ul>
</li> <li>
<a href="#macros">4 Macros</a><ul> <li>
<a href="#macros-1">4.1 Macros</a><ul> <li>
<a href="#macro-by-example">4.1.1 Macro By Example</a>
</li> <li>
<a href="#parsing-limitations">4.1.2 Parsing limitations</a>
</li>
</ul>
</li> <li>
<a href="#procedural-macros">4.2 Procedural Macros</a>
</li>
</ul>
</li> <li>
<a href="#crates-and-source-files">5 Crates and source files</a>
</li> <li>
<a href="#items-and-attributes">6 Items and attributes</a><ul> <li>
<a href="#items">6.1 Items</a><ul> <li>
<a href="#type-parameters">6.1.1 Type Parameters</a>
</li> <li>
<a href="#modules">6.1.2 Modules</a><ul> <li>
<a href="#extern-crate-declarations">6.1.2.1 Extern crate declarations</a>
</li> <li>
<a href="#use-declarations">6.1.2.2 Use declarations</a>
</li>
</ul>
</li> <li>
<a href="#functions">6.1.3 Functions</a><ul> <li>
<a href="#generic-functions">6.1.3.1 Generic functions</a>
</li> <li>
<a href="#diverging-functions">6.1.3.2 Diverging functions</a>
</li> <li>
<a href="#extern-functions">6.1.3.3 Extern functions</a>
</li>
</ul>
</li> <li>
<a href="#type-aliases">6.1.4 Type aliases</a>
</li> <li>
<a href="#structs">6.1.5 Structs</a>
</li> <li>
<a href="#enumerations">6.1.6 Enumerations</a>
</li> <li>
<a href="#constant-items">6.1.7 Constant items</a>
</li> <li>
<a href="#static-items">6.1.8 Static items</a><ul> <li>
<a href="#mutable-statics">6.1.8.1 Mutable statics</a>
</li>
</ul>
</li> <li>
<a href="#traits">6.1.9 Traits</a>
</li> <li>
<a href="#implementations">6.1.10 Implementations</a>
</li> <li>
<a href="#external-blocks">6.1.11 External blocks</a>
</li>
</ul>
</li> <li>
<a href="#visibility-and-privacy">6.2 Visibility and Privacy</a><ul> <li>
<a href="#re-exporting-and-visibility">6.2.1 Re-exporting and Visibility</a>
</li>
</ul>
</li> <li>
<a href="#attributes">6.3 Attributes</a><ul> <li>
<a href="#crate-only-attributes">6.3.1 Crate-only attributes</a>
</li> <li>
<a href="#module-only-attributes">6.3.2 Module-only attributes</a>
</li> <li>
<a href="#function-only-attributes">6.3.3 Function-only attributes</a>
</li> <li>
<a href="#static-only-attributes">6.3.4 Static-only attributes</a>
</li> <li>
<a href="#ffi-attributes">6.3.5 FFI attributes</a>
</li> <li>
<a href="#macro-related-attributes">6.3.6 Macro-related attributes</a>
</li> <li>
<a href="#miscellaneous-attributes">6.3.7 Miscellaneous attributes</a>
</li> <li>
<a href="#conditional-compilation">6.3.8 Conditional compilation</a>
</li> <li>
<a href="#lint-check-attributes">6.3.9 Lint check attributes</a>
</li> <li>
<a href="#language-items">6.3.10 Language items</a>
</li> <li>
<a href="#inline-attributes">6.3.11 Inline attributes</a>
</li> <li>
<a href="#derive">6.3.12 <code>derive</code></a>
</li> <li>
<a href="#compiler-features">6.3.13 Compiler Features</a>
</li>
</ul>
</li>
</ul>
</li> <li>
<a href="#statements-and-expressions">7 Statements and expressions</a><ul> <li>
<a href="#statements">7.1 Statements</a><ul> <li>
<a href="#declaration-statements">7.1.1 Declaration statements</a><ul> <li>
<a href="#item-declarations">7.1.1.1 Item declarations</a>
</li> <li>
<a href="#let-statements">7.1.1.2 <code>let</code> statements</a>
</li>
</ul>
</li> <li>
<a href="#expression-statements">7.1.2 Expression statements</a>
</li>
</ul>
</li> <li>
<a href="#expressions">7.2 Expressions</a><ul> <li>
<a href="#lvalues-rvalues-and-temporaries">7.2.0.1 Lvalues, rvalues and temporaries</a><ul> <li>
<a href="#temporary-lifetimes">7.2.0.1.1 Temporary lifetimes</a>
</li>
</ul>
</li> <li>
<a href="#moved-and-copied-types">7.2.0.2 Moved and copied types</a>
</li> <li>
<a href="#literal-expressions">7.2.1 Literal expressions</a>
</li> <li>
<a href="#path-expressions">7.2.2 Path expressions</a>
</li> <li>
<a href="#tuple-expressions">7.2.3 Tuple expressions</a>
</li> <li>
<a href="#struct-expressions">7.2.4 Struct expressions</a>
</li> <li>
<a href="#block-expressions">7.2.5 Block expressions</a>
</li> <li>
<a href="#method-call-expressions">7.2.6 Method-call expressions</a>
</li> <li>
<a href="#field-expressions">7.2.7 Field expressions</a>
</li> <li>
<a href="#array-expressions">7.2.8 Array expressions</a>
</li> <li>
<a href="#index-expressions">7.2.9 Index expressions</a>
</li> <li>
<a href="#range-expressions">7.2.10 Range expressions</a>
</li> <li>
<a href="#unary-operator-expressions">7.2.11 Unary operator expressions</a>
</li> <li>
<a href="#binary-operator-expressions">7.2.12 Binary operator expressions</a><ul> <li>
<a href="#arithmetic-operators">7.2.12.1 Arithmetic operators</a>
</li> <li>
<a href="#bitwise-operators">7.2.12.2 Bitwise operators</a>
</li> <li>
<a href="#lazy-boolean-operators">7.2.12.3 Lazy boolean operators</a>
</li> <li>
<a href="#comparison-operators">7.2.12.4 Comparison operators</a>
</li> <li>
<a href="#type-cast-expressions">7.2.12.5 Type cast expressions</a>
</li> <li>
<a href="#assignment-expressions">7.2.12.6 Assignment expressions</a>
</li> <li>
<a href="#compound-assignment-expressions">7.2.12.7 Compound assignment expressions</a>
</li> <li>
<a href="#operator-precedence">7.2.12.8 Operator precedence</a>
</li>
</ul>
</li> <li>
<a href="#grouped-expressions">7.2.13 Grouped expressions</a>
</li> <li>
<a href="#call-expressions">7.2.14 Call expressions</a>
</li> <li>
<a href="#lambda-expressions">7.2.15 Lambda expressions</a>
</li> <li>
<a href="#infinite-loops">7.2.16 Infinite loops</a>
</li> <li>
<a href="#break-expressions">7.2.17 <code>break</code> expressions</a>
</li> <li>
<a href="#continue-expressions">7.2.18 <code>continue</code> expressions</a>
</li> <li>
<a href="#while-loops">7.2.19 <code>while</code> loops</a>
</li> <li>
<a href="#for-expressions">7.2.20 <code>for</code> expressions</a>
</li> <li>
<a href="#if-expressions">7.2.21 <code>if</code> expressions</a>
</li> <li>
<a href="#match-expressions">7.2.22 <code>match</code> expressions</a>
</li> <li>
<a href="#if-let-expressions">7.2.23 <code>if let</code> expressions</a>
</li> <li>
<a href="#while-let-loops">7.2.24 <code>while let</code> loops</a>
</li> <li>
<a href="#return-expressions">7.2.25 <code>return</code> expressions</a>
</li>
</ul>
</li>
</ul>
</li> <li>
<a href="#type-system">8 Type system</a><ul> <li>
<a href="#types">8.1 Types</a><ul> <li>
<a href="#primitive-types">8.1.1 Primitive types</a><ul> <li>
<a href="#machine-types">8.1.1.1 Machine types</a>
</li> <li>
<a href="#machine-dependent-integer-types">8.1.1.2 Machine-dependent integer types</a>
</li>
</ul>
</li> <li>
<a href="#textual-types">8.1.2 Textual types</a>
</li> <li>
<a href="#tuple-types">8.1.3 Tuple types</a>
</li> <li>
<a href="#array-and-slice-types">8.1.4 Array, and Slice types</a>
</li> <li>
<a href="#struct-types">8.1.5 Struct types</a>
</li> <li>
<a href="#enumerated-types">8.1.6 Enumerated types</a>
</li> <li>
<a href="#recursive-types">8.1.7 Recursive types</a>
</li> <li>
<a href="#pointer-types">8.1.8 Pointer types</a>
</li> <li>
<a href="#function-types">8.1.9 Function types</a><ul> <li>
<a href="#function-types-for-specific-items">8.1.9.1 Function types for specific items</a>
</li>
</ul>
</li> <li>
<a href="#closure-types">8.1.10 Closure types</a>
</li> <li>
<a href="#trait-objects">8.1.11 Trait objects</a>
</li> <li>
<a href="#type-parameters-1">8.1.12 Type parameters</a>
</li> <li>
<a href="#self-types">8.1.13 Self types</a>
</li>
</ul>
</li> <li>
<a href="#subtyping">8.2 Subtyping</a>
</li> <li>
<a href="#type-coercions">8.3 Type coercions</a><ul> <li>
<a href="#coercion-sites">8.3.1 Coercion sites</a>
</li> <li>
<a href="#coercion-types">8.3.2 Coercion types</a>
</li>
</ul>
</li>
</ul>
</li> <li>
<a href="#special-traits">9 Special traits</a><ul> <li>
<a href="#the-copy-trait">9.1 The <code>Copy</code> trait</a>
</li> <li>
<a href="#the-sized-trait">9.2 The <code>Sized</code> trait</a>
</li> <li>
<a href="#the-drop-trait">9.3 The <code>Drop</code> trait</a>
</li> <li>
<a href="#the-deref-trait">9.4 The <code>Deref</code> trait</a>
</li> <li>
<a href="#the-send-trait">9.5 The <code>Send</code> trait</a>
</li> <li>
<a href="#the-sync-trait">9.6 The <code>Sync</code> trait</a>
</li>
</ul>
</li> <li>
<a href="#memory-model">10 Memory model</a><ul> <li>
<a href="#memory-allocation-and-lifetime">10.0.1 Memory allocation and lifetime</a>
</li> <li>
<a href="#memory-ownership">10.0.2 Memory ownership</a>
</li> <li>
<a href="#variables">10.0.3 Variables</a>
</li>
</ul>
</li> <li>
<a href="#linkage">11 Linkage</a>
</li> <li>
<a href="#unsafety">12 Unsafety</a><ul> <li>
<a href="#unsafe-functions">12.1 Unsafe functions</a>
</li> <li>
<a href="#unsafe-blocks">12.2 Unsafe blocks</a>
</li> <li>
<a href="#behavior-considered-undefined">12.3 Behavior considered undefined</a>
</li> <li>
<a href="#behavior-not-considered-unsafe">12.4 Behavior not considered unsafe</a>
</li>
</ul>
</li> <li>
<a href="#appendix-influences">13 Appendix: Influences</a>
</li>
</ul></nav> <h2 id="introduction" class="section-header">1 Introduction</h2> <p>This document is the primary reference for the Rust programming language. It provides three kinds of material:</p> <ul> <li>Chapters that informally describe each language construct and their use.</li> <li>Chapters that informally describe the memory model, concurrency model, runtime services, linkage model and debugging facilities.</li> <li>Appendix chapters providing rationale and references to languages that influenced the design.</li> </ul> <p>This document does not serve as an introduction to the language. Background familiarity with the language is assumed. A separate <a href="../">book</a> is available to help acquire such background familiarity.</p> <p>This document also does not serve as a reference to the <a href="../std/">standard</a> library included in the language distribution. Those libraries are documented separately by extracting documentation attributes from their source code. Many of the features that one might expect to be language features are library features in Rust, so what you're looking for may be there, not here.</p> <p>Finally, this document is not normative. It may include details that are specific to <code>rustc</code> itself, and should not be taken as a specification for the Rust language. We intend to produce such a document someday, but this is what we have for now.</p> <p>You may also be interested in the <a href="https://doc.rust-lang.org/grammar.html" target="_blank">grammar</a>.</p> <h2 id="notation" class="section-header">2 Notation</h2> <h3 id="unicode-productions" class="section-header">2.1 Unicode productions</h3> <p>A few productions in Rust's grammar permit Unicode code points outside the ASCII range. We define these productions in terms of character properties specified in the Unicode standard, rather than in terms of ASCII-range code points. The grammar has a <a href="https://doc.rust-lang.org/grammar.html#special-unicode-productions" target="_blank">Special Unicode Productions</a> section that lists these productions.</p> <h3 id="string-table-productions" class="section-header">2.2 String table productions</h3> <p>Some rules in the grammar — notably <a href="#unary-operator-expressions">unary operators</a>, <a href="#binary-operator-expressions">binary operators</a>, and <a href="https://doc.rust-lang.org/grammar.html#keywords" target="_blank">keywords</a> — are given in a simplified form: as a listing of a table of unquoted, printable whitespace-separated strings. These cases form a subset of the rules regarding the <a href="#tokens">token</a> rule, and are assumed to be the result of a lexical-analysis phase feeding the parser, driven by a DFA, operating over the disjunction of all such string table entries.</p> <p>When such a string enclosed in double-quotes (<code>"</code>) occurs inside the grammar, it is an implicit reference to a single member of such a string table production. See <a href="#tokens">tokens</a> for more information.</p> <h2 id="lexical-structure" class="section-header">3 Lexical structure</h2> <h3 id="input-format" class="section-header">3.1 Input format</h3> <p>Rust input is interpreted as a sequence of Unicode code points encoded in UTF-8. Most Rust grammar rules are defined in terms of printable ASCII-range code points, but a small number are defined in terms of Unicode properties or explicit code point lists. <sup id="fnref1"><a href="#fn1" rel="footnote">1</a></sup></p> <h3 id="identifiers" class="section-header">3.2 Identifiers</h3> <p>An identifier is any nonempty Unicode<sup id="fnref2"><a href="#fn2" rel="footnote">2</a></sup> string of the following form:</p> <p>Either</p> <ul> <li>The first character has property <code>XID_start</code>
</li> <li>The remaining characters have property <code>XID_continue</code>
</li> </ul> <p>Or</p> <ul> <li>The first character is <code>_</code>
</li> <li>The identifier is more than one character, <code>_</code> alone is not an identifier</li> <li>The remaining characters have property <code>XID_continue</code>
</li> </ul> <p>that does <em>not</em> occur in the set of <a href="https://doc.rust-lang.org/grammar.html#keywords" target="_blank">keywords</a>.</p> <blockquote> <p><strong>Note</strong>: <code>XID_start</code> and <code>XID_continue</code> as character properties cover the character ranges used to form the more familiar C and Java language-family identifiers.</p> </blockquote> <h3 id="comments" class="section-header">3.3 Comments</h3> <p>Comments in Rust code follow the general C++ style of line (<code>//</code>) and block (<code>/* ... */</code>) comment forms. Nested block comments are supported.</p> <p>Line comments beginning with exactly <em>three</em> slashes (<code>///</code>), and block comments (<code>/** ... */</code>), are interpreted as a special syntax for <code>doc</code> <a href="#attributes">attributes</a>. That is, they are equivalent to writing <code>#[doc="..."]</code> around the body of the comment, i.e., <code>/// Foo</code> turns into <code>#[doc="Foo"]</code>.</p> <p>Line comments beginning with <code>//!</code> and block comments <code>/*! ... */</code> are doc comments that apply to the parent of the comment, rather than the item that follows. That is, they are equivalent to writing <code>#![doc="..."]</code> around the body of the comment. <code>//!</code> comments are usually used to document modules that occupy a source file.</p> <p>Non-doc comments are interpreted as a form of whitespace.</p> <h3 id="whitespace" class="section-header">3.4 Whitespace</h3> <p>Whitespace is any non-empty string containing only characters that have the <code>Pattern_White_Space</code> Unicode property, namely:</p> <ul> <li>
<code>U+0009</code> (horizontal tab, <code>'\t'</code>)</li> <li>
<code>U+000A</code> (line feed, <code>'\n'</code>)</li> <li>
<code>U+000B</code> (vertical tab)</li> <li>
<code>U+000C</code> (form feed)</li> <li>
<code>U+000D</code> (carriage return, <code>'\r'</code>)</li> <li>
<code>U+0020</code> (space, <code>' '</code>)</li> <li>
<code>U+0085</code> (next line)</li> <li>
<code>U+200E</code> (left-to-right mark)</li> <li>
<code>U+200F</code> (right-to-left mark)</li> <li>
<code>U+2028</code> (line separator)</li> <li>
<code>U+2029</code> (paragraph separator)</li> </ul> <p>Rust is a "free-form" language, meaning that all forms of whitespace serve only to separate <em>tokens</em> in the grammar, and have no semantic significance.</p> <p>A Rust program has identical meaning if each whitespace element is replaced with any other legal whitespace element, such as a single space character.</p> <h3 id="tokens" class="section-header">3.5 Tokens</h3> <p>Tokens are primitive productions in the grammar defined by regular (non-recursive) languages. "Simple" tokens are given in <a href="#string-table-productions">string table production</a> form, and occur in the rest of the grammar as double-quoted strings. Other tokens have exact rules given.</p> <h3 id="literals" class="section-header">3.5.1 Literals</h3> <p>A literal is an expression consisting of a single token, rather than a sequence of tokens, that immediately and directly denotes the value it evaluates to, rather than referring to it by name or some other evaluation rule. A literal is a form of constant expression, so is evaluated (primarily) at compile time.</p> <h4 id="examples" class="section-header">3.5.1.1 Examples</h4> <h5 id="characters-and-strings" class="section-header">3.5.1.1.1 Characters and strings</h5> <table> <thead> <tr> <th></th> <th>Example</th> <th>
<code>#</code> sets</th> <th>Characters</th> <th>Escapes</th> </tr> </thead> <tbody> <tr> <td><a href="#character-literals">Character</a></td> <td><code>'H'</code></td> <td><code>N/A</code></td> <td>All Unicode</td> <td>
<a href="#quote-escapes">Quote</a> &amp; <a href="#byte-escapes">Byte</a> &amp; <a href="#unicode-escapes">Unicode</a>
</td> </tr> <tr> <td><a href="#string-literals">String</a></td> <td><code>"hello"</code></td> <td><code>N/A</code></td> <td>All Unicode</td> <td>
<a href="#quote-escapes">Quote</a> &amp; <a href="#byte-escapes">Byte</a> &amp; <a href="#unicode-escapes">Unicode</a>
</td> </tr> <tr> <td><a href="#raw-string-literals">Raw</a></td> <td><code>r#"hello"#</code></td> <td><code>0...</code></td> <td>All Unicode</td> <td><code>N/A</code></td> </tr> <tr> <td><a href="#byte-literals">Byte</a></td> <td><code>b'H'</code></td> <td><code>N/A</code></td> <td>All ASCII</td> <td>
<a href="#quote-escapes">Quote</a> &amp; <a href="#byte-escapes">Byte</a>
</td> </tr> <tr> <td><a href="#byte-string-literals">Byte string</a></td> <td><code>b"hello"</code></td> <td><code>N/A</code></td> <td>All ASCII</td> <td>
<a href="#quote-escapes">Quote</a> &amp; <a href="#byte-escapes">Byte</a>
</td> </tr> <tr> <td><a href="#raw-byte-string-literals">Raw byte string</a></td> <td><code>br#"hello"#</code></td> <td><code>0...</code></td> <td>All ASCII</td> <td><code>N/A</code></td> </tr> </tbody> </table> <h5 id="byte-escapes" class="section-header">3.5.1.1.2 Byte escapes</h5> <table> <thead> <tr> <th></th> <th>Name</th> </tr> </thead> <tbody> <tr> <td><code>\x7F</code></td> <td>8-bit character code (exactly 2 digits)</td> </tr> <tr> <td><code>\n</code></td> <td>Newline</td> </tr> <tr> <td><code>\r</code></td> <td>Carriage return</td> </tr> <tr> <td><code>\t</code></td> <td>Tab</td> </tr> <tr> <td><code>\\</code></td> <td>Backslash</td> </tr> <tr> <td><code>\0</code></td> <td>Null</td> </tr> </tbody> </table> <h5 id="unicode-escapes" class="section-header">3.5.1.1.3 Unicode escapes</h5> <table> <thead> <tr> <th></th> <th>Name</th> </tr> </thead> <tbody> <tr> <td><code>\u{7FFF}</code></td> <td>24-bit Unicode character code (up to 6 digits)</td> </tr> </tbody> </table> <h5 id="quote-escapes" class="section-header">3.5.1.1.4 Quote escapes</h5> <table> <thead> <tr> <th></th> <th>Name</th> </tr> </thead> <tbody> <tr> <td><code>\'</code></td> <td>Single quote</td> </tr> <tr> <td><code>\"</code></td> <td>Double quote</td> </tr> </tbody> </table> <h5 id="numbers" class="section-header">3.5.1.1.5 Numbers</h5> <table> <thead> <tr> <th>
<a href="#number-literals">Number literals</a><code>*</code>
</th> <th>Example</th> <th>Exponentiation</th> <th>Suffixes</th> </tr> </thead> <tbody> <tr> <td>Decimal integer</td> <td><code>98_222</code></td> <td><code>N/A</code></td> <td>Integer suffixes</td> </tr> <tr> <td>Hex integer</td> <td><code>0xff</code></td> <td><code>N/A</code></td> <td>Integer suffixes</td> </tr> <tr> <td>Octal integer</td> <td><code>0o77</code></td> <td><code>N/A</code></td> <td>Integer suffixes</td> </tr> <tr> <td>Binary integer</td> <td><code>0b1111_0000</code></td> <td><code>N/A</code></td> <td>Integer suffixes</td> </tr> <tr> <td>Floating-point</td> <td><code>123.0E+77</code></td> <td><code>Optional</code></td> <td>Floating-point suffixes</td> </tr> </tbody> </table> <p><code>*</code> All number literals allow <code>_</code> as a visual separator: <code>1_234.0E+18f64</code></p> <h5 id="suffixes" class="section-header">3.5.1.1.6 Suffixes</h5> <table> <thead> <tr> <th>Integer</th> <th>Floating-point</th> </tr> </thead> <tbody> <tr> <td>
<code>u8</code>, <code>i8</code>, <code>u16</code>, <code>i16</code>, <code>u32</code>, <code>i32</code>, <code>u64</code>, <code>i64</code>, <code>isize</code>, <code>usize</code>
</td> <td>
<code>f32</code>, <code>f64</code>
</td> </tr> </tbody> </table> <h4 id="character-and-string-literals" class="section-header">3.5.1.2 Character and string literals</h4> <h5 id="character-literals" class="section-header">3.5.1.2.1 Character literals</h5> <p>A <em>character literal</em> is a single Unicode character enclosed within two <code>U+0027</code> (single-quote) characters, with the exception of <code>U+0027</code> itself, which must be <em>escaped</em> by a preceding <code>U+005C</code> character (<code>\</code>).</p> <h5 id="string-literals" class="section-header">3.5.1.2.2 String literals</h5> <p>A <em>string literal</em> is a sequence of any Unicode characters enclosed within two <code>U+0022</code> (double-quote) characters, with the exception of <code>U+0022</code> itself, which must be <em>escaped</em> by a preceding <code>U+005C</code> character (<code>\</code>).</p> <p>Line-break characters are allowed in string literals. Normally they represent themselves (i.e. no translation), but as a special exception, when an unescaped <code>U+005C</code> character (<code>\</code>) occurs immediately before the newline (<code>U+000A</code>), the <code>U+005C</code> character, the newline, and all whitespace at the beginning of the next line are ignored. Thus <code>a</code> and <code>b</code> are equal:</p> <pre class="rust rust-example-rendered" data-language="rust">
let a = "foobar";
let b = "foo\
         bar";

assert_eq!(a,b);</pre> <h5 id="character-escapes" class="section-header">3.5.1.2.3 Character escapes</h5> <p>Some additional <em>escapes</em> are available in either character or non-raw string literals. An escape starts with a <code>U+005C</code> (<code>\</code>) and continues with one of the following forms:</p> <ul> <li>An <em>8-bit code point escape</em> starts with <code>U+0078</code> (<code>x</code>) and is followed by exactly two <em>hex digits</em>. It denotes the Unicode code point equal to the provided hex value.</li> <li>A <em>24-bit code point escape</em> starts with <code>U+0075</code> (<code>u</code>) and is followed by up to six <em>hex digits</em> surrounded by braces <code>U+007B</code> (<code>{</code>) and <code>U+007D</code> (<code>}</code>). It denotes the Unicode code point equal to the provided hex value.</li> <li>A <em>whitespace escape</em> is one of the characters <code>U+006E</code> (<code>n</code>), <code>U+0072</code> (<code>r</code>), or <code>U+0074</code> (<code>t</code>), denoting the Unicode values <code>U+000A</code> (LF), <code>U+000D</code> (CR) or <code>U+0009</code> (HT) respectively.</li> <li>The <em>null escape</em> is the character <code>U+0030</code> (<code>0</code>) and denotes the Unicode value <code>U+0000</code> (NUL).</li> <li>The <em>backslash escape</em> is the character <code>U+005C</code> (<code>\</code>) which must be escaped in order to denote <em>itself</em>.</li> </ul> <h5 id="raw-string-literals" class="section-header">3.5.1.2.4 Raw string literals</h5> <p>Raw string literals do not process any escapes. They start with the character <code>U+0072</code> (<code>r</code>), followed by zero or more of the character <code>U+0023</code> (<code>#</code>) and a <code>U+0022</code> (double-quote) character. The <em>raw string body</em> can contain any sequence of Unicode characters and is terminated only by another <code>U+0022</code> (double-quote) character, followed by the same number of <code>U+0023</code> (<code>#</code>) characters that preceded the opening <code>U+0022</code> (double-quote) character.</p> <p>All Unicode characters contained in the raw string body represent themselves, the characters <code>U+0022</code> (double-quote) (except when followed by at least as many <code>U+0023</code> (<code>#</code>) characters as were used to start the raw string literal) or <code>U+005C</code> (<code>\</code>) do not have any special meaning.</p> <p>Examples for string literals:</p> <pre class="rust rust-example-rendered" data-language="rust">
"foo"; r"foo";                     // foo
"\"foo\""; r#""foo""#;             // "foo"

"foo #\"# bar";
r##"foo #"# bar"##;                // foo #"# bar

"\x52"; "R"; r"R";                 // R
"\\x52"; r"\x52";                  // \x52</pre> <h4 id="byte-and-byte-string-literals" class="section-header">3.5.1.3 Byte and byte string literals</h4> <h5 id="byte-literals" class="section-header">3.5.1.3.1 Byte literals</h5> <p>A <em>byte literal</em> is a single ASCII character (in the <code>U+0000</code> to <code>U+007F</code> range) or a single <em>escape</em> preceded by the characters <code>U+0062</code> (<code>b</code>) and <code>U+0027</code> (single-quote), and followed by the character <code>U+0027</code>. If the character <code>U+0027</code> is present within the literal, it must be <em>escaped</em> by a preceding <code>U+005C</code> (<code>\</code>) character. It is equivalent to a <code>u8</code> unsigned 8-bit integer <em>number literal</em>.</p> <h5 id="byte-string-literals" class="section-header">3.5.1.3.2 Byte string literals</h5> <p>A non-raw <em>byte string literal</em> is a sequence of ASCII characters and <em>escapes</em>, preceded by the characters <code>U+0062</code> (<code>b</code>) and <code>U+0022</code> (double-quote), and followed by the character <code>U+0022</code>. If the character <code>U+0022</code> is present within the literal, it must be <em>escaped</em> by a preceding <code>U+005C</code> (<code>\</code>) character. Alternatively, a byte string literal can be a <em>raw byte string literal</em>, defined below. A byte string literal of length <code>n</code> is equivalent to a <code>&amp;'static [u8; n]</code> borrowed fixed-sized array of unsigned 8-bit integers.</p> <p>Some additional <em>escapes</em> are available in either byte or non-raw byte string literals. An escape starts with a <code>U+005C</code> (<code>\</code>) and continues with one of the following forms:</p> <ul> <li>A <em>byte escape</em> escape starts with <code>U+0078</code> (<code>x</code>) and is followed by exactly two <em>hex digits</em>. It denotes the byte equal to the provided hex value.</li> <li>A <em>whitespace escape</em> is one of the characters <code>U+006E</code> (<code>n</code>), <code>U+0072</code> (<code>r</code>), or <code>U+0074</code> (<code>t</code>), denoting the bytes values <code>0x0A</code> (ASCII LF), <code>0x0D</code> (ASCII CR) or <code>0x09</code> (ASCII HT) respectively.</li> <li>The <em>null escape</em> is the character <code>U+0030</code> (<code>0</code>) and denotes the byte value <code>0x00</code> (ASCII NUL).</li> <li>The <em>backslash escape</em> is the character <code>U+005C</code> (<code>\</code>) which must be escaped in order to denote its ASCII encoding <code>0x5C</code>.</li> </ul> <h5 id="raw-byte-string-literals" class="section-header">3.5.1.3.3 Raw byte string literals</h5> <p>Raw byte string literals do not process any escapes. They start with the character <code>U+0062</code> (<code>b</code>), followed by <code>U+0072</code> (<code>r</code>), followed by zero or more of the character <code>U+0023</code> (<code>#</code>), and a <code>U+0022</code> (double-quote) character. The <em>raw string body</em> can contain any sequence of ASCII characters and is terminated only by another <code>U+0022</code> (double-quote) character, followed by the same number of <code>U+0023</code> (<code>#</code>) characters that preceded the opening <code>U+0022</code> (double-quote) character. A raw byte string literal can not contain any non-ASCII byte.</p> <p>All characters contained in the raw string body represent their ASCII encoding, the characters <code>U+0022</code> (double-quote) (except when followed by at least as many <code>U+0023</code> (<code>#</code>) characters as were used to start the raw string literal) or <code>U+005C</code> (<code>\</code>) do not have any special meaning.</p> <p>Examples for byte string literals:</p> <pre class="rust rust-example-rendered" data-language="rust">
b"foo"; br"foo";                     // foo
b"\"foo\""; br#""foo""#;             // "foo"

b"foo #\"# bar";
br##"foo #"# bar"##;                 // foo #"# bar

b"\x52"; b"R"; br"R";                // R
b"\\x52"; br"\x52";                  // \x52</pre> <h4 id="number-literals" class="section-header">3.5.1.4 Number literals</h4> <p>A <em>number literal</em> is either an <em>integer literal</em> or a <em>floating-point literal</em>. The grammar for recognizing the two kinds of literals is mixed.</p> <h5 id="integer-literals" class="section-header">3.5.1.4.1 Integer literals</h5> <p>An <em>integer literal</em> has one of four forms:</p> <ul> <li>A <em>decimal literal</em> starts with a <em>decimal digit</em> and continues with any mixture of <em>decimal digits</em> and <em>underscores</em>.</li> <li>A <em>hex literal</em> starts with the character sequence <code>U+0030</code> <code>U+0078</code> (<code>0x</code>) and continues as any mixture of hex digits and underscores.</li> <li>An <em>octal literal</em> starts with the character sequence <code>U+0030</code> <code>U+006F</code> (<code>0o</code>) and continues as any mixture of octal digits and underscores.</li> <li>A <em>binary literal</em> starts with the character sequence <code>U+0030</code> <code>U+0062</code> (<code>0b</code>) and continues as any mixture of binary digits and underscores.</li> </ul> <p>Like any literal, an integer literal may be followed (immediately, without any spaces) by an <em>integer suffix</em>, which forcibly sets the type of the literal. The integer suffix must be the name of one of the integral types: <code>u8</code>, <code>i8</code>, <code>u16</code>, <code>i16</code>, <code>u32</code>, <code>i32</code>, <code>u64</code>, <code>i64</code>, <code>isize</code>, or <code>usize</code>.</p> <p>The type of an <em>unsuffixed</em> integer literal is determined by type inference:</p> <ul> <li><p>If an integer type can be <em>uniquely</em> determined from the surrounding program context, the unsuffixed integer literal has that type.</p></li> <li><p>If the program context under-constrains the type, it defaults to the signed 32-bit integer <code>i32</code>.</p></li> <li><p>If the program context over-constrains the type, it is considered a static type error.</p></li> </ul> <p>Examples of integer literals of various forms:</p> <pre class="rust rust-example-rendered" data-language="rust">
123i32;                            // type i32
123u32;                            // type u32
123_u32;                           // type u32
0xff_u8;                           // type u8
0o70_i16;                          // type i16
0b1111_1111_1001_0000_i32;         // type i32
0usize;                            // type usize</pre> <p>Note that the Rust syntax considers <code>-1i8</code> as an application of the <a href="#unary-operator-expressions">unary minus operator</a> to an integer literal <code>1i8</code>, rather than a single integer literal.</p> <h5 id="floating-point-literals" class="section-header">3.5.1.4.2 Floating-point literals</h5> <p>A <em>floating-point literal</em> has one of two forms:</p> <ul> <li>A <em>decimal literal</em> followed by a period character <code>U+002E</code> (<code>.</code>). This is optionally followed by another decimal literal, with an optional <em>exponent</em>.</li> <li>A single <em>decimal literal</em> followed by an <em>exponent</em>.</li> </ul> <p>Like integer literals, a floating-point literal may be followed by a suffix, so long as the pre-suffix part does not end with <code>U+002E</code> (<code>.</code>). The suffix forcibly sets the type of the literal. There are two valid <em>floating-point suffixes</em>, <code>f32</code> and <code>f64</code> (the 32-bit and 64-bit floating point types), which explicitly determine the type of the literal.</p> <p>The type of an <em>unsuffixed</em> floating-point literal is determined by type inference:</p> <ul> <li><p>If a floating-point type can be <em>uniquely</em> determined from the surrounding program context, the unsuffixed floating-point literal has that type.</p></li> <li><p>If the program context under-constrains the type, it defaults to <code>f64</code>.</p></li> <li><p>If the program context over-constrains the type, it is considered a static type error.</p></li> </ul> <p>Examples of floating-point literals of various forms:</p> <pre class="rust rust-example-rendered" data-language="rust">
123.0f64;        // type f64
0.1f64;          // type f64
0.1f32;          // type f32
12E+99_f64;      // type f64
let x: f64 = 2.; // type f64</pre> <p>This last example is different because it is not possible to use the suffix syntax with a floating point literal ending in a period. <code>2.f64</code> would attempt to call a method named <code>f64</code> on <code>2</code>.</p> <p>The representation semantics of floating-point numbers are described in <a href="#machine-types">"Machine Types"</a>.</p> <h4 id="boolean-literals" class="section-header">3.5.1.5 Boolean literals</h4> <p>The two values of the boolean type are written <code>true</code> and <code>false</code>.</p> <h3 id="symbols" class="section-header">3.5.2 Symbols</h3> <p>Symbols are a general class of printable <a href="#tokens">tokens</a> that play structural roles in a variety of grammar productions. They are a set of remaining miscellaneous printable tokens that do not otherwise appear as <a href="#unary-operator-expressions">unary operators</a>, <a href="#binary-operator-expressions">binary operators</a>, or <a href="https://doc.rust-lang.org/grammar.html#keywords" target="_blank">keywords</a>. They are catalogued in <a href="https://doc.rust-lang.org/grammar.html#symbols" target="_blank">the Symbols section</a> of the Grammar document.</p> <h3 id="paths" class="section-header">3.6 Paths</h3> <p>A <em>path</em> is a sequence of one or more path components <em>logically</em> separated by a namespace qualifier (<code>::</code>). If a path consists of only one component, it may refer to either an <a href="#items">item</a> or a <a href="#variables">variable</a> in a local control scope. If a path has multiple components, it refers to an item.</p> <p>Every item has a <em>canonical path</em> within its crate, but the path naming an item is only meaningful within a given crate. There is no global namespace across crates; an item's canonical path merely identifies it within the crate.</p> <p>Two examples of simple paths consisting of only identifier components:</p> <pre class="rust rust-example-rendered" data-language="rust">
x;
x::y::z;</pre> <p>Path components are usually <a href="#identifiers">identifiers</a>, but they may also include angle-bracket-enclosed lists of type arguments. In <a href="#expressions">expression</a> context, the type argument list is given after a <code>::</code> namespace qualifier in order to disambiguate it from a relational expression involving the less-than symbol (<code>&lt;</code>). In type expression context, the final namespace qualifier is omitted.</p> <p>Two examples of paths with type arguments:</p> <pre class="rust rust-example-rendered" data-language="rust">
type T = HashMap&lt;i32,String&gt;; // Type arguments used in a type expression
let x  = id::&lt;i32&gt;(10);       // Type arguments used in a call expression</pre> <p>Paths can be denoted with various leading qualifiers to change the meaning of how it is resolved:</p> <ul> <li>Paths starting with <code>::</code> are considered to be global paths where the components of the path start being resolved from the crate root. Each identifier in the path must resolve to an item.</li> </ul> <pre class="rust rust-example-rendered" data-language="rust">
mod a {
    pub fn foo() {}
}
mod b {
    pub fn foo() {
        ::a::foo(); // call a's foo function
    }
}</pre> <ul> <li>Paths starting with the keyword <code>super</code> begin resolution relative to the parent module. Each further identifier must resolve to an item.</li> </ul> <pre class="rust rust-example-rendered" data-language="rust">
mod a {
    pub fn foo() {}
}
mod b {
    pub fn foo() {
        super::a::foo(); // call a's foo function
    }
}</pre> <ul> <li>Paths starting with the keyword <code>self</code> begin resolution relative to the current module. Each further identifier must resolve to an item.</li> </ul> <pre class="rust rust-example-rendered" data-language="rust">
fn foo() {}
fn bar() {
    self::foo();
}</pre> <p>Additionally keyword <code>super</code> may be repeated several times after the first <code>super</code> or <code>self</code> to refer to ancestor modules.</p> <pre class="rust rust-example-rendered" data-language="rust">
mod a {
    fn foo() {}

    mod b {
        mod c {
            fn foo() {
                super::super::foo(); // call a's foo function
                self::super::super::foo(); // call a's foo function
            }
        }
    }
}</pre> <h2 id="macros" class="section-header">4 Macros</h2> <p>A number of minor features of Rust are not central enough to have their own syntax, and yet are not implementable as functions. Instead, they are given names, and invoked through a consistent syntax: <code>some_extension!(...)</code>.</p> <p>Users of <code>rustc</code> can define new macros in two ways:</p> <ul> <li>
<a href="../book/macros/">Macros</a> define new syntax in a higher-level, declarative way.</li> <li>
<a href="../book/procedural-macros/">Procedural Macros</a> can be used to implement custom derive.</li> </ul> <p>And one unstable way: <a href="../book/compiler-plugins/">compiler plugins</a>.</p> <h3 id="macros-1" class="section-header">4.1 Macros</h3> <p><code>macro_rules</code> allows users to define syntax extension in a declarative way. We call such extensions "macros by example" or simply "macros".</p> <p>Currently, macros can expand to expressions, statements, items, or patterns.</p> <p>(A <code>sep_token</code> is any token other than <code>*</code> and <code>+</code>. A <code>non_special_token</code> is any token other than a delimiter or <code>$</code>.)</p> <p>The macro expander looks up macro invocations by name, and tries each macro rule in turn. It transcribes the first successful match. Matching and transcription are closely related to each other, and we will describe them together.</p> <h3 id="macro-by-example" class="section-header">4.1.1 Macro By Example</h3> <p>The macro expander matches and transcribes every token that does not begin with a <code>$</code> literally, including delimiters. For parsing reasons, delimiters must be balanced, but they are otherwise not special.</p> <p>In the matcher, <code>$</code> <em>name</em> <code>:</code> <em>designator</em> matches the nonterminal in the Rust syntax named by <em>designator</em>. Valid designators are:</p> <ul> <li>
<code>item</code>: an <a href="#items">item</a>
</li> <li>
<code>block</code>: a <a href="#block-expressions">block</a>
</li> <li>
<code>stmt</code>: a <a href="#statements">statement</a>
</li> <li>
<code>pat</code>: a <a href="#match-expressions">pattern</a>
</li> <li>
<code>expr</code>: an <a href="#expressions">expression</a>
</li> <li>
<code>ty</code>: a <a href="#types">type</a>
</li> <li>
<code>ident</code>: an <a href="#identifiers">identifier</a>
</li> <li>
<code>path</code>: a <a href="#paths">path</a>
</li> <li>
<code>tt</code>: a token tree (a single <a href="#tokens">token</a> or a sequence of token trees surrounded by matching <code>()</code>, <code>[]</code>, or <code>{}</code>)</li> <li>
<code>meta</code>: the contents of an <a href="#attributes">attribute</a>
</li> </ul> <p>In the transcriber, the designator is already known, and so only the name of a matched nonterminal comes after the dollar sign.</p> <p>In both the matcher and transcriber, the Kleene star-like operator indicates repetition. The Kleene star operator consists of <code>$</code> and parentheses, optionally followed by a separator token, followed by <code>*</code> or <code>+</code>. <code>*</code> means zero or more repetitions, <code>+</code> means at least one repetition. The parentheses are not matched or transcribed. On the matcher side, a name is bound to <em>all</em> of the names it matches, in a structure that mimics the structure of the repetition encountered on a successful match. The job of the transcriber is to sort that structure out.</p> <p>The rules for transcription of these repetitions are called "Macro By Example". Essentially, one "layer" of repetition is discharged at a time, and all of them must be discharged by the time a name is transcribed. Therefore, <code>( $( $i:ident ),* ) =&gt; ( $i )</code> is an invalid macro, but <code>( $( $i:ident ),* ) =&gt; ( $( $i:ident ),* )</code> is acceptable (if trivial).</p> <p>When Macro By Example encounters a repetition, it examines all of the <code>$</code> <em>name</em> s that occur in its body. At the "current layer", they all must repeat the same number of times, so <code>( $( $i:ident ),* ; $( $j:ident ),* ) =&gt; ( $( ($i,$j) ),* )</code> is valid if given the argument <code>(a,b,c ; d,e,f)</code>, but not <code>(a,b,c ; d,e)</code>. The repetition walks through the choices at that layer in lockstep, so the former input transcribes to <code>(a,d), (b,e), (c,f)</code>.</p> <p>Nested repetitions are allowed.</p> <h3 id="parsing-limitations" class="section-header">4.1.2 Parsing limitations</h3> <p>The parser used by the macro system is reasonably powerful, but the parsing of Rust syntax is restricted in two ways:</p> <ol> <li>Macro definitions are required to include suitable separators after parsing expressions and other bits of the Rust grammar. This implies that a macro definition like <code>$i:expr [ , ]</code> is not legal, because <code>[</code> could be part of an expression. A macro definition like <code>$i:expr,</code> or <code>$i:expr;</code> would be legal, however, because <code>,</code> and <code>;</code> are legal separators. See <a href="https://github.com/rust-lang/rfcs/blob/master/text/0550-macro-future-proofing.md" target="_blank">RFC 550</a> for more information.</li> <li>The parser must have eliminated all ambiguity by the time it reaches a <code>$</code> <em>name</em> <code>:</code> <em>designator</em>. This requirement most often affects name-designator pairs when they occur at the beginning of, or immediately after, a <code>$(...)*</code>; requiring a distinctive token in front can solve the problem.</li> </ol> <h3 id="procedural-macros" class="section-header">4.2 Procedural Macros</h3> <p>"Procedural macros" are the second way to implement a macro. For now, the only thing they can be used for is to implement derive on your own types. See <a href="../book/procedural-macros/">the book</a> for a tutorial.</p> <p>Procedural macros involve a few different parts of the language and its standard libraries. First is the <code>proc_macro</code> crate, included with Rust, that defines an interface for building a procedural macro. The <code>#[proc_macro_derive(Foo)]</code> attribute is used to mark the deriving function. This function must have the type signature:</p> <pre class="rust rust-example-rendered" data-language="rust">
use proc_macro::TokenStream;

#[proc_macro_derive(Hello)]
pub fn hello_world(input: TokenStream) -&gt; TokenStream</pre> <p>Finally, procedural macros must be in their own crate, with the <code>proc-macro</code> crate type.</p> <h2 id="crates-and-source-files" class="section-header">5 Crates and source files</h2> <p>Although Rust, like any other language, can be implemented by an interpreter as well as a compiler, the only existing implementation is a compiler, and the language has always been designed to be compiled. For these reasons, this section assumes a compiler.</p> <p>Rust's semantics obey a <em>phase distinction</em> between compile-time and run-time.<sup id="fnref3"><a href="#fn3" rel="footnote">3</a></sup> Semantic rules that have a <em>static interpretation</em> govern the success or failure of compilation, while semantic rules that have a <em>dynamic interpretation</em> govern the behavior of the program at run-time.</p> <p>The compilation model centers on artifacts called <em>crates</em>. Each compilation processes a single crate in source form, and if successful, produces a single crate in binary form: either an executable or some sort of library.<sup id="fnref4"><a href="#fn4" rel="footnote">4</a></sup></p> <p>A <em>crate</em> is a unit of compilation and linking, as well as versioning, distribution and runtime loading. A crate contains a <em>tree</em> of nested <a href="#modules">module</a> scopes. The top level of this tree is a module that is anonymous (from the point of view of paths within the module) and any item within a crate has a canonical <a href="#paths">module path</a> denoting its location within the crate's module tree.</p> <p>The Rust compiler is always invoked with a single source file as input, and always produces a single output crate. The processing of that source file may result in other source files being loaded as modules. Source files have the extension <code>.rs</code>.</p> <p>A Rust source file describes a module, the name and location of which — in the module tree of the current crate — are defined from outside the source file: either by an explicit <code>mod_item</code> in a referencing source file, or by the name of the crate itself. Every source file is a module, but not every module needs its own source file: <a href="#modules">module definitions</a> can be nested within one file.</p> <p>Each source file contains a sequence of zero or more <code>item</code> definitions, and may optionally begin with any number of <a href="#items-and-attributes">attributes</a> that apply to the containing module, most of which influence the behavior of the compiler. The anonymous crate module can have additional attributes that apply to the crate as a whole.</p> <pre class="rust rust-example-rendered" data-language="rust">
// Specify the crate name.
#![crate_name = "projx"]

// Specify the type of output artifact.
#![crate_type = "lib"]

// Turn on a warning.
// This can be done in any module, not just the anonymous crate module.
#![warn(non_camel_case_types)]</pre> <p>A crate that contains a <code>main</code> function can be compiled to an executable. If a <code>main</code> function is present, its return type must be <code>()</code> ("<a href="#tuple-types">unit</a>") and it must take no arguments.</p> <h2 id="items-and-attributes" class="section-header">6 Items and attributes</h2> <p>Crates contain <a href="#items">items</a>, each of which may have some number of <a href="#attributes">attributes</a> attached to it.</p> <h3 id="items" class="section-header">6.1 Items</h3> <p>An <em>item</em> is a component of a crate. Items are organized within a crate by a nested set of <a href="#modules">modules</a>. Every crate has a single "outermost" anonymous module; all further items within the crate have <a href="#paths">paths</a> within the module tree of the crate.</p> <p>Items are entirely determined at compile-time, generally remain fixed during execution, and may reside in read-only memory.</p> <p>There are several kinds of item:</p> <ul> <li><a href="#extern-crate-declarations"><code>extern crate</code> declarations</a></li> <li><a href="#use-declarations"><code>use</code> declarations</a></li> <li><a href="#modules">modules</a></li> <li><a href="#functions">function definitions</a></li> <li><a href="#external-blocks"><code>extern</code> blocks</a></li> <li><a href="https://doc.rust-lang.org/grammar.html#type-definitions" target="_blank">type definitions</a></li> <li><a href="#structs">struct definitions</a></li> <li><a href="#enumerations">enumeration definitions</a></li> <li><a href="#constant-items">constant items</a></li> <li><a href="#static-items">static items</a></li> <li><a href="#traits">trait definitions</a></li> <li><a href="#implementations">implementations</a></li> </ul> <p>Some items form an implicit scope for the declaration of sub-items. In other words, within a function or module, declarations of items can (in many cases) be mixed with the statements, control blocks, and similar artifacts that otherwise compose the item body. The meaning of these scoped items is the same as if the item was declared outside the scope — it is still a static item — except that the item's <em>path name</em> within the module namespace is qualified by the name of the enclosing item, or is private to the enclosing item (in the case of functions). The grammar specifies the exact locations in which sub-item declarations may appear.</p> <h3 id="type-parameters" class="section-header">6.1.1 Type Parameters</h3> <p>All items except modules, constants and statics may be <em>parameterized</em> by type. Type parameters are given as a comma-separated list of identifiers enclosed in angle brackets (<code>&lt;...&gt;</code>), after the name of the item and before its definition. The type parameters of an item are considered "part of the name", not part of the type of the item. A referencing <a href="#paths">path</a> must (in principle) provide type arguments as a list of comma-separated types enclosed within angle brackets, in order to refer to the type-parameterized item. In practice, the type-inference system can usually infer such argument types from context. There are no general type-parametric types, only type-parametric items. That is, Rust has no notion of type abstraction: there are no higher-ranked (or "forall") types abstracted over other types, though higher-ranked types do exist for lifetimes.</p> <h3 id="modules" class="section-header">6.1.2 Modules</h3> <p>A module is a container for zero or more <a href="#items">items</a>.</p> <p>A <em>module item</em> is a module, surrounded in braces, named, and prefixed with the keyword <code>mod</code>. A module item introduces a new, named module into the tree of modules making up a crate. Modules can nest arbitrarily.</p> <p>An example of a module:</p> <pre class="rust rust-example-rendered" data-language="rust">
mod math {
    type Complex = (f64, f64);
    fn sin(f: f64) -&gt; f64 {
        /* ... */
    }
    fn cos(f: f64) -&gt; f64 {
        /* ... */
    }
    fn tan(f: f64) -&gt; f64 {
        /* ... */
    }
}</pre> <p>Modules and types share the same namespace. Declaring a named type with the same name as a module in scope is forbidden: that is, a type definition, trait, struct, enumeration, or type parameter can't shadow the name of a module in scope, or vice versa.</p> <p>A module without a body is loaded from an external file, by default with the same name as the module, plus the <code>.rs</code> extension. When a nested submodule is loaded from an external file, it is loaded from a subdirectory path that mirrors the module hierarchy.</p> <pre class="rust rust-example-rendered" data-language="rust">
// Load the `vec` module from `vec.rs`
mod vec;

mod thread {
    // Load the `local_data` module from `thread/local_data.rs`
    // or `thread/local_data/mod.rs`.
    mod local_data;
}</pre> <p>The directories and files used for loading external file modules can be influenced with the <code>path</code> attribute.</p> <pre class="rust rust-example-rendered" data-language="rust">
#[path = "thread_files"]
mod thread {
    // Load the `local_data` module from `thread_files/tls.rs`
    #[path = "tls.rs"]
    mod local_data;
}</pre> <h4 id="extern-crate-declarations" class="section-header">6.1.2.1 Extern crate declarations</h4> <p>An <em><code>extern crate</code> declaration</em> specifies a dependency on an external crate. The external crate is then bound into the declaring scope as the <code>ident</code> provided in the <code>extern_crate_decl</code>.</p> <p>The external crate is resolved to a specific <code>soname</code> at compile time, and a runtime linkage requirement to that <code>soname</code> is passed to the linker for loading at runtime. The <code>soname</code> is resolved at compile time by scanning the compiler's library path and matching the optional <code>crateid</code> provided against the <code>crateid</code> attributes that were declared on the external crate when it was compiled. If no <code>crateid</code> is provided, a default <code>name</code> attribute is assumed, equal to the <code>ident</code> given in the <code>extern_crate_decl</code>.</p> <p>Three examples of <code>extern crate</code> declarations:</p> <pre class="rust rust-example-rendered" data-language="rust">
extern crate pcre;

extern crate std; // equivalent to: extern crate std as std;

extern crate std as ruststd; // linking to 'std' under another name</pre> <p>When naming Rust crates, hyphens are disallowed. However, Cargo packages may make use of them. In such case, when <code>Cargo.toml</code> doesn't specify a crate name, Cargo will transparently replace <code>-</code> with <code>_</code> (Refer to <a href="https://github.com/rust-lang/rfcs/blob/master/text/0940-hyphens-considered-harmful.md" target="_blank">RFC 940</a> for more details).</p> <p>Here is an example:</p> <pre class="rust rust-example-rendered" data-language="rust">
// Importing the Cargo package hello-world
extern crate hello_world; // hyphen replaced with an underscore</pre> <h4 id="use-declarations" class="section-header">6.1.2.2 Use declarations</h4> <p>A <em>use declaration</em> creates one or more local name bindings synonymous with some other <a href="#paths">path</a>. Usually a <code>use</code> declaration is used to shorten the path required to refer to a module item. These declarations may appear in <a href="#modules">modules</a> and <a href="https://doc.rust-lang.org/grammar.html#block-expressions" target="_blank">blocks</a>, usually at the top.</p> <blockquote> <p><strong>Note</strong>: Unlike in many languages, <code>use</code> declarations in Rust do <em>not</em> declare linkage dependency with external crates. Rather, <a href="#extern-crate-declarations"><code>extern crate</code> declarations</a> declare linkage dependencies.</p> </blockquote> <p>Use declarations support a number of convenient shortcuts:</p> <ul> <li>Rebinding the target name as a new local name, using the syntax <code>use p::q::r as x;</code>
</li> <li>Simultaneously binding a list of paths differing only in their final element, using the glob-like brace syntax <code>use a::b::{c,d,e,f};</code>
</li> <li>Binding all paths matching a given prefix, using the asterisk wildcard syntax <code>use a::b::*;</code>
</li> <li>Simultaneously binding a list of paths differing only in their final element and their immediate parent module, using the <code>self</code> keyword, such as <code>use a::b::{self, c, d};</code>
</li> </ul> <p>An example of <code>use</code> declarations:</p> <pre class="rust rust-example-rendered" data-language="rust">
use std::option::Option::{Some, None};
use std::collections::hash_map::{self, HashMap};

fn foo&lt;T&gt;(_: T){}
fn bar(map1: HashMap&lt;String, usize&gt;, map2: hash_map::HashMap&lt;String, usize&gt;){}

fn main() {
    // Equivalent to 'foo(vec![std::option::Option::Some(1.0f64),
    // std::option::Option::None]);'
    foo(vec![Some(1.0f64), None]);

    // Both `hash_map` and `HashMap` are in scope.
    let map1 = HashMap::new();
    let map2 = hash_map::HashMap::new();
    bar(map1, map2);
}</pre> <p>Like items, <code>use</code> declarations are private to the containing module, by default. Also like items, a <code>use</code> declaration can be public, if qualified by the <code>pub</code> keyword. Such a <code>use</code> declaration serves to <em>re-export</em> a name. A public <code>use</code> declaration can therefore <em>redirect</em> some public name to a different target definition: even a definition with a private canonical path, inside a different module. If a sequence of such redirections form a cycle or cannot be resolved unambiguously, they represent a compile-time error.</p> <p>An example of re-exporting:</p> <pre class="rust rust-example-rendered" data-language="rust">
mod quux {
    pub use quux::foo::{bar, baz};

    pub mod foo {
        pub fn bar() { }
        pub fn baz() { }
    }
}</pre> <p>In this example, the module <code>quux</code> re-exports two public names defined in <code>foo</code>.</p> <p>Also note that the paths contained in <code>use</code> items are relative to the crate root. So, in the previous example, the <code>use</code> refers to <code>quux::foo::{bar, baz}</code>, and not simply to <code>foo::{bar, baz}</code>. This also means that top-level module declarations should be at the crate root if direct usage of the declared modules within <code>use</code> items is desired. It is also possible to use <code>self</code> and <code>super</code> at the beginning of a <code>use</code> item to refer to the current and direct parent modules respectively. All rules regarding accessing declared modules in <code>use</code> declarations apply to both module declarations and <code>extern crate</code> declarations.</p> <p>An example of what will and will not work for <code>use</code> items:</p> <pre class="rust rust-example-rendered" data-language="rust">
use foo::baz::foobaz;    // good: foo is at the root of the crate

mod foo {

    mod example {
        pub mod iter {}
    }

    use foo::example::iter; // good: foo is at crate root
//  use example::iter;      // bad:  example is not at the crate root
    use self::baz::foobaz;  // good: self refers to module 'foo'
    use foo::bar::foobar;   // good: foo is at crate root

    pub mod bar {
        pub fn foobar() { }
    }

    pub mod baz {
        use super::bar::foobar; // good: super refers to module 'foo'
        pub fn foobaz() { }
    }
}

fn main() {}</pre> <h3 id="functions" class="section-header">6.1.3 Functions</h3> <p>A <em>function item</em> defines a sequence of <a href="#statements">statements</a> and a final <a href="#expressions">expression</a>, along with a name and a set of parameters. Other than a name, all these are optional. Functions are declared with the keyword <code>fn</code>. Functions may declare a set of <em>input</em> <a href="#variables"><em>variables</em></a> as parameters, through which the caller passes arguments into the function, and the <em>output</em> <a href="#types"><em>type</em></a> of the value the function will return to its caller on completion.</p> <p>A function may also be copied into a first-class <em>value</em>, in which case the value has the corresponding <a href="#function-types"><em>function type</em></a>, and can be used otherwise exactly as a function item (with a minor additional cost of calling the function indirectly).</p> <p>Every control path in a function logically ends with a <code>return</code> expression or a diverging expression. If the outermost block of a function has a value-producing expression in its final-expression position, that expression is interpreted as an implicit <code>return</code> expression applied to the final-expression.</p> <p>An example of a function:</p> <pre class="rust rust-example-rendered" data-language="rust">
fn add(x: i32, y: i32) -&gt; i32 {
    x + y
}</pre> <p>As with <code>let</code> bindings, function arguments are irrefutable patterns, so any pattern that is valid in a let binding is also valid as an argument.</p> <pre class="rust rust-example-rendered" data-language="rust">
fn first((value, _): (i32, i32)) -&gt; i32 { value }</pre> <h4 id="generic-functions" class="section-header">6.1.3.1 Generic functions</h4> <p>A <em>generic function</em> allows one or more <em>parameterized types</em> to appear in its signature. Each type parameter must be explicitly declared in an angle-bracket-enclosed and comma-separated list, following the function name.</p> <pre class="rust rust-example-rendered" data-language="rust">
// foo is generic over A and B

fn foo&lt;A, B&gt;(x: A, y: B) {</pre> <p>Inside the function signature and body, the name of the type parameter can be used as a type name. <a href="#traits">Trait</a> bounds can be specified for type parameters to allow methods with that trait to be called on values of that type. This is specified using the <code>where</code> syntax:</p> <pre class="rust rust-example-rendered" data-language="rust">
fn foo&lt;T&gt;(x: T) where T: Debug {</pre> <p>When a generic function is referenced, its type is instantiated based on the context of the reference. For example, calling the <code>foo</code> function here:</p> <pre class="rust rust-example-rendered" data-language="rust">
use std::fmt::Debug;

fn foo&lt;T&gt;(x: &amp;[T]) where T: Debug {
    // details elided
}

foo(&amp;[1, 2]);</pre> <p>will instantiate type parameter <code>T</code> with <code>i32</code>.</p> <p>The type parameters can also be explicitly supplied in a trailing <a href="#paths">path</a> component after the function name. This might be necessary if there is not sufficient context to determine the type parameters. For example, <code>mem::size_of::&lt;u32&gt;() == 4</code>.</p> <h4 id="diverging-functions" class="section-header">6.1.3.2 Diverging functions</h4> <p>A special kind of function can be declared with a <code>!</code> character where the output type would normally be. For example:</p> <pre class="rust rust-example-rendered" data-language="rust">
fn my_err(s: &amp;str) -&gt; ! {
    println!("{}", s);
    panic!();
}</pre> <p>We call such functions "diverging" because they never return a value to the caller. Every control path in a diverging function must end with a <code>panic!()</code> or a call to another diverging function on every control path. The <code>!</code> annotation does <em>not</em> denote a type.</p> <p>It might be necessary to declare a diverging function because as mentioned previously, the typechecker checks that every control path in a function ends with a <a href="#return-expressions"><code>return</code></a> or diverging expression. So, if <code>my_err</code> were declared without the <code>!</code> annotation, the following code would not typecheck:</p> <pre class="rust rust-example-rendered" data-language="rust">

fn f(i: i32) -&gt; i32 {
    if i == 42 {
        return 42;
    }
    else {
        my_err("Bad number!");
    }
}</pre> <p>This will not compile without the <code>!</code> annotation on <code>my_err</code>, since the <code>else</code> branch of the conditional in <code>f</code> does not return an <code>i32</code>, as required by the signature of <code>f</code>. Adding the <code>!</code> annotation to <code>my_err</code> informs the typechecker that, should control ever enter <code>my_err</code>, no further type judgments about <code>f</code> need to hold, since control will never resume in any context that relies on those judgments. Thus the return type on <code>f</code> only needs to reflect the <code>if</code> branch of the conditional.</p> <h4 id="extern-functions" class="section-header">6.1.3.3 Extern functions</h4> <p>Extern functions are part of Rust's foreign function interface, providing the opposite functionality to <a href="#external-blocks">external blocks</a>. Whereas external blocks allow Rust code to call foreign code, extern functions with bodies defined in Rust code <em>can be called by foreign code</em>. They are defined in the same way as any other Rust function, except that they have the <code>extern</code> modifier.</p> <pre class="rust rust-example-rendered" data-language="rust">
// Declares an extern fn, the ABI defaults to "C"
extern fn new_i32() -&gt; i32 { 0 }

// Declares an extern fn with "stdcall" ABI
extern "stdcall" fn new_i32_stdcall() -&gt; i32 { 0 }</pre> <p>Unlike normal functions, extern fns have type <code>extern "ABI" fn()</code>. This is the same type as the functions declared in an extern block.</p> <pre class="rust rust-example-rendered" data-language="rust">
let fptr: extern "C" fn() -&gt; i32 = new_i32;</pre> <p>Extern functions may be called directly from Rust code as Rust uses large, contiguous stack segments like C.</p> <h3 id="type-aliases" class="section-header">6.1.4 Type aliases</h3> <p>A <em>type alias</em> defines a new name for an existing <a href="#types">type</a>. Type aliases are declared with the keyword <code>type</code>. Every value has a single, specific type, but may implement several different traits, or be compatible with several different type constraints.</p> <p>For example, the following defines the type <code>Point</code> as a synonym for the type <code>(u8, u8)</code>, the type of pairs of unsigned 8 bit integers:</p> <pre class="rust rust-example-rendered" data-language="rust">
type Point = (u8, u8);
let p: Point = (41, 68);</pre> <p>Currently a type alias to an enum type cannot be used to qualify the constructors:</p> <pre class="rust rust-example-rendered" data-language="rust">
enum E { A }
type F = E;
let _: F = E::A;  // OK
// let _: F = F::A;  // Doesn't work</pre> <h3 id="structs" class="section-header">6.1.5 Structs</h3> <p>A <em>struct</em> is a nominal <a href="#struct-types">struct type</a> defined with the keyword <code>struct</code>.</p> <p>An example of a <code>struct</code> item and its use:</p> <pre class="rust rust-example-rendered" data-language="rust">
struct Point {x: i32, y: i32}
let p = Point {x: 10, y: 11};
let px: i32 = p.x;</pre> <p>A <em>tuple struct</em> is a nominal <a href="#tuple-types">tuple type</a>, also defined with the keyword <code>struct</code>. For example:</p> <pre class="rust rust-example-rendered" data-language="rust">
struct Point(i32, i32);
let p = Point(10, 11);
let px: i32 = match p { Point(x, _) =&gt; x };</pre> <p>A <em>unit-like struct</em> is a struct without any fields, defined by leaving off the list of fields entirely. Such a struct implicitly defines a constant of its type with the same name. For example:</p> <pre class="rust rust-example-rendered" data-language="rust">
struct Cookie;
let c = [Cookie, Cookie {}, Cookie, Cookie {}];</pre> <p>is equivalent to</p> <pre class="rust rust-example-rendered" data-language="rust">
struct Cookie {}
const Cookie: Cookie = Cookie {};
let c = [Cookie, Cookie {}, Cookie, Cookie {}];</pre> <p>The precise memory layout of a struct is not specified. One can specify a particular layout using the <a href="#ffi-attributes"><code>repr</code> attribute</a>.</p> <h3 id="enumerations" class="section-header">6.1.6 Enumerations</h3> <p>An <em>enumeration</em> is a simultaneous definition of a nominal <a href="#enumerated-types">enumerated type</a> as well as a set of <em>constructors</em>, that can be used to create or pattern-match values of the corresponding enumerated type.</p> <p>Enumerations are declared with the keyword <code>enum</code>.</p> <p>An example of an <code>enum</code> item and its use:</p> <pre class="rust rust-example-rendered" data-language="rust">
enum Animal {
    Dog,
    Cat,
}

let mut a: Animal = Animal::Dog;
a = Animal::Cat;</pre> <p>Enumeration constructors can have either named or unnamed fields:</p> <pre class="rust rust-example-rendered" data-language="rust">
enum Animal {
    Dog (String, f64),
    Cat { name: String, weight: f64 },
}

let mut a: Animal = Animal::Dog("Cocoa".to_string(), 37.2);
a = Animal::Cat { name: "Spotty".to_string(), weight: 2.7 };</pre> <p>In this example, <code>Cat</code> is a <em>struct-like enum variant</em>, whereas <code>Dog</code> is simply called an enum variant.</p> <p>Each enum value has a <em>discriminant</em> which is an integer associated to it. You can specify it explicitly:</p> <pre class="rust rust-example-rendered" data-language="rust">
enum Foo {
    Bar = 123,
}</pre> <p>The right hand side of the specification is interpreted as an <code>isize</code> value, but the compiler is allowed to use a smaller type in the actual memory layout. The <a href="#ffi-attributes"><code>repr</code> attribute</a> can be added in order to change the type of the right hand side and specify the memory layout.</p> <p>If a discriminant isn't specified, they start at zero, and add one for each variant, in order.</p> <p>You can cast an enum to get its discriminant:</p> <pre class="rust rust-example-rendered" data-language="rust">
let x = Foo::Bar as u32; // x is now 123u32</pre> <p>This only works as long as none of the variants have data attached. If it were <code>Bar(i32)</code>, this is disallowed.</p> <h3 id="constant-items" class="section-header">6.1.7 Constant items</h3> <p>A <em>constant item</em> is a named <em>constant value</em> which is not associated with a specific memory location in the program. Constants are essentially inlined wherever they are used, meaning that they are copied directly into the relevant context when used. References to the same constant are not necessarily guaranteed to refer to the same memory address.</p> <p>Constant values must not have destructors, and otherwise permit most forms of data. Constants may refer to the address of other constants, in which case the address will have the <code>static</code> lifetime. The compiler is, however, still at liberty to translate the constant many times, so the address referred to may not be stable.</p> <p>Constants must be explicitly typed. The type may be <code>bool</code>, <code>char</code>, a number, or a type derived from those primitive types. The derived types are references with the <code>static</code> lifetime, fixed-size arrays, tuples, enum variants, and structs.</p> <pre class="rust rust-example-rendered" data-language="rust">
const BIT1: u32 = 1 &lt;&lt; 0;
const BIT2: u32 = 1 &lt;&lt; 1;

const BITS: [u32; 2] = [BIT1, BIT2];
const STRING: &amp;'static str = "bitstring";

struct BitsNStrings&lt;'a&gt; {
    mybits: [u32; 2],
    mystring: &amp;'a str,
}

const BITS_N_STRINGS: BitsNStrings&lt;'static&gt; = BitsNStrings {
    mybits: BITS,
    mystring: STRING,
};</pre> <h3 id="static-items" class="section-header">6.1.8 Static items</h3> <p>A <em>static item</em> is similar to a <em>constant</em>, except that it represents a precise memory location in the program. A static is never "inlined" at the usage site, and all references to it refer to the same memory location. Static items have the <code>static</code> lifetime, which outlives all other lifetimes in a Rust program. Static items may be placed in read-only memory if they do not contain any interior mutability.</p> <p>Statics may contain interior mutability through the <code>UnsafeCell</code> language item. All access to a static is safe, but there are a number of restrictions on statics:</p> <ul> <li>Statics may not contain any destructors.</li> <li>The types of static values must ascribe to <code>Sync</code> to allow thread-safe access.</li> <li>Statics may not refer to other statics by value, only by reference.</li> <li>Constants cannot refer to statics.</li> </ul> <p>Constants should in general be preferred over statics, unless large amounts of data are being stored, or single-address and mutability properties are required.</p> <h4 id="mutable-statics" class="section-header">6.1.8.1 Mutable statics</h4> <p>If a static item is declared with the <code>mut</code> keyword, then it is allowed to be modified by the program. One of Rust's goals is to make concurrency bugs hard to run into, and this is obviously a very large source of race conditions or other bugs. For this reason, an <code>unsafe</code> block is required when either reading or writing a mutable static variable. Care should be taken to ensure that modifications to a mutable static are safe with respect to other threads running in the same process.</p> <p>Mutable statics are still very useful, however. They can be used with C libraries and can also be bound from C libraries (in an <code>extern</code> block).</p> <pre class="rust rust-example-rendered" data-language="rust">

static mut LEVELS: u32 = 0;

// This violates the idea of no shared state, and this doesn't internally
// protect against races, so this function is `unsafe`
unsafe fn bump_levels_unsafe1() -&gt; u32 {
    let ret = LEVELS;
    LEVELS += 1;
    return ret;
}

// Assuming that we have an atomic_add function which returns the old value,
// this function is "safe" but the meaning of the return value may not be what
// callers expect, so it's still marked as `unsafe`
unsafe fn bump_levels_unsafe2() -&gt; u32 {
    return atomic_add(&amp;mut LEVELS, 1);
}</pre> <p>Mutable statics have the same restrictions as normal statics, except that the type of the value is not required to ascribe to <code>Sync</code>.</p> <h3 id="traits" class="section-header">6.1.9 Traits</h3> <p>A <em>trait</em> describes an abstract interface that types can implement. This interface consists of associated items, which come in three varieties:</p> <ul> <li>functions</li> <li>constants</li> <li>types</li> </ul> <p>Associated functions whose first parameter is named <code>self</code> are called methods and may be invoked using <code>.</code> notation (e.g., <code>x.foo()</code>).</p> <p>All traits define an implicit type parameter <code>Self</code> that refers to "the type that is implementing this interface". Traits may also contain additional type parameters. These type parameters (including <code>Self</code>) may be constrained by other traits and so forth as usual.</p> <p>Trait bounds on <code>Self</code> are considered "supertraits". These are required to be acyclic. Supertraits are somewhat different from other constraints in that they affect what methods are available in the vtable when the trait is used as a <a href="#trait-objects">trait object</a>.</p> <p>Traits are implemented for specific types through separate <a href="#implementations">implementations</a>.</p> <p>Consider the following trait:</p> <pre class="rust rust-example-rendered" data-language="rust">
trait Shape {
    fn draw(&amp;self, Surface);
    fn bounding_box(&amp;self) -&gt; BoundingBox;
}</pre> <p>This defines a trait with two methods. All values that have <a href="#implementations">implementations</a> of this trait in scope can have their <code>draw</code> and <code>bounding_box</code> methods called, using <code>value.bounding_box()</code> <a href="#method-call-expressions">syntax</a>.</p> <p>Traits can include default implementations of methods, as in:</p> <pre class="rust rust-example-rendered" data-language="rust">
trait Foo {
    fn bar(&amp;self);
    fn baz(&amp;self) { println!("We called baz."); }
}</pre> <p>Here the <code>baz</code> method has a default implementation, so types that implement <code>Foo</code> need only implement <code>bar</code>. It is also possible for implementing types to override a method that has a default implementation.</p> <p>Type parameters can be specified for a trait to make it generic. These appear after the trait name, using the same syntax used in <a href="#generic-functions">generic functions</a>.</p> <pre class="rust rust-example-rendered" data-language="rust">
trait Seq&lt;T&gt; {
    fn len(&amp;self) -&gt; u32;
    fn elt_at(&amp;self, n: u32) -&gt; T;
    fn iter&lt;F&gt;(&amp;self, F) where F: Fn(T);
}</pre> <p>It is also possible to define associated types for a trait. Consider the following example of a <code>Container</code> trait. Notice how the type is available for use in the method signatures:</p> <pre class="rust rust-example-rendered" data-language="rust">
trait Container {
    type E;
    fn empty() -&gt; Self;
    fn insert(&amp;mut self, Self::E);
}</pre> <p>In order for a type to implement this trait, it must not only provide implementations for every method, but it must specify the type <code>E</code>. Here's an implementation of <code>Container</code> for the standard library type <code>Vec</code>:</p> <pre class="rust rust-example-rendered" data-language="rust">
impl&lt;T&gt; Container for Vec&lt;T&gt; {
    type E = T;
    fn empty() -&gt; Vec&lt;T&gt; { Vec::new() }
    fn insert(&amp;mut self, x: T) { self.push(x); }
}</pre> <p>Generic functions may use traits as <em>bounds</em> on their type parameters. This will have two effects:</p> <ul> <li>Only types that have the trait may instantiate the parameter.</li> <li>Within the generic function, the methods of the trait can be called on values that have the parameter's type.</li> </ul> <p>For example:</p> <pre class="rust rust-example-rendered" data-language="rust">
fn draw_twice&lt;T: Shape&gt;(surface: Surface, sh: T) {
    sh.draw(surface);
    sh.draw(surface);
}</pre> <p>Traits also define a <a href="#trait-objects">trait object</a> with the same name as the trait. Values of this type are created by coercing from a pointer of some specific type to a pointer of trait type. For example, <code>&amp;T</code> could be coerced to <code>&amp;Shape</code> if <code>T: Shape</code> holds (and similarly for <code>Box&lt;T&gt;</code>). This coercion can either be implicit or <a href="#type-cast-expressions">explicit</a>. Here is an example of an explicit coercion:</p> <pre class="rust rust-example-rendered" data-language="rust">
trait Shape { }
impl Shape for i32 { }
let mycircle = 0i32;
let myshape: Box&lt;Shape&gt; = Box::new(mycircle) as Box&lt;Shape&gt;;</pre> <p>The resulting value is a box containing the value that was cast, along with information that identifies the methods of the implementation that was used. Values with a trait type can have <a href="#method-call-expressions">methods called</a> on them, for any method in the trait, and can be used to instantiate type parameters that are bounded by the trait.</p> <p>Trait methods may be static, which means that they lack a <code>self</code> argument. This means that they can only be called with function call syntax (<code>f(x)</code>) and not method call syntax (<code>obj.f()</code>). The way to refer to the name of a static method is to qualify it with the trait name, treating the trait name like a module. For example:</p> <pre class="rust rust-example-rendered" data-language="rust">
trait Num {
    fn from_i32(n: i32) -&gt; Self;
}
impl Num for f64 {
    fn from_i32(n: i32) -&gt; f64 { n as f64 }
}
let x: f64 = Num::from_i32(42);</pre> <p>Traits may inherit from other traits. Consider the following example:</p> <pre class="rust rust-example-rendered" data-language="rust">
trait Shape { fn area(&amp;self) -&gt; f64; }
trait Circle : Shape { fn radius(&amp;self) -&gt; f64; }</pre> <p>The syntax <code>Circle : Shape</code> means that types that implement <code>Circle</code> must also have an implementation for <code>Shape</code>. Multiple supertraits are separated by <code>+</code>, <code>trait Circle : Shape + PartialEq { }</code>. In an implementation of <code>Circle</code> for a given type <code>T</code>, methods can refer to <code>Shape</code> methods, since the typechecker checks that any type with an implementation of <code>Circle</code> also has an implementation of <code>Shape</code>:</p> <pre class="rust rust-example-rendered" data-language="rust">
struct Foo;

trait Shape { fn area(&amp;self) -&gt; f64; }
trait Circle : Shape { fn radius(&amp;self) -&gt; f64; }
impl Shape for Foo {
    fn area(&amp;self) -&gt; f64 {
        0.0
    }
}
impl Circle for Foo {
    fn radius(&amp;self) -&gt; f64 {
        println!("calling area: {}", self.area());

        0.0
    }
}

let c = Foo;
c.radius();</pre> <p>In type-parameterized functions, methods of the supertrait may be called on values of subtrait-bound type parameters. Referring to the previous example of <code>trait Circle : Shape</code>:</p> <pre class="rust rust-example-rendered" data-language="rust">
fn radius_times_area&lt;T: Circle&gt;(c: T) -&gt; f64 {
    // `c` is both a Circle and a Shape
    c.radius() * c.area()
}</pre> <p>Likewise, supertrait methods may also be called on trait objects.</p> <pre class="rust rust-example-rendered" data-language="rust">
let mycircle = Box::new(mycircle) as Box&lt;Circle&gt;;
let nonsense = mycircle.radius() * mycircle.area();</pre> <h3 id="implementations" class="section-header">6.1.10 Implementations</h3> <p>An <em>implementation</em> is an item that implements a <a href="#traits">trait</a> for a specific type.</p> <p>Implementations are defined with the keyword <code>impl</code>.</p> <pre class="rust rust-example-rendered" data-language="rust">
struct Circle {
    radius: f64,
    center: Point,
}

impl Copy for Circle {}

impl Clone for Circle {
    fn clone(&amp;self) -&gt; Circle { *self }
}

impl Shape for Circle {
    fn draw(&amp;self, s: Surface) { do_draw_circle(s, *self); }
    fn bounding_box(&amp;self) -&gt; BoundingBox {
        let r = self.radius;
        BoundingBox {
            x: self.center.x - r,
            y: self.center.y - r,
            width: 2.0 * r,
            height: 2.0 * r,
        }
    }
}</pre> <p>It is possible to define an implementation without referring to a trait. The methods in such an implementation can only be used as direct calls on the values of the type that the implementation targets. In such an implementation, the trait type and <code>for</code> after <code>impl</code> are omitted. Such implementations are limited to nominal types (enums, structs, trait objects), and the implementation must appear in the same crate as the <code>self</code> type:</p> <pre class="rust rust-example-rendered" data-language="rust">
struct Point {x: i32, y: i32}

impl Point {
    fn log(&amp;self) {
        println!("Point is at ({}, {})", self.x, self.y);
    }
}

let my_point = Point {x: 10, y:11};
my_point.log();</pre> <p>When a trait <em>is</em> specified in an <code>impl</code>, all methods declared as part of the trait must be implemented, with matching types and type parameter counts.</p> <p>An implementation can take type parameters, which can be different from the type parameters taken by the trait it implements. Implementation parameters are written after the <code>impl</code> keyword.</p> <pre class="rust rust-example-rendered" data-language="rust">
impl&lt;T&gt; Seq&lt;T&gt; for Vec&lt;T&gt; {
    /* ... */
}
impl Seq&lt;bool&gt; for u32 {
    /* Treat the integer as a sequence of bits */
}</pre> <h3 id="external-blocks" class="section-header">6.1.11 External blocks</h3> <p>External blocks form the basis for Rust's foreign function interface. Declarations in an external block describe symbols in external, non-Rust libraries.</p> <p>Functions within external blocks are declared in the same way as other Rust functions, with the exception that they may not have a body and are instead terminated by a semicolon.</p> <p>Functions within external blocks may be called by Rust code, just like functions defined in Rust. The Rust compiler automatically translates between the Rust ABI and the foreign ABI.</p> <p>Functions within external blocks may be variadic by specifying <code>...</code> after one or more named arguments in the argument list:</p> <pre class="rust rust-example-rendered" data-language="rust">
extern {
    fn foo(x: i32, ...);
}</pre> <p>A number of <a href="#ffi-attributes">attributes</a> control the behavior of external blocks.</p> <p>By default external blocks assume that the library they are calling uses the standard C ABI on the specific platform. Other ABIs may be specified using an <code>abi</code> string, as shown here:</p> <pre class="rust rust-example-rendered" data-language="rust">
// Interface to the Windows API
extern "stdcall" { }</pre> <p>There are three ABI strings which are cross-platform, and which all compilers are guaranteed to support:</p> <ul> <li>
<code>extern "Rust"</code> -- The default ABI when you write a normal <code>fn foo()</code> in any Rust code.</li> <li>
<code>extern "C"</code> -- This is the same as <code>extern fn foo()</code>; whatever the default your C compiler supports.</li> <li>
<code>extern "system"</code> -- Usually the same as <code>extern "C"</code>, except on Win32, in which case it's <code>"stdcall"</code>, or what you should use to link to the Windows API itself</li> </ul> <p>There are also some platform-specific ABI strings:</p> <ul> <li>
<code>extern "cdecl"</code> -- The default for x86_32 C code.</li> <li>
<code>extern "stdcall"</code> -- The default for the Win32 API on x86_32.</li> <li>
<code>extern "win64"</code> -- The default for C code on x86_64 Windows.</li> <li>
<code>extern "sysv64"</code> -- The default for C code on non-Windows x86_64.</li> <li>
<code>extern "aapcs"</code> -- The default for ARM.</li> <li>
<code>extern "fastcall"</code> -- The <code>fastcall</code> ABI -- corresponds to MSVC's <code>__fastcall</code> and GCC and clang's <code>__attribute__((fastcall))</code>
</li> <li>
<code>extern "vectorcall"</code> -- The <code>vectorcall</code> ABI -- corresponds to MSVC's <code>__vectorcall</code> and clang's <code>__attribute__((vectorcall))</code>
</li> </ul> <p>Finally, there are some rustc-specific ABI strings:</p> <ul> <li>
<code>extern "rust-intrinsic"</code> -- The ABI of rustc intrinsics.</li> <li>
<code>extern "rust-call"</code> -- The ABI of the Fn::call trait functions.</li> <li>
<code>extern "platform-intrinsic"</code> -- Specific platform intrinsics -- like, for example, <code>sqrt</code> -- have this ABI. You should never have to deal with it.</li> </ul> <p>The <code>link</code> attribute allows the name of the library to be specified. When specified the compiler will attempt to link against the native library of the specified name.</p> <pre class="rust rust-example-rendered" data-language="rust">
#[link(name = "crypto")]
extern { }</pre> <p>The type of a function declared in an extern block is <code>extern "abi" fn(A1, ..., An) -&gt; R</code>, where <code>A1...An</code> are the declared types of its arguments and <code>R</code> is the declared return type.</p> <p>It is valid to add the <code>link</code> attribute on an empty extern block. You can use this to satisfy the linking requirements of extern blocks elsewhere in your code (including upstream crates) instead of adding the attribute to each extern block.</p> <h3 id="visibility-and-privacy" class="section-header">6.2 Visibility and Privacy</h3> <p>These two terms are often used interchangeably, and what they are attempting to convey is the answer to the question "Can this item be used at this location?"</p> <p>Rust's name resolution operates on a global hierarchy of namespaces. Each level in the hierarchy can be thought of as some item. The items are one of those mentioned above, but also include external crates. Declaring or defining a new module can be thought of as inserting a new tree into the hierarchy at the location of the definition.</p> <p>To control whether interfaces can be used across modules, Rust checks each use of an item to see whether it should be allowed or not. This is where privacy warnings are generated, or otherwise "you used a private item of another module and weren't allowed to."</p> <p>By default, everything in Rust is <em>private</em>, with two exceptions: Associated items in a <code>pub</code> Trait are public by default; Enum variants in a <code>pub</code> enum are also public by default. When an item is declared as <code>pub</code>, it can be thought of as being accessible to the outside world. For example:</p> <pre class="rust rust-example-rendered" data-language="rust">
// Declare a private struct
struct Foo;

// Declare a public struct with a private field
pub struct Bar {
    field: i32,
}

// Declare a public enum with two public variants
pub enum State {
    PubliclyAccessibleState,
    PubliclyAccessibleState2,
}</pre> <p>With the notion of an item being either public or private, Rust allows item accesses in two cases:</p> <ol> <li>If an item is public, then it can be used externally through any of its public ancestors.</li> <li>If an item is private, it may be accessed by the current module and its descendants.</li> </ol> <p>These two cases are surprisingly powerful for creating module hierarchies exposing public APIs while hiding internal implementation details. To help explain, here's a few use cases and what they would entail:</p> <ul> <li><p>A library developer needs to expose functionality to crates which link against their library. As a consequence of the first case, this means that anything which is usable externally must be <code>pub</code> from the root down to the destination item. Any private item in the chain will disallow external accesses.</p></li> <li><p>A crate needs a global available "helper module" to itself, but it doesn't want to expose the helper module as a public API. To accomplish this, the root of the crate's hierarchy would have a private module which then internally has a "public API". Because the entire crate is a descendant of the root, then the entire local crate can access this private module through the second case.</p></li> <li><p>When writing unit tests for a module, it's often a common idiom to have an immediate child of the module to-be-tested named <code>mod test</code>. This module could access any items of the parent module through the second case, meaning that internal implementation details could also be seamlessly tested from the child module.</p></li> </ul> <p>In the second case, it mentions that a private item "can be accessed" by the current module and its descendants, but the exact meaning of accessing an item depends on what the item is. Accessing a module, for example, would mean looking inside of it (to import more items). On the other hand, accessing a function would mean that it is invoked. Additionally, path expressions and import statements are considered to access an item in the sense that the import/expression is only valid if the destination is in the current visibility scope.</p> <p>Here's an example of a program which exemplifies the three cases outlined above:</p> <pre class="rust rust-example-rendered" data-language="rust">
// This module is private, meaning that no external crate can access this
// module. Because it is private at the root of this current crate, however, any
// module in the crate may access any publicly visible item in this module.
mod crate_helper_module {

    // This function can be used by anything in the current crate
    pub fn crate_helper() {}

    // This function *cannot* be used by anything else in the crate. It is not
    // publicly visible outside of the `crate_helper_module`, so only this
    // current module and its descendants may access it.
    fn implementation_detail() {}
}

// This function is "public to the root" meaning that it's available to external
// crates linking against this one.
pub fn public_api() {}

// Similarly to 'public_api', this module is public so external crates may look
// inside of it.
pub mod submodule {
    use crate_helper_module;

    pub fn my_method() {
        // Any item in the local crate may invoke the helper module's public
        // interface through a combination of the two rules above.
        crate_helper_module::crate_helper();
    }

    // This function is hidden to any module which is not a descendant of
    // `submodule`
    fn my_implementation() {}

    #[cfg(test)]
    mod test {

        #[test]
        fn test_my_implementation() {
            // Because this module is a descendant of `submodule`, it's allowed
            // to access private items inside of `submodule` without a privacy
            // violation.
            super::my_implementation();
        }
    }
}
</pre> <p>For a Rust program to pass the privacy checking pass, all paths must be valid accesses given the two rules above. This includes all use statements, expressions, types, etc.</p> <h3 id="re-exporting-and-visibility" class="section-header">6.2.1 Re-exporting and Visibility</h3> <p>Rust allows publicly re-exporting items through a <code>pub use</code> directive. Because this is a public directive, this allows the item to be used in the current module through the rules above. It essentially allows public access into the re-exported item. For example, this program is valid:</p> <pre class="rust rust-example-rendered" data-language="rust">
pub use self::implementation::api;

mod implementation {
    pub mod api {
        pub fn f() {}
    }
}
</pre> <p>This means that any external crate referencing <code>implementation::api::f</code> would receive a privacy violation, while the path <code>api::f</code> would be allowed.</p> <p>When re-exporting a private item, it can be thought of as allowing the "privacy chain" being short-circuited through the reexport instead of passing through the namespace hierarchy as it normally would.</p> <h3 id="attributes" class="section-header">6.3 Attributes</h3> <p>Any item declaration may have an <em>attribute</em> applied to it. Attributes in Rust are modeled on Attributes in ECMA-335, with the syntax coming from ECMA-334 (C#). An attribute is a general, free-form metadatum that is interpreted according to name, convention, and language and compiler version. Attributes may appear as any of:</p> <ul> <li>A single identifier, the attribute name</li> <li>An identifier followed by the equals sign '=' and a literal, providing a key/value pair</li> <li>An identifier followed by a parenthesized list of sub-attribute arguments</li> </ul> <p>Attributes with a bang ("!") after the hash ("#") apply to the item that the attribute is declared within. Attributes that do not have a bang after the hash apply to the item that follows the attribute.</p> <p>An example of attributes:</p> <pre class="rust rust-example-rendered" data-language="rust">
// General metadata applied to the enclosing module or crate.
#![crate_type = "lib"]

// A function marked as a unit test
#[test]
fn test_foo() {
    /* ... */
}

// A conditionally-compiled module
#[cfg(target_os="linux")]
mod bar {
    /* ... */
}

// A lint attribute used to suppress a warning/error
#[allow(non_camel_case_types)]
type int8_t = i8;</pre> <blockquote> <p><strong>Note:</strong> At some point in the future, the compiler will distinguish between language-reserved and user-available attributes. Until then, there is effectively no difference between an attribute handled by a loadable syntax extension and the compiler.</p> </blockquote> <h3 id="crate-only-attributes" class="section-header">6.3.1 Crate-only attributes</h3> <ul> <li>
<code>crate_name</code> - specify the crate's crate name.</li> <li>
<code>crate_type</code> - see <a href="#linkage">linkage</a>.</li> <li>
<code>feature</code> - see <a href="#compiler-features">compiler features</a>.</li> <li>
<code>no_builtins</code> - disable optimizing certain code patterns to invocations of library functions that are assumed to exist</li> <li>
<code>no_main</code> - disable emitting the <code>main</code> symbol. Useful when some other object being linked to defines <code>main</code>.</li> <li>
<code>no_start</code> - disable linking to the <code>native</code> crate, which specifies the "start" language item.</li> <li>
<code>no_std</code> - disable linking to the <code>std</code> crate.</li> <li>
<code>plugin</code> - load a list of named crates as compiler plugins, e.g. <code>#![plugin(foo, bar)]</code>. Optional arguments for each plugin, i.e. <code>#![plugin(foo(... args ...))]</code>, are provided to the plugin's registrar function. The <code>plugin</code> feature gate is required to use this attribute.</li> <li>
<code>recursion_limit</code> - Sets the maximum depth for potentially infinitely-recursive compile-time operations like auto-dereference or macro expansion. The default is <code>#![recursion_limit="64"]</code>.</li> </ul> <h3 id="module-only-attributes" class="section-header">6.3.2 Module-only attributes</h3> <ul> <li>
<code>no_implicit_prelude</code> - disable injecting <code>use std::prelude::*</code> in this module.</li> <li>
<code>path</code> - specifies the file to load the module from. <code>#[path="foo.rs"] mod bar;</code> is equivalent to <code>mod bar { /* contents of foo.rs */ }</code>. The path is taken relative to the directory that the current module is in.</li> </ul> <h3 id="function-only-attributes" class="section-header">6.3.3 Function-only attributes</h3> <ul> <li>
<code>main</code> - indicates that this function should be passed to the entry point, rather than the function in the crate root named <code>main</code>.</li> <li>
<code>plugin_registrar</code> - mark this function as the registration point for <a href="../book/compiler-plugins/">compiler plugins</a>, such as loadable syntax extensions.</li> <li>
<code>start</code> - indicates that this function should be used as the entry point, overriding the "start" language item. See the "start" <a href="#language-items">language item</a> for more details.</li> <li>
<code>test</code> - indicates that this function is a test function, to only be compiled in case of <code>--test</code>.</li> <li>
<code>should_panic</code> - indicates that this test function should panic, inverting the success condition.</li> <li>
<code>cold</code> - The function is unlikely to be executed, so optimize it (and calls to it) differently.</li> <li>
<code>naked</code> - The function utilizes a custom ABI or custom inline ASM that requires epilogue and prologue to be skipped.</li> </ul> <h3 id="static-only-attributes" class="section-header">6.3.4 Static-only attributes</h3> <ul> <li>
<code>thread_local</code> - on a <code>static mut</code>, this signals that the value of this static may change depending on the current thread. The exact consequences of this are implementation-defined.</li> </ul> <h3 id="ffi-attributes" class="section-header">6.3.5 FFI attributes</h3> <p>On an <code>extern</code> block, the following attributes are interpreted:</p> <ul> <li>
<code>link_args</code> - specify arguments to the linker, rather than just the library name and type. This is feature gated and the exact behavior is implementation-defined (due to variety of linker invocation syntax).</li> <li>
<code>link</code> - indicate that a native library should be linked to for the declarations in this block to be linked correctly. <code>link</code> supports an optional <code>kind</code> key with three possible values: <code>dylib</code>, <code>static</code>, and <code>framework</code>. See <a href="#external-blocks">external blocks</a> for more about external blocks. Two examples: <code>#[link(name = "readline")]</code> and <code>#[link(name = "CoreFoundation", kind = "framework")]</code>.</li> <li>
<code>linked_from</code> - indicates what native library this block of FFI items is coming from. This attribute is of the form <code>#[linked_from = "foo"]</code> where <code>foo</code> is the name of a library in either <code>#[link]</code> or a <code>-l</code> flag. This attribute is currently required to export symbols from a Rust dynamic library on Windows, and it is feature gated behind the <code>linked_from</code> feature.</li> </ul> <p>On declarations inside an <code>extern</code> block, the following attributes are interpreted:</p> <ul> <li>
<code>link_name</code> - the name of the symbol that this function or static should be imported as.</li> <li>
<code>linkage</code> - on a static, this specifies the <a href="http://llvm.org/docs/LangRef.html#linkage-types" target="_blank">linkage type</a>.</li> </ul> <p>On <code>enum</code>s:</p> <ul> <li>
<code>repr</code> - on C-like enums, this sets the underlying type used for representation. Takes one argument, which is the primitive type this enum should be represented for, or <code>C</code>, which specifies that it should be the default <code>enum</code> size of the C ABI for that platform. Note that enum representation in C is undefined, and this may be incorrect when the C code is compiled with certain flags.</li> </ul> <p>On <code>struct</code>s:</p> <ul> <li>
<code>repr</code> - specifies the representation to use for this struct. Takes a list of options. The currently accepted ones are <code>C</code> and <code>packed</code>, which may be combined. <code>C</code> will use a C ABI compatible struct layout, and <code>packed</code> will remove any padding between fields (note that this is very fragile and may break platforms which require aligned access).</li> </ul> <h3 id="macro-related-attributes" class="section-header">6.3.6 Macro-related attributes</h3> <ul> <li><p><code>macro_use</code> on a <code>mod</code> — macros defined in this module will be visible in the module's parent, after this module has been included.</p></li> <li><p><code>macro_use</code> on an <code>extern crate</code> — load macros from this crate. An optional list of names <code>#[macro_use(foo, bar)]</code> restricts the import to just those macros named. The <code>extern crate</code> must appear at the crate root, not inside <code>mod</code>, which ensures proper function of the <a href="../book/macros/#the-variable-crate"><code>$crate</code> macro variable</a>.</p></li> <li><p><code>macro_reexport</code> on an <code>extern crate</code> — re-export the named macros.</p></li> <li><p><code>macro_export</code> - export a macro for cross-crate usage.</p></li> <li><p><code>no_link</code> on an <code>extern crate</code> — even if we load this crate for macros, don't link it into the output.</p></li> </ul> <p>See the <a href="../book/macros/#scoping-and-macro-importexport">macros section of the book</a> for more information on macro scope.</p> <h3 id="miscellaneous-attributes" class="section-header">6.3.7 Miscellaneous attributes</h3> <ul> <li>
<code>deprecated</code> - mark the item as deprecated; the full attribute is <code>#[deprecated(since = "crate version", note = "...")</code>, where both arguments are optional.</li> <li>
<code>export_name</code> - on statics and functions, this determines the name of the exported symbol.</li> <li>
<code>link_section</code> - on statics and functions, this specifies the section of the object file that this item's contents will be placed into.</li> <li>
<code>no_mangle</code> - on any item, do not apply the standard name mangling. Set the symbol for this item to its identifier.</li> <li>
<code>simd</code> - on certain tuple structs, derive the arithmetic operators, which lower to the target's SIMD instructions, if any; the <code>simd</code> feature gate is necessary to use this attribute.</li> <li>
<code>unsafe_destructor_blind_to_params</code> - on <code>Drop::drop</code> method, asserts that the destructor code (and all potential specializations of that code) will never attempt to read from nor write to any references with lifetimes that come in via generic parameters. This is a constraint we cannot currently express via the type system, and therefore we rely on the programmer to assert that it holds. Adding this to a Drop impl causes the associated destructor to be considered "uninteresting" by the Drop-Check rule, and thus it can help sidestep data ordering constraints that would otherwise be introduced by the Drop-Check rule. Such sidestepping of the constraints, if done incorrectly, can lead to undefined behavior (in the form of reading or writing to data outside of its dynamic extent), and thus this attribute has the word "unsafe" in its name. To use this, the <code>unsafe_destructor_blind_to_params</code> feature gate must be enabled.</li> <li>
<code>doc</code> - Doc comments such as <code>/// foo</code> are equivalent to <code>#[doc = "foo"]</code>.</li> <li>
<code>rustc_on_unimplemented</code> - Write a custom note to be shown along with the error when the trait is found to be unimplemented on a type. You may use format arguments like <code>{T}</code>, <code>{A}</code> to correspond to the types at the point of use corresponding to the type parameters of the trait of the same name. <code>{Self}</code> will be replaced with the type that is supposed to implement the trait but doesn't. To use this, the <code>on_unimplemented</code> feature gate must be enabled.</li> <li>
<code>must_use</code> - on structs and enums, will warn if a value of this type isn't used or assigned to a variable. You may also include an optional message by using <code>#[must_use = "message"]</code> which will be given alongside the warning.</li> </ul> <h3 id="conditional-compilation" class="section-header">6.3.8 Conditional compilation</h3> <p>Sometimes one wants to have different compiler outputs from the same code, depending on build target, such as targeted operating system, or to enable release builds.</p> <p>There are two kinds of configuration options, one that is either defined or not (<code>#[cfg(foo)]</code>), and the other that contains a string that can be checked against (<code>#[cfg(bar = "baz")]</code>). Currently, only compiler-defined configuration options can have the latter form.</p> <pre class="rust rust-example-rendered" data-language="rust">
// The function is only included in the build when compiling for OSX
#[cfg(target_os = "macos")]
fn macos_only() {
  // ...
}

// This function is only included when either foo or bar is defined
#[cfg(any(foo, bar))]
fn needs_foo_or_bar() {
  // ...
}

// This function is only included when compiling for a unixish OS with a 32-bit
// architecture
#[cfg(all(unix, target_pointer_width = "32"))]
fn on_32bit_unix() {
  // ...
}

// This function is only included when foo is not defined
#[cfg(not(foo))]
fn needs_not_foo() {
  // ...
}</pre> <p>This illustrates some conditional compilation can be achieved using the <code>#[cfg(...)]</code> attribute. <code>any</code>, <code>all</code> and <code>not</code> can be used to assemble arbitrarily complex configurations through nesting.</p> <p>The following configurations must be defined by the implementation:</p> <ul> <li>
<code>target_arch = "..."</code> - Target CPU architecture, such as <code>"x86"</code>, <code>"x86_64"</code> <code>"mips"</code>, <code>"powerpc"</code>, <code>"powerpc64"</code>, <code>"arm"</code>, or <code>"aarch64"</code>. This value is closely related to the first element of the platform target triple, though it is not identical.</li> <li>
<code>target_os = "..."</code> - Operating system of the target, examples include <code>"windows"</code>, <code>"macos"</code>, <code>"ios"</code>, <code>"linux"</code>, <code>"android"</code>, <code>"freebsd"</code>, <code>"dragonfly"</code>, <code>"bitrig"</code> , <code>"openbsd"</code> or <code>"netbsd"</code>. This value is closely related to the second and third element of the platform target triple, though it is not identical.</li> <li>
<code>target_family = "..."</code> - Operating system family of the target, e. g. <code>"unix"</code> or <code>"windows"</code>. The value of this configuration option is defined as a configuration itself, like <code>unix</code> or <code>windows</code>.</li> <li>
<code>unix</code> - See <code>target_family</code>.</li> <li>
<code>windows</code> - See <code>target_family</code>.</li> <li>
<code>target_env = ".."</code> - Further disambiguates the target platform with information about the ABI/libc. Presently this value is either <code>"gnu"</code>, <code>"msvc"</code>, <code>"musl"</code>, or the empty string. For historical reasons this value has only been defined as non-empty when needed for disambiguation. Thus on many GNU platforms this value will be empty. This value is closely related to the fourth element of the platform target triple, though it is not identical. For example, embedded ABIs such as <code>gnueabihf</code> will simply define <code>target_env</code> as <code>"gnu"</code>.</li> <li>
<code>target_endian = "..."</code> - Endianness of the target CPU, either <code>"little"</code> or <code>"big"</code>.</li> <li>
<code>target_pointer_width = "..."</code> - Target pointer width in bits. This is set to <code>"32"</code> for targets with 32-bit pointers, and likewise set to <code>"64"</code> for 64-bit pointers.</li> <li>
<code>target_has_atomic = "..."</code> - Set of integer sizes on which the target can perform atomic operations. Values are <code>"8"</code>, <code>"16"</code>, <code>"32"</code>, <code>"64"</code> and <code>"ptr"</code>.</li> <li>
<code>target_vendor = "..."</code> - Vendor of the target, for example <code>apple</code>, <code>pc</code>, or simply <code>"unknown"</code>.</li> <li>
<code>test</code> - Enabled when compiling the test harness (using the <code>--test</code> flag).</li> <li>
<code>debug_assertions</code> - Enabled by default when compiling without optimizations. This can be used to enable extra debugging code in development but not in production. For example, it controls the behavior of the standard library's <code>debug_assert!</code> macro.</li> </ul> <p>You can also set another attribute based on a <code>cfg</code> variable with <code>cfg_attr</code>:</p> <pre class="rust rust-example-rendered" data-language="rust">
#[cfg_attr(a, b)]</pre> <p>Will be the same as <code>#[b]</code> if <code>a</code> is set by <code>cfg</code>, and nothing otherwise.</p> <h3 id="lint-check-attributes" class="section-header">6.3.9 Lint check attributes</h3> <p>A lint check names a potentially undesirable coding pattern, such as unreachable code or omitted documentation, for the static entity to which the attribute applies.</p> <p>For any lint check <code>C</code>:</p> <ul> <li>
<code>allow(C)</code> overrides the check for <code>C</code> so that violations will go unreported,</li> <li>
<code>deny(C)</code> signals an error after encountering a violation of <code>C</code>,</li> <li>
<code>forbid(C)</code> is the same as <code>deny(C)</code>, but also forbids changing the lint level afterwards,</li> <li>
<code>warn(C)</code> warns about violations of <code>C</code> but continues compilation.</li> </ul> <p>The lint checks supported by the compiler can be found via <code>rustc -W help</code>, along with their default settings. <a href="../book/compiler-plugins/#lint-plugins">Compiler plugins</a> can provide additional lint checks.</p> <pre class="rust rust-example-rendered" data-language="rust">
pub mod m1 {
    // Missing documentation is ignored here
    #[allow(missing_docs)]
    pub fn undocumented_one() -&gt; i32 { 1 }

    // Missing documentation signals a warning here
    #[warn(missing_docs)]
    pub fn undocumented_too() -&gt; i32 { 2 }

    // Missing documentation signals an error here
    #[deny(missing_docs)]
    pub fn undocumented_end() -&gt; i32 { 3 }
}</pre> <p>This example shows how one can use <code>allow</code> and <code>warn</code> to toggle a particular check on and off:</p> <pre class="rust rust-example-rendered" data-language="rust">
#[warn(missing_docs)]
pub mod m2{
    #[allow(missing_docs)]
    pub mod nested {
        // Missing documentation is ignored here
        pub fn undocumented_one() -&gt; i32 { 1 }

        // Missing documentation signals a warning here,
        // despite the allow above.
        #[warn(missing_docs)]
        pub fn undocumented_two() -&gt; i32 { 2 }
    }

    // Missing documentation signals a warning here
    pub fn undocumented_too() -&gt; i32 { 3 }
}</pre> <p>This example shows how one can use <code>forbid</code> to disallow uses of <code>allow</code> for that lint check:</p> <pre class="rust rust-example-rendered" data-language="rust">
#[forbid(missing_docs)]
pub mod m3 {
    // Attempting to toggle warning signals an error here
    #[allow(missing_docs)]
    /// Returns 2.
    pub fn undocumented_too() -&gt; i32 { 2 }
}</pre> <h3 id="language-items" class="section-header">6.3.10 Language items</h3> <p>Some primitive Rust operations are defined in Rust code, rather than being implemented directly in C or assembly language. The definitions of these operations have to be easy for the compiler to find. The <code>lang</code> attribute makes it possible to declare these operations. For example, the <code>str</code> module in the Rust standard library defines the string equality function:</p> <pre class="rust rust-example-rendered" data-language="rust">
#[lang = "str_eq"]
pub fn eq_slice(a: &amp;str, b: &amp;str) -&gt; bool {
    // details elided
}</pre> <p>The name <code>str_eq</code> has a special meaning to the Rust compiler, and the presence of this definition means that it will use this definition when generating calls to the string equality function.</p> <p>The set of language items is currently considered unstable. A complete list of the built-in language items will be added in the future.</p> <h3 id="inline-attributes" class="section-header">6.3.11 Inline attributes</h3> <p>The inline attribute suggests that the compiler should place a copy of the function or static in the caller, rather than generating code to call the function or access the static where it is defined.</p> <p>The compiler automatically inlines functions based on internal heuristics. Incorrectly inlining functions can actually make the program slower, so it should be used with care.</p> <p><code>#[inline]</code> and <code>#[inline(always)]</code> always cause the function to be serialized into the crate metadata to allow cross-crate inlining.</p> <p>There are three different types of inline attributes:</p> <ul> <li>
<code>#[inline]</code> hints the compiler to perform an inline expansion.</li> <li>
<code>#[inline(always)]</code> asks the compiler to always perform an inline expansion.</li> <li>
<code>#[inline(never)]</code> asks the compiler to never perform an inline expansion.</li> </ul> <h3 id="derive" class="section-header">6.3.12 <code>derive</code>
</h3> <p>The <code>derive</code> attribute allows certain traits to be automatically implemented for data structures. For example, the following will create an <code>impl</code> for the <code>PartialEq</code> and <code>Clone</code> traits for <code>Foo</code>, the type parameter <code>T</code> will be given the <code>PartialEq</code> or <code>Clone</code> constraints for the appropriate <code>impl</code>:</p> <pre class="rust rust-example-rendered" data-language="rust">
#[derive(PartialEq, Clone)]
struct Foo&lt;T&gt; {
    a: i32,
    b: T,
}</pre> <p>The generated <code>impl</code> for <code>PartialEq</code> is equivalent to</p> <pre class="rust rust-example-rendered" data-language="rust">
impl&lt;T: PartialEq&gt; PartialEq for Foo&lt;T&gt; {
    fn eq(&amp;self, other: &amp;Foo&lt;T&gt;) -&gt; bool {
        self.a == other.a &amp;&amp; self.b == other.b
    }

    fn ne(&amp;self, other: &amp;Foo&lt;T&gt;) -&gt; bool {
        self.a != other.a || self.b != other.b
    }
}</pre> <p>You can implement <code>derive</code> for your own type through <a href="#procedural-macros">procedural macros</a>.</p> <h3 id="compiler-features" class="section-header">6.3.13 Compiler Features</h3> <p>Certain aspects of Rust may be implemented in the compiler, but they're not necessarily ready for every-day use. These features are often of "prototype quality" or "almost production ready", but may not be stable enough to be considered a full-fledged language feature.</p> <p>For this reason, Rust recognizes a special crate-level attribute of the form:</p> <pre class="rust rust-example-rendered" data-language="rust">
#![feature(feature1, feature2, feature3)]</pre> <p>This directive informs the compiler that the feature list: <code>feature1</code>, <code>feature2</code>, and <code>feature3</code> should all be enabled. This is only recognized at a crate-level, not at a module-level. Without this directive, all features are considered off, and using the features will result in a compiler error.</p> <p>The currently implemented features of the reference compiler are:</p> <ul> <li><p><code>advanced_slice_patterns</code> - See the <a href="#match-expressions">match expressions</a> section for discussion; the exact semantics of slice patterns are subject to change, so some types are still unstable.</p></li> <li><p><code>slice_patterns</code> - OK, actually, slice patterns are just scary and completely unstable.</p></li> <li><p><code>asm</code> - The <code>asm!</code> macro provides a means for inline assembly. This is often useful, but the exact syntax for this feature along with its semantics are likely to change, so this macro usage must be opted into.</p></li> <li><p><code>associated_consts</code> - Allows constants to be defined in <code>impl</code> and <code>trait</code> blocks, so that they can be associated with a type or trait in a similar manner to methods and associated types.</p></li> <li><p><code>box_patterns</code> - Allows <code>box</code> patterns, the exact semantics of which is subject to change.</p></li> <li><p><code>box_syntax</code> - Allows use of <code>box</code> expressions, the exact semantics of which is subject to change.</p></li> <li><p><code>cfg_target_vendor</code> - Allows conditional compilation using the <code>target_vendor</code> matcher which is subject to change.</p></li> <li><p><code>cfg_target_has_atomic</code> - Allows conditional compilation using the <code>target_has_atomic</code> matcher which is subject to change.</p></li> <li><p><code>concat_idents</code> - Allows use of the <code>concat_idents</code> macro, which is in many ways insufficient for concatenating identifiers, and may be removed entirely for something more wholesome.</p></li> <li><p><code>custom_attribute</code> - Allows the usage of attributes unknown to the compiler so that new attributes can be added in a backwards compatible manner (RFC 572).</p></li> <li><p><code>custom_derive</code> - Allows the use of <code>#[derive(Foo,Bar)]</code> as sugar for <code>#[derive_Foo] #[derive_Bar]</code>, which can be user-defined syntax extensions.</p></li> <li><p><code>inclusive_range_syntax</code> - Allows use of the <code>a...b</code> and <code>...b</code> syntax for inclusive ranges.</p></li> <li><p><code>inclusive_range</code> - Allows use of the types that represent desugared inclusive ranges.</p></li> <li><p><code>intrinsics</code> - Allows use of the "rust-intrinsics" ABI. Compiler intrinsics are inherently unstable and no promise about them is made.</p></li> <li><p><code>lang_items</code> - Allows use of the <code>#[lang]</code> attribute. Like <code>intrinsics</code>, lang items are inherently unstable and no promise about them is made.</p></li> <li><p><code>link_args</code> - This attribute is used to specify custom flags to the linker, but usage is strongly discouraged. The compiler's usage of the system linker is not guaranteed to continue in the future, and if the system linker is not used then specifying custom flags doesn't have much meaning.</p></li> <li><p><code>link_llvm_intrinsics</code> – Allows linking to LLVM intrinsics via <code>#[link_name="llvm.*"]</code>.</p></li> <li><p><code>linkage</code> - Allows use of the <code>linkage</code> attribute, which is not portable.</p></li> <li><p><code>log_syntax</code> - Allows use of the <code>log_syntax</code> macro attribute, which is a nasty hack that will certainly be removed.</p></li> <li><p><code>main</code> - Allows use of the <code>#[main]</code> attribute, which changes the entry point into a Rust program. This capability is subject to change.</p></li> <li><p><code>macro_reexport</code> - Allows macros to be re-exported from one crate after being imported from another. This feature was originally designed with the sole use case of the Rust standard library in mind, and is subject to change.</p></li> <li><p><code>non_ascii_idents</code> - The compiler supports the use of non-ascii identifiers, but the implementation is a little rough around the edges, so this can be seen as an experimental feature for now until the specification of identifiers is fully fleshed out.</p></li> <li><p><code>no_std</code> - Allows the <code>#![no_std]</code> crate attribute, which disables the implicit <code>extern crate std</code>. This typically requires use of the unstable APIs behind the libstd "facade", such as libcore and libcollections. It may also cause problems when using syntax extensions, including <code>#[derive]</code>.</p></li> <li><p><code>on_unimplemented</code> - Allows the <code>#[rustc_on_unimplemented]</code> attribute, which allows trait definitions to add specialized notes to error messages when an implementation was expected but not found.</p></li> <li><p><code>optin_builtin_traits</code> - Allows the definition of default and negative trait implementations. Experimental.</p></li> <li><p><code>plugin</code> - Usage of <a href="../book/compiler-plugins/">compiler plugins</a> for custom lints or syntax extensions. These depend on compiler internals and are subject to change.</p></li> <li><p><code>plugin_registrar</code> - Indicates that a crate provides <a href="../book/compiler-plugins/">compiler plugins</a>.</p></li> <li><p><code>quote</code> - Allows use of the <code>quote_*!</code> family of macros, which are implemented very poorly and will likely change significantly with a proper implementation.</p></li> <li><p><code>rustc_attrs</code> - Gates internal <code>#[rustc_*]</code> attributes which may be for internal use only or have meaning added to them in the future.</p></li> <li><p><code>rustc_diagnostic_macros</code>- A mysterious feature, used in the implementation of rustc, not meant for mortals.</p></li> <li><p><code>simd</code> - Allows use of the <code>#[simd]</code> attribute, which is overly simple and not the SIMD interface we want to expose in the long term.</p></li> <li><p><code>simd_ffi</code> - Allows use of SIMD vectors in signatures for foreign functions. The SIMD interface is subject to change.</p></li> <li><p><code>start</code> - Allows use of the <code>#[start]</code> attribute, which changes the entry point into a Rust program. This capability, especially the signature for the annotated function, is subject to change.</p></li> <li><p><code>static_in_const</code> - Enables lifetime elision with a <code>'static</code> default for <code>const</code> and <code>static</code> item declarations.</p></li> <li><p><code>thread_local</code> - The usage of the <code>#[thread_local]</code> attribute is experimental and should be seen as unstable. This attribute is used to declare a <code>static</code> as being unique per-thread leveraging LLVM's implementation which works in concert with the kernel loader and dynamic linker. This is not necessarily available on all platforms, and usage of it is discouraged.</p></li> <li><p><code>trace_macros</code> - Allows use of the <code>trace_macros</code> macro, which is a nasty hack that will certainly be removed.</p></li> <li><p><code>unboxed_closures</code> - Rust's new closure design, which is currently a work in progress feature with many known bugs.</p></li> <li><p><code>allow_internal_unstable</code> - Allows <code>macro_rules!</code> macros to be tagged with the <code>#[allow_internal_unstable]</code> attribute, designed to allow <code>std</code> macros to call <code>#[unstable]</code>/feature-gated functionality internally without imposing on callers (i.e. making them behave like function calls in terms of encapsulation).</p></li> <li><p><code>default_type_parameter_fallback</code> - Allows type parameter defaults to influence type inference.</p></li> <li><p><code>stmt_expr_attributes</code> - Allows attributes on expressions.</p></li> <li><p><code>type_ascription</code> - Allows type ascription expressions <code>expr: Type</code>.</p></li> <li><p><code>abi_vectorcall</code> - Allows the usage of the vectorcall calling convention (e.g. <code>extern "vectorcall" func fn_();</code>)</p></li> <li><p><code>abi_sysv64</code> - Allows the usage of the system V AMD64 calling convention (e.g. <code>extern "sysv64" func fn_();</code>)</p></li> </ul> <p>If a feature is promoted to a language feature, then all existing programs will start to receive compilation warnings about <code>#![feature]</code> directives which enabled the new feature (because the directive is no longer necessary). However, if a feature is decided to be removed from the language, errors will be issued (if there isn't a parser error first). The directive in this case is no longer necessary, and it's likely that existing code will break if the feature isn't removed.</p> <p>If an unknown feature is found in a directive, it results in a compiler error. An unknown feature is one which has never been recognized by the compiler.</p> <h2 id="statements-and-expressions" class="section-header">7 Statements and expressions</h2> <p>Rust is <em>primarily</em> an expression language. This means that most forms of value-producing or effect-causing evaluation are directed by the uniform syntax category of <em>expressions</em>. Each kind of expression can typically <em>nest</em> within each other kind of expression, and rules for evaluation of expressions involve specifying both the value produced by the expression and the order in which its sub-expressions are themselves evaluated.</p> <p>In contrast, statements in Rust serve <em>mostly</em> to contain and explicitly sequence expression evaluation.</p> <h3 id="statements" class="section-header">7.1 Statements</h3> <p>A <em>statement</em> is a component of a block, which is in turn a component of an outer <a href="#expressions">expression</a> or <a href="#functions">function</a>.</p> <p>Rust has two kinds of statement: <a href="#declaration-statements">declaration statements</a> and <a href="#expression-statements">expression statements</a>.</p> <h3 id="declaration-statements" class="section-header">7.1.1 Declaration statements</h3> <p>A <em>declaration statement</em> is one that introduces one or more <em>names</em> into the enclosing statement block. The declared names may denote new variables or new items.</p> <h4 id="item-declarations" class="section-header">7.1.1.1 Item declarations</h4> <p>An <em>item declaration statement</em> has a syntactic form identical to an <a href="#items">item</a> declaration within a module. Declaring an item — a function, enumeration, struct, type, static, trait, implementation or module — locally within a statement block is simply a way of restricting its scope to a narrow region containing all of its uses; it is otherwise identical in meaning to declaring the item outside the statement block.</p> <blockquote> <p><strong>Note</strong>: there is no implicit capture of the function's dynamic environment when declaring a function-local item.</p> </blockquote> <h4 id="let-statements" class="section-header">7.1.1.2 <code>let</code> statements</h4> <p>A <em><code>let</code> statement</em> introduces a new set of variables, given by a pattern. The pattern may be followed by a type annotation, and/or an initializer expression. When no type annotation is given, the compiler will infer the type, or signal an error if insufficient type information is available for definite inference. Any variables introduced by a variable declaration are visible from the point of declaration until the end of the enclosing block scope.</p> <h3 id="expression-statements" class="section-header">7.1.2 Expression statements</h3> <p>An <em>expression statement</em> is one that evaluates an <a href="#expressions">expression</a> and ignores its result. The type of an expression statement <code>e;</code> is always <code>()</code>, regardless of the type of <code>e</code>. As a rule, an expression statement's purpose is to trigger the effects of evaluating its expression.</p> <h3 id="expressions" class="section-header">7.2 Expressions</h3> <p>An expression may have two roles: it always produces a <em>value</em>, and it may have <em>effects</em> (otherwise known as "side effects"). An expression <em>evaluates to</em> a value, and has effects during <em>evaluation</em>. Many expressions contain sub-expressions (operands). The meaning of each kind of expression dictates several things:</p> <ul> <li>Whether or not to evaluate the sub-expressions when evaluating the expression</li> <li>The order in which to evaluate the sub-expressions</li> <li>How to combine the sub-expressions' values to obtain the value of the expression</li> </ul> <p>In this way, the structure of expressions dictates the structure of execution. Blocks are just another kind of expression, so blocks, statements, expressions, and blocks again can recursively nest inside each other to an arbitrary depth.</p> <h4 id="lvalues-rvalues-and-temporaries" class="section-header">7.2.0.1 Lvalues, rvalues and temporaries</h4> <p>Expressions are divided into two main categories: <em>lvalues</em> and <em>rvalues</em>. Likewise within each expression, sub-expressions may occur in <em>lvalue context</em> or <em>rvalue context</em>. The evaluation of an expression depends both on its own category and the context it occurs within.</p> <p>An lvalue is an expression that represents a memory location. These expressions are <a href="#path-expressions">paths</a> (which refer to local variables, function and method arguments, or static variables), dereferences (<code>*expr</code>), <a href="#index-expressions">indexing expressions</a> (<code>expr[expr]</code>), and <a href="#field-expressions">field references</a> (<code>expr.f</code>). All other expressions are rvalues.</p> <p>The left operand of an <a href="#assignment-expressions">assignment</a> or <a href="#compound-assignment-expressions">compound-assignment</a> expression is an lvalue context, as is the single operand of a unary <a href="#unary-operator-expressions">borrow</a>. The discriminant or subject of a <a href="#match-expressions">match expression</a> may be an lvalue context, if ref bindings are made, but is otherwise an rvalue context. All other expression contexts are rvalue contexts.</p> <p>When an lvalue is evaluated in an <em>lvalue context</em>, it denotes a memory location; when evaluated in an <em>rvalue context</em>, it denotes the value held <em>in</em> that memory location.</p> <h5 id="temporary-lifetimes" class="section-header">7.2.0.1.1 Temporary lifetimes</h5> <p>When an rvalue is used in an lvalue context, a temporary un-named lvalue is created and used instead. The lifetime of temporary values is typically the innermost enclosing statement; the tail expression of a block is considered part of the statement that encloses the block.</p> <p>When a temporary rvalue is being created that is assigned into a <code>let</code> declaration, however, the temporary is created with the lifetime of the enclosing block instead, as using the enclosing statement (the <code>let</code> declaration) would be a guaranteed error (since a pointer to the temporary would be stored into a variable, but the temporary would be freed before the variable could be used). The compiler uses simple syntactic rules to decide which values are being assigned into a <code>let</code> binding, and therefore deserve a longer temporary lifetime.</p> <p>Here are some examples:</p> <ul> <li>
<code>let x = foo(&amp;temp())</code>. The expression <code>temp()</code> is an rvalue. As it is being borrowed, a temporary is created which will be freed after the innermost enclosing statement (the <code>let</code> declaration, in this case).</li> <li>
<code>let x = temp().foo()</code>. This is the same as the previous example, except that the value of <code>temp()</code> is being borrowed via autoref on a method-call. Here we are assuming that <code>foo()</code> is an <code>&amp;self</code> method defined in some trait, say <code>Foo</code>. In other words, the expression <code>temp().foo()</code> is equivalent to <code>Foo::foo(&amp;temp())</code>.</li> <li>
<code>let x = &amp;temp()</code>. Here, the same temporary is being assigned into <code>x</code>, rather than being passed as a parameter, and hence the temporary's lifetime is considered to be the enclosing block.</li> <li>
<code>let x = SomeStruct { foo: &amp;temp() }</code>. As in the previous case, the temporary is assigned into a struct which is then assigned into a binding, and hence it is given the lifetime of the enclosing block.</li> <li>
<code>let x = [ &amp;temp() ]</code>. As in the previous case, the temporary is assigned into an array which is then assigned into a binding, and hence it is given the lifetime of the enclosing block.</li> <li>
<code>let ref x = temp()</code>. In this case, the temporary is created using a ref binding, but the result is the same: the lifetime is extended to the enclosing block.</li> </ul> <h4 id="moved-and-copied-types" class="section-header">7.2.0.2 Moved and copied types</h4> <p>When a <a href="#variables">local variable</a> is used as an <a href="#lvalues-rvalues-and-temporaries">rvalue</a>, the variable will be copied if its type implements <code>Copy</code>. All others are moved.</p> <h3 id="literal-expressions" class="section-header">7.2.1 Literal expressions</h3> <p>A <em>literal expression</em> consists of one of the <a href="#literals">literal</a> forms described earlier. It directly describes a number, character, string, boolean value, or the unit value.</p> <pre>();        // unit type
"hello";   // string type
'5';       // character type
5;         // integer type
</pre> <h3 id="path-expressions" class="section-header">7.2.2 Path expressions</h3> <p>A <a href="#paths">path</a> used as an expression context denotes either a local variable or an item. Path expressions are <a href="#lvalues-rvalues-and-temporaries">lvalues</a>.</p> <h3 id="tuple-expressions" class="section-header">7.2.3 Tuple expressions</h3> <p>Tuples are written by enclosing zero or more comma-separated expressions in parentheses. They are used to create <a href="#tuple-types">tuple-typed</a> values.</p> <pre>(0.0, 4.5);
("a", 4usize, true);
</pre> <p>You can disambiguate a single-element tuple from a value in parentheses with a comma:</p> <pre class="rust rust-example-rendered" data-language="rust">
(0,); // single-element tuple
(0); // zero in parentheses</pre> <h3 id="struct-expressions" class="section-header">7.2.4 Struct expressions</h3> <p>There are several forms of struct expressions. A <em>struct expression</em> consists of the <a href="#paths">path</a> of a <a href="#structs">struct item</a>, followed by a brace-enclosed list of zero or more comma-separated name-value pairs, providing the field values of a new instance of the struct. A field name can be any identifier, and is separated from its value expression by a colon. The location denoted by a struct field is mutable if and only if the enclosing struct is mutable.</p> <p>A <em>tuple struct expression</em> consists of the <a href="#paths">path</a> of a <a href="#structs">struct item</a>, followed by a parenthesized list of one or more comma-separated expressions (in other words, the path of a struct item followed by a tuple expression). The struct item must be a tuple struct item.</p> <p>A <em>unit-like struct expression</em> consists only of the <a href="#paths">path</a> of a <a href="#structs">struct item</a>.</p> <p>The following are examples of struct expressions:</p> <pre class="rust rust-example-rendered" data-language="rust">
Point {x: 10.0, y: 20.0};
NothingInMe {};
TuplePoint(10.0, 20.0);
let u = game::User {name: "Joe", age: 35, score: 100_000};
some_fn::&lt;Cookie&gt;(Cookie);</pre> <p>A struct expression forms a new value of the named struct type. Note that for a given <em>unit-like</em> struct type, this will always be the same value.</p> <p>A struct expression can terminate with the syntax <code>..</code> followed by an expression to denote a functional update. The expression following <code>..</code> (the base) must have the same struct type as the new struct type being formed. The entire expression denotes the result of constructing a new struct (with the same type as the base expression) with the given values for the fields that were explicitly specified and the values in the base expression for all other fields.</p> <pre class="rust rust-example-rendered" data-language="rust">
let base = Point3d {x: 1, y: 2, z: 3};
Point3d {y: 0, z: 10, .. base};</pre> <h3 id="block-expressions" class="section-header">7.2.5 Block expressions</h3> <p>A <em>block expression</em> is similar to a module in terms of the declarations that are possible. Each block conceptually introduces a new namespace scope. Use items can bring new names into scopes and declared items are in scope for only the block itself.</p> <p>A block will execute each statement sequentially, and then execute the expression (if given). If the block ends in a statement, its value is <code>()</code>:</p> <pre class="rust rust-example-rendered" data-language="rust">
let x: () = { println!("Hello."); };</pre> <p>If it ends in an expression, its value and type are that of the expression:</p> <pre class="rust rust-example-rendered" data-language="rust">
let x: i32 = { println!("Hello."); 5 };

assert_eq!(5, x);</pre> <h3 id="method-call-expressions" class="section-header">7.2.6 Method-call expressions</h3> <p>A <em>method call</em> consists of an expression followed by a single dot, an identifier, and a parenthesized expression-list. Method calls are resolved to methods on specific traits, either statically dispatching to a method if the exact <code>self</code>-type of the left-hand-side is known, or dynamically dispatching if the left-hand-side expression is an indirect <a href="#trait-objects">trait object</a>.</p> <h3 id="field-expressions" class="section-header">7.2.7 Field expressions</h3> <p>A <em>field expression</em> consists of an expression followed by a single dot and an identifier, when not immediately followed by a parenthesized expression-list (the latter is a <a href="#method-call-expressions">method call expression</a>). A field expression denotes a field of a <a href="#struct-types">struct</a>.</p> <pre class="rust rust-example-rendered" data-language="rust">
mystruct.myfield;
foo().x;
(Struct {a: 10, b: 20}).a;</pre> <p>A field access is an <a href="#lvalues-rvalues-and-temporaries">lvalue</a> referring to the value of that field. When the type providing the field inherits mutability, it can be <a href="#assignment-expressions">assigned</a> to.</p> <p>Also, if the type of the expression to the left of the dot is a pointer, it is automatically dereferenced as many times as necessary to make the field access possible. In cases of ambiguity, we prefer fewer autoderefs to more.</p> <h3 id="array-expressions" class="section-header">7.2.8 Array expressions</h3> <p>An <a href="#array-and-slice-types">array</a> <em>expression</em> is written by enclosing zero or more comma-separated expressions of uniform type in square brackets.</p> <p>In the <code>[expr ';' expr]</code> form, the expression after the <code>';'</code> must be a constant expression that can be evaluated at compile time, such as a <a href="#literals">literal</a> or a <a href="#static-items">static item</a>.</p> <pre class="rust rust-example-rendered" data-language="rust">
[1, 2, 3, 4];
["a", "b", "c", "d"];
[0; 128];              // array with 128 zeros
[0u8, 0u8, 0u8, 0u8];</pre> <h3 id="index-expressions" class="section-header">7.2.9 Index expressions</h3> <p><a href="#array-and-slice-types">Array</a>-typed expressions can be indexed by writing a square-bracket-enclosed expression (the index) after them. When the array is mutable, the resulting <a href="#lvalues-rvalues-and-temporaries">lvalue</a> can be assigned to.</p> <p>Indices are zero-based, and may be of any integral type. Vector access is bounds-checked at compile-time for constant arrays being accessed with a constant index value. Otherwise a check will be performed at run-time that will put the thread in a <em>panicked state</em> if it fails.</p> <pre>([1, 2, 3, 4])[0];

let x = (["a", "b"])[10]; // compiler error: const index-expr is out of bounds

let n = 10;
let y = (["a", "b"])[n]; // panics

let arr = ["a", "b"];
arr[10]; // panics
</pre> <p>Also, if the type of the expression to the left of the brackets is a pointer, it is automatically dereferenced as many times as necessary to make the indexing possible. In cases of ambiguity, we prefer fewer autoderefs to more.</p> <h3 id="range-expressions" class="section-header">7.2.10 Range expressions</h3> <p>The <code>..</code> operator will construct an object of one of the <code>std::ops::Range</code> variants.</p> <pre class="rust rust-example-rendered" data-language="rust">
1..2;   // std::ops::Range
3..;    // std::ops::RangeFrom
..4;    // std::ops::RangeTo
..;     // std::ops::RangeFull</pre> <p>The following expressions are equivalent.</p> <pre class="rust rust-example-rendered" data-language="rust">
let x = std::ops::Range {start: 0, end: 10};
let y = 0..10;

assert_eq!(x, y);</pre> <p>Similarly, the <code>...</code> operator will construct an object of one of the <code>std::ops::RangeInclusive</code> variants.</p> <pre class="rust rust-example-rendered" data-language="rust">
1...2;   // std::ops::RangeInclusive
...4;    // std::ops::RangeToInclusive</pre> <p>The following expressions are equivalent.</p> <pre class="rust rust-example-rendered" data-language="rust">
let x = std::ops::RangeInclusive::NonEmpty {start: 0, end: 10};
let y = 0...10;

assert_eq!(x, y);</pre> <h3 id="unary-operator-expressions" class="section-header">7.2.11 Unary operator expressions</h3> <p>Rust defines the following unary operators. With the exception of <code>?</code>, they are all written as prefix operators, before the expression they apply to.</p> <ul> <li>
<code>-</code> : Negation. Signed integer types and floating-point types support negation. It is an error to apply negation to unsigned types; for example, the compiler rejects <code>-1u32</code>.</li> <li>
<code>*</code> : Dereference. When applied to a <a href="#pointer-types">pointer</a> it denotes the pointed-to location. For pointers to mutable locations, the resulting <a href="#lvalues-rvalues-and-temporaries">lvalue</a> can be assigned to. On non-pointer types, it calls the <code>deref</code> method of the <code>std::ops::Deref</code> trait, or the <code>deref_mut</code> method of the <code>std::ops::DerefMut</code> trait (if implemented by the type and required for an outer expression that will or could mutate the dereference), and produces the result of dereferencing the <code>&amp;</code> or <code>&amp;mut</code> borrowed pointer returned from the overload method.</li> <li>
<code>!</code> : Logical negation. On the boolean type, this flips between <code>true</code> and <code>false</code>. On integer types, this inverts the individual bits in the two's complement representation of the value.</li> <li>
<code>&amp;</code> and <code>&amp;mut</code> : Borrowing. When applied to an lvalue, these operators produce a reference (pointer) to the lvalue. The lvalue is also placed into a borrowed state for the duration of the reference. For a shared borrow (<code>&amp;</code>), this implies that the lvalue may not be mutated, but it may be read or shared again. For a mutable borrow (<code>&amp;mut</code>), the lvalue may not be accessed in any way until the borrow expires. If the <code>&amp;</code> or <code>&amp;mut</code> operators are applied to an rvalue, a temporary value is created; the lifetime of this temporary value is defined by <a href="#temporary-lifetimes">syntactic rules</a>.</li> <li>
<code>?</code> : Propagating errors if applied to <code>Err(_)</code> and unwrapping if applied to <code>Ok(_)</code>. Only works on the <code>Result&lt;T, E&gt;</code> type, and written in postfix notation.</li> </ul> <h3 id="binary-operator-expressions" class="section-header">7.2.12 Binary operator expressions</h3> <p>Binary operators expressions are given in terms of <a href="#operator-precedence">operator precedence</a>.</p> <h4 id="arithmetic-operators" class="section-header">7.2.12.1 Arithmetic operators</h4> <p>Binary arithmetic expressions are syntactic sugar for calls to built-in traits, defined in the <code>std::ops</code> module of the <code>std</code> library. This means that arithmetic operators can be overridden for user-defined types. The default meaning of the operators on standard types is given here.</p> <ul> <li>
<code>+</code> : Addition and array/string concatenation. Calls the <code>add</code> method on the <code>std::ops::Add</code> trait.</li> <li>
<code>-</code> : Subtraction. Calls the <code>sub</code> method on the <code>std::ops::Sub</code> trait.</li> <li>
<code>*</code> : Multiplication. Calls the <code>mul</code> method on the <code>std::ops::Mul</code> trait.</li> <li>
<code>/</code> : Quotient. Calls the <code>div</code> method on the <code>std::ops::Div</code> trait.</li> <li>
<code>%</code> : Remainder. Calls the <code>rem</code> method on the <code>std::ops::Rem</code> trait.</li> </ul> <h4 id="bitwise-operators" class="section-header">7.2.12.2 Bitwise operators</h4> <p>Like the <a href="#arithmetic-operators">arithmetic operators</a>, bitwise operators are syntactic sugar for calls to methods of built-in traits. This means that bitwise operators can be overridden for user-defined types. The default meaning of the operators on standard types is given here. Bitwise <code>&amp;</code>, <code>|</code> and <code>^</code> applied to boolean arguments are equivalent to logical <code>&amp;&amp;</code>, <code>||</code> and <code>!=</code> evaluated in non-lazy fashion.</p> <ul> <li>
<code>&amp;</code> : Bitwise AND. Calls the <code>bitand</code> method of the <code>std::ops::BitAnd</code> trait.</li> <li>
<code>|</code> : Bitwise inclusive OR. Calls the <code>bitor</code> method of the <code>std::ops::BitOr</code> trait.</li> <li>
<code>^</code> : Bitwise exclusive OR. Calls the <code>bitxor</code> method of the <code>std::ops::BitXor</code> trait.</li> <li>
<code>&lt;&lt;</code> : Left shift. Calls the <code>shl</code> method of the <code>std::ops::Shl</code> trait.</li> <li>
<code>&gt;&gt;</code> : Right shift (arithmetic). Calls the <code>shr</code> method of the <code>std::ops::Shr</code> trait.</li> </ul> <h4 id="lazy-boolean-operators" class="section-header">7.2.12.3 Lazy boolean operators</h4> <p>The operators <code>||</code> and <code>&amp;&amp;</code> may be applied to operands of boolean type. The <code>||</code> operator denotes logical 'or', and the <code>&amp;&amp;</code> operator denotes logical 'and'. They differ from <code>|</code> and <code>&amp;</code> in that the right-hand operand is only evaluated when the left-hand operand does not already determine the result of the expression. That is, <code>||</code> only evaluates its right-hand operand when the left-hand operand evaluates to <code>false</code>, and <code>&amp;&amp;</code> only when it evaluates to <code>true</code>.</p> <h4 id="comparison-operators" class="section-header">7.2.12.4 Comparison operators</h4> <p>Comparison operators are, like the <a href="#arithmetic-operators">arithmetic operators</a>, and <a href="#bitwise-operators">bitwise operators</a>, syntactic sugar for calls to built-in traits. This means that comparison operators can be overridden for user-defined types. The default meaning of the operators on standard types is given here.</p> <ul> <li>
<code>==</code> : Equal to. Calls the <code>eq</code> method on the <code>std::cmp::PartialEq</code> trait.</li> <li>
<code>!=</code> : Unequal to. Calls the <code>ne</code> method on the <code>std::cmp::PartialEq</code> trait.</li> <li>
<code>&lt;</code> : Less than. Calls the <code>lt</code> method on the <code>std::cmp::PartialOrd</code> trait.</li> <li>
<code>&gt;</code> : Greater than. Calls the <code>gt</code> method on the <code>std::cmp::PartialOrd</code> trait.</li> <li>
<code>&lt;=</code> : Less than or equal. Calls the <code>le</code> method on the <code>std::cmp::PartialOrd</code> trait.</li> <li>
<code>&gt;=</code> : Greater than or equal. Calls the <code>ge</code> method on the <code>std::cmp::PartialOrd</code> trait.</li> </ul> <h4 id="type-cast-expressions" class="section-header">7.2.12.5 Type cast expressions</h4> <p>A type cast expression is denoted with the binary operator <code>as</code>.</p> <p>Executing an <code>as</code> expression casts the value on the left-hand side to the type on the right-hand side.</p> <p>An example of an <code>as</code> expression:</p> <pre class="rust rust-example-rendered" data-language="rust">

fn average(values: &amp;[f64]) -&gt; f64 {
    let sum: f64 = sum(values);
    let size: f64 = len(values) as f64;
    sum / size
}</pre> <p>Some of the conversions which can be done through the <code>as</code> operator can also be done implicitly at various points in the program, such as argument passing and assignment to a <code>let</code> binding with an explicit type. Implicit conversions are limited to "harmless" conversions that do not lose information and which have minimal or no risk of surprising side-effects on the dynamic execution semantics.</p> <h4 id="assignment-expressions" class="section-header">7.2.12.6 Assignment expressions</h4> <p>An <em>assignment expression</em> consists of an <a href="#lvalues-rvalues-and-temporaries">lvalue</a> expression followed by an equals sign (<code>=</code>) and an <a href="#lvalues-rvalues-and-temporaries">rvalue</a> expression.</p> <p>Evaluating an assignment expression <a href="#moved-and-copied-types">either copies or moves</a> its right-hand operand to its left-hand operand.</p> <pre class="rust rust-example-rendered" data-language="rust">
x = y;</pre> <h4 id="compound-assignment-expressions" class="section-header">7.2.12.7 Compound assignment expressions</h4> <p>The <code>+</code>, <code>-</code>, <code>*</code>, <code>/</code>, <code>%</code>, <code>&amp;</code>, <code>|</code>, <code>^</code>, <code>&lt;&lt;</code>, and <code>&gt;&gt;</code> operators may be composed with the <code>=</code> operator. The expression <code>lval OP= val</code> is equivalent to <code>lval = lval OP val</code>. For example, <code>x = x + 1</code> may be written as <code>x += 1</code>.</p> <p>Any such expression always has the <a href="#tuple-types"><code>unit</code></a> type.</p> <h4 id="operator-precedence" class="section-header">7.2.12.8 Operator precedence</h4> <p>The precedence of Rust binary operators is ordered as follows, going from strong to weak:</p> <pre>as :
* / %
+ -
&lt;&lt; &gt;&gt;
&amp;
^
|
== != &lt; &gt; &lt;= &gt;=
&amp;&amp;
||
.. ...
&lt;-
=
</pre> <p>Operators at the same precedence level are evaluated left-to-right. <a href="#unary-operator-expressions">Unary operators</a> have the same precedence level and are stronger than any of the binary operators.</p> <h3 id="grouped-expressions" class="section-header">7.2.13 Grouped expressions</h3> <p>An expression enclosed in parentheses evaluates to the result of the enclosed expression. Parentheses can be used to explicitly specify evaluation order within an expression.</p> <p>An example of a parenthesized expression:</p> <pre class="rust rust-example-rendered" data-language="rust">
let x: i32 = (2 + 3) * 4;</pre> <h3 id="call-expressions" class="section-header">7.2.14 Call expressions</h3> <p>A <em>call expression</em> invokes a function, providing zero or more input variables and an optional location to move the function's output into. If the function eventually returns, then the expression completes.</p> <p>Some examples of call expressions:</p> <pre class="rust rust-example-rendered" data-language="rust">

let x: i32 = add(1i32, 2i32);
let pi: Result&lt;f32, _&gt; = "3.14".parse();</pre> <h3 id="lambda-expressions" class="section-header">7.2.15 Lambda expressions</h3> <p>A <em>lambda expression</em> (sometimes called an "anonymous function expression") defines a function and denotes it as a value, in a single expression. A lambda expression is a pipe-symbol-delimited (<code>|</code>) list of identifiers followed by an expression.</p> <p>A lambda expression denotes a function that maps a list of parameters (<code>ident_list</code>) onto the expression that follows the <code>ident_list</code>. The identifiers in the <code>ident_list</code> are the parameters to the function. These parameters' types need not be specified, as the compiler infers them from context.</p> <p>Lambda expressions are most useful when passing functions as arguments to other functions, as an abbreviation for defining and capturing a separate function.</p> <p>Significantly, lambda expressions <em>capture their environment</em>, which regular <a href="#functions">function definitions</a> do not. The exact type of capture depends on the <a href="#function-types">function type</a> inferred for the lambda expression. In the simplest and least-expensive form (analogous to a <code>|| { }</code> expression), the lambda expression captures its environment by reference, effectively borrowing pointers to all outer variables mentioned inside the function. Alternately, the compiler may infer that a lambda expression should copy or move values (depending on their type) from the environment into the lambda expression's captured environment. A lambda can be forced to capture its environment by moving values by prefixing it with the <code>move</code> keyword.</p> <p>In this example, we define a function <code>ten_times</code> that takes a higher-order function argument, and we then call it with a lambda expression as an argument, followed by a lambda expression that moves values from its environment.</p> <pre class="rust rust-example-rendered" data-language="rust">
fn ten_times&lt;F&gt;(f: F) where F: Fn(i32) {
    for index in 0..10 {
        f(index);
    }
}

ten_times(|j| println!("hello, {}", j));

let word = "konnichiwa".to_owned();
ten_times(move |j| println!("{}, {}", word, j));</pre> <h3 id="infinite-loops" class="section-header">7.2.16 Infinite loops</h3> <p>A <code>loop</code> expression denotes an infinite loop.</p> <p>A <code>loop</code> expression may optionally have a <em>label</em>. The label is written as a lifetime preceding the loop expression, as in <code>'foo: loop{ }</code>. If a label is present, then labeled <code>break</code> and <code>continue</code> expressions nested within this loop may exit out of this loop or return control to its head. See <a href="#break-expressions">break expressions</a> and <a href="#continue-expressions">continue expressions</a>.</p> <h3 id="break-expressions" class="section-header">7.2.17 <code>break</code> expressions</h3> <p>A <code>break</code> expression has an optional <em>label</em>. If the label is absent, then executing a <code>break</code> expression immediately terminates the innermost loop enclosing it. It is only permitted in the body of a loop. If the label is present, then <code>break 'foo</code> terminates the loop with label <code>'foo</code>, which need not be the innermost label enclosing the <code>break</code> expression, but must enclose it.</p> <h3 id="continue-expressions" class="section-header">7.2.18 <code>continue</code> expressions</h3> <p>A <code>continue</code> expression has an optional <em>label</em>. If the label is absent, then executing a <code>continue</code> expression immediately terminates the current iteration of the innermost loop enclosing it, returning control to the loop <em>head</em>. In the case of a <code>while</code> loop, the head is the conditional expression controlling the loop. In the case of a <code>for</code> loop, the head is the call-expression controlling the loop. If the label is present, then <code>continue 'foo</code> returns control to the head of the loop with label <code>'foo</code>, which need not be the innermost label enclosing the <code>continue</code> expression, but must enclose it.</p> <p>A <code>continue</code> expression is only permitted in the body of a loop.</p> <h3 id="while-loops" class="section-header">7.2.19 <code>while</code> loops</h3> <p>A <code>while</code> loop begins by evaluating the boolean loop conditional expression. If the loop conditional expression evaluates to <code>true</code>, the loop body block executes and control returns to the loop conditional expression. If the loop conditional expression evaluates to <code>false</code>, the <code>while</code> expression completes.</p> <p>An example:</p> <pre class="rust rust-example-rendered" data-language="rust">
let mut i = 0;

while i &lt; 10 {
    println!("hello");
    i = i + 1;
}</pre> <p>Like <code>loop</code> expressions, <code>while</code> loops can be controlled with <code>break</code> or <code>continue</code>, and may optionally have a <em>label</em>. See <a href="#infinite-loops">infinite loops</a>, <a href="#break-expressions">break expressions</a>, and <a href="#continue-expressions">continue expressions</a> for more information.</p> <h3 id="for-expressions" class="section-header">7.2.20 <code>for</code> expressions</h3> <p>A <code>for</code> expression is a syntactic construct for looping over elements provided by an implementation of <code>std::iter::IntoIterator</code>.</p> <p>An example of a <code>for</code> loop over the contents of an array:</p> <pre class="rust rust-example-rendered" data-language="rust">

let v: &amp;[Foo] = &amp;[a, b, c];

for e in v {
    bar(e);
}</pre> <p>An example of a for loop over a series of integers:</p> <pre class="rust rust-example-rendered" data-language="rust">
for i in 0..256 {
    bar(i);
}</pre> <p>Like <code>loop</code> expressions, <code>for</code> loops can be controlled with <code>break</code> or <code>continue</code>, and may optionally have a <em>label</em>. See <a href="#infinite-loops">infinite loops</a>, <a href="#break-expressions">break expressions</a>, and <a href="#continue-expressions">continue expressions</a> for more information.</p> <h3 id="if-expressions" class="section-header">7.2.21 <code>if</code> expressions</h3> <p>An <code>if</code> expression is a conditional branch in program control. The form of an <code>if</code> expression is a condition expression, followed by a consequent block, any number of <code>else if</code> conditions and blocks, and an optional trailing <code>else</code> block. The condition expressions must have type <code>bool</code>. If a condition expression evaluates to <code>true</code>, the consequent block is executed and any subsequent <code>else if</code> or <code>else</code> block is skipped. If a condition expression evaluates to <code>false</code>, the consequent block is skipped and any subsequent <code>else if</code> condition is evaluated. If all <code>if</code> and <code>else if</code> conditions evaluate to <code>false</code> then any <code>else</code> block is executed.</p> <h3 id="match-expressions" class="section-header">7.2.22 <code>match</code> expressions</h3> <p>A <code>match</code> expression branches on a <em>pattern</em>. The exact form of matching that occurs depends on the pattern. Patterns consist of some combination of literals, destructured arrays or enum constructors, structs and tuples, variable binding specifications, wildcards (<code>..</code>), and placeholders (<code>_</code>). A <code>match</code> expression has a <em>head expression</em>, which is the value to compare to the patterns. The type of the patterns must equal the type of the head expression.</p> <p>In a pattern whose head expression has an <code>enum</code> type, a placeholder (<code>_</code>) stands for a <em>single</em> data field, whereas a wildcard <code>..</code> stands for <em>all</em> the fields of a particular variant.</p> <p>A <code>match</code> behaves differently depending on whether or not the head expression is an <a href="#lvalues-rvalues-and-temporaries">lvalue or an rvalue</a>. If the head expression is an rvalue, it is first evaluated into a temporary location, and the resulting value is sequentially compared to the patterns in the arms until a match is found. The first arm with a matching pattern is chosen as the branch target of the <code>match</code>, any variables bound by the pattern are assigned to local variables in the arm's block, and control enters the block.</p> <p>When the head expression is an lvalue, the match does not allocate a temporary location (however, a by-value binding may copy or move from the lvalue). When possible, it is preferable to match on lvalues, as the lifetime of these matches inherits the lifetime of the lvalue, rather than being restricted to the inside of the match.</p> <p>An example of a <code>match</code> expression:</p> <pre class="rust rust-example-rendered" data-language="rust">
let x = 1;

match x {
    1 =&gt; println!("one"),
    2 =&gt; println!("two"),
    3 =&gt; println!("three"),
    4 =&gt; println!("four"),
    5 =&gt; println!("five"),
    _ =&gt; println!("something else"),
}</pre> <p>Patterns that bind variables default to binding to a copy or move of the matched value (depending on the matched value's type). This can be changed to bind to a reference by using the <code>ref</code> keyword, or to a mutable reference using <code>ref mut</code>.</p> <p>Subpatterns can also be bound to variables by the use of the syntax <code>variable @ subpattern</code>. For example:</p> <pre class="rust rust-example-rendered" data-language="rust">
let x = 1;

match x {
    e @ 1 ... 5 =&gt; println!("got a range element {}", e),
    _ =&gt; println!("anything"),
}</pre> <p>Patterns can also dereference pointers by using the <code>&amp;</code>, <code>&amp;mut</code> and <code>box</code> symbols, as appropriate. For example, these two matches on <code>x: &amp;i32</code> are equivalent:</p> <pre class="rust rust-example-rendered" data-language="rust">
let y = match *x { 0 =&gt; "zero", _ =&gt; "some" };
let z = match x { &amp;0 =&gt; "zero", _ =&gt; "some" };

assert_eq!(y, z);</pre> <p>Multiple match patterns may be joined with the <code>|</code> operator. A range of values may be specified with <code>...</code>. For example:</p> <pre class="rust rust-example-rendered" data-language="rust">

let message = match x {
    0 | 1  =&gt; "not many",
    2 ... 9 =&gt; "a few",
    _      =&gt; "lots"
};</pre> <p>Range patterns only work on scalar types (like integers and characters; not like arrays and structs, which have sub-components). A range pattern may not be a sub-range of another range pattern inside the same <code>match</code>.</p> <p>Finally, match patterns can accept <em>pattern guards</em> to further refine the criteria for matching a case. Pattern guards appear after the pattern and consist of a bool-typed expression following the <code>if</code> keyword. A pattern guard may refer to the variables bound within the pattern they follow.</p> <pre class="rust rust-example-rendered" data-language="rust">

let message = match maybe_digit {
    Some(x) if x &lt; 10 =&gt; process_digit(x),
    Some(x) =&gt; process_other(x),
    None =&gt; panic!(),
};</pre> <h3 id="if-let-expressions" class="section-header">7.2.23 <code>if let</code> expressions</h3> <p>An <code>if let</code> expression is semantically identical to an <code>if</code> expression but in place of a condition expression it expects a <code>let</code> statement with a refutable pattern. If the value of the expression on the right hand side of the <code>let</code> statement matches the pattern, the corresponding block will execute, otherwise flow proceeds to the first <code>else</code> block that follows.</p> <pre class="rust rust-example-rendered" data-language="rust">
let dish = ("Ham", "Eggs");

// this body will be skipped because the pattern is refuted
if let ("Bacon", b) = dish {
    println!("Bacon is served with {}", b);
}

// this body will execute
if let ("Ham", b) = dish {
    println!("Ham is served with {}", b);
}</pre> <h3 id="while-let-loops" class="section-header">7.2.24 <code>while let</code> loops</h3> <p>A <code>while let</code> loop is semantically identical to a <code>while</code> loop but in place of a condition expression it expects <code>let</code> statement with a refutable pattern. If the value of the expression on the right hand side of the <code>let</code> statement matches the pattern, the loop body block executes and control returns to the pattern matching statement. Otherwise, the while expression completes.</p> <h3 id="return-expressions" class="section-header">7.2.25 <code>return</code> expressions</h3> <p>Return expressions are denoted with the keyword <code>return</code>. Evaluating a <code>return</code> expression moves its argument into the designated output location for the current function call, destroys the current function activation frame, and transfers control to the caller frame.</p> <p>An example of a <code>return</code> expression:</p> <pre class="rust rust-example-rendered" data-language="rust">
fn max(a: i32, b: i32) -&gt; i32 {
    if a &gt; b {
        return a;
    }
    return b;
}</pre> <h2 id="type-system" class="section-header">8 Type system</h2> <h3 id="types" class="section-header">8.1 Types</h3> <p>Every variable, item and value in a Rust program has a type. The <em>type</em> of a <em>value</em> defines the interpretation of the memory holding it.</p> <p>Built-in types and type-constructors are tightly integrated into the language, in nontrivial ways that are not possible to emulate in user-defined types. User-defined types have limited capabilities.</p> <h3 id="primitive-types" class="section-header">8.1.1 Primitive types</h3> <p>The primitive types are the following:</p> <ul> <li>The boolean type <code>bool</code> with values <code>true</code> and <code>false</code>.</li> <li>The machine types (integer and floating-point).</li> <li>The machine-dependent integer types.</li> <li>Arrays</li> <li>Tuples</li> <li>Slices</li> <li>Function pointers</li> </ul> <h4 id="machine-types" class="section-header">8.1.1.1 Machine types</h4> <p>The machine types are the following:</p> <ul> <li><p>The unsigned word types <code>u8</code>, <code>u16</code>, <code>u32</code> and <code>u64</code>, with values drawn from the integer intervals [0, 2<sup>8</sup> - 1], [0, 2<sup>16</sup> - 1], [0, 2<sup>32</sup> - 1] and [0, 2<sup>64</sup> - 1] respectively.</p></li> <li><p>The signed two's complement word types <code>i8</code>, <code>i16</code>, <code>i32</code> and <code>i64</code>, with values drawn from the integer intervals [-(2<sup>7</sup>), 2<sup>7</sup> - 1], [-(2<sup>15</sup>), 2<sup>15</sup> - 1], [-(2<sup>31</sup>), 2<sup>31</sup> - 1], [-(2<sup>63</sup>), 2<sup>63</sup> - 1] respectively.</p></li> <li><p>The IEEE 754-2008 <code>binary32</code> and <code>binary64</code> floating-point types: <code>f32</code> and <code>f64</code>, respectively.</p></li> </ul> <h4 id="machine-dependent-integer-types" class="section-header">8.1.1.2 Machine-dependent integer types</h4> <p>The <code>usize</code> type is an unsigned integer type with the same number of bits as the platform's pointer type. It can represent every memory address in the process.</p> <p>The <code>isize</code> type is a signed integer type with the same number of bits as the platform's pointer type. The theoretical upper bound on object and array size is the maximum <code>isize</code> value. This ensures that <code>isize</code> can be used to calculate differences between pointers into an object or array and can address every byte within an object along with one byte past the end.</p> <h3 id="textual-types" class="section-header">8.1.2 Textual types</h3> <p>The types <code>char</code> and <code>str</code> hold textual data.</p> <p>A value of type <code>char</code> is a <a href="http://www.unicode.org/glossary/#unicode_scalar_value" target="_blank">Unicode scalar value</a> (i.e. a code point that is not a surrogate), represented as a 32-bit unsigned word in the 0x0000 to 0xD7FF or 0xE000 to 0x10FFFF range. A <code>[char]</code> array is effectively an UCS-4 / UTF-32 string.</p> <p>A value of type <code>str</code> is a Unicode string, represented as an array of 8-bit unsigned bytes holding a sequence of UTF-8 code points. Since <code>str</code> is of unknown size, it is not a <em>first-class</em> type, but can only be instantiated through a pointer type, such as <code>&amp;str</code>.</p> <h3 id="tuple-types" class="section-header">8.1.3 Tuple types</h3> <p>A tuple <em>type</em> is a heterogeneous product of other types, called the <em>elements</em> of the tuple. It has no nominal name and is instead structurally typed.</p> <p>Tuple types and values are denoted by listing the types or values of their elements, respectively, in a parenthesized, comma-separated list.</p> <p>Because tuple elements don't have a name, they can only be accessed by pattern-matching or by using <code>N</code> directly as a field to access the <code>N</code>th element.</p> <p>An example of a tuple type and its use:</p> <pre class="rust rust-example-rendered" data-language="rust">
type Pair&lt;'a&gt; = (i32, &amp;'a str);
let p: Pair&lt;'static&gt; = (10, "ten");
let (a, b) = p;

assert_eq!(a, 10);
assert_eq!(b, "ten");
assert_eq!(p.0, 10);
assert_eq!(p.1, "ten");</pre> <p>For historical reasons and convenience, the tuple type with no elements (<code>()</code>) is often called ‘unit’ or ‘the unit type’.</p> <h3 id="array-and-slice-types" class="section-header">8.1.4 Array, and Slice types</h3> <p>Rust has two different types for a list of items:</p> <ul> <li>
<code>[T; N]</code>, an 'array'</li> <li>
<code>&amp;[T]</code>, a 'slice'</li> </ul> <p>An array has a fixed size, and can be allocated on either the stack or the heap.</p> <p>A slice is a 'view' into an array. It doesn't own the data it points to, it borrows it.</p> <p>Examples:</p> <pre class="rust rust-example-rendered" data-language="rust">
// A stack-allocated array
let array: [i32; 3] = [1, 2, 3];

// A heap-allocated array
let vector: Vec&lt;i32&gt; = vec![1, 2, 3];

// A slice into an array
let slice: &amp;[i32] = &amp;vector[..];</pre> <p>As you can see, the <code>vec!</code> macro allows you to create a <code>Vec&lt;T&gt;</code> easily. The <code>vec!</code> macro is also part of the standard library, rather than the language.</p> <p>All in-bounds elements of arrays and slices are always initialized, and access to an array or slice is always bounds-checked.</p> <h3 id="struct-types" class="section-header">8.1.5 Struct types</h3> <p>A <code>struct</code> <em>type</em> is a heterogeneous product of other types, called the <em>fields</em> of the type.<sup id="fnref5"><a href="#fn5" rel="footnote">5</a></sup></p> <p>New instances of a <code>struct</code> can be constructed with a <a href="#struct-expressions">struct expression</a>.</p> <p>The memory layout of a <code>struct</code> is undefined by default to allow for compiler optimizations like field reordering, but it can be fixed with the <code>#[repr(...)]</code> attribute. In either case, fields may be given in any order in a corresponding struct <em>expression</em>; the resulting <code>struct</code> value will always have the same memory layout.</p> <p>The fields of a <code>struct</code> may be qualified by <a href="#visibility-and-privacy">visibility modifiers</a>, to allow access to data in a struct outside a module.</p> <p>A <em>tuple struct</em> type is just like a struct type, except that the fields are anonymous.</p> <p>A <em>unit-like struct</em> type is like a struct type, except that it has no fields. The one value constructed by the associated <a href="#struct-expressions">struct expression</a> is the only value that inhabits such a type.</p> <h3 id="enumerated-types" class="section-header">8.1.6 Enumerated types</h3> <p>An <em>enumerated type</em> is a nominal, heterogeneous disjoint union type, denoted by the name of an <a href="#enumerations"><code>enum</code> item</a>. <sup id="fnref6"><a href="#fn6" rel="footnote">6</a></sup></p> <p>An <a href="#enumerations"><code>enum</code> item</a> declares both the type and a number of <em>variant constructors</em>, each of which is independently named and takes an optional tuple of arguments.</p> <p>New instances of an <code>enum</code> can be constructed by calling one of the variant constructors, in a <a href="#call-expressions">call expression</a>.</p> <p>Any <code>enum</code> value consumes as much memory as the largest variant constructor for its corresponding <code>enum</code> type.</p> <p>Enum types cannot be denoted <em>structurally</em> as types, but must be denoted by named reference to an <a href="#enumerations"><code>enum</code> item</a>.</p> <h3 id="recursive-types" class="section-header">8.1.7 Recursive types</h3> <p>Nominal types — <a href="#enumerated-types">enumerations</a> and <a href="#struct-types">structs</a> — may be recursive. That is, each <code>enum</code> constructor or <code>struct</code> field may refer, directly or indirectly, to the enclosing <code>enum</code> or <code>struct</code> type itself. Such recursion has restrictions:</p> <ul> <li>Recursive types must include a nominal type in the recursion (not mere <a href="https://doc.rust-lang.org/grammar.html#type-definitions" target="_blank">type definitions</a>, or other structural types such as <a href="#array-and-slice-types">arrays</a> or <a href="#tuple-types">tuples</a>).</li> <li>A recursive <code>enum</code> item must have at least one non-recursive constructor (in order to give the recursion a basis case).</li> <li>The size of a recursive type must be finite; in other words the recursive fields of the type must be <a href="#pointer-types">pointer types</a>.</li> <li>Recursive type definitions can cross module boundaries, but not module <em>visibility</em> boundaries, or crate boundaries (in order to simplify the module system and type checker).</li> </ul> <p>An example of a <em>recursive</em> type and its use:</p> <pre class="rust rust-example-rendered" data-language="rust">
enum List&lt;T&gt; {
    Nil,
    Cons(T, Box&lt;List&lt;T&gt;&gt;)
}

let a: List&lt;i32&gt; = List::Cons(7, Box::new(List::Cons(13, Box::new(List::Nil))));</pre> <h3 id="pointer-types" class="section-header">8.1.8 Pointer types</h3> <p>All pointers in Rust are explicit first-class values. They can be copied, stored into data structs, and returned from functions. There are two varieties of pointer in Rust:</p> <ul> <li><p>References (<code>&amp;</code>) : These point to memory <em>owned by some other value</em>. A reference type is written <code>&amp;type</code>, or <code>&amp;'a type</code> when you need to specify an explicit lifetime. Copying a reference is a "shallow" operation: it involves only copying the pointer itself. Releasing a reference has no effect on the value it points to, but a reference of a temporary value will keep it alive during the scope of the reference itself.</p></li> <li><p>Raw pointers (<code>*</code>) : Raw pointers are pointers without safety or liveness guarantees. Raw pointers are written as <code>*const T</code> or <code>*mut T</code>, for example <code>*const i32</code> means a raw pointer to a 32-bit integer. Copying or dropping a raw pointer has no effect on the lifecycle of any other value. Dereferencing a raw pointer or converting it to any other pointer type is an <a href="#unsafe-functions"><code>unsafe</code> operation</a>. Raw pointers are generally discouraged in Rust code; they exist to support interoperability with foreign code, and writing performance-critical or low-level functions.</p></li> </ul> <p>The standard library contains additional 'smart pointer' types beyond references and raw pointers.</p> <h3 id="function-types" class="section-header">8.1.9 Function types</h3> <p>The function type constructor <code>fn</code> forms new function types. A function type consists of a possibly-empty set of function-type modifiers (such as <code>unsafe</code> or <code>extern</code>), a sequence of input types and an output type.</p> <p>An example of a <code>fn</code> type:</p> <pre class="rust rust-example-rendered" data-language="rust">
fn add(x: i32, y: i32) -&gt; i32 {
    x + y
}

let mut x = add(5,7);

type Binop = fn(i32, i32) -&gt; i32;
let bo: Binop = add;
x = bo(5,7);</pre> <h4 id="function-types-for-specific-items" class="section-header">8.1.9.1 Function types for specific items</h4> <p>Internal to the compiler, there are also function types that are specific to a particular function item. In the following snippet, for example, the internal types of the functions <code>foo</code> and <code>bar</code> are different, despite the fact that they have the same signature:</p> <pre class="rust rust-example-rendered" data-language="rust">
fn foo() { }
fn bar() { }</pre> <p>The types of <code>foo</code> and <code>bar</code> can both be implicitly coerced to the fn pointer type <code>fn()</code>. There is currently no syntax for unique fn types, though the compiler will emit a type like <code>fn() {foo}</code> in error messages to indicate "the unique fn type for the function <code>foo</code>".</p> <h3 id="closure-types" class="section-header">8.1.10 Closure types</h3> <p>A <a href="#lambda-expressions">lambda expression</a> produces a closure value with a unique, anonymous type that cannot be written out.</p> <p>Depending on the requirements of the closure, its type implements one or more of the closure traits:</p> <ul> <li><p><code>FnOnce</code> : The closure can be called once. A closure called as <code>FnOnce</code> can move out values from its environment.</p></li> <li><p><code>FnMut</code> : The closure can be called multiple times as mutable. A closure called as <code>FnMut</code> can mutate values from its environment. <code>FnMut</code> inherits from <code>FnOnce</code> (i.e. anything implementing <code>FnMut</code> also implements <code>FnOnce</code>).</p></li> <li><p><code>Fn</code> : The closure can be called multiple times through a shared reference. A closure called as <code>Fn</code> can neither move out from nor mutate values from its environment. <code>Fn</code> inherits from <code>FnMut</code>, which itself inherits from <code>FnOnce</code>.</p></li> </ul> <h3 id="trait-objects" class="section-header">8.1.11 Trait objects</h3> <p>In Rust, a type like <code>&amp;SomeTrait</code> or <code>Box&lt;SomeTrait&gt;</code> is called a <em>trait object</em>. Each instance of a trait object includes:</p> <ul> <li>a pointer to an instance of a type <code>T</code> that implements <code>SomeTrait</code>
</li> <li>a <em>virtual method table</em>, often just called a <em>vtable</em>, which contains, for each method of <code>SomeTrait</code> that <code>T</code> implements, a pointer to <code>T</code>'s implementation (i.e. a function pointer).</li> </ul> <p>The purpose of trait objects is to permit "late binding" of methods. Calling a method on a trait object results in virtual dispatch at runtime: that is, a function pointer is loaded from the trait object vtable and invoked indirectly. The actual implementation for each vtable entry can vary on an object-by-object basis.</p> <p>Note that for a trait object to be instantiated, the trait must be <em>object-safe</em>. Object safety rules are defined in <a href="https://github.com/rust-lang/rfcs/blob/master/text/0255-object-safety.md" target="_blank">RFC 255</a>.</p> <p>Given a pointer-typed expression <code>E</code> of type <code>&amp;T</code> or <code>Box&lt;T&gt;</code>, where <code>T</code> implements trait <code>R</code>, casting <code>E</code> to the corresponding pointer type <code>&amp;R</code> or <code>Box&lt;R&gt;</code> results in a value of the <em>trait object</em> <code>R</code>. This result is represented as a pair of pointers: the vtable pointer for the <code>T</code> implementation of <code>R</code>, and the pointer value of <code>E</code>.</p> <p>An example of a trait object:</p> <pre class="rust rust-example-rendered" data-language="rust">
trait Printable {
    fn stringify(&amp;self) -&gt; String;
}

impl Printable for i32 {
    fn stringify(&amp;self) -&gt; String { self.to_string() }
}

fn print(a: Box&lt;Printable&gt;) {
    println!("{}", a.stringify());
}

fn main() {
    print(Box::new(10) as Box&lt;Printable&gt;);
}</pre> <p>In this example, the trait <code>Printable</code> occurs as a trait object in both the type signature of <code>print</code>, and the cast expression in <code>main</code>.</p> <h3 id="type-parameters-1" class="section-header">8.1.12 Type parameters</h3> <p>Within the body of an item that has type parameter declarations, the names of its type parameters are types:</p> <pre class="rust rust-example-rendered" data-language="rust">
fn to_vec&lt;A: Clone&gt;(xs: &amp;[A]) -&gt; Vec&lt;A&gt; {
    if xs.is_empty() {
        return vec![];
    }
    let first: A = xs[0].clone();
    let mut rest: Vec&lt;A&gt; = to_vec(&amp;xs[1..]);
    rest.insert(0, first);
    rest
}</pre> <p>Here, <code>first</code> has type <code>A</code>, referring to <code>to_vec</code>'s <code>A</code> type parameter; and <code>rest</code> has type <code>Vec&lt;A&gt;</code>, a vector with element type <code>A</code>.</p> <h3 id="self-types" class="section-header">8.1.13 Self types</h3> <p>The special type <code>Self</code> has a meaning within traits and impls. In a trait definition, it refers to an implicit type parameter representing the "implementing" type. In an impl, it is an alias for the implementing type. For example, in:</p> <pre class="rust rust-example-rendered" data-language="rust">
pub trait From&lt;T&gt; {
    fn from(T) -&gt; Self;
}

impl From&lt;i32&gt; for String {
    fn from(x: i32) -&gt; Self {
        x.to_string()
    }
}</pre> <p>The notation <code>Self</code> in the impl refers to the implementing type: <code>String</code>. In another example:</p> <pre class="rust rust-example-rendered" data-language="rust">
trait Printable {
    fn make_string(&amp;self) -&gt; String;
}

impl Printable for String {
    fn make_string(&amp;self) -&gt; String {
        (*self).clone()
    }
}</pre> <p>The notation <code>&amp;self</code> is a shorthand for <code>self: &amp;Self</code>. In this case, in the impl, <code>Self</code> refers to the value of type <code>String</code> that is the receiver for a call to the method <code>make_string</code>.</p> <h3 id="subtyping" class="section-header">8.2 Subtyping</h3> <p>Subtyping is implicit and can occur at any stage in type checking or inference. Subtyping in Rust is very restricted and occurs only due to variance with respect to lifetimes and between types with higher ranked lifetimes. If we were to erase lifetimes from types, then the only subtyping would be due to type equality.</p> <p>Consider the following example: string literals always have <code>'static</code> lifetime. Nevertheless, we can assign <code>s</code> to <code>t</code>:</p> <pre class="rust rust-example-rendered" data-language="rust">
fn bar&lt;'a&gt;() {
    let s: &amp;'static str = "hi";
    let t: &amp;'a str = s;
}</pre> <p>Since <code>'static</code> "lives longer" than <code>'a</code>, <code>&amp;'static str</code> is a subtype of <code>&amp;'a str</code>.</p> <h3 id="type-coercions" class="section-header">8.3 Type coercions</h3> <p>Coercions are defined in <a href="https://github.com/rust-lang/rfcs/blob/master/text/0401-coercions.md" target="_blank">RFC 401</a>. A coercion is implicit and has no syntax.</p> <h3 id="coercion-sites" class="section-header">8.3.1 Coercion sites</h3> <p>A coercion can only occur at certain coercion sites in a program; these are typically places where the desired type is explicit or can be derived by propagation from explicit types (without type inference). Possible coercion sites are:</p> <ul> <li>
<p><code>let</code> statements where an explicit type is given.</p> <p>For example, <code>42</code> is coerced to have type <code>i8</code> in the following:</p> <pre class="rust rust-example-rendered" data-language="rust">
let _: i8 = 42;</pre>
</li> <li><p><code>static</code> and <code>const</code> statements (similar to <code>let</code> statements).</p></li> <li>
<p>Arguments for function calls</p> <p>The value being coerced is the actual parameter, and it is coerced to the type of the formal parameter.</p> <p>For example, <code>42</code> is coerced to have type <code>i8</code> in the following:</p> <pre class="rust rust-example-rendered" data-language="rust">
fn bar(_: i8) { }

fn main() {
  bar(42);
}</pre>
</li> <li>
<p>Instantiations of struct or variant fields</p> <p>For example, <code>42</code> is coerced to have type <code>i8</code> in the following:</p> <pre class="rust rust-example-rendered" data-language="rust">
struct Foo { x: i8 }

fn main() {
  Foo { x: 42 };
}</pre>
</li> <li>
<p>Function results, either the final line of a block if it is not semicolon-terminated or any expression in a <code>return</code> statement</p> <p>For example, <code>42</code> is coerced to have type <code>i8</code> in the following:</p> <pre class="rust rust-example-rendered" data-language="rust">
fn foo() -&gt; i8 {
  42
}</pre>
</li> </ul> <p>If the expression in one of these coercion sites is a coercion-propagating expression, then the relevant sub-expressions in that expression are also coercion sites. Propagation recurses from these new coercion sites. Propagating expressions and their relevant sub-expressions are:</p> <ul> <li><p>Array literals, where the array has type <code>[U; n]</code>. Each sub-expression in the array literal is a coercion site for coercion to type <code>U</code>.</p></li> <li><p>Array literals with repeating syntax, where the array has type <code>[U; n]</code>. The repeated sub-expression is a coercion site for coercion to type <code>U</code>.</p></li> <li><p>Tuples, where a tuple is a coercion site to type <code>(U_0, U_1, ..., U_n)</code>. Each sub-expression is a coercion site to the respective type, e.g. the zeroth sub-expression is a coercion site to type <code>U_0</code>.</p></li> <li><p>Parenthesized sub-expressions (<code>(e)</code>): if the expression has type <code>U</code>, then the sub-expression is a coercion site to <code>U</code>.</p></li> <li><p>Blocks: if a block has type <code>U</code>, then the last expression in the block (if it is not semicolon-terminated) is a coercion site to <code>U</code>. This includes blocks which are part of control flow statements, such as <code>if</code>/<code>else</code>, if the block has a known type.</p></li> </ul> <h3 id="coercion-types" class="section-header">8.3.2 Coercion types</h3> <p>Coercion is allowed between the following types:</p> <ul> <li><p><code>T</code> to <code>U</code> if <code>T</code> is a subtype of <code>U</code> (<em>reflexive case</em>)</p></li> <li>
<p><code>T_1</code> to <code>T_3</code> where <code>T_1</code> coerces to <code>T_2</code> and <code>T_2</code> coerces to <code>T_3</code> (<em>transitive case</em>)</p> <p>Note that this is not fully supported yet</p>
</li> <li><p><code>&amp;mut T</code> to <code>&amp;T</code></p></li> <li><p><code>*mut T</code> to <code>*const T</code></p></li> <li><p><code>&amp;T</code> to <code>*const T</code></p></li> <li><p><code>&amp;mut T</code> to <code>*mut T</code></p></li> <li>
<p><code>&amp;T</code> to <code>&amp;U</code> if <code>T</code> implements <code>Deref&lt;Target = U&gt;</code>. For example:</p> <pre class="rust rust-example-rendered" data-language="rust">
use std::ops::Deref;

struct CharContainer {
  value: char,
}

impl Deref for CharContainer {
  type Target = char;

  fn deref&lt;'a&gt;(&amp;'a self) -&gt; &amp;'a char {
      &amp;self.value
  }
}

fn foo(arg: &amp;char) {}

fn main() {
  let x = &amp;mut CharContainer { value: 'y' };
  foo(x); //&amp;mut CharContainer is coerced to &amp;char.
}</pre>
</li> <li><p><code>&amp;mut T</code> to <code>&amp;mut U</code> if <code>T</code> implements <code>DerefMut&lt;Target = U&gt;</code>.</p></li> <li>
<p>TyCtor(<code>T</code>) to TyCtor(coerce_inner(<code>T</code>)), where TyCtor(<code>T</code>) is one of</p> <ul> <li><code>&amp;T</code></li> <li><code>&amp;mut T</code></li> <li><code>*const T</code></li> <li><code>*mut T</code></li> <li><code>Box&lt;T&gt;</code></li> </ul> <p>and where - coerce_inner(<code>[T, ..n]</code>) = <code>[T]</code> - coerce_inner(<code>T</code>) = <code>U</code> where <code>T</code> is a concrete type which implements the trait <code>U</code>.</p> <p>In the future, coerce_inner will be recursively extended to tuples and structs. In addition, coercions from sub-traits to super-traits will be added. See <a href="https://github.com/rust-lang/rfcs/blob/master/text/0401-coercions.md" target="_blank">RFC 401</a> for more details.</p>
</li> </ul> <h2 id="special-traits" class="section-header">9 Special traits</h2> <p>Several traits define special evaluation behavior.</p> <h3 id="the-copy-trait" class="section-header">9.1 The <code>Copy</code> trait</h3> <p>The <code>Copy</code> trait changes the semantics of a type implementing it. Values whose type implements <code>Copy</code> are copied rather than moved upon assignment.</p> <h3 id="the-sized-trait" class="section-header">9.2 The <code>Sized</code> trait</h3> <p>The <code>Sized</code> trait indicates that the size of this type is known at compile-time.</p> <h3 id="the-drop-trait" class="section-header">9.3 The <code>Drop</code> trait</h3> <p>The <code>Drop</code> trait provides a destructor, to be run whenever a value of this type is to be destroyed.</p> <h3 id="the-deref-trait" class="section-header">9.4 The <code>Deref</code> trait</h3> <p>The <code>Deref&lt;Target = U&gt;</code> trait allows a type to implicitly implement all the methods of the type <code>U</code>. When attempting to resolve a method call, the compiler will search the top-level type for the implementation of the called method. If no such method is found, <code>.deref()</code> is called and the compiler continues to search for the method implementation in the returned type <code>U</code>.</p> <h3 id="the-send-trait" class="section-header">9.5 The <code>Send</code> trait</h3> <p>The <code>Send</code> trait indicates that a value of this type is safe to send from one thread to another.</p> <h3 id="the-sync-trait" class="section-header">9.6 The <code>Sync</code> trait</h3> <p>The <code>Sync</code> trait indicates that a value of this type is safe to share between multiple threads.</p> <h2 id="memory-model" class="section-header">10 Memory model</h2> <p>A Rust program's memory consists of a static set of <em>items</em> and a <em>heap</em>. Immutable portions of the heap may be safely shared between threads, mutable portions may not be safely shared, but several mechanisms for effectively-safe sharing of mutable values, built on unsafe code but enforcing a safe locking discipline, exist in the standard library.</p> <p>Allocations in the stack consist of <em>variables</em>, and allocations in the heap consist of <em>boxes</em>.</p> <h3 id="memory-allocation-and-lifetime" class="section-header">10.0.1 Memory allocation and lifetime</h3> <p>The <em>items</em> of a program are those functions, modules and types that have their value calculated at compile-time and stored uniquely in the memory image of the rust process. Items are neither dynamically allocated nor freed.</p> <p>The <em>heap</em> is a general term that describes boxes. The lifetime of an allocation in the heap depends on the lifetime of the box values pointing to it. Since box values may themselves be passed in and out of frames, or stored in the heap, heap allocations may outlive the frame they are allocated within. An allocation in the heap is guaranteed to reside at a single location in the heap for the whole lifetime of the allocation - it will never be relocated as a result of moving a box value.</p> <h3 id="memory-ownership" class="section-header">10.0.2 Memory ownership</h3> <p>When a stack frame is exited, its local allocations are all released, and its references to boxes are dropped.</p> <h3 id="variables" class="section-header">10.0.3 Variables</h3> <p>A <em>variable</em> is a component of a stack frame, either a named function parameter, an anonymous <a href="#lvalues-rvalues-and-temporaries">temporary</a>, or a named local variable.</p> <p>A <em>local variable</em> (or <em>stack-local</em> allocation) holds a value directly, allocated within the stack's memory. The value is a part of the stack frame.</p> <p>Local variables are immutable unless declared otherwise like: <code>let mut x = ...</code>.</p> <p>Function parameters are immutable unless declared with <code>mut</code>. The <code>mut</code> keyword applies only to the following parameter (so <code>|mut x, y|</code> and <code>fn f(mut x: Box&lt;i32&gt;, y: Box&lt;i32&gt;)</code> declare one mutable variable <code>x</code> and one immutable variable <code>y</code>).</p> <p>Methods that take either <code>self</code> or <code>Box&lt;Self&gt;</code> can optionally place them in a mutable variable by prefixing them with <code>mut</code> (similar to regular arguments):</p> <pre class="rust rust-example-rendered" data-language="rust">
trait Changer: Sized {
    fn change(mut self) {}
    fn modify(mut self: Box&lt;Self&gt;) {}
}</pre> <p>Local variables are not initialized when allocated; the entire frame worth of local variables are allocated at once, on frame-entry, in an uninitialized state. Subsequent statements within a function may or may not initialize the local variables. Local variables can be used only after they have been initialized; this is enforced by the compiler.</p> <h2 id="linkage" class="section-header">11 Linkage</h2> <p>The Rust compiler supports various methods to link crates together both statically and dynamically. This section will explore the various methods to link Rust crates together, and more information about native libraries can be found in the <a href="../book/ffi/">FFI section of the book</a>.</p> <p>In one session of compilation, the compiler can generate multiple artifacts through the usage of either command line flags or the <code>crate_type</code> attribute. If one or more command line flags are specified, all <code>crate_type</code> attributes will be ignored in favor of only building the artifacts specified by command line.</p> <ul> <li><p><code>--crate-type=bin</code>, <code>#[crate_type = "bin"]</code> - A runnable executable will be produced. This requires that there is a <code>main</code> function in the crate which will be run when the program begins executing. This will link in all Rust and native dependencies, producing a distributable binary.</p></li> <li><p><code>--crate-type=lib</code>, <code>#[crate_type = "lib"]</code> - A Rust library will be produced. This is an ambiguous concept as to what exactly is produced because a library can manifest itself in several forms. The purpose of this generic <code>lib</code> option is to generate the "compiler recommended" style of library. The output library will always be usable by rustc, but the actual type of library may change from time-to-time. The remaining output types are all different flavors of libraries, and the <code>lib</code> type can be seen as an alias for one of them (but the actual one is compiler-defined).</p></li> <li><p><code>--crate-type=dylib</code>, <code>#[crate_type = "dylib"]</code> - A dynamic Rust library will be produced. This is different from the <code>lib</code> output type in that this forces dynamic library generation. The resulting dynamic library can be used as a dependency for other libraries and/or executables. This output type will create <code>*.so</code> files on linux, <code>*.dylib</code> files on osx, and <code>*.dll</code> files on windows.</p></li> <li><p><code>--crate-type=staticlib</code>, <code>#[crate_type = "staticlib"]</code> - A static system library will be produced. This is different from other library outputs in that the Rust compiler will never attempt to link to <code>staticlib</code> outputs. The purpose of this output type is to create a static library containing all of the local crate's code along with all upstream dependencies. The static library is actually a <code>*.a</code> archive on linux and osx and a <code>*.lib</code> file on windows. This format is recommended for use in situations such as linking Rust code into an existing non-Rust application because it will not have dynamic dependencies on other Rust code.</p></li> <li><p><code>--crate-type=cdylib</code>, <code>#[crate_type = "cdylib"]</code> - A dynamic system library will be produced. This is used when compiling Rust code as a dynamic library to be loaded from another language. This output type will create <code>*.so</code> files on Linux, <code>*.dylib</code> files on OSX, and <code>*.dll</code> files on Windows.</p></li> <li><p><code>--crate-type=rlib</code>, <code>#[crate_type = "rlib"]</code> - A "Rust library" file will be produced. This is used as an intermediate artifact and can be thought of as a "static Rust library". These <code>rlib</code> files, unlike <code>staticlib</code> files, are interpreted by the Rust compiler in future linkage. This essentially means that <code>rustc</code> will look for metadata in <code>rlib</code> files like it looks for metadata in dynamic libraries. This form of output is used to produce statically linked executables as well as <code>staticlib</code> outputs.</p></li> <li><p><code>--crate-type=proc-macro</code>, <code>#[crate_type = "proc-macro"]</code> - The output produced is not specified, but if a <code>-L</code> path is provided to it then the compiler will recognize the output artifacts as a macro and it can be loaded for a program. If a crate is compiled with the <code>proc-macro</code> crate type it will forbid exporting any items in the crate other than those functions tagged <code>#[proc_macro_derive]</code> and those functions must also be placed at the crate root. Finally, the compiler will automatically set the <code>cfg(proc_macro)</code> annotation whenever any crate type of a compilation is the <code>proc-macro</code> crate type.</p></li> </ul> <p>Note that these outputs are stackable in the sense that if multiple are specified, then the compiler will produce each form of output at once without having to recompile. However, this only applies for outputs specified by the same method. If only <code>crate_type</code> attributes are specified, then they will all be built, but if one or more <code>--crate-type</code> command line flags are specified, then only those outputs will be built.</p> <p>With all these different kinds of outputs, if crate A depends on crate B, then the compiler could find B in various different forms throughout the system. The only forms looked for by the compiler, however, are the <code>rlib</code> format and the dynamic library format. With these two options for a dependent library, the compiler must at some point make a choice between these two formats. With this in mind, the compiler follows these rules when determining what format of dependencies will be used:</p> <ol> <li>
<p>If a static library is being produced, all upstream dependencies are required to be available in <code>rlib</code> formats. This requirement stems from the reason that a dynamic library cannot be converted into a static format.</p> <p>Note that it is impossible to link in native dynamic dependencies to a static library, and in this case warnings will be printed about all unlinked native dynamic dependencies.</p>
</li> <li>
<p>If an <code>rlib</code> file is being produced, then there are no restrictions on what format the upstream dependencies are available in. It is simply required that all upstream dependencies be available for reading metadata from.</p> <p>The reason for this is that <code>rlib</code> files do not contain any of their upstream dependencies. It wouldn't be very efficient for all <code>rlib</code> files to contain a copy of <code>libstd.rlib</code>!</p>
</li> <li><p>If an executable is being produced and the <code>-C prefer-dynamic</code> flag is not specified, then dependencies are first attempted to be found in the <code>rlib</code> format. If some dependencies are not available in an rlib format, then dynamic linking is attempted (see below).</p></li> <li>
<p>If a dynamic library or an executable that is being dynamically linked is being produced, then the compiler will attempt to reconcile the available dependencies in either the rlib or dylib format to create a final product.</p> <p>A major goal of the compiler is to ensure that a library never appears more than once in any artifact. For example, if dynamic libraries B and C were each statically linked to library A, then a crate could not link to B and C together because there would be two copies of A. The compiler allows mixing the rlib and dylib formats, but this restriction must be satisfied.</p> <p>The compiler currently implements no method of hinting what format a library should be linked with. When dynamically linking, the compiler will attempt to maximize dynamic dependencies while still allowing some dependencies to be linked in via an rlib.</p> <p>For most situations, having all libraries available as a dylib is recommended if dynamically linking. For other situations, the compiler will emit a warning if it is unable to determine which formats to link each library with.</p>
</li> </ol> <p>In general, <code>--crate-type=bin</code> or <code>--crate-type=lib</code> should be sufficient for all compilation needs, and the other options are just available if more fine-grained control is desired over the output format of a Rust crate.</p> <h2 id="unsafety" class="section-header">12 Unsafety</h2> <p>Unsafe operations are those that potentially violate the memory-safety guarantees of Rust's static semantics.</p> <p>The following language level features cannot be used in the safe subset of Rust:</p> <ul> <li>Dereferencing a <a href="#pointer-types">raw pointer</a>.</li> <li>Reading or writing a <a href="#mutable-statics">mutable static variable</a>.</li> <li>Calling an unsafe function (including an intrinsic or foreign function).</li> </ul> <h3 id="unsafe-functions" class="section-header">12.1 Unsafe functions</h3> <p>Unsafe functions are functions that are not safe in all contexts and/or for all possible inputs. Such a function must be prefixed with the keyword <code>unsafe</code> and can only be called from an <code>unsafe</code> block or another <code>unsafe</code> function.</p> <h3 id="unsafe-blocks" class="section-header">12.2 Unsafe blocks</h3> <p>A block of code can be prefixed with the <code>unsafe</code> keyword, to permit calling <code>unsafe</code> functions or dereferencing raw pointers within a safe function.</p> <p>When a programmer has sufficient conviction that a sequence of potentially unsafe operations is actually safe, they can encapsulate that sequence (taken as a whole) within an <code>unsafe</code> block. The compiler will consider uses of such code safe, in the surrounding context.</p> <p>Unsafe blocks are used to wrap foreign libraries, make direct use of hardware or implement features not directly present in the language. For example, Rust provides the language features necessary to implement memory-safe concurrency in the language but the implementation of threads and message passing is in the standard library.</p> <p>Rust's type system is a conservative approximation of the dynamic safety requirements, so in some cases there is a performance cost to using safe code. For example, a doubly-linked list is not a tree structure and can only be represented with reference-counted pointers in safe code. By using <code>unsafe</code> blocks to represent the reverse links as raw pointers, it can be implemented with only boxes.</p> <h3 id="behavior-considered-undefined" class="section-header">12.3 Behavior considered undefined</h3> <p>The following is a list of behavior which is forbidden in all Rust code, including within <code>unsafe</code> blocks and <code>unsafe</code> functions. Type checking provides the guarantee that these issues are never caused by safe code.</p> <ul> <li>Data races</li> <li>Dereferencing a null/dangling raw pointer</li> <li>Reads of <a href="http://llvm.org/docs/LangRef.html#undefined-values" target="_blank">undef</a> (uninitialized) memory</li> <li>Breaking the <a href="http://llvm.org/docs/LangRef.html#pointer-aliasing-rules" target="_blank">pointer aliasing rules</a> with raw pointers (a subset of the rules used by C)</li> <li>
<code>&amp;mut T</code> and <code>&amp;T</code> follow LLVM’s scoped <a href="http://llvm.org/docs/LangRef.html#noalias" target="_blank">noalias</a> model, except if the <code>&amp;T</code> contains an <code>UnsafeCell&lt;U&gt;</code>. Unsafe code must not violate these aliasing guarantees.</li> <li>Mutating non-mutable data (that is, data reached through a shared reference or data owned by a <code>let</code> binding), unless that data is contained within an <code>UnsafeCell&lt;U&gt;</code>.</li> <li>Invoking undefined behavior via compiler intrinsics: <ul> <li>Indexing outside of the bounds of an object with <code>std::ptr::offset</code> (<code>offset</code> intrinsic), with the exception of one byte past the end which is permitted.</li> <li>Using <code>std::ptr::copy_nonoverlapping_memory</code> (<code>memcpy32</code>/<code>memcpy64</code> intrinsics) on overlapping buffers</li> </ul>
</li> <li>Invalid values in primitive types, even in private fields/locals: <ul> <li>Dangling/null references or boxes</li> <li>A value other than <code>false</code> (0) or <code>true</code> (1) in a <code>bool</code>
</li> <li>A discriminant in an <code>enum</code> not included in the type definition</li> <li>A value in a <code>char</code> which is a surrogate or above <code>char::MAX</code>
</li> <li>Non-UTF-8 byte sequences in a <code>str</code>
</li> </ul>
</li> <li>Unwinding into Rust from foreign code or unwinding from Rust into foreign code. Rust's failure system is not compatible with exception handling in other languages. Unwinding must be caught and handled at FFI boundaries.</li> </ul> <h3 id="behavior-not-considered-unsafe" class="section-header">12.4 Behavior not considered unsafe</h3> <p>This is a list of behavior not considered <em>unsafe</em> in Rust terms, but that may be undesired.</p> <ul> <li>Deadlocks</li> <li>Leaks of memory and other resources</li> <li>Exiting without calling destructors</li> <li>Integer overflow <ul> <li>Overflow is considered "unexpected" behavior and is always user-error, unless the <code>wrapping</code> primitives are used. In non-optimized builds, the compiler will insert debug checks that panic on overflow, but in optimized builds overflow instead results in wrapped values. See <a href="https://github.com/rust-lang/rfcs/blob/master/text/0560-integer-overflow.md" target="_blank">RFC 560</a> for the rationale and more details.</li> </ul>
</li> </ul> <h2 id="appendix-influences" class="section-header">13 Appendix: Influences</h2> <p>Rust is not a particularly original language, with design elements coming from a wide range of sources. Some of these are listed below (including elements that have since been removed):</p> <ul> <li>SML, OCaml: algebraic data types, pattern matching, type inference, semicolon statement separation</li> <li>C++: references, RAII, smart pointers, move semantics, monomorphization, memory model</li> <li>ML Kit, Cyclone: region based memory management</li> <li>Haskell (GHC): typeclasses, type families</li> <li>Newsqueak, Alef, Limbo: channels, concurrency</li> <li>Erlang: message passing, thread failure, <del>linked thread failure</del>, <del>lightweight concurrency</del>
</li> <li>Swift: optional bindings</li> <li>Scheme: hygienic macros</li> <li>C#: attributes</li> <li>Ruby: <del>block syntax</del>
</li> <li>NIL, Hermes: <del>typestate</del>
</li> <li>
<a href="http://www.unicode.org/reports/tr31/" target="_blank">Unicode Annex #31</a>: identifier and pattern syntax</li> </ul> <div class="footnotes">  <ol> <li id="fn1"> <p>Substitute definitions for the special Unicode productions are provided to the grammar verifier, restricted to ASCII range, when verifying the grammar in this document. <a href="#fnref1" rev="footnote">↩</a></p> </li> <li id="fn2"> <p>Non-ASCII characters in identifiers are currently feature gated. This is expected to improve soon. <a href="#fnref2" rev="footnote">↩</a></p> </li> <li id="fn3"> <p>This distinction would also exist in an interpreter. Static checks like syntactic analysis, type checking, and lints should happen before the program is executed regardless of when it is executed. <a href="#fnref3" rev="footnote">↩</a></p> </li> <li id="fn4"> <p>A crate is somewhat analogous to an <em>assembly</em> in the ECMA-335 CLI model, a <em>library</em> in the SML/NJ Compilation Manager, a <em>unit</em> in the Owens and Flatt module system, or a <em>configuration</em> in Mesa. <a href="#fnref4" rev="footnote">↩</a></p> </li> <li id="fn5"> <p><code>struct</code> types are analogous to <code>struct</code> types in C, the <em>record</em> types of the ML family, or the <em>struct</em> types of the Lisp family. <a href="#fnref5" rev="footnote">↩</a></p> </li> <li id="fn6"> <p>The <code>enum</code> type is analogous to a <code>data</code> constructor declaration in ML, or a <em>pick ADT</em> in Limbo. <a href="#fnref6" rev="footnote">↩</a></p> </li> </ol> </div> <footer><p> Copyright © 2011 The Rust Project Developers. Licensed under the <a href="http://www.apache.org/licenses/LICENSE-2.0" target="_blank">Apache License, Version 2.0</a> or the <a href="https://opensource.org/licenses/MIT" target="_blank">MIT license</a>, at your option. </p>
<p> This file may not be copied, modified, or distributed except according to those terms. </p></footer><div class="_attribution">
  <p class="_attribution-p">
    © 2010 The Rust Project Developers<br>Licensed under the Apache License, Version 2.0 or the MIT license, at your option.<br>
    <a href="https://doc.rust-lang.org/reference.html" class="_attribution-link" target="_blank">https://doc.rust-lang.org/reference.html</a>
  </p>
</div>

			</div>
		</div>
	</section>

	</div>
</body>
</html>
