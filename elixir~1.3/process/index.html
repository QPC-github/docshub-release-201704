
<!DOCTYPE HTML>

<html lang="en">

<head>
  <meta charset="utf-8">
  <title>Process - Elixir 1.3 - W3cubDocs</title>
  
  <meta name="description" content=" Conveniences for working with processes and the process dictionary. ">
  <meta name="keywords" content="process, summary, types, functions, -, elixir, elixir~1.3">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="http://docs.w3cub.com/elixir~1.3/process/">
  <link href="/favicon.png" rel="icon">
  <link type="text/css" rel="stylesheet" href="/assets/application-50364fff564ce3b6327021805f3f00e2957b441cf27f576a7dd4ff63bbc47047.css">
  <script type="text/javascript" src="/assets/application-db64bfd54ceb42be11af7995804cf4902548419ceb79d509b0b7d62c22d98e6f.js"></script>
  <script src="/json/elixir~1.3.js"></script>
  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-71174418-1']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>


</head>

<body>
	<div class="_app">
	<header class="_header">
  
  <form class="_search">
    <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
    <a class="_search-clear"></a>
    <div class="_search-tag"></div>
  </form>
  
  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/elixir~1.3/" class="_nav-link" title="" style="margin-left:0;">Elixir 1.3</a></span>
  
  <nav class="_nav">
    <a href="/app/" class="_nav-link ">App</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		<div class="_list">
			
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<div class="_page _elixir">
				
<h1>  Process  </h1>  <p>Conveniences for working with processes and the process dictionary.</p> <p>Besides the functions available in this module, the <a href="../kernel/"><code class="inline">Kernel</code></a> module exposes and auto-imports some basic functionality related to processes available through the functions:</p> <ul> <li>
<a href="../kernel/#spawn/1"><code class="inline">Kernel.spawn/1</code></a> and <a href="../kernel/#spawn/3"><code class="inline">Kernel.spawn/3</code></a> </li> <li>
<a href="../kernel/#spawn_link/1"><code class="inline">Kernel.spawn_link/1</code></a> and <a href="../kernel/#spawn_link/3"><code class="inline">Kernel.spawn_link/3</code></a> </li> <li>
<a href="../kernel/#spawn_monitor/1"><code class="inline">Kernel.spawn_monitor/1</code></a> and <a href="../kernel/#spawn_monitor/3"><code class="inline">Kernel.spawn_monitor/3</code></a> </li> <li>
<a href="../kernel/#self/0"><code class="inline">Kernel.self/0</code></a> </li> <li>
<a href="../kernel/#send/2"><code class="inline">Kernel.send/2</code></a> </li> </ul>   <h1 class="section-heading" id="summary">  Summary </h1> <h2> Types </h2>
<dl class="summary-types summary">   <dt class="summary-signature"> <a href="#t:spawn_opt/0">spawn_opt()</a> </dt>   <dt class="summary-signature"> <a href="#t:spawn_opts/0">spawn_opts()</a> </dt>  </dl> <h2> Functions </h2>
<dl class="summary-functions summary">   <dt class="summary-signature"> <a href="#alive?/1">alive?(pid)</a> </dt> <dd class="summary-synopsis">
<p>Returns <code class="inline">true</code> if the process exists and is alive (i.e. it is not exiting and has not exited yet). Otherwise, returns <code class="inline">false</code></p> </dd>   <dt class="summary-signature"> <a href="#cancel_timer/1">cancel_timer(timer_ref)</a> </dt> <dd class="summary-synopsis">
<p>Cancels a timer created by <a href="#send_after/3"><code class="inline">send_after/3</code></a></p> </dd>   <dt class="summary-signature"> <a href="#delete/1">delete(key)</a> </dt> <dd class="summary-synopsis">
<p>Deletes the given <code class="inline">key</code> from the process dictionary</p> </dd>   <dt class="summary-signature"> <a href="#demonitor/2">demonitor(monitor_ref, options \\ [])</a> </dt> <dd class="summary-synopsis">
<p>If <code class="inline">monitor_ref</code> is a reference which the calling process obtained by calling <a href="#monitor/1"><code class="inline">monitor/1</code></a>, this monitoring is turned off. If the monitoring is already turned off, nothing happens</p> </dd>   <dt class="summary-signature"> <a href="#exit/2">exit(pid, reason)</a> </dt> <dd class="summary-synopsis">
<p>Sends an exit signal with the given <code class="inline">reason</code> to the <code class="inline">pid</code></p> </dd>   <dt class="summary-signature"> <a href="#flag/2">flag(flag, value)</a> </dt> <dd class="summary-synopsis">
<p>Sets certain flags for the process which calls this function. Returns the old value of the <code class="inline">flag</code></p> </dd>   <dt class="summary-signature"> <a href="#flag/3">flag(pid, flag, value)</a> </dt> <dd class="summary-synopsis">
<p>Sets certain flags for the process <code class="inline">pid</code>, in the same manner as <a href="#flag/2"><code class="inline">flag/2</code></a>. Returns the old value of the <code class="inline">flag</code>. The allowed values for <code class="inline">flag</code> are only a subset of those allowed in <a href="#flag/2"><code class="inline">flag/2</code></a>, namely <code class="inline">:save_calls</code></p> </dd>   <dt class="summary-signature"> <a href="#get/0">get()</a> </dt> <dd class="summary-synopsis">
<p>Returns all key-value pairs in the process dictionary</p> </dd>   <dt class="summary-signature"> <a href="#get/2">get(key, default \\ nil)</a> </dt> <dd class="summary-synopsis">
<p>Returns the value for the given <code class="inline">key</code> or <code class="inline">default</code> if <code class="inline">key</code> is not set</p> </dd>   <dt class="summary-signature"> <a href="#get_keys/0">get_keys()</a> </dt> <dd class="summary-synopsis">
<p>Returns all keys in the process dictionary</p> </dd>   <dt class="summary-signature"> <a href="#get_keys/1">get_keys(value)</a> </dt> <dd class="summary-synopsis">
<p>Returns all keys that have the given <code class="inline">value</code></p> </dd>   <dt class="summary-signature"> <a href="#group_leader/0">group_leader()</a> </dt> <dd class="summary-synopsis">
<p>Returns the pid of the group leader for the process which evaluates the function</p> </dd>   <dt class="summary-signature"> <a href="#group_leader/2">group_leader(pid, leader)</a> </dt> <dd class="summary-synopsis">
<p>Sets the group leader of <code class="inline">pid</code> to <code class="inline">leader</code>. Typically, this is used when a processes started from a certain shell should have a group leader other than <code class="inline">:init</code></p> </dd>   <dt class="summary-signature"> <a href="#hibernate/3">hibernate(mod, fun, args)</a> </dt> <dd class="summary-synopsis">
<p>Puts the calling process into a wait state where its memory allocation has been reduced as much as possible, which is useful if the process does not expect to receive any messages in the near future</p> </dd>   <dt class="summary-signature"> <a href="#info/1">info(pid)</a> </dt> <dd class="summary-synopsis">
<p>Returns information about the process identified by <code class="inline">pid</code>, or returns <code class="inline">nil</code> if the process is not alive. Use this only for debugging information</p> </dd>   <dt class="summary-signature"> <a href="#info/2">info(pid, spec)</a> </dt> <dd class="summary-synopsis">
<p>Returns information about the process identified by <code class="inline">pid</code>, or returns <code class="inline">nil</code> if the process is not alive</p> </dd>   <dt class="summary-signature"> <a href="#link/1">link(pid)</a> </dt> <dd class="summary-synopsis">
<p>Creates a link between the calling process and another process (or port) <code class="inline">pid</code>, if there is not such a link already</p> </dd>   <dt class="summary-signature"> <a href="#list/0">list()</a> </dt> <dd class="summary-synopsis">
<p>Returns a list of process identifiers corresponding to all the processes currently existing on the local node</p> </dd>   <dt class="summary-signature"> <a href="#monitor/1">monitor(item)</a> </dt> <dd class="summary-synopsis">
<p>The calling process starts monitoring the given <code class="inline">item</code>. It returns the monitor reference</p> </dd>   <dt class="summary-signature"> <a href="#put/2">put(key, value)</a> </dt> <dd class="summary-synopsis">
<p>Stores the given <code class="inline">key</code>-<code class="inline">value</code> pair in the process dictionary</p> </dd>   <dt class="summary-signature"> <a href="#read_timer/1">read_timer(timer_ref)</a> </dt> <dd class="summary-synopsis">
<p>Reads a timer created by <a href="#send_after/3"><code class="inline">send_after/3</code></a></p> </dd>   <dt class="summary-signature"> <a href="#register/2">register(pid, name)</a> </dt> <dd class="summary-synopsis">
<p>Associates the atom <code class="inline">name</code> with a <code class="inline">pid</code> or a port identifier</p> </dd>   <dt class="summary-signature"> <a href="#registered/0">registered()</a> </dt> <dd class="summary-synopsis">
<p>Returns a list of names which have been registered using <a href="#register/2"><code class="inline">register/2</code></a></p> </dd>   <dt class="summary-signature"> <a href="#send/3">send(dest, msg, options)</a> </dt> <dd class="summary-synopsis">
<p>Sends a message to the given process</p> </dd>   <dt class="summary-signature"> <a href="#send_after/3">send_after(dest, msg, time)</a> </dt> <dd class="summary-synopsis">
<p>Sends <code class="inline">msg</code> to <code class="inline">dest</code> after <code class="inline">time</code> milliseconds</p> </dd>   <dt class="summary-signature"> <a href="#sleep/1">sleep(timeout)</a> </dt> <dd class="summary-synopsis">
<p>Sleeps the current process by <code class="inline">timeout</code></p> </dd>   <dt class="summary-signature"> <a href="#spawn/2">spawn(fun, opts)</a> </dt> <dd class="summary-synopsis">
<p>Spawns the given function according to the given options</p> </dd>   <dt class="summary-signature"> <a href="#spawn/4">spawn(mod, fun, args, opts)</a> </dt> <dd class="summary-synopsis">
<p>Spawns the given function from module <code class="inline">mod</code>, passing the given <code class="inline">args</code> according to the given options</p> </dd>   <dt class="summary-signature"> <a href="#unlink/1">unlink(pid)</a> </dt> <dd class="summary-synopsis">
<p>Removes the link, if there is one, between the calling process and the process or port referred to by <code class="inline">pid</code>. Returns <code class="inline">true</code> and does not fail, even if there is no link or <code class="inline">id</code> does not exist</p> </dd>   <dt class="summary-signature"> <a href="#unregister/1">unregister(name)</a> </dt> <dd class="summary-synopsis">
<p>Removes the registered <code class="inline">name</code>, associated with a pid or a port identifier</p> </dd>   <dt class="summary-signature"> <a href="#whereis/1">whereis(name)</a> </dt> <dd class="summary-synopsis">
<p>Returns the pid or port identifier with the registered <code class="inline">name</code>. Returns <code class="inline">nil</code> if the name is not registered</p> </dd>  </dl>   <h1 class="section-heading" id="types">  Types </h1>   <h3 class="detail-header type" id="t:spawn_opt/0">  <span class="signature">spawn_opt()</span>     </h3>
<pre data-language="elixir"><a href="#t:spawn_opt/0">spawn_opt</a> ::
  :link |
  :monitor |
  {:priority, :low | :normal | :high} |
  {:fullsweep_after, non_neg_integer} |
  {:min_heap_size, non_neg_integer} |
  {:min_bin_vheap_size, non_neg_integer}</pre>     <h3 class="detail-header type" id="t:spawn_opts/0">  <span class="signature">spawn_opts()</span>     </h3>
<pre data-language="elixir">spawn_opts() :: [<a href="#t:spawn_opt/0">spawn_opt</a>]</pre>       <h1 class="section-heading" id="functions">  Functions </h1>  <h3 class="detail-header function" id="alive?/1">  <span class="signature">alive?(pid)</span>     </h3>
<pre data-language="elixir">alive?(pid) :: boolean</pre>  <p>Returns <code class="inline">true</code> if the process exists and is alive (i.e. it is not exiting and has not exited yet). Otherwise, returns <code class="inline">false</code>.</p> <p><code class="inline">pid</code> must refer to a process at the local node.</p> <p>Inlined by the compiler.</p>    <h3 class="detail-header function" id="cancel_timer/1">  <span class="signature">cancel_timer(timer_ref)</span>     </h3>
<pre data-language="elixir">cancel_timer(reference) :: non_neg_integer | false</pre>  <p>Cancels a timer created by <a href="#send_after/3"><code class="inline">send_after/3</code></a>.</p> <p>When the result is an integer, it represents the time in milliseconds left until the timer would have expired.</p> <p>When the result is <code class="inline">false</code>, a timer corresponding to <code class="inline">timer_ref</code> could not be found. This can be either because the timer expired, already has been canceled, or because <code class="inline">timer_ref</code> never corresponded to a timer.</p> <p>If the timer has expired, the timeout message has been sent, but it does not tell you whether or not it has arrived at its destination yet.</p> <p>Inlined by the compiler.</p>    <h3 class="detail-header function" id="delete/1">  <span class="signature">delete(key)</span>     </h3>
<pre data-language="elixir">delete(term) :: term | nil</pre>  <p>Deletes the given <code class="inline">key</code> from the process dictionary.</p>     <h3 class="detail-header function" id="demonitor/2">  <span class="signature">demonitor(monitor_ref, options \\ [])</span>     </h3>
<pre data-language="elixir">demonitor(reference, options :: [:flush | :info]) :: boolean</pre>  <p>If <code class="inline">monitor_ref</code> is a reference which the calling process obtained by calling <a href="#monitor/1"><code class="inline">monitor/1</code></a>, this monitoring is turned off. If the monitoring is already turned off, nothing happens.</p> <p>See <a href="http://www.erlang.org/doc/man/erlang.html#demonitor-2" target="_blank"><code class="inline">:erlang.demonitor/2</code></a> for more info.</p> <p>Inlined by the compiler.</p>    <h3 class="detail-header function" id="exit/2">  <span class="signature">exit(pid, reason)</span>     </h3>
<pre data-language="elixir">exit(pid, term) :: true</pre>  <p>Sends an exit signal with the given <code class="inline">reason</code> to the <code class="inline">pid</code>.</p> <p>The following behaviour applies if <code class="inline">reason</code> is any term except <code class="inline">:normal</code> or <code class="inline">:kill</code>:</p> <ol> <li>
<p>If <code class="inline">pid</code> is not trapping exits, <code class="inline">pid</code> will exit with the given <code class="inline">reason</code>.</p> </li> <li>
<p>If <code class="inline">pid</code> is trapping exits, the exit signal is transformed into a message <code class="inline">{:EXIT, from, reason}</code> and delivered to the message queue of <code class="inline">pid</code>.</p> </li> <li>
<p>If <code class="inline">reason</code> is the atom <code class="inline">:normal</code>, <code class="inline">pid</code> will not exit (unless it is the calling process’s pid, in which case it will exit with the reason <code class="inline">:normal</code>). If it is trapping exits, the exit signal is transformed into a message <code class="inline">{:EXIT, from, :normal}</code> and delivered to its message queue.</p> </li> <li>If <code class="inline">reason</code> is the atom <code class="inline">:kill</code>, that is if <code class="inline">exit(pid, :kill)</code> is called, an untrappable exit signal is sent to <code class="inline">pid</code> which will unconditionally exit with exit reason <code class="inline">:killed</code>. </li> </ol> <p>Inlined by the compiler.</p> <h4 id="exit/2-examples" class="section-heading">  Examples </h4> <pre data-language="elixir"><code class="elixir">Process.exit(pid, :kill)</code></pre>    <h3 class="detail-header function" id="flag/2">  <span class="signature">flag(flag, value)</span>     </h3>
<pre data-language="elixir">flag(process_flag, term) :: term</pre>  <p>Sets certain flags for the process which calls this function. Returns the old value of the <code class="inline">flag</code>.</p> <p>See <a href="http://www.erlang.org/doc/man/erlang.html#process_flag-2" target="_blank"><code class="inline">:erlang.process_flag/2</code></a> for more info.</p>    <h3 class="detail-header function" id="flag/3">  <span class="signature">flag(pid, flag, value)</span>     </h3>
<pre data-language="elixir">flag(pid, :save_calls, non_neg_integer) :: non_neg_integer</pre>  <p>Sets certain flags for the process <code class="inline">pid</code>, in the same manner as <a href="#flag/2"><code class="inline">flag/2</code></a>. Returns the old value of the <code class="inline">flag</code>. The allowed values for <code class="inline">flag</code> are only a subset of those allowed in <a href="#flag/2"><code class="inline">flag/2</code></a>, namely <code class="inline">:save_calls</code>.</p> <p>See <a href="http://www.erlang.org/doc/man/erlang.html#process_flag-3" target="_blank"><code class="inline">:erlang.process_flag/3</code></a> for more info.</p>    <h3 class="detail-header function" id="get/0">  <span class="signature">get()</span>     </h3>
<pre data-language="elixir">get() :: [{term, term}]</pre>  <p>Returns all key-value pairs in the process dictionary.</p> <p>Inlined by the compiler.</p>     <h3 class="detail-header function" id="get/2">  <span class="signature">get(key, default \\ nil)</span>     </h3>
<pre data-language="elixir">get(term, default :: term) :: term</pre>  <p>Returns the value for the given <code class="inline">key</code> or <code class="inline">default</code> if <code class="inline">key</code> is not set.</p>    <h3 class="detail-header function" id="get_keys/0">  <span class="signature">get_keys()</span>     </h3>
<pre data-language="elixir">get_keys() :: [term]</pre>  <p>Returns all keys in the process dictionary.</p> <p>Inlined by the compiler.</p>    <h3 class="detail-header function" id="get_keys/1">  <span class="signature">get_keys(value)</span>     </h3>
<pre data-language="elixir">get_keys(term) :: [term]</pre>  <p>Returns all keys that have the given <code class="inline">value</code>.</p> <p>Inlined by the compiler.</p>    <h3 class="detail-header function" id="group_leader/0">  <span class="signature">group_leader()</span>     </h3>
<pre data-language="elixir">group_leader() :: pid</pre>  <p>Returns the pid of the group leader for the process which evaluates the function.</p>    <h3 class="detail-header function" id="group_leader/2">  <span class="signature">group_leader(pid, leader)</span>     </h3>
<pre data-language="elixir">group_leader(pid, leader :: pid) :: true</pre>  <p>Sets the group leader of <code class="inline">pid</code> to <code class="inline">leader</code>. Typically, this is used when a processes started from a certain shell should have a group leader other than <code class="inline">:init</code>.</p>    <h3 class="detail-header function" id="hibernate/3">  <span class="signature">hibernate(mod, fun, args)</span>     </h3>
<pre data-language="elixir">hibernate(module, atom, list) :: no_return</pre>  <p>Puts the calling process into a wait state where its memory allocation has been reduced as much as possible, which is useful if the process does not expect to receive any messages in the near future.</p> <p>See <a href="http://www.erlang.org/doc/man/erlang.html#hibernate-3" target="_blank"><code class="inline">:erlang.hibernate/3</code></a> for more info.</p> <p>Inlined by the compiler.</p>    <h3 class="detail-header function" id="info/1">  <span class="signature">info(pid)</span>     </h3>
<pre data-language="elixir">info(pid) :: <a href="../keyword/#t:t/0">Keyword.t</a></pre>  <p>Returns information about the process identified by <code class="inline">pid</code>, or returns <code class="inline">nil</code> if the process is not alive. Use this only for debugging information.</p> <p>See <a href="http://www.erlang.org/doc/man/erlang.html#process_info-1" target="_blank"><code class="inline">:erlang.process_info/1</code></a> for more info.</p>    <h3 class="detail-header function" id="info/2">  <span class="signature">info(pid, spec)</span>     </h3>
<pre data-language="elixir">info(pid, atom | [atom]) ::
  {atom, term} |
  [{atom, term}] |
  nil</pre>  <p>Returns information about the process identified by <code class="inline">pid</code>, or returns <code class="inline">nil</code> if the process is not alive.</p> <p>See <a href="http://www.erlang.org/doc/man/erlang.html#process_info-2" target="_blank"><code class="inline">:erlang.process_info/2</code></a> for more info.</p>    <h3 class="detail-header function" id="link/1">  <span class="signature">link(pid)</span>     </h3>
<pre data-language="elixir">link(pid | port) :: true</pre>  <p>Creates a link between the calling process and another process (or port) <code class="inline">pid</code>, if there is not such a link already.</p> <p>See <a href="http://www.erlang.org/doc/man/erlang.html#link-1" target="_blank"><code class="inline">:erlang.link/1</code></a> for more info.</p> <p>Inlined by the compiler.</p>    <h3 class="detail-header function" id="list/0">  <span class="signature">list()</span>     </h3>
<pre data-language="elixir">list() :: [pid]</pre>  <p>Returns a list of process identifiers corresponding to all the processes currently existing on the local node.</p> <p>Note that a process that is exiting, exists but is not alive, i.e., <a href="#alive?/1"><code class="inline">alive?/1</code></a> will return <code class="inline">false</code> for a process that is exiting, but its process identifier will be part of the result returned.</p> <p>See <a href="http://www.erlang.org/doc/man/erlang.html#processes-0" target="_blank"><code class="inline">:erlang.processes/0</code></a> for more info.</p>    <h3 class="detail-header function" id="monitor/1">  <span class="signature">monitor(item)</span>     </h3>
<pre data-language="elixir">monitor(pid | {reg_name :: atom, node :: atom} | reg_name :: atom) :: reference</pre>  <p>The calling process starts monitoring the given <code class="inline">item</code>. It returns the monitor reference.</p> <p>See <a href="http://elixir-lang.org/getting-started/mix-otp/genserver.html#the-need-for-monitoring" target="_blank">the need for monitoring</a> for an example. See <a href="http://www.erlang.org/doc/man/erlang.html#monitor-2" target="_blank"><code class="inline">:erlang.monitor/2</code></a> for more info.</p> <p>Inlined by the compiler.</p>    <h3 class="detail-header function" id="put/2">  <span class="signature">put(key, value)</span>     </h3>
<pre data-language="elixir">put(term, term) :: term | nil</pre>  <p>Stores the given <code class="inline">key</code>-<code class="inline">value</code> pair in the process dictionary.</p> <p>The return value is the value that was previously stored under the key <code class="inline">key</code> (or <code class="inline">nil</code> in case no value was stored under <code class="inline">key</code>).</p>    <h3 class="detail-header function" id="read_timer/1">  <span class="signature">read_timer(timer_ref)</span>     </h3>
<pre data-language="elixir">read_timer(reference) :: non_neg_integer | false</pre>  <p>Reads a timer created by <a href="#send_after/3"><code class="inline">send_after/3</code></a>.</p> <p>When the result is an integer, it represents the time in milliseconds left until the timer will expire.</p> <p>When the result is <code class="inline">false</code>, a timer corresponding to <code class="inline">timer_ref</code> could not be found. This can be either because the timer expired, already has been canceled, or because <code class="inline">timer_ref</code> never corresponded to a timer.</p> <p>If the timer has expired, the timeout message has been sent, but it does not tell you whether or not it has arrived at its destination yet.</p> <p>Inlined by the compiler.</p>    <h3 class="detail-header function" id="register/2">  <span class="signature">register(pid, name)</span>     </h3>
<pre data-language="elixir">register(pid | port, atom) :: true</pre>  <p>Associates the atom <code class="inline">name</code> with a <code class="inline">pid</code> or a port identifier.</p> <p><code class="inline">name</code>, can then be used instead of the <code class="inline">pid</code> / port identifier with the <a href="../kernel/#send/2"><code class="inline">Kernel.send/2</code></a> function. <a href="../process/#register/2"><code class="inline">Process.register/2</code></a> will fail with <a href="../argumenterror/"><code class="inline">ArgumentError</code></a> if the pid supplied is no longer alive, (check with <a href="#alive?/1)"><code class="inline">alive?/1</code></a> or if the name is already registered (check with <a href="#whereis/1)"><code class="inline">whereis/1</code></a> or if the <code class="inline">pid</code> is already registered to a different <code class="inline">name</code>.</p>    <h3 class="detail-header function" id="registered/0">  <span class="signature">registered()</span>     </h3>
<pre data-language="elixir">registered() :: [atom]</pre>  <p>Returns a list of names which have been registered using <a href="#register/2"><code class="inline">register/2</code></a>.</p>    <h3 class="detail-header function" id="send/3">  <span class="signature">send(dest, msg, options)</span>     </h3>
<pre data-language="elixir">send(dest, msg, [option]) ::
  :ok |
  :noconnect |
  :nosuspend when dest: pid | port | atom | {atom, node}, msg: any, option: :noconnect | :nosuspend</pre>  <p>Sends a message to the given process.</p> <p>If the option <code class="inline">:noconnect</code> is used and sending the message would require an auto-connection to another node the message is not sent and <code class="inline">:noconnect</code> is returned.</p> <p>If the option <code class="inline">:nosuspend</code> is used and sending the message would cause the sender to be suspended the message is not sent and <code class="inline">:nosuspend</code> is returned.</p> <p>Otherwise the message is sent and <code class="inline">:ok</code> is returned.</p> <h4 id="send/3-examples" class="section-heading">  Examples </h4> <pre data-language="elixir"><code class="iex elixir">iex&gt; Process.send({:name, :node_does_not_exist}, :hi, [:noconnect])
:noconnect</code></pre>    <h3 class="detail-header function" id="send_after/3">  <span class="signature">send_after(dest, msg, time)</span>     </h3>
<pre data-language="elixir">send_after(pid | atom, term, non_neg_integer) :: reference</pre>  <p>Sends <code class="inline">msg</code> to <code class="inline">dest</code> after <code class="inline">time</code> milliseconds.</p> <p>If <code class="inline">dest</code> is a pid, it must be the pid of a local process, dead or alive. If <code class="inline">dest</code> is an atom, it must be the name of a registered process which is looked up at the time of delivery. No error is given if the name does not refer to a process.</p> <p>This function returns a timer reference, which can be read or canceled with <a href="#read_timer/1"><code class="inline">read_timer/1</code></a> and <a href="#cancel_timer/1"><code class="inline">cancel_timer/1</code></a>.</p> <p>Finally, the timer will be automatically canceled if the given <code class="inline">dest</code> is a pid which is not alive or when the given pid exits. Note that timers will not be automatically canceled when <code class="inline">dest</code> is an atom (as the atom resolution is done on delivery).</p>    <h3 class="detail-header function" id="sleep/1">  <span class="signature">sleep(timeout)</span>  </h3>  <p>Sleeps the current process by <code class="inline">timeout</code>.</p> <p><code class="inline">timeout</code> is either the number of milliseconds to sleep as an integer or the atom <code class="inline">:infinity</code>. When <code class="inline">:infinity</code> is given, the current process will suspend forever.</p> <p><strong>Use this function with extreme care</strong>. For almost all situations where you would use <a href="#sleep/1"><code class="inline">sleep/1</code></a> in Elixir, there is likely a more correct, faster and precise way of achieving it with message passing.</p> <p>For example, if you are waiting a process to perform some action, it is better to communicate.</p> <p>In other words, <strong>do not</strong>:</p> <pre data-language="elixir"><code class="elixir">Task.start_link fn -&gt;
  do_something()
  ...
end

# Wait until work is done
Process.sleep(2000)</code></pre> <p>But <strong>do</strong>:</p> <pre data-language="elixir"><code class="elixir">parent = self()
Task.start_link fn -&gt;
  do_something()
  send parent, :work_is_done
  ...
end

receive do
  :work_is_done -&gt; :ok
after
  30_000 -&gt; :timeout # Optional timeout
end</code></pre> <p>Or even use <a href="../task/#async/1"><code class="inline">Task.async/1</code></a> and <a href="../task/#await/2"><code class="inline">Task.await/2</code></a> in the example above.</p> <p>Similarly, if you are waiting for a process to terminate, use monitor instead of sleep. <strong>Do not</strong>:</p> <pre data-language="elixir"><code class="elixir">Task.start_link fn -&gt;
  ...
end

# Wait until task terminates
Process.sleep(2000)</code></pre> <p>Instead <strong>do</strong>:</p> <pre data-language="elixir"><code class="elixir">{:ok, pid} =
  Task.start_link fn -&gt;
    ...
  end

ref = Process.monitor(pid)
receive do
  {:DOWN, ^ref, _, _, _} -&gt; :task_is_down
after
  30_000 -&gt; :timeout # Optional timeout
end</code></pre>    <h3 class="detail-header function" id="spawn/2">  <span class="signature">spawn(fun, opts)</span>     </h3>
<pre data-language="elixir">spawn((() -&gt; any), <a href="#t:spawn_opts/0">spawn_opts</a>) :: pid | {pid, reference}</pre>  <p>Spawns the given function according to the given options.</p> <p>The result depends on the given options. In particular, if <code class="inline">:monitor</code> is given as an option, it will return a tuple containing the pid and the monitoring reference, otherwise just the spawned process pid.</p> <p>It also accepts extra options, for the list of available options check <a href="http://www.erlang.org/doc/man/erlang.html#spawn_opt-4" target="_blank"><code class="inline">:erlang.spawn_opt/4</code></a>.</p> <p>Inlined by the compiler.</p>    <h3 class="detail-header function" id="spawn/4">  <span class="signature">spawn(mod, fun, args, opts)</span>     </h3>
<pre data-language="elixir">spawn(module, atom, list, <a href="#t:spawn_opts/0">spawn_opts</a>) ::
  pid |
  {pid, reference}</pre>  <p>Spawns the given function from module <code class="inline">mod</code>, passing the given <code class="inline">args</code> according to the given options.</p> <p>The result depends on the given options. In particular, if <code class="inline">:monitor</code> is given as an option, it will return a tuple containing the pid and the monitoring reference, otherwise just the spawned process pid.</p> <p>It also accepts extra options, for the list of available options check <a href="http://www.erlang.org/doc/man/erlang.html#spawn_opt-4" target="_blank"><code class="inline">:erlang.spawn_opt/4</code></a>.</p> <p>Inlined by the compiler.</p>    <h3 class="detail-header function" id="unlink/1">  <span class="signature">unlink(pid)</span>     </h3>
<pre data-language="elixir">unlink(pid | port) :: true</pre>  <p>Removes the link, if there is one, between the calling process and the process or port referred to by <code class="inline">pid</code>. Returns <code class="inline">true</code> and does not fail, even if there is no link or <code class="inline">id</code> does not exist</p> <p>See <a href="http://www.erlang.org/doc/man/erlang.html#unlink-1" target="_blank"><code class="inline">:erlang.unlink/1</code></a> for more info.</p> <p>Inlined by the compiler.</p>    <h3 class="detail-header function" id="unregister/1">  <span class="signature">unregister(name)</span>     </h3>
<pre data-language="elixir">unregister(atom) :: true</pre>  <p>Removes the registered <code class="inline">name</code>, associated with a pid or a port identifier.</p> <p>Fails with <a href="../argumenterror/"><code class="inline">ArgumentError</code></a> if the name is not registered to any pid or port.</p> <p>See <a href="http://www.erlang.org/doc/man/erlang.html#unregister-1" target="_blank"><code class="inline">:erlang.unregister/1</code></a> for more info.</p>    <h3 class="detail-header function" id="whereis/1">  <span class="signature">whereis(name)</span>     </h3>
<pre data-language="elixir">whereis(atom) :: pid | port | nil</pre>  <p>Returns the pid or port identifier with the registered <code class="inline">name</code>. Returns <code class="inline">nil</code> if the name is not registered.</p> <p>See <a href="http://www.erlang.org/doc/man/erlang.html#whereis-1" target="_blank"><code class="inline">:erlang.whereis/1</code></a> for more info.</p>
<div class="_attribution">
  <p class="_attribution-p">
    © 2012–2017 Plataformatec<br>Licensed under the Apache License, Version 2.0.<br>
    <a href="https://hexdocs.pm/elixir/1.3.3/Process.html" class="_attribution-link" target="_blank">https://hexdocs.pm/elixir/1.3.3/Process.html</a>
  </p>
</div>

			</div>
		</div>
	</section>

	</div>
</body>
</html>
