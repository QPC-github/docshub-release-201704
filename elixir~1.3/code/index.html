
<!DOCTYPE HTML>

<html lang="en">

<head>
  <meta charset="utf-8">
  <title>Code - Elixir 1.3 - W3cubDocs</title>
  
  <meta name="description" content=" Utilities for managing code compilation, code evaluation and code loading. ">
  <meta name="keywords" content="code, summary, functions, -, elixir, elixir~1.3">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="http://docs.w3cub.com/elixir~1.3/code/">
  <link href="/favicon.png" rel="icon">
  <link type="text/css" rel="stylesheet" href="/assets/application-50364fff564ce3b6327021805f3f00e2957b441cf27f576a7dd4ff63bbc47047.css">
  <script type="text/javascript" src="/assets/application-db64bfd54ceb42be11af7995804cf4902548419ceb79d509b0b7d62c22d98e6f.js"></script>
  <script src="/json/elixir~1.3.js"></script>
  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-71174418-1']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>


</head>

<body>
	<div class="_app">
	<header class="_header">
  
  <form class="_search">
    <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
    <a class="_search-clear"></a>
    <div class="_search-tag"></div>
  </form>
  
  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/elixir~1.3/" class="_nav-link" title="" style="margin-left:0;">Elixir 1.3</a></span>
  
  <nav class="_nav">
    <a href="/app/" class="_nav-link ">App</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		<div class="_list">
			
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<div class="_page _elixir">
				
<h1>  Code  </h1>  <p>Utilities for managing code compilation, code evaluation and code loading.</p> <p>This module complements Erlang’s <a href="http://www.erlang.org/doc/man/code.html" target="_blank"><code class="inline">:code</code> module</a> to add behaviour which is specific to Elixir. Almost all of the functions in this module have global side effects on the behaviour of Elixir.</p>   <h1 class="section-heading" id="summary">  Summary </h1> <h2> Functions </h2>
<dl class="summary-functions summary">   <dt class="summary-signature"> <a href="#append_path/1">append_path(path)</a> </dt> <dd class="summary-synopsis">
<p>Appends a path to the end of the Erlang VM code path list</p> </dd>   <dt class="summary-signature"> <a href="#available_compiler_options/0">available_compiler_options()</a> </dt> <dd class="summary-synopsis">
<p>Returns a list with the available compiler options</p> </dd>   <dt class="summary-signature"> <a href="#compile_quoted/2">compile_quoted(quoted, file \\ "nofile")</a> </dt> <dd class="summary-synopsis">
<p>Compiles the quoted expression</p> </dd>   <dt class="summary-signature"> <a href="#compile_string/2">compile_string(string, file \\ "nofile")</a> </dt> <dd class="summary-synopsis">
<p>Compiles the given string</p> </dd>   <dt class="summary-signature"> <a href="#compiler_options/0">compiler_options()</a> </dt> <dd class="summary-synopsis">
<p>Gets the compilation options from the code server</p> </dd>   <dt class="summary-signature"> <a href="#compiler_options/1">compiler_options(opts)</a> </dt> <dd class="summary-synopsis">
<p>Sets compilation options</p> </dd>   <dt class="summary-signature"> <a href="#delete_path/1">delete_path(path)</a> </dt> <dd class="summary-synopsis">
<p>Deletes a path from the Erlang VM code path list. This is the list of directories the Erlang VM uses for finding module code</p> </dd>   <dt class="summary-signature"> <a href="#ensure_compiled/1">ensure_compiled(module)</a> </dt> <dd class="summary-synopsis">
<p>Ensures the given module is compiled and loaded</p> </dd>   <dt class="summary-signature"> <a href="#ensure_compiled?/1">ensure_compiled?(module)</a> </dt> <dd class="summary-synopsis">
<p>Ensures the given module is compiled and loaded</p> </dd>   <dt class="summary-signature"> <a href="#ensure_loaded/1">ensure_loaded(module)</a> </dt> <dd class="summary-synopsis">
<p>Ensures the given module is loaded</p> </dd>   <dt class="summary-signature"> <a href="#ensure_loaded?/1">ensure_loaded?(module)</a> </dt> <dd class="summary-synopsis">
<p>Ensures the given module is loaded</p> </dd>   <dt class="summary-signature"> <a href="#eval_file/2">eval_file(file, relative_to \\ nil)</a> </dt> <dd class="summary-synopsis">
<p>Evals the given file</p> </dd>   <dt class="summary-signature"> <a href="#eval_quoted/3">eval_quoted(quoted, binding \\ [], opts \\ [])</a> </dt> <dd class="summary-synopsis">
<p>Evaluates the quoted contents</p> </dd>   <dt class="summary-signature"> <a href="#eval_string/3">eval_string(string, binding \\ [], opts \\ [])</a> </dt> <dd class="summary-synopsis">
<p>Evaluates the contents given by <code class="inline">string</code></p> </dd>   <dt class="summary-signature"> <a href="#get_docs/2">get_docs(module, kind)</a> </dt> <dd class="summary-synopsis">
<p>Returns the docs for the given module</p> </dd>   <dt class="summary-signature"> <a href="#load_file/2">load_file(file, relative_to \\ nil)</a> </dt> <dd class="summary-synopsis">
<p>Loads the given file</p> </dd>   <dt class="summary-signature"> <a href="#loaded_files/0">loaded_files()</a> </dt> <dd class="summary-synopsis">
<p>Lists all loaded files</p> </dd>   <dt class="summary-signature"> <a href="#prepend_path/1">prepend_path(path)</a> </dt> <dd class="summary-synopsis">
<p>Prepends a path to the beginning of the Erlang VM code path list</p> </dd>   <dt class="summary-signature"> <a href="#require_file/2">require_file(file, relative_to \\ nil)</a> </dt> <dd class="summary-synopsis">
<p>Requires the given <code class="inline">file</code></p> </dd>   <dt class="summary-signature"> <a href="#string_to_quoted/2">string_to_quoted(string, opts \\ [])</a> </dt> <dd class="summary-synopsis">
<p>Converts the given string to its quoted form</p> </dd>   <dt class="summary-signature"> <a href="#string_to_quoted!/2">string_to_quoted!(string, opts \\ [])</a> </dt> <dd class="summary-synopsis">
<p>Converts the given string to its quoted form</p> </dd>   <dt class="summary-signature"> <a href="#unload_files/1">unload_files(files)</a> </dt> <dd class="summary-synopsis">
<p>Removes files from the loaded files list</p> </dd>  </dl>   <h1 class="section-heading" id="functions">  Functions </h1>  <h3 class="detail-header function" id="append_path/1">  <span class="signature">append_path(path)</span>  </h3>  <p>Appends a path to the end of the Erlang VM code path list.</p> <p>This is the list of directories the Erlang VM uses for finding module code.</p> <p>The path is expanded with <a href="../path/#expand/1"><code class="inline">Path.expand/1</code></a> before being appended. If this path does not exist, an error is returned.</p> <h4 id="append_path/1-examples" class="section-heading">  Examples </h4> <pre data-language="elixir"><code class="elixir">Code.append_path(".") #=&gt; true

Code.append_path("/does_not_exist") #=&gt; {:error, :bad_directory}</code></pre>    <h3 class="detail-header function" id="available_compiler_options/0">  <span class="signature">available_compiler_options()</span>  </h3>  <p>Returns a list with the available compiler options.</p> <p>See <a href="../code/#compiler_options/1"><code class="inline">Code.compiler_options/1</code></a> for more info.</p> <h4 id="available_compiler_options/0-examples" class="section-heading">  Examples </h4> <pre data-language="elixir"><code class="iex elixir">iex&gt; Code.available_compiler_options
[:docs, :debug_info, :ignore_module_conflict, :warnings_as_errors]</code></pre>     <h3 class="detail-header function" id="compile_quoted/2">  <span class="signature">compile_quoted(quoted, file \\ "nofile")</span>  </h3>  <p>Compiles the quoted expression.</p> <p>Returns a list of tuples where the first element is the module name and the second one is its byte code (as a binary).</p>     <h3 class="detail-header function" id="compile_string/2">  <span class="signature">compile_string(string, file \\ "nofile")</span>  </h3>  <p>Compiles the given string.</p> <p>Returns a list of tuples where the first element is the module name and the second one is its byte code (as a binary).</p> <p>For compiling many files at once, check <a href="../kernel.parallelcompiler/#files/2"><code class="inline">Kernel.ParallelCompiler.files/2</code></a>.</p>    <h3 class="detail-header function" id="compiler_options/0">  <span class="signature">compiler_options()</span>  </h3>  <p>Gets the compilation options from the code server.</p> <p>Check <a href="#compiler_options/1"><code class="inline">compiler_options/1</code></a> for more information.</p> <h4 id="compiler_options/0-examples" class="section-heading">  Examples </h4> <pre data-language="elixir"><code class="elixir">Code.compiler_options
#=&gt; %{debug_info: true, docs: true,
      warnings_as_errors: false, ignore_module_conflict: false}</code></pre>    <h3 class="detail-header function" id="compiler_options/1">  <span class="signature">compiler_options(opts)</span>  </h3>  <p>Sets compilation options.</p> <p>These options are global since they are stored by Elixir’s Code Server.</p> <p>Available options are:</p> <ul> <li>
<p><code class="inline">:docs</code> - when <code class="inline">true</code>, retain documentation in the compiled module, <code class="inline">true</code> by default</p> </li> <li>
<p><code class="inline">:debug_info</code> - when <code class="inline">true</code>, retain debug information in the compiled module; this allows a developer to reconstruct the original source code, <code class="inline">false</code> by default</p> </li> <li>
<p><code class="inline">:ignore_module_conflict</code> - when <code class="inline">true</code>, override modules that were already defined without raising errors, <code class="inline">false</code> by default</p> </li> <li>
<code class="inline">:warnings_as_errors</code> - cause compilation to fail when warnings are generated </li> </ul> <p>It returns the new list of compiler options.</p> <h4 id="compiler_options/1-examples" class="section-heading">  Examples </h4> <pre data-language="elixir"><code class="elixir">Code.compiler_options(debug_info: true)
#=&gt; %{debug_info: true, docs: true,
      warnings_as_errors: false, ignore_module_conflict: false}</code></pre>    <h3 class="detail-header function" id="delete_path/1">  <span class="signature">delete_path(path)</span>  </h3>  <p>Deletes a path from the Erlang VM code path list. This is the list of directories the Erlang VM uses for finding module code.</p> <p>The path is expanded with <a href="../path/#expand/1"><code class="inline">Path.expand/1</code></a> before being deleted. If the path does not exist it returns <code class="inline">false</code>.</p> <h4 id="delete_path/1-examples" class="section-heading">  Examples </h4> <pre data-language="elixir"><code class="elixir">Code.prepend_path(".")
Code.delete_path(".") #=&gt; true

Code.delete_path("/does_not_exist") #=&gt; false</code></pre>    <h3 class="detail-header function" id="ensure_compiled/1">  <span class="signature">ensure_compiled(module)</span>  </h3>  <p>Ensures the given module is compiled and loaded.</p> <p>If the module is already loaded, it works as no-op. If the module was not loaded yet, it checks if it needs to be compiled first and then tries to load it.</p> <p>If it succeeds loading the module, it returns <code class="inline">{:module, module}</code>. If not, returns <code class="inline">{:error, reason}</code> with the error reason.</p> <p>Check <a href="#ensure_loaded/1"><code class="inline">ensure_loaded/1</code></a> for more information on module loading and when to use <a href="#ensure_loaded/1"><code class="inline">ensure_loaded/1</code></a> or <a href="#ensure_compiled/1"><code class="inline">ensure_compiled/1</code></a>.</p>    <h3 class="detail-header function" id="ensure_compiled?/1">  <span class="signature">ensure_compiled?(module)</span>  </h3>  <p>Ensures the given module is compiled and loaded.</p> <p>Similar to <a href="#ensure_compiled/1"><code class="inline">ensure_compiled/1</code></a>, but returns <code class="inline">true</code> if the module is already loaded or was successfully loaded and compiled. Returns <code class="inline">false</code> otherwise.</p>    <h3 class="detail-header function" id="ensure_loaded/1">  <span class="signature">ensure_loaded(module)</span>  </h3>  <p>Ensures the given module is loaded.</p> <p>If the module is already loaded, this works as no-op. If the module was not yet loaded, it tries to load it.</p> <p>If it succeeds loading the module, it returns <code class="inline">{:module, module}</code>. If not, returns <code class="inline">{:error, reason}</code> with the error reason.</p> <h4 id="ensure_loaded/1-code-loading-on-the-erlang-vm" class="section-heading">  Code loading on the Erlang VM </h4> <p>Erlang has two modes to load code: interactive and embedded.</p> <p>By default, the Erlang VM runs in interactive mode, where modules are loaded as needed. In embedded mode the opposite happens, as all modules need to be loaded upfront or explicitly.</p> <p>Therefore, this function is used to check if a module is loaded before using it and allows one to react accordingly. For example, the <a href="../uri/"><code class="inline">URI</code></a> module uses this function to check if a specific parser exists for a given URI scheme.</p> <h4 id="ensure_loaded/1-code-ensure_compiled-1" class="section-heading">  Code.ensure_compiled/1 </h4> <p>Elixir also contains an <a href="#ensure_compiled/1"><code class="inline">ensure_compiled/1</code></a> function that is a superset of <a href="#ensure_loaded/1"><code class="inline">ensure_loaded/1</code></a>.</p> <p>Since Elixir’s compilation happens in parallel, in some situations you may need to use a module that was not yet compiled, therefore it can’t even be loaded.</p> <p><a href="#ensure_compiled/1"><code class="inline">ensure_compiled/1</code></a> halts the current process until the module we are depending on is available.</p> <p>In most cases, <a href="#ensure_loaded/1"><code class="inline">ensure_loaded/1</code></a> is enough. <a href="#ensure_compiled/1"><code class="inline">ensure_compiled/1</code></a> must be used in rare cases, usually involving macros that need to invoke a module for callback information.</p> <h4 id="ensure_loaded/1-examples" class="section-heading">  Examples </h4> <pre data-language="elixir"><code class="iex elixir">iex&gt; Code.ensure_loaded(Atom)
{:module, Atom}

iex&gt; Code.ensure_loaded(DoesNotExist)
{:error, :nofile}</code></pre>    <h3 class="detail-header function" id="ensure_loaded?/1">  <span class="signature">ensure_loaded?(module)</span>  </h3>  <p>Ensures the given module is loaded.</p> <p>Similar to <a href="#ensure_loaded/1"><code class="inline">ensure_loaded/1</code></a>, but returns <code class="inline">true</code> if the module is already loaded or was successfully loaded. Returns <code class="inline">false</code> otherwise.</p> <h4 id="ensure_loaded?/1-examples" class="section-heading">  Examples </h4> <pre data-language="elixir"><code class="iex elixir">iex&gt; Code.ensure_loaded?(Atom)
true</code></pre>     <h3 class="detail-header function" id="eval_file/2">  <span class="signature">eval_file(file, relative_to \\ nil)</span>  </h3>  <p>Evals the given file.</p> <p>Accepts <code class="inline">relative_to</code> as an argument to tell where the file is located.</p> <p>While <code class="inline">load_file</code> loads a file and returns the loaded modules and their byte code, <code class="inline">eval_file</code> simply evaluates the file contents and returns the evaluation result and its bindings.</p>      <h3 class="detail-header function" id="eval_quoted/3">  <span class="signature">eval_quoted(quoted, binding \\ [], opts \\ [])</span>  </h3>  <p>Evaluates the quoted contents.</p> <p>See <a href="#eval_string/3"><code class="inline">eval_string/3</code></a> for a description of arguments and return values.</p> <h4 id="eval_quoted/3-examples" class="section-heading">  Examples </h4> <pre data-language="elixir"><code class="iex elixir">iex&gt; contents = quote(do: var!(a) + var!(b))
iex&gt; Code.eval_quoted(contents, [a: 1, b: 2], file: __ENV__.file, line: __ENV__.line)
{3, [a: 1, b: 2]}</code></pre> <p>For convenience, you can pass <code class="inline">__ENV__</code> as the <code class="inline">opts</code> argument and all options will be automatically extracted from the current environment:</p> <pre data-language="elixir"><code class="iex elixir">iex&gt; contents = quote(do: var!(a) + var!(b))
iex&gt; Code.eval_quoted(contents, [a: 1, b: 2], __ENV__)
{3, [a: 1, b: 2]}</code></pre>      <h3 class="detail-header function" id="eval_string/3">  <span class="signature">eval_string(string, binding \\ [], opts \\ [])</span>  </h3>  <p>Evaluates the contents given by <code class="inline">string</code>.</p> <p>The <code class="inline">binding</code> argument is a keyword list of variable bindings. The <code class="inline">opts</code> argument is a keyword list of environment options.</p> <p>Those options can be:</p> <ul> <li>
<code class="inline">:file</code> - the file to be considered in the evaluation </li> <li>
<code class="inline">:line</code> - the line on which the script starts </li> </ul> <p>Additionally, the following scope values can be configured:</p> <ul> <li>
<p><code class="inline">:aliases</code> - a list of tuples with the alias and its target</p> </li> <li>
<p><code class="inline">:requires</code> - a list of modules required</p> </li> <li>
<p><code class="inline">:functions</code> - a list of tuples where the first element is a module and the second a list of imported function names and arity; the list of function names and arity must be sorted</p> </li> <li>
<code class="inline">:macros</code> - a list of tuples where the first element is a module and the second a list of imported macro names and arity; the list of function names and arity must be sorted </li> </ul> <p>Notice that setting any of the values above overrides Elixir’s default values. For example, setting <code class="inline">:requires</code> to <code class="inline">[]</code>, will no longer automatically require the <a href="../kernel/"><code class="inline">Kernel</code></a> module; in the same way setting <code class="inline">:macros</code> will no longer auto-import <a href="../kernel/"><code class="inline">Kernel</code></a> macros like <code class="inline">if/2</code>, <code class="inline">case/2</code>, etc.</p> <p>Returns a tuple of the form <code class="inline">{value, binding}</code>, where <code class="inline">value</code> is the value returned from evaluating <code class="inline">string</code>. If an error occurs while evaluating <code class="inline">string</code> an exception will be raised.</p> <p><code class="inline">binding</code> is a keyword list with the value of all variable bindings after evaluating <code class="inline">string</code>. The binding key is usually an atom, but it may be a tuple for variables defined in a different context.</p> <h4 id="eval_string/3-examples" class="section-heading">  Examples </h4> <pre data-language="elixir"><code class="iex elixir">iex&gt; Code.eval_string("a + b", [a: 1, b: 2], file: __ENV__.file, line: __ENV__.line)
{3, [a: 1, b: 2]}

iex&gt; Code.eval_string("c = a + b", [a: 1, b: 2], __ENV__)
{3, [a: 1, b: 2, c: 3]}

iex&gt; Code.eval_string("a = a + b", [a: 1, b: 2])
{3, [a: 3, b: 2]}</code></pre> <p>For convenience, you can pass <code class="inline">__ENV__</code> as the <code class="inline">opts</code> argument and all imports, requires and aliases defined in the current environment will be automatically carried over:</p> <pre data-language="elixir"><code class="iex elixir">iex&gt; Code.eval_string("a + b", [a: 1, b: 2], __ENV__)
{3, [a: 1, b: 2]}</code></pre>    <h3 class="detail-header function" id="get_docs/2">  <span class="signature">get_docs(module, kind)</span>  </h3>  <p>Returns the docs for the given module.</p> <p>When given a module name, it finds its BEAM code and reads the docs from it.</p> <p>When given a path to a .beam file, it will load the docs directly from that file.</p> <p>The return value depends on the <code class="inline">kind</code> value:</p> <ul> <li>
<p><code class="inline">:docs</code> - list of all docstrings attached to functions and macros using the <code class="inline">@doc</code> attribute</p> </li> <li>
<p><code class="inline">:moduledoc</code> - tuple <code class="inline">{&lt;line&gt;, &lt;doc&gt;}</code> where <code class="inline">line</code> is the line on which module definition starts and <code class="inline">doc</code> is the string attached to the module using the <code class="inline">@moduledoc</code> attribute</p> </li> <li>
<p><code class="inline">:callback_docs</code> - list of all docstrings attached to <code class="inline">@callbacks</code> using the <code class="inline">@doc</code> attribute</p> </li> <li>
<p><code class="inline">:type_docs</code> - list of all docstrings attached to <code class="inline">@type</code> callbacks using the <code class="inline">@typedoc</code> attribute</p> </li> <li>
<code class="inline">:all</code> - a keyword list with <code class="inline">:docs</code> and <code class="inline">:moduledoc</code>, <code class="inline">:callback_docs</code>, and <code class="inline">:type_docs</code>. </li> </ul> <p>If the module cannot be found, it returns <code class="inline">nil</code>.</p> <h4 id="get_docs/2-examples" class="section-heading">  Examples </h4> <pre data-language="elixir"><code class="elixir"># Get the module documentation
iex&gt; {_line, text} = Code.get_docs(Atom, :moduledoc)
iex&gt; String.split(text, "\n") |&gt; Enum.at(0)
"Convenience functions for working with atoms."

# Module doesn't exist
iex&gt; Code.get_docs(ModuleNotGood, :all)
nil</code></pre>     <h3 class="detail-header function" id="load_file/2">  <span class="signature">load_file(file, relative_to \\ nil)</span>  </h3>  <p>Loads the given file.</p> <p>Accepts <code class="inline">relative_to</code> as an argument to tell where the file is located. If the file was already required/loaded, loads it again.</p> <p>It returns a list of tuples <code class="inline">{ModuleName, &lt;&lt;byte_code&gt;&gt;}</code>, one tuple for each module defined in the file.</p> <p>Notice that if <code class="inline">load_file</code> is invoked by different processes concurrently, the target file will be loaded concurrently many times. Check <a href="#require_file/2"><code class="inline">require_file/2</code></a> if you don’t want a file to be loaded concurrently.</p> <h4 id="load_file/2-examples" class="section-heading">  Examples </h4> <pre data-language="elixir"><code class="elixir">Code.load_file("eex_test.exs", "../eex/test") |&gt; List.first
#=&gt; {EExTest.Compiled, &lt;&lt;70, 79, 82, 49, ...&gt;&gt;}</code></pre>    <h3 class="detail-header function" id="loaded_files/0">  <span class="signature">loaded_files()</span>  </h3>  <p>Lists all loaded files.</p> <h4 id="loaded_files/0-examples" class="section-heading">  Examples </h4> <pre data-language="elixir"><code class="elixir">Code.require_file("../eex/test/eex_test.exs")
List.first(Code.loaded_files) =~ "eex_test.exs" #=&gt; true</code></pre>    <h3 class="detail-header function" id="prepend_path/1">  <span class="signature">prepend_path(path)</span>  </h3>  <p>Prepends a path to the beginning of the Erlang VM code path list.</p> <p>This is the list of directories the Erlang VM uses for finding module code.</p> <p>The path is expanded with <a href="../path/#expand/1"><code class="inline">Path.expand/1</code></a> before being prepended. If this path does not exist, an error is returned.</p> <h4 id="prepend_path/1-examples" class="section-heading">  Examples </h4> <pre data-language="elixir"><code class="elixir">Code.prepend_path(".") #=&gt; true

Code.prepend_path("/does_not_exist") #=&gt; {:error, :bad_directory}</code></pre>     <h3 class="detail-header function" id="require_file/2">  <span class="signature">require_file(file, relative_to \\ nil)</span>  </h3>  <p>Requires the given <code class="inline">file</code>.</p> <p>Accepts <code class="inline">relative_to</code> as an argument to tell where the file is located. The return value is the same as that of <a href="#load_file/2"><code class="inline">load_file/2</code></a>. If the file was already required/loaded, doesn’t do anything and returns <code class="inline">nil</code>.</p> <p>Notice that if <code class="inline">require_file</code> is invoked by different processes concurrently, the first process to invoke <code class="inline">require_file</code> acquires a lock and the remaining ones will block until the file is available. I.e. if <code class="inline">require_file</code> is called N times with a given file, it will be loaded only once. The first process to call <code class="inline">require_file</code> will get the list of loaded modules, others will get <code class="inline">nil</code>.</p> <p>Check <a href="#load_file/2"><code class="inline">load_file/2</code></a> if you want a file to be loaded multiple times. See also <a href="#unload_files/1"><code class="inline">unload_files/1</code></a></p> <h4 id="require_file/2-examples" class="section-heading">  Examples </h4> <p>If the code is already loaded, it returns <code class="inline">nil</code>:</p> <pre data-language="elixir"><code class="elixir">Code.require_file("eex_test.exs", "../eex/test") #=&gt; nil</code></pre> <p>If the code is not loaded yet, it returns the same as <a href="#load_file/2"><code class="inline">load_file/2</code></a>:</p> <pre data-language="elixir"><code class="elixir">Code.require_file("eex_test.exs", "../eex/test") |&gt; List.first
#=&gt; {EExTest.Compiled, &lt;&lt;70, 79, 82, 49, ...&gt;&gt;}</code></pre>     <h3 class="detail-header function" id="string_to_quoted/2">  <span class="signature">string_to_quoted(string, opts \\ [])</span>  </h3>  <p>Converts the given string to its quoted form.</p> <p>Returns <code class="inline">{:ok, quoted_form}</code> if it succeeds, <code class="inline">{:error, {line, error, token}}</code> otherwise.</p> <h4 id="string_to_quoted/2-options" class="section-heading">  Options </h4> <ul> <li>
<p><code class="inline">:file</code> - the filename to be used in stacktraces and the file reported in the <code class="inline">__ENV__</code> variable</p> </li> <li>
<p><code class="inline">:line</code> - the line reported in the <code class="inline">__ENV__</code> variable</p> </li> <li>
<code class="inline">:existing_atoms_only</code> - when <code class="inline">true</code>, raises an error when non-existing atoms are found by the tokenizer </li> </ul> <h4 id="string_to_quoted/2-macro-to_string-2" class="section-heading">  Macro.to_string/2 </h4> <p>The opposite of converting a string to its quoted form is <a href="../macro/#to_string/2"><code class="inline">Macro.to_string/2</code></a>, which converts a quoted form to a string/binary representation.</p>     <h3 class="detail-header function" id="string_to_quoted!/2">  <span class="signature">string_to_quoted!(string, opts \\ [])</span>  </h3>  <p>Converts the given string to its quoted form.</p> <p>It returns the ast if it succeeds, raises an exception otherwise. The exception is a <a href="../tokenmissingerror/"><code class="inline">TokenMissingError</code></a> in case a token is missing (usually because the expression is incomplete), <a href="../syntaxerror/"><code class="inline">SyntaxError</code></a> otherwise.</p> <p>Check <a href="#string_to_quoted/2"><code class="inline">string_to_quoted/2</code></a> for options information.</p>    <h3 class="detail-header function" id="unload_files/1">  <span class="signature">unload_files(files)</span>  </h3>  <p>Removes files from the loaded files list.</p> <p>The modules defined in the file are not removed; calling this function only removes them from the list, allowing them to be required again.</p> <h4 id="unload_files/1-examples" class="section-heading">  Examples </h4> <pre data-language="elixir"><code class="elixir"># Load EEx test code, unload file, check for functions still available
Code.load_file("../eex/test/eex_test.exs")
Code.unload_files(Code.loaded_files)
function_exported?(EExTest.Compiled, :before_compile, 0) #=&gt; true</code></pre>
<div class="_attribution">
  <p class="_attribution-p">
    © 2012–2017 Plataformatec<br>Licensed under the Apache License, Version 2.0.<br>
    <a href="https://hexdocs.pm/elixir/1.3.3/Code.html" class="_attribution-link" target="_blank">https://hexdocs.pm/elixir/1.3.3/Code.html</a>
  </p>
</div>

			</div>
		</div>
	</section>

	</div>
</body>
</html>
