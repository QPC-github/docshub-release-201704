
<!DOCTYPE HTML>

<html lang="en">

<head>
  <meta charset="utf-8">
  <title>Enum - Elixir 1.3 - W3cubDocs</title>
  
  <meta name="description" content=" Provides a set of algorithms that enumerate over enumerables according to the Enumerable protocol. ">
  <meta name="keywords" content="enum, summary, types, functions, -, elixir, elixir~1.3">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="http://docs.w3cub.com/elixir~1.3/enum/">
  <link href="/favicon.png" rel="icon">
  <link type="text/css" rel="stylesheet" href="/assets/application-50364fff564ce3b6327021805f3f00e2957b441cf27f576a7dd4ff63bbc47047.css">
  <script type="text/javascript" src="/assets/application-db64bfd54ceb42be11af7995804cf4902548419ceb79d509b0b7d62c22d98e6f.js"></script>
  <script src="/json/elixir~1.3.js"></script>
  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-71174418-1']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>


</head>

<body>
	<div class="_app">
	<header class="_header">
  
  <form class="_search">
    <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
    <a class="_search-clear"></a>
    <div class="_search-tag"></div>
  </form>
  
  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/elixir~1.3/" class="_nav-link" title="" style="margin-left:0;">Elixir 1.3</a></span>
  
  <nav class="_nav">
    <a href="/app/" class="_nav-link ">App</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		<div class="_list">
			
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<div class="_page _elixir">
				
<h1>  Enum  </h1>  <p>Provides a set of algorithms that enumerate over enumerables according to the <a href="../enumerable/"><code class="inline">Enumerable</code></a> protocol.</p> <pre data-language="elixir"><code class="iex elixir">iex&gt; Enum.map([1, 2, 3], fn(x) -&gt; x * 2 end)
[2, 4, 6]</code></pre> <p>Some particular types, like maps, yield a specific format on enumeration. For example, the argument is always a <code class="inline">{key, value}</code> tuple for maps:</p> <pre data-language="elixir"><code class="iex elixir">iex&gt; map = %{a: 1, b: 2}
iex&gt; Enum.map(map, fn {k, v} -&gt; {k, v * 2} end)
[a: 2, b: 4]</code></pre> <p>Note that the functions in the <a href="../enum/#content"><code class="inline">Enum</code></a> module are eager: they always start the enumeration of the given enumerable. The <a href="../stream/"><code class="inline">Stream</code></a> module allows lazy enumeration of enumerables and provides infinite streams.</p> <p>Since the majority of the functions in <a href="../enum/#content"><code class="inline">Enum</code></a> enumerate the whole enumerable and return a list as result, infinite streams need to be carefully used with such functions, as they can potentially run forever. For example:</p> <pre data-language="elixir"><code class="elixir">Enum.each Stream.cycle([1, 2, 3]), &amp;IO.puts(&amp;1)</code></pre>   <h1 class="section-heading" id="summary">  Summary </h1> <h2> Types </h2>
<dl class="summary-types summary">   <dt class="summary-signature"> <a href="#t:default/0">default()</a> </dt>   <dt class="summary-signature"> <a href="#t:element/0">element()</a> </dt>   <dt class="summary-signature"> <a href="#t:index/0">index()</a> </dt>   <dt class="summary-signature"> <a href="#t:t/0">t()</a> </dt>  </dl> <h2> Functions </h2>
<dl class="summary-functions summary">   <dt class="summary-signature"> <a href="#all?/2">all?(enumerable, fun \\ fn x -&gt; x end)</a> </dt> <dd class="summary-synopsis">
<p>Invokes the given <code class="inline">fun</code> for each item in the enumerable. It stops the iteration at the first invocation that returns <code class="inline">false</code> or <code class="inline">nil</code>. It returns <code class="inline">false</code> if at least one invocation returns <code class="inline">false</code> or <code class="inline">nil</code>. Otherwise returns <code class="inline">true</code></p> </dd>   <dt class="summary-signature"> <a href="#any?/2">any?(enumerable, fun \\ fn x -&gt; x end)</a> </dt> <dd class="summary-synopsis">
<p>Invokes the given <code class="inline">fun</code> for each item in the enumerable. It stops the iteration at the first invocation that returns a truthy value. Returns <code class="inline">true</code> if at least one invocation returns a truthy value. Otherwise returns <code class="inline">false</code></p> </dd>   <dt class="summary-signature"> <a href="#at/3">at(enumerable, index, default \\ nil)</a> </dt> <dd class="summary-synopsis">
<p>Finds the element at the given <code class="inline">index</code> (zero-based)</p> </dd>   <dt class="summary-signature"> <a href="#chunk/2">chunk(enumerable, count)</a> </dt> <dd class="summary-synopsis">
<p>Shortcut to <code class="inline">chunk(enumerable, count, count)</code></p> </dd>   <dt class="summary-signature"> <a href="#chunk/4">chunk(enumerable, count, step, leftover \\ nil)</a> </dt> <dd class="summary-synopsis">
<p>Returns list of lists containing <code class="inline">count</code> items each, where each new chunk starts <code class="inline">step</code> elements into the enumerable</p> </dd>   <dt class="summary-signature"> <a href="#chunk_by/2">chunk_by(enumerable, fun)</a> </dt> <dd class="summary-synopsis">
<p>Splits enumerable on every element for which <code class="inline">fun</code> returns a new value</p> </dd>   <dt class="summary-signature"> <a href="#concat/1">concat(enumerables)</a> </dt> <dd class="summary-synopsis">
<p>Given an enumerable of enumerables, concatenates the enumerables into a single list</p> </dd>   <dt class="summary-signature"> <a href="#concat/2">concat(left, right)</a> </dt> <dd class="summary-synopsis">
<p>Concatenates the enumerable on the right with the enumerable on the left</p> </dd>   <dt class="summary-signature"> <a href="#count/1">count(enumerable)</a> </dt> <dd class="summary-synopsis">
<p>Returns the size of the enumerable</p> </dd>   <dt class="summary-signature"> <a href="#count/2">count(enumerable, fun)</a> </dt> <dd class="summary-synopsis">
<p>Returns the count of items in the enumerable for which <code class="inline">fun</code> returns a truthy value</p> </dd>   <dt class="summary-signature"> <a href="#dedup/1">dedup(enumerable)</a> </dt> <dd class="summary-synopsis">
<p>Enumerates the <code class="inline">enumerable</code>, returning a list where all consecutive duplicated elements are collapsed to a single element</p> </dd>   <dt class="summary-signature"> <a href="#dedup_by/2">dedup_by(enumerable, fun)</a> </dt> <dd class="summary-synopsis">
<p>Enumerates the <code class="inline">enumerable</code>, returning a list where all consecutive duplicated elements are collapsed to a single element</p> </dd>   <dt class="summary-signature"> <a href="#drop/2">drop(enumerable, n)</a> </dt> <dd class="summary-synopsis">
<p>Drops the first <code class="inline">n</code> items from then enumerable</p> </dd>   <dt class="summary-signature"> <a href="#drop_every/2">drop_every(enumerable, nth)</a> </dt> <dd class="summary-synopsis">
<p>Returns a list of every <code class="inline">nth</code> item in the enumerable dropped, starting with the first element</p> </dd>   <dt class="summary-signature"> <a href="#drop_while/2">drop_while(enumerable, fun)</a> </dt> <dd class="summary-synopsis">
<p>Drops items at the beginning of the enumerable while <code class="inline">fun</code> returns a truthy value</p> </dd>   <dt class="summary-signature"> <a href="#each/2">each(enumerable, fun)</a> </dt> <dd class="summary-synopsis">
<p>Invokes the given <code class="inline">fun</code> for each item in the enumerable</p> </dd>   <dt class="summary-signature"> <a href="#empty?/1">empty?(enumerable)</a> </dt> <dd class="summary-synopsis">
<p>Determines if the enumerable is empty</p> </dd>   <dt class="summary-signature"> <a href="#fetch/2">fetch(enumerable, index)</a> </dt> <dd class="summary-synopsis">
<p>Finds the element at the given <code class="inline">index</code> (zero-based)</p> </dd>   <dt class="summary-signature"> <a href="#fetch!/2">fetch!(enumerable, index)</a> </dt> <dd class="summary-synopsis">
<p>Finds the element at the given <code class="inline">index</code> (zero-based)</p> </dd>   <dt class="summary-signature"> <a href="#filter/2">filter(enumerable, fun)</a> </dt> <dd class="summary-synopsis">
<p>Filters the enumerable, i.e. returns only those elements for which <code class="inline">fun</code> returns a truthy value</p> </dd>   <dt class="summary-signature"> <a href="#filter_map/3">filter_map(enumerable, filter, mapper)</a> </dt> <dd class="summary-synopsis">
<p>Filters the enumerable and maps its elements in one pass</p> </dd>   <dt class="summary-signature"> <a href="#find/3">find(enumerable, default \\ nil, fun)</a> </dt> <dd class="summary-synopsis">
<p>Returns the first item for which <code class="inline">fun</code> returns a truthy value. If no such item is found, returns <code class="inline">default</code></p> </dd>   <dt class="summary-signature"> <a href="#find_index/2">find_index(enumerable, fun)</a> </dt> <dd class="summary-synopsis">
<p>Similar to <a href="#find/3"><code class="inline">find/3</code></a>, but returns the index (zero-based) of the element instead of the element itself</p> </dd>   <dt class="summary-signature"> <a href="#find_value/3">find_value(enumerable, default \\ nil, fun)</a> </dt> <dd class="summary-synopsis">
<p>Similar to <a href="#find/3"><code class="inline">find/3</code></a>, but returns the value of the function invocation instead of the element itself</p> </dd>   <dt class="summary-signature"> <a href="#flat_map/2">flat_map(enumerable, fun)</a> </dt> <dd class="summary-synopsis">
<p>Returns a new enumerable appending the result of invoking <code class="inline">fun</code> on each corresponding item of <code class="inline">enumerable</code></p> </dd>   <dt class="summary-signature"> <a href="#flat_map_reduce/3">flat_map_reduce(enumerable, acc, fun)</a> </dt> <dd class="summary-synopsis">
<p>Maps and reduces an enumerable, flattening the given results (only one level deep)</p> </dd>   <dt class="summary-signature"> <a href="#group_by/3">group_by(enumerable, key_fun, mapper_fun \\ fn x -&gt; x end)</a> </dt> <dd class="summary-synopsis">
<p>Splits the enumerable into groups based on <code class="inline">fun</code></p> </dd>   <dt class="summary-signature"> <a href="#intersperse/2">intersperse(enumerable, element)</a> </dt> <dd class="summary-synopsis">
<p>Intersperses <code class="inline">element</code> between each element of the enumeration</p> </dd>   <dt class="summary-signature"> <a href="#into/2">into(enumerable, collectable)</a> </dt> <dd class="summary-synopsis">
<p>Inserts the given <code class="inline">enumerable</code> into a <code class="inline">collectable</code></p> </dd>   <dt class="summary-signature"> <a href="#into/3">into(enumerable, collectable, transform)</a> </dt> <dd class="summary-synopsis">
<p>Inserts the given <code class="inline">enumerable</code> into a <code class="inline">collectable</code> according to the transformation function</p> </dd>   <dt class="summary-signature"> <a href="#join/2">join(enumerable, joiner \\ "")</a> </dt> <dd class="summary-synopsis">
<p>Joins the given enumerable into a binary using <code class="inline">joiner</code> as a separator</p> </dd>   <dt class="summary-signature"> <a href="#map/2">map(enumerable, fun)</a> </dt> <dd class="summary-synopsis">
<p>Returns a list where each item is the result of invoking <code class="inline">fun</code> on each corresponding item of <code class="inline">enumerable</code></p> </dd>   <dt class="summary-signature"> <a href="#map_join/3">map_join(enumerable, joiner \\ "", mapper)</a> </dt> <dd class="summary-synopsis">
<p>Maps and joins the given enumerable in one pass</p> </dd>   <dt class="summary-signature"> <a href="#map_reduce/3">map_reduce(enumerable, acc, fun)</a> </dt> <dd class="summary-synopsis">
<p>Invokes the given function to each item in the enumerable to reduce it to a single element, while keeping an accumulator</p> </dd>   <dt class="summary-signature"> <a href="#max/1">max(enumerable)</a> </dt> <dd class="summary-synopsis">
<p>Returns the maximal element in the enumerable according to Erlang’s term ordering</p> </dd>   <dt class="summary-signature"> <a href="#max_by/2">max_by(enumerable, fun)</a> </dt> <dd class="summary-synopsis">
<p>Returns the maximal element in the enumerable as calculated by the given function</p> </dd>   <dt class="summary-signature"> <a href="#member?/2">member?(enumerable, element)</a> </dt> <dd class="summary-synopsis">
<p>Checks if <code class="inline">element</code> exists within the enumerable</p> </dd>   <dt class="summary-signature"> <a href="#min/1">min(enumerable)</a> </dt> <dd class="summary-synopsis">
<p>Returns the minimal element in the enumerable according to Erlang’s term ordering</p> </dd>   <dt class="summary-signature"> <a href="#min_by/2">min_by(enumerable, fun)</a> </dt> <dd class="summary-synopsis">
<p>Returns the minimal element in the enumerable as calculated by the given function</p> </dd>   <dt class="summary-signature"> <a href="#min_max/1">min_max(enumerable)</a> </dt> <dd class="summary-synopsis">
<p>Returns a tuple with the minimal and the maximal elements in the enumerable according to Erlang’s term ordering</p> </dd>   <dt class="summary-signature"> <a href="#min_max_by/2">min_max_by(enumerable, fun)</a> </dt> <dd class="summary-synopsis">
<p>Returns a tuple with the minimal and the maximal elements in the enumerable as calculated by the given function</p> </dd>   <dt class="summary-signature"> <a href="#partition/2">partition(enumerable, fun)</a> </dt> <dd class="summary-synopsis">
<p>Partitions <code class="inline">enumerable</code> into two lists, where the first one contains elements for which <code class="inline">fun</code> returns a truthy value, and the second one – for which <code class="inline">fun</code> returns <code class="inline">false</code> or <code class="inline">nil</code></p> </dd>   <dt class="summary-signature"> <a href="#random/1">random(enumerable)</a> </dt> <dd class="summary-synopsis">
<p>Returns a random element of an enumerable</p> </dd>   <dt class="summary-signature"> <a href="#reduce/2">reduce(enumerable, fun)</a> </dt> <dd class="summary-synopsis">
<p>Invokes <code class="inline">fun</code> for each element in the <code class="inline">enumerable</code>, passing that element and the accumulator as arguments. <code class="inline">fun</code>’s return value is stored in the accumulator</p> </dd>   <dt class="summary-signature"> <a href="#reduce/3">reduce(enumerable, acc, fun)</a> </dt> <dd class="summary-synopsis">
<p>Invokes <code class="inline">fun</code> for each element in the <code class="inline">enumerable</code>, passing that element and the accumulator <code class="inline">acc</code> as arguments. <code class="inline">fun</code>’s return value is stored in <code class="inline">acc</code></p> </dd>   <dt class="summary-signature"> <a href="#reduce_while/3">reduce_while(enumerable, acc, fun)</a> </dt> <dd class="summary-synopsis">
<p>Reduces the enumerable until <code class="inline">halt</code> is emitted</p> </dd>   <dt class="summary-signature"> <a href="#reject/2">reject(enumerable, fun)</a> </dt> <dd class="summary-synopsis">
<p>Returns elements of <code class="inline">enumerable</code> for which the function <code class="inline">fun</code> returns <code class="inline">false</code> or <code class="inline">nil</code></p> </dd>   <dt class="summary-signature"> <a href="#reverse/1">reverse(enumerable)</a> </dt> <dd class="summary-synopsis">
<p>Returns a list of elements in <code class="inline">enumerable</code> in reverse order</p> </dd>   <dt class="summary-signature"> <a href="#reverse/2">reverse(enumerable, tail)</a> </dt> <dd class="summary-synopsis">
<p>Reverses the elements in <code class="inline">enumerable</code>, appends the tail, and returns it as a list</p> </dd>   <dt class="summary-signature"> <a href="#reverse_slice/3">reverse_slice(enumerable, start, count)</a> </dt> <dd class="summary-synopsis">
<p>Reverses the enumerable in the range from initial position <code class="inline">start</code> through <code class="inline">count</code> elements</p> </dd>   <dt class="summary-signature"> <a href="#scan/2">scan(enumerable, fun)</a> </dt> <dd class="summary-synopsis">
<p>Applies the given function to each element in the enumerable, storing the result in a list and passing it as the accumulator for the next computation</p> </dd>   <dt class="summary-signature"> <a href="#scan/3">scan(enumerable, acc, fun)</a> </dt> <dd class="summary-synopsis">
<p>Applies the given function to each element in the enumerable, storing the result in a list and passing it as the accumulator for the next computation. Uses the given <code class="inline">acc</code> as the starting value</p> </dd>   <dt class="summary-signature"> <a href="#shuffle/1">shuffle(enumerable)</a> </dt> <dd class="summary-synopsis">
<p>Returns a list with the elements of <code class="inline">enumerable</code> shuffled</p> </dd>   <dt class="summary-signature"> <a href="#slice/2">slice(enumerable, range)</a> </dt> <dd class="summary-synopsis">
<p>Returns a subset list of the given enumerable. Drops elements until element position <code class="inline">range.first</code>, then takes elements until element position <code class="inline">range.last</code> (inclusive)</p> </dd>   <dt class="summary-signature"> <a href="#slice/3">slice(enumerable, start, count)</a> </dt> <dd class="summary-synopsis">
<p>Returns a subset list of the given enumerable. Drops elements until element position <code class="inline">start</code>, then takes <code class="inline">count</code> elements</p> </dd>   <dt class="summary-signature"> <a href="#sort/1">sort(enumerable)</a> </dt> <dd class="summary-synopsis">
<p>Sorts the enumerable according to Erlang’s term ordering</p> </dd>   <dt class="summary-signature"> <a href="#sort/2">sort(enumerable, fun)</a> </dt> <dd class="summary-synopsis">
<p>Sorts the enumerable by the given function</p> </dd>   <dt class="summary-signature"> <a href="#sort_by/3">sort_by(enumerable, mapper, sorter \\ &amp;&lt;=/2)</a> </dt> <dd class="summary-synopsis">
<p>Sorts the mapped results of the enumerable according to the <code class="inline">sorter</code> function</p> </dd>   <dt class="summary-signature"> <a href="#split/2">split(enumerable, count)</a> </dt> <dd class="summary-synopsis">
<p>Splits the <code class="inline">enumerable</code> into two enumerables, leaving <code class="inline">count</code> elements in the first one. If <code class="inline">count</code> is a negative number, it starts counting from the back to the beginning of the enumerable</p> </dd>   <dt class="summary-signature"> <a href="#split_while/2">split_while(enumerable, fun)</a> </dt> <dd class="summary-synopsis">
<p>Splits enumerable in two at the position of the element for which <code class="inline">fun</code> returns <code class="inline">false</code> for the first time</p> </dd>   <dt class="summary-signature"> <a href="#sum/1">sum(enumerable)</a> </dt> <dd class="summary-synopsis">
<p>Returns the sum of all elements</p> </dd>   <dt class="summary-signature"> <a href="#take/2">take(enumerable, count)</a> </dt> <dd class="summary-synopsis">
<p>Takes the first <code class="inline">count</code> items from the enumerable</p> </dd>   <dt class="summary-signature"> <a href="#take_every/2">take_every(enumerable, nth)</a> </dt> <dd class="summary-synopsis">
<p>Returns a list of every <code class="inline">nth</code> item in the enumerable, starting with the first element</p> </dd>   <dt class="summary-signature"> <a href="#take_random/2">take_random(enumerable, count)</a> </dt> <dd class="summary-synopsis">
<p>Takes random items from <code class="inline">enumerable</code></p> </dd>   <dt class="summary-signature"> <a href="#take_while/2">take_while(enumerable, fun)</a> </dt> <dd class="summary-synopsis">
<p>Takes the items from the beginning of the enumerable while <code class="inline">fun</code> returns a truthy value</p> </dd>   <dt class="summary-signature"> <a href="#to_list/1">to_list(enumerable)</a> </dt> <dd class="summary-synopsis">
<p>Converts <code class="inline">enumerable</code> to a list</p> </dd>   <dt class="summary-signature"> <a href="#uniq/1">uniq(enumerable)</a> </dt> <dd class="summary-synopsis">
<p>Enumerates the <code class="inline">enumerable</code>, removing all duplicated elements</p> </dd>   <dt class="summary-signature"> <a href="#uniq_by/2">uniq_by(enumerable, fun)</a> </dt> <dd class="summary-synopsis">
<p>Enumerates the <code class="inline">enumerable</code>, by removing the elements for which function <code class="inline">fun</code> returned duplicate items</p> </dd>   <dt class="summary-signature"> <a href="#unzip/1">unzip(enumerable)</a> </dt> <dd class="summary-synopsis">
<p>Opposite of <a href="../enum/#zip/2"><code class="inline">Enum.zip/2</code></a>; extracts a two-element tuples from the enumerable and groups them together</p> </dd>   <dt class="summary-signature"> <a href="#with_index/2">with_index(enumerable, offset \\ 0)</a> </dt> <dd class="summary-synopsis">
<p>Returns the enumerable with each element wrapped in a tuple alongside its index</p> </dd>   <dt class="summary-signature"> <a href="#zip/2">zip(enumerable1, enumerable2)</a> </dt> <dd class="summary-synopsis">
<p>Zips corresponding elements from two enumerables into one list of tuples</p> </dd>  </dl>   <h1 class="section-heading" id="types">  Types </h1>   <h3 class="detail-header type" id="t:default/0">  <span class="signature">default()</span>     </h3>
<pre data-language="elixir">default() :: any</pre>     <h3 class="detail-header type" id="t:element/0">  <span class="signature">element()</span>     </h3>
<pre data-language="elixir">element() :: any</pre>     <h3 class="detail-header type" id="t:index/0">  <span class="signature">index()</span>     </h3>
<pre data-language="elixir">index() :: non_neg_integer</pre>     <h3 class="detail-header type" id="t:t/0">  <span class="signature">t()</span>     </h3>
<pre data-language="elixir">t() :: <a href="../enumerable/#t:t/0">Enumerable.t</a></pre>       <h1 class="section-heading" id="functions">  Functions </h1>   <h3 class="detail-header function" id="all?/2">  <span class="signature">all?(enumerable, fun \\ fn x -&gt; x end)</span>     </h3>
<pre data-language="elixir">all?(<a href="#t:t/0">t</a>, (<a href="#t:element/0">element</a> -&gt; as_boolean(term))) :: boolean</pre>  <p>Invokes the given <code class="inline">fun</code> for each item in the enumerable. It stops the iteration at the first invocation that returns <code class="inline">false</code> or <code class="inline">nil</code>. It returns <code class="inline">false</code> if at least one invocation returns <code class="inline">false</code> or <code class="inline">nil</code>. Otherwise returns <code class="inline">true</code>.</p> <h4 id="all?/2-examples" class="section-heading">  Examples </h4> <pre data-language="elixir"><code class="iex elixir">iex&gt; Enum.all?([2, 4, 6], fn(x) -&gt; rem(x, 2) == 0 end)
true

iex&gt; Enum.all?([2, 3, 4], fn(x) -&gt; rem(x, 2) == 0 end)
false</code></pre> <p>If no function is given, it defaults to checking if all items in the enumerable are truthy values.</p> <pre data-language="elixir"><code class="iex elixir">iex&gt; Enum.all?([1, 2, 3])
true

iex&gt; Enum.all?([1, nil, 3])
false</code></pre>     <h3 class="detail-header function" id="any?/2">  <span class="signature">any?(enumerable, fun \\ fn x -&gt; x end)</span>     </h3>
<pre data-language="elixir">any?(<a href="#t:t/0">t</a>, (<a href="#t:element/0">element</a> -&gt; as_boolean(term))) :: boolean</pre>  <p>Invokes the given <code class="inline">fun</code> for each item in the enumerable. It stops the iteration at the first invocation that returns a truthy value. Returns <code class="inline">true</code> if at least one invocation returns a truthy value. Otherwise returns <code class="inline">false</code>.</p> <h4 id="any?/2-examples" class="section-heading">  Examples </h4> <pre data-language="elixir"><code class="iex elixir">iex&gt; Enum.any?([2, 4, 6], fn(x) -&gt; rem(x, 2) == 1 end)
false

iex&gt; Enum.any?([2, 3, 4], fn(x) -&gt; rem(x, 2) == 1 end)
true</code></pre> <p>If no function is given, it defaults to checking if at least one item in the enumerable is a truthy value.</p> <pre data-language="elixir"><code class="iex elixir">iex&gt; Enum.any?([false, false, false])
false

iex&gt; Enum.any?([false, true, false])
true</code></pre>     <h3 class="detail-header function" id="at/3">  <span class="signature">at(enumerable, index, default \\ nil)</span>     </h3>
<pre data-language="elixir">at(<a href="#t:t/0">t</a>, integer, <a href="#t:default/0">default</a>) :: <a href="#t:element/0">element</a> | <a href="#t:default/0">default</a></pre>  <p>Finds the element at the given <code class="inline">index</code> (zero-based).</p> <p>Returns <code class="inline">default</code> if <code class="inline">index</code> is out of bounds.</p> <p>A negative <code class="inline">index</code> can be passed, which means the <code class="inline">enumerable</code> is enumerated once and the <code class="inline">index</code> is counted from the end (e.g. <code class="inline">-1</code> finds the last element).</p> <p>Note this operation takes linear time. In order to access the element at index <code class="inline">index</code>, it will need to traverse <code class="inline">index</code> previous elements.</p> <h4 id="at/3-examples" class="section-heading">  Examples </h4> <pre data-language="elixir"><code class="iex elixir">iex&gt; Enum.at([2, 4, 6], 0)
2

iex&gt; Enum.at([2, 4, 6], 2)
6

iex&gt; Enum.at([2, 4, 6], 4)
nil

iex&gt; Enum.at([2, 4, 6], 4, :none)
:none</code></pre>    <h3 class="detail-header function" id="chunk/2">  <span class="signature">chunk(enumerable, count)</span>     </h3>
<pre data-language="elixir">chunk(<a href="#t:t/0">t</a>, pos_integer) :: [list]</pre>  <p>Shortcut to <code class="inline">chunk(enumerable, count, count)</code>.</p>     <h3 class="detail-header function" id="chunk/4">  <span class="signature">chunk(enumerable, count, step, leftover \\ nil)</span>     </h3>
<pre data-language="elixir">chunk(<a href="#t:t/0">t</a>, pos_integer, pos_integer, <a href="#t:t/0">t</a> | nil) :: [list]</pre>  <p>Returns list of lists containing <code class="inline">count</code> items each, where each new chunk starts <code class="inline">step</code> elements into the enumerable.</p> <p><code class="inline">step</code> is optional and, if not passed, defaults to <code class="inline">count</code>, i.e. chunks do not overlap.</p> <p>If the final chunk does not have <code class="inline">count</code> elements to fill the chunk, elements are taken as necessary from <code class="inline">leftover</code> if it was passed.</p> <p>If <code class="inline">leftover</code> is passed and does not have enough elements to fill the chunk, then a partial chunk is returned with less than <code class="inline">count</code> elements. If <code class="inline">leftover</code> is not passed at all or is <code class="inline">nil</code>, then the partial chunk is discarded from the result.</p> <p>If <code class="inline">count</code> is greater than the number of elements in the enumerable and <code class="inline">leftover</code> is not passed, empty list will be returned.</p> <h4 id="chunk/4-examples" class="section-heading">  Examples </h4> <pre data-language="elixir"><code class="iex elixir">iex&gt; Enum.chunk([1, 2, 3, 4, 5, 6], 2)
[[1, 2], [3, 4], [5, 6]]

iex&gt; Enum.chunk([1, 2, 3, 4, 5, 6], 3, 2)
[[1, 2, 3], [3, 4, 5]]

iex&gt; Enum.chunk([1, 2, 3, 4, 5, 6], 3, 2, [7])
[[1, 2, 3], [3, 4, 5], [5, 6, 7]]

iex&gt; Enum.chunk([1, 2, 3, 4], 3, 3, [])
[[1, 2, 3], [4]]

iex&gt; Enum.chunk([1, 2, 3, 4], 10)
[]

iex&gt; Enum.chunk([1, 2, 3, 4], 10, 10, [])
[[1, 2, 3, 4]]</code></pre>    <h3 class="detail-header function" id="chunk_by/2">  <span class="signature">chunk_by(enumerable, fun)</span>     </h3>
<pre data-language="elixir">chunk_by(<a href="#t:t/0">t</a>, (<a href="#t:element/0">element</a> -&gt; any)) :: [list]</pre>  <p>Splits enumerable on every element for which <code class="inline">fun</code> returns a new value.</p> <p>Returns a list of lists.</p> <h4 id="chunk_by/2-examples" class="section-heading">  Examples </h4> <pre data-language="elixir"><code class="iex elixir">iex&gt; Enum.chunk_by([1, 2, 2, 3, 4, 4, 6, 7, 7], &amp;(rem(&amp;1, 2) == 1))
[[1], [2, 2], [3], [4, 4, 6], [7, 7]]</code></pre>    <h3 class="detail-header function" id="concat/1">  <span class="signature">concat(enumerables)</span>     </h3>
<pre data-language="elixir">concat(<a href="#t:t/0">t</a>) :: <a href="#t:t/0">t</a></pre>  <p>Given an enumerable of enumerables, concatenates the enumerables into a single list.</p> <h4 id="concat/1-examples" class="section-heading">  Examples </h4> <pre data-language="elixir"><code class="iex elixir">iex&gt; Enum.concat([1..3, 4..6, 7..9])
[1, 2, 3, 4, 5, 6, 7, 8, 9]

iex&gt; Enum.concat([[1, [2], 3], [4], [5, 6]])
[1, [2], 3, 4, 5, 6]</code></pre>    <h3 class="detail-header function" id="concat/2">  <span class="signature">concat(left, right)</span>     </h3>
<pre data-language="elixir">concat(<a href="#t:t/0">t</a>, <a href="#t:t/0">t</a>) :: <a href="#t:t/0">t</a></pre>  <p>Concatenates the enumerable on the right with the enumerable on the left.</p> <p>This function produces the same result as the <a href="../kernel/#++/2"><code class="inline">Kernel.++/2</code></a> operator for lists.</p> <h4 id="concat/2-examples" class="section-heading">  Examples </h4> <pre data-language="elixir"><code class="iex elixir">iex&gt; Enum.concat(1..3, 4..6)
[1, 2, 3, 4, 5, 6]

iex&gt; Enum.concat([1, 2, 3], [4, 5, 6])
[1, 2, 3, 4, 5, 6]</code></pre>    <h3 class="detail-header function" id="count/1">  <span class="signature">count(enumerable)</span>     </h3>
<pre data-language="elixir">count(<a href="#t:t/0">t</a>) :: non_neg_integer</pre>  <p>Returns the size of the enumerable.</p> <h4 id="count/1-examples" class="section-heading">  Examples </h4> <pre data-language="elixir"><code class="iex elixir">iex&gt; Enum.count([1, 2, 3])
3</code></pre>    <h3 class="detail-header function" id="count/2">  <span class="signature">count(enumerable, fun)</span>     </h3>
<pre data-language="elixir">count(<a href="#t:t/0">t</a>, (<a href="#t:element/0">element</a> -&gt; as_boolean(term))) :: non_neg_integer</pre>  <p>Returns the count of items in the enumerable for which <code class="inline">fun</code> returns a truthy value.</p> <h4 id="count/2-examples" class="section-heading">  Examples </h4> <pre data-language="elixir"><code class="iex elixir">iex&gt; Enum.count([1, 2, 3, 4, 5], fn(x) -&gt; rem(x, 2) == 0 end)
2</code></pre>    <h3 class="detail-header function" id="dedup/1">  <span class="signature">dedup(enumerable)</span>     </h3>
<pre data-language="elixir">dedup(<a href="#t:t/0">t</a>) :: list</pre>  <p>Enumerates the <code class="inline">enumerable</code>, returning a list where all consecutive duplicated elements are collapsed to a single element.</p> <p>Elements are compared using <code class="inline">===</code>.</p> <p>If you want to remove all duplicated elements, regardless of order, see <a href="#uniq/1"><code class="inline">uniq/1</code></a>.</p> <h4 id="dedup/1-examples" class="section-heading">  Examples </h4> <pre data-language="elixir"><code class="iex elixir">iex&gt; Enum.dedup([1, 2, 3, 3, 2, 1])
[1, 2, 3, 2, 1]

iex&gt; Enum.dedup([1, 1, 2, 2.0, :three, :"three"])
[1, 2, 2.0, :three]</code></pre>    <h3 class="detail-header function" id="dedup_by/2">  <span class="signature">dedup_by(enumerable, fun)</span>     </h3>
<pre data-language="elixir">dedup_by(<a href="#t:t/0">t</a>, (<a href="#t:element/0">element</a> -&gt; term)) :: list</pre>  <p>Enumerates the <code class="inline">enumerable</code>, returning a list where all consecutive duplicated elements are collapsed to a single element.</p> <p>The function <code class="inline">fun</code> maps every element to a term which is used to determine if two elements are duplicates.</p> <h4 id="dedup_by/2-examples" class="section-heading">  Examples </h4> <pre data-language="elixir"><code class="iex elixir">iex&gt; Enum.dedup_by([{1, :a}, {2, :b}, {2, :c}, {1, :a}], fn {x, _} -&gt; x end)
[{1, :a}, {2, :b}, {1, :a}]

iex&gt; Enum.dedup_by([5, 1, 2, 3, 2, 1], fn x -&gt; x &gt; 2 end)
[5, 1, 3, 2]</code></pre>    <h3 class="detail-header function" id="drop/2">  <span class="signature">drop(enumerable, n)</span>     </h3>
<pre data-language="elixir">drop(<a href="#t:t/0">t</a>, integer) :: list</pre>  <p>Drops the first <code class="inline">n</code> items from then enumerable.</p> <p>If a negative value <code class="inline">n</code> is given, the last <code class="inline">n</code> values will be dropped.</p> <p>The <code class="inline">enumerable</code> is enumerated once to retrieve the proper index and the remaining calculation is performed from the end.</p> <h4 id="drop/2-examples" class="section-heading">  Examples </h4> <pre data-language="elixir"><code class="iex elixir">iex&gt; Enum.drop([1, 2, 3], 2)
[3]

iex&gt; Enum.drop([1, 2, 3], 10)
[]

iex&gt; Enum.drop([1, 2, 3], 0)
[1, 2, 3]

iex&gt; Enum.drop([1, 2, 3], -1)
[1, 2]</code></pre>    <h3 class="detail-header function" id="drop_every/2">  <span class="signature">drop_every(enumerable, nth)</span>     </h3>
<pre data-language="elixir">drop_every(<a href="#t:t/0">t</a>, non_neg_integer) :: list | no_return</pre>  <p>Returns a list of every <code class="inline">nth</code> item in the enumerable dropped, starting with the first element.</p> <p>The first item is always dropped, unless <code class="inline">nth</code> is 0.</p> <p>The second argument specifying every <code class="inline">nth</code> item must be a non-negative integer, otherwise <a href="../functionclauseerror/"><code class="inline">FunctionClauseError</code></a> will be raised.</p> <h4 id="drop_every/2-examples" class="section-heading">  Examples </h4> <pre data-language="elixir"><code class="iex elixir">iex&gt; Enum.drop_every(1..10, 2)
[2, 4, 6, 8, 10]

iex&gt; Enum.drop_every(1..10, 0)
[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]

iex&gt; Enum.drop_every([1, 2, 3], 1)
[]</code></pre>    <h3 class="detail-header function" id="drop_while/2">  <span class="signature">drop_while(enumerable, fun)</span>     </h3>
<pre data-language="elixir">drop_while(<a href="#t:t/0">t</a>, (<a href="#t:element/0">element</a> -&gt; as_boolean(term))) :: list</pre>  <p>Drops items at the beginning of the enumerable while <code class="inline">fun</code> returns a truthy value.</p> <h4 id="drop_while/2-examples" class="section-heading">  Examples </h4> <pre data-language="elixir"><code class="iex elixir">iex&gt; Enum.drop_while([1, 2, 3, 4, 5], fn(x) -&gt; x &lt; 3 end)
[3, 4, 5]</code></pre>    <h3 class="detail-header function" id="each/2">  <span class="signature">each(enumerable, fun)</span>     </h3>
<pre data-language="elixir">each(<a href="#t:t/0">t</a>, (<a href="#t:element/0">element</a> -&gt; any)) :: :ok</pre>  <p>Invokes the given <code class="inline">fun</code> for each item in the enumerable.</p> <p>Returns <code class="inline">:ok</code>.</p> <h4 id="each/2-examples" class="section-heading">  Examples </h4> <pre data-language="elixir"><code class="elixir">Enum.each(["some", "example"], fn(x) -&gt; IO.puts x end)
"some"
"example"
#=&gt; :ok</code></pre>    <h3 class="detail-header function" id="empty?/1">  <span class="signature">empty?(enumerable)</span>     </h3>
<pre data-language="elixir">empty?(<a href="#t:t/0">t</a>) :: boolean</pre>  <p>Determines if the enumerable is empty.</p> <p>Returns <code class="inline">true</code> if <code class="inline">enumerable</code> is empty, otherwise <code class="inline">false</code>.</p> <h4 id="empty?/1-examples" class="section-heading">  Examples </h4> <pre data-language="elixir"><code class="iex elixir">iex&gt; Enum.empty?([])
true

iex&gt; Enum.empty?([1, 2, 3])
false</code></pre>    <h3 class="detail-header function" id="fetch/2">  <span class="signature">fetch(enumerable, index)</span>     </h3>
<pre data-language="elixir">fetch(<a href="#t:t/0">t</a>, integer) :: {:ok, <a href="#t:element/0">element</a>} | :error</pre>  <p>Finds the element at the given <code class="inline">index</code> (zero-based).</p> <p>Returns <code class="inline">{:ok, element}</code> if found, otherwise <code class="inline">:error</code>.</p> <p>A negative <code class="inline">index</code> can be passed, which means the <code class="inline">enumerable</code> is enumerated once and the <code class="inline">index</code> is counted from the end (e.g. <code class="inline">-1</code> fetches the last element).</p> <p>Note this operation takes linear time. In order to access the element at index <code class="inline">index</code>, it will need to traverse <code class="inline">index</code> previous elements.</p> <h4 id="fetch/2-examples" class="section-heading">  Examples </h4> <pre data-language="elixir"><code class="iex elixir">iex&gt; Enum.fetch([2, 4, 6], 0)
{:ok, 2}

iex&gt; Enum.fetch([2, 4, 6], 2)
{:ok, 6}

iex&gt; Enum.fetch([2, 4, 6], 4)
:error</code></pre>    <h3 class="detail-header function" id="fetch!/2">  <span class="signature">fetch!(enumerable, index)</span>     </h3>
<pre data-language="elixir">fetch!(<a href="#t:t/0">t</a>, integer) :: <a href="#t:element/0">element</a> | no_return</pre>  <p>Finds the element at the given <code class="inline">index</code> (zero-based).</p> <p>Raises <code class="inline">OutOfBoundsError</code> if the given <code class="inline">index</code> is outside the range of the enumerable.</p> <p>Note this operation takes linear time. In order to access the element at index <code class="inline">index</code>, it will need to traverse <code class="inline">index</code> previous elements.</p> <h4 id="fetch!/2-examples" class="section-heading">  Examples </h4> <pre data-language="elixir"><code class="iex elixir">iex&gt; Enum.fetch!([2, 4, 6], 0)
2

iex&gt; Enum.fetch!([2, 4, 6], 2)
6

iex&gt; Enum.fetch!([2, 4, 6], 4)
** (Enum.OutOfBoundsError) out of bounds error</code></pre>    <h3 class="detail-header function" id="filter/2">  <span class="signature">filter(enumerable, fun)</span>     </h3>
<pre data-language="elixir">filter(<a href="#t:t/0">t</a>, (<a href="#t:element/0">element</a> -&gt; as_boolean(term))) :: list</pre>  <p>Filters the enumerable, i.e. returns only those elements for which <code class="inline">fun</code> returns a truthy value.</p> <p>See also <a href="#reject/2"><code class="inline">reject/2</code></a>.</p> <h4 id="filter/2-examples" class="section-heading">  Examples </h4> <pre data-language="elixir"><code class="iex elixir">iex&gt; Enum.filter([1, 2, 3], fn(x) -&gt; rem(x, 2) == 0 end)
[2]</code></pre>    <h3 class="detail-header function" id="filter_map/3">  <span class="signature">filter_map(enumerable, filter, mapper)</span>     </h3>
<pre data-language="elixir">filter_map(<a href="#t:t/0">t</a>, (<a href="#t:element/0">element</a> -&gt; as_boolean(term)), (<a href="#t:element/0">element</a> -&gt; <a href="#t:element/0">element</a>)) :: list</pre>  <p>Filters the enumerable and maps its elements in one pass.</p> <h4 id="filter_map/3-examples" class="section-heading">  Examples </h4> <pre data-language="elixir"><code class="iex elixir">iex&gt; Enum.filter_map([1, 2, 3], fn(x) -&gt; rem(x, 2) == 0 end, &amp;(&amp;1 * 2))
[4]</code></pre>     <h3 class="detail-header function" id="find/3">  <span class="signature">find(enumerable, default \\ nil, fun)</span>     </h3>
<pre data-language="elixir">find(<a href="#t:t/0">t</a>, <a href="#t:default/0">default</a>, (<a href="#t:element/0">element</a> -&gt; any)) :: <a href="#t:element/0">element</a> | <a href="#t:default/0">default</a></pre>  <p>Returns the first item for which <code class="inline">fun</code> returns a truthy value. If no such item is found, returns <code class="inline">default</code>.</p> <h4 id="find/3-examples" class="section-heading">  Examples </h4> <pre data-language="elixir"><code class="iex elixir">iex&gt; Enum.find([2, 4, 6], fn(x) -&gt; rem(x, 2) == 1 end)
nil

iex&gt; Enum.find([2, 4, 6], 0, fn(x) -&gt; rem(x, 2) == 1 end)
0

iex&gt; Enum.find([2, 3, 4], fn(x) -&gt; rem(x, 2) == 1 end)
3</code></pre>    <h3 class="detail-header function" id="find_index/2">  <span class="signature">find_index(enumerable, fun)</span>     </h3>
<pre data-language="elixir">find_index(<a href="#t:t/0">t</a>, (<a href="#t:element/0">element</a> -&gt; any)) :: <a href="#t:index/0">index</a> | nil</pre>  <p>Similar to <a href="#find/3"><code class="inline">find/3</code></a>, but returns the index (zero-based) of the element instead of the element itself.</p> <h4 id="find_index/2-examples" class="section-heading">  Examples </h4> <pre data-language="elixir"><code class="iex elixir">iex&gt; Enum.find_index([2, 4, 6], fn(x) -&gt; rem(x, 2) == 1 end)
nil

iex&gt; Enum.find_index([2, 3, 4], fn(x) -&gt; rem(x, 2) == 1 end)
1</code></pre>     <h3 class="detail-header function" id="find_value/3">  <span class="signature">find_value(enumerable, default \\ nil, fun)</span>     </h3>
<pre data-language="elixir">find_value(<a href="#t:t/0">t</a>, any, (<a href="#t:element/0">element</a> -&gt; any)) :: any | nil</pre>  <p>Similar to <a href="#find/3"><code class="inline">find/3</code></a>, but returns the value of the function invocation instead of the element itself.</p> <h4 id="find_value/3-examples" class="section-heading">  Examples </h4> <pre data-language="elixir"><code class="iex elixir">iex&gt; Enum.find_value([2, 4, 6], fn(x) -&gt; rem(x, 2) == 1 end)
nil

iex&gt; Enum.find_value([2, 3, 4], fn(x) -&gt; rem(x, 2) == 1 end)
true

iex&gt; Enum.find_value([1, 2, 3], "no bools!", &amp;is_boolean/1)
"no bools!"</code></pre>    <h3 class="detail-header function" id="flat_map/2">  <span class="signature">flat_map(enumerable, fun)</span>     </h3>
<pre data-language="elixir">flat_map(<a href="#t:t/0">t</a>, (<a href="#t:element/0">element</a> -&gt; <a href="#t:t/0">t</a>)) :: list</pre>  <p>Returns a new enumerable appending the result of invoking <code class="inline">fun</code> on each corresponding item of <code class="inline">enumerable</code>.</p> <p>The given function must return an enumerable.</p> <h4 id="flat_map/2-examples" class="section-heading">  Examples </h4> <pre data-language="elixir"><code class="iex elixir">iex&gt; Enum.flat_map([:a, :b, :c], fn(x) -&gt; [x, x] end)
[:a, :a, :b, :b, :c, :c]

iex&gt; Enum.flat_map([{1, 3}, {4, 6}], fn({x, y}) -&gt; x..y end)
[1, 2, 3, 4, 5, 6]

iex&gt; Enum.flat_map([:a, :b, :c], fn(x) -&gt; [[x]] end)
[[:a], [:b], [:c]]</code></pre>    <h3 class="detail-header function" id="flat_map_reduce/3">  <span class="signature">flat_map_reduce(enumerable, acc, fun)</span>     </h3>
<pre data-language="elixir">flat_map_reduce(<a href="#t:t/0">t</a>, acc, fun) :: {[any], any} when fun: (<a href="#t:element/0">element</a>, acc -&gt; {<a href="#t:t/0">t</a>, acc} | {:halt, acc}), acc: any</pre>  <p>Maps and reduces an enumerable, flattening the given results (only one level deep).</p> <p>It expects an accumulator and a function that receives each enumerable item, and must return a tuple containing a new enumerable (often a list) with the new accumulator or a tuple with <code class="inline">:halt</code> as first element and the accumulator as second.</p> <h4 id="flat_map_reduce/3-examples" class="section-heading">  Examples </h4> <pre data-language="elixir"><code class="iex elixir">iex&gt; enum = 1..100
iex&gt; n = 3
iex&gt; Enum.flat_map_reduce(enum, 0, fn i, acc -&gt;
...&gt;   if acc &lt; n, do: {[i], acc + 1}, else: {:halt, acc}
...&gt; end)
{[1, 2, 3], 3}

iex&gt; Enum.flat_map_reduce(1..5, 0, fn(i, acc) -&gt; {[[i]], acc + i} end)
{[[1], [2], [3], [4], [5]], 15}</code></pre>     <h3 class="detail-header function" id="group_by/3">  <span class="signature">group_by(enumerable, key_fun, mapper_fun \\ fn x -&gt; x end)</span>     </h3>
<pre data-language="elixir">group_by(<a href="#t:t/0">t</a>, (<a href="#t:element/0">element</a> -&gt; any), (<a href="#t:element/0">element</a> -&gt; any)) :: map</pre>  <p>Splits the enumerable into groups based on <code class="inline">fun</code>.</p> <p>The result is a map where each key is given by <code class="inline">key_fun</code> and each value is a list of elements given by <code class="inline">value_fun</code>. Ordering is preserved.</p> <h4 id="group_by/3-examples" class="section-heading">  Examples </h4> <pre data-language="elixir"><code class="iex elixir">iex&gt; Enum.group_by(~w{ant buffalo cat dingo}, &amp;String.length/1)
%{3 =&gt; ["ant", "cat"], 7 =&gt; ["buffalo"], 5 =&gt; ["dingo"]}

iex&gt; Enum.group_by(~w{ant buffalo cat dingo}, &amp;String.length/1, &amp;String.first/1)
%{3 =&gt; ["a", "c"], 7 =&gt; ["b"], 5 =&gt; ["d"]}</code></pre>    <h3 class="detail-header function" id="intersperse/2">  <span class="signature">intersperse(enumerable, element)</span>     </h3>
<pre data-language="elixir">intersperse(<a href="#t:t/0">t</a>, <a href="#t:element/0">element</a>) :: list</pre>  <p>Intersperses <code class="inline">element</code> between each element of the enumeration.</p> <p>Complexity: O(n).</p> <h4 id="intersperse/2-examples" class="section-heading">  Examples </h4> <pre data-language="elixir"><code class="iex elixir">iex&gt; Enum.intersperse([1, 2, 3], 0)
[1, 0, 2, 0, 3]

iex&gt; Enum.intersperse([1], 0)
[1]

iex&gt; Enum.intersperse([], 0)
[]</code></pre>    <h3 class="detail-header function" id="into/2">  <span class="signature">into(enumerable, collectable)</span>     </h3>
<pre data-language="elixir">into(<a href="../enumerable/#t:t/0">Enumerable.t</a>, <a href="../collectable/#t:t/0">Collectable.t</a>) :: <a href="../collectable/#t:t/0">Collectable.t</a></pre>  <p>Inserts the given <code class="inline">enumerable</code> into a <code class="inline">collectable</code>.</p> <h4 id="into/2-examples" class="section-heading">  Examples </h4> <pre data-language="elixir"><code class="iex elixir">iex&gt; Enum.into([1, 2], [0])
[0, 1, 2]

iex&gt; Enum.into([a: 1, b: 2], %{})
%{a: 1, b: 2}

iex&gt; Enum.into(%{a: 1}, %{b: 2})
%{a: 1, b: 2}

iex&gt; Enum.into([a: 1, a: 2], %{})
%{a: 2}</code></pre>    <h3 class="detail-header function" id="into/3">  <span class="signature">into(enumerable, collectable, transform)</span>     </h3>
<pre data-language="elixir">into(<a href="../enumerable/#t:t/0">Enumerable.t</a>, <a href="../collectable/#t:t/0">Collectable.t</a>, (term -&gt; term)) :: <a href="../collectable/#t:t/0">Collectable.t</a></pre>  <p>Inserts the given <code class="inline">enumerable</code> into a <code class="inline">collectable</code> according to the transformation function.</p> <h4 id="into/3-examples" class="section-heading">  Examples </h4> <pre data-language="elixir"><code class="iex elixir">iex&gt; Enum.into([2, 3], [3], fn x -&gt; x * 3 end)
[3, 6, 9]</code></pre>     <h3 class="detail-header function" id="join/2">  <span class="signature">join(enumerable, joiner \\ "")</span>     </h3>
<pre data-language="elixir">join(<a href="#t:t/0">t</a>, <a href="../string/#t:t/0">String.t</a>) :: <a href="../string/#t:t/0">String.t</a></pre>  <p>Joins the given enumerable into a binary using <code class="inline">joiner</code> as a separator.</p> <p>If <code class="inline">joiner</code> is not passed at all, it defaults to the empty binary.</p> <p>All items in the enumerable must be convertible to a binary, otherwise an error is raised.</p> <h4 id="join/2-examples" class="section-heading">  Examples </h4> <pre data-language="elixir"><code class="iex elixir">iex&gt; Enum.join([1, 2, 3])
"123"

iex&gt; Enum.join([1, 2, 3], " = ")
"1 = 2 = 3"</code></pre>    <h3 class="detail-header function" id="map/2">  <span class="signature">map(enumerable, fun)</span>     </h3>
<pre data-language="elixir">map(<a href="#t:t/0">t</a>, (<a href="#t:element/0">element</a> -&gt; any)) :: list</pre>  <p>Returns a list where each item is the result of invoking <code class="inline">fun</code> on each corresponding item of <code class="inline">enumerable</code>.</p> <p>For maps, the function expects a key-value tuple.</p> <h4 id="map/2-examples" class="section-heading">  Examples </h4> <pre data-language="elixir"><code class="iex elixir">iex&gt; Enum.map([1, 2, 3], fn(x) -&gt; x * 2 end)
[2, 4, 6]

iex&gt; Enum.map([a: 1, b: 2], fn({k, v}) -&gt; {k, -v} end)
[a: -1, b: -2]</code></pre>     <h3 class="detail-header function" id="map_join/3">  <span class="signature">map_join(enumerable, joiner \\ "", mapper)</span>     </h3>
<pre data-language="elixir">map_join(<a href="#t:t/0">t</a>, <a href="../string/#t:t/0">String.t</a>, (<a href="#t:element/0">element</a> -&gt; any)) :: <a href="../string/#t:t/0">String.t</a></pre>  <p>Maps and joins the given enumerable in one pass.</p> <p><code class="inline">joiner</code> can be either a binary or a list and the result will be of the same type as <code class="inline">joiner</code>. If <code class="inline">joiner</code> is not passed at all, it defaults to an empty binary.</p> <p>All items in the enumerable must be convertible to a binary, otherwise an error is raised.</p> <h4 id="map_join/3-examples" class="section-heading">  Examples </h4> <pre data-language="elixir"><code class="iex elixir">iex&gt; Enum.map_join([1, 2, 3], &amp;(&amp;1 * 2))
"246"

iex&gt; Enum.map_join([1, 2, 3], " = ", &amp;(&amp;1 * 2))
"2 = 4 = 6"</code></pre>    <h3 class="detail-header function" id="map_reduce/3">  <span class="signature">map_reduce(enumerable, acc, fun)</span>     </h3>
<pre data-language="elixir">map_reduce(<a href="#t:t/0">t</a>, any, (<a href="#t:element/0">element</a>, any -&gt; {any, any})) :: {any, any}</pre>  <p>Invokes the given function to each item in the enumerable to reduce it to a single element, while keeping an accumulator.</p> <p>Returns a tuple where the first element is the mapped enumerable and the second one is the final accumulator.</p> <p>The function, <code class="inline">fun</code>, receives two arguments: the first one is the element, and the second one is the accumulator. <code class="inline">fun</code> must return a tuple with two elements in the form of <code class="inline">{result, accumulator}</code>.</p> <p>For maps, the first tuple element must be a <code class="inline">{key, value}</code> tuple.</p> <h4 id="map_reduce/3-examples" class="section-heading">  Examples </h4> <pre data-language="elixir"><code class="iex elixir">iex&gt; Enum.map_reduce([1, 2, 3], 0, fn(x, acc) -&gt; {x * 2, x + acc} end)
{[2, 4, 6], 6}</code></pre>    <h3 class="detail-header function" id="max/1">  <span class="signature">max(enumerable)</span>     </h3>
<pre data-language="elixir">max(<a href="#t:t/0">t</a>) :: <a href="#t:element/0">element</a> | no_return</pre>  <p>Returns the maximal element in the enumerable according to Erlang’s term ordering.</p> <p>If multiple elements are considered maximal, the first one that was found is returned.</p> <p>Raises <a href="../enum.emptyerror/"><code class="inline">Enum.EmptyError</code></a> if <code class="inline">enumerable</code> is empty.</p> <h4 id="max/1-examples" class="section-heading">  Examples </h4> <pre data-language="elixir"><code class="iex elixir">iex&gt; Enum.max([1, 2, 3])
3</code></pre>    <h3 class="detail-header function" id="max_by/2">  <span class="signature">max_by(enumerable, fun)</span>     </h3>
<pre data-language="elixir">max_by(<a href="#t:t/0">t</a>, (<a href="#t:element/0">element</a> -&gt; any)) :: <a href="#t:element/0">element</a> | no_return</pre>  <p>Returns the maximal element in the enumerable as calculated by the given function.</p> <p>If multiple elements are considered maximal, the first one that was found is returned.</p> <p>Raises <a href="../enum.emptyerror/"><code class="inline">Enum.EmptyError</code></a> if <code class="inline">enumerable</code> is empty.</p> <h4 id="max_by/2-examples" class="section-heading">  Examples </h4> <pre data-language="elixir"><code class="iex elixir">iex&gt; Enum.max_by(["a", "aa", "aaa"], fn(x) -&gt; String.length(x) end)
"aaa"

iex&gt; Enum.max_by(["a", "aa", "aaa", "b", "bbb"], &amp;String.length/1)
"aaa"</code></pre>    <h3 class="detail-header function" id="member?/2">  <span class="signature">member?(enumerable, element)</span>     </h3>
<pre data-language="elixir">member?(<a href="#t:t/0">t</a>, <a href="#t:element/0">element</a>) :: boolean</pre>  <p>Checks if <code class="inline">element</code> exists within the enumerable.</p> <p>Membership is tested with the match (<code class="inline">===</code>) operator.</p> <h4 id="member?/2-examples" class="section-heading">  Examples </h4> <pre data-language="elixir"><code class="iex elixir">iex&gt; Enum.member?(1..10, 5)
true
iex&gt; Enum.member?(1..10, 5.0)
false

iex&gt; Enum.member?([1.0, 2.0, 3.0], 2)
false
iex&gt; Enum.member?([1.0, 2.0, 3.0], 2.000)
true

iex&gt; Enum.member?([:a, :b, :c], :d)
false</code></pre>    <h3 class="detail-header function" id="min/1">  <span class="signature">min(enumerable)</span>     </h3>
<pre data-language="elixir">min(<a href="#t:t/0">t</a>) :: <a href="#t:element/0">element</a> | no_return</pre>  <p>Returns the minimal element in the enumerable according to Erlang’s term ordering.</p> <p>If multiple elements are considered minimal, the first one that was found is returned.</p> <p>Raises <a href="../enum.emptyerror/"><code class="inline">Enum.EmptyError</code></a> if <code class="inline">enumerable</code> is empty.</p> <h4 id="min/1-examples" class="section-heading">  Examples </h4> <pre data-language="elixir"><code class="iex elixir">iex&gt; Enum.min([1, 2, 3])
1</code></pre>    <h3 class="detail-header function" id="min_by/2">  <span class="signature">min_by(enumerable, fun)</span>     </h3>
<pre data-language="elixir">min_by(<a href="#t:t/0">t</a>, (<a href="#t:element/0">element</a> -&gt; any)) :: <a href="#t:element/0">element</a> | no_return</pre>  <p>Returns the minimal element in the enumerable as calculated by the given function.</p> <p>If multiple elements are considered minimal, the first one that was found is returned.</p> <p>Raises <a href="../enum.emptyerror/"><code class="inline">Enum.EmptyError</code></a> if <code class="inline">enumerable</code> is empty.</p> <h4 id="min_by/2-examples" class="section-heading">  Examples </h4> <pre data-language="elixir"><code class="iex elixir">iex&gt; Enum.min_by(["a", "aa", "aaa"], fn(x) -&gt; String.length(x) end)
"a"

iex&gt; Enum.min_by(["a", "aa", "aaa", "b", "bbb"], &amp;String.length/1)
"a"</code></pre>    <h3 class="detail-header function" id="min_max/1">  <span class="signature">min_max(enumerable)</span>     </h3>
<pre data-language="elixir">min_max(<a href="#t:t/0">t</a>) :: {<a href="#t:element/0">element</a>, <a href="#t:element/0">element</a>} | no_return</pre>  <p>Returns a tuple with the minimal and the maximal elements in the enumerable according to Erlang’s term ordering.</p> <p>If multiple elements are considered maximal or minimal, the first one that was found is returned.</p> <p>Raises <a href="../enum.emptyerror/"><code class="inline">Enum.EmptyError</code></a> if <code class="inline">enumerable</code> is empty.</p> <h4 id="min_max/1-examples" class="section-heading">  Examples </h4> <pre data-language="elixir"><code class="iex elixir">iex&gt; Enum.min_max([2, 3, 1])
{1, 3}</code></pre>    <h3 class="detail-header function" id="min_max_by/2">  <span class="signature">min_max_by(enumerable, fun)</span>     </h3>
<pre data-language="elixir">min_max_by(<a href="#t:t/0">t</a>, (<a href="#t:element/0">element</a> -&gt; any)) ::
  {<a href="#t:element/0">element</a>, <a href="#t:element/0">element</a>} |
  no_return</pre>  <p>Returns a tuple with the minimal and the maximal elements in the enumerable as calculated by the given function.</p> <p>If multiple elements are considered maximal or minimal, the first one that was found is returned.</p> <p>Raises <a href="../enum.emptyerror/"><code class="inline">Enum.EmptyError</code></a> if <code class="inline">enumerable</code> is empty.</p> <h4 id="min_max_by/2-examples" class="section-heading">  Examples </h4> <pre data-language="elixir"><code class="iex elixir">iex&gt; Enum.min_max_by(["aaa", "bb", "c"], fn(x) -&gt; String.length(x) end)
{"c", "aaa"}

iex&gt; Enum.min_max_by(["aaa", "a", "bb", "c", "ccc"], &amp;String.length/1)
{"a", "aaa"}</code></pre>    <h3 class="detail-header function" id="partition/2">  <span class="signature">partition(enumerable, fun)</span>     </h3>
<pre data-language="elixir">partition(<a href="#t:t/0">t</a>, (<a href="#t:element/0">element</a> -&gt; any)) :: {list, list}</pre>  <p>Partitions <code class="inline">enumerable</code> into two lists, where the first one contains elements for which <code class="inline">fun</code> returns a truthy value, and the second one – for which <code class="inline">fun</code> returns <code class="inline">false</code> or <code class="inline">nil</code>.</p> <h4 id="partition/2-examples" class="section-heading">  Examples </h4> <pre data-language="elixir"><code class="iex elixir">iex&gt; Enum.partition([1, 2, 3], fn(x) -&gt; rem(x, 2) == 0 end)
{[2], [1, 3]}</code></pre>    <h3 class="detail-header function" id="random/1">  <span class="signature">random(enumerable)</span>     </h3>
<pre data-language="elixir">random(<a href="#t:t/0">t</a>) :: <a href="#t:element/0">element</a> | no_return</pre>  <p>Returns a random element of an enumerable.</p> <p>Raises <a href="../enum.emptyerror/"><code class="inline">Enum.EmptyError</code></a> if <code class="inline">enumerable</code> is empty.</p> <p>This function uses Erlang’s <code class="inline">:rand</code> module to calculate the random value. Check its documentation for setting a different random algorithm or a different seed.</p> <p>The implementation is based on the <a href="https://en.wikipedia.org/wiki/Reservoir_sampling#Relation_to_Fisher-Yates_shuffle" target="_blank">reservoir sampling</a> algorithm. It assumes that the sample being returned can fit into memory; the input <code class="inline">enumerable</code> doesn’t have to, as it is traversed just once.</p> <h4 id="random/1-examples" class="section-heading">  Examples </h4> <pre data-language="elixir"><code class="elixir"># Although not necessary, let's seed the random algorithm
iex&gt; :rand.seed(:exsplus, {1, 2, 3})
iex&gt; Enum.random([1, 2, 3])
2
iex&gt; Enum.random([1, 2, 3])
1</code></pre>    <h3 class="detail-header function" id="reduce/2">  <span class="signature">reduce(enumerable, fun)</span>     </h3>
<pre data-language="elixir">reduce(<a href="#t:t/0">t</a>, (<a href="#t:element/0">element</a>, any -&gt; any)) :: any</pre>  <p>Invokes <code class="inline">fun</code> for each element in the <code class="inline">enumerable</code>, passing that element and the accumulator as arguments. <code class="inline">fun</code>’s return value is stored in the accumulator.</p> <p>The first element of the enumerable is used as the initial value of the accumulator. If you wish to use another value for the accumulator, use <a href="../enumerable/#reduce/3"><code class="inline">Enumerable.reduce/3</code></a>. This function won’t call the specified function for enumerables that are one-element long.</p> <p>Returns the accumulator.</p> <p>Note that since the first element of the enumerable is used as the initial value of the accumulator, <code class="inline">fun</code> will only be executed <code class="inline">n - 1</code> times where <code class="inline">n</code> is the length of the enumerable.</p> <h4 id="reduce/2-examples" class="section-heading">  Examples </h4> <pre data-language="elixir"><code class="iex elixir">iex&gt; Enum.reduce([1, 2, 3, 4], fn(x, acc) -&gt; x * acc end)
24</code></pre>    <h3 class="detail-header function" id="reduce/3">  <span class="signature">reduce(enumerable, acc, fun)</span>     </h3>
<pre data-language="elixir">reduce(<a href="#t:t/0">t</a>, any, (<a href="#t:element/0">element</a>, any -&gt; any)) :: any</pre>  <p>Invokes <code class="inline">fun</code> for each element in the <code class="inline">enumerable</code>, passing that element and the accumulator <code class="inline">acc</code> as arguments. <code class="inline">fun</code>’s return value is stored in <code class="inline">acc</code>.</p> <p>Returns the accumulator.</p> <h4 id="reduce/3-examples" class="section-heading">  Examples </h4> <pre data-language="elixir"><code class="iex elixir">iex&gt; Enum.reduce([1, 2, 3], 0, fn(x, acc) -&gt; x + acc end)
6</code></pre>    <h3 class="detail-header function" id="reduce_while/3">  <span class="signature">reduce_while(enumerable, acc, fun)</span>  </h3>  <p>Reduces the enumerable until <code class="inline">halt</code> is emitted.</p> <p>The return value for <code class="inline">fun</code> is expected to be <code class="inline">{:cont, acc}</code>, return <code class="inline">{:halt, acc}</code> to end the reduction early.</p> <p>Returns the accumulator.</p> <h4 id="reduce_while/3-examples" class="section-heading">  Examples </h4> <pre data-language="elixir"><code class="iex elixir">iex&gt; Enum.reduce_while(1..100, 0, fn i, acc -&gt;
...&gt;   if i &lt; 3, do: {:cont, acc + i}, else: {:halt, acc}
...&gt; end)
3</code></pre>    <h3 class="detail-header function" id="reject/2">  <span class="signature">reject(enumerable, fun)</span>     </h3>
<pre data-language="elixir">reject(<a href="#t:t/0">t</a>, (<a href="#t:element/0">element</a> -&gt; as_boolean(term))) :: list</pre>  <p>Returns elements of <code class="inline">enumerable</code> for which the function <code class="inline">fun</code> returns <code class="inline">false</code> or <code class="inline">nil</code>.</p> <p>See also <a href="#filter/2"><code class="inline">filter/2</code></a>.</p> <h4 id="reject/2-examples" class="section-heading">  Examples </h4> <pre data-language="elixir"><code class="iex elixir">iex&gt; Enum.reject([1, 2, 3], fn(x) -&gt; rem(x, 2) == 0 end)
[1, 3]</code></pre>    <h3 class="detail-header function" id="reverse/1">  <span class="signature">reverse(enumerable)</span>     </h3>
<pre data-language="elixir">reverse(<a href="#t:t/0">t</a>) :: list</pre>  <p>Returns a list of elements in <code class="inline">enumerable</code> in reverse order.</p> <h4 id="reverse/1-examples" class="section-heading">  Examples </h4> <pre data-language="elixir"><code class="iex elixir">iex&gt; Enum.reverse([1, 2, 3])
[3, 2, 1]</code></pre>    <h3 class="detail-header function" id="reverse/2">  <span class="signature">reverse(enumerable, tail)</span>     </h3>
<pre data-language="elixir">reverse(<a href="#t:t/0">t</a>, <a href="#t:t/0">t</a>) :: list</pre>  <p>Reverses the elements in <code class="inline">enumerable</code>, appends the tail, and returns it as a list.</p> <p>This is an optimization for <code class="inline">Enum.concat(Enum.reverse(enumerable), tail)</code>.</p> <h4 id="reverse/2-examples" class="section-heading">  Examples </h4> <pre data-language="elixir"><code class="iex elixir">iex&gt; Enum.reverse([1, 2, 3], [4, 5, 6])
[3, 2, 1, 4, 5, 6]</code></pre>    <h3 class="detail-header function" id="reverse_slice/3">  <span class="signature">reverse_slice(enumerable, start, count)</span>     </h3>
<pre data-language="elixir">reverse_slice(<a href="#t:t/0">t</a>, non_neg_integer, non_neg_integer) :: list</pre>  <p>Reverses the enumerable in the range from initial position <code class="inline">start</code> through <code class="inline">count</code> elements.</p> <p>If <code class="inline">count</code> is greater than the size of the rest of the enumerable, then this function will reverse the rest of the enumerable.</p> <h4 id="reverse_slice/3-examples" class="section-heading">  Examples </h4> <pre data-language="elixir"><code class="iex elixir">iex&gt; Enum.reverse_slice([1, 2, 3, 4, 5, 6], 2, 4)
[1, 2, 6, 5, 4, 3]</code></pre>    <h3 class="detail-header function" id="scan/2">  <span class="signature">scan(enumerable, fun)</span>     </h3>
<pre data-language="elixir">scan(<a href="#t:t/0">t</a>, (<a href="#t:element/0">element</a>, any -&gt; any)) :: list</pre>  <p>Applies the given function to each element in the enumerable, storing the result in a list and passing it as the accumulator for the next computation.</p> <h4 id="scan/2-examples" class="section-heading">  Examples </h4> <pre data-language="elixir"><code class="iex elixir">iex&gt; Enum.scan(1..5, &amp;(&amp;1 + &amp;2))
[1, 3, 6, 10, 15]</code></pre>    <h3 class="detail-header function" id="scan/3">  <span class="signature">scan(enumerable, acc, fun)</span>     </h3>
<pre data-language="elixir">scan(<a href="#t:t/0">t</a>, any, (<a href="#t:element/0">element</a>, any -&gt; any)) :: list</pre>  <p>Applies the given function to each element in the enumerable, storing the result in a list and passing it as the accumulator for the next computation. Uses the given <code class="inline">acc</code> as the starting value.</p> <h4 id="scan/3-examples" class="section-heading">  Examples </h4> <pre data-language="elixir"><code class="iex elixir">iex&gt; Enum.scan(1..5, 0, &amp;(&amp;1 + &amp;2))
[1, 3, 6, 10, 15]</code></pre>    <h3 class="detail-header function" id="shuffle/1">  <span class="signature">shuffle(enumerable)</span>     </h3>
<pre data-language="elixir">shuffle(<a href="#t:t/0">t</a>) :: list</pre>  <p>Returns a list with the elements of <code class="inline">enumerable</code> shuffled.</p> <p>This function uses Erlang’s <code class="inline">:rand</code> module to calculate the random value. Check its documentation for setting a different random algorithm or a different seed.</p> <h4 id="shuffle/1-examples" class="section-heading">  Examples </h4> <pre data-language="elixir"><code class="elixir"># Although not necessary, let's seed the random algorithm
iex&gt; :rand.seed(:exsplus, {1, 2, 3})
iex&gt; Enum.shuffle([1, 2, 3])
[2, 1, 3]
iex&gt; Enum.shuffle([1, 2, 3])
[2, 3, 1]</code></pre>    <h3 class="detail-header function" id="slice/2">  <span class="signature">slice(enumerable, range)</span>     </h3>
<pre data-language="elixir">slice(<a href="#t:t/0">t</a>, <a href="../range/#t:t/0">Range.t</a>) :: list</pre>  <p>Returns a subset list of the given enumerable. Drops elements until element position <code class="inline">range.first</code>, then takes elements until element position <code class="inline">range.last</code> (inclusive).</p> <p>Positions are calculated by adding the number of items in the enumerable to negative positions (e.g. position -3 in an enumerable with count 5 becomes position 2).</p> <p>The first position (after adding count to negative positions) must be smaller or equal to the last position.</p> <p>If the start of the range is not a valid offset for the given enumerable or if the range is in reverse order, returns <code class="inline">[]</code>.</p> <h4 id="slice/2-examples" class="section-heading">  Examples </h4> <pre data-language="elixir"><code class="iex elixir">iex&gt; Enum.slice(1..100, 5..10)
[6, 7, 8, 9, 10, 11]

iex&gt; Enum.slice(1..10, 5..20)
[6, 7, 8, 9, 10]

iex&gt; Enum.slice(1..10, 11..20)
[]

iex&gt; Enum.slice(1..10, 6..5)
[]</code></pre>    <h3 class="detail-header function" id="slice/3">  <span class="signature">slice(enumerable, start, count)</span>     </h3>
<pre data-language="elixir">slice(<a href="#t:t/0">t</a>, integer, non_neg_integer) :: list</pre>  <p>Returns a subset list of the given enumerable. Drops elements until element position <code class="inline">start</code>, then takes <code class="inline">count</code> elements.</p> <p>If the count is greater than <code class="inline">enumerable</code> length, it returns as many as possible. If zero, then it returns <code class="inline">[]</code>.</p> <h4 id="slice/3-examples" class="section-heading">  Examples </h4> <pre data-language="elixir"><code class="iex elixir">iex&gt; Enum.slice(1..100, 5, 10)
[6, 7, 8, 9, 10, 11, 12, 13, 14, 15]

iex&gt; Enum.slice(1..10, 5, 100)
[6, 7, 8, 9, 10]

iex&gt; Enum.slice(1..10, 5, 0)
[]</code></pre>    <h3 class="detail-header function" id="sort/1">  <span class="signature">sort(enumerable)</span>     </h3>
<pre data-language="elixir">sort(<a href="#t:t/0">t</a>) :: list</pre>  <p>Sorts the enumerable according to Erlang’s term ordering.</p> <p>Uses the merge sort algorithm.</p> <h4 id="sort/1-examples" class="section-heading">  Examples </h4> <pre data-language="elixir"><code class="iex elixir">iex&gt; Enum.sort([3, 2, 1])
[1, 2, 3]</code></pre>    <h3 class="detail-header function" id="sort/2">  <span class="signature">sort(enumerable, fun)</span>     </h3>
<pre data-language="elixir">sort(<a href="#t:t/0">t</a>, (<a href="#t:element/0">element</a>, <a href="#t:element/0">element</a> -&gt; boolean)) :: list</pre>  <p>Sorts the enumerable by the given function.</p> <p>This function uses the merge sort algorithm. The given function should compare two arguments, and return <code class="inline">false</code> if the first argument follows the second one.</p> <h4 id="sort/2-examples" class="section-heading">  Examples </h4> <pre data-language="elixir"><code class="iex elixir">iex&gt; Enum.sort([1, 2, 3], &amp;(&amp;1 &gt; &amp;2))
[3, 2, 1]</code></pre> <p>The sorting algorithm will be stable as long as the given function returns <code class="inline">true</code> for values considered equal:</p> <pre data-language="elixir"><code class="iex elixir">iex&gt; Enum.sort ["some", "kind", "of", "monster"], &amp;(byte_size(&amp;1) &lt;= byte_size(&amp;2))
["of", "some", "kind", "monster"]</code></pre> <p>If the function does not return <code class="inline">true</code> for equal values, the sorting is not stable and the order of equal terms may be shuffled. For example:</p> <pre data-language="elixir"><code class="iex elixir">iex&gt; Enum.sort ["some", "kind", "of", "monster"], &amp;(byte_size(&amp;1) &lt; byte_size(&amp;2))
["of", "kind", "some", "monster"]</code></pre>     <h3 class="detail-header function" id="sort_by/3">  <span class="signature">sort_by(enumerable, mapper, sorter \\ &amp;&lt;=/2)</span>     </h3>
<pre data-language="elixir">sort_by(<a href="#t:t/0">t</a>, (<a href="#t:element/0">element</a> -&gt; mapped_element), (mapped_element, mapped_element -&gt; boolean)) :: list when mapped_element: <a href="#t:element/0">element</a></pre>  <p>Sorts the mapped results of the enumerable according to the <code class="inline">sorter</code> function.</p> <p>This function maps each element of the enumerable using the <code class="inline">mapper</code> function. The enumerable is then sorted by the mapped elements using the <code class="inline">sorter</code> function, which defaults to <a href="../kernel/#%253C=/2"><code class="inline">Kernel.&lt;=/2</code></a></p> <p><a href="#sort_by/3"><code class="inline">sort_by/3</code></a> differs from <a href="#sort/2"><code class="inline">sort/2</code></a> in that it only calculates the comparison value for each element in the enumerable once instead of once for each element in each comparison. If the same function is being called on both element, it’s also more compact to use <a href="#sort_by/3"><code class="inline">sort_by/3</code></a>.</p> <p>This technique is also known as a <em><a href="https://en.wikipedia.org/wiki/Schwartzian_transform" target="_blank">Schwartzian Transform</a></em>, or the <em>Lisp decorate-sort-undecorate idiom</em> as the <code class="inline">mapper</code> is decorating the original <code class="inline">enumerable</code>; then <code class="inline">sorter</code> is sorting the decorations; and finally the enumerable is being undecorated so only the original elements remain, but now in sorted order.</p> <h4 id="sort_by/3-examples" class="section-heading">  Examples </h4> <p>Using the default <code class="inline">sorter</code> of <code class="inline">&lt;=/2</code>:</p> <pre data-language="elixir"><code class="iex elixir">iex&gt; Enum.sort_by ["some", "kind", "of", "monster"], &amp;byte_size/1
["of", "some", "kind", "monster"]</code></pre> <p>Using a custom <code class="inline">sorter</code> to override the order:</p> <pre data-language="elixir"><code class="iex elixir">iex&gt; Enum.sort_by ["some", "kind", "of", "monster"], &amp;byte_size/1, &amp;&gt;=/2
["monster", "some", "kind", "of"]</code></pre>    <h3 class="detail-header function" id="split/2">  <span class="signature">split(enumerable, count)</span>     </h3>
<pre data-language="elixir">split(<a href="#t:t/0">t</a>, integer) :: {list, list}</pre>  <p>Splits the <code class="inline">enumerable</code> into two enumerables, leaving <code class="inline">count</code> elements in the first one. If <code class="inline">count</code> is a negative number, it starts counting from the back to the beginning of the enumerable.</p> <p>Be aware that a negative <code class="inline">count</code> implies the <code class="inline">enumerable</code> will be enumerated twice: once to calculate the position, and a second time to do the actual splitting.</p> <h4 id="split/2-examples" class="section-heading">  Examples </h4> <pre data-language="elixir"><code class="iex elixir">iex&gt; Enum.split([1, 2, 3], 2)
{[1, 2], [3]}

iex&gt; Enum.split([1, 2, 3], 10)
{[1, 2, 3], []}

iex&gt; Enum.split([1, 2, 3], 0)
{[], [1, 2, 3]}

iex&gt; Enum.split([1, 2, 3], -1)
{[1, 2], [3]}

iex&gt; Enum.split([1, 2, 3], -5)
{[], [1, 2, 3]}</code></pre>    <h3 class="detail-header function" id="split_while/2">  <span class="signature">split_while(enumerable, fun)</span>     </h3>
<pre data-language="elixir">split_while(<a href="#t:t/0">t</a>, (<a href="#t:element/0">element</a> -&gt; as_boolean(term))) :: {list, list}</pre>  <p>Splits enumerable in two at the position of the element for which <code class="inline">fun</code> returns <code class="inline">false</code> for the first time.</p> <h4 id="split_while/2-examples" class="section-heading">  Examples </h4> <pre data-language="elixir"><code class="iex elixir">iex&gt; Enum.split_while([1, 2, 3, 4], fn(x) -&gt; x &lt; 3 end)
{[1, 2], [3, 4]}</code></pre>    <h3 class="detail-header function" id="sum/1">  <span class="signature">sum(enumerable)</span>     </h3>
<pre data-language="elixir">sum(<a href="#t:t/0">t</a>) :: number</pre>  <p>Returns the sum of all elements.</p> <p>Raises <a href="../arithmeticerror/"><code class="inline">ArithmeticError</code></a> if <code class="inline">enumerable</code> contains a non-numeric value.</p> <h4 id="sum/1-examples" class="section-heading">  Examples </h4> <pre data-language="elixir"><code class="iex elixir">iex&gt; Enum.sum([1, 2, 3])
6</code></pre>    <h3 class="detail-header function" id="take/2">  <span class="signature">take(enumerable, count)</span>     </h3>
<pre data-language="elixir">take(<a href="#t:t/0">t</a>, integer) :: list</pre>  <p>Takes the first <code class="inline">count</code> items from the enumerable.</p> <p><code class="inline">count</code> must be an integer. If a negative <code class="inline">count</code> is given, the last <code class="inline">count</code> values will be taken. For such, the enumerable is fully enumerated keeping up to <code class="inline">2 * count</code> elements in memory. Once the end of the enumerable is reached, the last <code class="inline">count</code> elements are returned.</p> <h4 id="take/2-examples" class="section-heading">  Examples </h4> <pre data-language="elixir"><code class="iex elixir">iex&gt; Enum.take([1, 2, 3], 2)
[1, 2]

iex&gt; Enum.take([1, 2, 3], 10)
[1, 2, 3]

iex&gt; Enum.take([1, 2, 3], 0)
[]

iex&gt; Enum.take([1, 2, 3], -1)
[3]</code></pre>    <h3 class="detail-header function" id="take_every/2">  <span class="signature">take_every(enumerable, nth)</span>     </h3>
<pre data-language="elixir">take_every(<a href="#t:t/0">t</a>, non_neg_integer) :: list | no_return</pre>  <p>Returns a list of every <code class="inline">nth</code> item in the enumerable, starting with the first element.</p> <p>The first item is always included, unless <code class="inline">nth</code> is 0.</p> <p>The second argument specifying every <code class="inline">nth</code> item must be a non-negative integer, otherwise <a href="../functionclauseerror/"><code class="inline">FunctionClauseError</code></a> will be raised.</p> <h4 id="take_every/2-examples" class="section-heading">  Examples </h4> <pre data-language="elixir"><code class="iex elixir">iex&gt; Enum.take_every(1..10, 2)
[1, 3, 5, 7, 9]

iex&gt; Enum.take_every(1..10, 0)
[]

iex&gt; Enum.take_every([1, 2, 3], 1)
[1, 2, 3]</code></pre>    <h3 class="detail-header function" id="take_random/2">  <span class="signature">take_random(enumerable, count)</span>     </h3>
<pre data-language="elixir">take_random(<a href="#t:t/0">t</a>, non_neg_integer) :: list</pre>  <p>Takes random items from <code class="inline">enumerable</code>.</p> <p>Notice this function will traverse the whole <code class="inline">enumerable</code> to get the random sublist.</p> <p>See <a href="#random/1"><code class="inline">random/1</code></a> for notes on implementation and random seed.</p> <h4 id="take_random/2-examples" class="section-heading">  Examples </h4> <pre data-language="elixir"><code class="elixir"># Although not necessary, let's seed the random algorithm
iex&gt; :rand.seed(:exsplus, {1, 2, 3})
iex&gt; Enum.take_random(1..10, 2)
[5, 8]
iex&gt; Enum.take_random(?a..?z, 5)
'fhjni'</code></pre>    <h3 class="detail-header function" id="take_while/2">  <span class="signature">take_while(enumerable, fun)</span>     </h3>
<pre data-language="elixir">take_while(<a href="#t:t/0">t</a>, (<a href="#t:element/0">element</a> -&gt; as_boolean(term))) :: list</pre>  <p>Takes the items from the beginning of the enumerable while <code class="inline">fun</code> returns a truthy value.</p> <h4 id="take_while/2-examples" class="section-heading">  Examples </h4> <pre data-language="elixir"><code class="iex elixir">iex&gt; Enum.take_while([1, 2, 3], fn(x) -&gt; x &lt; 3 end)
[1, 2]</code></pre>    <h3 class="detail-header function" id="to_list/1">  <span class="signature">to_list(enumerable)</span>     </h3>
<pre data-language="elixir">to_list(<a href="#t:t/0">t</a>) :: [<a href="#t:element/0">element</a>]</pre>  <p>Converts <code class="inline">enumerable</code> to a list.</p> <h4 id="to_list/1-examples" class="section-heading">  Examples </h4> <pre data-language="elixir"><code class="iex elixir">iex&gt; Enum.to_list(1..3)
[1, 2, 3]</code></pre>    <h3 class="detail-header function" id="uniq/1">  <span class="signature">uniq(enumerable)</span>     </h3>
<pre data-language="elixir">uniq(<a href="#t:t/0">t</a>) :: list</pre>  <p>Enumerates the <code class="inline">enumerable</code>, removing all duplicated elements.</p> <h4 id="uniq/1-examples" class="section-heading">  Examples </h4> <pre data-language="elixir"><code class="iex elixir">iex&gt; Enum.uniq([1, 2, 3, 3, 2, 1])
[1, 2, 3]</code></pre>    <h3 class="detail-header function" id="uniq_by/2">  <span class="signature">uniq_by(enumerable, fun)</span>     </h3>
<pre data-language="elixir">uniq_by(<a href="#t:t/0">t</a>, (<a href="#t:element/0">element</a> -&gt; term)) :: list</pre>  <p>Enumerates the <code class="inline">enumerable</code>, by removing the elements for which function <code class="inline">fun</code> returned duplicate items.</p> <p>The function <code class="inline">fun</code> maps every element to a term which is used to determine if two elements are duplicates.</p> <h4 id="uniq_by/2-example" class="section-heading">  Example </h4> <pre data-language="elixir"><code class="iex elixir">iex&gt; Enum.uniq_by([{1, :x}, {2, :y}, {1, :z}], fn {x, _} -&gt; x end)
[{1, :x}, {2, :y}]

iex&gt; Enum.uniq_by([a: {:tea, 2}, b: {:tea, 2}, c: {:coffee, 1}], fn {_, y} -&gt; y end)
[a: {:tea, 2}, c: {:coffee, 1}]</code></pre>    <h3 class="detail-header function" id="unzip/1">  <span class="signature">unzip(enumerable)</span>     </h3>
<pre data-language="elixir">unzip(<a href="#t:t/0">t</a>) :: {[<a href="#t:element/0">element</a>], [<a href="#t:element/0">element</a>]}</pre>  <p>Opposite of <a href="../enum/#zip/2"><code class="inline">Enum.zip/2</code></a>; extracts a two-element tuples from the enumerable and groups them together.</p> <p>It takes an enumerable with items being two-element tuples and returns a tuple with two lists, each of which is formed by the first and second element of each tuple, respectively.</p> <p>This function fails unless <code class="inline">enumerable</code> is or can be converted into a list of tuples with <em>exactly</em> two elements in each tuple.</p> <h4 id="unzip/1-examples" class="section-heading">  Examples </h4> <pre data-language="elixir"><code class="iex elixir">iex&gt; Enum.unzip([{:a, 1}, {:b, 2}, {:c, 3}])
{[:a, :b, :c], [1, 2, 3]}

iex&gt; Enum.unzip(%{a: 1, b: 2})
{[:a, :b], [1, 2]}</code></pre>     <h3 class="detail-header function" id="with_index/2">  <span class="signature">with_index(enumerable, offset \\ 0)</span>     </h3>
<pre data-language="elixir">with_index(<a href="#t:t/0">t</a>, integer) :: [{<a href="#t:element/0">element</a>, integer}]</pre>  <p>Returns the enumerable with each element wrapped in a tuple alongside its index.</p> <h4 id="with_index/2-examples" class="section-heading">  Examples </h4> <pre data-language="elixir"><code class="iex elixir">iex&gt; Enum.with_index([:a, :b, :c])
[a: 0, b: 1, c: 2]

iex&gt; Enum.with_index([:a, :b, :c], 3)
[a: 3, b: 4, c: 5]</code></pre>    <h3 class="detail-header function" id="zip/2">  <span class="signature">zip(enumerable1, enumerable2)</span>     </h3>
<pre data-language="elixir">zip(<a href="#t:t/0">t</a>, <a href="#t:t/0">t</a>) :: [{any, any}]</pre>  <p>Zips corresponding elements from two enumerables into one list of tuples.</p> <p>The zipping finishes as soon as any enumerable completes.</p> <h4 id="zip/2-examples" class="section-heading">  Examples </h4> <pre data-language="elixir"><code class="iex elixir">iex&gt; Enum.zip([1, 2, 3], [:a, :b, :c])
[{1, :a}, {2, :b}, {3, :c}]

iex&gt; Enum.zip([1, 2, 3, 4, 5], [:a, :b, :c])
[{1, :a}, {2, :b}, {3, :c}]</code></pre>
<div class="_attribution">
  <p class="_attribution-p">
    © 2012–2017 Plataformatec<br>Licensed under the Apache License, Version 2.0.<br>
    <a href="https://hexdocs.pm/elixir/1.3.3/Enum.html" class="_attribution-link" target="_blank">https://hexdocs.pm/elixir/1.3.3/Enum.html</a>
  </p>
</div>

			</div>
		</div>
	</section>

	</div>
</body>
</html>
