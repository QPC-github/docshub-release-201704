
<!DOCTYPE HTML>

<html lang="en">

<head>
  <meta charset="utf-8">
  <title>Map - Elixir 1.3 - W3cubDocs</title>
  
  <meta name="description" content=" A set of functions for working with maps. ">
  <meta name="keywords" content="map, summary, types, functions, -, elixir, elixir~1.3">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="http://docs.w3cub.com/elixir~1.3/map/">
  <link href="/favicon.png" rel="icon">
  <link type="text/css" rel="stylesheet" href="/assets/application-50364fff564ce3b6327021805f3f00e2957b441cf27f576a7dd4ff63bbc47047.css">
  <script type="text/javascript" src="/assets/application-db64bfd54ceb42be11af7995804cf4902548419ceb79d509b0b7d62c22d98e6f.js"></script>
  <script src="/json/elixir~1.3.js"></script>
  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-71174418-1']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>


</head>

<body>
	<div class="_app">
	<header class="_header">
  
  <form class="_search">
    <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
    <a class="_search-clear"></a>
    <div class="_search-tag"></div>
  </form>
  
  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/elixir~1.3/" class="_nav-link" title="" style="margin-left:0;">Elixir 1.3</a></span>
  
  <nav class="_nav">
    <a href="/app/" class="_nav-link ">App</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		<div class="_list">
			
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<div class="_page _elixir">
				
<h1>  Map  </h1>  <p>A set of functions for working with maps.</p> <p>Maps are key-value stores where keys can be any value and are compared using the match operator (<code class="inline">===</code>). Maps can be created with the <code class="inline">%{}</code> special form defined in the <a href="../kernel.specialforms/"><code class="inline">Kernel.SpecialForms</code></a> module.</p>   <h1 class="section-heading" id="summary">  Summary </h1> <h2> Types </h2>
<dl class="summary-types summary">   <dt class="summary-signature"> <a href="#t:key/0">key()</a> </dt>   <dt class="summary-signature"> <a href="#t:value/0">value()</a> </dt>  </dl> <h2> Functions </h2>
<dl class="summary-functions summary">   <dt class="summary-signature"> <a href="#delete/2">delete(map, key)</a> </dt> <dd class="summary-synopsis">
<p>Deletes the entries in <code class="inline">map</code> for a specific <code class="inline">key</code></p> </dd>   <dt class="summary-signature"> <a href="#drop/2">drop(map, keys)</a> </dt> <dd class="summary-synopsis">
<p>Drops the given <code class="inline">keys</code> from <code class="inline">map</code></p> </dd>   <dt class="summary-signature"> <a href="#equal?/2">equal?(map1, map2)</a> </dt> <dd class="summary-synopsis">
<p>Checks if two maps are equal</p> </dd>   <dt class="summary-signature"> <a href="#fetch/2">fetch(map, key)</a> </dt> <dd class="summary-synopsis">
<p>Fetches the value for a specific <code class="inline">key</code> and returns it in a tuple</p> </dd>   <dt class="summary-signature"> <a href="#fetch!/2">fetch!(map, key)</a> </dt> <dd class="summary-synopsis">
<p>Fetches the value for specific <code class="inline">key</code></p> </dd>   <dt class="summary-signature"> <a href="#from_struct/1">from_struct(struct)</a> </dt> <dd class="summary-synopsis">
<p>Converts a <code class="inline">struct</code> to map</p> </dd>   <dt class="summary-signature"> <a href="#get/3">get(map, key, default \\ nil)</a> </dt> <dd class="summary-synopsis">
<p>Gets the value for a specific <code class="inline">key</code></p> </dd>   <dt class="summary-signature"> <a href="#get_and_update/3">get_and_update(map, key, fun)</a> </dt> <dd class="summary-synopsis">
<p>Gets the value from <code class="inline">key</code> and updates it, all in one pass</p> </dd>   <dt class="summary-signature"> <a href="#get_and_update!/3">get_and_update!(map, key, fun)</a> </dt> <dd class="summary-synopsis">
<p>Gets the value from <code class="inline">key</code> and updates it. Raises if there is no <code class="inline">key</code></p> </dd>   <dt class="summary-signature"> <a href="#get_lazy/3">get_lazy(map, key, fun)</a> </dt> <dd class="summary-synopsis">
<p>Gets the value for a specific <code class="inline">key</code></p> </dd>   <dt class="summary-signature"> <a href="#has_key?/2">has_key?(map, key)</a> </dt> <dd class="summary-synopsis">
<p>Returns whether a given <code class="inline">key</code> exists in the given <code class="inline">map</code></p> </dd>   <dt class="summary-signature"> <a href="#keys/1">keys(map)</a> </dt> <dd class="summary-synopsis">
<p>Returns all keys from <code class="inline">map</code></p> </dd>   <dt class="summary-signature"> <a href="#merge/2">merge(map1, map2)</a> </dt> <dd class="summary-synopsis">
<p>Merges two maps into one</p> </dd>   <dt class="summary-signature"> <a href="#merge/3">merge(map1, map2, callback)</a> </dt> <dd class="summary-synopsis">
<p>Merges two maps into one</p> </dd>   <dt class="summary-signature"> <a href="#new/0">new()</a> </dt> <dd class="summary-synopsis">
<p>Returns a new empty map</p> </dd>   <dt class="summary-signature"> <a href="#new/1">new(enumerable)</a> </dt> <dd class="summary-synopsis">
<p>Creates a map from an <code class="inline">enumerable</code></p> </dd>   <dt class="summary-signature"> <a href="#new/2">new(enumerable, transform)</a> </dt> <dd class="summary-synopsis">
<p>Creates a map from an <code class="inline">enumerable</code> via the transformation function</p> </dd>   <dt class="summary-signature"> <a href="#pop/3">pop(map, key, default \\ nil)</a> </dt> <dd class="summary-synopsis">
<p>Returns and removes the value associated with <code class="inline">key</code> in <code class="inline">map</code></p> </dd>   <dt class="summary-signature"> <a href="#pop_lazy/3">pop_lazy(map, key, fun)</a> </dt> <dd class="summary-synopsis">
<p>Lazily returns and removes the value associated with <code class="inline">key</code> in <code class="inline">map</code></p> </dd>   <dt class="summary-signature"> <a href="#put/3">put(map, key, val)</a> </dt> <dd class="summary-synopsis">
<p>Puts the given <code class="inline">value</code> under <code class="inline">key</code></p> </dd>   <dt class="summary-signature"> <a href="#put_new/3">put_new(map, key, value)</a> </dt> <dd class="summary-synopsis">
<p>Puts the given <code class="inline">value</code> under <code class="inline">key</code> unless the entry <code class="inline">key</code> already exists</p> </dd>   <dt class="summary-signature"> <a href="#put_new_lazy/3">put_new_lazy(map, key, fun)</a> </dt> <dd class="summary-synopsis">
<p>Evaluates <code class="inline">fun</code> and puts the result under <code class="inline">key</code> in map unless <code class="inline">key</code> is already present</p> </dd>   <dt class="summary-signature"> <a href="#split/2">split(map, keys)</a> </dt> <dd class="summary-synopsis">
<p>Takes all entries corresponding to the given <code class="inline">keys</code> and extracts them into a separate <code class="inline">map</code></p> </dd>   <dt class="summary-signature"> <a href="#take/2">take(map, keys)</a> </dt> <dd class="summary-synopsis">
<p>Takes all entries corresponding to the given keys and returns them in a new map</p> </dd>   <dt class="summary-signature"> <a href="#to_list/1">to_list(map)</a> </dt> <dd class="summary-synopsis">
<p>Converts <code class="inline">map</code> to a list</p> </dd>   <dt class="summary-signature"> <a href="#update/4">update(map, key, initial, fun)</a> </dt> <dd class="summary-synopsis">
<p>Updates the <code class="inline">key</code> in <code class="inline">map</code> with the given function</p> </dd>   <dt class="summary-signature"> <a href="#update!/3">update!(map, key, fun)</a> </dt> <dd class="summary-synopsis">
<p>Updates the <code class="inline">key</code> with the given function</p> </dd>   <dt class="summary-signature"> <a href="#values/1">values(map)</a> </dt> <dd class="summary-synopsis">
<p>Returns all values from <code class="inline">map</code></p> </dd>  </dl>   <h1 class="section-heading" id="types">  Types </h1>   <h3 class="detail-header type" id="t:key/0">  <span class="signature">key()</span>     </h3>
<pre data-language="elixir">key() :: any</pre>     <h3 class="detail-header type" id="t:value/0">  <span class="signature">value()</span>     </h3>
<pre data-language="elixir">value() :: any</pre>       <h1 class="section-heading" id="functions">  Functions </h1>  <h3 class="detail-header function" id="delete/2">  <span class="signature">delete(map, key)</span>     </h3>
<pre data-language="elixir">delete(map, <a href="#t:key/0">key</a>) :: map</pre>  <p>Deletes the entries in <code class="inline">map</code> for a specific <code class="inline">key</code>.</p> <p>If the <code class="inline">key</code> does not exist, returns <code class="inline">map</code> unchanged.</p> <h4 id="delete/2-examples" class="section-heading">  Examples </h4> <pre data-language="elixir"><code class="iex elixir">iex&gt; Map.delete(%{a: 1, b: 2}, :a)
%{b: 2}
iex&gt; Map.delete(%{b: 2}, :a)
%{b: 2}</code></pre>    <h3 class="detail-header function" id="drop/2">  <span class="signature">drop(map, keys)</span>     </h3>
<pre data-language="elixir">drop(map, <a href="../enumerable/#t:t/0">Enumerable.t</a>) :: map</pre>  <p>Drops the given <code class="inline">keys</code> from <code class="inline">map</code>.</p> <h4 id="drop/2-examples" class="section-heading">  Examples </h4> <pre data-language="elixir"><code class="iex elixir">iex&gt; Map.drop(%{a: 1, b: 2, c: 3}, [:b, :d])
%{a: 1, c: 3}</code></pre>    <h3 class="detail-header function" id="equal?/2">  <span class="signature">equal?(map1, map2)</span>     </h3>
<pre data-language="elixir">equal?(map, map) :: boolean</pre>  <p>Checks if two maps are equal.</p> <p>Two maps are considered to be equal if they contain the same keys and those keys contain the same values.</p> <h4 id="equal?/2-examples" class="section-heading">  Examples </h4> <pre data-language="elixir"><code class="iex elixir">iex&gt; Map.equal?(%{a: 1, b: 2}, %{b: 2, a: 1})
true
iex&gt; Map.equal?(%{a: 1, b: 2}, %{b: 1, a: 2})
false</code></pre>    <h3 class="detail-header function" id="fetch/2">  <span class="signature">fetch(map, key)</span>     </h3>
<pre data-language="elixir">fetch(map, <a href="#t:key/0">key</a>) :: {:ok, <a href="#t:value/0">value</a>} | :error</pre>  <p>Fetches the value for a specific <code class="inline">key</code> and returns it in a tuple.</p> <p>If the <code class="inline">key</code> does not exist, returns <code class="inline">:error</code>.</p> <h4 id="fetch/2-examples" class="section-heading">  Examples </h4> <pre data-language="elixir"><code class="iex elixir">iex&gt; Map.fetch(%{a: 1}, :a)
{:ok, 1}
iex&gt; Map.fetch(%{a: 1}, :b)
:error</code></pre>    <h3 class="detail-header function" id="fetch!/2">  <span class="signature">fetch!(map, key)</span>     </h3>
<pre data-language="elixir">fetch!(map, <a href="#t:key/0">key</a>) :: <a href="#t:value/0">value</a> | no_return</pre>  <p>Fetches the value for specific <code class="inline">key</code>.</p> <p>If <code class="inline">key</code> does not exist, a <a href="../keyerror/"><code class="inline">KeyError</code></a> is raised.</p> <h4 id="fetch!/2-examples" class="section-heading">  Examples </h4> <pre data-language="elixir"><code class="iex elixir">iex&gt; Map.fetch!(%{a: 1}, :a)
1
iex&gt; Map.fetch!(%{a: 1}, :b)
** (KeyError) key :b not found in: %{a: 1}</code></pre>    <h3 class="detail-header function" id="from_struct/1">  <span class="signature">from_struct(struct)</span>     </h3>
<pre data-language="elixir">from_struct(atom | struct) :: map</pre>  <p>Converts a <code class="inline">struct</code> to map.</p> <p>It accepts the struct module or a struct itself and simply removes the <code class="inline">__struct__</code> field from the struct.</p> <h4 id="from_struct/1-example" class="section-heading">  Example </h4> <pre data-language="elixir"><code class="elixir">defmodule User do
  defstruct [:name]
end

Map.from_struct(User)
#=&gt; %{name: nil}

Map.from_struct(%User{name: "john"})
#=&gt; %{name: "john"}</code></pre>     <h3 class="detail-header function" id="get/3">  <span class="signature">get(map, key, default \\ nil)</span>     </h3>
<pre data-language="elixir">get(map, <a href="#t:key/0">key</a>, <a href="#t:value/0">value</a>) :: <a href="#t:value/0">value</a></pre>  <p>Gets the value for a specific <code class="inline">key</code>.</p> <p>If <code class="inline">key</code> does not exist, return the default value (<code class="inline">nil</code> if no default value).</p> <h4 id="get/3-examples" class="section-heading">  Examples </h4> <pre data-language="elixir"><code class="iex elixir">iex&gt; Map.get(%{}, :a)
nil
iex&gt; Map.get(%{a: 1}, :a)
1
iex&gt; Map.get(%{a: 1}, :b)
nil
iex&gt; Map.get(%{a: 1}, :b, 3)
3</code></pre>    <h3 class="detail-header function" id="get_and_update/3">  <span class="signature">get_and_update(map, key, fun)</span>     </h3>
<pre data-language="elixir">get_and_update(map, <a href="#t:key/0">key</a>, (<a href="#t:value/0">value</a> -&gt; {get, <a href="#t:value/0">value</a>} | :pop)) :: {get, map} when get: term</pre>  <p>Gets the value from <code class="inline">key</code> and updates it, all in one pass.</p> <p>This <code class="inline">fun</code> argument receives the value of <code class="inline">key</code> (or <code class="inline">nil</code> if <code class="inline">key</code> is not present) and must return a two-element tuple: the “get” value (the retrieved value, which can be operated on before being returned) and the new value to be stored under <code class="inline">key</code>. The <code class="inline">fun</code> may also return <code class="inline">:pop</code>, implying the current value shall be removed from <code class="inline">map</code> and returned.</p> <p>The returned value is a tuple with the “get” value returned by <code class="inline">fun</code> and a new map with the updated value under <code class="inline">key</code>.</p> <h4 id="get_and_update/3-examples" class="section-heading">  Examples </h4> <pre data-language="elixir"><code class="iex elixir">iex&gt; Map.get_and_update(%{a: 1}, :a, fn current_value -&gt;
...&gt;   {current_value, "new value!"}
...&gt; end)
{1, %{a: "new value!"}}

iex&gt; Map.get_and_update(%{a: 1}, :b, fn current_value -&gt;
...&gt;   {current_value, "new value!"}
...&gt; end)
{nil, %{b: "new value!", a: 1}}

iex&gt; Map.get_and_update(%{a: 1}, :a, fn _ -&gt; :pop end)
{1, %{}}

iex&gt; Map.get_and_update(%{a: 1}, :b, fn _ -&gt; :pop end)
{nil, %{a: 1}}</code></pre>    <h3 class="detail-header function" id="get_and_update!/3">  <span class="signature">get_and_update!(map, key, fun)</span>     </h3>
<pre data-language="elixir">get_and_update!(map, <a href="#t:key/0">key</a>, (<a href="#t:value/0">value</a> -&gt; {get, <a href="#t:value/0">value</a>})) ::
  {get, map} |
  no_return when get: term</pre>  <p>Gets the value from <code class="inline">key</code> and updates it. Raises if there is no <code class="inline">key</code>.</p> <p>This <code class="inline">fun</code> argument receives the value of <code class="inline">key</code> and must return a two-element tuple: the “get” value (the retrieved value, which can be operated on before being returned) and the new value to be stored under <code class="inline">key</code>.</p> <p>The returned value is a tuple with the “get” value returned by <code class="inline">fun</code> and a new map with the updated value under <code class="inline">key</code>.</p> <h4 id="get_and_update!/3-examples" class="section-heading">  Examples </h4> <pre data-language="elixir"><code class="iex elixir">iex&gt; Map.get_and_update!(%{a: 1}, :a, fn current_value -&gt;
...&gt;   {current_value, "new value!"}
...&gt; end)
{1, %{a: "new value!"}}

iex&gt; Map.get_and_update!(%{a: 1}, :b, fn current_value -&gt;
...&gt;   {current_value, "new value!"}
...&gt; end)
** (KeyError) key :b not found

iex&gt; Map.get_and_update!(%{a: 1}, :a, fn _ -&gt;
...&gt;   :pop
...&gt; end)
{1, %{}}</code></pre>    <h3 class="detail-header function" id="get_lazy/3">  <span class="signature">get_lazy(map, key, fun)</span>     </h3>
<pre data-language="elixir">get_lazy(map, <a href="#t:key/0">key</a>, (() -&gt; <a href="#t:value/0">value</a>)) :: <a href="#t:value/0">value</a></pre>  <p>Gets the value for a specific <code class="inline">key</code>.</p> <p>If <code class="inline">key</code> does not exist, lazily evaluates <code class="inline">fun</code> and returns its result.</p> <p>This is useful if the default value is very expensive to calculate or generally difficult to setup and teardown again.</p> <h4 id="get_lazy/3-examples" class="section-heading">  Examples </h4> <pre data-language="elixir"><code class="iex elixir">iex&gt; map = %{a: 1}
iex&gt; fun = fn -&gt;
...&gt;   # some expensive operation here
...&gt;   13
...&gt; end
iex&gt; Map.get_lazy(map, :a, fun)
1
iex&gt; Map.get_lazy(map, :b, fun)
13</code></pre>    <h3 class="detail-header function" id="has_key?/2">  <span class="signature">has_key?(map, key)</span>     </h3>
<pre data-language="elixir">has_key?(map, <a href="#t:key/0">key</a>) :: boolean</pre>  <p>Returns whether a given <code class="inline">key</code> exists in the given <code class="inline">map</code>.</p> <h4 id="has_key?/2-examples" class="section-heading">  Examples </h4> <pre data-language="elixir"><code class="iex elixir">iex&gt; Map.has_key?(%{a: 1}, :a)
true
iex&gt; Map.has_key?(%{a: 1}, :b)
false</code></pre>    <h3 class="detail-header function" id="keys/1">  <span class="signature">keys(map)</span>     </h3>
<pre data-language="elixir">keys(map) :: [<a href="#t:key/0">key</a>]</pre>  <p>Returns all keys from <code class="inline">map</code>.</p> <h4 id="keys/1-examples" class="section-heading">  Examples </h4> <pre data-language="elixir"><code class="iex elixir">iex&gt; Map.keys(%{a: 1, b: 2})
[:a, :b]</code></pre>    <h3 class="detail-header function" id="merge/2">  <span class="signature">merge(map1, map2)</span>     </h3>
<pre data-language="elixir">merge(map, map) :: map</pre>  <p>Merges two maps into one.</p> <p>All keys in <code class="inline">map2</code> will be added to <code class="inline">map1</code>, overriding any existing one.</p> <p>If you have a struct and you would like to merge a set of keys into the struct, do not use this function, as it would merge all keys on the right side into the struct, even if the key is not part of the struct. Instead, use <a href="../kernel/#struct/2"><code class="inline">Kernel.struct/2</code></a>.</p> <h4 id="merge/2-examples" class="section-heading">  Examples </h4> <pre data-language="elixir"><code class="iex elixir">iex&gt; Map.merge(%{a: 1, b: 2}, %{a: 3, d: 4})
%{a: 3, b: 2, d: 4}</code></pre>    <h3 class="detail-header function" id="merge/3">  <span class="signature">merge(map1, map2, callback)</span>     </h3>
<pre data-language="elixir">merge(map, map, (<a href="#t:key/0">key</a>, <a href="#t:value/0">value</a>, <a href="#t:value/0">value</a> -&gt; <a href="#t:value/0">value</a>)) :: map</pre>  <p>Merges two maps into one.</p> <p>All keys in <code class="inline">map2</code> will be added to <code class="inline">map1</code>. The given function will be invoked with the key, value1 and value2 to solve conflicts.</p> <h4 id="merge/3-examples" class="section-heading">  Examples </h4> <pre data-language="elixir"><code class="iex elixir">iex&gt; Map.merge(%{a: 1, b: 2}, %{a: 3, d: 4}, fn _k, v1, v2 -&gt;
...&gt;   v1 + v2
...&gt; end)
%{a: 4, b: 2, d: 4}</code></pre>    <h3 class="detail-header function" id="new/0">  <span class="signature">new()</span>     </h3>
<pre data-language="elixir">new() :: map</pre>  <p>Returns a new empty map.</p> <h4 id="new/0-examples" class="section-heading">  Examples </h4> <pre data-language="elixir"><code class="iex elixir">iex&gt; Map.new
%{}</code></pre>    <h3 class="detail-header function" id="new/1">  <span class="signature">new(enumerable)</span>     </h3>
<pre data-language="elixir">new(<a href="../enum/#t:t/0">Enum.t</a>) :: map</pre>  <p>Creates a map from an <code class="inline">enumerable</code>.</p> <p>Duplicated keys are removed; the latest one prevails.</p> <h4 id="new/1-examples" class="section-heading">  Examples </h4> <pre data-language="elixir"><code class="iex elixir">iex&gt; Map.new([{:b, 1}, {:a, 2}])
%{a: 2, b: 1}
iex&gt; Map.new([a: 1, a: 2, a: 3])
%{a: 3}</code></pre>    <h3 class="detail-header function" id="new/2">  <span class="signature">new(enumerable, transform)</span>     </h3>
<pre data-language="elixir">new(<a href="../enum/#t:t/0">Enum.t</a>, (term -&gt; {<a href="#t:key/0">key</a>, <a href="#t:value/0">value</a>})) :: map</pre>  <p>Creates a map from an <code class="inline">enumerable</code> via the transformation function.</p> <p>Duplicated keys are removed; the latest one prevails.</p> <h4 id="new/2-examples" class="section-heading">  Examples </h4> <pre data-language="elixir"><code class="iex elixir">iex&gt; Map.new([:a, :b], fn x -&gt; {x, x} end)
%{a: :a, b: :b}</code></pre>     <h3 class="detail-header function" id="pop/3">  <span class="signature">pop(map, key, default \\ nil)</span>     </h3>
<pre data-language="elixir">pop(map, <a href="#t:key/0">key</a>, <a href="#t:value/0">value</a>) :: {<a href="#t:value/0">value</a>, map}</pre>  <p>Returns and removes the value associated with <code class="inline">key</code> in <code class="inline">map</code>.</p> <h4 id="pop/3-examples" class="section-heading">  Examples </h4> <pre data-language="elixir"><code class="iex elixir">iex&gt; Map.pop(%{a: 1}, :a)
{1, %{}}
iex&gt; Map.pop(%{a: 1}, :b)
{nil, %{a: 1}}
iex&gt; Map.pop(%{a: 1}, :b, 3)
{3, %{a: 1}}</code></pre>    <h3 class="detail-header function" id="pop_lazy/3">  <span class="signature">pop_lazy(map, key, fun)</span>     </h3>
<pre data-language="elixir">pop_lazy(map, <a href="#t:key/0">key</a>, (() -&gt; <a href="#t:value/0">value</a>)) :: {<a href="#t:value/0">value</a>, map}</pre>  <p>Lazily returns and removes the value associated with <code class="inline">key</code> in <code class="inline">map</code>.</p> <p>This is useful if the default value is very expensive to calculate or generally difficult to setup and teardown again.</p> <h4 id="pop_lazy/3-examples" class="section-heading">  Examples </h4> <pre data-language="elixir"><code class="iex elixir">iex&gt; map = %{a: 1}
iex&gt; fun = fn -&gt;
...&gt;   # some expensive operation here
...&gt;   13
...&gt; end
iex&gt; Map.pop_lazy(map, :a, fun)
{1, %{}}
iex&gt; Map.pop_lazy(map, :b, fun)
{13, %{a: 1}}</code></pre>    <h3 class="detail-header function" id="put/3">  <span class="signature">put(map, key, val)</span>     </h3>
<pre data-language="elixir">put(map, <a href="#t:key/0">key</a>, <a href="#t:value/0">value</a>) :: map</pre>  <p>Puts the given <code class="inline">value</code> under <code class="inline">key</code>.</p> <h4 id="put/3-examples" class="section-heading">  Examples </h4> <pre data-language="elixir"><code class="iex elixir">iex&gt; Map.put(%{a: 1}, :b, 2)
%{a: 1, b: 2}
iex&gt; Map.put(%{a: 1, b: 2}, :a, 3)
%{a: 3, b: 2}</code></pre>    <h3 class="detail-header function" id="put_new/3">  <span class="signature">put_new(map, key, value)</span>     </h3>
<pre data-language="elixir">put_new(map, <a href="#t:key/0">key</a>, <a href="#t:value/0">value</a>) :: map</pre>  <p>Puts the given <code class="inline">value</code> under <code class="inline">key</code> unless the entry <code class="inline">key</code> already exists.</p> <h4 id="put_new/3-examples" class="section-heading">  Examples </h4> <pre data-language="elixir"><code class="iex elixir">iex&gt; Map.put_new(%{a: 1}, :b, 2)
%{b: 2, a: 1}
iex&gt; Map.put_new(%{a: 1, b: 2}, :a, 3)
%{a: 1, b: 2}</code></pre>    <h3 class="detail-header function" id="put_new_lazy/3">  <span class="signature">put_new_lazy(map, key, fun)</span>     </h3>
<pre data-language="elixir">put_new_lazy(map, <a href="#t:key/0">key</a>, (() -&gt; <a href="#t:value/0">value</a>)) :: map</pre>  <p>Evaluates <code class="inline">fun</code> and puts the result under <code class="inline">key</code> in map unless <code class="inline">key</code> is already present.</p> <p>This is useful if the value is very expensive to calculate or generally difficult to setup and teardown again.</p> <h4 id="put_new_lazy/3-examples" class="section-heading">  Examples </h4> <pre data-language="elixir"><code class="iex elixir">iex&gt; map = %{a: 1}
iex&gt; fun = fn -&gt;
...&gt;   # some expensive operation here
...&gt;   3
...&gt; end
iex&gt; Map.put_new_lazy(map, :a, fun)
%{a: 1}
iex&gt; Map.put_new_lazy(map, :b, fun)
%{a: 1, b: 3}</code></pre>    <h3 class="detail-header function" id="split/2">  <span class="signature">split(map, keys)</span>     </h3>
<pre data-language="elixir">split(map, <a href="../enumerable/#t:t/0">Enumerable.t</a>) :: {map, map}</pre>  <p>Takes all entries corresponding to the given <code class="inline">keys</code> and extracts them into a separate <code class="inline">map</code>.</p> <p>Returns a tuple with the new map and the old map with removed keys.</p> <p>Keys for which there are no entries in <code class="inline">map</code> are ignored.</p> <h4 id="split/2-examples" class="section-heading">  Examples </h4> <pre data-language="elixir"><code class="iex elixir">iex&gt; Map.split(%{a: 1, b: 2, c: 3}, [:a, :c, :e])
{%{a: 1, c: 3}, %{b: 2}}</code></pre>    <h3 class="detail-header function" id="take/2">  <span class="signature">take(map, keys)</span>     </h3>
<pre data-language="elixir">take(map, <a href="../enumerable/#t:t/0">Enumerable.t</a>) :: map</pre>  <p>Takes all entries corresponding to the given keys and returns them in a new map.</p> <h4 id="take/2-examples" class="section-heading">  Examples </h4> <pre data-language="elixir"><code class="iex elixir">iex&gt; Map.take(%{a: 1, b: 2, c: 3}, [:a, :c, :e])
%{a: 1, c: 3}</code></pre>    <h3 class="detail-header function" id="to_list/1">  <span class="signature">to_list(map)</span>     </h3>
<pre data-language="elixir">to_list(map) :: [{term, term}]</pre>  <p>Converts <code class="inline">map</code> to a list.</p> <h4 id="to_list/1-examples" class="section-heading">  Examples </h4> <pre data-language="elixir"><code class="iex elixir">iex&gt; Map.to_list(%{a: 1})
[a: 1]
iex&gt; Map.to_list(%{1 =&gt; 2})
[{1, 2}]</code></pre>    <h3 class="detail-header function" id="update/4">  <span class="signature">update(map, key, initial, fun)</span>     </h3>
<pre data-language="elixir">update(map, <a href="#t:key/0">key</a>, <a href="#t:value/0">value</a>, (<a href="#t:value/0">value</a> -&gt; <a href="#t:value/0">value</a>)) :: map</pre>  <p>Updates the <code class="inline">key</code> in <code class="inline">map</code> with the given function.</p> <p>If the <code class="inline">key</code> does not exist, inserts the given <code class="inline">initial</code> value.</p> <h4 id="update/4-examples" class="section-heading">  Examples </h4> <pre data-language="elixir"><code class="iex elixir">iex&gt; Map.update(%{a: 1}, :a, 13, &amp;(&amp;1 * 2))
%{a: 2}
iex&gt; Map.update(%{a: 1}, :b, 11, &amp;(&amp;1 * 2))
%{a: 1, b: 11}</code></pre>    <h3 class="detail-header function" id="update!/3">  <span class="signature">update!(map, key, fun)</span>     </h3>
<pre data-language="elixir">update!(map, <a href="#t:key/0">key</a>, (<a href="#t:value/0">value</a> -&gt; <a href="#t:value/0">value</a>)) :: map | no_return</pre>  <p>Updates the <code class="inline">key</code> with the given function.</p> <p>If the <code class="inline">key</code> does not exist, raises <a href="../keyerror/"><code class="inline">KeyError</code></a>.</p> <h4 id="update!/3-examples" class="section-heading">  Examples </h4> <pre data-language="elixir"><code class="iex elixir">iex&gt; Map.update!(%{a: 1}, :a, &amp;(&amp;1 * 2))
%{a: 2}

iex&gt; Map.update!(%{a: 1}, :b, &amp;(&amp;1 * 2))
** (KeyError) key :b not found</code></pre>    <h3 class="detail-header function" id="values/1">  <span class="signature">values(map)</span>     </h3>
<pre data-language="elixir">values(map) :: [<a href="#t:value/0">value</a>]</pre>  <p>Returns all values from <code class="inline">map</code>.</p> <h4 id="values/1-examples" class="section-heading">  Examples </h4> <pre data-language="elixir"><code class="iex elixir">iex&gt; Map.values(%{a: 1, b: 2})
[1, 2]</code></pre>
<div class="_attribution">
  <p class="_attribution-p">
    © 2012–2017 Plataformatec<br>Licensed under the Apache License, Version 2.0.<br>
    <a href="https://hexdocs.pm/elixir/1.3.3/Map.html" class="_attribution-link" target="_blank">https://hexdocs.pm/elixir/1.3.3/Map.html</a>
  </p>
</div>

			</div>
		</div>
	</section>

	</div>
</body>
</html>
