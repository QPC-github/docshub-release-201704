
<!DOCTYPE HTML>

<html lang="en">

<head>
  <meta charset="utf-8">
  <title>OpenSSL&#58;&#58;SSL&#58;&#58;SSLContext - Ruby 2.3 - W3cubDocs</title>
  
  <meta name="description" content="An SSLContext is used to set various options regarding certificates, algorithms, verification, session caching, etc. The SSLContext is used to &hellip;">
  <meta name="keywords" content="class, openssl, ssl, sslcontext, -, ruby, ruby~2.3">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="http://docs.w3cub.com/ruby~2.3/openssl/ssl/sslcontext/">
  <link href="/favicon.png" rel="icon">
  <link type="text/css" rel="stylesheet" href="/assets/application-50364fff564ce3b6327021805f3f00e2957b441cf27f576a7dd4ff63bbc47047.css">
  <script type="text/javascript" src="/assets/application-db64bfd54ceb42be11af7995804cf4902548419ceb79d509b0b7d62c22d98e6f.js"></script>
  <script src="/json/ruby~2.3.js"></script>
  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-71174418-1']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>


</head>

<body>
	<div class="_app">
	<header class="_header">
  
  <form class="_search">
    <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
    <a class="_search-clear"></a>
    <div class="_search-tag"></div>
  </form>
  
  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/ruby~2.3/" class="_nav-link" title="" style="margin-left:0;">Ruby 2.3</a></span>
  
  <nav class="_nav">
    <a href="/app/" class="_nav-link ">App</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		<div class="_list">
			
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<div class="_page _rdoc">
				
<h1 id="class-OpenSSL::SSL::SSLContext" class="class"> class OpenSSL::SSL::SSLContext </h1>
<dl class="meta">
<dt>Parent:</dt>
<dd class="meta-parent"><a href="../../../object/">Object</a></dd>
</dl> <section class="description"> <p>An <a href="../sslcontext/">SSLContext</a> is used to set various options regarding certificates, algorithms, verification, session caching, etc. The <a href="../sslcontext/">SSLContext</a> is used to create an <a href="../sslsocket/">SSLSocket</a>.</p> <p>All attributes must be set before creating an <a href="../sslsocket/">SSLSocket</a> as the <a href="../sslcontext/">SSLContext</a> will be frozen afterward.</p> <p>The following attributes are available but don't show up in rdoc:</p> <ul>
<li> <p>ssl_version, cert, key, <a href="../sslcontext/#attribute-i-client_ca">#client_ca</a>, <a href="../sslcontext/#attribute-i-ca_file">#ca_file</a>, <a href="../sslcontext/#attribute-i-ca_path">#ca_path</a>, timeout,</p> </li>
<li> <p><a href="../sslcontext/#attribute-i-verify_mode">#verify_mode</a>, <a href="../sslcontext/#attribute-i-verify_depth">#verify_depth</a> <a href="../sslcontext/#attribute-i-client_cert_cb">#client_cert_cb</a>, <a href="../sslcontext/#attribute-i-tmp_dh_callback">#tmp_dh_callback</a>,</p> </li>
<li> <p><a href="../sslcontext/#attribute-i-session_id_context">#session_id_context</a>, session_add_cb, <a href="../sslcontext/#attribute-i-session_new_cb">#session_new_cb</a>, <a href="../sslcontext/#attribute-i-session_remove_cb">#session_remove_cb</a></p> </li>
</ul> </section> <section id="5Buntitled-5D" class="documentation-section"> <section class="constants-list"> <header> <h3>Constants</h3> </header> <dl> <dt id="DEFAULT_CERT_STORE">DEFAULT_CERT_STORE </dt>

<dt id="DEFAULT_PARAMS">DEFAULT_PARAMS </dt>

<dt id="INIT_VARS">INIT_VARS </dt>

<dt id="METHODS">METHODS </dt>
<dd>
<p>The list of available SSL/TLS methods</p> </dd>
<dt id="SESSION_CACHE_BOTH">SESSION_CACHE_BOTH </dt>
<dd>
<p>Both client and server sessions are added to the session cache</p> </dd>
<dt id="SESSION_CACHE_CLIENT">SESSION_CACHE_CLIENT </dt>
<dd>
<p>Client sessions are added to the session cache</p> </dd>
<dt id="SESSION_CACHE_NO_AUTO_CLEAR">SESSION_CACHE_NO_AUTO_CLEAR </dt>
<dd>
<p>Normally the session cache is checked for expired sessions every 255 connections. Since this may lead to a delay that cannot be controlled, the automatic flushing may be disabled and <a href="../sslcontext/#method-i-flush_sessions">flush_sessions</a> can be called explicitly.</p> </dd>
<dt id="SESSION_CACHE_NO_INTERNAL">SESSION_CACHE_NO_INTERNAL </dt>
<dd>
<p>Enables both <a href="../sslcontext/#SESSION_CACHE_NO_INTERNAL_LOOKUP">SESSION_CACHE_NO_INTERNAL_LOOKUP</a> and <a href="../sslcontext/#SESSION_CACHE_NO_INTERNAL_STORE">SESSION_CACHE_NO_INTERNAL_STORE</a>.</p> </dd>
<dt id="SESSION_CACHE_NO_INTERNAL_LOOKUP">SESSION_CACHE_NO_INTERNAL_LOOKUP </dt>
<dd>
<p>Always perform external lookups of sessions even if they are in the internal cache.</p> <p>This flag has no effect on clients</p> </dd>
<dt id="SESSION_CACHE_NO_INTERNAL_STORE">SESSION_CACHE_NO_INTERNAL_STORE </dt>
<dd>
<p>Never automatically store sessions in the internal store.</p> </dd>
<dt id="SESSION_CACHE_OFF">SESSION_CACHE_OFF </dt>
<dd>
<p>No session caching for client or server</p> </dd>
<dt id="SESSION_CACHE_SERVER">SESSION_CACHE_SERVER </dt>
<dd>
<p>Server sessions are added to the session cache</p> </dd>
</dl> </section> <section class="attribute-method-details"> <header> <h3>Attributes</h3> </header> <div class="method-detail"> <div class="method-heading attribute-method-heading" id="attribute-i-alpn_protocols"> <span class="method-name">alpn_protocols</span><span class="attribute-access-type">[RW]</span> </div> <div class="method-description"> <p>An <a href="../../../enumerable/">Enumerable</a> of Strings. Each String represents a protocol to be advertised as the list of supported protocols for Application-Layer Protocol Negotiation. Supported in <a href="../../../openssl/">OpenSSL</a> 1.0.1 and higher. Has no effect on the client side. If not set explicitly, the NPN extension will not be sent by the server in the handshake.</p> <h3 id="attribute-i-alpn_protocols-label-Example">Example</h3> <pre class="ruby" data-language="ruby">ctx.alpn_protocols = ["http/1.1", "spdy/2", "h2"]
</pre> </div> </div> <div class="method-detail"> <div class="method-heading attribute-method-heading" id="attribute-i-alpn_select_cb"> <span class="method-name">alpn_select_cb</span><span class="attribute-access-type">[RW]</span> </div> <div class="method-description"> <p>A callback invoked on the server side when the server needs to select a protocol from the list sent by the client. Supported in <a href="../../../openssl/">OpenSSL</a> 1.0.2 and higher. The server MUST select a protocol of those advertised by the client. If none is acceptable, raising an error in the callback will cause the handshake to fail. Not setting this callback explicitly means not supporting the ALPN extension on the client - any protocols advertised by the server will be ignored.</p> <h3 id="attribute-i-alpn_select_cb-label-Example">Example</h3> <pre class="ruby" data-language="ruby">ctx.alpn_select_cb = lambda do |protocols|
  #inspect the protocols and select one
  protocols.first
end
</pre> </div> </div> <div class="method-detail"> <div class="method-heading attribute-method-heading" id="attribute-i-ca_file"> <span class="method-name">ca_file</span><span class="attribute-access-type">[RW]</span> </div> <div class="method-description"> <p>The path to a file containing a PEM-format CA certificate</p> </div> </div> <div class="method-detail"> <div class="method-heading attribute-method-heading" id="attribute-i-ca_path"> <span class="method-name">ca_path</span><span class="attribute-access-type">[RW]</span> </div> <div class="method-description"> <p>The path to a directory containing CA certificates in PEM format.</p> <p>Files are looked up by subject's <a href="../../x509/">X509</a> name's hash value.</p> </div> </div> <div class="method-detail"> <div class="method-heading attribute-method-heading" id="attribute-i-cert"> <span class="method-name">cert</span><span class="attribute-access-type">[RW]</span> </div> <div class="method-description"> <p>Context certificate</p> </div> </div> <div class="method-detail"> <div class="method-heading attribute-method-heading" id="attribute-i-cert_store"> <span class="method-name">cert_store</span><span class="attribute-access-type">[RW]</span> </div> <div class="method-description"> <p>An <a href="../../x509/store/">OpenSSL::X509::Store</a> used for certificate verification</p> </div> </div> <div class="method-detail"> <div class="method-heading attribute-method-heading" id="attribute-i-client_ca"> <span class="method-name">client_ca</span><span class="attribute-access-type">[RW]</span> </div> <div class="method-description"> <p>A certificate or Array of certificates that will be sent to the client.</p> </div> </div> <div class="method-detail"> <div class="method-heading attribute-method-heading" id="attribute-i-client_cert_cb"> <span class="method-name">client_cert_cb</span><span class="attribute-access-type">[RW]</span> </div> <div class="method-description"> <p>A callback invoked when a client certificate is requested by a server and no certificate has been set.</p> <p>The callback is invoked with a <a href="../session/">Session</a> and must return an Array containing an <a href="../../x509/certificate/">OpenSSL::X509::Certificate</a> and an <a href="../../pkey/">OpenSSL::PKey</a>. If any other value is returned the handshake is suspended.</p> </div> </div> <div class="method-detail"> <div class="method-heading attribute-method-heading" id="attribute-i-extra_chain_cert"> <span class="method-name">extra_chain_cert</span><span class="attribute-access-type">[RW]</span> </div> <div class="method-description"> <p>An Array of extra <a href="../../x509/">X509</a> certificates to be added to the certificate chain.</p> </div> </div> <div class="method-detail"> <div class="method-heading attribute-method-heading" id="attribute-i-key"> <span class="method-name">key</span><span class="attribute-access-type">[RW]</span> </div> <div class="method-description"> <p>Context private key</p> </div> </div> <div class="method-detail"> <div class="method-heading attribute-method-heading" id="attribute-i-npn_protocols"> <span class="method-name">npn_protocols</span><span class="attribute-access-type">[RW]</span> </div> <div class="method-description"> <p>An <a href="../../../enumerable/">Enumerable</a> of Strings. Each String represents a protocol to be advertised as the list of supported protocols for Next Protocol Negotiation. Supported in <a href="../../../openssl/">OpenSSL</a> 1.0.1 and higher. Has no effect on the client side. If not set explicitly, the NPN extension will not be sent by the server in the handshake.</p> <h3 id="attribute-i-npn_protocols-label-Example">Example</h3> <pre class="ruby" data-language="ruby">ctx.npn_protocols = ["http/1.1", "spdy/2"]
</pre> </div> </div> <div class="method-detail"> <div class="method-heading attribute-method-heading" id="attribute-i-npn_select_cb"> <span class="method-name">npn_select_cb</span><span class="attribute-access-type">[RW]</span> </div> <div class="method-description"> <p>A callback invoked on the client side when the client needs to select a protocol from the list sent by the server. Supported in <a href="../../../openssl/">OpenSSL</a> 1.0.1 and higher. The client MUST select a protocol of those advertised by the server. If none is acceptable, raising an error in the callback will cause the handshake to fail. Not setting this callback explicitly means not supporting the NPN extension on the client - any protocols advertised by the server will be ignored.</p> <h3 id="attribute-i-npn_select_cb-label-Example">Example</h3> <pre class="ruby" data-language="ruby">ctx.npn_select_cb = lambda do |protocols|
  #inspect the protocols and select one
  protocols.first
end
</pre> </div> </div> <div class="method-detail"> <div class="method-heading attribute-method-heading" id="attribute-i-renegotiation_cb"> <span class="method-name">renegotiation_cb</span><span class="attribute-access-type">[RW]</span> </div> <div class="method-description"> <p>A callback invoked whenever a new handshake is initiated. May be used to disable renegotiation entirely.</p> <p>The callback is invoked with the active <a href="../sslsocket/">SSLSocket</a>. The callback's return value is irrelevant, normal return indicates “approval” of the renegotiation and will continue the process. To forbid renegotiation and to cancel the process, an Error may be raised within the callback.</p> <h3 id="attribute-i-renegotiation_cb-label-Disable+client+renegotiation">Disable client renegotiation</h3> <p>When running a server, it is often desirable to disable client renegotiation entirely. You may use a callback as follows to implement this feature:</p> <pre class="ruby" data-language="ruby">num_handshakes = 0
ctx.renegotiation_cb = lambda do |ssl|
  num_handshakes += 1
  raise RuntimeError.new("Client renegotiation disabled") if num_handshakes &gt; 1
end
</pre> </div> </div> <div class="method-detail"> <div class="method-heading attribute-method-heading" id="attribute-i-session_get_cb"> <span class="method-name">session_get_cb</span><span class="attribute-access-type">[RW]</span> </div> <div class="method-description"> <p>A callback invoked on a server when a session is proposed by the client but the session could not be found in the server's internal cache.</p> <p>The callback is invoked with the <a href="../sslsocket/">SSLSocket</a> and session id. The callback may return a <a href="../session/">Session</a> from an external cache.</p> </div> </div> <div class="method-detail"> <div class="method-heading attribute-method-heading" id="attribute-i-session_id_context"> <span class="method-name">session_id_context</span><span class="attribute-access-type">[RW]</span> </div> <div class="method-description"> <p>Sets the context in which a session can be reused. This allows sessions for multiple applications to be distinguished, for example, by name.</p> </div> </div> <div class="method-detail"> <div class="method-heading attribute-method-heading" id="attribute-i-session_new_cb"> <span class="method-name">session_new_cb</span><span class="attribute-access-type">[RW]</span> </div> <div class="method-description"> <p>A callback invoked when a new session was negotiated.</p> <p>The callback is invoked with an <a href="../sslsocket/">SSLSocket</a>. If false is returned the session will be removed from the internal cache.</p> </div> </div> <div class="method-detail"> <div class="method-heading attribute-method-heading" id="attribute-i-session_remove_cb"> <span class="method-name">session_remove_cb</span><span class="attribute-access-type">[RW]</span> </div> <div class="method-description"> <p>A callback invoked when a session is removed from the internal cache.</p> <p>The callback is invoked with an <a href="../sslcontext/">SSLContext</a> and a <a href="../session/">Session</a>.</p> </div> </div> <div class="method-detail"> <div class="method-heading attribute-method-heading" id="attribute-i-ssl_timeout"> <span class="method-name">ssl_timeout</span><span class="attribute-access-type">[RW]</span> </div> <div class="method-description"> <p>Maximum session lifetime.</p> </div> </div> <div class="method-detail"> <div class="method-heading attribute-method-heading" id="attribute-i-timeout"> <span class="method-name">timeout</span><span class="attribute-access-type">[RW]</span> </div> <div class="method-description"> <p>Maximum session lifetime.</p> </div> </div> <div class="method-detail"> <div class="method-heading attribute-method-heading" id="attribute-i-tmp_dh_callback"> <span class="method-name">tmp_dh_callback</span><span class="attribute-access-type">[RW]</span> </div> <div class="method-description"> <p>A callback invoked when DH parameters are required.</p> <p>The callback is invoked with the <a href="../session/">Session</a> for the key exchange, an flag indicating the use of an export cipher and the keylength required.</p> <p>The callback must return an <a href="../../pkey/dh/">OpenSSL::PKey::DH</a> instance of the correct key length.</p> </div> </div> <div class="method-detail"> <div class="method-heading attribute-method-heading" id="attribute-i-tmp_ecdh_callback"> <span class="method-name">tmp_ecdh_callback</span><span class="attribute-access-type">[RW]</span> </div> <div class="method-description"> <p>A callback invoked when ECDH parameters are required.</p> <p>The callback is invoked with the <a href="../session/">Session</a> for the key exchange, an flag indicating the use of an export cipher and the keylength required.</p> <p>The callback must return an <a href="../../pkey/ec/">OpenSSL::PKey::EC</a> instance of the correct key length.</p> </div> </div> <div class="method-detail"> <div class="method-heading attribute-method-heading" id="attribute-i-verify_callback"> <span class="method-name">verify_callback</span><span class="attribute-access-type">[RW]</span> </div> <div class="method-description"> <p>A callback for additional certificate verification. The callback is invoked for each certificate in the chain.</p> <p>The callback is invoked with two values. <code>preverify_ok</code> indicates indicates if the verification was passed (true) or not (false). <code>store_context</code> is an <a href="../../x509/storecontext/">OpenSSL::X509::StoreContext</a> containing the context used for certificate verification.</p> <p>If the callback returns false verification is stopped.</p> </div> </div> <div class="method-detail"> <div class="method-heading attribute-method-heading" id="attribute-i-verify_depth"> <span class="method-name">verify_depth</span><span class="attribute-access-type">[RW]</span> </div> <div class="method-description"> <p>Number of CA certificates to walk when verifying a certificate chain.</p> </div> </div> <div class="method-detail"> <div class="method-heading attribute-method-heading" id="attribute-i-verify_mode"> <span class="method-name">verify_mode</span><span class="attribute-access-type">[RW]</span> </div> <div class="method-description"> <p><a href="../session/">Session</a> verification mode.</p> <p>Valid modes are VERIFY_NONE, VERIFY_PEER, VERIFY_CLIENT_ONCE, VERIFY_FAIL_IF_NO_PEER_CERT and defined on <a href="../../ssl/">OpenSSL::SSL</a></p> </div> </div> </section> <section id="public-class-5Buntitled-5D-method-details" class="method-section"> <header> <h3>Public Class Methods</h3> </header> <div class="method-detail "> <div class="method-heading" id="method-c-new"> <span class="method-callseq"> new → ctx </span> <a class="method-click-advice">Show source</a> </div> <div class="method-heading"> <span class="method-callseq"> new(:TLSv1) → ctx </span> </div> <div class="method-heading"> <span class="method-callseq"> new("SSLv23_client") → ctx </span> </div> <div class="method-description"> <p>You can get a list of valid methods with OpenSSL::SSL::SSLContext::METHODS</p> <div class="method-source-code" id="new-source"> <pre class="ruby" data-language="ruby"># File ext/openssl/lib/openssl/ssl.rb, line 108
def initialize(version = nil)
  INIT_VARS.each { |v| instance_variable_set v, nil }
  self.options = self.options | OpenSSL::SSL::OP_ALL
  return unless version
  self.ssl_version = version
end</pre> </div> </div> </div> </section> <section id="public-instance-5Buntitled-5D-method-details" class="method-section"> <header> <h3>Public Instance Methods</h3> </header> <div class="method-detail "> <div class="method-heading" id="method-i-ciphers"> <span class="method-callseq"> ciphers → [[name, version, bits, alg_bits], ...] </span> <a class="method-click-advice">Show source</a> </div> <div class="method-description"> <p>The list of ciphers configured for this context.</p> <div class="method-source-code" id="ciphers-source"> <pre class="c" data-language="c">static VALUE
ossl_sslctx_get_ciphers(VALUE self)
{
    SSL_CTX *ctx;
    STACK_OF(SSL_CIPHER) *ciphers;
    SSL_CIPHER *cipher;
    VALUE ary;
    int i, num;

    GetSSLCTX(self, ctx);
    if(!ctx){
        rb_warning("SSL_CTX is not initialized.");
        return Qnil;
    }
    ciphers = ctx-&gt;cipher_list;

    if (!ciphers)
        return rb_ary_new();

    num = sk_SSL_CIPHER_num(ciphers);
    ary = rb_ary_new2(num);
    for(i = 0; i &lt; num; i++){
        cipher = sk_SSL_CIPHER_value(ciphers, i);
        rb_ary_push(ary, ossl_ssl_cipher_to_ary(cipher));
    }
    return ary;
}</pre> </div> </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-ciphers-3D"> <span class="method-callseq"> ciphers = "cipher1:cipher2:..." </span> <a class="method-click-advice">Show source</a> </div> <div class="method-heading"> <span class="method-callseq"> ciphers = [name, ...] </span> </div> <div class="method-heading"> <span class="method-callseq"> ciphers = [[name, version, bits, alg_bits], ...] </span> </div> <div class="method-description"> <p>Sets the list of available ciphers for this context. Note in a server context some ciphers require the appropriate certificates. For example, an RSA cipher can only be chosen when an RSA certificate is available.</p> <p>See also <a href="../../cipher/">OpenSSL::Cipher</a> and <a href="../../cipher/#method-c-ciphers">OpenSSL::Cipher.ciphers</a></p> <div class="method-source-code" id="ciphers-3D-source"> <pre class="c" data-language="c">static VALUE
ossl_sslctx_set_ciphers(VALUE self, VALUE v)
{
    SSL_CTX *ctx;
    VALUE str, elem;
    int i;

    rb_check_frozen(self);
    if (NIL_P(v))
        return v;
    else if (RB_TYPE_P(v, T_ARRAY)) {
        str = rb_str_new(0, 0);
        for (i = 0; i &lt; RARRAY_LEN(v); i++) {
            elem = rb_ary_entry(v, i);
            if (RB_TYPE_P(elem, T_ARRAY)) elem = rb_ary_entry(elem, 0);
            elem = rb_String(elem);
            rb_str_append(str, elem);
            if (i &lt; RARRAY_LEN(v)-1) rb_str_cat2(str, ":");
        }
    } else {
        str = v;
        StringValue(str);
    }

    GetSSLCTX(self, ctx);
    if(!ctx){
        ossl_raise(eSSLError, "SSL_CTX is not initialized.");
        return Qnil;
    }
    if (!SSL_CTX_set_cipher_list(ctx, RSTRING_PTR(str))) {
        ossl_raise(eSSLError, "SSL_CTX_set_cipher_list");
    }

    return v;
}</pre> </div> </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-flush_sessions"> <span class="method-callseq"> flush_sessions(time | nil) → self </span> <a class="method-click-advice">Show source</a> </div> <div class="method-description"> <p>Removes sessions in the internal cache that have expired at <code>time</code>.</p> <div class="method-source-code" id="flush_sessions-source"> <pre class="c" data-language="c">static VALUE
ossl_sslctx_flush_sessions(int argc, VALUE *argv, VALUE self)
{
    VALUE arg1;
    SSL_CTX *ctx;
    time_t tm = 0;

    rb_scan_args(argc, argv, "01", &amp;arg1);

    GetSSLCTX(self, ctx);

    if (NIL_P(arg1)) {
        tm = time(0);
    } else if (rb_obj_is_instance_of(arg1, rb_cTime)) {
        tm = NUM2LONG(rb_funcall(arg1, rb_intern("to_i"), 0));
    } else {
        ossl_raise(rb_eArgError, "arg must be Time or nil");
    }

    SSL_CTX_flush_sessions(ctx, (long)tm);

    return self;
}</pre> </div> </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-options"> <span class="method-name">options</span><span class="method-args">()</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description"> <p>Gets various <a href="../../../openssl/">OpenSSL</a> options.</p> <div class="method-source-code" id="options-source"> <pre class="c" data-language="c">static VALUE
ossl_sslctx_get_options(VALUE self)
{
    SSL_CTX *ctx;
    GetSSLCTX(self, ctx);
    return LONG2NUM(SSL_CTX_get_options(ctx));
}</pre> </div> </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-options-3D"> <span class="method-name">options=</span><span class="method-args">(p1)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description"> <p>Sets various <a href="../../../openssl/">OpenSSL</a> options.</p> <div class="method-source-code" id="options-3D-source"> <pre class="c" data-language="c">static VALUE
ossl_sslctx_set_options(VALUE self, VALUE options)
{
    SSL_CTX *ctx;

    rb_check_frozen(self);
    GetSSLCTX(self, ctx);

    SSL_CTX_clear_options(ctx, SSL_CTX_get_options(ctx));

    if (NIL_P(options)) {
        SSL_CTX_set_options(ctx, SSL_OP_ALL);
    } else {
        SSL_CTX_set_options(ctx, NUM2LONG(options));
    }

    return self;
}</pre> </div> </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-session_add"> <span class="method-callseq"> session_add(session) → true | false </span> <a class="method-click-advice">Show source</a> </div> <div class="method-description"> <p>Adds <code>session</code> to the session cache</p> <div class="method-source-code" id="session_add-source"> <pre class="c" data-language="c">static VALUE
ossl_sslctx_session_add(VALUE self, VALUE arg)
{
    SSL_CTX *ctx;
    SSL_SESSION *sess;

    GetSSLCTX(self, ctx);
    SafeGetSSLSession(arg, sess);

    return SSL_CTX_add_session(ctx, sess) == 1 ? Qtrue : Qfalse;
}</pre> </div> </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-session_cache_mode"> <span class="method-callseq"> session_cache_mode → Integer </span> <a class="method-click-advice">Show source</a> </div> <div class="method-description"> <p>The current session cache mode.</p> <div class="method-source-code" id="session_cache_mode-source"> <pre class="c" data-language="c">static VALUE
ossl_sslctx_get_session_cache_mode(VALUE self)
{
    SSL_CTX *ctx;

    GetSSLCTX(self, ctx);

    return LONG2NUM(SSL_CTX_get_session_cache_mode(ctx));
}</pre> </div> </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-session_cache_mode-3D"> <span class="method-callseq"> session_cache_mode=(integer) → Integer </span> <a class="method-click-advice">Show source</a> </div> <div class="method-description"> <p>Sets the <a href="../../ssl/">SSL</a> session cache mode. Bitwise-or together the desired SESSION_CACHE_* constants to set. See SSL_CTX_set_session_cache_mode(3) for details.</p> <div class="method-source-code" id="session_cache_mode-3D-source"> <pre class="c" data-language="c">static VALUE
ossl_sslctx_set_session_cache_mode(VALUE self, VALUE arg)
{
    SSL_CTX *ctx;

    GetSSLCTX(self, ctx);

    SSL_CTX_set_session_cache_mode(ctx, NUM2LONG(arg));

    return arg;
}</pre> </div> </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-session_cache_size"> <span class="method-callseq"> session_cache_size → Integer </span> <a class="method-click-advice">Show source</a> </div> <div class="method-description"> <p>Returns the current session cache size. Zero is used to represent an unlimited cache size.</p> <div class="method-source-code" id="session_cache_size-source"> <pre class="c" data-language="c">static VALUE
ossl_sslctx_get_session_cache_size(VALUE self)
{
    SSL_CTX *ctx;

    GetSSLCTX(self, ctx);

    return LONG2NUM(SSL_CTX_sess_get_cache_size(ctx));
}</pre> </div> </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-session_cache_size-3D"> <span class="method-callseq"> session_cache_size=(integer) → Integer </span> <a class="method-click-advice">Show source</a> </div> <div class="method-description"> <p>Sets the session cache size. Returns the previously valid session cache size. Zero is used to represent an unlimited session cache size.</p> <div class="method-source-code" id="session_cache_size-3D-source"> <pre class="c" data-language="c">static VALUE
ossl_sslctx_set_session_cache_size(VALUE self, VALUE arg)
{
    SSL_CTX *ctx;

    GetSSLCTX(self, ctx);

    SSL_CTX_sess_set_cache_size(ctx, NUM2LONG(arg));

    return arg;
}</pre> </div> </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-session_cache_stats"> <span class="method-callseq"> session_cache_stats → Hash </span> <a class="method-click-advice">Show source</a> </div> <div class="method-description"> <p>Returns a <a href="../../../hash/">Hash</a> containing the following keys:</p> <dl class="rdoc-list note-list">
<dt>:accept </dt>
<dd> <p>Number of started SSL/TLS handshakes in server mode</p> </dd>
<dt>:accept_good </dt>
<dd> <p>Number of established SSL/TLS sessions in server mode</p> </dd>
<dt>:accept_renegotiate </dt>
<dd> <p>Number of start renegotiations in server mode</p> </dd>
<dt>:cache_full </dt>
<dd> <p>Number of sessions that were removed due to cache overflow</p> </dd>
<dt>:cache_hits </dt>
<dd> <p>Number of successfully reused connections</p> </dd>
<dt>:cache_misses </dt>
<dd> <p>Number of sessions proposed by clients that were not found in the cache</p> </dd>
<dt>:cache_num </dt>
<dd> <p>Number of sessions in the internal session cache</p> </dd>
<dt>:cb_hits </dt>
<dd> <p>Number of sessions retrieved from the external cache in server mode</p> </dd>
<dt>:connect </dt>
<dd> <p>Number of started SSL/TLS handshakes in client mode</p> </dd>
<dt>:connect_good </dt>
<dd> <p>Number of established SSL/TLS sessions in client mode</p> </dd>
<dt>:connect_renegotiate </dt>
<dd> <p>Number of start renegotiations in client mode</p> </dd>
<dt>:timeouts </dt>
<dd> <p>Number of sessions proposed by clients that were found in the cache but had expired due to timeouts</p> </dd>
</dl> <div class="method-source-code" id="session_cache_stats-source"> <pre class="c" data-language="c">static VALUE
ossl_sslctx_get_session_cache_stats(VALUE self)
{
    SSL_CTX *ctx;
    VALUE hash;

    GetSSLCTX(self, ctx);

    hash = rb_hash_new();
    rb_hash_aset(hash, ID2SYM(rb_intern("cache_num")), LONG2NUM(SSL_CTX_sess_number(ctx)));
    rb_hash_aset(hash, ID2SYM(rb_intern("connect")), LONG2NUM(SSL_CTX_sess_connect(ctx)));
    rb_hash_aset(hash, ID2SYM(rb_intern("connect_good")), LONG2NUM(SSL_CTX_sess_connect_good(ctx)));
    rb_hash_aset(hash, ID2SYM(rb_intern("connect_renegotiate")), LONG2NUM(SSL_CTX_sess_connect_renegotiate(ctx)));
    rb_hash_aset(hash, ID2SYM(rb_intern("accept")), LONG2NUM(SSL_CTX_sess_accept(ctx)));
    rb_hash_aset(hash, ID2SYM(rb_intern("accept_good")), LONG2NUM(SSL_CTX_sess_accept_good(ctx)));
    rb_hash_aset(hash, ID2SYM(rb_intern("accept_renegotiate")), LONG2NUM(SSL_CTX_sess_accept_renegotiate(ctx)));
    rb_hash_aset(hash, ID2SYM(rb_intern("cache_hits")), LONG2NUM(SSL_CTX_sess_hits(ctx)));
    rb_hash_aset(hash, ID2SYM(rb_intern("cb_hits")), LONG2NUM(SSL_CTX_sess_cb_hits(ctx)));
    rb_hash_aset(hash, ID2SYM(rb_intern("cache_misses")), LONG2NUM(SSL_CTX_sess_misses(ctx)));
    rb_hash_aset(hash, ID2SYM(rb_intern("cache_full")), LONG2NUM(SSL_CTX_sess_cache_full(ctx)));
    rb_hash_aset(hash, ID2SYM(rb_intern("timeouts")), LONG2NUM(SSL_CTX_sess_timeouts(ctx)));

    return hash;
}</pre> </div> </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-session_remove"> <span class="method-callseq"> session_remove(session) → true | false </span> <a class="method-click-advice">Show source</a> </div> <div class="method-description"> <p>Removes <code>session</code> from the session cache</p> <div class="method-source-code" id="session_remove-source"> <pre class="c" data-language="c">static VALUE
ossl_sslctx_session_remove(VALUE self, VALUE arg)
{
    SSL_CTX *ctx;
    SSL_SESSION *sess;

    GetSSLCTX(self, ctx);
    SafeGetSSLSession(arg, sess);

    return SSL_CTX_remove_session(ctx, sess) == 1 ? Qtrue : Qfalse;
}</pre> </div> </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-set_params"> <span class="method-name">set_params</span><span class="method-args">(params={})</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description"> <p>Sets the parameters for this <a href="../../ssl/">SSL</a> context to the values in <code>params</code>. The keys in <code>params</code> must be assignment methods on <a href="../sslcontext/">SSLContext</a>.</p> <p>If the <a href="../sslcontext/#attribute-i-verify_mode">#verify_mode</a> is not VERIFY_NONE and <a href="../sslcontext/#attribute-i-ca_file">#ca_file</a>, <a href="../sslcontext/#attribute-i-ca_path">#ca_path</a> and <a href="../sslcontext/#attribute-i-cert_store">#cert_store</a> are not set then the system default certificate store is used.</p> <div class="method-source-code" id="set_params-source"> <pre class="ruby" data-language="ruby"># File ext/openssl/lib/openssl/ssl.rb, line 123
def set_params(params={})
  params = DEFAULT_PARAMS.merge(params)
  params.each{|name, value| self.__send__("#{name}=", value) }
  if self.verify_mode != OpenSSL::SSL::VERIFY_NONE
    unless self.ca_file or self.ca_path or self.cert_store
      self.cert_store = DEFAULT_CERT_STORE
    end
  end
  return params
end</pre> </div> </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-setup"> <span class="method-callseq"> setup → Qtrue # first time </span> <a class="method-click-advice">Show source</a> </div> <div class="method-heading"> <span class="method-callseq"> setup → nil # thereafter </span> </div> <div class="method-description"> <p>This method is called automatically when a new <a href="../sslsocket/">SSLSocket</a> is created. However, it is not thread-safe and must be called before creating <a href="../sslsocket/">SSLSocket</a> objects in a multi-threaded program.</p> <div class="method-source-code" id="setup-source"> <pre class="c" data-language="c">static VALUE
ossl_sslctx_setup(VALUE self)
{
    SSL_CTX *ctx;
    X509 *cert = NULL, *client_ca = NULL;
    X509_STORE *store;
    EVP_PKEY *key = NULL;
    char *ca_path = NULL, *ca_file = NULL;
    int verify_mode;
    long i;
    VALUE val;

    if(OBJ_FROZEN(self)) return Qnil;
    GetSSLCTX(self, ctx);

#if !defined(OPENSSL_NO_DH)
    SSL_CTX_set_tmp_dh_callback(ctx, ossl_tmp_dh_callback);
#endif

#if !defined(OPENSSL_NO_EC)
    if (RTEST(ossl_sslctx_get_tmp_ecdh_cb(self))){
        SSL_CTX_set_tmp_ecdh_callback(ctx, ossl_tmp_ecdh_callback);
    }
#endif

    val = ossl_sslctx_get_cert_store(self);
    if(!NIL_P(val)){
        /*
         * WORKAROUND:
         *   X509_STORE can count references, but
         *   X509_STORE_free() doesn't care it.
         *   So we won't increment it but mark it by ex_data.
         */
        store = GetX509StorePtr(val); /* NO NEED TO DUP */
        SSL_CTX_set_cert_store(ctx, store);
        SSL_CTX_set_ex_data(ctx, ossl_ssl_ex_store_p, (void*)1);
    }

    val = ossl_sslctx_get_extra_cert(self);
    if(!NIL_P(val)){
        rb_block_call(val, rb_intern("each"), 0, 0, ossl_sslctx_add_extra_chain_cert_i, self);
    }

    /* private key may be bundled in certificate file. */
    val = ossl_sslctx_get_cert(self);
    cert = NIL_P(val) ? NULL : GetX509CertPtr(val); /* NO DUP NEEDED */
    val = ossl_sslctx_get_key(self);
    key = NIL_P(val) ? NULL : GetPKeyPtr(val); /* NO DUP NEEDED */
    if (cert &amp;&amp; key) {
        if (!SSL_CTX_use_certificate(ctx, cert)) {
            /* Adds a ref =&gt; Safe to FREE */
            ossl_raise(eSSLError, "SSL_CTX_use_certificate");
        }
        if (!SSL_CTX_use_PrivateKey(ctx, key)) {
            /* Adds a ref =&gt; Safe to FREE */
            ossl_raise(eSSLError, "SSL_CTX_use_PrivateKey");
        }
        if (!SSL_CTX_check_private_key(ctx)) {
            ossl_raise(eSSLError, "SSL_CTX_check_private_key");
        }
    }

    val = ossl_sslctx_get_client_ca(self);
    if(!NIL_P(val)){
        if (RB_TYPE_P(val, T_ARRAY)) {
            for(i = 0; i &lt; RARRAY_LEN(val); i++){
                client_ca = GetX509CertPtr(RARRAY_AREF(val, i));
                if (!SSL_CTX_add_client_CA(ctx, client_ca)){
                    /* Copies X509_NAME =&gt; FREE it. */
                    ossl_raise(eSSLError, "SSL_CTX_add_client_CA");
                }
            }
        }
        else{
            client_ca = GetX509CertPtr(val); /* NO DUP NEEDED. */
            if (!SSL_CTX_add_client_CA(ctx, client_ca)){
                /* Copies X509_NAME =&gt; FREE it. */
                ossl_raise(eSSLError, "SSL_CTX_add_client_CA");
            }
        }
    }

    val = ossl_sslctx_get_ca_file(self);
    ca_file = NIL_P(val) ? NULL : StringValuePtr(val);
    val = ossl_sslctx_get_ca_path(self);
    ca_path = NIL_P(val) ? NULL : StringValuePtr(val);
    if(ca_file || ca_path){
        if (!SSL_CTX_load_verify_locations(ctx, ca_file, ca_path))
            rb_warning("can't set verify locations");
    }

    val = ossl_sslctx_get_verify_mode(self);
    verify_mode = NIL_P(val) ? SSL_VERIFY_NONE : NUM2INT(val);
    SSL_CTX_set_verify(ctx, verify_mode, ossl_ssl_verify_callback);
    if (RTEST(ossl_sslctx_get_client_cert_cb(self)))
        SSL_CTX_set_client_cert_cb(ctx, ossl_client_cert_cb);

    val = ossl_sslctx_get_timeout(self);
    if(!NIL_P(val)) SSL_CTX_set_timeout(ctx, NUM2LONG(val));

    val = ossl_sslctx_get_verify_dep(self);
    if(!NIL_P(val)) SSL_CTX_set_verify_depth(ctx, NUM2INT(val));

#ifdef HAVE_SSL_CTX_SET_NEXT_PROTO_SELECT_CB
    val = rb_iv_get(self, "@npn_protocols");
    if (!NIL_P(val)) {
        rb_iv_set(self, "@_protocols", ssl_encode_npn_protocols(val));
        SSL_CTX_set_next_protos_advertised_cb(ctx, ssl_npn_advertise_cb, (void *) self);
        OSSL_Debug("SSL NPN advertise callback added");
    }
    if (RTEST(rb_iv_get(self, "@npn_select_cb"))) {
        SSL_CTX_set_next_proto_select_cb(ctx, ssl_npn_select_cb, (void *) self);
        OSSL_Debug("SSL NPN select callback added");
    }
#endif

#ifdef HAVE_SSL_CTX_SET_ALPN_SELECT_CB
    val = rb_iv_get(self, "@alpn_protocols");
    if (!NIL_P(val)) {
        VALUE rprotos = ssl_encode_npn_protocols(val);
        SSL_CTX_set_alpn_protos(ctx, (const unsigned char *)StringValueCStr(rprotos), RSTRING_LENINT(rprotos));
        OSSL_Debug("SSL ALPN values added");
    }
    if (RTEST(rb_iv_get(self, "@alpn_select_cb"))) {
        SSL_CTX_set_alpn_select_cb(ctx, ssl_alpn_select_cb, (void *) self);
        OSSL_Debug("SSL ALPN select callback added");
    }
#endif

    rb_obj_freeze(self);

    val = ossl_sslctx_get_sess_id_ctx(self);
    if (!NIL_P(val)){
        StringValue(val);
        if (!SSL_CTX_set_session_id_context(ctx, (unsigned char *)RSTRING_PTR(val),
                                            RSTRING_LENINT(val))){
            ossl_raise(eSSLError, "SSL_CTX_set_session_id_context");
        }
    }

    if (RTEST(rb_iv_get(self, "@session_get_cb"))) {
        SSL_CTX_sess_set_get_cb(ctx, ossl_sslctx_session_get_cb);
        OSSL_Debug("SSL SESSION get callback added");
    }
    if (RTEST(rb_iv_get(self, "@session_new_cb"))) {
        SSL_CTX_sess_set_new_cb(ctx, ossl_sslctx_session_new_cb);
        OSSL_Debug("SSL SESSION new callback added");
    }
    if (RTEST(rb_iv_get(self, "@session_remove_cb"))) {
        SSL_CTX_sess_set_remove_cb(ctx, ossl_sslctx_session_remove_cb);
        OSSL_Debug("SSL SESSION remove callback added");
    }

#ifdef HAVE_SSL_SET_TLSEXT_HOST_NAME
    val = rb_iv_get(self, "@servername_cb");
    if (!NIL_P(val)) {
        SSL_CTX_set_tlsext_servername_callback(ctx, ssl_servername_cb);
        OSSL_Debug("SSL TLSEXT servername callback added");
    }
#endif

    return Qtrue;
}</pre> </div> </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-ssl_version-3D"> <span class="method-callseq"> ssl_version = :TLSv1 </span> <a class="method-click-advice">Show source</a> </div> <div class="method-heading"> <span class="method-callseq"> ssl_version = "SSLv23_client" </span> </div> <div class="method-description"> <p>You can get a list of valid versions with OpenSSL::SSL::SSLContext::METHODS</p> <div class="method-source-code" id="ssl_version-3D-source"> <pre class="c" data-language="c">static VALUE
ossl_sslctx_set_ssl_version(VALUE self, VALUE ssl_method)
{
    SSL_METHOD *method = NULL;
    const char *s;
    VALUE m = ssl_method;
    int i;

    SSL_CTX *ctx;
    if (RB_TYPE_P(ssl_method, T_SYMBOL))
        m = rb_sym2str(ssl_method);
    s = StringValueCStr(m);
    for (i = 0; i &lt; numberof(ossl_ssl_method_tab); i++) {
        if (strcmp(ossl_ssl_method_tab[i].name, s) == 0) {
            method = ossl_ssl_method_tab[i].func();
            break;
        }
    }
    if (!method) {
        ossl_raise(rb_eArgError, "unknown SSL method `%"PRIsVALUE"'.", m);
    }
    GetSSLCTX(self, ctx);
    if (SSL_CTX_set_ssl_version(ctx, method) != 1) {
        ossl_raise(eSSLError, "SSL_CTX_set_ssl_version");
    }

    return ssl_method;
}</pre> </div> </div> </div> </section> </section><div class="_attribution">
  <p class="_attribution-p">
    Ruby Core © 1993–2016 Yukihiro Matsumoto<br>Licensed under the Ruby License.<br>Ruby Standard Library © contributors<br>Licensed under their own licenses.<br>
    
  </p>
</div>

			</div>
		</div>
	</section>

	</div>
</body>
</html>
