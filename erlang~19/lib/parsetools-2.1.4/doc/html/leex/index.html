
<!DOCTYPE HTML>

<html lang="en">

<head>
  <meta charset="utf-8">
  <title>Leex - Erlang 19 - W3cubDocs</title>
  
  <meta name="description" content=" leex ">
  <meta name="keywords" content="leex, -, erlang, erlang~19">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="http://docs.w3cub.com/erlang~19/lib/parsetools-2.1.4/doc/html/leex/">
  <link href="/favicon.png" rel="icon">
  <link type="text/css" rel="stylesheet" href="/assets/application-50364fff564ce3b6327021805f3f00e2957b441cf27f576a7dd4ff63bbc47047.css">
  <script type="text/javascript" src="/assets/application-db64bfd54ceb42be11af7995804cf4902548419ceb79d509b0b7d62c22d98e6f.js"></script>
  <script src="/json/erlang~19.js"></script>
  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-71174418-1']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>


</head>

<body>
	<div class="_app">
	<header class="_header">
  
  <form class="_search">
    <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
    <a class="_search-clear"></a>
    <div class="_search-tag"></div>
  </form>
  
  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/erlang~19/" class="_nav-link" title="" style="margin-left:0;">Erlang 19</a></span>
  
  <nav class="_nav">
    <a href="/app/" class="_nav-link ">App</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		<div class="_list">
			
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<div class="_page _erlang">
				
<h1>leex</h1> <h2>Module</h2> <p class="REFBODY">leex</p> <h2>Module summary</h2> <p class="REFBODY">Lexical analyzer generator for Erlang</p> <h2>Description</h2> 
<p>A regular expression based lexical analyzer generator for Erlang, similar to lex or flex.</p> <div class="note"> <div class="label">Note</div> <div class="content">

<p>The Leex module should be considered experimental as it will be subject to changes in future releases.</p>
</div> </div>  <h2 id="id63928">Data types</h2>  <div class="example"><pre>
ErrorInfo = {ErrorLine,module(),error_descriptor()}
ErrorLine = integer()
Token = tuple()</pre></div>  <h2>Exports</h2> <h3 id="file-2" class="code">file(FileName, [, Options]) -&gt; LeexRet</h3>  <p>Types:</p>           <pre>FileName = filename()
Options = Option | [Option]
Option = - see below -
LeexRet = {ok, Scannerfile} | {ok, Scannerfile, Warnings} | error | {error, Errors, Warnings}
Scannerfile = filename()
Warnings = Errors = [{filename(), [ErrorInfo]}]
ErrorInfo = {ErrorLine, module(), Reason}
ErrorLine = integer()
Reason = - formatable by format_error/1 -</pre>

<p>Generates a lexical analyzer from the definition in the input file. The input file has the extension <code class="code">.xrl</code>. This is added to the filename if it is not given. The resulting module is the Xrl filename without the <code class="code">.xrl</code> extension.</p> <p>The current options are:</p> <dl> <dt><strong><code class="code">dfa_graph</code></strong></dt> <dd> <p>Generates a <code class="code">.dot</code> file which contains a description of the DFA in a format which can be viewed with Graphviz, <code class="code">www.graphviz.com</code>.</p> </dd> <dt><strong><code class="code">{includefile,Includefile}</code></strong></dt> <dd> <p>Uses a specific or customised prologue file instead of default <code class="code">lib/parsetools/include/leexinc.hrl</code> which is otherwise included.</p> </dd> <dt><strong><code class="code">{report_errors, bool()}</code></strong></dt> <dd> <p>Causes errors to be printed as they occur. Default is <code class="code">true</code>.</p> </dd> <dt><strong><code class="code">{report_warnings, bool()}</code></strong></dt> <dd> <p>Causes warnings to be printed as they occur. Default is <code class="code">true</code>.</p> </dd> <dt><strong><code class="code">warnings_as_errors</code></strong></dt> <dd> <p>Causes warnings to be treated as errors.</p> </dd> <dt><strong><code class="code">{report, bool()}</code></strong></dt> <dd> <p>This is a short form for both <code class="code">report_errors</code> and <code class="code">report_warnings</code>.</p> </dd> <dt><strong><code class="code">{return_errors, bool()}</code></strong></dt> <dd> <p>If this flag is set, <code class="code">{error, Errors, Warnings}</code> is returned when there are errors. Default is <code class="code">false</code>.</p> </dd> <dt><strong><code class="code">{return_warnings, bool()}</code></strong></dt> <dd> <p>If this flag is set, an extra field containing <code class="code">Warnings</code> is added to the tuple returned upon success. Default is <code class="code">false</code>.</p> </dd> <dt><strong><code class="code">{return, bool()}</code></strong></dt> <dd> <p>This is a short form for both <code class="code">return_errors</code> and <code class="code">return_warnings</code>.</p> </dd> <dt><strong><code class="code">{scannerfile, Scannerfile}</code></strong></dt> <dd> <p><code class="code">Scannerfile</code> is the name of the file that will contain the Erlang scanner code that is generated. The default (<code class="code">""</code>) is to add the extension <code class="code">.erl</code> to <code class="code">FileName</code> stripped of the <code class="code">.xrl</code> extension.</p> </dd> <dt><strong><code class="code">{verbose, bool()}</code></strong></dt> <dd> <p>Outputs information from parsing the input file and generating the internal tables.</p> </dd> </dl> <p>Any of the Boolean options can be set to <code class="code">true</code> by stating the name of the option. For example, <code class="code">verbose</code> is equivalent to <code class="code">{verbose, true}</code>.</p> <p>Leex will add the extension <code class="code">.hrl</code> to the <code class="code">Includefile</code> name and the extension <code class="code">.erl</code> to the <code class="code">Scannerfile</code> name, unless the extension is already there.</p>  <h3 id="format_error-1" class="code">format_error(ErrorInfo) -&gt; Chars</h3>  <p>Types:</p>   <pre>Chars = [char() | Chars]</pre>

<p>Returns a string which describes the error <code class="code">ErrorInfo</code> returned when there is an error in a regular expression.</p>  <h2 id="id61319">Generated scanner exports</h2>  <p>The following functions are exported by the generated scanner.</p>  <h2>Exports</h2> <h3 id="string-2" class="code">string(String) -&gt; StringRet<br>string(String, StartLine) -&gt; StringRet</h3>  <p>Types:</p>      <pre>String = string()
StringRet = {ok,Tokens,EndLine} | ErrorInfo
Tokens = [Token]
EndLine = StartLine = integer()</pre>

<p>Scans <code class="code">String</code> and returns all the tokens in it, or an error.</p> <div class="note"> <div class="label">Note</div> <div class="content">

<p>It is an error if not all of the characters in <code class="code">String</code> are consumed.</p>
</div> </div>  <h3 id="token-3" class="code">token(Cont, Chars) -&gt; {more,Cont1} | {done,TokenRet,RestChars}<br>token(Cont, Chars, StartLine) -&gt; {more,Cont1} | {done,TokenRet,RestChars}</h3>  <p>Types:</p>       <pre>Cont = [] | Cont1
Cont1 = tuple()
Chars = RestChars = string() | eof
TokenRet = {ok, Token, EndLine} | {eof, EndLine} | ErrorInfo
StartLine = EndLine = integer()</pre>

<p>This is a re-entrant call to try and scan one token from <code class="code">Chars</code>. If there are enough characters in <code class="code">Chars</code> to either scan a token or detect an error then this will be returned with <code class="code">{done,...}</code>. Otherwise <code class="code">{cont,Cont}</code> will be returned where <code class="code">Cont</code> is used in the next call to <code class="code">token()</code> with more characters to try an scan the token. This is continued until a token has been scanned. <code class="code">Cont</code> is initially <code class="code">[]</code>.</p> <p>It is not designed to be called directly by an application but used through the i/o system where it can typically be called in an application by:</p> <div class="example"><pre>
io:request(InFile, {get_until,Prompt,Module,token,[Line]})
  -&gt; TokenRet</pre></div>  <h3 id="tokens-3" class="code">tokens(Cont, Chars) -&gt; {more,Cont1} | {done,TokensRet,RestChars}<br>tokens(Cont, Chars, StartLine) -&gt; {more,Cont1} | {done,TokensRet,RestChars}</h3>  <p>Types:</p>        <pre>Cont = [] | Cont1
Cont1 = tuple()
Chars = RestChars = string() | eof
TokensRet = {ok, Tokens, EndLine} | {eof, EndLine} | ErrorInfo
Tokens = [Token]
StartLine = EndLine = integer()</pre>

<p>This is a re-entrant call to try and scan tokens from <code class="code">Chars</code>. If there are enough characters in <code class="code">Chars</code> to either scan tokens or detect an error then this will be returned with <code class="code">{done,...}</code>. Otherwise <code class="code">{cont,Cont}</code> will be returned where <code class="code">Cont</code> is used in the next call to <code class="code">tokens()</code> with more characters to try an scan the tokens. This is continued until all tokens have been scanned. <code class="code">Cont</code> is initially <code class="code">[]</code>.</p> <p>This functions differs from <code class="code">token</code> in that it will continue to scan tokens upto and including an <code class="code">{end_token,Token}</code> has been scanned (see next section). It will then return all the tokens. This is typically used for scanning grammars like Erlang where there is an explicit end token, <code class="code">'.'</code>. If no end token is found then the whole file will be scanned and returned. If an error occurs then all tokens upto and including the next end token will be skipped.</p> <p>It is not designed to be called directly by an application but used through the i/o system where it can typically be called in an application by:</p> <div class="example"><pre>
io:request(InFile, {get_until,Prompt,Module,tokens,[Line]})
  -&gt; TokensRet</pre></div>  <h2 id="id61874">Input File Format</h2>  <p>Erlang style comments starting with a <code class="code">%</code> are allowed in scanner files. A definition file has the following format:</p> <div class="example"><pre>
&lt;Header&gt;

Definitions.

&lt;Macro Definitions&gt;

Rules.

&lt;Token Rules&gt;

Erlang code.

&lt;Erlang code&gt;</pre></div> <p>The "Definitions.", "Rules." and "Erlang code." headings are mandatory and must occur at the beginning of a source line. The &lt;Header&gt;, &lt;Macro Definitions&gt; and &lt;Erlang code&gt; sections may be empty but there must be at least one rule.</p> <p>Macro definitions have the following format:</p> <div class="example"><pre>
NAME = VALUE</pre></div> <p>and there must be spaces around <code class="code">=</code>. Macros can be used in the regular expressions of rules by writing <code class="code">{NAME}</code>.</p> <div class="note"> <div class="label">Note</div> <div class="content">

<p>When macros are expanded in expressions the macro calls are replaced by the macro value without any form of quoting or enclosing in parentheses.</p>
</div> </div> <p>Rules have the following format:</p> <div class="example"><pre>
&lt;Regexp&gt; : &lt;Erlang code&gt;.</pre></div> <p>The &lt;Regexp&gt; must occur at the start of a line and not include any blanks; use <code class="code">\t</code> and <code class="code">\s</code> to include TAB and SPACE characters in the regular expression. If &lt;Regexp&gt; matches then the corresponding &lt;Erlang code&gt; is evaluated to generate a token. With the Erlang code the following predefined variables are available:</p> <dl> <dt><strong><code class="code">TokenChars</code></strong></dt> <dd> <p>A list of the characters in the matched token.</p> </dd> <dt><strong><code class="code">TokenLen</code></strong></dt> <dd> <p>The number of characters in the matched token.</p> </dd> <dt><strong><code class="code">TokenLine</code></strong></dt> <dd> <p>The line number where the token occurred.</p> </dd> </dl> <p>The code must return:</p> <dl> <dt><strong><code class="code">{token,Token}</code></strong></dt> <dd> <p>Return <code class="code">Token</code> to the caller.</p> </dd> <dt><strong><code class="code">{end_token,Token}</code></strong></dt> <dd> <p>Return <code class="code">Token</code> and is last token in a tokens call.</p> </dd> <dt><strong><code class="code">skip_token</code></strong></dt> <dd> <p>Skip this token completely.</p> </dd> <dt><strong><code class="code">{error,ErrString}</code></strong></dt> <dd> <p>An error in the token, <code class="code">ErrString</code> is a string describing the error.</p> </dd> </dl> <p>It is also possible to push back characters into the input characters with the following returns:</p> <ul> <li><code class="code">{token,Token,PushBackList}</code></li> <li><code class="code">{end_token,Token,PushBackList}</code></li> <li><code class="code">{skip_token,PushBackList}</code></li> </ul> <p>These have the same meanings as the normal returns but the characters in <code class="code">PushBackList</code> will be prepended to the input characters and scanned for the next token. Note that pushing back a newline will mean the line numbering will no longer be correct.</p> <div class="note"> <div class="label">Note</div> <div class="content">

<p>Pushing back characters gives you unexpected possibilities to cause the scanner to loop!</p>
</div> </div> <p>The following example would match a simple Erlang integer or float and return a token which could be sent to the Erlang parser:</p> <div class="example"><pre>
D = [0-9]

{D}+ :
  {token,{integer,TokenLine,list_to_integer(TokenChars)}}.

{D}+\.{D}+((E|e)(\+|\-)?{D}+)? :
  {token,{float,TokenLine,list_to_float(TokenChars)}}.</pre></div> <p>The Erlang code in the "Erlang code." section is written into the output file directly after the module declaration and predefined exports declaration so it is possible to add extra exports, define imports and other attributes which are then visible in the whole file.</p>  <h2 id="id62112">Regular Expressions</h2>  <p>The regular expressions allowed here is a subset of the set found in <code class="code">egrep</code> and in the AWK programming language, as defined in the book, The AWK Programming Language, by A. V. Aho, B. W. Kernighan, P. J. Weinberger. They are composed of the following characters:</p> <dl> <dt><strong><code class="code">c</code></strong></dt> <dd> <p>Matches the non-metacharacter c.</p> </dd> <dt><strong><code class="code">\c</code></strong></dt> <dd> <p>Matches the escape sequence or literal character c.</p> </dd> <dt><strong><code class="code">.</code></strong></dt> <dd> <p>Matches any character.</p> </dd> <dt><strong><code class="code">^</code></strong></dt> <dd> <p>Matches the beginning of a string.</p> </dd> <dt><strong><code class="code">$</code></strong></dt> <dd><p>Matches the end of a string.</p></dd> <dt><strong><code class="code">[abc...]</code></strong></dt> <dd> <p>Character class, which matches any of the characters <code class="code">abc...</code>. Character ranges are specified by a pair of characters separated by a <code class="code">-</code>.</p> </dd> <dt><strong><code class="code">[^abc...]</code></strong></dt> <dd> <p>Negated character class, which matches any character except <code class="code">abc...</code>.</p> </dd> <dt><strong><code class="code">r1 | r2</code></strong></dt> <dd> <p>Alternation. It matches either <code class="code">r1</code> or <code class="code">r2</code>.</p> </dd> <dt><strong><code class="code">r1r2</code></strong></dt> <dd> <p>Concatenation. It matches <code class="code">r1</code> and then <code class="code">r2</code>.</p> </dd> <dt><strong><code class="code">r+</code></strong></dt> <dd> <p>Matches one or more <code class="code">rs</code>.</p> </dd> <dt><strong><code class="code">r*</code></strong></dt> <dd> <p>Matches zero or more <code class="code">rs</code>.</p> </dd> <dt><strong><code class="code">r?</code></strong></dt> <dd> <p>Matches zero or one <code class="code">rs</code>.</p> </dd> <dt><strong><code class="code">(r)</code></strong></dt> <dd> <p>Grouping. It matches <code class="code">r</code>.</p> </dd> </dl> <p>The escape sequences allowed are the same as for Erlang strings:</p> <dl> <dt><strong><code class="code">\b</code></strong></dt> <dd><p>Backspace.</p></dd> <dt><strong><code class="code">\f</code></strong></dt> <dd><p>Form feed.</p></dd> <dt><strong><code class="code">\n</code></strong></dt> <dd><p>Newline (line feed).</p></dd> <dt><strong><code class="code">\r</code></strong></dt> <dd><p>Carriage return.</p></dd> <dt><strong><code class="code">\t</code></strong></dt> <dd><p>Tab.</p></dd> <dt><strong><code class="code">\e</code></strong></dt> <dd><p>Escape.</p></dd> <dt><strong><code class="code">\v</code></strong></dt> <dd><p>Vertical tab.</p></dd> <dt><strong><code class="code">\s</code></strong></dt> <dd><p>Space.</p></dd> <dt><strong><code class="code">\d</code></strong></dt> <dd><p>Delete.</p></dd> <dt><strong><code class="code">\ddd</code></strong></dt> <dd><p>The octal value <code class="code">ddd</code>.</p></dd> <dt><strong><code class="code">\xhh</code></strong></dt> <dd><p>The hexadecimal value <code class="code">hh</code>.</p></dd> <dt><strong><code class="code">\x{h...}</code></strong></dt> <dd><p>The hexadecimal value <code class="code">h...</code>.</p></dd> <dt><strong><code class="code">\c</code></strong></dt> <dd> <p>Any other character literally, for example <code class="code">\\</code> for backslash, <code class="code">\"</code> for <code class="code">"</code>.</p> </dd> </dl> <p>The following examples define Erlang data types:</p> <div class="example"><pre> 
Atoms [a-z][0-9a-zA-Z_]*

Variables [A-Z_][0-9a-zA-Z_]*

Floats (\+|-)?[0-9]+\.[0-9]+((E|e)(\+|-)?[0-9]+)?</pre></div> <div class="note"> <div class="label">Note</div> <div class="content">

<p>Anchoring a regular expression with <code class="code">^</code> and <code class="code">$</code> is not implemented in the current version of Leex and just generates a parse error.</p>
</div> </div>
<div class="_attribution">
  <p class="_attribution-p">
    © 1999–2016 Ericsson AB<br>Licensed under the Apache License, Version 2.0.<br>
    
  </p>
</div>

			</div>
		</div>
	</section>

	</div>
</body>
</html>
