
<!DOCTYPE HTML>

<html lang="en">

<head>
  <meta charset="utf-8">
  <title>Ssh_sftp - Erlang 19 - W3cubDocs</title>
  
  <meta name="description" content=" ssh_sftp ">
  <meta name="keywords" content="ssh, sftp, -, erlang, erlang~19">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="http://docs.w3cub.com/erlang~19/lib/ssh-4.4.1/doc/html/ssh_sftp/">
  <link href="/favicon.png" rel="icon">
  <link type="text/css" rel="stylesheet" href="/assets/application-50364fff564ce3b6327021805f3f00e2957b441cf27f576a7dd4ff63bbc47047.css">
  <script type="text/javascript" src="/assets/application-db64bfd54ceb42be11af7995804cf4902548419ceb79d509b0b7d62c22d98e6f.js"></script>
  <script src="/json/erlang~19.js"></script>
  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-71174418-1']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>


</head>

<body>
	<div class="_app">
	<header class="_header">
  
  <form class="_search">
    <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
    <a class="_search-clear"></a>
    <div class="_search-tag"></div>
  </form>
  
  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/erlang~19/" class="_nav-link" title="" style="margin-left:0;">Erlang 19</a></span>
  
  <nav class="_nav">
    <a href="/app/" class="_nav-link ">App</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		<div class="_list">
			
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<div class="_page _erlang">
				
<h1>ssh_sftp</h1> <h2>Module</h2> <p class="REFBODY">ssh_sftp</p> <h2>Module summary</h2> <p class="REFBODY">SFTP client.</p> <h2>Description</h2> 
<p>This module implements an SSH FTP (SFTP) client. SFTP is a secure, encrypted file transfer service available for SSH.</p>  <h2 id="id76372">Data types</h2>  <p>Type definitions that are used more than once in this module, or abstractions to indicate the intended use of the data type, or both: </p> <dl> <dt><strong><code class="code">reason()</code></strong></dt> <dd> <p>= <code class="code">atom()</code> A description of the reason why an operation failed.</p> <p> The value is formed from the sftp error codes in the protocol-level responses as defined in <code class="bold_code"><a href="https://tools.ietf.org/id/draft-ietf-secsh-filexfer-13.txt" target="_blank">draft-ietf-secsh-filexfer-13.txt</a></code> section 9.1. </p> <p> The codes are named as <code class="code">SSH_FX_*</code> which are transformed into lowercase of the star-part. E.g. the error code <code class="code">SSH_FX_NO_SUCH_FILE</code> will cause the <code class="code">reason()</code> to be <code class="code">no_such_file</code>. </p> </dd> <dt><strong><code class="code">ssh_connection_ref() =</code></strong></dt> <dd><p><code class="code">opaque()</code> - as returned by <code class="bold_code"><a href="../ssh/#connect-3"><span class="code">ssh:connect/3</span></a></code></p></dd> <dt><strong><code class="code">timeout()</code></strong></dt> <dd><p>= <code class="code">infinity | integer()</code> in milliseconds. Default infinity.</p></dd> </dl>  <h2 id="id76466">Time-outs</h2>  <p>If the request functions for the SFTP channel return <code class="code">{error, timeout}</code>, no answer was received from the server within the expected time.</p> <p>The request may have reached the server and may have been performed. However, no answer was received from the server within the expected time.</p>  <h2>Exports</h2> <h3 id="apread-4" class="code">apread(ChannelPid, Handle, Position, Len) -&gt; {async, N} | {error, reason()}</h3>  <p>Types:</p>       <pre>ChannelPid = pid()
Handle = term()
Position = integer()
Len = integer()
N = term()</pre>

<p>The <code class="code">apread/4</code> function reads from a specified position, combining the <code class="bold_code"><a href="#position-3"><span class="code">position/3</span></a></code> and <code class="bold_code"><a href="#aread-3"><span class="code">aread/3</span></a></code> functions.</p>  <h3 id="apwrite-4" class="code">apwrite(ChannelPid, Handle, Position, Data) -&gt; {async, N} | {error, reason()}</h3>  <p>Types:</p>         <pre>ChannelPid = pid()
Handle = term()
Position = integer()
Len = integer()
Data = binary()
Timeout = timeout()
N = term()</pre>

<p>The <code class="code">apwrite/4</code> function writes to a specified position, combining the <code class="bold_code"><a href="#position-3"><span class="code">position/3</span></a></code> and <code class="bold_code"><a href="#awrite-3"><span class="code">awrite/3</span></a></code> functions.</p>  <h3 id="aread-3" class="code">aread(ChannelPid, Handle, Len) -&gt; {async, N} | {error, reason()}</h3>  <p>Types:</p>       <pre>ChannelPid = pid()
Handle = term()
Position = integer()
Len = integer()
N = term()</pre>

<p>Reads from an open file, without waiting for the result. If the handle is valid, the function returns <code class="code">{async, N}</code>, where <code class="code">N</code> is a term guaranteed to be unique between calls of <code class="code">aread</code>. The actual data is sent as a message to the calling process. This message has the form <code class="code">{async_reply, N, Result}</code>, where <code class="code">Result</code> is the result from the read, either <code class="code">{ok, Data}</code>, <code class="code">eof</code>, or <code class="code">{error, reason()}</code>.</p>  <h3 id="awrite-3" class="code">awrite(ChannelPid, Handle, Data) -&gt; {async, N} | {error, reason()}</h3>  <p>Types:</p>        <pre>ChannelPid = pid()
Handle = term()
Position = integer()
Len = integer()
Data = binary()
Timeout = timeout()</pre>

<p>Writes to an open file, without waiting for the result. If the handle is valid, the function returns <code class="code">{async, N}</code>, where <code class="code">N</code> is a term guaranteed to be unique between calls of <code class="code">awrite</code>. The result of the <code class="code">write</code> operation is sent as a message to the calling process. This message has the form <code class="code">{async_reply, N, Result}</code>, where <code class="code">Result</code> is the result from the write, either <code class="code">ok</code>, or <code class="code">{error, reason()}</code>.</p>  <h3 id="close-3" class="code">close(ChannelPid, Handle) -&gt;<br>close(ChannelPid, Handle, Timeout) -&gt; ok | {error, reason()}</h3>  <p>Types:</p>     <pre>ChannelPid = pid()
Handle = term()
Timeout = timeout()</pre>

<p>Closes a handle to an open file or directory on the server.</p>  <h3 id="delete-3" class="code">delete(ChannelPid, Name) -&gt;<br>delete(ChannelPid, Name, Timeout) -&gt; ok | {error, reason()}</h3>  <p>Types:</p>     <pre>ChannelPid = pid()
Name = string()
Timeout = timeout()</pre>

<p>Deletes the file specified by <code class="code">Name</code>. </p>  <h3 id="del_dir-3" class="code">del_dir(ChannelPid, Name) -&gt;<br>del_dir(ChannelPid, Name, Timeout) -&gt; ok | {error, reason()}</h3>  <p>Types:</p>     <pre>ChannelPid = pid()
Name = string()
Timeout = timeout()</pre>

<p>Deletes a directory specified by <code class="code">Name</code>. The directory must be empty before it can be successfully deleted. </p>  <h3 id="list_dir-3" class="code">list_dir(ChannelPid, Path) -&gt;<br>list_dir(ChannelPid, Path, Timeout) -&gt; {ok, Filenames} | {error, reason()}</h3>  <p>Types:</p>       <pre>ChannelPid = pid()
Path = string()
Filenames = [Filename]
Filename = string()
Timeout = timeout()</pre>

<p>Lists the given directory on the server, returning the filenames as a list of strings.</p>  <h3 id="make_dir-3" class="code">make_dir(ChannelPid, Name) -&gt;<br>make_dir(ChannelPid, Name, Timeout) -&gt; ok | {error, reason()}</h3>  <p>Types:</p>     <pre>ChannelPid = pid()
Name = string()
Timeout = timeout()</pre>

<p>Creates a directory specified by <code class="code">Name</code>. <code class="code">Name</code> must be a full path to a new directory. The directory can only be created in an existing directory.</p>  <h3 id="make_symlink-4" class="code">make_symlink(ChannelPid, Name, Target) -&gt;<br>make_symlink(ChannelPid, Name, Target, Timeout) -&gt; ok | {error, reason()}</h3>  <p>Types:</p>     <pre>ChannelPid = pid()
Name = string()
Target = string()</pre>

<p>Creates a symbolic link pointing to <code class="code">Target</code> with the name <code class="code">Name</code>. </p>  <h3 id="open-4" class="code">open(ChannelPid, File, Mode) -&gt;<br>open(ChannelPid, File, Mode, Timeout) -&gt; {ok, Handle} | {error, reason()}</h3>  <p>Types:</p>        <pre>ChannelPid = pid()
File = string()
Mode = [Modeflag]
Modeflag = read | write | creat | trunc | append | binary
Timeout = timeout()
Handle = term()</pre>

<p>Opens a file on the server and returns a handle, which can be used for reading or writing.</p>  <h3 id="opendir-3" class="code">opendir(ChannelPid, Path) -&gt;<br>opendir(ChannelPid, Path, Timeout) -&gt; {ok, Handle} | {error, reason()}</h3>  <p>Types:</p>     <pre>ChannelPid = pid()
Path = string()
Timeout = timeout()</pre>

<p>Opens a handle to a directory on the server. The handle can be used for reading directory contents.</p>  <h3 id="open_tar-4" class="code">open_tar(ChannelPid, Path, Mode) -&gt;<br>open_tar(ChannelPid, Path, Mode, Timeout) -&gt; {ok, Handle} | {error, reason()}</h3>  <p>Types:</p>                  <pre>ChannelPid = pid()
Path = string()
Mode = [read] | [write] | [read,EncryptOpt] | [write,DecryptOpt]
EncryptOpt = {crypto,{InitFun,EncryptFun,CloseFun}}
DecryptOpt = {crypto,{InitFun,DecryptFun}}
InitFun = (fun() -&gt; {ok,CryptoState}) | (fun() -&gt; {ok,CryptoState,ChunkSize})
CryptoState = any()
ChunkSize = undefined | pos_integer()
EncryptFun = (fun(PlainBin,CryptoState) -&gt; EncryptResult)
EncryptResult = {ok,EncryptedBin,CryptoState} | {ok,EncryptedBin,CryptoState,ChunkSize}
PlainBin = binary()
EncryptedBin = binary()
DecryptFun = (fun(EncryptedBin,CryptoState) -&gt; DecryptResult)
DecryptResult = {ok,PlainBin,CryptoState} | {ok,PlainBin,CryptoState,ChunkSize}
CloseFun = (fun(PlainBin,CryptoState) -&gt; {ok,EncryptedBin})
Timeout = timeout()</pre>

<p>Opens a handle to a tar file on the server, associated with <code class="code">ChannelPid</code>. The handle can be used for remote tar creation and extraction, as defined by the <code class="bold_code">erl_tar:init/3</code> function. </p> <p> For code exampel see Section <code class="bold_code"><a href="../using_ssh/">SFTP Client with TAR Compression and Encryption</a></code> in the ssh Users Guide. </p> <p>The <code class="code">crypto</code> mode option is applied to the generated stream of bytes prior to sending them to the SFTP server. This is intended for encryption but can be used for other purposes. </p> <p>The <code class="code">InitFun</code> is applied once prior to any other <code class="code">crypto</code> operation. The returned <code class="code">CryptoState</code> is then folded into repeated applications of the <code class="code">EncryptFun</code> or <code class="code">DecryptFun</code>. The binary returned from those funs are sent further to the remote SFTP server. Finally, if doing encryption, the <code class="code">CloseFun</code> is applied to the last piece of data. The <code class="code">CloseFun</code> is responsible for padding (if needed) and encryption of that last piece. </p> <p>The <code class="code">ChunkSize</code> defines the size of the <code class="code">PlainBin</code>s that <code class="code">EncodeFun</code> is applied to. If the <code class="code">ChunkSize</code> is <code class="code">undefined</code>, the size of the <code class="code">PlainBin</code>s varies, because this is intended for stream crypto, whereas a fixed <code class="code">ChunkSize</code> is intended for block crypto. <code class="code">ChunkSize</code>s can be changed in the return from the <code class="code">EncryptFun</code> or <code class="code">DecryptFun</code>. The value can be changed between <code class="code">pos_integer()</code> and <code class="code">undefined</code>. </p>  <h3 id="position-4" class="code">position(ChannelPid, Handle, Location) -&gt;<br>position(ChannelPid, Handle, Location, Timeout) -&gt; {ok, NewPosition | {error, reason()}</h3>  <p>Types:</p>        <pre>ChannelPid = pid()
Handle = term()
Location = Offset | {bof, Offset} | {cur, Offset} | {eof, Offset} | bof | cur | eof
Offset = integer()
Timeout = timeout()
NewPosition = integer()</pre>

<p>Sets the file position of the file referenced by <code class="code">Handle</code>. Returns <code class="code">{ok, NewPosition}</code> (as an absolute offset) if successful, otherwise <code class="code">{error, reason()}</code>. <code class="code">Location</code> is one of the following:</p> <dl> <dt><strong><code class="code">Offset</code></strong></dt> <dd> <p>The same as <code class="code">{bof, Offset}</code>.</p> </dd> <dt><strong><code class="code">{bof, Offset}</code></strong></dt> <dd> <p>Absolute offset.</p> </dd> <dt><strong><code class="code">{cur, Offset}</code></strong></dt> <dd> <p>Offset from the current position.</p> </dd> <dt><strong><code class="code">{eof, Offset}</code></strong></dt> <dd> <p>Offset from the end of file.</p> </dd> <dt><strong><code class="code">bof | cur | eof</code></strong></dt> <dd> <p>The same as eariler with <code class="code">Offset</code> 0, that is, <code class="code">{bof, 0} | {cur, 0} | {eof, 0}</code>. </p> </dd> </dl>  <h3 id="pread-5" class="code">pread(ChannelPid, Handle, Position, Len) -&gt;<br>pread(ChannelPid, Handle, Position, Len, Timeout) -&gt; {ok, Data} | eof | {error, reason()}</h3>  <p>Types:</p>        <pre>ChannelPid = pid()
Handle = term()
Position = integer()
Len = integer()
Timeout = timeout()
Data = string() | binary()</pre>

<p>The <code class="code">pread/3,4</code> function reads from a specified position, combining the <code class="bold_code"><a href="#position-3"><span class="code">position/3</span></a></code> and <code class="bold_code"><a href="#read-3"><span class="code">read/3,4</span></a></code> functions.</p>  <h3 id="pwrite-5" class="code">pwrite(ChannelPid, Handle, Position, Data) -&gt; ok<br>pwrite(ChannelPid, Handle, Position, Data, Timeout) -&gt; ok | {error, reason()}</h3>  <p>Types:</p>       <pre>ChannelPid = pid()
Handle = term()
Position = integer()
Data = iolist()
Timeout = timeout()</pre>

<p>The <code class="code">pwrite/3,4</code> function writes to a specified position, combining the <code class="bold_code"><a href="#position-3"><span class="code">position/3</span></a></code> and <code class="bold_code"><a href="#write-3"><span class="code">write/3,4</span></a></code> functions.</p>  <h3 id="read-4" class="code">read(ChannelPid, Handle, Len) -&gt;<br>read(ChannelPid, Handle, Len, Timeout) -&gt; {ok, Data} | eof | {error, reason()}</h3>  <p>Types:</p>        <pre>ChannelPid = pid()
Handle = term()
Position = integer()
Len = integer()
Timeout = timeout()
Data = string() | binary()</pre>

<p>Reads <code class="code">Len</code> bytes from the file referenced by <code class="code">Handle</code>. Returns <code class="code">{ok, Data}</code>, <code class="code">eof</code>, or <code class="code">{error, reason()}</code>. If the file is opened with <code class="code">binary</code>, <code class="code">Data</code> is a binary, otherwise it is a string.</p> <p>If the file is read past <code class="code">eof</code>, only the remaining bytes are read and returned. If no bytes are read, <code class="code">eof</code> is returned.</p>  <h3 id="read_file-3" class="code">read_file(ChannelPid, File) -&gt;<br>read_file(ChannelPid, File, Timeout) -&gt; {ok, Data} | {error, reason()}</h3>  <p>Types:</p>      <pre>ChannelPid = pid()
File = string()
Data = binary()
Timeout = timeout()</pre>

<p>Reads a file from the server, and returns the data in a binary.</p>  <h3 id="read_file_info-3" class="code">read_file_info(ChannelPid, Name) -&gt;<br>read_file_info(ChannelPid, Name, Timeout) -&gt; {ok, FileInfo} | {error, reason()}</h3>  <p>Types:</p>       <pre>ChannelPid = pid()
Name = string()
Handle = term()
Timeout = timeout()
FileInfo = record()</pre>

<p>Returns a <code class="code">file_info</code> record from the file specified by <code class="code">Name</code> or <code class="code">Handle</code>. See <code class="bold_code">file:read_file_info/2</code> for information about the record. </p>  <h3 id="read_link-3" class="code">read_link(ChannelPid, Name) -&gt;<br>read_link(ChannelPid, Name, Timeout) -&gt; {ok, Target} | {error, reason()}</h3>  <p>Types:</p>     <pre>ChannelPid = pid()
Name = string()
Target = string()</pre>

<p>Reads the link target from the symbolic link specified by <code class="code">name</code>. </p>  <h3 id="read_link_info-3" class="code">read_link_info(ChannelPid, Name) -&gt; {ok, FileInfo} | {error, reason()}<br>read_link_info(ChannelPid, Name, Timeout) -&gt; {ok, FileInfo} | {error, reason()}</h3>  <p>Types:</p>       <pre>ChannelPid = pid()
Name = string()
Handle = term()
Timeout = timeout()
FileInfo = record()</pre>

<p>Returns a <code class="code">file_info</code> record from the symbolic link specified by <code class="code">Name</code> or <code class="code">Handle</code>. See <code class="bold_code">file:read_link_info/2</code> for information about the record. </p>  <h3 id="rename-4" class="code">rename(ChannelPid, OldName, NewName) -&gt;<br>rename(ChannelPid, OldName, NewName, Timeout) -&gt; ok | {error, reason()}</h3>  <p>Types:</p>      <pre>ChannelPid = pid()
OldName = string()
NewName = string()
Timeout = timeout()</pre>

<p>Renames a file named <code class="code">OldName</code> and gives it the name <code class="code">NewName</code>. </p>  <h3 id="start_channel-2" class="code">start_channel(ConnectionRef) -&gt;<br>start_channel(ConnectionRef, Options) -&gt; {ok, Pid} | {error, reason()|term()}<br>start_channel(Host, Options) -&gt;<br>start_channel(Host, Port, Options) -&gt; {ok, Pid, ConnectionRef} | {error, reason()|term()}<br>start_channel(TcpSocket) -&gt;<br>start_channel(TcpSocket, Options) -&gt; {ok, Pid, ConnectionRef} | {error, reason()|term()}</h3>  <p>Types:</p>     The socket is supposed to be from <pre>Host = string()
ConnectionRef = ssh_connection_ref()
Port = integer()
TcpSocket = port()</pre>
<code class="bold_code">gen_tcp:connect</code> or <code class="bold_code">gen_tcp:accept</code> with option <code class="code">{active,false}</code>    <pre>Options = [{Option, Value}]</pre>

<p>If no connection reference is provided, a connection is set up, and the new connection is returned. An SSH channel process is started to handle the communication with the SFTP server. The returned <code class="code">pid</code> for this process is to be used as input to all other API functions in this module.</p> <p>Options:</p> <dl> <dt><strong><code class="code">{timeout, timeout()}</code></strong></dt> <dd> <p>The time-out is passed to the <code class="code">ssh_channel</code> start function, and defaults to <code class="code">infinity</code>.</p> </dd> <dt><strong> <code class="code">{sftp_vsn, integer()}</code> </strong></dt> <dd> <p> Desired SFTP protocol version. The actual version is the minimum of the desired version and the maximum supported versions by the SFTP server. </p> </dd> </dl> <p>All other options are directly passed to <code class="bold_code"><a href="../ssh/">ssh:connect/3</a></code> or ignored if a connection is already provided.</p>  <h3 id="stop_channel-1" class="code">stop_channel(ChannelPid) -&gt; ok</h3>  <p>Types:</p>   <pre>ChannelPid = pid()</pre>

<p>Stops an SFTP channel. Does not close the SSH connection. Use <code class="bold_code"><a href="../ssh/#close-1">ssh:close/1</a></code> to close it.</p>  <h3 id="write-4" class="code">write(ChannelPid, Handle, Data) -&gt;<br>write(ChannelPid, Handle, Data, Timeout) -&gt; ok | {error, reason()}</h3>  <p>Types:</p>       <pre>ChannelPid = pid()
Handle = term()
Position = integer()
Data = iolist()
Timeout = timeout()</pre>

<p>Writes <code class="code">data</code> to the file referenced by <code class="code">Handle</code>. The file is to be opened with <code class="code">write</code> or <code class="code">append</code> flag. Returns <code class="code">ok</code> if successful or <code class="code">{error, reason()}</code> otherwise.</p>  <h3 id="write_file-4" class="code">write_file(ChannelPid, File, Iolist) -&gt;<br>write_file(ChannelPid, File, Iolist, Timeout) -&gt; ok | {error, reason()}</h3>  <p>Types:</p>      <pre>ChannelPid = pid()
File = string()
Iolist = iolist()
Timeout = timeout()</pre>

<p>Writes a file to the server. The file is created if it does not exist but overwritten if it exists.</p>  <h3 id="write_file_info-4" class="code">write_file_info(ChannelPid, Name, Info) -&gt;<br>write_file_info(ChannelPid, Name, Info, Timeout) -&gt; ok | {error, reason()}</h3>  <p>Types:</p>      <pre>ChannelPid = pid()
Name = string()
Info = record()
Timeout = timeout()</pre>

<p>Writes file information from a <code class="code">file_info</code> record to the file specified by <code class="code">Name</code>. See <code class="bold_code">file:write_file_info/[2,3]</code> for information about the record. </p>
<div class="_attribution">
  <p class="_attribution-p">
    © 1999–2016 Ericsson AB<br>Licensed under the Apache License, Version 2.0.<br>
    
  </p>
</div>

			</div>
		</div>
	</section>

	</div>
</body>
</html>
