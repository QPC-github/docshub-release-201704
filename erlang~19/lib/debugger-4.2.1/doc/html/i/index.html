
<!DOCTYPE HTML>

<html lang="en">

<head>
  <meta charset="utf-8">
  <title>I - Erlang 19 - W3cubDocs</title>
  
  <meta name="description" content=" i ">
  <meta name="keywords" content="i, -, erlang, erlang~19">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="http://docs.w3cub.com/erlang~19/lib/debugger-4.2.1/doc/html/i/">
  <link href="/favicon.png" rel="icon">
  <link type="text/css" rel="stylesheet" href="/assets/application-50364fff564ce3b6327021805f3f00e2957b441cf27f576a7dd4ff63bbc47047.css">
  <script type="text/javascript" src="/assets/application-db64bfd54ceb42be11af7995804cf4902548419ceb79d509b0b7d62c22d98e6f.js"></script>
  <script src="/json/erlang~19.js"></script>
  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-71174418-1']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>


</head>

<body>
	<div class="_app">
	<header class="_header">
  
  <form class="_search">
    <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
    <a class="_search-clear"></a>
    <div class="_search-tag"></div>
  </form>
  
  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/erlang~19/" class="_nav-link" title="" style="margin-left:0;">Erlang 19</a></span>
  
  <nav class="_nav">
    <a href="/app/" class="_nav-link ">App</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		<div class="_list">
			
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<div class="_page _erlang">
				
<h1>i</h1> <h2>Module</h2> <p class="REFBODY">i</p> <h2>Module summary</h2> <p class="REFBODY">Debugger/Interpreter Interface.</p> <h2>Description</h2> 
<p>The <code class="code">i</code> module provides short forms for some of the functions used by the graphical Debugger and some of the functions in module <code class="bold_code"><a href="../int/"><span class="code">int</span></a></code>, the Erlang interpreter.</p> <p>This module also provides facilities for displaying status information about interpreted processes and break points.</p> <p>It is possible to attach to interpreted processes by giving the corresponding process identity only. By default, an attachment window is displayed. Processes at other Erlang nodes can be attached manually or automatically.</p> <p>By preference, these functions can be included in module <code class="bold_code"><span class="code">shell_default</span></code>. By default, they are included in that module.</p>  <h2>Exports</h2> <h3 id="im-0" class="code">im() -&gt; pid()</h3> 
<p>Starts a new graphical monitor. This is the Monitor window, the main window of Debugger. All the Debugger and interpreter functionality is accessed from the Monitor window. This window displays the status of all processes that have been or are executing interpreted modules.</p>  <h3 id="ini-1" class="code">ii(AbsModules) -&gt; ok<br>ii(AbsModule) -&gt; {module, Module} | error<br>ini(AbsModules) -&gt; ok<br>ini(AbsModule) -&gt; {module, Module} | error</h3>  <p>Types:</p>      <pre>AbsModules = [AbsModule]
AbsModule = Module | File
 Module = atom()
 File = string()</pre>

<p>Interprets the specified module(s). <code class="code">ii/1</code> interprets the module(s) only at the current node, see <code class="bold_code"><a href="../int/#i-1">int:i/1</a></code>. <code class="code">ini/1</code> interprets the module(s) at all known nodes, see <code class="bold_code"><a href="../int/#ni-1">int:ni/1</a></code>.</p>  <h3 id="inq-1" class="code">iq(AbsModule) -&gt; ok<br>inq(AbsModule) -&gt; ok</h3>  <p>Types:</p>     <pre>AbsModule = Module | File
 Module = atom()
 File = string()</pre>

<p>Stops interpreting the specified module. <code class="code">iq/1</code> stops interpreting the module only at the current node. <code class="code">inq/1</code> stops interpreting the module at all known nodes.</p>  <h3 id="il-0" class="code">il() -&gt; ok</h3> 
<p>Makes a printout of all interpreted modules. Modules are printed together with the full path name of the corresponding source code file.</p>  <h3 id="ip-0" class="code">ip() -&gt; ok</h3> 
<p>Prints the current status of all interpreted processes.</p>  <h3 id="ic-0" class="code">ic() -&gt; ok</h3> 
<p>Clears information about processes executing interpreted code by removing all information about terminated processes.</p>  <h3 id="iaa-2" class="code">iaa(Flags) -&gt; true<br>iaa(Flags, Function) -&gt; true</h3>  <p>Types:</p>      <pre>Flags = [init | break | exit]
Function = {Module,Name,Args}
 Module = Name = atom()
 Args = [term()]</pre>

<p>Sets when and how to attach to a debugged process automatically, see <code class="bold_code"><a href="../int/#auto_attach-0">int:auto_attach/2</a></code>. <code class="code">Function</code> defaults to the standard function used by Debugger.</p>  <h3 id="ist-1" class="code">ist(Flag) -&gt; true</h3>  <p>Types:</p>   <pre>Flag = all | no_tail | false</pre>

<p>Sets how to save call frames in the stack, see <code class="bold_code"><a href="../int/#stack_trace-0">int:stack_trace/1</a></code>.</p>  <h3 id="ia-1" class="code">ia(Pid) -&gt; ok | no_proc</h3>  <p>Types:</p>   <pre>Pid = pid()</pre>

<p>Attaches to the debugged process <code class="code">Pid</code>. An Attach Process window is opened for the process.</p>  <h3 id="ia-3" class="code">ia(X,Y,Z) -&gt; ok | no_proc</h3>  <p>Types:</p>   <pre>X = Y = Z = int()</pre>

<p>Same as <code class="code">ia(Pid)</code>, where <code class="code">Pid</code> is the result of calling the shell function <code class="code">pid(X,Y,Z)</code>.</p>  <h3 id="ia-2" class="code">ia(Pid, Function) -&gt; ok | no_proc</h3>  <p>Types:</p>     <pre>Pid = pid()
Function = {Module,Name}
 Module = Name = atom()</pre>

<p>Attaches to the debugged process <code class="code">Pid</code>. The interpreter calls <code class="code">spawn(Module, Name, [Pid])</code> (and ignores the result).</p>  <h3 id="ia-4" class="code">ia(X,Y,Z, Function) -&gt; ok | no_proc</h3>  <p>Types:</p>     <pre>X = Y = Z = int()
Function = {Module,Name}
 Module = Name = atom()</pre>

<p>Same as <code class="code">ia(Pid, Function)</code>, where <code class="code">Pid</code> is the result of calling the shell function <code class="code">pid(X,Y,Z)</code>. An attached process is expected to call the unofficial function <code class="code">int:attached(Pid)</code> and to be able to handle messages from the interpreter. For an example, see <code class="code">dbg_wx_trace.erl</code>.</p>  <h3 id="ib-2" class="code">ib(Module, Line) -&gt; ok | {error, break_exists}</h3>  <p>Types:</p>    <pre>Module = atom()
Line = int()</pre>

<p>Creates a breakpoint at <code class="code">Line</code> in <code class="code">Module</code>.</p>  <h3 id="ib-3" class="code">ib(Module, Name, Arity) -&gt; ok | {error, function_not_found}</h3>  <p>Types:</p>    <pre>Module = Name = atom()
Arity = int()</pre>

<p>Creates breakpoints at the first line of every clause of function <code class="code">Module:Name/Arity</code>.</p>  <h3 id="ir-0" class="code">ir() -&gt; ok</h3> 
<p>Deletes all breakpoints.</p>  <h3 id="ir-1" class="code">ir(Module) -&gt; ok</h3>  <p>Types:</p>   <pre>Module = atom()</pre>

<p>Deletes all breakpoints in <code class="code">Module</code>.</p>  <h3 id="ir-2" class="code">ir(Module, Line) -&gt; ok</h3>  <p>Types:</p>    <pre>Module = atom()
Line = int()</pre>

<p>Deletes the breakpoint at <code class="code">Line</code> in <code class="code">Module</code>.</p>  <h3 id="ir-3" class="code">ir(Module, Name, Arity) -&gt; ok | {error, function_not_found}</h3>  <p>Types:</p>    <pre>Module = Name = atom()
Arity = int()</pre>

<p>Deletes the breakpoints at the first line of every clause of function <code class="code">Module:Name/Arity</code>.</p>  <h3 id="ibd-2" class="code">ibd(Module, Line) -&gt; ok</h3>  <p>Types:</p>    <pre>Module = atom()
Line = int()</pre>

<p>Makes the breakpoint at <code class="code">Line</code> in <code class="code">Module</code> inactive.</p>  <h3 id="ibe-2" class="code">ibe(Module, Line) -&gt; ok</h3>  <p>Types:</p>    <pre>Module = atom()
Line = int()</pre>

<p>Makes the breakpoint at <code class="code">Line</code> in <code class="code">Module</code> active.</p>  <h3 id="iba-3" class="code">iba(Module, Line, Action) -&gt; ok</h3>  <p>Types:</p>     <pre>Module = atom()
Line = int()
Action = enable | disable | delete</pre>

<p>Sets the trigger action of the breakpoint at <code class="code">Line</code> in <code class="code">Module</code> to <code class="code">Action</code>.</p>  <h3 id="ibc-3" class="code">ibc(Module, Line, Function) -&gt; ok</h3>  <p>Types:</p>      <pre>Module = atom()
Line = int()
Function = {Module,Name}
 Name = atom()</pre>

<p>Sets the conditional test of the breakpoint at <code class="code">Line</code> in <code class="code">Module</code> to <code class="code">Function</code>.</p> <p>The conditional test is performed by calling <code class="code">Module:Name(Bindings)</code>, where <code class="code">Bindings</code> is the current variable bindings. The function must return <code class="code">true</code> (break) or <code class="code">false</code> (do not break). To retrieve the value of a variable <code class="code">Var</code>, use <code class="bold_code"><a href="../int/#get_binding-2">int:get_binding(Var, Bindings)</a></code>.</p>  <h3 id="ipb-0" class="code">ipb() -&gt; ok</h3> 
<p>Prints all existing breakpoints.</p>  <h3 id="ipb-1" class="code">ipb(Module) -&gt; ok</h3>  <p>Types:</p>   <pre>Module = atom()</pre>

<p>Prints all existing breakpoints in <code class="code">Module</code>.</p>  <h3 id="iv-0" class="code">iv() -&gt; atom()</h3> 
<p>Returns the current version number of the interpreter. Same as the version number of the Debugger application.</p>  <h3 id="help-0" class="code">help() -&gt; ok</h3> 
<p>Prints help text.</p>  <h2 id="id62610">See Also</h2>  <p><code class="bold_code"><a href="../int/"><span class="code">int(3)</span></a></code></p>
<div class="_attribution">
  <p class="_attribution-p">
    © 1999–2016 Ericsson AB<br>Licensed under the Apache License, Version 2.0.<br>
    
  </p>
</div>

			</div>
		</div>
	</section>

	</div>
</body>
</html>
