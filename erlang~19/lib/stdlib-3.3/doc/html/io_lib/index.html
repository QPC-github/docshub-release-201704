
<!DOCTYPE HTML>

<html lang="en">

<head>
  <meta charset="utf-8">
  <title>Io_lib - Erlang 19 - W3cubDocs</title>
  
  <meta name="description" content=" io_lib ">
  <meta name="keywords" content="io, lib, -, erlang, erlang~19">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="http://docs.w3cub.com/erlang~19/lib/stdlib-3.3/doc/html/io_lib/">
  <link href="/favicon.png" rel="icon">
  <link type="text/css" rel="stylesheet" href="/assets/application-50364fff564ce3b6327021805f3f00e2957b441cf27f576a7dd4ff63bbc47047.css">
  <script type="text/javascript" src="/assets/application-db64bfd54ceb42be11af7995804cf4902548419ceb79d509b0b7d62c22d98e6f.js"></script>
  <script src="/json/erlang~19.js"></script>
  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-71174418-1']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>


</head>

<body>
	<div class="_app">
	<header class="_header">
  
  <form class="_search">
    <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
    <a class="_search-clear"></a>
    <div class="_search-tag"></div>
  </form>
  
  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/erlang~19/" class="_nav-link" title="" style="margin-left:0;">Erlang 19</a></span>
  
  <nav class="_nav">
    <a href="/app/" class="_nav-link ">App</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		<div class="_list">
			
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<div class="_page _erlang">
				
<h1>io_lib</h1> <h2>Module</h2> <p class="REFBODY">io_lib</p> <h2>Module summary</h2> <p class="REFBODY">I/O library functions.</p> <h2>Description</h2> 
<p>This module contains functions for converting to and from strings (lists of characters). They are used for implementing the functions in the <code class="bold_code"><a href="../io/"><span class="code">io</span></a></code> module. There is no guarantee that the character lists returned from some of the functions are flat, they can be deep lists. Function <code class="bold_code"><a href="../lists/#flatten-1"><span class="code">lists:flatten/1</span></a></code> can be used for flattening deep lists.</p>  <h2>Data types</h2> <h3 class="code">chars() = [char() | <a href="#type-chars">chars()</a>]</h3> <h3 class="code">continuation()</h3> 
<p>A continuation as returned by <code class="bold_code"><a href="#fread-3"><span class="code">fread/3</span></a></code>.</p>  <h3 class="code">depth() = -1 | integer() &gt;= 0</h3> <h3 class="code">fread_error() = <br>    atom |<br>    based |<br>    character |<br>    float |<br>    format |<br>    input |<br>    integer |<br>    string |<br>    unsigned</h3> <h3 class="code">fread_item() = string() | atom() | integer() | float()</h3> <h3 class="code">latin1_string() = [<a href="../unicode/#type-latin1_char">unicode:latin1_char()</a>]</h3> <h3 class="code">format_spec() = <br>    #{control_char := char(),<br>      args := [any()],<br>      width := none | integer(),<br>      adjust := left | right,<br>      precision := none | integer(),<br>      pad_char := char(),<br>      encoding := unicode | latin1,<br>      strings := boolean()}</h3> 
<p>Where:</p> <ul> <li> <p><code class="code">control_char</code> is the type of control sequence: <code class="code">$P</code>, <code class="code">$w</code>, and so on.</p> </li> <li> <p><code class="code">args</code> is a list of the arguments used by the control sequence, or an empty list if the control sequence does not take any arguments.</p> </li> <li> <p><code class="code">width</code> is the field width.</p> </li> <li> <p><code class="code">adjust</code> is the adjustment.</p> </li> <li> <p><code class="code">precision</code> is the precision of the printed argument.</p> </li> <li> <p><code class="code">pad_char</code> is the padding character.</p> </li> <li> <p><code class="code">encoding</code> is set to <code class="code">true</code> if translation modifier <code class="code">t</code> is present.</p> </li> <li> <p><code class="code">strings</code> is set to <code class="code">false</code> if modifier <code class="code">l</code> is present.</p> </li> </ul>  <h2>Exports</h2> <h3 id="build_text-1" class="code">build_text(FormatList) -&gt; <a href="#type-chars">chars()</a>
</h3> <p>Types:</p>   <pre>FormatList = [char() | <a href="#type-format_spec">format_spec()</a>]</pre>

<p>For details, see <code class="bold_code"><a href="#scan_format-2"><span class="code">scan_format/2</span></a></code>.</p>  <h3 id="char_list-1" class="code">char_list(Term) -&gt; boolean()</h3> <p>Types:</p>   <pre>Term = term()</pre>

<p>Returns <code class="code">true</code> if <code class="code">Term</code> is a flat list of characters in the Unicode range, otherwise <code class="code">false</code>.</p>  <h3 id="deep_char_list-1" class="code">deep_char_list(Term) -&gt; boolean()</h3> <p>Types:</p>   <pre>Term = term()</pre>

<p>Returns <code class="code">true</code> if <code class="code">Term</code> is a, possibly deep, list of characters in the Unicode range, otherwise <code class="code">false</code>.</p>  <h3 id="deep_latin1_char_list-1" class="code">deep_latin1_char_list(Term) -&gt; boolean()</h3> <p>Types:</p>   <pre>Term = term()</pre>

<p>Returns <code class="code">true</code> if <code class="code">Term</code> is a, possibly deep, list of characters in the ISO Latin-1 range, otherwise <code class="code">false</code>.</p>  <h3 id="fwrite-2" class="code">format(Format, Data) -&gt; <a href="#type-chars">chars()</a><br>fwrite(Format, Data) -&gt; <a href="#type-chars">chars()</a>
</h3> <p>Types:</p>    <pre>Format = <a href="../io/#type-format">io:format()</a>
Data = [term()]</pre>

<p>Returns a character list that represents <code class="code">Data</code> formatted in accordance with <code class="code">Format</code>. For a detailed description of the available formatting options, see <code class="bold_code"><a href="../io/#fwrite-1"><span class="code">io:fwrite/1,2,3</span></a></code>. If the format string or argument list contains an error, a fault is generated.</p> <p>If and only if the Unicode translation modifier is used in the format string (that is, <code class="code">~ts</code> or <code class="code">~tc</code>), the resulting list can contain characters beyond the ISO Latin-1 character range (that is, numbers &gt; 255). If so, the result is not an ordinary Erlang <code class="code">string()</code>, but can well be used in any context where Unicode data is allowed.</p>  <h3 id="fread-2" class="code">fread(Format, String) -&gt; Result</h3> <p>Types:</p>     <pre>Format = String = string()

Result = 
    {ok, InputList :: [<a href="#type-fread_item">fread_item()</a>], LeftOverChars :: string()} |
    {more,
     RestFormat :: string(),
     Nchars :: integer() &gt;= 0,
     InputStack :: <a href="#type-chars">chars()</a>} |
    {error, {fread, What :: <a href="#type-fread_error">fread_error()</a>}}</pre>

<p>Tries to read <code class="code">String</code> in accordance with the control sequences in <code class="code">Format</code>. For a detailed description of the available formatting options, see <code class="bold_code"><a href="../io/#fread-3"><span class="code">io:fread/3</span></a></code>. It is assumed that <code class="code">String</code> contains whole lines.</p> <p>The function returns:</p> <dl> <dt><strong><code class="code">{ok, InputList, LeftOverChars}</code></strong></dt> <dd> <p>The string was read. <code class="code">InputList</code> is the list of successfully matched and read items, and <code class="code">LeftOverChars</code> are the input characters not used.</p> </dd> <dt><strong><code class="code">{more, RestFormat, Nchars, InputStack}</code></strong></dt> <dd> <p>The string was read, but more input is needed to complete the original format string. <code class="code">RestFormat</code> is the remaining format string, <code class="code">Nchars</code> is the number of characters scanned, and <code class="code">InputStack</code> is the reversed list of inputs matched up to that point.</p> </dd> <dt><strong><code class="code">{error, What}</code></strong></dt> <dd> <p>The read operation failed and parameter <code class="code">What</code> gives a hint about the error.</p> </dd> </dl> <p><strong>Example:</strong></p> <div class="example"><pre>
3&gt; io_lib:fread("~f~f~f", "15.6 17.3e-6 24.5").
{ok,[15.6,1.73e-5,24.5],[]}</pre></div>  <h3 id="fread-3" class="code">fread(Continuation, CharSpec, Format) -&gt; Return</h3> <p>Types:</p>       <pre>Continuation = <a href="#type-continuation">continuation()</a> | []
CharSpec = string() | eof
Format = string()
Return = 
    {more, Continuation1 :: <a href="#type-continuation">continuation()</a>} |
    {done, Result, LeftOverChars :: string()}
Result = 
    {ok, InputList :: [<a href="#type-fread_item">fread_item()</a>]} |
    eof |
    {error, {fread, What :: <a href="#type-fread_error">fread_error()</a>}}</pre>

<p>This is the re-entrant formatted reader. The continuation of the first call to the functions must be <code class="code">[]</code>. For a complete description of how the re-entrant input scheme works, see Armstrong, Virding, Williams: 'Concurrent Programming in Erlang', Chapter 13.</p> <p>The function returns:</p> <dl> <dt><strong><code class="code">{done, Result, LeftOverChars}</code></strong></dt> <dd> <p>The input is complete. The result is one of the following:</p> <dl> <dt><strong><code class="code">{ok, InputList}</code></strong></dt> <dd> <p>The string was read. <code class="code">InputList</code> is the list of successfully matched and read items, and <code class="code">LeftOverChars</code> are the remaining characters.</p> </dd> <dt><strong><code class="code">eof</code></strong></dt> <dd> <p>End of file was encountered. <code class="code">LeftOverChars</code> are the input characters not used.</p> </dd> <dt><strong><code class="code">{error, What}</code></strong></dt> <dd> <p>An error occurred and parameter <code class="code">What</code> gives a hint about the error.</p> </dd> </dl> </dd> <dt><strong><code class="code">{more, Continuation}</code></strong></dt> <dd> <p>More data is required to build a term. <code class="code">Continuation</code> must be passed to <code class="code">fread/3</code> when more data becomes available.</p> </dd> </dl>  <h3 id="indentation-2" class="code">indentation(String, StartIndent) -&gt; integer()</h3> <p>Types:</p>    <pre>String = string()
StartIndent = integer()</pre>

<p>Returns the indentation if <code class="code">String</code> has been printed, starting at <code class="code">StartIndent</code>.</p>  <h3 id="latin1_char_list-1" class="code">latin1_char_list(Term) -&gt; boolean()</h3> <p>Types:</p>   <pre>Term = term()</pre>

<p>Returns <code class="code">true</code> if <code class="code">Term</code> is a flat list of characters in the ISO Latin-1 range, otherwise <code class="code">false</code>.</p>  <h3 id="nl-0" class="code">nl() -&gt; string()</h3> 
<p>Returns a character list that represents a new line character.</p>  <h3 id="print-4" class="code">print(Term) -&gt; <a href="#type-chars">chars()</a><br>print(Term, Column, LineLength, Depth) -&gt; <a href="#type-chars">chars()</a>
</h3> <p>Types:</p>      <pre>Term = term()
Column = LineLength = integer() &gt;= 0

Depth = <a href="#type-depth">depth()</a></pre>

<p>Returns a list of characters that represents <code class="code">Term</code>, but breaks representations longer than one line into many lines and indents each line sensibly. Also tries to detect and output lists of printable characters as strings.</p> <ul> <li> <code class="code">Column</code> is the starting column; defaults to 1.</li> <li> <code class="code">LineLength</code> is the maximum line length; defaults to 80.</li> <li> <code class="code">Depth</code> is the maximum print depth; defaults to -1, which means no limitation.</li> </ul>  <h3 id="printable_latin1_list-1" class="code">printable_latin1_list(Term) -&gt; boolean()</h3> <p>Types:</p>   <pre>Term = term()</pre>

<p>Returns <code class="code">true</code> if <code class="code">Term</code> is a flat list of printable ISO Latin-1 characters, otherwise <code class="code">false</code>.</p>  <h3 id="printable_list-1" class="code">printable_list(Term) -&gt; boolean()</h3> <p>Types:</p>   <pre>Term = term()</pre>

<p>Returns <code class="code">true</code> if <code class="code">Term</code> is a flat list of printable characters, otherwise <code class="code">false</code>.</p> <p>What is a printable character in this case is determined by startup flag <code class="code">+pc</code> to the Erlang VM; see <code class="bold_code"><a href="../io/#printable_range-0"><span class="code">io:printable_range/0</span></a></code> and <code class="bold_code"><span class="code">erl(1)</span></code>.</p>  <h3 id="printable_unicode_list-1" class="code">printable_unicode_list(Term) -&gt; boolean()</h3> <p>Types:</p>   <pre>Term = term()</pre>

<p>Returns <code class="code">true</code> if <code class="code">Term</code> is a flat list of printable Unicode characters, otherwise <code class="code">false</code>.</p>  <h3 id="scan_format-2" class="code">scan_format(Format, Data) -&gt; FormatList</h3> <p>Types:</p>     <pre>Format = <a href="../io/#type-format">io:format()</a>
Data = [term()]
FormatList = [char() | <a href="#type-format_spec">format_spec()</a>]</pre>

<p>Returns a list corresponding to the specified format string, where control sequences have been replaced with corresponding tuples. This list can be passed to:</p> <ul> <li> <p><code class="bold_code"><a href="#build_text-1"><span class="code">build_text/1</span></a></code> to have the same effect as <code class="code">format(Format, Args)</code></p> </li> <li> <p><code class="bold_code"><a href="#unscan_format-1"><span class="code">unscan_format/1</span></a></code> to get the corresponding pair of <code class="code">Format</code> and <code class="code">Args</code> (with every <code class="code">*</code> and corresponding argument expanded to numeric values)</p> </li> </ul> <p>A typical use of this function is to replace unbounded-size control sequences like <code class="code">~w</code> and <code class="code">~p</code> with the depth-limited variants <code class="code">~W</code> and <code class="code">~P</code> before formatting to text in, for example, a logger.</p>  <h3 id="unscan_format-1" class="code">unscan_format(FormatList) -&gt; {Format, Data}</h3> <p>Types:</p>     <pre>FormatList = [char() | <a href="#type-format_spec">format_spec()</a>]
Format = <a href="../io/#type-format">io:format()</a>
Data = [term()]</pre>

<p>For details, see <code class="bold_code"><a href="#scan_format-2"><span class="code">scan_format/2</span></a></code>.</p>  <h3 id="write-2" class="code">write(Term) -&gt; <a href="#type-chars">chars()</a><br>write(Term, Depth) -&gt; <a href="#type-chars">chars()</a>
</h3> <p>Types:</p>    <pre>Term = term()
Depth = <a href="#type-depth">depth()</a></pre>

<p>Returns a character list that represents <code class="code">Term</code>. Argument <code class="code">Depth</code> controls the depth of the structures written. When the specified depth is reached, everything below this level is replaced by "<code class="code">...</code>". <code class="code">Depth</code> defaults to -1, which means no limitation.</p> <p><strong>Example:</strong></p> <div class="example"><pre>
1&gt; lists:flatten(io_lib:write({1,[2],[3],[4,5],6,7,8,9})).
"{1,[2],[3],[4,5],6,7,8,9}"
2&gt; lists:flatten(io_lib:write({1,[2],[3],[4,5],6,7,8,9}, 5)).
"{1,[2],[3],[...],...}"</pre></div>  <h3 id="write_atom-1" class="code">write_atom(Atom) -&gt; <a href="#type-chars">chars()</a>
</h3> <p>Types:</p>   <pre>Atom = atom()</pre>

<p>Returns the list of characters needed to print atom <code class="code">Atom</code>.</p>  <h3 id="write_char-1" class="code">write_char(Char) -&gt; <a href="#type-chars">chars()</a>
</h3> <p>Types:</p>   <pre>Char = char()</pre>

<p>Returns the list of characters needed to print a character constant in the Unicode character set.</p>  <h3 id="write_char_as_latin1-1" class="code">write_char_as_latin1(Char) -&gt; <a href="#type-latin1_string">latin1_string()</a>
</h3> <p>Types:</p>   <pre>Char = char()</pre>

<p>Returns the list of characters needed to print a character constant in the Unicode character set. Non-Latin-1 characters are escaped.</p>  <h3 id="write_latin1_char-1" class="code">write_latin1_char(Latin1Char) -&gt; <a href="#type-latin1_string">latin1_string()</a>
</h3> <p>Types:</p>   <pre>Latin1Char = <a href="../unicode/#type-latin1_char">unicode:latin1_char()</a></pre>

<p>Returns the list of characters needed to print a character constant in the ISO Latin-1 character set.</p>  <h3 id="write_latin1_string-1" class="code">write_latin1_string(Latin1String) -&gt; <a href="#type-latin1_string">latin1_string()</a>
</h3> <p>Types:</p>   <pre>Latin1String = <a href="#type-latin1_string">latin1_string()</a></pre>

<p>Returns the list of characters needed to print <code class="code">Latin1String</code> as a string.</p>  <h3 id="write_string-1" class="code">write_string(String) -&gt; <a href="#type-chars">chars()</a>
</h3> <p>Types:</p>   <pre>String = string()</pre>

<p>Returns the list of characters needed to print <code class="code">String</code> as a string.</p>  <h3 id="write_string_as_latin1-1" class="code">write_string_as_latin1(String) -&gt; <a href="#type-latin1_string">latin1_string()</a>
</h3> <p>Types:</p>   <pre>String = string()</pre>

<p>Returns the list of characters needed to print <code class="code">String</code> as a string. Non-Latin-1 characters are escaped.</p>
<div class="_attribution">
  <p class="_attribution-p">
    © 1999–2016 Ericsson AB<br>Licensed under the Apache License, Version 2.0.<br>
    
  </p>
</div>

			</div>
		</div>
	</section>

	</div>
</body>
</html>
