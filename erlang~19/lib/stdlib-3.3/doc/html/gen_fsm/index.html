
<!DOCTYPE HTML>

<html lang="en">

<head>
  <meta charset="utf-8">
  <title>Gen_fsm - Erlang 19 - W3cubDocs</title>
  
  <meta name="description" content=" gen_fsm ">
  <meta name="keywords" content="gen, fsm, -, erlang, erlang~19">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="http://docs.w3cub.com/erlang~19/lib/stdlib-3.3/doc/html/gen_fsm/">
  <link href="/favicon.png" rel="icon">
  <link type="text/css" rel="stylesheet" href="/assets/application-50364fff564ce3b6327021805f3f00e2957b441cf27f576a7dd4ff63bbc47047.css">
  <script type="text/javascript" src="/assets/application-db64bfd54ceb42be11af7995804cf4902548419ceb79d509b0b7d62c22d98e6f.js"></script>
  <script src="/json/erlang~19.js"></script>
  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-71174418-1']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>


</head>

<body>
	<div class="_app">
	<header class="_header">
  
  <form class="_search">
    <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
    <a class="_search-clear"></a>
    <div class="_search-tag"></div>
  </form>
  
  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/erlang~19/" class="_nav-link" title="" style="margin-left:0;">Erlang 19</a></span>
  
  <nav class="_nav">
    <a href="/app/" class="_nav-link ">App</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		<div class="_list">
			
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<div class="_page _erlang">
				
<h1>gen_fsm</h1> <h2>Module</h2> <p class="REFBODY">gen_fsm</p> <h2>Module summary</h2> <p class="REFBODY">Generic finite state machine behavior.</p> <h2>Description</h2> 
<div class="note"> <div class="label">Note</div> <div class="content">

<p> There is a new behaviour <code class="bold_code"><a href="../gen_statem/"><span class="code">gen_statem</span></a></code> that is intended to replace <code class="code">gen_fsm</code> for new code. <code class="code">gen_fsm</code> will not be removed for the foreseeable future to keep old state machine implementations running. </p> </div> </div> <p>This behavior module provides a finite state machine. A generic finite state machine process (<code class="code">gen_fsm</code>) implemented using this module has a standard set of interface functions and includes functionality for tracing and error reporting. It also fits into an OTP supervision tree. For more information, see <code class="bold_code">OTP Design Principles</code>. </p> <p>A <code class="code">gen_fsm</code> process assumes all specific parts to be located in a callback module exporting a predefined set of functions. The relationship between the behavior functions and the callback functions is as follows:</p> <div class="example"><pre>
gen_fsm module                    Callback module
--------------                    ---------------
gen_fsm:start
gen_fsm:start_link                -----&gt; Module:init/1

gen_fsm:stop                      -----&gt; Module:terminate/3

gen_fsm:send_event                -----&gt; Module:StateName/2

gen_fsm:send_all_state_event      -----&gt; Module:handle_event/3

gen_fsm:sync_send_event           -----&gt; Module:StateName/3

gen_fsm:sync_send_all_state_event -----&gt; Module:handle_sync_event/4

-                                 -----&gt; Module:handle_info/3

-                                 -----&gt; Module:terminate/3

-                                 -----&gt; Module:code_change/4</pre></div> <p>If a callback function fails or returns a bad value, the <code class="code">gen_fsm</code> process terminates.</p> <p>A <code class="code">gen_fsm</code> process handles system messages as described in <code class="bold_code"><a href="../sys/"><span class="code">sys(3)</span></a></code>. The <code class="code">sys</code> module can be used for debugging a <code class="code">gen_fsm</code> process.</p> <p>Notice that a <code class="code">gen_fsm</code> process does not trap exit signals automatically, this must be explicitly initiated in the callback module.</p> <p>Unless otherwise stated, all functions in this module fail if the specified <code class="code">gen_fsm</code> process does not exist or if bad arguments are specified.</p> <p>The <code class="code">gen_fsm</code> process can go into hibernation (see <code class="bold_code"><span class="code">erlang:hibernate/3</span></code>) if a callback function specifies <code class="code">'hibernate'</code> instead of a time-out value. This can be useful if the server is expected to be idle for a long time. However, use this feature with care, as hibernation implies at least two garbage collections (when hibernating and shortly after waking up) and is not something you want to do between each call to a busy state machine.</p>  <h2>Exports</h2> <h3 id="cancel_timer-1" class="code">cancel_timer(Ref) -&gt; RemainingTime | false</h3>  <p>Types:</p>    <pre>Ref = reference()
RemainingTime = integer()</pre>

<p>Cancels an internal timer referred by <code class="code">Ref</code> in the <code class="code">gen_fsm</code> process that calls this function.</p> <p><code class="code">Ref</code> is a reference returned from <code class="bold_code"><a href="#send_event_after-2"><span class="code">send_event_after/2</span></a></code> or <code class="bold_code"><a href="#start_timer-2"><span class="code">start_timer/2</span></a></code>.</p> <p>If the timer has already timed out, but the event not yet been delivered, it is cancelled as if it had <strong>not</strong> timed out, so there is no false timer event after returning from this function.</p> <p>Returns the remaining time in milliseconds until the timer would have expired if <code class="code">Ref</code> referred to an active timer, otherwise <code class="code">false</code>.</p>  <h3 id="enter_loop-6" class="code">enter_loop(Module, Options, StateName, StateData)<br>enter_loop(Module, Options, StateName, StateData, FsmName)<br>enter_loop(Module, Options, StateName, StateData, Timeout)<br>enter_loop(Module, Options, StateName, StateData, FsmName, Timeout)</h3>  <p>Types:</p>               <pre>Module = atom()
Options = [Option]
 Option = {debug,Dbgs}
  Dbgs = [Dbg]
   Dbg = trace | log | statistics
    | {log_to_file,FileName} | {install,{Func,FuncState}}
StateName = atom()
StateData = term()
FsmName = {local,Name} | {global,GlobalName}
  | {via,Module,ViaName}
 Name = atom()
 GlobalName = ViaName = term()
Timeout = int() | infinity</pre>

<p>Makes an existing process into a <code class="code">gen_fsm</code> process. Does not return, instead the calling process enters the <code class="code">gen_fsm</code> receive loop and becomes a <code class="code">gen_fsm</code> process. The process <strong>must</strong> have been started using one of the start functions in <code class="bold_code"><a href="../proc_lib/"><span class="code">proc_lib(3)</span></a></code>. The user is responsible for any initialization of the process, including registering a name for it.</p> <p>This function is useful when a more complex initialization procedure is needed than the <code class="code">gen_fsm</code> behavior provides.</p> <p><code class="code">Module</code>, <code class="code">Options</code>, and <code class="code">FsmName</code> have the same meanings as when calling <code class="bold_code"><a href="#start_link-3"><span class="code">start[_link]/3,4</span></a></code>. However, if <code class="code">FsmName</code> is specified, the process must have been registered accordingly <strong>before</strong> this function is called.</p> <p><code class="code">StateName</code>, <code class="code">StateData</code>, and <code class="code">Timeout</code> have the same meanings as in the return value of <code class="bold_code"><a href="#Moduleinit"><span class="code">Module:init/1</span></a></code>. The callback module <code class="code">Module</code> does not need to export an <code class="code">init/1</code> function.</p> <p>The function fails if the calling process was not started by a <code class="code">proc_lib</code> start function, or if it is not registered according to <code class="code">FsmName</code>.</p>  <h3 id="reply-2" class="code">reply(Caller, Reply) -&gt; Result</h3>  <p>Types:</p>     <pre>Caller - see below
Reply = term()
Result = term()</pre>

<p>This function can be used by a <code class="code">gen_fsm</code> process to explicitly send a reply to a client process that called <code class="bold_code"><a href="#sync_send_event-2"><span class="code">sync_send_event/2,3</span></a></code> or <code class="bold_code"><a href="#sync_send_all_state_event-2"><span class="code">sync_send_all_state_event/2,3</span></a></code> when the reply cannot be defined in the return value of <code class="bold_code"><a href="#Module:StateName-3"><span class="code">Module:StateName/3</span></a></code> or <code class="bold_code"><a href="#Module:handle_sync_event-4"><span class="code">Module:handle_sync_event/4</span></a></code>.</p> <p><code class="code">Caller</code> must be the <code class="code">From</code> argument provided to the callback function. <code class="code">Reply</code> is any term given back to the client as the return value of <code class="code">sync_send_event/2,3</code> or <code class="code">sync_send_all_state_event/2,3</code>.</p> <p>Return value <code class="code">Result</code> is not further defined, and is always to be ignored.</p>  <h3 id="send_all_state_event-2" class="code">send_all_state_event(FsmRef, Event) -&gt; ok</h3>  <p>Types:</p>       <pre>FsmRef = Name | {Name,Node} | {global,GlobalName}
  | {via,Module,ViaName} | pid()
 Name = Node = atom()
 GlobalName = ViaName = term()
Event = term()</pre>

<p>Sends an event asynchronously to the <code class="code">FsmRef</code> of the <code class="code">gen_fsm</code> process and returns <code class="code">ok</code> immediately. The <code class="code">gen_fsm</code> process calls <code class="bold_code"><a href="#Module:handle_event-3"><span class="code">Module:handle_event/3</span></a></code> to handle the event.</p> <p>For a description of the arguments, see <code class="bold_code"><a href="#send_event-2"><span class="code">send_event/2</span></a></code>.</p> <p>The difference between <code class="code">send_event/2</code> and <code class="code">send_all_state_event/2</code> is which callback function is used to handle the event. This function is useful when sending events that are handled the same way in every state, as only one <code class="code">handle_event</code> clause is needed to handle the event instead of one clause in each state name function.</p>  <h3 id="send_event-2" class="code">send_event(FsmRef, Event) -&gt; ok</h3>  <p>Types:</p>       <pre>FsmRef = Name | {Name,Node} | {global,GlobalName}
  | {via,Module,ViaName} | pid()
 Name = Node = atom()
 GlobalName = ViaName = term()
Event = term()</pre>

<p>Sends an event asynchronously to the <code class="code">FsmRef</code> of the <code class="code">gen_fsm</code> process and returns <code class="code">ok</code> immediately. The <code class="code">gen_fsm</code> process calls <code class="bold_code"><a href="#Module:StateName-2"><span class="code">Module:StateName/2</span></a></code> to handle the event, where <code class="code">StateName</code> is the name of the current state of the <code class="code">gen_fsm</code> process.</p> <p><code class="code">FsmRef</code> can be any of the following:</p> <ul> <li>The pid</li> <li> <code class="code">Name</code>, if the <code class="code">gen_fsm</code> process is locally registered</li> <li> <code class="code">{Name,Node}</code>, if the <code class="code">gen_fsm</code> process is locally registered at another node</li> <li> <code class="code">{global,GlobalName}</code>, if the <code class="code">gen_fsm</code> process is globally registered</li> <li> <code class="code">{via,Module,ViaName}</code>, if the <code class="code">gen_fsm</code> process is registered through an alternative process registry</li> </ul> <p><code class="code">Event</code> is any term that is passed as one of the arguments to <code class="code">Module:StateName/2</code>.</p>  <h3 id="send_event_after-2" class="code">send_event_after(Time, Event) -&gt; Ref</h3>  <p>Types:</p>     <pre>Time = integer()
Event = term()
Ref = reference()</pre>

<p>Sends a delayed event internally in the <code class="code">gen_fsm</code> process that calls this function after <code class="code">Time</code> milliseconds. Returns immediately a reference that can be used to cancel the delayed send using <code class="bold_code"><a href="#cancel_timer-1"><span class="code">cancel_timer/1</span></a></code>.</p> <p>The <code class="code">gen_fsm</code> process calls <code class="bold_code"><a href="#Module:StateName-2"><span class="code">Module:StateName/2</span></a></code> to handle the event, where <code class="code">StateName</code> is the name of the current state of the <code class="code">gen_fsm</code> process at the time the delayed event is delivered.</p> <p><code class="code">Event</code> is any term that is passed as one of the arguments to <code class="code">Module:StateName/2</code>.</p>  <h3 id="start-4" class="code">start(Module, Args, Options) -&gt; Result<br>start(FsmName, Module, Args, Options) -&gt; Result</h3>  <p>Types:</p>                 <pre>FsmName = {local,Name} | {global,GlobalName}
  | {via,Module,ViaName}
 Name = atom()
 GlobalName = ViaName = term()
Module = atom()
Args = term()
Options = [Option]
 Option = {debug,Dbgs} | {timeout,Time} | {spawn_opt,SOpts}
  Dbgs = [Dbg]
   Dbg = trace | log | statistics
    | {log_to_file,FileName} | {install,{Func,FuncState}}
  SOpts = [term()]
Result = {ok,Pid} | ignore | {error,Error}
 Pid = pid()
 Error = {already_started,Pid} | term()</pre>

<p>Creates a standalone <code class="code">gen_fsm</code> process, that is, a process that is not part of a supervision tree and thus has no supervisor.</p> <p>For a description of arguments and return values, see <code class="bold_code"><a href="#start_link-3"><span class="code">start_link/3,4</span></a></code>.</p>  <h3 id="start_link-4" class="code">start_link(Module, Args, Options) -&gt; Result<br>start_link(FsmName, Module, Args, Options) -&gt; Result</h3>  <p>Types:</p>                  <pre>FsmName = {local,Name} | {global,GlobalName}
  | {via,Module,ViaName}
 Name = atom()
 GlobalName = ViaName = term()
Module = atom()
Args = term()
Options = [Option]
 Option = {debug,Dbgs} | {timeout,Time} | {spawn_opt,SOpts}
  Dbgs = [Dbg]
   Dbg = trace | log | statistics
    | {log_to_file,FileName} | {install,{Func,FuncState}}
  SOpts = [SOpt]
   SOpt - see erlang:spawn_opt/2,3,4,5
Result = {ok,Pid} | ignore | {error,Error}
 Pid = pid()
 Error = {already_started,Pid} | term()</pre>

<p>Creates a <code class="code">gen_fsm</code> process as part of a supervision tree. The function is to be called, directly or indirectly, by the supervisor. For example, it ensures that the <code class="code">gen_fsm</code> process is linked to the supervisor.</p> <p>The <code class="code">gen_fsm</code> process calls <code class="bold_code"><a href="#Module:init-1"><span class="code">Module:init/1</span></a></code> to initialize. To ensure a synchronized startup procedure, <code class="code">start_link/3,4</code> does not return until <code class="code">Module:init/1</code> has returned.</p> <ul> <li> <p>If <code class="code">FsmName={local,Name}</code>, the <code class="code">gen_fsm</code> process is registered locally as <code class="code">Name</code> using <code class="code">register/2</code>.</p> </li> <li> <p>If <code class="code">FsmName={global,GlobalName}</code>, the <code class="code">gen_fsm</code> process is registered globally as <code class="code">GlobalName</code> using <code class="bold_code"><span class="code">global:register_name/2</span></code>.</p> </li> <li> <p>If <code class="code">FsmName={via,Module,ViaName}</code>, the <code class="code">gen_fsm</code> process registers with the registry represented by <code class="code">Module</code>. The <code class="code">Module</code> callback is to export the functions <code class="code">register_name/2</code>, <code class="code">unregister_name/1</code>, <code class="code">whereis_name/1</code>, and <code class="code">send/2</code>, which are to behave like the corresponding functions in <code class="bold_code"><span class="code">global</span></code>. Thus, <code class="code">{via,global,GlobalName}</code> is a valid reference.</p> </li> </ul> <p>If no name is provided, the <code class="code">gen_fsm</code> process is not registered.</p> <p><code class="code">Module</code> is the name of the callback module.</p> <p><code class="code">Args</code> is any term that is passed as the argument to <code class="code">Module:init/1</code>.</p> <p>If option <code class="code">{timeout,Time}</code> is present, the <code class="code">gen_fsm</code> process is allowed to spend <code class="code">Time</code> milliseconds initializing or it terminates and the start function returns <code class="code">{error,timeout}</code>.</p> <p>If option <code class="code">{debug,Dbgs}</code> is present, the corresponding <code class="code">sys</code> function is called for each item in <code class="code">Dbgs</code>; see <code class="bold_code"><a href="../sys/"><span class="code">sys(3)</span></a></code>.</p> <p>If option <code class="code">{spawn_opt,SOpts}</code> is present, <code class="code">SOpts</code> is passed as option list to the <code class="code">spawn_opt</code> BIF that is used to spawn the <code class="code">gen_fsm</code> process; see <code class="bold_code"><span class="code">spawn_opt/2</span></code>.</p> <div class="note"> <div class="label">Note</div> <div class="content">

<p>Using spawn option <code class="code">monitor</code> is not allowed, it causes the function to fail with reason <code class="code">badarg</code>.</p> </div> </div> <p>If the <code class="code">gen_fsm</code> process is successfully created and initialized, the function returns <code class="code">{ok,Pid}</code>, where <code class="code">Pid</code> is the pid of the <code class="code">gen_fsm</code> process. If a process with the specified <code class="code">FsmName</code> exists already, the function returns <code class="code">{error,{already_started,Pid}}</code>, where <code class="code">Pid</code> is the pid of that process.</p> <p>If <code class="code">Module:init/1</code> fails with <code class="code">Reason</code>, the function returns <code class="code">{error,Reason}</code>. If <code class="code">Module:init/1</code> returns <code class="code">{stop,Reason}</code> or <code class="code">ignore</code>, the process is terminated and the function returns <code class="code">{error,Reason}</code> or <code class="code">ignore</code>, respectively.</p>  <h3 id="start_timer-2" class="code">start_timer(Time, Msg) -&gt; Ref</h3>  <p>Types:</p>     <pre>Time = integer()
Msg = term()
Ref = reference()</pre>

<p>Sends a time-out event internally in the <code class="code">gen_fsm</code> process that calls this function after <code class="code">Time</code> milliseconds. Returns immediately a reference that can be used to cancel the timer using <code class="bold_code"><a href="#cancel_timer-1"><span class="code">cancel_timer/1</span></a></code>.</p> <p>The <code class="code">gen_fsm</code> process calls <code class="bold_code"><a href="#Module:StateName-2"><span class="code">Module:StateName/2</span></a></code> to handle the event, where <code class="code">StateName</code> is the name of the current state of the <code class="code">gen_fsm</code> process at the time the time-out message is delivered.</p> <p><code class="code">Msg</code> is any term that is passed in the time-out message, <code class="code">{timeout, Ref, Msg}</code>, as one of the arguments to <code class="code">Module:StateName/2</code>.</p>  <h3 id="stop-3" class="code">stop(FsmRef) -&gt; ok<br>stop(FsmRef, Reason, Timeout) -&gt; ok</h3>  <p>Types:</p>        <pre>FsmRef = Name | {Name,Node} | {global,GlobalName}
  | {via,Module,ViaName} | pid()
 Node = atom()
 GlobalName = ViaName = term()
Reason = term()
Timeout = int()&gt;0 | infinity</pre>

<p>Orders a generic finite state machine to exit with the specified <code class="code">Reason</code> and waits for it to terminate. The <code class="code">gen_fsm</code> process calls <code class="bold_code"><a href="#Module:terminate-3"><span class="code">Module:terminate/3</span></a></code> before exiting.</p> <p>The function returns <code class="code">ok</code> if the generic finite state machine terminates with the expected reason. Any other reason than <code class="code">normal</code>, <code class="code">shutdown</code>, or <code class="code">{shutdown,Term}</code> causes an error report to be issued using <code class="bold_code"><span class="code">error_logger:format/2</span></code>. The default <code class="code">Reason</code> is <code class="code">normal</code>.</p> <p><code class="code">Timeout</code> is an integer greater than zero that specifies how many milliseconds to wait for the generic FSM to terminate, or the atom <code class="code">infinity</code> to wait indefinitely. The default value is <code class="code">infinity</code>. If the generic finite state machine has not terminated within the specified time, a <code class="code">timeout</code> exception is raised.</p> <p>If the process does not exist, a <code class="code">noproc</code> exception is raised.</p>  <h3 id="sync_send_all_state_event-3" class="code">sync_send_all_state_event(FsmRef, Event) -&gt; Reply<br>sync_send_all_state_event(FsmRef, Event, Timeout) -&gt; Reply</h3>  <p>Types:</p>         <pre>FsmRef = Name | {Name,Node} | {global,GlobalName}
  | {via,Module,ViaName} | pid()
 Name = Node = atom()
 GlobalName = ViaName = term()
Event = term()
Timeout = int()&gt;0 | infinity
Reply = term()</pre>

<p>Sends an event to the <code class="code">FsmRef</code> of the <code class="code">gen_fsm</code> process and waits until a reply arrives or a time-out occurs. The <code class="code">gen_fsm</code> process calls <code class="bold_code"><a href="#Module:handle_sync_event-4"><span class="code">Module:handle_sync_event/4</span></a></code> to handle the event.</p> <p>For a description of <code class="code">FsmRef</code> and <code class="code">Event</code>, see <code class="bold_code"><a href="#send_event-2">send_event/2</a></code>. For a description of <code class="code">Timeout</code> and <code class="code">Reply</code>, see <code class="bold_code"><a href="#sync_send_event-3"><span class="code">sync_send_event/3</span></a></code>.</p> <p>For a discussion about the difference between <code class="code">sync_send_event</code> and <code class="code">sync_send_all_state_event</code>, see <code class="bold_code"><a href="#send_all_state_event-2"><span class="code">send_all_state_event/2</span></a></code>.</p>  <h3 id="sync_send_event-3" class="code">sync_send_event(FsmRef, Event) -&gt; Reply<br>sync_send_event(FsmRef, Event, Timeout) -&gt; Reply</h3>  <p>Types:</p>         <pre>FsmRef = Name | {Name,Node} | {global,GlobalName}
  | {via,Module,ViaName} | pid()
 Name = Node = atom()
 GlobalName = ViaName = term()
Event = term()
Timeout = int()&gt;0 | infinity
Reply = term()</pre>

<p>Sends an event to the <code class="code">FsmRef</code> of the <code class="code">gen_fsm</code> process and waits until a reply arrives or a time-out occurs. <code class="code">The gen_fsm</code> process calls <code class="bold_code"><a href="#Module:StateName-3"><span class="code">Module:StateName/3</span></a></code> to handle the event, where <code class="code">StateName</code> is the name of the current state of the <code class="code">gen_fsm</code> process.</p> <p>For a description of <code class="code">FsmRef</code> and <code class="code">Event</code>, see <code class="bold_code"><a href="#send_event-2"><span class="code">send_event/2</span></a></code>.</p> <p><code class="code">Timeout</code> is an integer greater than zero that specifies how many milliseconds to wait for a reply, or the atom <code class="code">infinity</code> to wait indefinitely. Defaults to 5000. If no reply is received within the specified time, the function call fails.</p> <p>Return value <code class="code">Reply</code> is defined in the return value of <code class="code">Module:StateName/3</code>.</p> <div class="note"> <div class="label">Note</div> <div class="content">

<p>The ancient behavior of sometimes consuming the server exit message if the server died during the call while linked to the client was removed in Erlang 5.6/OTP R12B.</p> </div> </div>  <h2 id="id215558">Callback Functions</h2>  <p>The following functions are to be exported from a <code class="code">gen_fsm</code> callback module.</p> <p><strong>state name</strong> denotes a state of the state machine.</p> <p><strong>state data</strong> denotes the internal state of the Erlang process that implements the state machine.</p>  <h2>Exports</h2> <h3 id="Module:code_change-4" class="code">Module:code_change(OldVsn, StateName, StateData, Extra) -&gt; {ok, NextStateName, NewStateData}</h3>  <p>Types:</p>       <pre>OldVsn = Vsn | {down, Vsn}
  Vsn = term()
StateName = NextStateName = atom()
StateData = NewStateData = term()
Extra = term()</pre>

<p>This function is called by a <code class="code">gen_fsm</code> process when it is to update its internal state data during a release upgrade/downgrade, that is, when instruction <code class="code">{update,Module,Change,...}</code>, where <code class="code">Change={advanced,Extra}</code>, is given in the <code class="code">appup</code> file; see section <code class="bold_code">Release Handling Instructions</code> in OTP Design Principles.</p> <p>For an upgrade, <code class="code">OldVsn</code> is <code class="code">Vsn</code>, and for a downgrade, <code class="code">OldVsn</code> is <code class="code">{down,Vsn}</code>. <code class="code">Vsn</code> is defined by the <code class="code">vsn</code> attribute(s) of the old version of the callback module <code class="code">Module</code>. If no such attribute is defined, the version is the checksum of the Beam file.</p> <p><code class="code">StateName</code> is the current state name and <code class="code">StateData</code> the internal state data of the <code class="code">gen_fsm</code> process.</p> <p><code class="code">Extra</code> is passed "as is" from the <code class="code">{advanced,Extra}</code> part of the update instruction.</p> <p>The function is to return the new current state name and updated internal data.</p>  <h3 id="Module:format_status-2" class="code">Module:format_status(Opt, [PDict, StateData]) -&gt; Status</h3>  <p>Types:</p>      <pre>Opt = normal | terminate
PDict = [{Key, Value}]
StateData = term()
Status = term()</pre>

<div class="note"> <div class="label">Note</div> <div class="content">

<p>This callback is optional, so callback modules need not export it. The <code class="code">gen_fsm</code> module provides a default implementation of this function that returns the callback module state data.</p> </div> </div> <p>This function is called by a <code class="code">gen_fsm</code> process in the following situations:</p> <ul> <li>One of <code class="bold_code"><a href="../sys/#get_status-1"><span class="code">sys:get_status/1,2</span></a></code> is invoked to get the <code class="code">gen_fsm</code> status. <code class="code">Opt</code> is set to the atom <code class="code">normal</code> for this case.</li> <li>The <code class="code">gen_fsm</code> process terminates abnormally and logs an error. <code class="code">Opt</code> is set to the atom <code class="code">terminate</code> for this case.</li> </ul> <p>This function is useful for changing the form and appearance of the <code class="code">gen_fsm</code> status for these cases. A callback module wishing to change the <code class="code">sys:get_status/1,2</code> return value as well as how its status appears in termination error logs, exports an instance of <code class="code">format_status/2</code> that returns a term describing the current status of the <code class="code">gen_fsm</code> process.</p> <p><code class="code">PDict</code> is the current value of the process dictionary of the <code class="code">gen_fsm</code> process.</p> <p><code class="code">StateData</code> is the internal state data of the <code class="code">gen_fsm</code> process.</p> <p>The function is to return <code class="code">Status</code>, a term that change the details of the current state and status of the <code class="code">gen_fsm</code> process. There are no restrictions on the form <code class="code">Status</code> can take, but for the <code class="code">sys:get_status/1,2</code> case (when <code class="code">Opt</code> is <code class="code">normal</code>), the recommended form for the <code class="code">Status</code> value is <code class="code">[{data, [{"StateData", Term}]}]</code>, where <code class="code">Term</code> provides relevant details of the <code class="code">gen_fsm</code> state data. Following this recommendation is not required, but it makes the callback module status consistent with the rest of the <code class="code">sys:get_status/1,2</code> return value.</p> <p>One use for this function is to return compact alternative state data representations to avoid that large state terms are printed in log files.</p>  <h3 id="Module:handle_event-3" class="code">Module:handle_event(Event, StateName, StateData) -&gt; Result</h3>  <p>Types:</p>             <pre>Event = term()
StateName = atom()
StateData = term()
Result = {next_state,NextStateName,NewStateData}
  | {next_state,NextStateName,NewStateData,Timeout}
  | {next_state,NextStateName,NewStateData,hibernate}
  | {stop,Reason,NewStateData}
 NextStateName = atom()
 NewStateData = term()
 Timeout = int()&gt;0 | infinity
 Reason = term()</pre>

<p>Whenever a <code class="code">gen_fsm</code> process receives an event sent using <code class="bold_code"><a href="#send_all_state_event-2"><span class="code">send_all_state_event/2</span></a></code>, this function is called to handle the event.</p> <p><code class="code">StateName</code> is the current state name of the <code class="code">gen_fsm</code> process.</p> <p>For a description of the other arguments and possible return values, see <code class="bold_code"><a href="#Module:StateName-2"><span class="code">Module:StateName/2</span></a></code>.</p>  <h3 id="Module:handle_info-3" class="code">Module:handle_info(Info, StateName, StateData) -&gt; Result</h3>  <p>Types:</p>             <pre>Info = term()
StateName = atom()
StateData = term()
Result = {next_state,NextStateName,NewStateData}
  | {next_state,NextStateName,NewStateData,Timeout}
  | {next_state,NextStateName,NewStateData,hibernate}
  | {stop,Reason,NewStateData}
 NextStateName = atom()
 NewStateData = term()
 Timeout = int()&gt;0 | infinity
 Reason = normal | term()</pre>

<p>This function is called by a <code class="code">gen_fsm</code> process when it receives any other message than a synchronous or asynchronous event (or a system message).</p> <p><code class="code">Info</code> is the received message.</p> <p>For a description of the other arguments and possible return values, see <code class="bold_code"><a href="#Module:StateName-2"><span class="code">Module:StateName/2</span></a></code>.</p>  <h3 id="Module:handle_sync_event-4" class="code">Module:handle_sync_event(Event, From, StateName, StateData) -&gt; Result</h3>  <p>Types:</p>                  <pre>Event = term()
From = {pid(),Tag}
StateName = atom()
StateData = term()
Result = {reply,Reply,NextStateName,NewStateData}
  | {reply,Reply,NextStateName,NewStateData,Timeout}
  | {reply,Reply,NextStateName,NewStateData,hibernate}
  | {next_state,NextStateName,NewStateData}
  | {next_state,NextStateName,NewStateData,Timeout}
  | {next_state,NextStateName,NewStateData,hibernate}
  | {stop,Reason,Reply,NewStateData} | {stop,Reason,NewStateData}
 Reply = term()
 NextStateName = atom()
 NewStateData = term()
 Timeout = int()&gt;0 | infinity
 Reason = term()</pre>

<p>Whenever a <code class="code">gen_fsm</code> process receives an event sent using <code class="bold_code"><a href="#sync_send_all_state_event-2"><span class="code">sync_send_all_state_event/2,3</span></a></code>, this function is called to handle the event.</p> <p><code class="code">StateName</code> is the current state name of the <code class="code">gen_fsm</code> process.</p> <p>For a description of the other arguments and possible return values, see <code class="bold_code"><a href="#Module:StateName-3"><span class="code">Module:StateName/3</span></a></code>.</p>  <h3 id="Module:init-1" class="code">Module:init(Args) -&gt; Result</h3>  <p>Types:</p>          <pre>Args = term()
Result = {ok,StateName,StateData} | {ok,StateName,StateData,Timeout}
  | {ok,StateName,StateData,hibernate}
  | {stop,Reason} | ignore
 StateName = atom()
 StateData = term()
 Timeout = int()&gt;0 | infinity
 Reason = term()</pre>

<p>Whenever a <code class="code">gen_fsm</code> process is started using <code class="bold_code"><a href="#start-3"><span class="code">start/3,4</span></a></code> or <code class="bold_code"><a href="#start_link-3"><span class="code">start_link/3,4</span></a></code>, this function is called by the new process to initialize.</p> <p><code class="code">Args</code> is the <code class="code">Args</code> argument provided to the start function.</p> <p>If initialization is successful, the function is to return <code class="code">{ok,StateName,StateData}</code>, <code class="code">{ok,StateName,StateData,Timeout}</code>, or <code class="code">{ok,StateName,StateData,hibernate}</code>, where <code class="code">StateName</code> is the initial state name and <code class="code">StateData</code> the initial state data of the <code class="code">gen_fsm</code> process.</p> <p>If an integer time-out value is provided, a time-out occurs unless an event or a message is received within <code class="code">Timeout</code> milliseconds. A time-out is represented by the atom <code class="code">timeout</code> and is to be handled by the <code class="bold_code"><a href="#Module:StateName-2"><span class="code">Module:StateName/2</span></a></code> callback functions. The atom <code class="code">infinity</code> can be used to wait indefinitely, this is the default value.</p> <p>If <code class="code">hibernate</code> is specified instead of a time-out value, the process goes into hibernation when waiting for the next message to arrive (by calling <code class="bold_code"><a href="../proc_lib/#hibernate-3"><span class="code">proc_lib:hibernate/3</span></a></code>).</p> <p>If the initialization fails, the function returns <code class="code">{stop,Reason}</code>, where <code class="code">Reason</code> is any term, or <code class="code">ignore</code>.</p>  <h3 id="Module:StateName-2" class="code">Module:StateName(Event, StateData) -&gt; Result</h3>  <p>Types:</p>            <pre>Event = timeout | term()
StateData = term()
Result = {next_state,NextStateName,NewStateData}
  | {next_state,NextStateName,NewStateData,Timeout}
  | {next_state,NextStateName,NewStateData,hibernate}
  | {stop,Reason,NewStateData}
 NextStateName = atom()
 NewStateData = term()
 Timeout = int()&gt;0 | infinity
 Reason = term()</pre>

<p>There is to be one instance of this function for each possible state name. Whenever a <code class="code">gen_fsm</code> process receives an event sent using <code class="bold_code"><a href="#send_event-2"><span class="code">send_event/2</span></a></code>, the instance of this function with the same name as the current state name <code class="code">StateName</code> is called to handle the event. It is also called if a time-out occurs.</p> <p><code class="code">Event</code> is either the atom <code class="code">timeout</code>, if a time-out has occurred, or the <code class="code">Event</code> argument provided to <code class="code">send_event/2</code>.</p> <p><code class="code">StateData</code> is the state data of the <code class="code">gen_fsm</code> process.</p> <p>If the function returns <code class="code">{next_state,NextStateName,NewStateData}</code>, <code class="code">{next_state,NextStateName,NewStateData,Timeout}</code>, or <code class="code">{next_state,NextStateName,NewStateData,hibernate}</code>, the <code class="code">gen_fsm</code> process continues executing with the current state name set to <code class="code">NextStateName</code> and with the possibly updated state data <code class="code">NewStateData</code>. For a description of <code class="code">Timeout</code> and <code class="code">hibernate</code>, see <code class="bold_code"><a href="#Module:init-1"><span class="code">Module:init/1</span></a></code>.</p> <p>If the function returns <code class="code">{stop,Reason,NewStateData}</code>, the <code class="code">gen_fsm</code> process calls <code class="code">Module:terminate(Reason,StateName,NewStateData)</code> and terminates.</p>  <h3 id="Module:StateName-3" class="code">Module:StateName(Event, From, StateData) -&gt; Result</h3>  <p>Types:</p>                 <pre>Event = term()
From = {pid(),Tag}
StateData = term()
Result = {reply,Reply,NextStateName,NewStateData}
  | {reply,Reply,NextStateName,NewStateData,Timeout}
  | {reply,Reply,NextStateName,NewStateData,hibernate}
  | {next_state,NextStateName,NewStateData}
  | {next_state,NextStateName,NewStateData,Timeout}
  | {next_state,NextStateName,NewStateData,hibernate}
  | {stop,Reason,Reply,NewStateData} | {stop,Reason,NewStateData}
 Reply = term()
 NextStateName = atom()
 NewStateData = term()
 Timeout = int()&gt;0 | infinity
 Reason = normal | term()</pre>

<p>There is to be one instance of this function for each possible state name. Whenever a <code class="code">gen_fsm</code> process receives an event sent using <code class="bold_code"><a href="#sync_send_event-2"><span class="code">sync_send_event/2,3</span></a></code>, the instance of this function with the same name as the current state name <code class="code">StateName</code> is called to handle the event.</p> <p><code class="code">Event</code> is the <code class="code">Event</code> argument provided to <code class="code">sync_send_event/2,3</code>.</p> <p><code class="code">From</code> is a tuple <code class="code">{Pid,Tag}</code> where <code class="code">Pid</code> is the pid of the process that called <code class="code">sync_send_event/2,3</code> and <code class="code">Tag</code> is a unique tag.</p> <p><code class="code">StateData</code> is the state data of the <code class="code">gen_fsm</code> process.</p> <ul> <li> <p>If <code class="code">{reply,Reply,NextStateName,NewStateData}</code>, <code class="code">{reply,Reply,NextStateName,NewStateData,Timeout}</code>, or <code class="code">{reply,Reply,NextStateName,NewStateData,hibernate}</code> is returned, <code class="code">Reply</code> is given back to <code class="code">From</code> as the return value of <code class="code">sync_send_event/2,3</code>. The <code class="code">gen_fsm</code> process then continues executing with the current state name set to <code class="code">NextStateName</code> and with the possibly updated state data <code class="code">NewStateData</code>. For a description of <code class="code">Timeout</code> and <code class="code">hibernate</code>, see <code class="bold_code"><a href="#Module:init-1"><span class="code">Module:init/1</span></a></code>.</p> </li> <li> <p>If <code class="code">{next_state,NextStateName,NewStateData}</code>, <code class="code">{next_state,NextStateName,NewStateData,Timeout}</code>, or <code class="code">{next_state,NextStateName,NewStateData,hibernate}</code> is returned, the <code class="code">gen_fsm</code> process continues executing in <code class="code">NextStateName</code> with <code class="code">NewStateData</code>. Any reply to <code class="code">From</code> must be specified explicitly using <code class="bold_code"><a href="#reply-2"><span class="code">reply/2</span></a></code>.</p> </li> <li> <p>If the function returns <code class="code">{stop,Reason,Reply,NewStateData}</code>, <code class="code">Reply</code> is given back to <code class="code">From</code>. If the function returns <code class="code">{stop,Reason,NewStateData}</code>, any reply to <code class="code">From</code> must be specified explicitly using <code class="code">reply/2</code>. The <code class="code">gen_fsm</code> process then calls <code class="code">Module:terminate(Reason,StateName,NewStateData)</code> and terminates.</p> </li> </ul>  <h3 id="Module:terminate-3" class="code">Module:terminate(Reason, StateName, StateData)</h3>  <p>Types:</p>     <pre>Reason = normal | shutdown | {shutdown,term()} | term()
StateName = atom()
StateData = term()</pre>

<p>This function is called by a <code class="code">gen_fsm</code> process when it is about to terminate. It is to be the opposite of <code class="bold_code"><a href="#Module:init-1"><span class="code">Module:init/1</span></a></code> and do any necessary cleaning up. When it returns, the <code class="code">gen_fsm</code> process terminates with <code class="code">Reason</code>. The return value is ignored. </p> <p><code class="code">Reason</code> is a term denoting the stop reason, <code class="code">StateName</code> is the current state name, and <code class="code">StateData</code> is the state data of the <code class="code">gen_fsm</code> process.</p> <p><code class="code">Reason</code> depends on why the <code class="code">gen_fsm</code> process is terminating. If it is because another callback function has returned a stop tuple <code class="code">{stop,..}</code>, <code class="code">Reason</code> has the value specified in that tuple. If it is because of a failure, <code class="code">Reason</code> is the error reason.</p> <p>If the <code class="code">gen_fsm</code> process is part of a supervision tree and is ordered by its supervisor to terminate, this function is called with <code class="code">Reason=shutdown</code> if the following conditions apply:</p> <ul> <li> <p>The <code class="code">gen_fsm</code> process has been set to trap exit signals.</p> </li> <li> <p>The shutdown strategy as defined in the child specification of the supervisor is an integer time-out value, not <code class="code">brutal_kill</code>.</p> </li> </ul> <p>Even if the <code class="code">gen_fsm</code> process is <strong>not</strong> part of a supervision tree, this function is called if it receives an <code class="code">'EXIT'</code> message from its parent. <code class="code">Reason</code> is the same as in the <code class="code">'EXIT'</code> message.</p> <p>Otherwise, the <code class="code">gen_fsm</code> process terminates immediately.</p> <p>Notice that for any other reason than <code class="code">normal</code>, <code class="code">shutdown</code>, or <code class="code">{shutdown,Term}</code> the <code class="code">gen_fsm</code> process is assumed to terminate because of an error and an error report is issued using <code class="bold_code"><span class="code">error_logger:format/2</span></code>.</p>  <h2 id="id217047">See Also</h2>  <p><code class="bold_code"><a href="../gen_event/"><span class="code">gen_event(3)</span></a></code>, <code class="bold_code"><a href="../gen_server/"><span class="code">gen_server(3)</span></a></code>, <code class="bold_code"><a href="../gen_statem/"><span class="code">gen_statem(3)</span></a></code>, <code class="bold_code"><a href="../proc_lib/"><span class="code">proc_lib(3)</span></a></code>, <code class="bold_code"><a href="../supervisor/"><span class="code">supervisor(3)</span></a></code>, <code class="bold_code"><a href="../sys/"><span class="code">sys(3)</span></a></code></p>
<div class="_attribution">
  <p class="_attribution-p">
    © 1999–2016 Ericsson AB<br>Licensed under the Apache License, Version 2.0.<br>
    
  </p>
</div>

			</div>
		</div>
	</section>

	</div>
</body>
</html>
