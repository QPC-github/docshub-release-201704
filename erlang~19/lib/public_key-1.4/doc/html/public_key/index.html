
<!DOCTYPE HTML>

<html lang="en">

<head>
  <meta charset="utf-8">
  <title>Public_key - Erlang 19 - W3cubDocs</title>
  
  <meta name="description" content=" public_key ">
  <meta name="keywords" content="public, key, -, erlang, erlang~19">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="http://docs.w3cub.com/erlang~19/lib/public_key-1.4/doc/html/public_key/">
  <link href="/favicon.png" rel="icon">
  <link type="text/css" rel="stylesheet" href="/assets/application-50364fff564ce3b6327021805f3f00e2957b441cf27f576a7dd4ff63bbc47047.css">
  <script type="text/javascript" src="/assets/application-db64bfd54ceb42be11af7995804cf4902548419ceb79d509b0b7d62c22d98e6f.js"></script>
  <script src="/json/erlang~19.js"></script>
  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-71174418-1']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>


</head>

<body>
	<div class="_app">
	<header class="_header">
  
  <form class="_search">
    <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
    <a class="_search-clear"></a>
    <div class="_search-tag"></div>
  </form>
  
  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/erlang~19/" class="_nav-link" title="" style="margin-left:0;">Erlang 19</a></span>
  
  <nav class="_nav">
    <a href="/app/" class="_nav-link ">App</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		<div class="_list">
			
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<div class="_page _erlang">
				
<h1>public_key</h1> <h2>Module</h2> <p class="REFBODY">public_key</p> <h2>Module summary</h2> <p class="REFBODY">API module for public-key infrastructure.</p> <h2>Description</h2> 
<p>Provides functions to handle public-key infrastructure, for details see <code class="bold_code"><span>public_key(6)</span></code>. </p>  <h2 id="id66128">Data types</h2>  <div class="note"> <div class="label">Note</div> <div class="content">

<p>All records used in this Reference Manual are generated from ASN.1 specifications and are documented in the User's Guide. See <code class="bold_code"><a href="../public_key_records/">Public-key Records</a></code>. </p>
</div> </div> <p>Use the following include directive to get access to the records and constant macros described here and in the User's Guide:</p> <div class="example"><pre>-include_lib("public_key/include/public_key.hrl").</pre></div> <p>The following data types are used in the functions for <code class="code">public_key</code>:</p> <dl> <dt><strong><code class="code">oid()</code></strong></dt> <dd><p>Object identifier, a tuple of integers as generated by the <code class="code">ASN.1</code> compiler.</p></dd> <dt><strong><code class="code">boolean() =</code></strong></dt> <dd><p><code class="code">true | false</code></p></dd> <dt><strong><code class="code">string() =</code></strong></dt> <dd><p><code class="code">[bytes()]</code></p></dd> <dt><strong><code class="code">der_encoded() =</code></strong></dt> <dd><p><code class="code">binary()</code></p></dd> <dt><strong><code class="code">pki_asn1_type() =</code></strong></dt> <dd> <p><code class="code">'Certificate'</code></p> <p><code class="code">| 'RSAPrivateKey'</code></p> <p><code class="code">| 'RSAPublicKey'</code></p> <p><code class="code">| 'DSAPrivateKey'</code></p> <p><code class="code">| 'DSAPublicKey'</code></p> <p><code class="code">| 'DHParameter'</code></p> <p><code class="code">| 'SubjectPublicKeyInfo'</code></p> <p><code class="code">| 'PrivateKeyInfo'</code></p> <p><code class="code">| 'CertificationRequest'</code></p> <p><code class="code">| 'CertificateList'</code></p> <p><code class="code">| 'ECPrivateKey'</code></p> <p><code class="code">| 'EcpkParameters'</code></p> </dd> <dt><strong><code class="code">pem_entry () =</code></strong></dt> <dd> <p><code class="code">{pki_asn1_type(), binary(), %% DER or encrypted DER</code></p> <p><code class="code">not_encrypted | cipher_info()}</code></p> </dd> <dt><strong><code class="code">cipher_info() =</code></strong></dt> <dd> <p><code class="code">{"RC2-CBC" | "DES-CBC" | "DES-EDE3-CBC", crypto:strong_rand_bytes(8)</code></p> <p><code class="code">| {#'PBEParameter{}, digest_type()} | #'PBES2-params'{}}</code></p> </dd> <dt><strong><code class="code">public_key() =</code></strong></dt> <dd><p><code class="code">rsa_public_key() | dsa_public_key() | ec_public_key()</code></p></dd> <dt><strong><code class="code">private_key() =</code></strong></dt> <dd><p><code class="code">rsa_private_key() | dsa_private_key() | ec_private_key()</code></p></dd> <dt><strong><code class="code">rsa_public_key() =</code></strong></dt> <dd><p><code class="code">#'RSAPublicKey'{}</code></p></dd> <dt><strong><code class="code">rsa_private_key() =</code></strong></dt> <dd><p><code class="code">#'RSAPrivateKey'{}</code></p></dd> <dt><strong><code class="code">dsa_public_key() =</code></strong></dt> <dd><p><code class="code">{integer(), #'Dss-Parms'{}}</code></p></dd> <dt><strong><code class="code">dsa_private_key() =</code></strong></dt> <dd><p><code class="code">#'DSAPrivateKey'{}</code></p></dd> <dt><strong><code class="code">ec_public_key()</code></strong></dt> <dd><p>= <code class="code">{#'ECPoint'{}, #'ECParameters'{} | {namedCurve, oid()}}</code></p></dd> <dt><strong><code class="code">ec_private_key() =</code></strong></dt> <dd><p><code class="code">#'ECPrivateKey'{}</code></p></dd> <dt><strong><code class="code">public_crypt_options() =</code></strong></dt> <dd><p><code class="code">[{rsa_pad, rsa_padding()}]</code></p></dd> <dt><strong><code class="code">rsa_padding() =</code></strong></dt> <dd> <p><code class="code">'rsa_pkcs1_padding'</code></p> <p><code class="code">| 'rsa_pkcs1_oaep_padding'</code></p> <p><code class="code">| 'rsa_no_padding'</code></p> </dd> <dt><strong><code class="code">digest_type() =</code></strong></dt> <dd><p>Union of <code class="code">rsa_digest_type()</code>, <code class="code">dss_digest_type()</code>, and <code class="code">ecdsa_digest_type()</code>.</p></dd> <dt><strong><code class="code">rsa_digest_type() =</code></strong></dt> <dd><p><code class="code">'md5' | 'sha' | 'sha224' | 'sha256' | 'sha384' | 'sha512'</code></p></dd> <dt><strong><code class="code">dss_digest_type() =</code></strong></dt> <dd><p><code class="code">'sha'</code></p></dd> <dt><strong><code class="code">ecdsa_digest_type() =</code></strong></dt> <dd><p><code class="code">'sha'| 'sha224' | 'sha256' | 'sha384' | 'sha512'</code></p></dd> <dt><strong><code class="code">crl_reason() =</code></strong></dt> <dd> <p><code class="code">unspecified</code></p> <p><code class="code">| keyCompromise</code></p> <p><code class="code">| cACompromise</code></p> <p><code class="code">| affiliationChanged</code></p> <p><code class="code">| superseded</code></p> <p><code class="code">| cessationOfOperation</code></p> <p><code class="code">| certificateHold</code></p> <p><code class="code">| privilegeWithdrawn</code></p> <p><code class="code">| aACompromise</code></p> </dd> <dt><strong><code class="code">issuer_name() =</code></strong></dt> <dd> <p><code class="code">{rdnSequence,[#'AttributeTypeAndValue'{}]}</code></p> </dd> <dt><strong><code class="code">ssh_file() =</code></strong></dt> <dd> <p><code class="code">openssh_public_key</code></p> <p><code class="code">| rfc4716_public_key</code></p> <p><code class="code">| known_hosts</code></p> <p><code class="code">| auth_keys</code></p> </dd> </dl>  <h2>Exports</h2> <h3 id="compute_key-3" class="code">compute_key(OthersKey, MyKey)-&gt;<br>compute_key(OthersKey, MyKey, Params)-&gt;</h3>  <p>Types:</p>    <pre>OthersKey = #'ECPoint'{} | binary(), MyKey = #'ECPrivateKey'{} | binary()
Params = #'DHParameter'{}</pre>

<p>Computes shared secret.</p>  <h3 id="decrypt_private-3" class="code">decrypt_private(CipherText, Key) -&gt; binary()<br>decrypt_private(CipherText, Key, Options) -&gt; binary()</h3>  <p>Types:</p>     <pre>CipherText = binary()
Key = rsa_private_key()
Options = public_crypt_options()</pre>

<p>Public-key decryption using the private key. See also <code class="bold_code">crypto:private_decrypt/4</code></p>  <h3 id="decrypt_public-3" class="code">decrypt_public(CipherText, Key) - &gt; binary()<br>decrypt_public(CipherText, Key, Options) - &gt; binary()</h3>  <p>Types:</p>     <pre>CipherText = binary()
Key = rsa_public_key()
Options = public_crypt_options()</pre>

<p>Public-key decryption using the public key. See also <code class="bold_code">crypto:public_decrypt/4</code></p>  <h3 id="der_decode-2" class="code">der_decode(Asn1type, Der) -&gt; term()</h3>  <p>Types:</p>  <pre>Asn1Type = atom()</pre>
<p class="REFBODY">ASN.1 type present in the Public Key applications ASN.1 specifications.</p>   <pre>Der = der_encoded()</pre>

<p>Decodes a public-key ASN.1 DER encoded entity.</p>  <h3 id="der_encode-2" class="code">der_encode(Asn1Type, Entity) -&gt; der_encoded()</h3>  <p>Types:</p>  <pre>Asn1Type = atom()</pre>
<p class="REFBODY">ASN.1 type present in the Public Key applications ASN.1 specifications.</p>  Erlang representation of <pre>Entity = term()</pre>
<code class="code">Asn1Type</code>   
<p>Encodes a public-key entity with ASN.1 DER encoding.</p>  <h3 id="dh_gex_group-4" class="code">dh_gex_group(MinSize, SuggestedSize, MaxSize, Groups) -&gt; {ok, {Size,Group}} | {error,Error}</h3>  <p>Types:</p>          <pre>MinSize = positive_integer()
SuggestedSize = positive_integer()
MaxSize = positive_integer()
Groups = undefined | [{Size,[{G,P}]}]
Size = positive_integer()
Group = {G,P}
G = positive_integer()
P = positive_integer()</pre>

<p>Selects a group for Diffie-Hellman key exchange with the key size in the range <code class="code">MinSize...MaxSize</code> and as close to <code class="code">SuggestedSize</code> as possible. If <code class="code">Groups == undefined</code> a default set will be used, otherwise the group is selected from <code class="code">Groups</code>.</p> <p>First a size, as close as possible to SuggestedSize, is selected. Then one group with that key size is randomly selected from the specified set of groups. If no size within the limits of <code class="code">MinSize</code> and <code class="code">MaxSize</code> is available, <code class="code">{error,no_group_found}</code> is returned.</p> <p>The default set of groups is listed in <code class="code">lib/public_key/priv/moduli</code>. This file may be regenerated like this:</p> <div class="example"><pre>
$&gt; cd $ERL_TOP/lib/public_key/priv/
$&gt; generate
         ---- wait until all background jobs has finished. It may take several days !
$&gt; cat moduli-* &gt; moduli
$&gt; cd ..; make 
      </pre></div>  <h3 id="encrypt_private-2" class="code">encrypt_private(PlainText, Key) -&gt; binary()</h3>  <p>Types:</p>    <pre>PlainText = binary()
Key = rsa_private_key()</pre>

<p>Public-key encryption using the private key. See also <code class="bold_code">crypto:private_encrypt/4</code>.</p>  <h3 id="encrypt_public-2" class="code">encrypt_public(PlainText, Key) -&gt; binary()</h3>  <p>Types:</p>    <pre>PlainText = binary()
Key = rsa_public_key()</pre>

<p>Public-key encryption using the public key. See also <code class="bold_code">crypto:public_encrypt/4</code>.</p>  <h3 id="generate_key-1" class="code">generate_key(Params) -&gt; {Public::binary(), Private::binary()} | #'ECPrivateKey'{}</h3>  <p>Types:</p>   <pre>Params = #'DHParameter'{} | {namedCurve, oid()} | #'ECParameters'{}</pre>

<p>Generates a new keypair.</p>  <h3 id="pem_decode-1" class="code">pem_decode(PemBin) -&gt; [pem_entry()]</h3>  <p>Types:</p>  <pre>PemBin = binary()</pre>
<p class="REFBODY">Example {ok, PemBin} = file:read_file("cert.pem").</p>  
<p>Decodes PEM binary data and returns entries as ASN.1 DER encoded entities.</p>  <h3 id="pem_encode-1" class="code">pem_encode(PemEntries) -&gt; binary()</h3>  <p>Types:</p>   <pre>PemEntries = [pem_entry()]</pre>

<p>Creates a PEM binary.</p>  <h3 id="pem_entry_decode-2" class="code">pem_entry_decode(PemEntry) -&gt; term()<br>pem_entry_decode(PemEntry, Password) -&gt; term()</h3>  <p>Types:</p>    <pre>PemEntry = pem_entry()
Password = string()</pre>

<p>Decodes a PEM entry. <code class="code">pem_decode/1</code> returns a list of PEM entries. Notice that if the PEM entry is of type 'SubjectPublickeyInfo', it is further decoded to an <code class="code">rsa_public_key()</code> or <code class="code">dsa_public_key()</code>.</p>  <h3 id="pem_entry_encode-3" class="code">pem_entry_encode(Asn1Type, Entity) -&gt; pem_entry()<br>pem_entry_encode(Asn1Type, Entity, {CipherInfo, Password}) -&gt; pem_entry()</h3>  <p>Types:</p>   Erlang representation of <pre>Asn1Type = pki_asn1_type()
Entity = term()</pre>
<code class="code">Asn1Type</code>. If <code class="code">Asn1Type</code> is 'SubjectPublicKeyInfo', <code class="code">Entity</code> must be either an <code class="code">rsa_public_key()</code>, <code class="code">dsa_public_key()</code> or an <code class="code">ec_public_key()</code> and this function creates the appropriate 'SubjectPublicKeyInfo' entry.     <pre>CipherInfo = cipher_info()
Password = string()</pre>

<p>Creates a PEM entry that can be feed to <code class="code">pem_encode/1</code>.</p>  <h3 id="pkix_decode_cert-2" class="code">pkix_decode_cert(Cert, otp|plain) -&gt; #'Certificate'{} | #'OTPCertificate'{}</h3>  <p>Types:</p>   <pre>Cert = der_encoded()</pre>

<p>Decodes an ASN.1 DER-encoded PKIX certificate. Option <code class="code">otp</code> uses the customized ASN.1 specification OTP-PKIX.asn1 for decoding and also recursively decode most of the standard parts.</p>  <h3 id="pkix_encode-3" class="code">pkix_encode(Asn1Type, Entity, otp | plain) -&gt; der_encoded()</h3>  <p>Types:</p>  <pre>Asn1Type = atom()</pre>
<p class="REFBODY">The ASN.1 type can be 'Certificate', 'OTPCertificate' or a subtype of either.</p>   <pre>Entity = #'Certificate'{} | #'OTPCertificate'{} | a valid subtype</pre>

<p>DER encodes a PKIX x509 certificate or part of such a certificate. This function must be used for encoding certificates or parts of certificates that are decoded/created in the <code class="code">otp</code> format, whereas for the plain format this function directly calls <code class="code">der_encode/2</code>.</p>  <h3 id="pkix_is_issuer-2" class="code">pkix_is_issuer(Cert, IssuerCert) -&gt; boolean()</h3>  <p>Types:</p>    <pre>Cert = der_encoded() | #'OTPCertificate'{} | #'CertificateList'{}
IssuerCert = der_encoded() | #'OTPCertificate'{}</pre>

<p>Checks if <code class="code">IssuerCert</code> issued <code class="code">Cert</code>.</p>  <h3 id="pkix_is_fixed_dh_cert-1" class="code">pkix_is_fixed_dh_cert(Cert) -&gt; boolean()</h3>  <p>Types:</p>   <pre>Cert = der_encoded() | #'OTPCertificate'{}</pre>

<p>Checks if a certificate is a fixed Diffie-Hellman certificate.</p>  <h3 id="pkix_is_self_signed-1" class="code">pkix_is_self_signed(Cert) -&gt; boolean()</h3>  <p>Types:</p>   <pre>Cert = der_encoded() | #'OTPCertificate'{}</pre>

<p>Checks if a certificate is self-signed.</p>  <h3 id="pkix_issuer_id-2" class="code">pkix_issuer_id(Cert, IssuedBy) -&gt; {ok, IssuerID} | {error, Reason}</h3>  <p>Types:</p>    <pre>Cert = der_encoded() | #'OTPCertificate'{}
IssuedBy = self | other
IssuerID = {integer(), issuer_name()}</pre>
<p class="REFBODY">The issuer id consists of the serial number and the issuers name.</p>   <pre>Reason = term()</pre>

<p>Returns the issuer id.</p>  <h3 id="pkix_normalize_name-1" class="code">pkix_normalize_name(Issuer) -&gt; Normalized</h3>  <p>Types:</p>    <pre>Issuer = issuer_name()
Normalized = issuer_name()</pre>

<p>Normalizes an issuer name so that it can be easily compared to another issuer name.</p>  <h3 id="pkix_path_validation-3" class="code">pkix_path_validation(TrustedCert, CertChain, Options) -&gt; {ok, {PublicKeyInfo, PolicyTree}} | {error, {bad_cert, Reason}}</h3>  <p>Types:</p>  Normally a trusted certificate, but it can also be a path-validation error that can be discovered while constructing the input to this function and that is to be run through the <pre>TrustedCert = #'OTPCertificate'{} | der_encoded() | atom()</pre>
<code class="code">verify_fun</code>. Examples are <code class="code">unknown_ca</code> and <code class="code">selfsigned_peer.</code>   <pre>CertChain = [der_encoded()]</pre>
<p class="REFBODY">A list of DER-encoded certificates in trust order ending with the peer certificate.</p>    <pre>Options = proplists:proplist()
PublicKeyInfo = {?'rsaEncryption' | ?'id-dsa', rsa_public_key() | integer(), 'NULL' | 'Dss-Parms'{}}
PolicyTree = term()</pre>
<p class="REFBODY">At the moment this is always an empty list as policies are not currently supported.</p>   <pre>Reason = cert_expired | invalid_issuer | invalid_signature | name_not_permitted | missing_basic_constraint | invalid_key_usage | {revoked, crl_reason()} | atom()</pre>

<p> Performs a basic path validation according to <code class="bold_code"><a href="http://www.ietf.org/rfc/rfc5280.txt" target="_blank">RFC 5280.</a></code> However, CRL validation is done separately by <code class="bold_code"><a href="#pkix_crls_validate-3">pkix_crls_validate/3</a></code> and is to be called from the supplied <code class="code">verify_fun</code>. </p> <p>Available options:</p> <dl> <dt><strong>{verify_fun, fun()}</strong></dt> <dd> <p>The fun must be defined as:</p> <div class="example"><pre>
fun(OtpCert :: #'OTPCertificate'{},
    Event :: {bad_cert, Reason :: atom() | {revoked, atom()}} |
             {extension, #'Extension'{}},
    InitialUserState :: term()) -&gt;
	{valid, UserState :: term()} |
	{valid_peer, UserState :: term()} |
	{fail, Reason :: term()} |
	{unknown, UserState :: term()}.
	  </pre></div> <p>If the verify callback fun returns <code class="code">{fail, Reason}</code>, the verification process is immediately stopped. If the verify callback fun returns <code class="code">{valid, UserState}</code>, the verification process is continued. This can be used to accept specific path validation errors, such as <code class="code">selfsigned_peer</code>, as well as verifying application-specific extensions. If called with an extension unknown to the user application, the return value <code class="code">{unknown, UserState}</code> is to be used.</p> </dd> <dt><strong>{max_path_length, integer()}</strong></dt> <dd> The <code class="code">max_path_length</code> is the maximum number of non-self-issued intermediate certificates that can follow the peer certificate in a valid certification path. So, if <code class="code">max_path_length</code> is 0, the PEER must be signed by the trusted ROOT-CA directly, if it is 1, the path can be PEER, CA, ROOT-CA, if it is 2, the path can be PEER, CA, CA, ROOT-CA, and so on. </dd> </dl> <p>Possible reasons for a bad certificate: </p> <dl> <dt><strong>cert_expired</strong></dt> <dd><p>Certificate is no longer valid as its expiration date has passed.</p></dd> <dt><strong>invalid_issuer</strong></dt> <dd><p>Certificate issuer name does not match the name of the issuer certificate in the chain.</p></dd> <dt><strong>invalid_signature</strong></dt> <dd><p>Certificate was not signed by its issuer certificate in the chain.</p></dd> <dt><strong>name_not_permitted</strong></dt> <dd><p>Invalid Subject Alternative Name extension.</p></dd> <dt><strong>missing_basic_constraint</strong></dt> <dd><p>Certificate, required to have the basic constraints extension, does not have a basic constraints extension.</p></dd> <dt><strong>invalid_key_usage</strong></dt> <dd><p>Certificate key is used in an invalid way according to the key-usage extension.</p></dd> <dt><strong>{revoked, crl_reason()}</strong></dt> <dd><p>Certificate has been revoked.</p></dd> <dt><strong>atom()</strong></dt> <dd><p>Application-specific error reason that is to be checked by the <code class="code">verify_fun</code>.</p></dd> </dl>  <h3 id="pkix_crl_issuer-1" class="code">pkix_crl_issuer(CRL) -&gt; issuer_name()</h3>  <p>Types:</p>   <pre>CRL = der_encoded() | #'CertificateList'{}</pre>

<p>Returns the issuer of the <code class="code">CRL</code>.</p>  <h3 id="pkix_crls_validate-3" class="code">pkix_crls_validate(OTPCertificate, DPAndCRLs, Options) -&gt; CRLStatus()</h3>  <p>Types:</p>      <pre>OTPCertificate = #'OTPCertificate'{}
DPAndCRLs = [{DP::#'DistributionPoint'{}, {DerCRL::der_encoded(), CRL::#'CertificateList'{}}}]
Options = proplists:proplist()
CRLStatus() = valid | {bad_cert, revocation_status_undetermined} | {bad_cert, {revoked, crl_reason()}}</pre>

<p>Performs CRL validation. It is intended to be called from the verify fun of <code class="bold_code"><a href="#pkix_path_validation-3">pkix_path_validation/3</a></code>.</p> <p>Available options:</p> <dl> <dt><strong>{update_crl, fun()}</strong></dt> <dd> <p>The fun has the following type specification:</p> <div class="example"><pre>fun(#'DistributionPoint'{}, #'CertificateList'{}) -&gt;
       #'CertificateList'{}</pre></div> <p>The fun uses the information in the distribution point to access the latest possible version of the CRL. If this fun is not specified, Public Key uses the default implementation: </p> <div class="example"><pre>fun(_DP, CRL) -&gt; CRL end</pre></div> </dd> <dt><strong>{issuer_fun, fun()}</strong></dt> <dd> <p>The fun has the following type specification:</p> <div class="example"><pre>
fun(#'DistributionPoint'{}, #'CertificateList'{},
    {rdnSequence,[#'AttributeTypeAndValue'{}]}, term()) -&gt;
	{ok, #'OTPCertificate'{}, [der_encoded]}</pre></div> <p>The fun returns the root certificate and certificate chain that has signed the CRL. </p> <div class="example"><pre>fun(DP, CRL, Issuer, UserState) -&gt; {ok, RootCert, CertChain}</pre></div> </dd> </dl>  <h3 id="pkix_crl_verify-2" class="code">pkix_crl_verify(CRL, Cert) -&gt; boolean()</h3>  <p>Types:</p>    <pre>CRL = der_encoded() | #'CertificateList'{}
Cert = der_encoded() | #'OTPCertificate'{}</pre>

<p>Verify that <code class="code">Cert</code> is the <code class="code">CRL</code> signer.</p>  <h3 id="pkix_dist_point-1" class="code">pkix_dist_point(Cert) -&gt; DistPoint</h3>  <p>Types:</p>    <pre>Cert = der_encoded() | #'OTPCertificate'{}
DistPoint = #'DistributionPoint'{}</pre>

<p>Creates a distribution point for CRLs issued by the same issuer as <code class="code">Cert</code>. Can be used as input to <code class="bold_code"><a href="#pkix_crls_validate-3">pkix_crls_validate/3</a></code> </p>  <h3 id="pkix_dist_points-1" class="code">pkix_dist_points(Cert) -&gt; DistPoints</h3>  <p>Types:</p>    <pre>Cert = der_encoded() | #'OTPCertificate'{}
DistPoints = [#'DistributionPoint'{}]</pre>

<p> Extracts distribution points from the certificates extensions.</p>  <h3 id="pkix_match_dist_point-2" class="code">pkix_match_dist_point(CRL, DistPoint) -&gt; boolean()</h3>  <p>Types:</p>    <pre>CRL = der_encoded() | #'CertificateList'{}
DistPoint = #'DistributionPoint'{}</pre>

<p>Checks whether the given distribution point matches the Issuing Distribution Point of the CRL, as described in RFC 5280. If the CRL doesn't have an Issuing Distribution Point extension, the distribution point always matches.</p>  <h3 id="pkix_sign-2" class="code">pkix_sign(#'OTPTBSCertificate'{}, Key) -&gt; der_encoded()</h3>  <p>Types:</p>   <pre>Key = rsa_private_key() | dsa_private_key()</pre>

<p>Signs an 'OTPTBSCertificate'. Returns the corresponding DER-encoded certificate.</p>  <h3 id="pkix_sign_types-1" class="code">pkix_sign_types(AlgorithmId) -&gt; {DigestType, SignatureType}</h3>  <p>Types:</p>  <pre>AlgorithmId = oid()</pre>
<p class="REFBODY">Signature OID from a certificate or a certificate revocation list.</p>    <pre>DigestType = rsa_digest_type() | dss_digest_type()
SignatureType = rsa | dsa | ecdsa</pre>

<p>Translates signature algorithm OID to Erlang digest and signature types. </p>  <h3 id="pkix_verify-2" class="code">pkix_verify(Cert, Key) -&gt; boolean()</h3>  <p>Types:</p>    <pre>Cert = der_encoded()
Key = rsa_public_key() | dsa_public_key() | ec_public_key()</pre>

<p>Verifies PKIX x.509 certificate signature.</p>  <h3 id="pkix_verify_hostname-3" class="code">pkix_verify_hostname(Cert, ReferenceIDs) -&gt; boolean()<br>pkix_verify_hostname(Cert, ReferenceIDs, Opts) -&gt; boolean()</h3>  <p>Types:</p>            <pre>Cert = der_encoded() | #'OTPCertificate'{}
ReferenceIDs = [ RefID ]
RefID = {IdType,string()}
IdType = dns_id | srv_id | uri_id
Opts = [ PvhOpt() ]
PvhOpt = [MatchOpt | FailCallBackOpt | FqdnExtractOpt]
MatchOpt = {fun(RefId | FQDN::string(), PresentedID) -&gt; boolean() | default}
PresentedID = {dNSName,string()} | {uniformResourceIdentifier,string()}
FailCallBackOpt = {fail_callback, fun(#'OTPCertificate'{}) -&gt; boolean()}
FqdnExtractOpt = {fqdn_fun, fun(RefID) -&gt; FQDN::string() | default | undefined}</pre>

<p>This function checks that the <i>Presented Identifier</i> (e.g hostname) in a peer certificate conforms with the Expected Identifier that the client wants to connect to. This functions is intended to be added as an extra client check to the peer certificate when performing <code class="bold_code">public_key:pkix_path_validation/3</code> </p> <p>See <code class="bold_code"><a href="https://tools.ietf.org/html/rfc6125" target="_blank">RFC 6125</a></code> for detailed information about hostname verification. The <code class="bold_code"><a href="../using_public_key/#verify_hostname">User's Manual</a></code> and <code class="bold_code"><a href="../using_public_key/#verify_hostname_examples">code examples</a></code> describes this function more detailed. </p>  <h3 id="sign-3" class="code">sign(Msg, DigestType, Key) -&gt; binary()</h3>  <p>Types:</p>  The <pre>Msg = binary() | {digest,binary()}</pre>
<code class="code">Msg</code> is either the binary "plain text" data to be signed or it is the hashed value of "plain text", that is, the digest.    <pre>DigestType = rsa_digest_type() | dss_digest_type() | ecdsa_digest_type()
Key = rsa_private_key() | dsa_private_key() | ec_private_key()</pre>

<p>Creates a digital signature.</p>  <h3 id="ssh_decode-2" class="code">ssh_decode(SshBin, Type) -&gt; [{public_key(), Attributes::list()}]</h3>  <p>Types:</p>  Example <pre>SshBin = binary()</pre>
<code class="code">{ok, SshBin} = file:read_file("known_hosts")</code>.  If <pre>Type = public_key | ssh_file()</pre>
<code class="code">Type</code> is <code class="code">public_key</code> the binary can be either an RFC4716 public key or an OpenSSH public key.  
<p>Decodes an SSH file-binary. In the case of <code class="code">known_hosts</code> or <code class="code">auth_keys</code>, the binary can include one or more lines of the file. Returns a list of public keys and their attributes, possible attribute values depends on the file type represented by the binary. </p> <dl> <dt><strong>RFC4716 attributes - see RFC 4716.</strong></dt> <dd><p>{headers, [{string(), utf8_string()}]}</p></dd> <dt><strong>auth_key attributes - see manual page for sshd.</strong></dt> <dd>{comment, string()}</dd> <dd>{options, [string()]}</dd> <dd><p>{bits, integer()} - In SSH version 1 files.</p></dd> <dt><strong>known_host attributes - see manual page for sshd.</strong></dt> <dd>{hostnames, [string()]}</dd> <dd>{comment, string()}</dd> <dd><p>{bits, integer()} - In SSH version 1 files.</p></dd> </dl>  <h3 id="ssh_encode-2" class="code">ssh_encode([{Key, Attributes}], Type) -&gt; binary()</h3>  <p>Types:</p>     <pre>Key = public_key()
Attributes = list()
Type = ssh_file()</pre>

<p>Encodes a list of SSH file entries (public keys and attributes) to a binary. Possible attributes depend on the file type, see <code class="bold_code"><a href="#ssh_decode-2">ssh_decode/2</a></code>.</p>  <h3 id="ssh_hostkey_fingerprint-2" class="code">ssh_hostkey_fingerprint(HostKey) -&gt; string()<br>ssh_hostkey_fingerprint(DigestType, HostKey) -&gt; string()<br>ssh_hostkey_fingerprint([DigestType], HostKey) -&gt; [string()]</h3>  <p>Types:</p>    <pre>Key = public_key()
DigestType = digest_type()</pre>

<p>Calculates a ssh fingerprint from a public host key as openssh does.</p> <p>The algorithm in <code class="code">ssh_hostkey_fingerprint/1</code> is md5 to be compatible with older ssh-keygen commands. The string from the second variant is prepended by the algorithm name in uppercase as in newer ssh-keygen commands.</p> <p>Examples:</p> <div class="example"><pre>
2&gt; public_key:ssh_hostkey_fingerprint(Key).    
"f5:64:a6:c1:5a:cb:9f:0a:10:46:a2:5c:3e:2f:57:84"

3&gt; public_key:ssh_hostkey_fingerprint(md5,Key).
"MD5:f5:64:a6:c1:5a:cb:9f:0a:10:46:a2:5c:3e:2f:57:84"

4&gt; public_key:ssh_hostkey_fingerprint(sha,Key).
"SHA1:bSLY/C4QXLDL/Iwmhyg0PGW9UbY"

5&gt; public_key:ssh_hostkey_fingerprint(sha256,Key).
"SHA256:aZGXhabfbf4oxglxltItWeHU7ub3Dc31NcNw2cMJePQ"

6&gt; public_key:ssh_hostkey_fingerprint([sha,sha256],Key).
["SHA1:bSLY/C4QXLDL/Iwmhyg0PGW9UbY",
 "SHA256:aZGXhabfbf4oxglxltItWeHU7ub3Dc31NcNw2cMJePQ"]
   </pre></div>  <h3 id="verify-4" class="code">verify(Msg, DigestType, Signature, Key) -&gt; boolean()</h3>  <p>Types:</p>  The <pre>Msg = binary() | {digest,binary()}</pre>
<code class="code">Msg</code> is either the binary "plain text" data or it is the hashed value of "plain text", that is, the digest.     <pre>DigestType = rsa_digest_type() | dss_digest_type() | ecdsa_digest_type()
Signature = binary()
Key = rsa_public_key() | dsa_public_key() | ec_public_key()</pre>

<p>Verifies a digital signature.</p>  <h3 id="short_name_hash-1" class="code">short_name_hash(Name) -&gt; string()</h3>  <p>Types:</p>   <pre>Name = issuer_name()</pre>

<p>Generates a short hash of an issuer name. The hash is returned as a string containing eight hexadecimal digits.</p> <p>The return value of this function is the same as the result of the commands <code class="code">openssl crl -hash</code> and <code class="code">openssl x509 -issuer_hash</code>, when passed the issuer name of a CRL or a certificate, respectively. This hash is used by the <code class="code">c_rehash</code> tool to maintain a directory of symlinks to CRL files, in order to facilitate looking up a CRL by its issuer name.</p>
<div class="_attribution">
  <p class="_attribution-p">
    © 1999–2016 Ericsson AB<br>Licensed under the Apache License, Version 2.0.<br>
    
  </p>
</div>

			</div>
		</div>
	</section>

	</div>
</body>
</html>
