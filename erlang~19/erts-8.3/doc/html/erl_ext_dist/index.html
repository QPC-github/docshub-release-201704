
<!DOCTYPE HTML>

<html lang="en">

<head>
  <meta charset="utf-8">
  <title>11. External Term Format - Erlang 19 - W3cubDocs</title>
  
  <meta name="description" content=" The external term format is mainly used in the distribution mechanism of Erlang. ">
  <meta name="keywords" content="external, term, format, -, erlang, erlang~19">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="http://docs.w3cub.com/erlang~19/erts-8.3/doc/html/erl_ext_dist/">
  <link href="/favicon.png" rel="icon">
  <link type="text/css" rel="stylesheet" href="/assets/application-50364fff564ce3b6327021805f3f00e2957b441cf27f576a7dd4ff63bbc47047.css">
  <script type="text/javascript" src="/assets/application-db64bfd54ceb42be11af7995804cf4902548419ceb79d509b0b7d62c22d98e6f.js"></script>
  <script src="/json/erlang~19.js"></script>
  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-71174418-1']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>


</head>

<body>
	<div class="_app">
	<header class="_header">
  
  <form class="_search">
    <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
    <a class="_search-clear"></a>
    <div class="_search-tag"></div>
  </form>
  
  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/erlang~19/" class="_nav-link" title="" style="margin-left:0;">Erlang 19</a></span>
  
  <nav class="_nav">
    <a href="/app/" class="_nav-link ">App</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		<div class="_list">
			
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<div class="_page _erlang">
				
<h1>11 External Term Format</h1> <h2 id="id98642">11.1 Introduction</h2> <p> The external term format is mainly used in the distribution mechanism of Erlang. </p> <p> As Erlang has a fixed number of types, there is no need for a programmer to define a specification for the external format used within some application. All Erlang terms have an external representation and the interpretation of the different terms is application-specific. </p> <p> In Erlang the BIF <code class="bold_code"><span class="code">erlang:term_to_binary/1,2</span></code> is used to convert a term into the external format. To convert binary data encoding to a term, the BIF <code class="bold_code"><span class="code">erlang:binary_to_term/1</span>c&gt;</code> is used. </p> <p> The distribution does this implicitly when sending messages across node boundaries. </p>  <p> The overall format of the term format is as follows: </p> <table> <tr> <td>1</td> <td>1</td> <td>N</td> </tr> <tr> <td><code class="code">131</code></td> <td><code class="code">Tag</code></td> <td><code class="code">Data</code></td> </tr> </table> <em>Table 11.1: Term Format</em> <div class="note"> <div class="label">Note</div> <div class="content">

<p> When messages are <code class="bold_code"><a href="../erl_dist_protocol/#connected_nodes">passed between connected nodes</a></code> and a <code class="bold_code"><a href="#distribution_header">distribution header</a></code> is used, the first byte containing the version number (131) is omitted from the terms that follow the distribution header. This is because the version number is implied by the version number in the distribution header. </p> </div> </div> <p> The compressed term format is as follows: </p> <table> <tr> <td>1</td> <td>1</td> <td>4</td> <td>N</td> </tr> <tr> <td><code class="code">131</code></td> <td><code class="code">80</code></td> <td><code class="code">UncompressedSize</code></td> <td><code class="code">Zlib-compressedData</code></td> </tr> </table> <em>Table 11.2: Compressed Term Format</em> <p> Uncompressed size (unsigned 32-bit integer in big-endian byte order) is the size of the data before it was compressed. The compressed data has the following format when it has been expanded: </p> <table> <tr> <td>1</td> <td>Uncompressed Size</td> </tr> <tr> <td><code class="code">Tag</code></td> <td><code class="code">Data</code></td> </tr> </table> <em>Table 11.3: Compressed Data Format when Expanded</em>  <div class="note"> <div class="label">Note</div> <div class="content">

<p>As from ERTS 5.10 (OTP R16) support for UTF-8 encoded atoms has been introduced in the external format. However, only characters that can be encoded using Latin-1 (ISO-8859-1) are currently supported in atoms. The support for UTF-8 encoded atoms in the external format has been implemented to be able to support all Unicode characters in atoms in <strong>some future release</strong>. Until full Unicode support for atoms has been introduced, it is an <strong>error</strong> to pass atoms containing characters that cannot be encoded in Latin-1, and <strong>the behavior is undefined</strong>.</p> <p>When distribution flag <code class="bold_code"><a href="../erl_dist_protocol/#dflags"><span class="code">DFLAG_UTF8_ATOMS</span></a></code> has been exchanged between both nodes in the <code class="bold_code"><a href="../erl_dist_protocol/#distribution_handshake">distribution handshake</a></code>, all atoms in the distribution header are encoded in UTF-8, otherwise in Latin-1. The two new tags <code class="bold_code"><a href="#ATOM_UTF8_EXT"><span class="code">ATOM_UTF8_EXT</span></a></code> and <code class="bold_code"><a href="#SMALL_ATOM_UTF8_EXT"><span class="code">SMALL_ATOM_UTF8_EXT</span></a></code> are only used if the distribution flag <code class="code">DFLAG_UTF8_ATOMS</code> has been exchanged between nodes, or if an atom containing characters that cannot be encoded in Latin-1 is encountered.</p> <p>The maximum number of allowed characters in an atom is 255. In the UTF-8 case, each character can need 4 bytes to be encoded.</p> </div> </div> <h2 id="id99007">11.2 Distribution Header</h2> <p id="distribution_header">  As from ERTS 5.7.2 the old atom cache protocol was dropped and a new one was introduced. This protocol introduced the distribution header. Nodes with an ERTS version earlier than 5.7.2 can still communicate with new nodes, but no distribution header and no atom cache are used.</p> <p> The distribution header only contains an atom cache reference section, but can in the future contain more information. The distribution header precedes one or more Erlang terms on the external format. For more information, see the documentation of the <code class="bold_code"><a href="../erl_dist_protocol/#connected_nodes">protocol between connected nodes</a></code> in the <code class="bold_code"><a href="../erl_dist_protocol/">distribution protocol</a></code> documentation. </p> <p> <code class="bold_code"><a href="#ATOM_CACHE_REF">ATOM_CACHE_REF</a></code> entries with corresponding <code class="code">AtomCacheReferenceIndex</code> in terms encoded on the external format following a distribution header refer to the atom cache references made in the distribution header. The range is 0 &lt;= <code class="code">AtomCacheReferenceIndex</code> &lt; 255, that is, at most 255 different atom cache references from the following terms can be made. </p> <p> The distribution header format is as follows: </p> <table> <tr> <td>1</td> <td>1</td> <td>1</td> <td>NumberOfAtomCacheRefs/2+1 | 0</td> <td>N | 0</td> </tr> <tr> <td><code class="code">131</code></td> <td><code class="code">68</code></td> <td><code class="code">NumberOfAtomCacheRefs</code></td> <td><code class="code">Flags</code></td> <td><code class="code">AtomCacheRefs</code></td> </tr> </table> <em>Table 11.4: Distribution Header Format</em> <p> <code class="code">Flags</code> consist of <code class="code">NumberOfAtomCacheRefs/2+1</code> bytes, unless <code class="code">NumberOfAtomCacheRefs</code> is <code class="code">0</code>. If <code class="code">NumberOfAtomCacheRefs</code> is <code class="code">0</code>, <code class="code">Flags</code> and <code class="code">AtomCacheRefs</code> are omitted. Each atom cache reference has a half byte flag field. Flags corresponding to a specific <code class="code">AtomCacheReferenceIndex</code> are located in flag byte number <code class="code">AtomCacheReferenceIndex/2</code>. Flag byte 0 is the first byte after the <code class="code">NumberOfAtomCacheRefs</code> byte. Flags for an even <code class="code">AtomCacheReferenceIndex</code> are located in the least significant half byte and flags for an odd <code class="code">AtomCacheReferenceIndex</code> are located in the most significant half byte. </p> <p> The flag field of an atom cache reference has the following format: </p> <table> <tr> <td>1 bit</td> <td>3 bits</td> </tr> <tr> <td><code class="code">NewCacheEntryFlag</code></td> <td><code class="code">SegmentIndex</code></td> </tr> </table> <em>Table 11.5: </em> <p> The most significant bit is the <code class="code">NewCacheEntryFlag</code>. If set, the corresponding cache reference is new. The three least significant bits are the <code class="code">SegmentIndex</code> of the corresponding atom cache entry. An atom cache consists of 8 segments, each of size 256, that is, an atom cache can contain 2048 entries. </p> <p> After flag fields for atom cache references, another half byte flag field is located with the following format: </p> <table> <tr> <td>3 bits</td> <td>1 bit</td> </tr> <tr> <td><code class="code">CurrentlyUnused</code></td> <td><code class="code">LongAtoms</code></td> </tr> </table> <em>Table 11.6: </em> <p> The least significant bit in that half byte is flag <code class="code">LongAtoms</code>. If it is set, 2 bytes are used for atom lengths instead of 1 byte in the distribution header. </p> <p> After the <code class="code">Flags</code> field follow the <code class="code">AtomCacheRefs</code>. The first <code class="code">AtomCacheRef</code> is the one corresponding to <code class="code">AtomCacheReferenceIndex</code> 0. Higher indices follow in sequence up to index <code class="code">NumberOfAtomCacheRefs - 1</code>. </p> <p> If the <code class="code">NewCacheEntryFlag</code> for the next <code class="code">AtomCacheRef</code> has been set, a <code class="code">NewAtomCacheRef</code> on the following format follows: </p> <table> <tr> <td>1</td> <td>1 | 2</td> <td>Length</td> </tr> <tr> <td><code class="code">InternalSegmentIndex</code></td> <td><code class="code">Length</code></td> <td><code class="code">AtomText</code></td> </tr> </table> <em>Table 11.7: </em> <p> <code class="code">InternalSegmentIndex</code> together with the <code class="code">SegmentIndex</code> completely identify the location of an atom cache entry in the atom cache. <code class="code">Length</code> is the number of bytes that <code class="code">AtomText</code> consists of. Length is a 2 byte big-endian integer if flag <code class="code">LongAtoms</code> has been set, otherwise a 1 byte integer. When distribution flag <code class="bold_code"><a href="../erl_dist_protocol/#dflags"><span class="code">DFLAG_UTF8_ATOMS</span></a></code> has been exchanged between both nodes in the <code class="bold_code"><a href="../erl_dist_protocol/#distribution_handshake">distribution handshake</a></code>, characters in <code class="code">AtomText</code> are encoded in UTF-8, otherwise in Latin-1. The following <code class="code">CachedAtomRef</code>s with the same <code class="code">SegmentIndex</code> and <code class="code">InternalSegmentIndex</code> as this <code class="code">NewAtomCacheRef</code> refer to this atom until a new <code class="code">NewAtomCacheRef</code> with the same <code class="code">SegmentIndex</code> and <code class="code">InternalSegmentIndex</code> appear. </p> <p> For more information on encoding of atoms, see the <code class="bold_code"><a href="#utf8_atoms">note on UTF-8 encoded atoms</a></code> in the beginning of this section. </p> <p> If the <code class="code">NewCacheEntryFlag</code> for the next <code class="code">AtomCacheRef</code> has not been set, a <code class="code">CachedAtomRef</code> on the following format follows: </p> <table> <tr> <td>1</td> </tr> <tr> <td><code class="code">InternalSegmentIndex</code></td> </tr> </table> <em>Table 11.8: </em> <p> <code class="code">InternalSegmentIndex</code> together with the <code class="code">SegmentIndex</code> identify the location of the atom cache entry in the atom cache. The atom corresponding to this <code class="code">CachedAtomRef</code> is the latest <code class="code">NewAtomCacheRef</code> preceding this <code class="code">CachedAtomRef</code> in another previously passed distribution header. </p> <h2 id="id99618"> 11.3 atom_cache_ref </h2> <table> <tr> <td>1</td> <td>1</td> </tr> <tr> <td><code class="code">82</code></td> <td><code class="code">AtomCacheReferenceIndex</code></td> </tr> </table> <em>Table 11.9: ATOM_CACHE_REF</em> <p> Refers to the atom with <code class="code">AtomCacheReferenceIndex</code> in the <code class="bold_code"><a href="#distribution_header">distribution header</a></code>. </p> <h2 id="id99695"> 11.4 small_integer_ext </h2> <table> <tr> <td>1</td> <td>1</td> </tr> <tr> <td><code class="code">97</code></td> <td><code class="code">Int</code></td> </tr> </table> <em>Table 11.10: SMALL_INTEGER_EXT</em> <p> Unsigned 8-bit integer. </p> <h2 id="id99762"> 11.5 integer_ext </h2> <table> <tr> <td>1</td> <td>4</td> </tr> <tr> <td><code class="code">98</code></td> <td><code class="code">Int</code></td> </tr> </table> <em>Table 11.11: INTEGER_EXT</em> <p> Signed 32-bit integer in big-endian format. </p> <h2 id="id99829"> 11.6 float_ext </h2> <table> <tr> <td>1</td> <td>31</td> </tr> <tr> <td><code class="code">99</code></td> <td><code class="code">Float string</code></td> </tr> </table> <em>Table 11.12: FLOAT_EXT</em> <p> A float is stored in string format. The format used in sprintf to format the float is "%.20e" (there are more bytes allocated than necessary). To unpack the float, use sscanf with format "%lf". </p> <p> This term is used in minor version 0 of the external format; it has been superseded by <code class="bold_code"><a href="#NEW_FLOAT_EXT"><span class="code">NEW_FLOAT_EXT</span></a></code>. </p> <h2 id="id99909"> 11.7 atom_ext </h2> <table> <tr> <td>1</td> <td>2</td> <td>Len</td> </tr> <tr> <td><code class="code">100</code></td> <td><code class="code">Len</code></td> <td><code class="code">AtomName</code></td> </tr> </table> <em>Table 11.13: ATOM_EXT</em> <p> An atom is stored with a 2 byte unsigned length in big-endian order, followed by <code class="code">Len</code> numbers of 8-bit Latin-1 characters that forms the <code class="code">AtomName</code>. The maximum allowed value for <code class="code">Len</code> is 255. </p> <h2 id="id100006"> 11.8 reference_ext </h2> <table> <tr> <td>1</td> <td>N</td> <td>4</td> <td>1</td> </tr> <tr> <td><code class="code">101</code></td> <td><code class="code">Node</code></td> <td><code class="code">ID</code></td> <td><code class="code">Creation</code></td> </tr> </table> <em>Table 11.14: REFERENCE_EXT</em> <p> Encodes a reference object (an object generated with <code class="bold_code">erlang:make_ref/0</code>). The <code class="code">Node</code> term is an encoded atom, that is, <code class="bold_code"><a href="#ATOM_EXT"><span class="code">ATOM_EXT</span></a></code>, <code class="bold_code"><a href="#SMALL_ATOM_EXT"><span class="code">SMALL_ATOM_EXT</span></a></code>, or <code class="bold_code"><a href="#ATOM_CACHE_REF"><span class="code">ATOM_CACHE_REF</span></a></code>. The <code class="code">ID</code> field contains a big-endian unsigned integer, but <strong>is to be regarded as uninterpreted data</strong>, as this field is node-specific. <code class="code">Creation</code> is a byte containing a node serial number, which makes it possible to separate old (crashed) nodes from a new one. </p> <p> In <code class="code">ID</code>, only 18 bits are significant; the rest are to be 0. In <code class="code">Creation</code>, only two bits are significant; the rest are to be 0. See <code class="bold_code"><a href="#NEW_REFERENCE_EXT"><span class="code">NEW_REFERENCE_EXT</span></a></code>. </p> <h2 id="id100173"> 11.9 port_ext </h2> <table> <tr> <td>1</td> <td>N</td> <td>4</td> <td>1</td> </tr> <tr> <td><code class="code">102</code></td> <td><code class="code">Node</code></td> <td><code class="code">ID</code></td> <td><code class="code">Creation</code></td> </tr> </table> <em>Table 11.15: PORT_EXT</em> <p> Encodes a port object (obtained from <code class="bold_code"><span class="code">erlang:open_port/2</span></code>). The <code class="code">ID</code> is a node-specific identifier for a local port. Port operations are not allowed across node boundaries. The <code class="code">Creation</code> works just like in <code class="bold_code"><a href="#REFERENCE_EXT"><span class="code">REFERENCE_EXT</span></a></code>. </p> <h2 id="id100300"> 11.10 pid_ext </h2> <table> <tr> <td>1</td> <td>N</td> <td>4</td> <td>4</td> <td>1</td> </tr> <tr> <td><code class="code">103</code></td> <td><code class="code">Node</code></td> <td><code class="code">ID</code></td> <td><code class="code">Serial</code></td> <td><code class="code">Creation</code></td> </tr> </table> <em>Table 11.16: PID_EXT</em> <p> Encodes a process identifier object (obtained from <code class="bold_code"><span class="code">erlang:spawn/3</span></code> or friends). The <code class="code">ID</code> and <code class="code">Creation</code> fields works just like in <code class="bold_code"><a href="#REFERENCE_EXT"><span class="code">REFERENCE_EXT</span></a></code>, while the <code class="code">Serial</code> field is used to improve safety. In <code class="code">ID</code>, only 15 bits are significant; the rest are to be 0. </p> <h2 id="id100449"> 11.11 small_tuple_ext </h2> <table> <tr> <td>1</td> <td>1</td> <td>N</td> </tr> <tr> <td><code class="code">104</code></td> <td><code class="code">Arity</code></td> <td><code class="code">Elements</code></td> </tr> </table> <em>Table 11.17: SMALL_TUPLE_EXT</em> <p> Encodes a tuple. The <code class="code">Arity</code> field is an unsigned byte that determines how many elements that follows in section <code class="code">Elements</code>. </p> <h2 id="id100542"> 11.12 large_tuple_ext </h2> <table> <tr> <td>1</td> <td>4</td> <td>N</td> </tr> <tr> <td><code class="code">105</code></td> <td><code class="code">Arity</code></td> <td><code class="code">Elements</code></td> </tr> </table> <em>Table 11.18: LARGE_TUPLE_EXT</em> <p> Same as <code class="bold_code"><a href="#SMALL_TUPLE_EXT"><span class="code">SMALL_TUPLE_EXT</span></a></code> except that <code class="code">Arity</code> is an unsigned 4 byte integer in big-endian format. </p> <h2 id="id100638"> 11.13 map_ext </h2> <table> <tr> <td>1</td> <td>4</td> <td>N</td> </tr> <tr> <td><code class="code">116</code></td> <td><code class="code">Arity</code></td> <td><code class="code">Pairs</code></td> </tr> </table> <em>Table 11.19: MAP_EXT</em> <p> Encodes a map. The <code class="code">Arity</code> field is an unsigned 4 byte integer in big-endian format that determines the number of key-value pairs in the map. Key and value pairs (<code class="code">Ki =&gt; Vi</code>) are encoded in section <code class="code">Pairs</code> in the following order: <code class="code">K1, V1, K2, V2,..., Kn, Vn</code>. Duplicate keys are <strong>not allowed</strong> within the same map. </p> <p><strong>As from </strong>Erlang/OTP 17.0</p> <h2 id="id100749"> 11.14 nil_ext </h2> <table> <tr> <td>1</td> </tr> <tr> <td><code class="code">106</code></td> </tr> </table> <em>Table 11.20: NIL_EXT</em> <p> The representation for an empty list, that is, the Erlang syntax <code class="code">[]</code>. </p> <h2 id="id100802"> 11.15 string_ext </h2> <table> <tr> <td>1</td> <td>2</td> <td>Len</td> </tr> <tr> <td><code class="code">107</code></td> <td><code class="code">Length</code></td> <td><code class="code">Characters</code></td> </tr> </table> <em>Table 11.21: STRING_EXT</em> <p> String does <strong>not</strong> have a corresponding Erlang representation, but is an optimization for sending lists of bytes (integer in the range 0-255) more efficiently over the distribution. As field <code class="code">Length</code> is an unsigned 2 byte integer (big-endian), implementations must ensure that lists longer than 65535 elements are encoded as <code class="bold_code"><a href="#LIST_EXT"><span class="code">LIST_EXT</span></a></code>. </p> <h2 id="id100904"> 11.16 list_ext </h2> <table> <tr> <td>1</td> <td>4</td> <td> </td> <td> </td> </tr> <tr> <td><code class="code">108</code></td> <td><code class="code">Length</code></td> <td><code class="code">Elements</code></td> <td><code class="code">Tail</code></td> </tr> </table> <em>Table 11.22: LIST_EXT</em> <p> <code class="code">Length</code> is the number of elements that follows in section <code class="code">Elements</code>. <code class="code">Tail</code> is the final tail of the list; it is <code class="bold_code"><a href="#NIL_EXT"><span class="code">NIL_EXT</span></a></code> for a proper list, but can be any type if the list is improper (for example, <code class="code">[a|b]</code>). </p> <h2 id="id101029"> 11.17 binary_ext </h2> <table> <tr> <td>1</td> <td>4</td> <td>Len</td> </tr> <tr> <td><code class="code">109</code></td> <td><code class="code">Len</code></td> <td><code class="code">Data</code></td> </tr> </table> <em>Table 11.23: BINARY_EXT</em> <p> Binaries are generated with bit syntax expression or with <code class="bold_code"><span class="code">erlang:list_to_binary/1</span></code>, <code class="bold_code"><span class="code">erlang:term_to_binary/1</span></code>, or as input from binary ports. The <code class="code">Len</code> length field is an unsigned 4 byte integer (big-endian). </p> <h2 id="id101135"> 11.18 small_big_ext </h2> <table> <tr> <td>1</td> <td>1</td> <td>1</td> <td>n</td> </tr> <tr> <td><code class="code">110</code></td> <td><code class="code">n</code></td> <td><code class="code">Sign</code></td> <td> <code class="code">d(0)</code> ... <code class="code">d(n-1)</code> </td> </tr> </table> <em>Table 11.24: SMALL_BIG_EXT</em> <p> Bignums are stored in unary form with a <code class="code">Sign</code> byte, that is, 0 if the binum is positive and 1 if it is negative. The digits are stored with the least significant byte stored first. To calculate the integer, the following formula can be used: </p> <p><code class="code">B</code> = 256<br> <code class="code">(d0*B^0 + d1*B^1 + d2*B^2 + ... d(N-1)*B^(n-1))</code> </p> <h2 id="id101259"> 11.19 large_big_ext </h2> <table> <tr> <td>1</td> <td>4</td> <td>1</td> <td>n</td> </tr> <tr> <td><code class="code">111</code></td> <td><code class="code">n</code></td> <td><code class="code">Sign</code></td> <td> <code class="code">d(0)</code> ... <code class="code">d(n-1)</code> </td> </tr> </table> <em>Table 11.25: LARGE_BIG_EXT</em> <p> Same as <code class="bold_code"><a href="#SMALL_BIG_EXT"><span class="code">SMALL_BIG_EXT</span></a></code> except that the length field is an unsigned 4 byte integer. </p> <h2 id="id101374"> 11.20 new_reference_ext </h2> <table> <tr> <td>1</td> <td>2</td> <td>N</td> <td>1</td> <td>N'</td> </tr> <tr> <td><code class="code">114</code></td> <td><code class="code">Len</code></td> <td><code class="code">Node</code></td> <td><code class="code">Creation</code></td> <td><code class="code">ID ...</code></td> </tr> </table> <em>Table 11.26: NEW_REFERENCE_EXT</em> <p> <code class="code">Node</code> and <code class="code">Creation</code> are as in <code class="bold_code"><a href="#REFERENCE_EXT"><span class="code">REFERENCE_EXT</span></a></code>. </p> <p> <code class="code">ID</code> contains a sequence of big-endian unsigned integers (4 bytes each, so <code class="code">N'</code> is a multiple of 4), but is to be regarded as uninterpreted data. </p> <p> <code class="code">N'</code> = 4 * <code class="code">Len</code>. </p> <p> In the first word (4 bytes) of <code class="code">ID</code>, only 18 bits are significant, the rest are to be 0. In <code class="code">Creation</code>, only two bits are significant, the rest are to be 0. </p> <p> <code class="code">NEW_REFERENCE_EXT</code> was introduced with distribution version 4. In version 4, <code class="code">N'</code> is to be at most 12. </p> <p> See <code class="bold_code"><a href="#REFERENCE_EXT"><span class="code">REFERENCE_EXT</span></a></code>. </p> <h2 id="id101566"> 11.21 small_atom_ext </h2> <table> <tr> <td>1</td> <td>1</td> <td>Len</td> </tr> <tr> <td><code class="code">115</code></td> <td><code class="code">Len</code></td> <td><code class="code">AtomName</code></td> </tr> </table> <em>Table 11.27: SMALL_ATOM_EXT</em> <p> An atom is stored with a 1 byte unsigned length, followed by <code class="code">Len</code> numbers of 8-bit Latin-1 characters that forms the <code class="code">AtomName</code>. Longer atoms can be represented by <code class="bold_code"><a href="#ATOM_EXT"><span class="code">ATOM_EXT</span></a></code>. </p> <div class="note"> <div class="label">Note</div> <div class="content">

<p> <code class="code">SMALL_ATOM_EXT</code> was introduced in ERTS 5.7.2 and require an exchange of distribution flag <code class="bold_code"><a href="../erl_dist_protocol/#dflags"><span class="code">DFLAG_SMALL_ATOM_TAGS</span></a></code> in the <code class="bold_code"><a href="../erl_dist_protocol/#distribution_handshake">distribution handshake</a></code>. </p> </div> </div> <h2 id="id101693"> 11.22 fun_ext </h2> <table> <tr> <td>1</td> <td>4</td> <td>N1</td> <td>N2</td> <td>N3</td> <td>N4</td> <td>N5</td> </tr> <tr> <td><code class="code">117</code></td> <td><code class="code">NumFree</code></td> <td><code class="code">Pid</code></td> <td><code class="code">Module</code></td> <td><code class="code">Index</code></td> <td><code class="code">Uniq</code></td> <td><code class="code">Free vars ...</code></td> </tr> </table> <em>Table 11.28: FUN_EXT</em> <dl> <dt><strong><code class="code">Pid</code></strong></dt> <dd> <p>A process identifier as in <code class="bold_code"><a href="#PID_EXT"><span class="code">PID_EXT</span></a></code>. Represents the process in which the fun was created. </p> </dd> <dt><strong><code class="code">Module</code></strong></dt> <dd> <p>Encoded as an atom, using <code class="bold_code"><a href="#ATOM_EXT"><span class="code">ATOM_EXT</span></a></code>, <code class="bold_code"><a href="#SMALL_ATOM_EXT"><span class="code">SMALL_ATOM_EXT</span></a></code>, or <code class="bold_code"><a href="#ATOM_CACHE_REF"><span class="code">ATOM_CACHE_REF</span></a></code>. This is the module that the fun is implemented in. </p> </dd> <dt><strong><code class="code">Index</code></strong></dt> <dd> <p>An integer encoded using <code class="bold_code"><a href="#SMALL_INTEGER_EXT"><span class="code">SMALL_INTEGER_EXT</span></a></code> or <code class="bold_code"><a href="#INTEGER_EXT"><span class="code">INTEGER_EXT</span></a></code>. It is typically a small index into the module's fun table. </p> </dd> <dt><strong><code class="code">Uniq</code></strong></dt> <dd> <p>An integer encoded using <code class="bold_code"><a href="#SMALL_INTEGER_EXT"><span class="code">SMALL_INTEGER_EXT</span></a></code> or <code class="bold_code"><a href="#INTEGER_EXT"><span class="code">INTEGER_EXT</span></a></code>. <code class="code">Uniq</code> is the hash value of the parse for the fun. </p> </dd> <dt><strong><code class="code">Free vars</code></strong></dt> <dd> <p><code class="code">NumFree</code> number of terms, each one encoded according to its type. </p> </dd> </dl> <h2 id="id101978"> 11.23 new_fun_ext </h2> <table> <tr> <td>1</td> <td>4</td> <td>1</td> <td>16</td> <td>4</td> <td>4</td> <td>N1</td> <td>N2</td> <td>N3</td> <td>N4</td> <td>N5</td> </tr> <tr> <td><code class="code">112</code></td> <td><code class="code">Size</code></td> <td><code class="code">Arity</code></td> <td><code class="code">Uniq</code></td> <td><code class="code">Index</code></td> <td><code class="code">NumFree</code></td> <td><code class="code">Module</code></td> <td><code class="code">OldIndex</code></td> <td><code class="code">OldUniq</code></td> <td><code class="code">Pid</code></td> <td><code class="code">Free Vars</code></td> </tr> </table> <em>Table 11.29: NEW_FUN_EXT</em> <p> This is the new encoding of internal funs: <code class="code">fun F/A</code> and <code class="code">fun(Arg1,..) -&gt; ... end</code>. </p> <dl> <dt><strong><code class="code">Size</code></strong></dt> <dd> <p>The total number of bytes, including field <code class="code">Size</code>.</p> </dd> <dt><strong><code class="code">Arity</code></strong></dt> <dd> <p>The arity of the function implementing the fun.</p> </dd> <dt><strong><code class="code">Uniq</code></strong></dt> <dd> <p>The 16 bytes MD5 of the significant parts of the Beam file.</p> </dd> <dt><strong><code class="code">Index</code></strong></dt> <dd> <p>An index number. Each fun within a module has an unique index. <code class="code">Index</code> is stored in big-endian byte order. </p> </dd> <dt><strong><code class="code">NumFree</code></strong></dt> <dd> <p>The number of free variables.</p> </dd> <dt><strong><code class="code">Module</code></strong></dt> <dd> <p>Encoded as an atom, using <code class="bold_code"><a href="#ATOM_EXT"><span class="code">ATOM_EXT</span></a></code>, <code class="bold_code"><a href="#SMALL_ATOM_EXT"><span class="code">SMALL_ATOM_EXT</span></a></code>, or <code class="bold_code"><a href="#ATOM_CACHE_REF"><span class="code">ATOM_CACHE_REF</span></a></code>. Is the module that the fun is implemented in. </p> </dd> <dt><strong><code class="code">OldIndex</code></strong></dt> <dd> <p>An integer encoded using <code class="bold_code"><a href="#SMALL_INTEGER_EXT"><span class="code">SMALL_INTEGER_EXT</span></a></code> or <code class="bold_code"><a href="#INTEGER_EXT"><span class="code">INTEGER_EXT</span></a></code>. Is typically a small index into the module's fun table. </p> </dd> <dt><strong><code class="code">OldUniq</code></strong></dt> <dd> <p>An integer encoded using <code class="bold_code"><a href="#SMALL_INTEGER_EXT"><span class="code">SMALL_INTEGER_EXT</span></a></code> or <code class="bold_code"><a href="#INTEGER_EXT"><span class="code">INTEGER_EXT</span></a></code>. <code class="code">Uniq</code> is the hash value of the parse tree for the fun. </p> </dd> <dt><strong><code class="code">Pid</code></strong></dt> <dd> <p>A process identifier as in <code class="bold_code"><a href="#PID_EXT"><span class="code">PID_EXT</span></a></code>. Represents the process in which the fun was created. </p> </dd> <dt><strong><code class="code">Free vars</code></strong></dt> <dd> <p><code class="code">NumFree</code> number of terms, each one encoded according to its type. </p> </dd> </dl> <h2 id="id102416"> 11.24 export_ext </h2> <table> <tr> <td>1</td> <td>N1</td> <td>N2</td> <td>N3</td> </tr> <tr> <td><code class="code">113</code></td> <td><code class="code">Module</code></td> <td><code class="code">Function</code></td> <td><code class="code">Arity</code></td> </tr> </table> <em>Table 11.30: EXPORT_EXT</em> <p> This term is the encoding for external funs: <code class="code">fun M:F/A</code>. </p> <p> <code class="code">Module</code> and <code class="code">Function</code> are atoms (encoded using <code class="bold_code"><a href="#ATOM_EXT"><span class="code">ATOM_EXT</span></a></code>, <code class="bold_code"><a href="#SMALL_ATOM_EXT"><span class="code">SMALL_ATOM_EXT</span></a></code>, or <code class="bold_code"><a href="#ATOM_CACHE_REF"><span class="code">ATOM_CACHE_REF</span></a></code>). </p> <p> <code class="code">Arity</code> is an integer encoded using <code class="bold_code"><a href="#SMALL_INTEGER_EXT"><span class="code">SMALL_INTEGER_EXT</span></a></code>. </p> <h2 id="id102570"> 11.25 bit_binary_ext </h2> <table> <tr> <td>1</td> <td>4</td> <td>1</td> <td>Len</td> </tr> <tr> <td><code class="code">77</code></td> <td><code class="code">Len</code></td> <td><code class="code">Bits</code></td> <td><code class="code">Data</code></td> </tr> </table> <em>Table 11.31: BIT_BINARY_EXT</em> <p> This term represents a bitstring whose length in bits does not have to be a multiple of 8. The <code class="code">Len</code> field is an unsigned 4 byte integer (big-endian). The <code class="code">Bits</code> field is the number of bits (1-8) that are used in the last byte in the data field, counting from the most significant bit to the least significant. </p> <h2 id="id102682"> 11.26 new_float_ext </h2> <table> <tr> <td>1</td> <td>8</td> </tr> <tr> <td><code class="code">70</code></td> <td><code class="code">IEEE float</code></td> </tr> </table> <em>Table 11.32: NEW_FLOAT_EXT</em> <p> A float is stored as 8 bytes in big-endian IEEE format. </p> <p> This term is used in minor version 1 of the external format. </p> <h2 id="id102754"> 11.27 atom_utf8_ext </h2> <table> <tr> <td>1</td> <td>2</td> <td>Len</td> </tr> <tr> <td><code class="code">118</code></td> <td><code class="code">Len</code></td> <td><code class="code">AtomName</code></td> </tr> </table> <em>Table 11.33: ATOM_UTF8_EXT</em> <p> An atom is stored with a 2 byte unsigned length in big-endian order, followed by <code class="code">Len</code> bytes containing the <code class="code">AtomName</code> encoded in UTF-8. </p> <p> For more information on encoding of atoms, see the <code class="bold_code"><a href="#utf8_atoms">note on UTF-8 encoded atoms</a></code> in the beginning of this section. </p> <h2 id="id102857"> 11.28 small_atom_utf8_ext </h2> <table> <tr> <td>1</td> <td>1</td> <td>Len</td> </tr> <tr> <td><code class="code">119</code></td> <td><code class="code">Len</code></td> <td><code class="code">AtomName</code></td> </tr> </table> <em>Table 11.34: SMALL_ATOM_UTF8_EXT</em> <p> An atom is stored with a 1 byte unsigned length, followed by <code class="code">Len</code> bytes containing the <code class="code">AtomName</code> encoded in UTF-8. Longer atoms encoded in UTF-8 can be represented using <code class="bold_code"><a href="#ATOM_UTF8_EXT"><span class="code">ATOM_UTF8_EXT</span></a></code>. </p> <p> For more information on encoding of atoms, see the <code class="bold_code"><a href="#utf8_atoms">note on UTF-8 encoded atoms</a></code> in the beginning of this section. </p>
<div class="_attribution">
  <p class="_attribution-p">
    © 1999–2016 Ericsson AB<br>Licensed under the Apache License, Version 2.0.<br>
    
  </p>
</div>

			</div>
		</div>
	</section>

	</div>
</body>
</html>
