
<!DOCTYPE HTML>

<html lang="en">

<head>
  <meta charset="utf-8">
  <title>Erlang - Erlang 19 - W3cubDocs</title>
  
  <meta name="description" content=" erlang ">
  <meta name="keywords" content="erlang, -, erlang~19">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="http://docs.w3cub.com/erlang~19/erts-8.3/doc/html/erlang/">
  <link href="/favicon.png" rel="icon">
  <link type="text/css" rel="stylesheet" href="/assets/application-50364fff564ce3b6327021805f3f00e2957b441cf27f576a7dd4ff63bbc47047.css">
  <script type="text/javascript" src="/assets/application-db64bfd54ceb42be11af7995804cf4902548419ceb79d509b0b7d62c22d98e6f.js"></script>
  <script src="/json/erlang~19.js"></script>
  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-71174418-1']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>


</head>

<body>
	<div class="_app">
	<header class="_header">
  
  <form class="_search">
    <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
    <a class="_search-clear"></a>
    <div class="_search-tag"></div>
  </form>
  
  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/erlang~19/" class="_nav-link" title="" style="margin-left:0;">Erlang 19</a></span>
  
  <nav class="_nav">
    <a href="/app/" class="_nav-link ">App</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		<div class="_list">
			
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<div class="_page _erlang">
				
<h1>erlang</h1> <h2>Module</h2> <p class="REFBODY">erlang</p> <h2>Module summary</h2> <p class="REFBODY">The Erlang BIFs.</p> <h2>Description</h2> 
<p>By convention, most Built-In Functions (BIFs) are included in this module. Some of the BIFs are viewed more or less as part of the Erlang programming language and are <strong>auto-imported</strong>. Thus, it is not necessary to specify the module name. For example, the calls <code class="code">atom_to_list(Erlang)</code> and <code class="code">erlang:atom_to_list(Erlang)</code> are identical.</p> <p>Auto-imported BIFs are listed without module prefix. BIFs listed with module prefix are not auto-imported.</p> <p>BIFs can fail for various reasons. All BIFs fail with reason <code class="code">badarg</code> if they are called with arguments of an incorrect type. The other reasons are described in the description of each individual BIF.</p> <p>Some BIFs can be used in guard tests and are marked with "Allowed in guard tests".</p>  <h2>Data types</h2> <h3 id="type-ext_binary" class="code">ext_binary()</h3> 
<p>A binary data object, structured according to the Erlang external term format.</p>  <h3 class="code">message_queue_data() = off_heap | on_heap</h3> 
<p>See <code class="bold_code"><a href="#process_flag_message_queue_data"><span class="code">process_flag(message_queue_data, MQD)</span></a></code>.</p>  <h3 class="code">timestamp() = <br>    {MegaSecs :: integer() &gt;= 0,<br>     Secs :: integer() &gt;= 0,<br>     MicroSecs :: integer() &gt;= 0}</h3> 
<p>See <code class="bold_code"><a href="#timestamp-0"><span class="code">erlang:timestamp/0</span></a></code>.</p>  <h3 class="code">time_unit() = <br>    integer() &gt;= 1 |<br>    second |<br>    millisecond |<br>    microsecond |<br>    nanosecond |<br>    native |<br>    perf_counter |<br>    <a href="#type-deprecated_time_unit">deprecated_time_unit()</a>
</h3> 
<p>Supported time unit representations:</p> <dl> <dt><strong><code class="code">PartsPerSecond :: integer() &gt;= 1</code></strong></dt> <dd> <p>Time unit expressed in parts per second. That is, the time unit equals <code class="code">1/PartsPerSecond</code> second.</p> </dd> <dt><strong><code class="code">second</code></strong></dt> <dd> <p>Symbolic representation of the time unit represented by the integer <code class="code">1</code>.</p> </dd> <dt><strong><code class="code">millisecond</code></strong></dt> <dd> <p>Symbolic representation of the time unit represented by the integer <code class="code">1000</code>.</p> </dd> <dt><strong><code class="code">microsecond</code></strong></dt> <dd> <p>Symbolic representation of the time unit represented by the integer <code class="code">1000000</code>.</p> </dd> <dt><strong><code class="code">nanosecond</code></strong></dt> <dd> <p>Symbolic representation of the time unit represented by the integer <code class="code">1000000000</code>.</p> </dd> <dt><strong><code class="code">native</code></strong></dt> <dd> <p>Symbolic representation of the native time unit used by the Erlang runtime system.</p> <p>The <code class="code">native</code> time unit is determined at runtime system start, and remains the same until the runtime system terminates. If a runtime system is stopped and then started again (even on the same machine), the <code class="code">native</code> time unit of the new runtime system instance can differ from the <code class="code">native</code> time unit of the old runtime system instance.</p> <p>One can get an approximation of the <code class="code">native</code> time unit by calling <code class="bold_code"><span class="code">erlang:convert_time_unit(1, second, native)</span></code>. The result equals the number of whole <code class="code">native</code> time units per second. If the number of <code class="code">native</code> time units per second does not add up to a whole number, the result is rounded downwards.</p> <div class="note"> <div class="label">Note</div> <div class="content">

<p>The value of the <code class="code">native</code> time unit gives you more or less no information about the quality of time values. It sets a limit for the <code class="bold_code"><a href="../time_correction/#Time_Resolution">resolution</a></code> and for the <code class="bold_code"><a href="../time_correction/#Time_Precision">precision</a></code> of time values, but it gives no information about the <code class="bold_code"><a href="../time_correction/#Time_Accuracy">accuracy</a></code> of time values. The resolution of the <code class="code">native</code> time unit and the resolution of time values can differ significantly.</p> </div> </div> </dd> <dt><strong><code class="code">perf_counter</code></strong></dt> <dd> <p>Symbolic representation of the performance counter time unit used by the Erlang runtime system.</p> <p>The <code class="code">perf_counter</code> time unit behaves much in the same way as the <code class="code">native</code> time unit. That is, it can differ between runtime restarts. To get values of this type, call <code class="bold_code"><span class="code">os:perf_counter/0</span></code>.</p> </dd> <dt><strong><code class="bold_code"><a href="#type_deprecated_time_unit"><span class="code">deprecated_time_unit()</span></a></code></strong></dt> <dd><p> Deprecated symbolic representations kept for backwards-compatibility. </p></dd> </dl> <p>The <code class="code">time_unit/0</code> type can be extended. To convert time values between time units, use <code class="bold_code"><a href="#convert_time_unit-3"><span class="code">erlang:convert_time_unit/3</span></a></code>.</p>  <h3 class="code">deprecated_time_unit() = <br>    seconds | milli_seconds | micro_seconds | nano_seconds</h3> 
<p>The <code class="bold_code"><a href="#type_time_unit"><span class="code">time_unit()</span></a></code> type also consist of the following <strong>deprecated</strong> symbolic time units:</p> <dl> <dt><strong><code class="code">seconds</code></strong></dt> <dd><p>Same as <code class="bold_code"><a href="#type_time_unit"><span class="code">second</span></a></code>.</p></dd> <dt><strong><code class="code">milli_seconds</code></strong></dt> <dd><p>Same as <code class="bold_code"><a href="#type_time_unit"><span class="code">millisecond</span></a></code>.</p></dd> <dt><strong><code class="code">micro_seconds</code></strong></dt> <dd><p>Same as <code class="bold_code"><a href="#type_time_unit"><span class="code">microsecond</span></a></code>.</p></dd> <dt><strong><code class="code">nano_seconds</code></strong></dt> <dd><p>Same as <code class="bold_code"><a href="#type_time_unit"><span class="code">nanosecond</span></a></code>.</p></dd> </dl>  <h2>Exports</h2> <h3 id="abs-1" class="code">abs(Float) -&gt; float()<br>abs(Int) -&gt; integer() &gt;= 0</h3> <p>Types:</p>    <pre>Int = integer()</pre>
<p>Types:</p>    <pre>Float = float()
Int = integer()</pre>

<p>Returns an integer or float that is the arithmetical absolute value of <code class="code">Float</code> or <code class="code">Int</code>, for example:</p> <div class="example"><pre>
&gt; abs(-3.33).
3.33
&gt; abs(-3).
3</pre></div> <p>Allowed in guard tests.</p>  <h3 id="adler32-1" class="code">erlang:adler32(Data) -&gt; integer() &gt;= 0</h3> <p>Types:</p>   <pre>Data = iodata()</pre>

<p>Computes and returns the adler32 checksum for <code class="code">Data</code>.</p>  <h3 id="adler32-2" class="code">erlang:adler32(OldAdler, Data) -&gt; integer() &gt;= 0</h3> <p>Types:</p>    <pre>OldAdler = integer() &gt;= 0
Data = iodata()</pre>

<p>Continues computing the adler32 checksum by combining the previous checksum, <code class="code">OldAdler</code>, with the checksum of <code class="code">Data</code>.</p> <p>The following code:</p> <div class="example"><pre>
X = erlang:adler32(Data1),
Y = erlang:adler32(X,Data2).</pre></div> <p>assigns the same value to <code class="code">Y</code> as this:</p> <div class="example"><pre>
Y = erlang:adler32([Data1,Data2]).</pre></div>  <h3 id="adler32_combine-3" class="code">erlang:adler32_combine(FirstAdler, SecondAdler, SecondSize) -&gt;<br>                          integer() &gt;= 0</h3> <p>Types:</p>     <pre>FirstAdler = SecondAdler = SecondSize = integer() &gt;= 0</pre>

<p>Combines two previously computed adler32 checksums. This computation requires the size of the data object for the second checksum to be known.</p> <p>The following code:</p> <div class="example"><pre>
Y = erlang:adler32(Data1),
Z = erlang:adler32(Y,Data2).</pre></div> <p>assigns the same value to <code class="code">Z</code> as this:</p> <div class="example"><pre>
X = erlang:adler32(Data1),
Y = erlang:adler32(Data2),
Z = erlang:adler32_combine(X,Y,iolist_size(Data2)).</pre></div>  <h3 id="append_element-2" class="code">erlang:append_element(Tuple1, Term) -&gt; Tuple2</h3> <p>Types:</p>     <pre>Tuple1 = Tuple2 = tuple()

Term = term()</pre>

<p>Returns a new tuple that has one element more than <code class="code">Tuple1</code>, and contains the elements in <code class="code">Tuple1</code> followed by <code class="code">Term</code> as the last element. Semantically equivalent to <code class="code">list_to_tuple(tuple_to_list(Tuple1) ++ [Term])</code>, but much faster. Example:</p> <div class="example"><pre>
&gt; erlang:append_element({one, two}, three).
{one,two,three}</pre></div>  <h3 id="apply-2" class="code">apply(Fun, Args) -&gt; term()</h3> <p>Types:</p>    <pre>Fun = function()
Args = [term()]</pre>

<p>Calls a fun, passing the elements in <code class="code">Args</code> as arguments.</p> <p>If the number of elements in the arguments are known at compile time, the call is better written as <code class="code">Fun(Arg1, Arg2, ... ArgN)</code>.</p> <div class="warning"> <div class="label">Warning</div> <div class="content">

<p>Earlier, <code class="code">Fun</code> could also be specified as <code class="code">{Module, Function}</code>, equivalent to <code class="code">apply(Module, Function, Args)</code>. <strong>This use is deprecated and will stop working in a future release.</strong></p> </div> </div>  <h3 id="apply-3" class="code">apply(Module, Function, Args) -&gt; term()</h3> <p>Types:</p>     <pre>Module = module()
Function = atom()
Args = [term()]</pre>

<p>Returns the result of applying <code class="code">Function</code> in <code class="code">Module</code> to <code class="code">Args</code>. The applied function must be exported from <code class="code">Module</code>. The arity of the function is the length of <code class="code">Args</code>. Example:</p> <div class="example"><pre>
&gt; apply(lists, reverse, [[a, b, c]]).
[c,b,a]
&gt; apply(erlang, atom_to_list, ['Erlang']).
"Erlang"</pre></div> <p>If the number of arguments are known at compile time, the call is better written as <code class="code">Module:Function(Arg1, Arg2, ..., ArgN)</code>.</p> <p>Failure: <code class="bold_code"><span class="code">error_handler:undefined_function/3</span></code> is called if the applied function is not exported. The error handler can be redefined (see <code class="bold_code"><a href="#process_flag-2"><span class="code">process_flag/2</span></a></code>). If <code class="code">error_handler</code> is undefined, or if the user has redefined the default <code class="code">error_handler</code> so the replacement module is undefined, an error with reason <code class="code">undef</code> is generated.</p>  <h3 id="atom_to_binary-2" class="code">atom_to_binary(Atom, Encoding) -&gt; binary()</h3> <p>Types:</p>    <pre>Atom = atom()
Encoding = latin1 | unicode | utf8</pre>

<p>Returns a binary corresponding to the text representation of <code class="code">Atom</code>. If <code class="code">Encoding</code> is <code class="code">latin1</code>, one byte exists for each character in the text representation. If <code class="code">Encoding</code> is <code class="code">utf8</code> or <code class="code">unicode</code>, the characters are encoded using UTF-8 (that is, characters from 128 through 255 are encoded in two bytes).</p> <div class="note"> <div class="label">Note</div> <div class="content">

<p><code class="code">atom_to_binary(Atom, latin1)</code> never fails, as the text representation of an atom can only contain characters from 0 through 255. In a future release, the text representation of atoms can be allowed to contain any Unicode character and <code class="code">atom_to_binary(Atom, latin1)</code> then fails if the text representation for <code class="code">Atom</code> contains a Unicode character &gt; 255.</p> </div> </div> <p>Example:</p> <div class="example"><pre>
&gt; atom_to_binary('Erlang', latin1).
&lt;&lt;"Erlang"&gt;&gt;</pre></div>  <h3 id="atom_to_list-1" class="code">atom_to_list(Atom) -&gt; string()</h3> <p>Types:</p>   <pre>Atom = atom()</pre>

<p>Returns a string corresponding to the text representation of <code class="code">Atom</code>, for example:</p> <div class="example"><pre>
&gt; atom_to_list('Erlang').
"Erlang"</pre></div>  <h3 id="binary_part-2" class="code">binary_part(Subject, PosLen) -&gt; binary()</h3> <p>Types:</p>    <pre>Subject = binary()
PosLen = {Start :: integer() &gt;= 0, Length :: integer()}</pre>

<p>Extracts the part of the binary described by <code class="code">PosLen</code>.</p> <p>Negative length can be used to extract bytes at the end of a binary, for example:</p> <div class="example"><pre>
1&gt; Bin = &lt;&lt;1,2,3,4,5,6,7,8,9,10&gt;&gt;.
2&gt; binary_part(Bin,{byte_size(Bin), -5}).
&lt;&lt;6,7,8,9,10&gt;&gt;</pre></div> <p>Failure: <code class="code">badarg</code> if <code class="code">PosLen</code> in any way references outside the binary.</p> <p><code class="code">Start</code> is zero-based, that is:</p> <div class="example"><pre>
1&gt; Bin = &lt;&lt;1,2,3&gt;&gt;
2&gt; binary_part(Bin,{0,2}).
&lt;&lt;1,2&gt;&gt;</pre></div> <p>For details about the <code class="code">PosLen</code> semantics, see <code class="bold_code"><span class="code">binary(3)</span></code>.</p> <p>Allowed in guard tests.</p>  <h3 id="binary_part-3" class="code">binary_part(Subject, Start, Length) -&gt; binary()</h3> <p>Types:</p>     <pre>Subject = binary()
Start = integer() &gt;= 0
Length = integer()</pre>

<p>The same as <code class="code">binary_part(Subject, {Start, Length})</code>.</p> <p>Allowed in guard tests.</p>  <h3 id="binary_to_atom-2" class="code">binary_to_atom(Binary, Encoding) -&gt; atom()</h3> <p>Types:</p>    <pre>Binary = binary()
Encoding = latin1 | unicode | utf8</pre>

<p>Returns the atom whose text representation is <code class="code">Binary</code>. If <code class="code">Encoding</code> is <code class="code">latin1</code>, no translation of bytes in the binary is done. If <code class="code">Encoding</code> is <code class="code">utf8</code> or <code class="code">unicode</code>, the binary must contain valid UTF-8 sequences. Only Unicode characters up to 255 are allowed.</p> <div class="note"> <div class="label">Note</div> <div class="content">

<p><code class="code">binary_to_atom(Binary, utf8)</code> fails if the binary contains Unicode characters &gt; 255. In a future release, such Unicode characters can be allowed and <code class="code">binary_to_atom(Binary, utf8)</code> does then not fail. For more information about Unicode support in atoms, see the <code class="bold_code"><a href="../erl_ext_dist/#utf8_atoms">note on UTF-8 encoded atoms</a></code> in section "External Term Format" in the User's Guide.</p> </div> </div> <p>Examples:</p> <div class="example"><pre>
&gt; binary_to_atom(&lt;&lt;"Erlang"&gt;&gt;, latin1).
'Erlang'
&gt; binary_to_atom(&lt;&lt;1024/utf8&gt;&gt;, utf8).
** exception error: bad argument
     in function  binary_to_atom/2
        called as binary_to_atom(&lt;&lt;208,128&gt;&gt;,utf8)</pre></div>  <h3 id="binary_to_existing_atom-2" class="code">binary_to_existing_atom(Binary, Encoding) -&gt; atom()</h3> <p>Types:</p>    <pre>Binary = binary()
Encoding = latin1 | unicode | utf8</pre>

<p>As <code class="bold_code"><a href="#binary_to_atom-2"><span class="code">binary_to_atom/2</span></a></code>, but the atom must exist.</p> <p>Failure: <code class="code">badarg</code> if the atom does not exist.</p>  <h3 id="binary_to_float-1" class="code">binary_to_float(Binary) -&gt; float()</h3> <p>Types:</p>   <pre>Binary = binary()</pre>

<p>Returns the float whose text representation is <code class="code">Binary</code>, for example:</p> <div class="example"><pre>
&gt; binary_to_float(&lt;&lt;"2.2017764e+0"&gt;&gt;).
2.2017764</pre></div> <p>Failure: <code class="code">badarg</code> if <code class="code">Binary</code> contains a bad representation of a float.</p>  <h3 id="binary_to_integer-1" class="code">binary_to_integer(Binary) -&gt; integer()</h3> <p>Types:</p>   <pre>Binary = binary()</pre>

<p>Returns an integer whose text representation is <code class="code">Binary</code>, for example:</p> <div class="example"><pre>
&gt; binary_to_integer(&lt;&lt;"123"&gt;&gt;).
123</pre></div> <p>Failure: <code class="code">badarg</code> if <code class="code">Binary</code> contains a bad representation of an integer.</p>  <h3 id="binary_to_integer-2" class="code">binary_to_integer(Binary, Base) -&gt; integer()</h3> <p>Types:</p>    <pre>Binary = binary()
Base = 2..36</pre>

<p>Returns an integer whose text representation in base <code class="code">Base</code> is <code class="code">Binary</code>, for example:</p> <div class="example"><pre>
&gt; binary_to_integer(&lt;&lt;"3FF"&gt;&gt;, 16).
1023</pre></div> <p>Failure: <code class="code">badarg</code> if <code class="code">Binary</code> contains a bad representation of an integer.</p>  <h3 id="binary_to_list-1" class="code">binary_to_list(Binary) -&gt; [byte()]</h3> <p>Types:</p>   <pre>Binary = binary()</pre>

<p>Returns a list of integers corresponding to the bytes of <code class="code">Binary</code>.</p>  <h3 id="binary_to_list-3" class="code">binary_to_list(Binary, Start, Stop) -&gt; [byte()]</h3> <p>Types:</p>   1..byte_size(<pre>Binary = binary()
Start = Stop = integer() &gt;= 1</pre>
<code class="code">Binary</code>)    

<p>As <code class="code">binary_to_list/1</code>, but returns a list of integers corresponding to the bytes from position <code class="code">Start</code> to position <code class="code">Stop</code> in <code class="code">Binary</code>. The positions in the binary are numbered starting from 1.</p> <div class="note"> <div class="label">Note</div> <div class="content">

<p><strong>The one-based indexing for binaries used by this function is deprecated.</strong> New code is to use <code class="bold_code"><span class="code">binary:bin_to_list/3</span></code> in STDLIB instead. All functions in module <code class="code">binary</code> consistently use zero-based indexing.</p> </div> </div>  <h3 id="binary_to_term-1" class="code">binary_to_term(Binary) -&gt; term()</h3> <p>Types:</p>   <pre>Binary = <a href="#type-ext_binary">ext_binary()</a></pre>

<p>Returns an Erlang term that is the result of decoding binary object <code class="code">Binary</code>, which must be encoded according to the <code class="bold_code">Erlang external term format</code>.</p> <div class="example"><pre>
&gt; Bin = term_to_binary(hello).
&lt;&lt;131,100,0,5,104,101,108,108,111&gt;&gt;
&gt; hello = binary_to_term(Bin).
hello
</pre></div> <div class="warning"> <div class="label">Warning</div> <div class="content">

<p>When decoding binaries from untrusted sources, consider using <code class="code">binary_to_term/2</code> to prevent Denial of Service attacks.</p> </div> </div> <p>See also <code class="bold_code"><a href="#term_to_binary-1"><span class="code">term_to_binary/1</span></a></code> and <code class="bold_code"><a href="#binary_to_term-2"><span class="code">binary_to_term/2</span></a></code>.</p>  <h3 id="binary_to_term-2" class="code">binary_to_term(Binary, Opts) -&gt; term()</h3> <p>Types:</p>    <pre>Binary = <a href="#type-ext_binary">ext_binary()</a>
Opts = [safe]</pre>

<p>As <code class="code">binary_to_term/1</code>, but takes options that affect decoding of the binary.</p> <p>Option:</p> <dl> <dt><strong><code class="code">safe</code></strong></dt> <dd> <p>Use this option when receiving binaries from an untrusted source.</p> <p>When enabled, it prevents decoding data that can be used to attack the Erlang system. In the event of receiving unsafe data, decoding fails with a <code class="code">badarg</code> error.</p> <p>This prevents creation of new atoms directly, creation of new atoms indirectly (as they are embedded in certain structures, such as process identifiers, refs, and funs), and creation of new external function references. None of those resources are garbage collected, so unchecked creation of them can exhaust available memory.</p> </dd> </dl> <p>Failure: <code class="code">badarg</code> if <code class="code">safe</code> is specified and unsafe data is decoded.</p> <div class="example"><pre>
&gt; binary_to_term(&lt;&lt;131,100,0,5,104,101,108,108,111&gt;&gt;, [safe]).
** exception error: bad argument
&gt; hello.
hello
&gt; binary_to_term(&lt;&lt;131,100,0,5,104,101,108,108,111&gt;&gt;, [safe]).
hello
</pre></div> <p>See also <code class="bold_code"><a href="#term_to_binary-1"><span class="code">term_to_binary/1</span></a></code>, <code class="bold_code"><a href="#binary_to_term-1"><span class="code">binary_to_term/1</span></a></code>, and <code class="bold_code"><a href="#list_to_existing_atom-1"><span class="code">list_to_existing_atom/1</span></a></code>.</p>  <h3 id="bit_size-1" class="code">bit_size(Bitstring) -&gt; integer() &gt;= 0</h3> <p>Types:</p>   <pre>Bitstring = bitstring()</pre>

<p>Returns an integer that is the size in bits of <code class="code">Bitstring</code>, for example:</p> <div class="example"><pre>
&gt; bit_size(&lt;&lt;433:16,3:3&gt;&gt;).
19
&gt; bit_size(&lt;&lt;1,2,3&gt;&gt;).
24</pre></div> <p>Allowed in guard tests.</p>  <h3 id="bitstring_to_list-1" class="code">bitstring_to_list(Bitstring) -&gt; [byte() | bitstring()]</h3> <p>Types:</p>   <pre>Bitstring = bitstring()</pre>

<p>Returns a list of integers corresponding to the bytes of <code class="code">Bitstring</code>. If the number of bits in the binary is not divisible by 8, the last element of the list is a bitstring containing the remaining 1-7 bits.</p>  <h3 id="bump_reductions-1" class="code">erlang:bump_reductions(Reductions) -&gt; true</h3> <p>Types:</p>   <pre>Reductions = integer() &gt;= 1</pre>

<p>This implementation-dependent function increments the reduction counter for the calling process. In the Beam emulator, the reduction counter is normally incremented by one for each function and BIF call. A context switch is forced when the counter reaches the maximum number of reductions for a process (2000 reductions in Erlang/OTP R12B).</p> <div class="warning"> <div class="label">Warning</div> <div class="content">

<p>This BIF can be removed in a future version of the Beam machine without prior warning. It is unlikely to be implemented in other Erlang implementations.</p> </div> </div>  <h3 id="byte_size-1" class="code">byte_size(Bitstring) -&gt; integer() &gt;= 0</h3> <p>Types:</p>   <pre>Bitstring = bitstring()</pre>

<p>Returns an integer that is the number of bytes needed to contain <code class="code">Bitstring</code>. That is, if the number of bits in <code class="code">Bitstring</code> is not divisible by 8, the resulting number of bytes is rounded <strong>up</strong>. Examples:</p> <div class="example"><pre>
&gt; byte_size(&lt;&lt;433:16,3:3&gt;&gt;).
3
&gt; byte_size(&lt;&lt;1,2,3&gt;&gt;).
3</pre></div> <p>Allowed in guard tests.</p>  <h3 id="cancel_timer-1" class="code">erlang:cancel_timer(TimerRef) -&gt; Result</h3> <p>Types:</p>     <pre>TimerRef = reference()
Time = integer() &gt;= 0
Result = Time | false</pre>

<p>Cancels a timer. The same as calling <code class="bold_code"><a href="#cancel_timer-2"><span class="code">erlang:cancel_timer(TimerRef, [])</span></a></code>.</p>  <h3 id="cancel_timer-2" class="code">erlang:cancel_timer(TimerRef, Options) -&gt; Result | ok</h3> <p>Types:</p>         <pre>TimerRef = reference()
Async = Info = boolean()

Option = {async, Async} | {info, Info}
Options = [Option]
Time = integer() &gt;= 0
Result = Time | false</pre>

<p>Cancels a timer that has been created by <code class="bold_code"><a href="#start_timer-4"><span class="code">erlang:start_timer</span></a></code> or <code class="bold_code"><a href="#send_after-4"><span class="code">erlang:send_after</span></a></code>. <code class="code">TimerRef</code> identifies the timer, and was returned by the BIF that created the timer.</p> <p><code class="code">Option</code>s:</p> <dl> <dt><strong><code class="code">{async, Async}</code></strong></dt> <dd> <p>Asynchronous request for cancellation. <code class="code">Async</code> defaults to <code class="code">false</code>, which causes the cancellation to be performed synchronously. When <code class="code">Async</code> is set to <code class="code">true</code>, the cancel operation is performed asynchronously. That is, <code class="code">cancel_timer()</code> sends an asynchronous request for cancellation to the timer service that manages the timer, and then returns <code class="code">ok</code>.</p> </dd> <dt><strong><code class="code">{info, Info}</code></strong></dt> <dd> <p>Requests information about the <code class="code">Result</code> of the cancellation. <code class="code">Info</code> defaults to <code class="code">true</code>, which means the <code class="code">Result</code> is given. When <code class="code">Info</code> is set to <code class="code">false</code>, no information about the result of the cancellation is given.</p> <ul> <li> <p>When <code class="code">Async</code> is <code class="code">false</code>: if <code class="code">Info</code> is <code class="code">true</code>, the <code class="code">Result</code> is returned by <code class="code">erlang:cancel_timer()</code>. otherwise <code class="code">ok</code> is returned.</p> </li> <li> <p>When <code class="code">Async</code> is <code class="code">true</code>: if <code class="code">Info</code> is <code class="code">true</code>, a message on the form <code class="code">{cancel_timer, TimerRef, Result}</code> is sent to the caller of <code class="code">erlang:cancel_timer()</code> when the cancellation operation has been performed, otherwise no message is sent.</p> </li> </ul> </dd> </dl> <p>More <code class="code">Option</code>s may be added in the future.</p> <p>If <code class="code">Result</code> is an integer, it represents the time in milliseconds left until the canceled timer would have expired.</p> <p>If <code class="code">Result</code> is <code class="code">false</code>, a timer corresponding to <code class="code">TimerRef</code> could not be found. This can be either because the timer had expired, already had been canceled, or because <code class="code">TimerRef</code> never corresponded to a timer. Even if the timer had expired, it does not tell you if the time-out message has arrived at its destination yet.</p> <div class="note"> <div class="label">Note</div> <div class="content">

<p>The timer service that manages the timer can be co-located with another scheduler than the scheduler that the calling process is executing on. If so, communication with the timer service takes much longer time than if it is located locally. If the calling process is in critical path, and can do other things while waiting for the result of this operation, or is not interested in the result of the operation, you want to use option <code class="code">{async, true}</code>. If using option <code class="code">{async, false}</code>, the calling process blocks until the operation has been performed.</p> </div> </div> <p>See also <code class="bold_code"><a href="#send_after-4"><span class="code">erlang:send_after/4</span></a></code>, <code class="bold_code"><a href="#start_timer-4"><span class="code">erlang:start_timer/4</span></a></code>, and <code class="bold_code"><a href="#read_timer-2"><span class="code">erlang:read_timer/2</span></a></code>.</p>  <h3 id="check_old_code-1" class="code">check_old_code(Module) -&gt; boolean()</h3> <p>Types:</p>   <pre>Module = module()</pre>

<p>Returns <code class="code">true</code> if <code class="code">Module</code> has old code, otherwise <code class="code">false</code>.</p> <p>See also <code class="bold_code"><span class="code">code(3)</span></code>.</p>  <h3 id="check_process_code-2" class="code">check_process_code(Pid, Module) -&gt; CheckResult</h3> <p>Types:</p>     <pre>Pid = pid()
Module = module()
CheckResult = boolean()</pre>

<p>The same as <code class="bold_code"><a href="#check_process_code-3"><span class="code">check_process_code(Pid,Module, [])</span></a></code>.</p>  <h3 id="check_process_code-3" class="code">check_process_code(Pid, Module, OptionList) -&gt; CheckResult | async</h3> <p>Types:</p>        <pre>Pid = pid()
Module = module()
RequestId = term()
Option = {async, RequestId} | {allow_gc, boolean()}
OptionList = [Option]
CheckResult = boolean() | aborted</pre>

<p>Checks if the node local process identified by <code class="code">Pid</code> executes old code for <code class="code">Module</code>.</p> <p><code class="code">Option</code>s:</p> <dl> <dt><strong><code class="code">{allow_gc, boolean()}</code></strong></dt> <dd> <p>Determines if garbage collection is allowed when performing the operation. If <code class="code">{allow_gc, false}</code> is passed, and a garbage collection is needed to determine the result of the operation, the operation is aborted (see information on <code class="code">CheckResult</code> below). The default is to allow garbage collection, that is, <code class="code">{allow_gc, true}</code>.</p> </dd> <dt><strong><code class="code">{async, RequestId}</code></strong></dt> <dd> <p>The function <code class="code">check_process_code/3</code> returns the value <code class="code">async</code> immediately after the request has been sent. When the request has been processed, the process that called this function is passed a message on the form <code class="code">{check_process_code, RequestId, CheckResult}</code>.</p> </dd> </dl> <p>If <code class="code">Pid</code> equals <code class="code">self()</code>, and no <code class="code">async</code> option has been passed, the operation is performed at once. Otherwise a request for the operation is sent to the process identified by <code class="code">Pid</code>, and is handled when appropriate. If no <code class="code">async</code> option has been passed, the caller blocks until <code class="code">CheckResult</code> is available and can be returned.</p> <p><code class="code">CheckResult</code> informs about the result of the request as follows:</p> <dl> <dt><strong><code class="code">true</code></strong></dt> <dd> <p>The process identified by <code class="code">Pid</code> executes old code for <code class="code">Module</code>. That is, the current call of the process executes old code for this module, or the process has references to old code for this module, or the process contains funs that references old code for this module.</p> </dd> <dt><strong><code class="code">false</code></strong></dt> <dd> <p>The process identified by <code class="code">Pid</code> does not execute old code for <code class="code">Module</code>.</p> </dd> <dt><strong><code class="code">aborted</code></strong></dt> <dd> <p>The operation was aborted, as the process needed to be garbage collected to determine the operation result, and the operation was requested by passing option <code class="code">{allow_gc, false}</code>.</p> </dd> </dl> <div class="note"> <div class="label">Note</div> <div class="content">

<p> Up until ERTS version 8.*, the check process code operation checks for all types of references to the old code. That is, direct references (e.g. return addresses on the process stack), indirect references (<code class="code">fun</code>s in process context), and references to literals in the code. </p> <p> As of ERTS version 9.0, the check process code operation only checks for direct references to the code. Indirect references via <code class="code">fun</code>s will be ignored. If such <code class="code">fun</code>s exist and are used after a purge of the old code, an exception will be raised upon usage (same as the case when the <code class="code">fun</code> is received by the process after the purge). Literals will be taken care of (copied) at a later stage. This behavior can as of ERTS version 8.1 be enabled when <code class="bold_code">building OTP</code>, and will automatically be enabled if dirty scheduler support is enabled. </p> </div> </div> <p>See also <code class="bold_code"><span class="code">code(3)</span></code>.</p> <p>Failures:</p> <dl> <dt><strong><code class="code">badarg</code></strong></dt> <dd>If <code class="code">Pid</code> is not a node local process identifier. </dd> <dt><strong><code class="code">badarg</code></strong></dt> <dd>If <code class="code">Module</code> is not an atom. </dd> <dt><strong><code class="code">badarg</code></strong></dt> <dd>If <code class="code">OptionList</code> is an invalid list of options. </dd> </dl>  <h3 id="convert_time_unit-3" class="code">erlang:convert_time_unit(Time, FromUnit, ToUnit) -&gt; ConvertedTime</h3> <p>Types:</p>      <pre>Time = ConvertedTime = integer()

FromUnit = ToUnit = <a href="#type-time_unit">time_unit()</a></pre>

<p>Converts the <code class="code">Time</code> value of time unit <code class="code">FromUnit</code> to the corresponding <code class="code">ConvertedTime</code> value of time unit <code class="code">ToUnit</code>. The result is rounded using the floor function.</p> <div class="warning"> <div class="label">Warning</div> <div class="content">

<p>You can lose accuracy and precision when converting between time units. To minimize such loss, collect all data at <code class="code">native</code> time unit and do the conversion on the end result.</p> </div> </div>  <h3 id="crc32-1" class="code">erlang:crc32(Data) -&gt; integer() &gt;= 0</h3> <p>Types:</p>   <pre>Data = iodata()</pre>

<p>Computes and returns the crc32 (IEEE 802.3 style) checksum for <code class="code">Data</code>.</p>  <h3 id="crc32-2" class="code">erlang:crc32(OldCrc, Data) -&gt; integer() &gt;= 0</h3> <p>Types:</p>    <pre>OldCrc = integer() &gt;= 0
Data = iodata()</pre>

<p>Continues computing the crc32 checksum by combining the previous checksum, <code class="code">OldCrc</code>, with the checksum of <code class="code">Data</code>.</p> <p>The following code:</p> <div class="example"><pre>
X = erlang:crc32(Data1),
Y = erlang:crc32(X,Data2).</pre></div> <p>assigns the same value to <code class="code">Y</code> as this:</p> <div class="example"><pre>
Y = erlang:crc32([Data1,Data2]).</pre></div>  <h3 id="crc32_combine-3" class="code">erlang:crc32_combine(FirstCrc, SecondCrc, SecondSize) -&gt;<br>                        integer() &gt;= 0</h3> <p>Types:</p>     <pre>FirstCrc = SecondCrc = SecondSize = integer() &gt;= 0</pre>

<p>Combines two previously computed crc32 checksums. This computation requires the size of the data object for the second checksum to be known.</p> <p>The following code:</p> <div class="example"><pre>
Y = erlang:crc32(Data1),
Z = erlang:crc32(Y,Data2).</pre></div> <p>assigns the same value to <code class="code">Z</code> as this:</p> <div class="example"><pre>
X = erlang:crc32(Data1),
Y = erlang:crc32(Data2),
Z = erlang:crc32_combine(X,Y,iolist_size(Data2)).</pre></div>  <h3 id="date-0" class="code">date() -&gt; Date</h3> <p>Types:</p>   <pre>Date = calendar:date()</pre>

<p>Returns the current date as <code class="code">{Year, Month, Day}</code>.</p> <p>The time zone and Daylight Saving Time correction depend on the underlying OS. Example:</p> <div class="example"><pre>
&gt; date().
{1995,2,19}</pre></div>  <h3 id="decode_packet-3" class="code">erlang:decode_packet(Type, Bin, Options) -&gt;<br>                        {ok, Packet, Rest} |<br>                        {more, Length} |<br>                        {error, Reason}</h3> <p>Types:</p>                    <pre>Type = 
    raw |
    0 |
    1 |
    2 |
    4 |
    asn1 |
    cdr |
    sunrm |
    fcgi |
    tpkt |
    line |
    http |
    http_bin |
    httph |
    httph_bin
Bin = binary()
Options = [Opt]
Opt = 
    {packet_size, integer() &gt;= 0} |
    {line_length, integer() &gt;= 0}
Packet = binary() | HttpPacket
Rest = binary()
Length = integer() &gt;= 0 | undefined
Reason = term()
HttpPacket = 
    HttpRequest | HttpResponse | HttpHeader | http_eoh | HttpError
HttpRequest = {http_request, HttpMethod, HttpUri, HttpVersion}
HttpResponse = 
    {http_response, HttpVersion, integer(), HttpString}
HttpHeader = 
    {http_header,
     integer(),
     HttpField,
     Reserved :: term(),
     Value :: HttpString}
HttpError = {http_error, HttpString}
HttpMethod = 
    'OPTIONS' |
    'GET' |
    'HEAD' |
    'POST' |
    'PUT' |
    'DELETE' |
    'TRACE' |
    HttpString
HttpUri = 
    '*' |
    {absoluteURI,
     http | https,
     Host :: HttpString,
     Port :: inet:port_number() | undefined,
     Path :: HttpString} |
    {scheme, Scheme :: HttpString, HttpString} |
    {abs_path, HttpString} |
    HttpString
HttpVersion = 
    {Major :: integer() &gt;= 0, Minor :: integer() &gt;= 0}
HttpField = 
    'Cache-Control' |
    'Connection' |
    'Date' |
    'Pragma' |
    'Transfer-Encoding' |
    'Upgrade' |
    'Via' |
    'Accept' |
    'Accept-Charset' |
    'Accept-Encoding' |
    'Accept-Language' |
    'Authorization' |
    'From' |
    'Host' |
    'If-Modified-Since' |
    'If-Match' |
    'If-None-Match' |
    'If-Range' |
    'If-Unmodified-Since' |
    'Max-Forwards' |
    'Proxy-Authorization' |
    'Range' |
    'Referer' |
    'User-Agent' |
    'Age' |
    'Location' |
    'Proxy-Authenticate' |
    'Public' |
    'Retry-After' |
    'Server' |
    'Vary' |
    'Warning' |
    'Www-Authenticate' |
    'Allow' |
    'Content-Base' |
    'Content-Encoding' |
    'Content-Language' |
    'Content-Length' |
    'Content-Location' |
    'Content-Md5' |
    'Content-Range' |
    'Content-Type' |
    'Etag' |
    'Expires' |
    'Last-Modified' |
    'Accept-Ranges' |
    'Set-Cookie' |
    'Set-Cookie2' |
    'X-Forwarded-For' |
    'Cookie' |
    'Keep-Alive' |
    'Proxy-Connection' |
    HttpString
HttpString = string() | binary()</pre>

<p>Decodes the binary <code class="code">Bin</code> according to the packet protocol specified by <code class="code">Type</code>. Similar to the packet handling done by sockets with option <code class="code">{packet,Type}.</code></p> <p>If an entire packet is contained in <code class="code">Bin</code>, it is returned together with the remainder of the binary as <code class="code">{ok,Packet,Rest}</code>.</p> <p>If <code class="code">Bin</code> does not contain the entire packet, <code class="code">{more,Length}</code> is returned. <code class="code">Length</code> is either the expected <strong>total size</strong> of the packet, or <code class="code">undefined</code> if the expected packet size is unknown. <code class="code">decode_packet</code> can then be called again with more data added.</p> <p>If the packet does not conform to the protocol format, <code class="code">{error,Reason}</code> is returned.</p> <p><code class="code">Type</code>s:</p> <dl> <dt><strong><code class="code">raw | 0</code></strong></dt> <dd> <p>No packet handling is done. The entire binary is returned unless it is empty.</p> </dd> <dt><strong><code class="code">1 | 2 | 4</code></strong></dt> <dd> <p>Packets consist of a header specifying the number of bytes in the packet, followed by that number of bytes. The length of the header can be one, two, or four bytes; the order of the bytes is big-endian. The header is stripped off when the packet is returned.</p> </dd> <dt><strong><code class="code">line</code></strong></dt> <dd> <p>A packet is a line-terminated by a delimiter byte, default is the latin-1 newline character. The delimiter byte is included in the returned packet unless the line was truncated according to option <code class="code">line_length</code>.</p> </dd> <dt><strong><code class="code">asn1 | cdr | sunrm | fcgi | tpkt</code></strong></dt> <dd> <p>The header is <strong>not</strong> stripped off.</p> <p>The meanings of the packet types are as follows:</p> <dl> <dt><strong><code class="code">asn1</code> - ASN.1 BER</strong></dt>  <dt><strong><code class="code">sunrm</code> - Sun's RPC encoding</strong></dt>  <dt><strong><code class="code">cdr</code> - CORBA (GIOP 1.1)</strong></dt>  <dt><strong><code class="code">fcgi</code> - Fast CGI</strong></dt>  <dt><strong><code class="code">tpkt</code> - TPKT format [RFC1006]</strong></dt>  </dl> </dd> <dt><strong><code class="code">http | httph | http_bin | httph_bin</code></strong></dt> <dd> <p>The Hypertext Transfer Protocol. The packets are returned with the format according to <code class="code">HttpPacket</code> described earlier. A packet is either a request, a response, a header, or an end of header mark. Invalid lines are returned as <code class="code">HttpError</code>.</p> <p>Recognized request methods and header fields are returned as atoms. Others are returned as strings. Strings of unrecognized header fields are formatted with only capital letters first and after hyphen characters, for example, <code class="code">"Sec-Websocket-Key"</code>.</p> <p>The protocol type <code class="code">http</code> is only to be used for the first line when an <code class="code">HttpRequest</code> or an <code class="code">HttpResponse</code> is expected. The following calls are to use <code class="code">httph</code> to get <code class="code">HttpHeader</code>s until <code class="code">http_eoh</code> is returned, which marks the end of the headers and the beginning of any following message body.</p> <p>The variants <code class="code">http_bin</code> and <code class="code">httph_bin</code> return strings (<code class="code">HttpString</code>) as binaries instead of lists.</p> </dd> </dl> <p>Options:</p> <dl> <dt><strong><code class="code">{packet_size, integer() &gt;= 0}</code></strong></dt> <dd> <p>Sets the maximum allowed size of the packet body. If the packet header indicates that the length of the packet is longer than the maximum allowed length, the packet is considered invalid. Defaults to 0, which means no size limit.</p> </dd> <dt><strong><code class="code">{line_length, integer() &gt;= 0}</code></strong></dt> <dd> <p>For packet type <code class="code">line</code>, lines longer than the indicated length are truncated.</p> <p>Option <code class="code">line_length</code> also applies to <code class="code">http*</code> packet types as an alias for option <code class="code">packet_size</code> if <code class="code">packet_size</code> itself is not set. This use is only intended for backward compatibility.</p> </dd> <dt><strong><code class="code">{line_delimiter, 0 =&lt; byte() =&lt; 255}</code></strong></dt> <dd> <p>For packet type <code class="code">line</code>, sets the delimiting byte. Default is the latin-1 character <code class="code">$\n</code>.</p> </dd> </dl> <p>Examples:</p> <div class="example"><pre>
&gt; erlang:decode_packet(1,&lt;&lt;3,"abcd"&gt;&gt;,[]).
{ok,&lt;&lt;"abc"&gt;&gt;,&lt;&lt;"d"&gt;&gt;}
&gt; erlang:decode_packet(1,&lt;&lt;5,"abcd"&gt;&gt;,[]).
{more,6}</pre></div>  <h3 id="delete_element-2" class="code">erlang:delete_element(Index, Tuple1) -&gt; Tuple2</h3> <p>Types:</p>  <pre>Index = integer() &gt;= 1</pre>
<p class="REFBODY">1..tuple_size(Tuple1)</p>    <pre>Tuple1 = Tuple2 = tuple()</pre>

<p>Returns a new tuple with element at <code class="code">Index</code> removed from tuple <code class="code">Tuple1</code>, for example:</p> <div class="example"><pre>
&gt; erlang:delete_element(2, {one, two, three}).
{one,three}</pre></div>  <h3 id="delete_module-1" class="code">delete_module(Module) -&gt; true | undefined</h3> <p>Types:</p>   <pre>Module = module()</pre>

<p>Makes the current code for <code class="code">Module</code> become old code and deletes all references for this module from the export table. Returns <code class="code">undefined</code> if the module does not exist, otherwise <code class="code">true</code>.</p> <div class="warning"> <div class="label">Warning</div> <div class="content">

<p>This BIF is intended for the code server (see <code class="bold_code"><span class="code">code(3)</span></code>) and is not to be used elsewhere.</p> </div> </div> <p>Failure: <code class="code">badarg</code> if there already is an old version of <code class="code">Module</code>.</p>  <h3 id="demonitor-1" class="code">demonitor(MonitorRef) -&gt; true</h3> <p>Types:</p>   <pre>MonitorRef = reference()</pre>

<p>If <code class="code">MonitorRef</code> is a reference that the calling process obtained by calling <code class="bold_code"><a href="#monitor-2"><span class="code">monitor/2</span></a></code>, this monitoring is turned off. If the monitoring is already turned off, nothing happens.</p> <p>Once <code class="code">demonitor(MonitorRef)</code> has returned, it is guaranteed that no <code class="code">{'DOWN', MonitorRef, _, _, _}</code> message, because of the monitor, will be placed in the caller message queue in the future. However, a <code class="code">{'DOWN', MonitorRef, _, _, _}</code> message can have been placed in the caller message queue before the call. It is therefore usually advisable to remove such a <code class="code">'DOWN'</code> message from the message queue after monitoring has been stopped. <code class="bold_code"><a href="#demonitor-2"><span class="code">demonitor(MonitorRef, [flush])</span></a></code> can be used instead of <code class="code">demonitor(MonitorRef)</code> if this cleanup is wanted.</p> <div class="note"> <div class="label">Note</div> <div class="content">

<p>Before Erlang/OTP R11B (ERTS 5.5) <code class="code">demonitor/1</code> behaved completely asynchronously, that is, the monitor was active until the "demonitor signal" reached the monitored entity. This had one undesirable effect. You could never know when you were guaranteed <strong>not</strong> to receive a <code class="code">DOWN</code> message because of the monitor.</p> <p>The current behavior can be viewed as two combined operations: asynchronously send a "demonitor signal" to the monitored entity and ignore any future results of the monitor.</p> </div> </div> <p>Failure: It is an error if <code class="code">MonitorRef</code> refers to a monitoring started by another process. Not all such cases are cheap to check. If checking is cheap, the call fails with <code class="code">badarg</code>, for example if <code class="code">MonitorRef</code> is a remote reference.</p>  <h3 id="demonitor-2" class="code">demonitor(MonitorRef, OptionList) -&gt; boolean()</h3> <p>Types:</p>     <pre>MonitorRef = reference()
OptionList = [Option]
Option = flush | info</pre>

<p>The returned value is <code class="code">true</code> unless <code class="code">info</code> is part of <code class="code">OptionList</code>.</p> <p><code class="code">demonitor(MonitorRef, [])</code> is equivalent to <code class="bold_code"><a href="#demonitor-1"><span class="code">demonitor(MonitorRef)</span></a></code>.</p> <p><code class="code">Option</code>s:</p> <dl> <dt><strong><code class="code">flush</code></strong></dt> <dd> <p>Removes (one) <code class="code">{_, MonitorRef, _, _, _}</code> message, if there is one, from the caller message queue after monitoring has been stopped.</p> <p>Calling <code class="code">demonitor(MonitorRef, [flush])</code> is equivalent to the following, but more efficient:</p> <div class="example"><pre>
demonitor(MonitorRef),
receive
    {_, MonitorRef, _, _, _} -&gt;
        true
after 0 -&gt;
        true
end</pre></div> </dd> <dt><strong><code class="code">info</code></strong></dt> <dd> <p>The returned value is one of the following:</p> <dl> <dt><strong><code class="code">true</code></strong></dt> <dd> <p>The monitor was found and removed. In this case, no <code class="code">'DOWN'</code> message corresponding to this monitor has been delivered and will not be delivered.</p> </dd> <dt><strong><code class="code">false</code></strong></dt> <dd> <p>The monitor was not found and could not be removed. This probably because someone already has placed a <code class="code">'DOWN'</code> message corresponding to this monitor in the caller message queue.</p> </dd> </dl> <p>If option <code class="code">info</code> is combined with option <code class="code">flush</code>, <code class="code">false</code> is returned if a flush was needed, otherwise <code class="code">true</code>.</p> </dd> </dl> <div class="note"> <div class="label">Note</div> <div class="content">

<p>More options can be added in a future release.</p> </div> </div> <p>Failures:</p> <dl> <dt><strong><code class="code">badarg</code></strong></dt> <dd>If <code class="code">OptionList</code> is not a list. </dd> <dt><strong><code class="code">badarg</code></strong></dt> <dd>If <code class="code">Option</code> is an invalid option. </dd> <dt><strong><code class="code">badarg</code></strong></dt> <dd>The same failure as for <code class="bold_code"><a href="#demonitor-1"><span class="code">demonitor/1</span></a></code>. </dd> </dl>  <h3 id="disconnect_node-1" class="code">disconnect_node(Node) -&gt; boolean() | ignored</h3> <p>Types:</p>   <pre>Node = node()</pre>

<p>Forces the disconnection of a node. This appears to the node <code class="code">Node</code> as if the local node has crashed. This BIF is mainly used in the Erlang network authentication protocols.</p> <p>Returns <code class="code">true</code> if disconnection succeeds, otherwise <code class="code">false</code>. If the local node is not alive, <code class="code">ignored</code> is returned.</p>  <h3 id="display-1" class="code">erlang:display(Term) -&gt; true</h3> <p>Types:</p>   <pre>Term = term()</pre>

<p>Prints a text representation of <code class="code">Term</code> on the standard output.</p> <div class="warning"> <div class="label">Warning</div> <div class="content">

<p>This BIF is intended for debugging only.</p> </div> </div>  <h3 id="element-2" class="code">element(N, Tuple) -&gt; term()</h3> <p>Types:</p>  <pre>N = integer() &gt;= 1</pre>
<p class="REFBODY">1..tuple_size(Tuple)</p>   <pre>Tuple = tuple()</pre>

<p>Returns the <code class="code">N</code>th element (numbering from 1) of <code class="code">Tuple</code>, for example:</p> <div class="example"><pre>
&gt; element(2, {a, b, c}).
b</pre></div> <p>Allowed in guard tests.</p>  <h3 id="erase-0" class="code">erase() -&gt; [{Key, Val}]</h3> <p>Types:</p>    <pre>Key = Val = term()</pre>

<p>Returns the process dictionary and deletes it, for example:</p> <div class="example"><pre>
&gt; put(key1, {1, 2, 3}),
put(key2, [a, b, c]),
erase().
[{key1,{1,2,3}},{key2,[a,b,c]}]</pre></div>  <h3 id="erase-1" class="code">erase(Key) -&gt; Val | undefined</h3> <p>Types:</p>    <pre>Key = Val = term()</pre>

<p>Returns the value <code class="code">Val</code> associated with <code class="code">Key</code> and deletes it from the process dictionary. Returns <code class="code">undefined</code> if no value is associated with <code class="code">Key</code>. Example:</p> <div class="example"><pre>
&gt; put(key1, {merry, lambs, are, playing}),
X = erase(key1),
{X, erase(key1)}.
{{merry,lambs,are,playing},undefined}</pre></div>  <h3 id="error-1" class="code">error(Reason) -&gt; no_return()</h3> <p>Types:</p>   <pre>Reason = term()</pre>

<p>Stops the execution of the calling process with the reason <code class="code">Reason</code>, where <code class="code">Reason</code> is any term. The exit reason is <code class="code">{Reason, Where}</code>, where <code class="code">Where</code> is a list of the functions most recently called (the current function first). As evaluating this function causes the process to terminate, it has no return value. Example:</p> <div class="example"><pre>
&gt; catch error(foobar).
{'EXIT',{foobar,[{erl_eval,do_apply,5},
                 {erl_eval,expr,5},
                 {shell,exprs,6},
                 {shell,eval_exprs,6},
                 {shell,eval_loop,3}]}}</pre></div>  <h3 id="error-2" class="code">error(Reason, Args) -&gt; no_return()</h3> <p>Types:</p>    <pre>Reason = term()
Args = [term()]</pre>

<p>Stops the execution of the calling process with the reason <code class="code">Reason</code>, where <code class="code">Reason</code> is any term. The exit reason is <code class="code">{Reason, Where}</code>, where <code class="code">Where</code> is a list of the functions most recently called (the current function first). <code class="code">Args</code> is expected to be the list of arguments for the current function; in Beam it is used to provide the arguments for the current function in the term <code class="code">Where</code>. As evaluating this function causes the process to terminate, it has no return value.</p>  <h3 id="exit-1" class="code">exit(Reason) -&gt; no_return()</h3> <p>Types:</p>   <pre>Reason = term()</pre>

<p>Stops the execution of the calling process with exit reason <code class="code">Reason</code>, where <code class="code">Reason</code> is any term. As evaluating this function causes the process to terminate, it has no return value. Example:</p> <div class="example"><pre>
&gt; exit(foobar).
** exception exit: foobar
&gt; catch exit(foobar).
{'EXIT',foobar}</pre></div>  <h3 id="exit-2" class="code">exit(Pid, Reason) -&gt; true</h3> <p>Types:</p>    <pre>Pid = pid() | port()
Reason = term()</pre>

<p>Sends an exit signal with exit reason <code class="code">Reason</code> to the process or port identified by <code class="code">Pid</code>.</p> <p>The following behavior applies if <code class="code">Reason</code> is any term, except <code class="code">normal</code> or <code class="code">kill</code>:</p> <ul> <li> <p>If <code class="code">Pid</code> is not trapping exits, <code class="code">Pid</code> itself exits with exit reason <code class="code">Reason</code>.</p> </li> <li> <p>If <code class="code">Pid</code> is trapping exits, the exit signal is transformed into a message <code class="code">{'EXIT', From, Reason}</code> and delivered to the message queue of <code class="code">Pid</code>.</p> </li> <li> <p><code class="code">From</code> is the process identifier of the process that sent the exit signal. See also <code class="bold_code"><a href="#process_flag-2"><span class="code">process_flag/2</span></a></code>.</p> </li> </ul> <p>If <code class="code">Reason</code> is the atom <code class="code">normal</code>, <code class="code">Pid</code> does not exit. If it is trapping exits, the exit signal is transformed into a message <code class="code">{'EXIT', From, normal}</code> and delivered to its message queue.</p> <p>If <code class="code">Reason</code> is the atom <code class="code">kill</code>, that is, if <code class="code">exit(Pid, kill)</code> is called, an untrappable exit signal is sent to <code class="code">Pid</code>, which unconditionally exits with exit reason <code class="code">killed</code>.</p>  <h3 id="external_size-1" class="code">erlang:external_size(Term) -&gt; integer() &gt;= 0</h3> <p>Types:</p>   <pre>Term = term()</pre>

<p>Calculates, without doing the encoding, the maximum byte size for a term encoded in the Erlang external term format. The following condition applies always:</p> <div class="example"><pre>
&gt; Size1 = byte_size(term_to_binary(Term)),
&gt; Size2 = erlang:external_size(Term),
&gt; true = Size1 =&lt; Size2.
true</pre></div> <p>This is equivalent to a call to:</p> <div class="example"><pre>
erlang:external_size(Term, [])</pre></div>  <h3 id="external_size-2" class="code">erlang:external_size(Term, Options) -&gt; integer() &gt;= 0</h3> <p>Types:</p>    <pre>Term = term()
Options = [{minor_version, Version :: integer() &gt;= 0}]</pre>

<p>Calculates, without doing the encoding, the maximum byte size for a term encoded in the Erlang external term format. The following condition applies always:</p> <div class="example"><pre>
&gt; Size1 = byte_size(term_to_binary(Term, Options)),
&gt; Size2 = erlang:external_size(Term, Options),
&gt; true = Size1 =&lt; Size2.
true</pre></div> <p>Option <code class="code">{minor_version, Version}</code> specifies how floats are encoded. For a detailed description, see <code class="bold_code"><a href="#term_to_binary-2"><span class="code">term_to_binary/2</span></a></code>.</p>  <h3 id="float-1" class="code">float(Number) -&gt; float()</h3> <p>Types:</p>   <pre>Number = number()</pre>

<p>Returns a float by converting <code class="code">Number</code> to a float, for example:</p> <div class="example"><pre>
&gt; float(55).
55.0</pre></div> <p>Allowed in guard tests.</p> <div class="note"> <div class="label">Note</div> <div class="content">

<p>If used on the top level in a guard, it tests whether the argument is a floating point number; for clarity, use <code class="bold_code"><a href="#is_float-1"><span class="code">is_float/1</span></a></code> instead.</p> <p>When <code class="code">float/1</code> is used in an expression in a guard, such as '<code class="code">float(A) == 4.0</code>', it converts a number as described earlier.</p> </div> </div>  <h3 id="float_to_binary-1" class="code">float_to_binary(Float) -&gt; binary()</h3> <p>Types:</p>   <pre>Float = float()</pre>

<p>The same as <code class="code">float_to_binary(Float,[{scientific,20}])</code>.</p>  <h3 id="float_to_binary-2" class="code">float_to_binary(Float, Options) -&gt; binary()</h3> <p>Types:</p>     <pre>Float = float()
Options = [Option]
Option = 
    {decimals, Decimals :: 0..253} |
    {scientific, Decimals :: 0..249} |
    compact</pre>

<p>Returns a binary corresponding to the text representation of <code class="code">Float</code> using fixed decimal point formatting. <code class="code">Options</code> behaves in the same way as <code class="bold_code"><a href="#float_to_list-2"><span class="code">float_to_list/2</span></a></code>. Examples:</p> <div class="example"><pre>
&gt; float_to_binary(7.12, [{decimals, 4}]).
&lt;&lt;"7.1200"&gt;&gt;
&gt; float_to_binary(7.12, [{decimals, 4}, compact]).
&lt;&lt;"7.12"&gt;&gt;</pre></div>  <h3 id="float_to_list-1" class="code">float_to_list(Float) -&gt; string()</h3> <p>Types:</p>   <pre>Float = float()</pre>

<p>The same as <code class="code">float_to_list(Float,[{scientific,20}])</code>.</p>  <h3 id="float_to_list-2" class="code">float_to_list(Float, Options) -&gt; string()</h3> <p>Types:</p>     <pre>Float = float()
Options = [Option]
Option = 
    {decimals, Decimals :: 0..253} |
    {scientific, Decimals :: 0..249} |
    compact</pre>

<p>Returns a string corresponding to the text representation of <code class="code">Float</code> using fixed decimal point formatting.</p> <p>Available options:</p> <ul> <li> <p>If option <code class="code">decimals</code> is specified, the returned value contains at most <code class="code">Decimals</code> number of digits past the decimal point. If the number does not fit in the internal static buffer of 256 bytes, the function throws <code class="code">badarg</code>.</p> </li> <li> <p>If option <code class="code">compact</code> is specified, the trailing zeros at the end of the list are truncated. This option is only meaningful together with option <code class="code">decimals</code>.</p> </li> <li> <p>If option <code class="code">scientific</code> is specified, the float is formatted using scientific notation with <code class="code">Decimals</code> digits of precision.</p> </li> <li> <p>If <code class="code">Options</code> is <code class="code">[]</code>, the function behaves as <code class="bold_code"><a href="#float_to_list-1"><span class="code">float_to_list/1</span></a></code>.</p> </li> </ul> <p>Examples:</p> <div class="example"><pre>
&gt; float_to_list(7.12, [{decimals, 4}]).
"7.1200"
&gt; float_to_list(7.12, [{decimals, 4}, compact]).
"7.12"</pre></div>  <h3 id="fun_info-1" class="code">erlang:fun_info(Fun) -&gt; [{Item, Info}]</h3> <p>Types:</p>     <pre>Fun = function()
Item = 
    arity |
    env |
    index |
    name |
    module |
    new_index |
    new_uniq |
    pid |
    type |
    uniq
Info = term()</pre>

<p>Returns a list with information about the fun <code class="code">Fun</code>. Each list element is a tuple. The order of the tuples is undefined, and more tuples can be added in a future release.</p> <div class="warning"> <div class="label">Warning</div> <div class="content">

<p>This BIF is mainly intended for debugging, but it can sometimes be useful in library functions that need to verify, for example, the arity of a fun.</p> </div> </div> <p>Two types of funs have slightly different semantics:</p> <ul> <li> <p>A fun created by <code class="code">fun M:F/A</code> is called an <strong>external</strong> fun. Calling it will always call the function <code class="code">F</code> with arity <code class="code">A</code> in the latest code for module <code class="code">M</code>. Notice that module <code class="code">M</code> does not even need to be loaded when the fun <code class="code">fun M:F/A</code> is created.</p> </li> <li> <p>All other funs are called <strong>local</strong>. When a local fun is called, the same version of the code that created the fun is called (even if a newer version of the module has been loaded).</p> </li> </ul> <p>The following elements are always present in the list for both local and external funs:</p> <dl> <dt><strong><code class="code">{type, Type}</code></strong></dt> <dd> <p><code class="code">Type</code> is <code class="code">local</code> or <code class="code">external</code>.</p> </dd> <dt><strong><code class="code">{module, Module}</code></strong></dt> <dd> <p><code class="code">Module</code> (an atom) is the module name.</p> <p>If <code class="code">Fun</code> is a local fun, <code class="code">Module</code> is the module in which the fun is defined.</p> <p>If <code class="code">Fun</code> is an external fun, <code class="code">Module</code> is the module that the fun refers to.</p> </dd> <dt><strong><code class="code">{name, Name}</code></strong></dt> <dd> <p><code class="code">Name</code> (an atom) is a function name.</p> <p>If <code class="code">Fun</code> is a local fun, <code class="code">Name</code> is the name of the local function that implements the fun. (This name was generated by the compiler, and is only of informational use. As it is a local function, it cannot be called directly.) If no code is currently loaded for the fun, <code class="code">[]</code> is returned instead of an atom.</p> <p>If <code class="code">Fun</code> is an external fun, <code class="code">Name</code> is the name of the exported function that the fun refers to.</p> </dd> <dt><strong><code class="code">{arity, Arity}</code></strong></dt> <dd> <p><code class="code">Arity</code> is the number of arguments that the fun is to be called with.</p> </dd> <dt><strong><code class="code">{env, Env}</code></strong></dt> <dd> <p><code class="code">Env</code> (a list) is the environment or free variables for the fun. For external funs, the returned list is always empty.</p> </dd> </dl> <p>The following elements are only present in the list if <code class="code">Fun</code> is local:</p> <dl> <dt><strong><code class="code">{pid, Pid}</code></strong></dt> <dd> <p><code class="code">Pid</code> is the process identifier of the process that originally created the fun.</p> </dd> <dt><strong><code class="code">{index, Index}</code></strong></dt> <dd> <p><code class="code">Index</code> (an integer) is an index into the module fun table.</p> </dd> <dt><strong><code class="code">{new_index, Index}</code></strong></dt> <dd> <p><code class="code">Index</code> (an integer) is an index into the module fun table.</p> </dd> <dt><strong><code class="code">{new_uniq, Uniq}</code></strong></dt> <dd> <p><code class="code">Uniq</code> (a binary) is a unique value for this fun. It is calculated from the compiled code for the entire module.</p> </dd> <dt><strong><code class="code">{uniq, Uniq}</code></strong></dt> <dd> <p><code class="code">Uniq</code> (an integer) is a unique value for this fun. As from Erlang/OTP R15, this integer is calculated from the compiled code for the entire module. Before Erlang/OTP R15, this integer was based on only the body of the fun.</p> </dd> </dl>  <h3 id="fun_info-2" class="code">erlang:fun_info(Fun, Item) -&gt; {Item, Info}</h3> <p>Types:</p>      <pre>Fun = function()
Item = fun_info_item()
Info = term()
fun_info_item() = 
    arity |
    env |
    index |
    name |
    module |
    new_index |
    new_uniq |
    pid |
    type |
    uniq</pre>

<p>Returns information about <code class="code">Fun</code> as specified by <code class="code">Item</code>, in the form <code class="code">{Item,Info}</code>.</p> <p>For any fun, <code class="code">Item</code> can be any of the atoms <code class="code">module</code>, <code class="code">name</code>, <code class="code">arity</code>, <code class="code">env</code>, or <code class="code">type</code>.</p> <p>For a local fun, <code class="code">Item</code> can also be any of the atoms <code class="code">index</code>, <code class="code">new_index</code>, <code class="code">new_uniq</code>, <code class="code">uniq</code>, and <code class="code">pid</code>. For an external fun, the value of any of these items is always the atom <code class="code">undefined</code>.</p> <p>See <code class="bold_code"><a href="#fun_info-1"><span class="code">erlang:fun_info/1</span></a></code>.</p>  <h3 id="fun_to_list-1" class="code">erlang:fun_to_list(Fun) -&gt; string()</h3> <p>Types:</p>   <pre>Fun = function()</pre>

<p>Returns a string corresponding to the text representation of <code class="code">Fun</code>.</p>  <h3 id="function_exported-3" class="code">erlang:function_exported(Module, Function, Arity) -&gt; boolean()</h3> <p>Types:</p>     <pre>Module = module()
Function = atom()
Arity = arity()</pre>

<p>Returns <code class="code">true</code> if the module <code class="code">Module</code> is loaded and contains an exported function <code class="code">Function/Arity</code>, or if there is a BIF (a built-in function implemented in C) with the specified name, otherwise returns <code class="code">false</code>.</p> <div class="note"> <div class="label">Note</div> <div class="content">

<p>This function used to return <code class="code">false</code> for BIFs before Erlang/OTP 18.0.</p> </div> </div>  <h3 id="garbage_collect-0" class="code">garbage_collect() -&gt; true</h3> 
<p>Forces an immediate garbage collection of the executing process. The function is not to be used unless it has been noticed (or there are good reasons to suspect) that the spontaneous garbage collection will occur too late or not at all.</p> <div class="warning"> <div class="label">Warning</div> <div class="content">

<p>Improper use can seriously degrade system performance.</p> </div> </div>  <h3 id="garbage_collect-1" class="code">garbage_collect(Pid) -&gt; GCResult</h3> <p>Types:</p>    <pre>Pid = pid()
GCResult = boolean()</pre>

<p>The same as <code class="bold_code"><a href="#garbage_collect-2"><span class="code">garbage_collect(Pid, [])</span></a></code>.</p>  <h3 id="garbage_collect-2" class="code">garbage_collect(Pid, OptionList) -&gt; GCResult | async</h3> <p>Types:</p>       <pre>Pid = pid()
RequestId = term()
Option = {async, RequestId}
OptionList = [Option]
GCResult = boolean()</pre>

<p>Garbage collects the node local process identified by <code class="code">Pid</code>.</p> <p><code class="code">Option</code>:</p> <dl> <dt><strong><code class="code">{async, RequestId}</code></strong></dt> <dd>The function <code class="code">garbage_collect/2</code> returns the value <code class="code">async</code> immediately after the request has been sent. When the request has been processed, the process that called this function is passed a message on the form <code class="code">{garbage_collect, RequestId, GCResult}</code>. </dd> </dl> <p>If <code class="code">Pid</code> equals <code class="code">self()</code>, and no <code class="code">async</code> option has been passed, the garbage collection is performed at once, that is, the same as calling <code class="bold_code"><a href="#garbage_collect-0"><span class="code">garbage_collect/0</span></a></code>. Otherwise a request for garbage collection is sent to the process identified by <code class="code">Pid</code>, and will be handled when appropriate. If no <code class="code">async</code> option has been passed, the caller blocks until <code class="code">GCResult</code> is available and can be returned.</p> <p><code class="code">GCResult</code> informs about the result of the garbage collection request as follows:</p> <dl> <dt><strong><code class="code">true</code></strong></dt> <dd> The process identified by <code class="code">Pid</code> has been garbage collected. </dd> <dt><strong><code class="code">false</code></strong></dt> <dd> No garbage collection was performed, as the process identified by <code class="code">Pid</code> terminated before the request could be satisfied. </dd> </dl> <p>Notice that the same caveats apply as for <code class="bold_code"><a href="#garbage_collect-0"><span class="code">garbage_collect/0</span></a></code>.</p> <p>Failures:</p> <dl> <dt><strong><code class="code">badarg</code></strong></dt> <dd> If <code class="code">Pid</code> is not a node local process identifier. </dd> <dt><strong><code class="code">badarg</code></strong></dt> <dd> If <code class="code">OptionList</code> is an invalid list of options. </dd> </dl>  <h3 id="get-0" class="code">get() -&gt; [{Key, Val}]</h3> <p>Types:</p>    <pre>Key = Val = term()</pre>

<p>Returns the process dictionary as a list of <code class="code">{Key, Val}</code> tuples, for example:</p> <div class="example"><pre>
&gt; put(key1, merry),
put(key2, lambs),
put(key3, {are, playing}),
get().
[{key1,merry},{key2,lambs},{key3,{are,playing}}]</pre></div>  <h3 id="get-1" class="code">get(Key) -&gt; Val | undefined</h3> <p>Types:</p>    <pre>Key = Val = term()</pre>

<p>Returns the value <code class="code">Val</code> associated with <code class="code">Key</code> in the process dictionary, or <code class="code">undefined</code> if <code class="code">Key</code> does not exist. Example:</p> <div class="example"><pre>
&gt; put(key1, merry),
put(key2, lambs),
put({any, [valid, term]}, {are, playing}),
get({any, [valid, term]}).
{are,playing}</pre></div>  <h3 id="get_cookie-0" class="code">erlang:get_cookie() -&gt; Cookie | nocookie</h3> <p>Types:</p>   <pre>Cookie = atom()</pre>

<p>Returns the magic cookie of the local node if the node is alive, otherwise the atom <code class="code">nocookie</code>.</p>  <h3 id="get_keys-0" class="code">get_keys() -&gt; [Key]</h3> <p>Types:</p>   <pre>Key = term()</pre>

<p>Returns a list of all keys present in the process dictionary, for example:</p> <div class="example"><pre>
&gt; put(dog, {animal,1}),
put(cow, {animal,2}),
put(lamb, {animal,3}),
get_keys().
[dog,cow,lamb]</pre></div>  <h3 id="get_keys-1" class="code">get_keys(Val) -&gt; [Key]</h3> <p>Types:</p>    <pre>Val = Key = term()</pre>

<p>Returns a list of keys that are associated with the value <code class="code">Val</code> in the process dictionary, for example:</p> <div class="example"><pre>
&gt; put(mary, {1, 2}),
put(had, {1, 2}),
put(a, {1, 2}),
put(little, {1, 2}),
put(dog, {1, 3}),
put(lamb, {1, 2}),
get_keys({1, 2}).
[mary,had,a,little,lamb]</pre></div>  <h3 id="get_stacktrace-0" class="code">erlang:get_stacktrace() -&gt; [stack_item()]</h3> <p>Types:</p>   <pre>stack_item() = 
    {Module :: module(),
     Function :: atom(),
     Arity :: arity() | (Args :: [term()]),
     Location ::
         [{file, Filename :: string()} |
          {line, Line :: integer() &gt;= 1}]}</pre>

<p>Gets the call stack back-trace (<strong>stacktrace</strong>) of the last exception in the calling process as a list of <code class="code">{Module,Function,Arity,Location}</code> tuples. Field <code class="code">Arity</code> in the first tuple can be the argument list of that function call instead of an arity integer, depending on the exception.</p> <p>If there has not been any exceptions in a process, the stacktrace is <code class="code">[]</code>. After a code change for the process, the stacktrace can also be reset to <code class="code">[]</code>.</p> <p>The stacktrace is the same data as operator <code class="code">catch</code> returns, for example:</p> <div class="example"><pre>
{'EXIT',{badarg,Stacktrace}} = catch abs(x)</pre></div> <p><code class="code">Location</code> is a (possibly empty) list of two-tuples that can indicate the location in the source code of the function. The first element is an atom describing the type of information in the second element. The following items can occur:</p> <dl> <dt><strong><code class="code">file</code></strong></dt> <dd>The second element of the tuple is a string (list of characters) representing the filename of the source file of the function. </dd> <dt><strong><code class="code">line</code></strong></dt> <dd>The second element of the tuple is the line number (an integer &gt; 0) in the source file where the exception occurred or the function was called. </dd> </dl> <p>See also <code class="bold_code"><a href="#error-1"><span class="code">error/1</span></a></code> and <code class="bold_code"><a href="#error-2"><span class="code">error/2</span></a></code>.</p>  <h3 id="group_leader-0" class="code">group_leader() -&gt; pid()</h3> 
<p>Returns the process identifier of the group leader for the process evaluating the function.</p> <p>Every process is a member of some process group and all groups have a <strong>group leader</strong>. All I/O from the group is channeled to the group leader. When a new process is spawned, it gets the same group leader as the spawning process. Initially, at system startup, <code class="code">init</code> is both its own group leader and the group leader of all processes.</p>  <h3 id="group_leader-2" class="code">group_leader(GroupLeader, Pid) -&gt; true</h3> <p>Types:</p>    <pre>GroupLeader = Pid = pid()</pre>

<p>Sets the group leader of <code class="code">Pid</code> to <code class="code">GroupLeader</code>. Typically, this is used when a process started from a certain shell is to have another group leader than <code class="code">init</code>.</p> <p>See also <code class="bold_code"><a href="#group_leader-0"><span class="code">group_leader/0</span></a></code>.</p>  <h3 id="halt-0" class="code">halt() -&gt; no_return()</h3> 
<p>The same as <code class="bold_code"><a href="#halt-2"><span class="code">halt(0, [])</span></a></code>. Example:</p> <div class="example"><pre>
&gt; halt().
os_prompt%</pre></div>  <h3 id="halt-1" class="code">halt(Status) -&gt; no_return()</h3> <p>Types:</p>   <pre>Status = integer() &gt;= 0 | abort | string()</pre>

<p>The same as <code class="bold_code"><a href="#halt-2"><span class="code">halt(Status, [])</span></a></code>. Example:</p> <div class="example"><pre>
&gt; halt(17).
os_prompt% echo $?
17
os_prompt%</pre></div>  <h3 id="halt-2" class="code">halt(Status, Options) -&gt; no_return()</h3> <p>Types:</p>     <pre>Status = integer() &gt;= 0 | abort | string()
Options = [Option]
Option = {flush, boolean()}</pre>

<p><code class="code">Status</code> must be a non-negative integer, a string, or the atom <code class="code">abort</code>. Halts the Erlang runtime system. Has no return value. Depending on <code class="code">Status</code>, the following occurs:</p> <dl> <dt><strong>integer()</strong></dt> <dd>The runtime system exits with integer value <code class="code">Status</code> as status code to the calling environment (OS). </dd> <dt><strong>string()</strong></dt> <dd>An Erlang crash dump is produced with <code class="code">Status</code> as slogan. Then the runtime system exits with status code <code class="code">1</code>. Note that only code points in the range 0-255 may be used and the string will be truncated if longer than 200 characters. </dd> <dt><strong><code class="code">abort</code></strong></dt> <dd>The runtime system aborts producing a core dump, if that is enabled in the OS. </dd> </dl> <div class="note"> <div class="label">Note</div> <div class="content">

<p>On many platforms, the OS supports only status codes 0-255. A too large status code is truncated by clearing the high bits.</p> </div> </div> <p>For integer <code class="code">Status</code>, the Erlang runtime system closes all ports and allows async threads to finish their operations before exiting. To exit without such flushing, use <code class="code">Option</code> as <code class="code">{flush,false}</code>.</p> <p>For statuses <code class="code">string()</code> and <code class="code">abort</code>, option <code class="code">flush</code> is ignored and flushing is <strong>not</strong> done.</p>  <h3 id="hash-2" class="code">erlang:hash(Term, Range) -&gt; integer() &gt;= 1</h3> <p>Types:</p>    <pre>Term = term()
Range = integer() &gt;= 1</pre>

<p>Returns a hash value for <code class="code">Term</code> within the range <code class="code">1..Range</code>. The maximum range is 1..2^27-1.</p> <div class="warning"> <div class="label">Warning</div> <div class="content">

<p><strong>This BIF is deprecated, as the hash value can differ on different architectures.</strong> The hash values for integer terms &gt; 2^27 and large binaries are poor. The BIF is retained for backward compatibility reasons (it can have been used to hash records into a file), but all new code is to use one of the BIFs <code class="bold_code"><a href="#phash-2"><span class="code">erlang:phash/2</span></a></code> or <code class="bold_code"><a href="#phash2-1"><span class="code">erlang:phash2/1,2</span></a></code> instead.</p> </div> </div>  <h3 id="hd-1" class="code">hd(List) -&gt; term()</h3> <p>Types:</p>   <pre>List = [term(), ...]</pre>

<p>Returns the head of <code class="code">List</code>, that is, the first element, for example:</p> <div class="example"><pre>
&gt; hd([1,2,3,4,5]).
1</pre></div> <p>Allowed in guard tests.</p> <p>Failure: <code class="code">badarg</code> if <code class="code">List</code> is the empty list <code class="code">[]</code>.</p>  <h3 id="hibernate-3" class="code">erlang:hibernate(Module, Function, Args) -&gt; no_return()</h3> <p>Types:</p>     <pre>Module = module()
Function = atom()
Args = [term()]</pre>

<p>Puts the calling process into a wait state where its memory allocation has been reduced as much as possible. This is useful if the process does not expect to receive any messages soon.</p> <p>The process is awaken when a message is sent to it, and control resumes in <code class="code">Module:Function</code> with the arguments specified by <code class="code">Args</code> with the call stack emptied, meaning that the process terminates when that function returns. Thus <code class="code">erlang:hibernate/3</code> never returns to its caller.</p> <p>If the process has any message in its message queue, the process is awakened immediately in the same way as described earlier.</p> <p>In more technical terms, <code class="code">erlang:hibernate/3</code> discards the call stack for the process, and then garbage collects the process. After this, all live data is in one continuous heap. The heap is then shrunken to the exact same size as the live data that it holds (even if that size is less than the minimum heap size for the process).</p> <p>If the size of the live data in the process is less than the minimum heap size, the first garbage collection occurring after the process is awakened ensures that the heap size is changed to a size not smaller than the minimum heap size.</p> <p>Notice that emptying the call stack means that any surrounding <code class="code">catch</code> is removed and must be re-inserted after hibernation. One effect of this is that processes started using <code class="code">proc_lib</code> (also indirectly, such as <code class="code">gen_server</code> processes), are to use <code class="bold_code"><span class="code">proc_lib:hibernate/3</span></code> instead, to ensure that the exception handler continues to work when the process wakes up.</p>  <h3 id="insert_element-3" class="code">erlang:insert_element(Index, Tuple1, Term) -&gt; Tuple2</h3> <p>Types:</p>  <pre>Index = integer() &gt;= 1</pre>
<p class="REFBODY">1..tuple_size(Tuple1) + 1</p>     <pre>Tuple1 = Tuple2 = tuple()

Term = term()</pre>

<p>Returns a new tuple with element <code class="code">Term</code> inserted at position <code class="code">Index</code> in tuple <code class="code">Tuple1</code>. All elements from position <code class="code">Index</code> and upwards are pushed one step higher in the new tuple <code class="code">Tuple2</code>. Example:</p> <div class="example"><pre>
&gt; erlang:insert_element(2, {one, two, three}, new).
{one,new,two,three}</pre></div>  <h3 id="integer_to_binary-1" class="code">integer_to_binary(Integer) -&gt; binary()</h3> <p>Types:</p>   <pre>Integer = integer()</pre>

<p>Returns a binary corresponding to the text representation of <code class="code">Integer</code>, for example:</p> <div class="example"><pre>
&gt; integer_to_binary(77).
&lt;&lt;"77"&gt;&gt;</pre></div>  <h3 id="integer_to_binary-2" class="code">integer_to_binary(Integer, Base) -&gt; binary()</h3> <p>Types:</p>    <pre>Integer = integer()
Base = 2..36</pre>

<p>Returns a binary corresponding to the text representation of <code class="code">Integer</code> in base <code class="code">Base</code>, for example:</p> <div class="example"><pre>
&gt; integer_to_binary(1023, 16).
&lt;&lt;"3FF"&gt;&gt;</pre></div>  <h3 id="integer_to_list-1" class="code">integer_to_list(Integer) -&gt; string()</h3> <p>Types:</p>   <pre>Integer = integer()</pre>

<p>Returns a string corresponding to the text representation of <code class="code">Integer</code>, for example:</p> <div class="example"><pre>
&gt; integer_to_list(77).
"77"</pre></div>  <h3 id="integer_to_list-2" class="code">integer_to_list(Integer, Base) -&gt; string()</h3> <p>Types:</p>    <pre>Integer = integer()
Base = 2..36</pre>

<p>Returns a string corresponding to the text representation of <code class="code">Integer</code> in base <code class="code">Base</code>, for example:</p> <div class="example"><pre>
&gt; integer_to_list(1023, 16).
"3FF"</pre></div>  <h3 id="iolist_size-1" class="code">iolist_size(Item) -&gt; integer() &gt;= 0</h3> <p>Types:</p>   <pre>Item = iolist() | binary()</pre>

<p>Returns an integer, that is the size in bytes, of the binary that would be the result of <code class="code">iolist_to_binary(Item)</code>, for example:</p> <div class="example"><pre>
&gt; iolist_size([1,2|&lt;&lt;3,4&gt;&gt;]).
4</pre></div>  <h3 id="iolist_to_binary-1" class="code">iolist_to_binary(IoListOrBinary) -&gt; binary()</h3> <p>Types:</p>   <pre>IoListOrBinary = iolist() | binary()</pre>

<p>Returns a binary that is made from the integers and binaries in <code class="code">IoListOrBinary</code>, for example:</p> <div class="example"><pre>
&gt; Bin1 = &lt;&lt;1,2,3&gt;&gt;.
&lt;&lt;1,2,3&gt;&gt;
&gt; Bin2 = &lt;&lt;4,5&gt;&gt;.
&lt;&lt;4,5&gt;&gt;
&gt; Bin3 = &lt;&lt;6&gt;&gt;.
&lt;&lt;6&gt;&gt;
&gt; iolist_to_binary([Bin1,1,[2,3,Bin2],4|Bin3]).
&lt;&lt;1,2,3,1,2,3,4,5,4,6&gt;&gt;</pre></div>  <h3 id="is_alive-0" class="code">is_alive() -&gt; boolean()</h3> 
<p>Returns <code class="code">true</code> if the local node is alive (that is, if the node can be part of a distributed system), otherwise <code class="code">false</code>.</p>  <h3 id="is_atom-1" class="code">is_atom(Term) -&gt; boolean()</h3> <p>Types:</p>   <pre>Term = term()</pre>

<p>Returns <code class="code">true</code> if <code class="code">Term</code> is an atom, otherwise <code class="code">false</code>.</p> <p>Allowed in guard tests.</p>  <h3 id="is_binary-1" class="code">is_binary(Term) -&gt; boolean()</h3> <p>Types:</p>   <pre>Term = term()</pre>

<p>Returns <code class="code">true</code> if <code class="code">Term</code> is a binary, otherwise <code class="code">false</code>.</p> <p>A binary always contains a complete number of bytes.</p> <p>Allowed in guard tests.</p>  <h3 id="is_bitstring-1" class="code">is_bitstring(Term) -&gt; boolean()</h3> <p>Types:</p>   <pre>Term = term()</pre>

<p>Returns <code class="code">true</code> if <code class="code">Term</code> is a bitstring (including a binary), otherwise <code class="code">false</code>.</p> <p>Allowed in guard tests.</p>  <h3 id="is_boolean-1" class="code">is_boolean(Term) -&gt; boolean()</h3> <p>Types:</p>   <pre>Term = term()</pre>

<p>Returns <code class="code">true</code> if <code class="code">Term</code> is the atom <code class="code">true</code> or the atom <code class="code">false</code> (that is, a boolean). Otherwise returns <code class="code">false</code>.</p> <p>Allowed in guard tests.</p>  <h3 id="is_builtin-3" class="code">erlang:is_builtin(Module, Function, Arity) -&gt; boolean()</h3> <p>Types:</p>     <pre>Module = module()
Function = atom()
Arity = arity()</pre>

<p>This BIF is useful for builders of cross-reference tools.</p> <p>Returns <code class="code">true</code> if <code class="code">Module:Function/Arity</code> is a BIF implemented in C, otherwise <code class="code">false</code>.</p>  <h3 id="is_float-1" class="code">is_float(Term) -&gt; boolean()</h3> <p>Types:</p>   <pre>Term = term()</pre>

<p>Returns <code class="code">true</code> if <code class="code">Term</code> is a floating point number, otherwise <code class="code">false</code>.</p> <p>Allowed in guard tests.</p>  <h3 id="is_function-1" class="code">is_function(Term) -&gt; boolean()</h3> <p>Types:</p>   <pre>Term = term()</pre>

<p>Returns <code class="code">true</code> if <code class="code">Term</code> is a fun, otherwise <code class="code">false</code>.</p> <p>Allowed in guard tests.</p>  <h3 id="is_function-2" class="code">is_function(Term, Arity) -&gt; boolean()</h3> <p>Types:</p>    <pre>Term = term()
Arity = arity()</pre>

<p>Returns <code class="code">true</code> if <code class="code">Term</code> is a fun that can be applied with <code class="code">Arity</code> number of arguments, otherwise <code class="code">false</code>.</p> <p>Allowed in guard tests.</p>  <h3 id="is_integer-1" class="code">is_integer(Term) -&gt; boolean()</h3> <p>Types:</p>   <pre>Term = term()</pre>

<p>Returns <code class="code">true</code> if <code class="code">Term</code> is an integer, otherwise <code class="code">false</code>.</p> <p>Allowed in guard tests.</p>  <h3 id="is_list-1" class="code">is_list(Term) -&gt; boolean()</h3> <p>Types:</p>   <pre>Term = term()</pre>

<p>Returns <code class="code">true</code> if <code class="code">Term</code> is a list with zero or more elements, otherwise <code class="code">false</code>.</p> <p>Allowed in guard tests.</p>  <h3 id="is_map-1" class="code">is_map(Term) -&gt; boolean()</h3> <p>Types:</p>   <pre>Term = term()</pre>

<p>Returns <code class="code">true</code> if <code class="code">Term</code> is a map, otherwise <code class="code">false</code>.</p> <p>Allowed in guard tests.</p>  <h3 id="is_number-1" class="code">is_number(Term) -&gt; boolean()</h3> <p>Types:</p>   <pre>Term = term()</pre>

<p>Returns <code class="code">true</code> if <code class="code">Term</code> is an integer or a floating point number. Otherwise returns <code class="code">false</code>.</p> <p>Allowed in guard tests.</p>  <h3 id="is_pid-1" class="code">is_pid(Term) -&gt; boolean()</h3> <p>Types:</p>   <pre>Term = term()</pre>

<p>Returns <code class="code">true</code> if <code class="code">Term</code> is a process identifier, otherwise <code class="code">false</code>.</p> <p>Allowed in guard tests.</p>  <h3 id="is_port-1" class="code">is_port(Term) -&gt; boolean()</h3> <p>Types:</p>   <pre>Term = term()</pre>

<p>Returns <code class="code">true</code> if <code class="code">Term</code> is a port identifier, otherwise <code class="code">false</code>.</p> <p>Allowed in guard tests.</p>  <h3 id="is_process_alive-1" class="code">is_process_alive(Pid) -&gt; boolean()</h3> <p>Types:</p>   <pre>Pid = pid()</pre>

<p><code class="code">Pid</code> must refer to a process at the local node.</p> <p>Returns <code class="code">true</code> if the process exists and is alive, that is, is not exiting and has not exited. Otherwise returns <code class="code">false</code>.</p>  <h3 id="is_record-2" class="code">is_record(Term, RecordTag) -&gt; boolean()</h3> <p>Types:</p>    <pre>Term = term()
RecordTag = atom()</pre>

<p>Returns <code class="code">true</code> if <code class="code">Term</code> is a tuple and its first element is <code class="code">RecordTag</code>. Otherwise returns <code class="code">false</code>.</p> <div class="note"> <div class="label">Note</div> <div class="content">

<p>Normally the compiler treats calls to <code class="code">is_record/2</code> especially. It emits code to verify that <code class="code">Term</code> is a tuple, that its first element is <code class="code">RecordTag</code>, and that the size is correct. However, if <code class="code">RecordTag</code> is not a literal atom, the BIF <code class="code">is_record/2</code> is called instead and the size of the tuple is not verified.</p> </div> </div> <p>Allowed in guard tests, if <code class="code">RecordTag</code> is a literal atom.</p>  <h3 id="is_record-3" class="code">is_record(Term, RecordTag, Size) -&gt; boolean()</h3> <p>Types:</p>     <pre>Term = term()
RecordTag = atom()
Size = integer() &gt;= 0</pre>

<p><code class="code">RecordTag</code> must be an atom.</p> <p>Returns <code class="code">true</code> if <code class="code">Term</code> is a tuple, its first element is <code class="code">RecordTag</code>, and its size is <code class="code">Size</code>. Otherwise returns <code class="code">false</code>.</p> <p>Allowed in guard tests if <code class="code">RecordTag</code> is a literal atom and <code class="code">Size</code> is a literal integer.</p> <div class="note"> <div class="label">Note</div> <div class="content">

<p>This BIF is documented for completeness. Usually <code class="code">is_record/2</code> is to be used.</p> </div> </div>  <h3 id="is_reference-1" class="code">is_reference(Term) -&gt; boolean()</h3> <p>Types:</p>   <pre>Term = term()</pre>

<p>Returns <code class="code">true</code> if <code class="code">Term</code> is a reference, otherwise <code class="code">false</code>.</p> <p>Allowed in guard tests.</p>  <h3 id="is_tuple-1" class="code">is_tuple(Term) -&gt; boolean()</h3> <p>Types:</p>   <pre>Term = term()</pre>

<p>Returns <code class="code">true</code> if <code class="code">Term</code> is a tuple, otherwise <code class="code">false</code>.</p> <p>Allowed in guard tests.</p>  <h3 id="length-1" class="code">length(List) -&gt; integer() &gt;= 0</h3> <p>Types:</p>   <pre>List = [term()]</pre>

<p>Returns the length of <code class="code">List</code>, for example:</p> <div class="example"><pre>
&gt; length([1,2,3,4,5,6,7,8,9]).
9</pre></div> <p>Allowed in guard tests.</p>  <h3 id="link-1" class="code">link(PidOrPort) -&gt; true</h3> <p>Types:</p>   <pre>PidOrPort = pid() | port()</pre>

<p>Creates a link between the calling process and another process (or port) <code class="code">PidOrPort</code>, if there is not such a link already. If a process attempts to create a link to itself, nothing is done. Returns <code class="code">true</code>.</p> <p>If <code class="code">PidOrPort</code> does not exist, the behavior of the BIF depends on if the calling process is trapping exits or not (see <code class="bold_code"><a href="#process_flag-2"><span class="code">process_flag/2</span></a></code>):</p> <ul> <li><p>If the calling process is not trapping exits, and checking <code class="code">PidOrPort</code> is cheap (that is, if <code class="code">PidOrPort</code> is local), <code class="code">link/1</code> fails with reason <code class="code">noproc</code>.</p></li> <li><p>Otherwise, if the calling process is trapping exits, and/or <code class="code">PidOrPort</code> is remote, <code class="code">link/1</code> returns <code class="code">true</code>, but an exit signal with reason <code class="code">noproc</code> is sent to the calling process.</p></li> </ul>  <h3 id="list_to_atom-1" class="code">list_to_atom(String) -&gt; atom()</h3> <p>Types:</p>   <pre>String = string()</pre>

<p>Returns the atom whose text representation is <code class="code">String</code>.</p> <p><code class="code">String</code> can only contain ISO-latin-1 characters (that is, numbers &lt; 256) as the implementation does not allow Unicode characters equal to or above 256 in atoms. For more information on Unicode support in atoms, see <code class="bold_code"><a href="../erl_ext_dist/#utf8_atoms">note on UTF-8 encoded atoms</a></code> in section "External Term Format" in the User's Guide.</p> <p>Example:</p> <div class="example"><pre>
&gt; list_to_atom("Erlang").
'Erlang'</pre></div>  <h3 id="list_to_binary-1" class="code">list_to_binary(IoList) -&gt; binary()</h3> <p>Types:</p>   <pre>IoList = iolist()</pre>

<p>Returns a binary that is made from the integers and binaries in <code class="code">IoList</code>, for example:</p> <div class="example"><pre>
&gt; Bin1 = &lt;&lt;1,2,3&gt;&gt;.
&lt;&lt;1,2,3&gt;&gt;
&gt; Bin2 = &lt;&lt;4,5&gt;&gt;.
&lt;&lt;4,5&gt;&gt;
&gt; Bin3 = &lt;&lt;6&gt;&gt;.
&lt;&lt;6&gt;&gt;
&gt; list_to_binary([Bin1,1,[2,3,Bin2],4|Bin3]).
&lt;&lt;1,2,3,1,2,3,4,5,4,6&gt;&gt;</pre></div>  <h3 id="list_to_bitstring-1" class="code">list_to_bitstring(BitstringList) -&gt; bitstring()</h3> <p>Types:</p>    <pre>BitstringList = bitstring_list()
bitstring_list() = 
    maybe_improper_list(byte() | bitstring() | bitstring_list(),
                        bitstring() | [])</pre>

<p>Returns a bitstring that is made from the integers and bitstrings in <code class="code">BitstringList</code>. (The last tail in <code class="code">BitstringList</code> is allowed to be a bitstring.) Example:</p> <div class="example"><pre>
&gt; Bin1 = &lt;&lt;1,2,3&gt;&gt;.
&lt;&lt;1,2,3&gt;&gt;
&gt; Bin2 = &lt;&lt;4,5&gt;&gt;.
&lt;&lt;4,5&gt;&gt;
&gt; Bin3 = &lt;&lt;6,7:4&gt;&gt;.
&lt;&lt;6,7:4&gt;&gt;
&gt; list_to_bitstring([Bin1,1,[2,3,Bin2],4|Bin3]).
&lt;&lt;1,2,3,1,2,3,4,5,4,6,7:4&gt;&gt;</pre></div>  <h3 id="list_to_existing_atom-1" class="code">list_to_existing_atom(String) -&gt; atom()</h3> <p>Types:</p>   <pre>String = string()</pre>

<p>Returns the atom whose text representation is <code class="code">String</code>, but only if there already exists such atom.</p> <p>Failure: <code class="code">badarg</code> if there does not already exist an atom whose text representation is <code class="code">String</code>.</p>  <h3 id="list_to_float-1" class="code">list_to_float(String) -&gt; float()</h3> <p>Types:</p>   <pre>String = string()</pre>

<p>Returns the float whose text representation is <code class="code">String</code>, for example:</p> <div class="example"><pre>
&gt; list_to_float("2.2017764e+0").
2.2017764</pre></div> <p>Failure: <code class="code">badarg</code> if <code class="code">String</code> contains a bad representation of a float.</p>  <h3 id="list_to_integer-1" class="code">list_to_integer(String) -&gt; integer()</h3> <p>Types:</p>   <pre>String = string()</pre>

<p>Returns an integer whose text representation is <code class="code">String</code>, for example:</p> <div class="example"><pre>
&gt; list_to_integer("123").
123</pre></div> <p>Failure: <code class="code">badarg</code> if <code class="code">String</code> contains a bad representation of an integer.</p>  <h3 id="list_to_integer-2" class="code">list_to_integer(String, Base) -&gt; integer()</h3> <p>Types:</p>    <pre>String = string()
Base = 2..36</pre>

<p>Returns an integer whose text representation in base <code class="code">Base</code> is <code class="code">String</code>, for example:</p> <div class="example"><pre>
&gt; list_to_integer("3FF", 16).
1023</pre></div> <p>Failure: <code class="code">badarg</code> if <code class="code">String</code> contains a bad representation of an integer.</p>  <h3 id="list_to_pid-1" class="code">list_to_pid(String) -&gt; pid()</h3> <p>Types:</p>   <pre>String = string()</pre>

<p>Returns a process identifier whose text representation is a <code class="code">String</code>, for example:</p> <div class="example"><pre>
&gt; list_to_pid("&lt;0.4.1&gt;").
&lt;0.4.1&gt;</pre></div> <p>Failure: <code class="code">badarg</code> if <code class="code">String</code> contains a bad representation of a process identifier.</p> <div class="warning"> <div class="label">Warning</div> <div class="content">

<p>This BIF is intended for debugging and is not to be used in application programs.</p> </div> </div>  <h3 id="list_to_tuple-1" class="code">list_to_tuple(List) -&gt; tuple()</h3> <p>Types:</p>   <pre>List = [term()]</pre>

<p>Returns a tuple corresponding to <code class="code">List</code>, for example</p> <div class="example"><pre>
&gt; list_to_tuple([share, ['Ericsson_B', 163]]).
{share, ['Ericsson_B', 163]}</pre></div> <p><code class="code">List</code> can contain any Erlang terms.</p>  <h3 id="load_module-2" class="code">load_module(Module, Binary) -&gt; {module, Module} | {error, Reason}</h3> <p>Types:</p>     <pre>Module = module()
Binary = binary()
Reason = badfile | not_purged | on_load</pre>

<p>If <code class="code">Binary</code> contains the object code for module <code class="code">Module</code>, this BIF loads that object code. If the code for module <code class="code">Module</code> already exists, all export references are replaced so they point to the newly loaded code. The previously loaded code is kept in the system as old code, as there can still be processes executing that code.</p> <p>Returns either <code class="code">{module, Module}</code>, or <code class="code">{error, Reason}</code> if loading fails. <code class="code">Reason</code> is one of the following:</p> <dl> <dt><strong><code class="code">badfile</code></strong></dt> <dd>The object code in <code class="code">Binary</code> has an incorrect format <strong>or</strong> the object code contains code for another module than <code class="code">Module</code>. </dd> <dt><strong><code class="code">not_purged</code></strong></dt> <dd> <code class="code">Binary</code> contains a module that cannot be loaded because old code for this module already exists. </dd> </dl> <div class="warning"> <div class="label">Warning</div> <div class="content">

<p>This BIF is intended for the code server (see <code class="bold_code"><span class="code">code(3)</span></code>) and is not to be used elsewhere.</p> </div> </div>  <h3 id="load_nif-2" class="code">erlang:load_nif(Path, LoadInfo) -&gt; ok | Error</h3> <p>Types:</p>      <pre>Path = string()
LoadInfo = term()
Error = {error, {Reason, Text :: string()}}
Reason = 
    load_failed | bad_lib | load | reload | upgrade | old_code</pre>

<div class="note"> <div class="label">Note</div> <div class="content">

<p>Before Erlang/OTP R14B, NIFs were an experimental feature. Versions before Erlang/OTP R14B can have different and possibly incompatible NIF semantics and interfaces. For example, in Erlang/OTP R13B03 the return value on failure was <code class="code">{error,Reason,Text}</code>.</p> </div> </div> <p>Loads and links a dynamic library containing native implemented functions (NIFs) for a module. <code class="code">Path</code> is a file path to the shareable object/dynamic library file minus the OS-dependent file extension (<code class="code">.so</code> for Unix and <code class="code">.dll</code> for Windows). Notice that on most OSs the library has to have a different name on disc when an upgrade of the nif is done. If the name is the same, but the contents differ, the old library may be loaded instead. For information on how to implement a NIF library, see <code class="bold_code"><a href="../erl_nif/"><span class="code">erl_nif(3)</span></a></code>.</p> <p><code class="code">LoadInfo</code> can be any term. It is passed on to the library as part of the initialization. A good practice is to include a module version number to support future code upgrade scenarios.</p> <p>The call to <code class="code">load_nif/2</code> must be made <strong>directly</strong> from the Erlang code of the module that the NIF library belongs to. It returns either <code class="code">ok</code>, or <code class="code">{error,{Reason,Text}}</code> if loading fails. <code class="code">Reason</code> is one of the following atoms while <code class="code">Text</code> is a human readable string that can give more information about the failure:</p> <dl> <dt><strong><code class="code">load_failed</code></strong></dt> <dd>The OS failed to load the NIF library. </dd> <dt><strong><code class="code">bad_lib</code></strong></dt> <dd>The library did not fulfill the requirements as a NIF library of the calling module. </dd> <dt><strong><code class="code">load | reload | upgrade</code></strong></dt> <dd>The corresponding library callback was unsuccessful. </dd> <dt><strong><code class="code">old_code</code></strong></dt> <dd>The call to <code class="code">load_nif/2</code> was made from the old code of a module that has been upgraded; this is not allowed. </dd> </dl>  <h3 id="loaded-0" class="code">erlang:loaded() -&gt; [Module]</h3> <p>Types:</p>   <pre>Module = module()</pre>

<p>Returns a list of all loaded Erlang modules (current and old code), including preloaded modules.</p> <p>See also <code class="bold_code"><span class="code">code(3)</span></code>.</p>  <h3 id="localtime-0" class="code">erlang:localtime() -&gt; DateTime</h3> <p>Types:</p>   <pre>DateTime = calendar:datetime()</pre>

<p>Returns the current local date and time, <code class="code">{{Year, Month, Day}, {Hour, Minute, Second}}</code>, for example:</p> <div class="example"><pre>
&gt; erlang:localtime().
{{1996,11,6},{14,45,17}}</pre></div> <p>The time zone and Daylight Saving Time correction depend on the underlying OS.</p>  <h3 id="localtime_to_universaltime-1" class="code">erlang:localtime_to_universaltime(Localtime) -&gt; Universaltime</h3> <p>Types:</p>    <pre>Localtime = Universaltime = calendar:datetime()</pre>

<p>Converts local date and time to Universal Time Coordinated (UTC), if supported by the underlying OS. Otherwise no conversion is done and <code class="code">Localtime</code> is returned. Example:</p> <div class="example"><pre>
&gt; erlang:localtime_to_universaltime({{1996,11,6},{14,45,17}}).
{{1996,11,6},{13,45,17}}</pre></div> <p>Failure: <code class="code">badarg</code> if <code class="code">Localtime</code> denotes an invalid date and time.</p>  <h3 id="localtime_to_universaltime-2" class="code">erlang:localtime_to_universaltime(Localtime, IsDst) -&gt;<br>                                     Universaltime</h3> <p>Types:</p>     <pre>Localtime = Universaltime = calendar:datetime()

IsDst = true | false | undefined</pre>

<p>Converts local date and time to Universal Time Coordinated (UTC) as <code class="code">erlang:localtime_to_universaltime/1</code>, but the caller decides if Daylight Saving Time is active.</p> <p>If <code class="code">IsDst == true</code>, <code class="code">Localtime</code> is during Daylight Saving Time, if <code class="code">IsDst == false</code> it is not. If <code class="code">IsDst == undefined</code>, the underlying OS can guess, which is the same as calling <code class="code">erlang:localtime_to_universaltime(Localtime)</code>.</p> <p>Examples:</p> <div class="example"><pre>
&gt; erlang:localtime_to_universaltime({{1996,11,6},{14,45,17}}, true).
{{1996,11,6},{12,45,17}}
&gt; erlang:localtime_to_universaltime({{1996,11,6},{14,45,17}}, false).
{{1996,11,6},{13,45,17}}
&gt; erlang:localtime_to_universaltime({{1996,11,6},{14,45,17}}, undefined).
{{1996,11,6},{13,45,17}}</pre></div> <p>Failure: <code class="code">badarg</code> if <code class="code">Localtime</code> denotes an invalid date and time.</p>  <h3 id="make_ref-0" class="code">make_ref() -&gt; reference()</h3> 
<p>Returns a <code class="bold_code">unique reference</code>. The reference is unique among connected nodes.</p> <div class="warning"> <div class="label">Warning</div> <div class="content">

<p>Known issue: When a node is restarted multiple times with the same node name, references created on a newer node can be mistaken for a reference created on an older node with the same node name.</p> </div> </div>  <h3 id="make_tuple-2" class="code">erlang:make_tuple(Arity, InitialValue) -&gt; tuple()</h3> <p>Types:</p>    <pre>Arity = arity()
InitialValue = term()</pre>

<p>Creates a new tuple of the specified <code class="code">Arity</code>, where all elements are <code class="code">InitialValue</code>, for example:</p> <div class="example"><pre>
&gt; erlang:make_tuple(4, []).
{[],[],[],[]}</pre></div>  <h3 id="make_tuple-3" class="code">erlang:make_tuple(Arity, DefaultValue, InitList) -&gt; tuple()</h3> <p>Types:</p>     <pre>Arity = arity()
DefaultValue = term()
InitList = [{Position :: integer() &gt;= 1, term()}]</pre>

<p>Creates a tuple of size <code class="code">Arity</code>, where each element has value <code class="code">DefaultValue</code>, and then fills in values from <code class="code">InitList</code>. Each list element in <code class="code">InitList</code> must be a two-tuple, where the first element is a position in the newly created tuple and the second element is any term. If a position occurs more than once in the list, the term corresponding to the last occurrence is used. Example:</p> <div class="example"><pre>
&gt; erlang:make_tuple(5, [], [{2,ignored},{5,zz},{2,aa}]).
{[],aa,[],[],zz}</pre></div>  <h3 id="map_size-1" class="code">map_size(Map) -&gt; integer() &gt;= 0</h3> <p>Types:</p>   <pre>Map = #{}</pre>

<p>Returns an integer, which is the number of key-value pairs in <code class="code">Map</code>, for example:</p> <div class="example"><pre>
&gt; map_size(#{a=&gt;1, b=&gt;2, c=&gt;3}).
3</pre></div> <p>Allowed in guard tests.</p>  <h3 id="match_spec_test-3" class="code">erlang:match_spec_test(MatchAgainst, MatchSpec, Type) -&gt;<br>                          TestResult</h3> <p>Types:</p>      <pre>MatchAgainst = [term()] | tuple()
MatchSpec = term()
Type = table | trace
TestResult = 
    {ok, term(), [return_trace], [{error | warning, string()}]} |
    {error, [{error | warning, string()}]}</pre>

<p>Tests a match specification used in calls to <code class="bold_code"><span class="code">ets:select/2</span></code> and <code class="bold_code"><a href="#trace_pattern-3"><span class="code">erlang:trace_pattern/3</span></a></code>. The function tests both a match specification for "syntactic" correctness and runs the match specification against the object. If the match specification contains errors, the tuple <code class="code">{error, Errors}</code> is returned, where <code class="code">Errors</code> is a list of natural language descriptions of what was wrong with the match specification.</p> <p>If <code class="code">Type</code> is <code class="code">table</code>, the object to match against is to be a tuple. The function then returns <code class="code">{ok,Result,[],Warnings}</code>, where <code class="code">Result</code> is what would have been the result in a real <code class="code">ets:select/2</code> call, or <code class="code">false</code> if the match specification does not match the object tuple.</p> <p>If <code class="code">Type</code> is <code class="code">trace</code>, the object to match against is to be a list. The function returns <code class="code">{ok, Result, Flags, Warnings}</code>, where <code class="code">Result</code> is one of the following:</p> <ul> <li> <code class="code">true</code> if a trace message is to be emitted</li> <li> <code class="code">false</code> if a trace message is not to be emitted</li> <li>The message term to be appended to the trace message</li> </ul> <p><code class="code">Flags</code> is a list containing all the trace flags to be enabled, currently this is only <code class="code">return_trace</code>.</p> <p>This is a useful debugging and test tool, especially when writing complicated match specifications.</p> <p>See also <code class="bold_code"><span class="code">ets:test_ms/2</span></code>.</p>  <h3 id="max-2" class="code">max(Term1, Term2) -&gt; Maximum</h3> <p>Types:</p>     <pre>Term1 = Term2 = Maximum = term()</pre>

<p>Returns the largest of <code class="code">Term1</code> and <code class="code">Term2</code>. If the terms are equal, <code class="code">Term1</code> is returned.</p>  <h3 id="md5-1" class="code">erlang:md5(Data) -&gt; Digest</h3> <p>Types:</p>    <pre>Data = iodata()
Digest = binary()</pre>

<p>Computes an MD5 message digest from <code class="code">Data</code>, where the length of the digest is 128 bits (16 bytes). <code class="code">Data</code> is a binary or a list of small integers and binaries.</p> <p>For more information about MD5, see <code class="bold_code"><a href="https://www.ietf.org/rfc/rfc1321.txt" target="_blank"> RFC 1321 - The MD5 Message-Digest Algorithm</a></code>.</p> <div class="warning"> <div class="label">Warning</div> <div class="content">

<p>The MD5 Message-Digest Algorithm is <strong>not</strong> considered safe for code-signing or software-integrity purposes.</p> </div> </div>  <h3 id="md5_final-1" class="code">erlang:md5_final(Context) -&gt; Digest</h3> <p>Types:</p>    <pre>Context = Digest = binary()</pre>

<p>Finishes the update of an MD5 <code class="code">Context</code> and returns the computed <code class="code">MD5</code> message digest.</p>  <h3 id="md5_init-0" class="code">erlang:md5_init() -&gt; Context</h3> <p>Types:</p>   <pre>Context = binary()</pre>

<p>Creates an MD5 context, to be used in the following calls to <code class="code">md5_update/2</code>.</p>  <h3 id="md5_update-2" class="code">erlang:md5_update(Context, Data) -&gt; NewContext</h3> <p>Types:</p>     <pre>Context = binary()
Data = iodata()
NewContext = binary()</pre>

<p>Update an MD5 <code class="code">Context</code> with <code class="code">Data</code> and returns a <code class="code">NewContext</code>.</p>  <h3 id="memory-0" class="code">erlang:memory() -&gt; [{Type, Size}]</h3> <p>Types:</p>     <pre>Type = memory_type()
Size = integer() &gt;= 0
memory_type() = 
    total |
    processes |
    processes_used |
    system |
    atom |
    atom_used |
    binary |
    code |
    ets |
    low |
    maximum</pre>

<p>Returns a list with information about memory dynamically allocated by the Erlang emulator. Each list element is a tuple <code class="code">{Type, Size}</code>. The first element <code class="code">Type</code> is an atom describing memory type. The second element <code class="code">Size</code> is the memory size in bytes.</p> <p>Memory types:</p> <dl> <dt><strong><code class="code">total</code></strong></dt> <dd> <p>The total amount of memory currently allocated. This is the same as the sum of the memory size for <code class="code">processes</code> and <code class="code">system</code>.</p> </dd> <dt><strong><code class="code">processes</code></strong></dt> <dd> <p>The total amount of memory currently allocated for the Erlang processes.</p> </dd> <dt><strong><code class="code">processes_used</code></strong></dt> <dd> <p>The total amount of memory currently used by the Erlang processes. This is part of the memory presented as <code class="code">processes</code> memory.</p> </dd> <dt><strong><code class="code">system</code></strong></dt> <dd> <p>The total amount of memory currently allocated for the emulator that is not directly related to any Erlang process. Memory presented as <code class="code">processes</code> is not included in this memory.</p> </dd> <dt><strong><code class="code">atom</code></strong></dt> <dd> <p>The total amount of memory currently allocated for atoms. This memory is part of the memory presented as <code class="code">system</code> memory.</p> </dd> <dt><strong><code class="code">atom_used</code></strong></dt> <dd> <p>The total amount of memory currently used for atoms. This memory is part of the memory presented as <code class="code">atom</code> memory.</p> </dd> <dt><strong><code class="code">binary</code></strong></dt> <dd> <p>The total amount of memory currently allocated for binaries. This memory is part of the memory presented as <code class="code">system</code> memory.</p> </dd> <dt><strong><code class="code">code</code></strong></dt> <dd> <p>The total amount of memory currently allocated for Erlang code. This memory is part of the memory presented as <code class="code">system</code> memory.</p> </dd> <dt><strong><code class="code">ets</code></strong></dt> <dd> <p>The total amount of memory currently allocated for ETS tables. This memory is part of the memory presented as <code class="code">system</code> memory.</p> </dd> <dt><strong><code class="code">low</code></strong></dt> <dd> <p>Only on 64-bit halfword emulator. The total amount of memory allocated in low memory areas that are restricted to &lt; 4 GB, although the system can have more memory.</p> <p>Can be removed in a future release of the halfword emulator.</p> </dd> <dt><strong><code class="code">maximum</code></strong></dt> <dd> <p>The maximum total amount of memory allocated since the emulator was started. This tuple is only present when the emulator is run with instrumentation.</p> <p>For information on how to run the emulator with instrumentation, see <code class="bold_code"><span class="code">instrument(3)</span></code> and/or <code class="bold_code"><a href="../erl/"><span class="code">erl(1)</span></a></code>.</p> </dd> </dl> <div class="note"> <div class="label">Note</div> <div class="content">

<p>The <code class="code">system</code> value is not complete. Some allocated memory that is to be part of this value is not.</p> <p>When the emulator is run with instrumentation, the <code class="code">system</code> value is more accurate, but memory directly allocated for <code class="code">malloc</code> (and friends) is still not part of the <code class="code">system</code> value. Direct calls to <code class="code">malloc</code> are only done from OS-specific runtime libraries and perhaps from user-implemented Erlang drivers that do not use the memory allocation functions in the driver interface.</p> <p>As the <code class="code">total</code> value is the sum of <code class="code">processes</code> and <code class="code">system</code>, the error in <code class="code">system</code> propagates to the <code class="code">total</code> value.</p> <p>The different amounts of memory that are summed are <strong>not</strong> gathered atomically, which introduces an error in the result.</p> </div> </div> <p>The different values have the following relation to each other. Values beginning with an uppercase letter is not part of the result.</p> <div class="example"><pre>
total      = processes + system
processes  = processes_used + ProcessesNotUsed
system     = atom + binary + code + ets + OtherSystem
atom       = atom_used + AtomNotUsed
RealTotal  = processes + RealSystem
RealSystem = system + MissedSystem</pre></div> <p>More tuples in the returned list can be added in a future release.</p> <div class="note"> <div class="label">Note</div> <div class="content">

<p>The <code class="code">total</code> value is supposed to be the total amount of memory dynamically allocated by the emulator. Shared libraries, the code of the emulator itself, and the emulator stacks are not supposed to be included. That is, the <code class="code">total</code> value is <strong>not</strong> supposed to be equal to the total size of all pages mapped to the emulator.</p> <p>Also, because of fragmentation and prereservation of memory areas, the size of the memory segments containing the dynamically allocated memory blocks can be much larger than the total size of the dynamically allocated memory blocks.</p> </div> </div> <div class="note"> <div class="label">Note</div> <div class="content">

<p>As from ERTS 5.6.4, <code class="code">erlang:memory/0</code> requires that all <code class="bold_code"><span class="code">erts_alloc(3)</span></code> allocators are enabled (default behavior).</p> </div> </div> <p>Failure: <code class="code">notsup</code> if an <code class="bold_code"><span class="code">erts_alloc(3)</span></code> allocator has been disabled.</p>  <h3 id="memory-1" class="code">erlang:memory(Type :: memory_type()) -&gt; integer() &gt;= 0<br>erlang:memory(TypeList :: [memory_type()]) -&gt;<br>                 [{memory_type(), integer() &gt;= 0}]</h3> <p>Types:</p>   <pre>memory_type() = 
    total |
    processes |
    processes_used |
    system |
    atom |
    atom_used |
    binary |
    code |
    ets |
    low |
    maximum</pre>

<p>Returns the memory size in bytes allocated for memory of type <code class="code">Type</code>. The argument can also be specified as a list of <code class="code">memory_type()</code> atoms, in which case a corresponding list of <code class="code">{memory_type(), Size :: integer &gt;= 0}</code> tuples is returned.</p> <div class="note"> <div class="label">Note</div> <div class="content">

<p>As from ERTS 5.6.4, <code class="code">erlang:memory/1</code> requires that all <code class="bold_code"><a href="../erts_alloc/"><span class="code">erts_alloc(3)</span></a></code> allocators are enabled (default behavior).</p> </div> </div> <p>Failures:</p> <dl> <dt><strong><code class="code">badarg</code></strong></dt> <dd> If <code class="code">Type</code> is not one of the memory types listed in the description of <code class="bold_code"><a href="#memory-0"><span class="code">erlang:memory/0</span></a></code>. </dd> <dt><strong><code class="code">badarg</code></strong></dt> <dd> If <code class="code">maximum</code> is passed as <code class="code">Type</code> and the emulator is not run in instrumented mode. </dd> <dt><strong><code class="code">notsup</code></strong></dt> <dd> If an <code class="bold_code"><a href="../erts_alloc/"><span class="code">erts_alloc(3)</span></a></code> allocator has been disabled. </dd> </dl> <p>See also <code class="bold_code"><a href="#memory-0"><span class="code">erlang:memory/0</span></a></code>.</p>  <h3 id="min-2" class="code">min(Term1, Term2) -&gt; Minimum</h3> <p>Types:</p>     <pre>Term1 = Term2 = Minimum = term()</pre>

<p>Returns the smallest of <code class="code">Term1</code> and <code class="code">Term2</code>. If the terms are equal, <code class="code">Term1</code> is returned.</p>  <h3 id="module_loaded-1" class="code">module_loaded(Module) -&gt; boolean()</h3> <p>Types:</p>   <pre>Module = module()</pre>

<p>Returns <code class="code">true</code> if the module <code class="code">Module</code> is loaded, otherwise <code class="code">false</code>. It does not attempt to load the module.</p> <div class="warning"> <div class="label">Warning</div> <div class="content">

<p>This BIF is intended for the code server (see <code class="bold_code"><span class="code">code(3)</span></code>) and is not to be used elsewhere.</p> </div> </div>  <h3 id="monitor-2" class="code">monitor(Type :: process, Item :: monitor_process_identifier()) -&gt;<br>           MonitorRef<br>monitor(Type :: port, Item :: monitor_port_identifier()) -&gt;<br>           MonitorRef<br>monitor(Type :: time_offset, Item :: clock_service) -&gt; MonitorRef</h3> <p>Types:</p>       <pre>MonitorRef = reference()
registered_name() = atom()
registered_process_identifier() = 
    registered_name() | {registered_name(), node()}
monitor_process_identifier() = 
    pid() | registered_process_identifier()
monitor_port_identifier() = port() | registered_name()</pre>

<p>Sends a monitor request of type <code class="code">Type</code> to the entity identified by <code class="code">Item</code>. If the monitored entity does not exist or it changes monitored state, the caller of <code class="code">monitor/2</code> is notified by a message on the following format:</p> <div class="example"><pre>
{Tag, MonitorRef, Type, Object, Info}</pre></div> <div class="note"> <div class="label">Note</div> <div class="content">

<p>The monitor request is an asynchronous signal. That is, it takes time before the signal reaches its destination.</p> </div> </div> <p><code class="code">Type</code> can be one of the following atoms: <code class="code">process</code>, <code class="code">port</code> or <code class="code">time_offset</code>.</p> <p>A <code class="code">process</code> or <code class="code">port</code> monitor is triggered only once, after that it is removed from both monitoring process and the monitored entity. Monitors are fired when the monitored process or port terminates, does not exist at the moment of creation, or if the connection to it is lost. If the connection to it is lost, we do not know if it still exists. The monitoring is also turned off when <code class="bold_code"><a href="#demonitor-1">demonitor/1</a></code> is called.</p> <p>A <code class="code">process</code> or <code class="code">port</code> monitor by name resolves the <code class="code">RegisteredName</code> to <code class="code">pid()</code> or <code class="code">port()</code> only once at the moment of monitor instantiation, later changes to the name registration will not affect the existing monitor.</p> <p>When a <code class="code">process</code> or <code class="code">port</code> monitor is triggered, a <code class="code">'DOWN'</code> message is sent that has the following pattern:</p> <div class="example"><pre>
{'DOWN', MonitorRef, Type, Object, Info}</pre></div> <p>In the monitor message <code class="code">MonitorRef</code> and <code class="code">Type</code> are the same as described earlier, and:</p> <dl> <dt><strong><code class="code">Object</code></strong></dt> <dd> <p>The monitored entity, which triggered the event. When monitoring a local process or port, <code class="code">Object</code> will be equal to the <code class="code">pid()</code> or <code class="code">port()</code> that was being monitored. When monitoring process or port by name, <code class="code">Object</code> will have format <code class="code">{RegisteredName, Node}</code> where <code class="code">RegisteredName</code> is the name which has been used with <code class="code">monitor/2</code> call and <code class="code">Node</code> is local or remote node name (for ports monitored by name, <code class="code">Node</code> is always local node name).</p> </dd> <dt><strong><code class="code">Info</code></strong></dt> <dd> <p>Either the exit reason of the process, <code class="code">noproc</code> (process or port did not exist at the time of monitor creation), or <code class="code">noconnection</code> (no connection to the node where the monitored process resides). </p> </dd> </dl> <p>If an attempt is made to monitor a process on an older node (where remote process monitoring is not implemented or where remote process monitoring by registered name is not implemented), the call fails with <code class="code">badarg</code>.</p> <div class="note"> <div class="label">Note</div> <div class="content">

<p>The format of the <code class="code">'DOWN'</code> message changed in ERTS 5.2 (Erlang/OTP R9B) for monitoring <strong>by registered name</strong>. Element <code class="code">Object</code> of the <code class="code">'DOWN'</code> message could in earlier versions sometimes be the process identifier of the monitored process and sometimes be the registered name. Now element <code class="code">Object</code> is always a tuple consisting of the registered name and the node name. Processes on new nodes (ERTS 5.2 or higher versions) always get <code class="code">'DOWN'</code> messages on the new format even if they are monitoring processes on old nodes. Processes on old nodes always get <code class="code">'DOWN'</code> messages on the old format.</p> </div> </div> <dl> <dt><strong id="monitor_process">Monitoring a <code class="code">process</code></strong></dt> <dd> <p>Creates monitor between the current process and another process identified by <code class="code">Item</code>, which can be a <code class="code">pid()</code> (local or remote), an atom <code class="code">RegisteredName</code> or a tuple <code class="code">{RegisteredName, Node}</code> for a registered process, located elsewhere.</p> </dd> <dt><strong id="monitor_port">Monitoring a <code class="code">port</code></strong></dt> <dd> <p>Creates monitor between the current process and a port identified by <code class="code">Item</code>, which can be a <code class="code">port()</code> (only local), an atom <code class="code">RegisteredName</code> or a tuple <code class="code">{RegisteredName, Node}</code> for a registered port, located on this node. Note, that attempt to monitor a remote port will result in <code class="code">badarg</code>.</p> </dd> <dt><strong id="monitor_time_offset">Monitoring a <code class="code">time_offset</code></strong></dt> <dd> <p>Monitors changes in <code class="bold_code"><a href="#time_offset-0"><span class="code">time offset</span></a></code> between <code class="bold_code"><a href="../time_correction/#Erlang_Monotonic_Time">Erlang monotonic time</a></code> and <code class="bold_code"><a href="../time_correction/#Erlang_System_Time">Erlang system time</a></code>. One valid <code class="code">Item</code> exists in combination with the <code class="code">time_offset Type</code>, namely the atom <code class="code">clock_service</code>. Notice that the atom <code class="code">clock_service</code> is <strong>not</strong> the registered name of a process. In this case it serves as an identifier of the runtime system internal clock service at current runtime system instance.</p> <p>The monitor is triggered when the time offset is changed. This either if the time offset value is changed, or if the offset is changed from preliminary to final during <code class="bold_code"><a href="#system_flag_time_offset">finalization of the time offset</a></code> when the <code class="bold_code"><a href="../time_correction/#Single_Time_Warp_Mode">single time warp mode</a></code> is used. When a change from preliminary to final time offset is made, the monitor is triggered once regardless of whether the time offset value was changed or not.</p> <p>If the runtime system is in <code class="bold_code"><a href="../time_correction/#Multi_Time_Warp_Mode">multi time warp mode</a></code>, the time offset is changed when the runtime system detects that the <code class="bold_code"><a href="../time_correction/#OS_System_Time">OS system time</a></code> has changed. The runtime system does, however, not detect this immediately when it occurs. A task checking the time offset is scheduled to execute at least once a minute, so under normal operation this is to be detected within a minute, but during heavy load it can take longer time.</p> <p>The monitor is <strong>not</strong> automatically removed after it has been triggered. That is, repeated changes of the time offset trigger the monitor repeatedly.</p> <p>When the monitor is triggered a <code class="code">'CHANGE'</code> message is sent to the monitoring process. A <code class="code">'CHANGE'</code> message has the following pattern:</p> <div class="example"><pre>
{'CHANGE', MonitorRef, Type, Item, NewTimeOffset}</pre></div> <p>where <code class="code">MonitorRef</code>, <code class="code">Type</code>, and <code class="code">Item</code> are the same as described above, and <code class="code">NewTimeOffset</code> is the new time offset.</p> <p>When the <code class="code">'CHANGE'</code> message has been received you are guaranteed not to retrieve the old time offset when calling <code class="bold_code"><a href="#time_offset-0"><span class="code">erlang:time_offset()</span></a></code>. Notice that you can observe the change of the time offset when calling <code class="code">erlang:time_offset()</code> before you get the <code class="code">'CHANGE'</code> message.</p> </dd> </dl> <p>Making several calls to <code class="code">monitor/2</code> for the same <code class="code">Item</code> and/or <code class="code">Type</code> is not an error; it results in as many independent monitoring instances.</p> <p>The monitor functionality is expected to be extended. That is, other <code class="code">Type</code>s and <code class="code">Item</code>s are expected to be supported in a future release.</p> <div class="note"> <div class="label">Note</div> <div class="content">

<p>If or when <code class="code">monitor/2</code> is extended, other possible values for <code class="code">Tag</code>, <code class="code">Object</code>, and <code class="code">Info</code> in the monitor message will be introduced.</p> </div> </div>  <h3 id="monitor_node-2" class="code">monitor_node(Node, Flag) -&gt; true</h3> <p>Types:</p>    <pre>Node = node()
Flag = boolean()</pre>

<p>Monitor the status of the node <code class="code">Node</code>. If <code class="code">Flag</code> is <code class="code">true</code>, monitoring is turned on. If <code class="code">Flag</code> is <code class="code">false</code>, monitoring is turned off.</p> <p>Making several calls to <code class="code">monitor_node(Node, true)</code> for the same <code class="code">Node</code> is not an error; it results in as many independent monitoring instances.</p> <p>If <code class="code">Node</code> fails or does not exist, the message <code class="code">{nodedown, Node}</code> is delivered to the process. If a process has made two calls to <code class="code">monitor_node(Node, true)</code> and <code class="code">Node</code> terminates, two <code class="code">nodedown</code> messages are delivered to the process. If there is no connection to <code class="code">Node</code>, an attempt is made to create one. If this fails, a <code class="code">nodedown</code> message is delivered.</p> <p>Nodes connected through hidden connections can be monitored as any other nodes.</p> <p>Failure: <code class="code">badarg</code> if the local node is not alive.</p>  <h3 id="monitor_node-3" class="code">erlang:monitor_node(Node, Flag, Options) -&gt; true</h3> <p>Types:</p>      <pre>Node = node()
Flag = boolean()
Options = [Option]
Option = allow_passive_connect</pre>

<p>Behaves as <code class="bold_code"><a href="#monitor_node-2"><span class="code">monitor_node/2</span></a></code> except that it allows an extra option to be specified, namely <code class="code">allow_passive_connect</code>. This option allows the BIF to wait the normal network connection time-out for the <strong>monitored node</strong> to connect itself, even if it cannot be actively connected from this node (that is, it is blocked). The state where this can be useful can only be achieved by using the Kernel option <code class="code">dist_auto_connect once</code>. If that option is not used, option <code class="code">allow_passive_connect</code> has no effect.</p> <div class="note"> <div class="label">Note</div> <div class="content">

<p>Option <code class="code">allow_passive_connect</code> is used internally and is seldom needed in applications where the network topology and the Kernel options in effect are known in advance.</p> </div> </div> <p>Failure: <code class="code">badarg</code> if the local node is not alive or the option list is malformed.</p>  <h3 id="monotonic_time-0" class="code">erlang:monotonic_time() -&gt; integer()</h3> 
<p>Returns the current <code class="bold_code"><a href="../time_correction/#Erlang_Monotonic_Time">Erlang monotonic time</a></code> in <code class="code">native</code> <code class="bold_code"><a href="#type_time_unit">time unit</a></code>. This is a monotonically increasing time since some unspecified point in time.</p> <div class="note"> <div class="label">Note</div> <div class="content">

<p>This is a <code class="bold_code"><a href="../time_correction/#Monotonically_Increasing">monotonically increasing</a></code> time, but <strong>not</strong> a <code class="bold_code"><a href="../time_correction/#Strictly_Monotonically_Increasing">strictly monotonically increasing</a></code> time. That is, consecutive calls to <code class="code">erlang:monotonic_time/0</code> can produce the same result.</p> <p>Different runtime system instances will use different unspecified points in time as base for their Erlang monotonic clocks. That is, it is <strong>pointless</strong> comparing monotonic times from different runtime system instances. Different runtime system instances can also place this unspecified point in time different relative runtime system start. It can be placed in the future (time at start is a negative value), the past (time at start is a positive value), or the runtime system start (time at start is zero). The monotonic time at runtime system start can be retrieved by calling <code class="bold_code"><a href="#system_info_start_time"><span class="code">erlang:system_info(start_time)</span></a></code>.</p> </div> </div>  <h3 id="monotonic_time-1" class="code">erlang:monotonic_time(Unit) -&gt; integer()</h3> <p>Types:</p>   <pre>Unit = <a href="#type-time_unit">time_unit()</a></pre>

<p>Returns the current <code class="bold_code"><a href="../time_correction/#Erlang_Monotonic_Time">Erlang monotonic time</a></code> converted into the <code class="code">Unit</code> passed as argument.</p> <p>Same as calling <code class="bold_code"><a href="#convert_time_unit-3"><span class="code">erlang:convert_time_unit</span></a></code><code class="code">(</code><code class="bold_code"><a href="#monotonic_time-0"><span class="code">erlang:monotonic_time()</span></a></code><code class="code">, native, Unit)</code>, however optimized for commonly used <code class="code">Unit</code>s.</p>  <h3 id="nif_error-1" class="code">erlang:nif_error(Reason) -&gt; no_return()</h3> <p>Types:</p>   <pre>Reason = term()</pre>

<p>Works exactly like <code class="bold_code"><a href="#error-1"><span class="code">error/1</span></a></code>, but Dialyzer thinks that this BIF will return an arbitrary term. When used in a stub function for a NIF to generate an exception when the NIF library is not loaded, Dialyzer does not generate false warnings.</p>  <h3 id="nif_error-2" class="code">erlang:nif_error(Reason, Args) -&gt; no_return()</h3> <p>Types:</p>    <pre>Reason = term()
Args = [term()]</pre>

<p>Works exactly like <code class="bold_code"><a href="#error-2"><span class="code">error/2</span></a></code>, but Dialyzer thinks that this BIF will return an arbitrary term. When used in a stub function for a NIF to generate an exception when the NIF library is not loaded, Dialyzer does not generate false warnings.</p>  <h3 id="node-0" class="code">node() -&gt; Node</h3> <p>Types:</p>   <pre>Node = node()</pre>

<p>Returns the name of the local node. If the node is not alive, <code class="code">nonode@nohost</code> is returned instead.</p> <p>Allowed in guard tests.</p>  <h3 id="node-1" class="code">node(Arg) -&gt; Node</h3> <p>Types:</p>    <pre>Arg = pid() | port() | reference()
Node = node()</pre>

<p>Returns the node where <code class="code">Arg</code> originates. <code class="code">Arg</code> can be a process identifier, a reference, or a port. If the local node is not alive, <code class="code">nonode@nohost</code> is returned.</p> <p>Allowed in guard tests.</p>  <h3 id="nodes-0" class="code">nodes() -&gt; Nodes</h3> <p>Types:</p>   <pre>Nodes = [node()]</pre>

<p>Returns a list of all visible nodes in the system, except the local node. Same as <code class="code">nodes(visible)</code>.</p>  <h3 id="nodes-1" class="code">nodes(Arg) -&gt; Nodes</h3> <p>Types:</p>     <pre>Arg = NodeType | [NodeType]
NodeType = visible | hidden | connected | this | known
Nodes = [node()]</pre>

<p>Returns a list of nodes according to the argument specified. The returned result, when the argument is a list, is the list of nodes satisfying the disjunction(s) of the list elements.</p> <p><code class="code">NodeType</code>s:</p> <dl> <dt><strong><code class="code">visible</code></strong></dt> <dd> <p>Nodes connected to this node through normal connections.</p> </dd> <dt><strong><code class="code">hidden</code></strong></dt> <dd> <p>Nodes connected to this node through hidden connections.</p> </dd> <dt><strong><code class="code">connected</code></strong></dt> <dd> <p>All nodes connected to this node.</p> </dd> <dt><strong><code class="code">this</code></strong></dt> <dd> <p>This node.</p> </dd> <dt><strong><code class="code">known</code></strong></dt> <dd> <p>Nodes that are known to this node. That is, connected nodes and nodes referred to by process identifiers, port identifiers, and references located on this node. The set of known nodes is garbage collected. Notice that this garbage collection can be delayed. For more information, see <code class="bold_code"><a href="../erlang/#system_info_delayed_node_table_gc"><span class="code">erlang:system_info(delayed_node_table_gc)</span></a></code>.</p> </dd> </dl> <p>Some equalities: <code class="code">[node()] = nodes(this)</code>, <code class="code">nodes(connected) = nodes([visible, hidden])</code>, and <code class="code">nodes() = nodes(visible)</code>.</p>  <h3 id="now-0" class="code">now() -&gt; Timestamp</h3> <p>Types:</p>    <pre>Timestamp = <a href="#type-timestamp">timestamp()</a>
timestamp() = 
    {MegaSecs :: integer() &gt;= 0,
     Secs :: integer() &gt;= 0,
     MicroSecs :: integer() &gt;= 0}</pre>

<div class="warning"> <div class="label">Warning</div> <div class="content">

<p><strong>This function is deprecated. Do not use it.</strong></p> <p>For more information, see section <code class="bold_code"><a href="../time_correction/">Time and Time Correction</a></code> in the User's Guide. Specifically, section <code class="bold_code"><a href="../time_correction/#Dos_and_Donts">Dos and Dont's</a></code> describes what to use instead of <code class="code">erlang:now/0</code>.</p> </div> </div> <p>Returns the tuple <code class="code">{MegaSecs, Secs, MicroSecs}</code>, which is the elapsed time since 00:00 GMT, January 1, 1970 (zero hour), if provided by the underlying OS. Otherwise some other point in time is chosen. It is also guaranteed that the following calls to this BIF return continuously increasing values. Hence, the return value from <code class="code">erlang:now/0</code> can be used to generate unique time stamps. If it is called in a tight loop on a fast machine, the time of the node can become skewed.</p> <p>Can only be used to check the local time of day if the time-zone information of the underlying OS is properly configured.</p>  <h3 id="open_port-2" class="code">open_port(PortName, PortSettings) -&gt; port()</h3> <p>Types:</p>     <pre>PortName = 
    {spawn, Command :: string() | binary()} |
    {spawn_driver, Command :: string() | binary()} |
    {spawn_executable, FileName :: file:name()} |
    {fd, In :: integer() &gt;= 0, Out :: integer() &gt;= 0}
PortSettings = [Opt]
Opt = 
    {packet, N :: 1 | 2 | 4} |
    stream |
    {line, L :: integer() &gt;= 0} |
    {cd, Dir :: string() | binary()} |
    {env, Env :: [{Name :: string(), Val :: string() | false}]} |
    {args, [string() | binary()]} |
    {arg0, string() | binary()} |
    exit_status |
    use_stdio |
    nouse_stdio |
    stderr_to_stdout |
    in |
    out |
    binary |
    eof |
    {parallelism, Boolean :: boolean()} |
    hide</pre>

<p>Returns a port identifier as the result of opening a new Erlang port. A port can be seen as an external Erlang process.</p> <p>The name of the executable as well as the arguments specifed in <code class="code">cd</code>, <code class="code">env</code>, <code class="code">args</code>, and <code class="code">arg0</code> are subject to Unicode filename translation if the system is running in Unicode filename mode. To avoid translation or to force, for example UTF-8, supply the executable and/or arguments as a binary in the correct encoding. For details, see the module <code class="bold_code"><span class="code">file(3)</span></code>, the function <code class="bold_code"><span class="code">file:native_name_encoding/0</span></code> in Kernel, and the <code class="bold_code"><span class="code">Using Unicode in Erlang</span></code> User's Guide.</p> <div class="note"> <div class="label">Note</div> <div class="content">

<p>The characters in the name (if specified as a list) can only be &gt; 255 if the Erlang virtual machine is started in Unicode filename translation mode. Otherwise the name of the executable is limited to the ISO Latin-1 character set.</p> </div> </div> <p><code class="code">PortName</code>s:</p> <dl> <dt><strong><code class="code">{spawn, Command}</code></strong></dt> <dd> <p>Starts an external program. <code class="code">Command</code> is the name of the external program to be run. <code class="code">Command</code> runs outside the Erlang work space unless an Erlang driver with the name <code class="code">Command</code> is found. If found, that driver is started. A driver runs in the Erlang work space, which means that it is linked with the Erlang runtime system.</p> <p>When starting external programs on Solaris, the system call <code class="code">vfork</code> is used in preference to <code class="code">fork</code> for performance reasons, although it has a history of being less robust. If there are problems using <code class="code">vfork</code>, setting environment variable <code class="code">ERL_NO_VFORK</code> to any value causes <code class="code">fork</code> to be used instead.</p> <p>For external programs, <code class="code">PATH</code> is searched (or an equivalent method is used to find programs, depending on the OS). This is done by invoking the shell on certain platforms. The first space-separated token of the command is considered as the name of the executable (or driver). This (among other things) makes this option unsuitable for running programs with spaces in filenames or directory names. If spaces in executable filenames are desired, use <code class="code">{spawn_executable, Command}</code> instead.</p> </dd> <dt><strong><code class="code">{spawn_driver, Command}</code></strong></dt> <dd> <p>Works like <code class="code">{spawn, Command}</code>, but demands the first (space-separated) token of the command to be the name of a loaded driver. If no driver with that name is loaded, a <code class="code">badarg</code> error is raised.</p> </dd> <dt><strong><code class="code">{spawn_executable, FileName}</code></strong></dt> <dd> <p>Works like <code class="code">{spawn, FileName}</code>, but only runs external executables. <code class="code">FileName</code> in its whole is used as the name of the executable, including any spaces. If arguments are to be passed, the <code class="code">PortSettings</code> <code class="code">args</code> and <code class="code">arg0</code> can be used.</p> <p>The shell is usually not invoked to start the program, it is executed directly. <code class="code">PATH</code> (or equivalent) is not searched. To find a program in <code class="code">PATH</code> to execute, use <code class="bold_code"><span class="code">os:find_executable/1</span></code>.</p> <p>Only if a shell script or <code class="code">.bat</code> file is executed, the appropriate command interpreter is invoked implicitly, but there is still no command-argument expansion or implicit <code class="code">PATH</code> search.</p> <p>If <code class="code">FileName</code> cannot be run, an error exception is raised, with the POSIX error code as the reason. The error reason can differ between OSs. Typically the error <code class="code">enoent</code> is raised when an attempt is made to run a program that is not found and <code class="code">eacces</code> is raised when the specified file is not executable.</p> </dd> <dt><strong><code class="code">{fd, In, Out}</code></strong></dt> <dd> <p>Allows an Erlang process to access any currently opened file descriptors used by Erlang. The file descriptor <code class="code">In</code> can be used for standard input, and the file descriptor <code class="code">Out</code> for standard output. It is only used for various servers in the Erlang OS (<code class="code">shell</code> and <code class="code">user</code>). Hence, its use is limited.</p> </dd> </dl> <p><code class="code">PortSettings</code> is a list of settings for the port. The valid settings are as follows:</p> <dl> <dt><strong><code class="code">{packet, N}</code></strong></dt> <dd> <p>Messages are preceded by their length, sent in <code class="code">N</code> bytes, with the most significant byte first. The valid values for <code class="code">N</code> are 1, 2, and 4.</p> </dd> <dt><strong><code class="code">stream</code></strong></dt> <dd> <p>Output messages are sent without packet lengths. A user-defined protocol must be used between the Erlang process and the external object.</p> </dd> <dt><strong><code class="code">{line, L}</code></strong></dt> <dd> <p>Messages are delivered on a per line basis. Each line (delimited by the OS-dependent newline sequence) is delivered in a single message. The message data format is <code class="code">{Flag, Line}</code>, where <code class="code">Flag</code> is <code class="code">eol</code> or <code class="code">noeol</code>, and <code class="code">Line</code> is the data delivered (without the newline sequence).</p> <p><code class="code">L</code> specifies the maximum line length in bytes. Lines longer than this are delivered in more than one message, with <code class="code">Flag</code> set to <code class="code">noeol</code> for all but the last message. If end of file is encountered anywhere else than immediately following a newline sequence, the last line is also delivered with <code class="code">Flag</code> set to <code class="code">noeol</code>. Otherwise lines are delivered with <code class="code">Flag</code> set to <code class="code">eol</code>.</p> <p>The <code class="code">{packet, N}</code> and <code class="code">{line, L}</code> settings are mutually exclusive.</p> </dd> <dt><strong><code class="code">{cd, Dir}</code></strong></dt> <dd> <p>Only valid for <code class="code">{spawn, Command}</code> and <code class="code">{spawn_executable, FileName}</code>. The external program starts using <code class="code">Dir</code> as its working directory. <code class="code">Dir</code> must be a string.</p> </dd> <dt><strong><code class="code">{env, Env}</code></strong></dt> <dd> <p>Only valid for <code class="code">{spawn, Command}</code>, and <code class="code">{spawn_executable, FileName}</code>. The environment of the started process is extended using the environment specifications in <code class="code">Env</code>.</p> <p><code class="code">Env</code> is to be a list of tuples <code class="code">{Name, Val}</code>, where <code class="code">Name</code> is the name of an environment variable, and <code class="code">Val</code> is the value it is to have in the spawned port process. Both <code class="code">Name</code> and <code class="code">Val</code> must be strings. The one exception is <code class="code">Val</code> being the atom <code class="code">false</code> (in analogy with <code class="bold_code"><span class="code">os:getenv/1</span></code>, which removes the environment variable.</p> </dd> <dt><strong><code class="code">{args, [ string() | binary() ]}</code></strong></dt> <dd> <p>Only valid for <code class="code">{spawn_executable, FileName}</code> and specifies arguments to the executable. Each argument is specified as a separate string and (on Unix) eventually ends up as one element each in the argument vector. On other platforms, a similar behavior is mimicked.</p> <p>The arguments are not expanded by the shell before they are supplied to the executable. Most notably this means that file wildcard expansion does not occur. To expand wildcards for the arguments, use <code class="bold_code"><span class="code">filelib:wildcard/1</span></code>. Notice that even if the program is a Unix shell script, meaning that the shell ultimately is invoked, wildcard expansion does not occur, and the script is provided with the untouched arguments. On Windows, wildcard expansion is always up to the program itself, therefore this is not an issue.</p> <p>The executable name (also known as <code class="code">argv[0]</code>) is not to be specified in this list. The proper executable name is automatically used as <code class="code">argv[0]</code>, where applicable.</p> <p>If you explicitly want to set the program name in the argument vector, option <code class="code">arg0</code> can be used.</p> </dd> <dt><strong><code class="code">{arg0, string() | binary()}</code></strong></dt> <dd> <p>Only valid for <code class="code">{spawn_executable, FileName}</code> and explicitly specifies the program name argument when running an executable. This can in some circumstances, on some OSs, be desirable. How the program responds to this is highly system-dependent and no specific effect is guaranteed.</p> </dd> <dt><strong><code class="code">exit_status</code></strong></dt> <dd> <p>Only valid for <code class="code">{spawn, Command}</code>, where <code class="code">Command</code> refers to an external program, and for <code class="code">{spawn_executable, FileName}</code>.</p> <p>When the external process connected to the port exits, a message of the form <code class="code">{Port,{exit_status,Status}}</code> is sent to the connected process, where <code class="code">Status</code> is the exit status of the external process. If the program aborts on Unix, the same convention is used as the shells do (that is, 128+signal).</p> <p>If option <code class="code">eof</code> is specified also, the messages <code class="code">eof</code> and <code class="code">exit_status</code> appear in an unspecified order.</p> <p>If the port program closes its <code class="code">stdout</code> without exiting, option <code class="code">exit_status</code> does not work.</p> </dd> <dt><strong><code class="code">use_stdio</code></strong></dt> <dd> <p>Only valid for <code class="code">{spawn, Command}</code> and <code class="code">{spawn_executable, FileName}</code>. It allows the standard input and output (file descriptors 0 and 1) of the spawned (Unix) process for communication with Erlang.</p> </dd> <dt><strong><code class="code">nouse_stdio</code></strong></dt> <dd> <p>The opposite of <code class="code">use_stdio</code>. It uses file descriptors 3 and 4 for communication with Erlang.</p> </dd> <dt><strong><code class="code">stderr_to_stdout</code></strong></dt> <dd> <p>Affects ports to external programs. The executed program gets its standard error file redirected to its standard output file. <code class="code">stderr_to_stdout</code> and <code class="code">nouse_stdio</code> are mutually exclusive.</p> </dd> <dt><strong><code class="code">overlapped_io</code></strong></dt> <dd> <p>Affects ports to external programs on Windows only. The standard input and standard output handles of the port program are, if this option is supplied, opened with flag <code class="code">FILE_FLAG_OVERLAPPED</code>, so that the port program can (and must) do overlapped I/O on its standard handles. This is not normally the case for simple port programs, but an option of value for the experienced Windows programmer. <strong>On all other platforms, this option is silently discarded.</strong></p> </dd> <dt><strong><code class="code">in</code></strong></dt> <dd> <p>The port can only be used for input.</p> </dd> <dt><strong><code class="code">out</code></strong></dt> <dd> <p>The port can only be used for output.</p> </dd> <dt><strong><code class="code">binary</code></strong></dt> <dd> <p>All I/O from the port is binary data objects as opposed to lists of bytes.</p> </dd> <dt><strong><code class="code">eof</code></strong></dt> <dd> <p>The port is not closed at the end of the file and does not produce an exit signal. Instead, it remains open and a <code class="code">{Port, eof}</code> message is sent to the process holding the port.</p> </dd> <dt><strong><code class="code">hide</code></strong></dt> <dd> <p>When running on Windows, suppresses creation of a new console window when spawning the port program. (This option has no effect on other platforms.)</p> </dd> <dt><strong><code class="code">{parallelism, Boolean}</code></strong></dt> <dd id="open_port_parallelism">  <p>Sets scheduler hint for port parallelism. If set to <code class="code">true</code>, the virtual machine schedules port tasks; when doing so, it improves parallelism in the system. If set to <code class="code">false</code>, the virtual machine tries to perform port tasks immediately, improving latency at the expense of parallelism. The default can be set at system startup by passing command-line argument <code class="bold_code"><a href="../erl/#+spp"><span class="code">+spp</span></a></code> to <code class="code">erl(1)</code>.</p> </dd> </dl> <p>Default is <code class="code">stream</code> for all port types and <code class="code">use_stdio</code> for spawned ports.</p> <p>Failure: if the port cannot be opened, the exit reason is <code class="code">badarg</code>, <code class="code">system_limit</code>, or the POSIX error code that most closely describes the error, or <code class="code">einval</code> if no POSIX code is appropriate:</p> <dl> <dt><strong><code class="code">badarg</code></strong></dt> <dd>Bad input arguments to <code class="code">open_port</code>. </dd> <dt><strong><code class="code">system_limit</code></strong></dt> <dd>All available ports in the Erlang emulator are in use. </dd> <dt><strong><code class="code">enomem</code></strong></dt> <dd>Not enough memory to create the port. </dd> <dt><strong><code class="code">eagain</code></strong></dt> <dd>No more available OS processes. </dd> <dt><strong><code class="code">enametoolong</code></strong></dt> <dd>Too long external command. </dd> <dt><strong><code class="code">emfile</code></strong></dt> <dd>No more available file descriptors (for the OS process that the Erlang emulator runs in). </dd> <dt><strong><code class="code">enfile</code></strong></dt> <dd>Full file table (for the entire OS). </dd> <dt><strong><code class="code">eacces</code></strong></dt> <dd> <code class="code">Command</code> specified in <code class="code">{spawn_executable, Command}</code> does not point out an executable file. </dd> <dt><strong><code class="code">enoent</code></strong></dt> <dd> <code class="code">FileName</code> specified in <code class="code">{spawn_executable, FileName}</code> does not point out an existing file. </dd> </dl> <p>During use of a port opened using <code class="code">{spawn, Name}</code>, <code class="code">{spawn_driver, Name}</code>, or <code class="code">{spawn_executable, Name}</code>, errors arising when sending messages to it are reported to the owning process using signals of the form <code class="code">{'EXIT', Port, PosixCode}</code>. For the possible values of <code class="code">PosixCode</code>, see <code class="bold_code"><span class="code">file(3)</span></code>.</p> <p>The maximum number of ports that can be open at the same time can be configured by passing command-line flag <code class="bold_code"><a href="../erl/#max_ports"><span class="code">+Q</span></a></code> to <code class="code">erl(1)</code>.</p>  <h3 id="phash-2" class="code">erlang:phash(Term, Range) -&gt; Hash</h3> <p>Types:</p>   <pre>Term = term()
Range = Hash = integer() &gt;= 1</pre>
<p class="REFBODY">Range = 1..2^32, Hash = 1..Range</p>   

<p>Portable hash function that gives the same hash for the same Erlang term regardless of machine architecture and ERTS version (the BIF was introduced in ERTS 4.9.1.1). The function returns a hash value for <code class="code">Term</code> within the range <code class="code">1..Range</code>. The maximum value for <code class="code">Range</code> is 2^32.</p> <p>This BIF can be used instead of the old deprecated BIF <code class="code">erlang:hash/2</code>, as it calculates better hashes for all data types, but consider using <code class="code">phash2/1,2</code> instead.</p>  <h3 id="phash2-2" class="code">erlang:phash2(Term) -&gt; Hash<br>erlang:phash2(Term, Range) -&gt; Hash</h3> <p>Types:</p>   <pre>Term = term()
Range = integer() &gt;= 1</pre>
<p class="REFBODY">1..2^32</p>  <pre>Hash = integer() &gt;= 0</pre>
<p class="REFBODY">0..Range-1</p>  
<p>Portable hash function that gives the same hash for the same Erlang term regardless of machine architecture and ERTS version (the BIF was introduced in ERTS 5.2). The function returns a hash value for <code class="code">Term</code> within the range <code class="code">0..Range-1</code>. The maximum value for <code class="code">Range</code> is 2^32. When without argument <code class="code">Range</code>, a value in the range 0..2^27-1 is returned.</p> <p>This BIF is always to be used for hashing terms. It distributes small integers better than <code class="code">phash/2</code>, and it is faster for bignums and binaries.</p> <p>Notice that the range <code class="code">0..Range-1</code> is different from the range of <code class="code">phash/2</code>, which is <code class="code">1..Range</code>.</p>  <h3 id="pid_to_list-1" class="code">pid_to_list(Pid) -&gt; string()</h3> <p>Types:</p>   <pre>Pid = pid()</pre>

<p>Returns a string corresponding to the text representation of <code class="code">Pid</code>.</p> <div class="warning"> <div class="label">Warning</div> <div class="content">

<p>This BIF is intended for debugging and is not to be used in application programs.</p> </div> </div>  <h3 id="port_call-3" class="code">erlang:port_call(Port, Operation, Data) -&gt; term()</h3> <p>Types:</p>     <pre>Port = port() | atom()
Operation = integer()
Data = term()</pre>

<p>Performs a synchronous call to a port. The meaning of <code class="code">Operation</code> and <code class="code">Data</code> depends on the port, that is, on the port driver. Not all port drivers support this feature.</p> <p><code class="code">Port</code> is a port identifier, referring to a driver.</p> <p><code class="code">Operation</code> is an integer, which is passed on to the driver.</p> <p><code class="code">Data</code> is any Erlang term. This data is converted to binary term format and sent to the port.</p> <p>Returns a term from the driver. The meaning of the returned data also depends on the port driver.</p> <p>Failures:</p> <dl> <dt><strong><code class="code">badarg</code></strong></dt> <dd> If <code class="code">Port</code> is not an identifier of an open port, or the registered name of an open port. If the calling process was previously linked to the closed port, identified by <code class="code">Port</code>, the exit signal from the port is guaranteed to be delivered before this <code class="code">badarg</code> exception occurs. </dd> <dt><strong><code class="code">badarg</code></strong></dt> <dd> If <code class="code">Operation</code> does not fit in a 32-bit integer. </dd> <dt><strong><code class="code">badarg</code></strong></dt> <dd> If the port driver does not support synchronous control operations. </dd> <dt><strong><code class="code">badarg</code></strong></dt> <dd> If the port driver so decides for any reason (probably something wrong with <code class="code">Operation</code> or <code class="code">Data</code>). </dd> </dl>  <h3 id="port_close-1" class="code">port_close(Port) -&gt; true</h3> <p>Types:</p>   <pre>Port = port() | atom()</pre>

<p>Closes an open port. Roughly the same as <code class="code">Port ! {self(), close}</code> except for the error behavior (see below), being synchronous, and that the port does <strong>not</strong> reply with <code class="code">{Port, closed}</code>. Any process can close a port with <code class="code">port_close/1</code>, not only the port owner (the connected process). If the calling process is linked to the port identified by <code class="code">Port</code>, the exit signal from the port is guaranteed to be delivered before <code class="code">port_close/1</code> returns.</p> <p>For comparison: <code class="code">Port ! {self(), close}</code> only fails with <code class="code">badarg</code> if <code class="code">Port</code> does not refer to a port or a process. If <code class="code">Port</code> is a closed port, nothing happens. If <code class="code">Port</code> is an open port and the calling process is the port owner, the port replies with <code class="code">{Port, closed}</code> when all buffers have been flushed and the port really closes. If the calling process is not the port owner, the <strong>port owner</strong> fails with <code class="code">badsig</code>.</p> <p>Notice that any process can close a port using <code class="code">Port ! {PortOwner, close}</code> as if it itself was the port owner, but the reply always goes to the port owner.</p> <p>As from Erlang/OTP R16, <code class="code">Port ! {PortOwner, close}</code> is truly asynchronous. Notice that this operation has always been documented as an asynchronous operation, while the underlying implementation has been synchronous. <code class="code">port_close/1</code> is however still fully synchronous because of its error behavior.</p> <p>Failure: <code class="code">badarg</code> if <code class="code">Port</code> is not an identifier of an open port, or the registered name of an open port. If the calling process was previously linked to the closed port, identified by <code class="code">Port</code>, the exit signal from the port is guaranteed to be delivered before this <code class="code">badarg</code> exception occurs.</p>  <h3 id="port_command-2" class="code">port_command(Port, Data) -&gt; true</h3> <p>Types:</p>    <pre>Port = port() | atom()
Data = iodata()</pre>

<p>Sends data to a port. Same as <code class="code">Port ! {PortOwner, {command, Data}}</code> except for the error behavior and being synchronous (see below). Any process can send data to a port with <code class="code">port_command/2</code>, not only the port owner (the connected process).</p> <p>For comparison: <code class="code">Port ! {PortOwner, {command, Data}}</code> only fails with <code class="code">badarg</code> if <code class="code">Port</code> does not refer to a port or a process. If <code class="code">Port</code> is a closed port, the data message disappears without a sound. If <code class="code">Port</code> is open and the calling process is not the port owner, the <strong>port owner</strong> fails with <code class="code">badsig</code>. The port owner fails with <code class="code">badsig</code> also if <code class="code">Data</code> is an invalid I/O list.</p> <p>Notice that any process can send to a port using <code class="code">Port ! {PortOwner, {command, Data}}</code> as if it itself was the port owner.</p> <p>If the port is busy, the calling process is suspended until the port is not busy any more.</p> <p>As from Erlang/OTP R16, <code class="code">Port ! {PortOwner, {command, Data}}</code> is truly asynchronous. Notice that this operation has always been documented as an asynchronous operation, while the underlying implementation has been synchronous. <code class="code">port_command/2</code> is however still fully synchronous because of its error behavior.</p> <p>Failures:</p> <dl> <dt><strong><code class="code">badarg</code></strong></dt> <dd> <p>If <code class="code">Port</code> is not an identifier of an open port, or the registered name of an open port. If the calling process was previously linked to the closed port, identified by <code class="code">Port</code>, the exit signal from the port is guaranteed to be delivered before this <code class="code">badarg</code> exception occurs.</p> </dd> <dt><strong><code class="code">badarg</code></strong></dt> <dd> <p>If <code class="code">Data</code> is an invalid I/O list.</p> </dd> </dl>  <h3 id="port_command-3" class="code">port_command(Port, Data, OptionList) -&gt; boolean()</h3> <p>Types:</p>      <pre>Port = port() | atom()
Data = iodata()
Option = force | nosuspend
OptionList = [Option]</pre>

<p>Sends data to a port. <code class="code">port_command(Port, Data, [])</code> equals <code class="code">port_command(Port, Data)</code>.</p> <p>If the port command is aborted, <code class="code">false</code> is returned, otherwise <code class="code">true</code>.</p> <p>If the port is busy, the calling process is suspended until the port is not busy anymore.</p> <p><code class="code">Option</code>s:</p> <dl> <dt><strong><code class="code">force</code></strong></dt> <dd>The calling process is not suspended if the port is busy, instead the port command is forced through. The call fails with a <code class="code">notsup</code> exception if the driver of the port does not support this. For more information, see driver flag <code class="bold_code"><a href="../driver_entry/#driver_flags"><span class="code">![CDATA[ERL_DRV_FLAG_SOFT_BUSY]]</span></a></code>. </dd> <dt><strong><code class="code">nosuspend</code></strong></dt> <dd>The calling process is not suspended if the port is busy, instead the port command is aborted and <code class="code">false</code> is returned. </dd> </dl> <div class="note"> <div class="label">Note</div> <div class="content">

<p>More options can be added in a future release.</p> </div> </div> <p>Failures:</p> <dl> <dt><strong><code class="code">badarg</code></strong></dt> <dd> If <code class="code">Port</code> is not an identifier of an open port, or the registered name of an open port. If the calling process was previously linked to the closed port, identified by <code class="code">Port</code>, the exit signal from the port is guaranteed to be delivered before this <code class="code">badarg</code> exception occurs. </dd> <dt><strong><code class="code">badarg</code></strong></dt> <dd> If <code class="code">Data</code> is an invalid I/O list. </dd> <dt><strong><code class="code">badarg</code></strong></dt> <dd> If <code class="code">OptionList</code> is an invalid option list. </dd> <dt><strong><code class="code">notsup</code></strong></dt> <dd> If option <code class="code">force</code> has been passed, but the driver of the port does not allow forcing through a busy port. </dd> </dl>  <h3 id="port_connect-2" class="code">port_connect(Port, Pid) -&gt; true</h3> <p>Types:</p>    <pre>Port = port() | atom()
Pid = pid()</pre>

<p>Sets the port owner (the connected port) to <code class="code">Pid</code>. Roughly the same as <code class="code">Port ! {Owner, {connect, Pid}}</code> except for the following:</p> <ul> <li> <p>The error behavior differs, see below.</p> </li> <li> <p>The port does <strong>not</strong> reply with <code class="code">{Port,connected}</code>.</p> </li> <li> <p><code class="code">port_connect/1</code> is synchronous, see below.</p> </li> <li> <p>The new port owner gets linked to the port.</p> </li> </ul> <p>The old port owner stays linked to the port and must call <code class="code">unlink(Port)</code> if this is not desired. Any process can set the port owner to be any process with <code class="code">port_connect/2</code>.</p> <p>For comparison: <code class="code">Port ! {self(), {connect, Pid}}</code> only fails with <code class="code">badarg</code> if <code class="code">Port</code> does not refer to a port or a process. If <code class="code">Port</code> is a closed port, nothing happens. If <code class="code">Port</code> is an open port and the calling process is the port owner, the port replies with <code class="code">{Port, connected}</code> to the old port owner. Notice that the old port owner is still linked to the port, while the new is not. If <code class="code">Port</code> is an open port and the calling process is not the port owner, the <strong>port owner</strong> fails with <code class="code">badsig</code>. The port owner fails with <code class="code">badsig</code> also if <code class="code">Pid</code> is not an existing local process identifier.</p> <p>Notice that any process can set the port owner using <code class="code">Port ! {PortOwner, {connect, Pid}}</code> as if it itself was the port owner, but the reply always goes to the port owner.</p> <p>As from Erlang/OTP R16, <code class="code">Port ! {PortOwner, {connect, Pid}}</code> is truly asynchronous. Notice that this operation has always been documented as an asynchronous operation, while the underlying implementation has been synchronous. <code class="code">port_connect/2</code> is however still fully synchronous because of its error behavior.</p> <p>Failures:</p> <dl> <dt><strong><code class="code">badarg</code></strong></dt> <dd> If <code class="code">Port</code> is not an identifier of an open port, or the registered name of an open port. If the calling process was previously linked to the closed port, identified by <code class="code">Port</code>, the exit signal from the port is guaranteed to be delivered before this <code class="code">badarg</code> exception occurs. </dd> <dt><strong><code class="code">badarg</code></strong></dt> <dd>If the process identified by <code class="code">Pid</code> is not an existing local process.</dd> </dl>  <h3 id="port_control-3" class="code">port_control(Port, Operation, Data) -&gt; iodata() | binary()</h3> <p>Types:</p>     <pre>Port = port() | atom()
Operation = integer()
Data = iodata()</pre>

<p>Performs a synchronous control operation on a port. The meaning of <code class="code">Operation</code> and <code class="code">Data</code> depends on the port, that is, on the port driver. Not all port drivers support this control feature.</p> <p>Returns a list of integers in the range 0..255, or a binary, depending on the port driver. The meaning of the returned data also depends on the port driver.</p> <p>Failures:</p> <dl> <dt><strong><code class="code">badarg</code></strong></dt> <dd> If <code class="code">Port</code> is not an open port or the registered name of an open port. </dd> <dt><strong><code class="code">badarg</code></strong></dt> <dd> If <code class="code">Operation</code> cannot fit in a 32-bit integer. </dd> <dt><strong><code class="code">badarg</code></strong></dt> <dd> If the port driver does not support synchronous control operations. </dd> <dt><strong><code class="code">badarg</code></strong></dt> <dd> If the port driver so decides for any reason (probably something wrong with <code class="code">Operation</code> or <code class="code">Data</code>). </dd> </dl>  <h3 id="port_info-1" class="code">erlang:port_info(Port) -&gt; Result</h3> <p>Types:</p>     <pre>Port = port() | atom()
ResultItem = 
    {registered_name, RegisteredName :: atom()} |
    {id, Index :: integer() &gt;= 0} |
    {connected, Pid :: pid()} |
    {links, Pids :: [pid()]} |
    {name, String :: string()} |
    {input, Bytes :: integer() &gt;= 0} |
    {output, Bytes :: integer() &gt;= 0} |
    {os_pid, OsPid :: integer() &gt;= 0 | undefined}
Result = [ResultItem] | undefined</pre>

<p>Returns a list containing tuples with information about <code class="code">Port</code>, or <code class="code">undefined</code> if the port is not open. The order of the tuples is undefined, and all the tuples are not mandatory. If the port is closed and the calling process was previously linked to the port, the exit signal from the port is guaranteed to be delivered before <code class="code">port_info/1</code> returns <code class="code">undefined</code>.</p> <p>The result contains information about the following <code class="code">Item</code>s:</p> <ul> <li> <code class="code">registered_name</code> (if the port has a registered name)</li> <li><code class="code">id</code></li> <li><code class="code">connected</code></li> <li><code class="code">links</code></li> <li><code class="code">name</code></li> <li><code class="code">input</code></li> <li><code class="code">output</code></li> </ul> <p>For more information about the different <code class="code">Item</code>s, see <code class="bold_code"><a href="#port_info-2"><span class="code">port_info/2</span></a></code>.</p> <p>Failure: <code class="code">badarg</code> if <code class="code">Port</code> is not a local port identifier, or an atom.</p>  <h3 id="port_info-2" class="code">erlang:port_info(Port, Item :: connected) -&gt;<br>                    {connected, Pid} | undefined</h3> <p>Types:</p>    <pre>Port = port() | atom()
Pid = pid()</pre>

<p><code class="code">Pid</code> is the process identifier of the process connected to the port.</p> <p>If the port identified by <code class="code">Port</code> is not open, <code class="code">undefined</code> is returned. If the port is closed and the calling process was previously linked to the port, the exit signal from the port is guaranteed to be delivered before <code class="code">port_info/2</code> returns <code class="code">undefined</code>.</p> <p>Failure: <code class="code">badarg</code> if <code class="code">Port</code> is not a local port identifier, or an atom.</p>  <h3 class="code">erlang:port_info(Port, Item :: id) -&gt; {id, Index} | undefined</h3> <p>Types:</p>    <pre>Port = port() | atom()
Index = integer() &gt;= 0</pre>

<p><code class="code">Index</code> is the internal index of the port. This index can be used to separate ports.</p> <p>If the port identified by <code class="code">Port</code> is not open, <code class="code">undefined</code> is returned. If the port is closed and the calling process was previously linked to the port, the exit signal from the port is guaranteed to be delivered before <code class="code">port_info/2</code> returns <code class="code">undefined</code>.</p> <p>Failure: <code class="code">badarg</code> if <code class="code">Port</code> is not a local port identifier, or an atom.</p>  <h3 class="code">erlang:port_info(Port, Item :: input) -&gt;<br>                    {input, Bytes} | undefined</h3> <p>Types:</p>    <pre>Port = port() | atom()
Bytes = integer() &gt;= 0</pre>

<p><code class="code">Bytes</code> is the total number of bytes read from the port.</p> <p>If the port identified by <code class="code">Port</code> is not open, <code class="code">undefined</code> is returned. If the port is closed and the calling process was previously linked to the port, the exit signal from the port is guaranteed to be delivered before <code class="code">port_info/2</code> returns <code class="code">undefined</code>.</p> <p>Failure: <code class="code">badarg</code> if <code class="code">Port</code> is not a local port identifier, or an atom.</p>  <h3 class="code">erlang:port_info(Port, Item :: links) -&gt; {links, Pids} | undefined</h3> <p>Types:</p>    <pre>Port = port() | atom()
Pids = [pid()]</pre>

<p><code class="code">Pids</code> is a list of the process identifiers of the processes that the port is linked to.</p> <p>If the port identified by <code class="code">Port</code> is not open, <code class="code">undefined</code> is returned. If the port is closed and the calling process was previously linked to the port, the exit signal from the port is guaranteed to be delivered before <code class="code">port_info/2</code> returns <code class="code">undefined</code>.</p> <p>Failure: <code class="code">badarg</code> if <code class="code">Port</code> is not a local port identifier, or an atom.</p>  <h3 class="code">erlang:port_info(Port, Item :: locking) -&gt;<br>                    {locking, Locking} | undefined</h3> <p>Types:</p>    <pre>Port = port() | atom()
Locking = false | port_level | driver_level</pre>

<p><code class="code">Locking</code> is one of the following:</p> <ul> <li> <code class="code">false</code> (emulator without SMP support)</li> <li> <code class="code">port_level</code> (port-specific locking)</li> <li> <code class="code">driver_level</code> (driver-specific locking)</li> </ul> <p>Notice that these results are highly implementation-specific and can change in a future release.</p> <p>If the port identified by <code class="code">Port</code> is not open, <code class="code">undefined</code> is returned. If the port is closed and the calling process was previously linked to the port, the exit signal from the port is guaranteed to be delivered before <code class="code">port_info/2</code> returns <code class="code">undefined</code>.</p> <p>Failure: <code class="code">badarg</code> if <code class="code">Port</code> is not a local port identifier, or an atom.</p>  <h3 class="code">erlang:port_info(Port, Item :: memory) -&gt;<br>                    {memory, Bytes} | undefined</h3> <p>Types:</p>    <pre>Port = port() | atom()
Bytes = integer() &gt;= 0</pre>

<p><code class="code">Bytes</code> is the total number of bytes allocated for this port by the runtime system. The port itself can have allocated memory that is not included in <code class="code">Bytes</code>.</p> <p>If the port identified by <code class="code">Port</code> is not open, <code class="code">undefined</code> is returned. If the port is closed and the calling process was previously linked to the port, the exit signal from the port is guaranteed to be delivered before <code class="code">port_info/2</code> returns <code class="code">undefined</code>.</p> <p>Failure: <code class="code">badarg</code> if <code class="code">Port</code> is not a local port identifier, or an atom.</p>  <h3 class="code">erlang:port_info(Port, Item :: monitors) -&gt;<br>                    {monitors, Monitors} | undefined</h3> <p>Types:</p>    <pre>Port = port() | atom()
Monitors = [{process, pid()}]</pre>

<p><code class="code">Monitors</code> represent processes monitored by this port.</p> <p>If the port identified by <code class="code">Port</code> is not open, <code class="code">undefined</code> is returned. If the port is closed and the calling process was previously linked to the port, the exit signal from the port is guaranteed to be delivered before <code class="code">port_info/2</code> returns <code class="code">undefined</code>.</p> <p>Failure: <code class="code">badarg</code> if <code class="code">Port</code> is not a local port identifier, or an atom.</p>  <h3 class="code">erlang:port_info(Port, Item :: monitored_by) -&gt;<br>                    {monitored_by, MonitoredBy} | undefined</h3> <p>Types:</p>    <pre>Port = port() | atom()
MonitoredBy = [pid()]</pre>

<p>Returns list of pids that are monitoring given port at the moment.</p> <p>If the port identified by <code class="code">Port</code> is not open, <code class="code">undefined</code> is returned. If the port is closed and the calling process was previously linked to the port, the exit signal from the port is guaranteed to be delivered before <code class="code">port_info/2</code> returns <code class="code">undefined</code>.</p> <p>Failure: <code class="code">badarg</code> if <code class="code">Port</code> is not a local port identifier, or an atom.</p>  <h3 class="code">erlang:port_info(Port, Item :: name) -&gt; {name, Name} | undefined</h3> <p>Types:</p>    <pre>Port = port() | atom()
Name = string()</pre>

<p><code class="code">Name</code> is the command name set by <code class="bold_code"><a href="#open_port-2"><span class="code">open_port/2</span></a></code>.</p> <p>If the port identified by <code class="code">Port</code> is not open, <code class="code">undefined</code> is returned. If the port is closed and the calling process was previously linked to the port, the exit signal from the port is guaranteed to be delivered before <code class="code">port_info/2</code> returns <code class="code">undefined</code>.</p> <p>Failure: <code class="code">badarg</code> if <code class="code">Port</code> is not a local port identifier, or an atom.</p>  <h3 class="code">erlang:port_info(Port, Item :: os_pid) -&gt;<br>                    {os_pid, OsPid} | undefined</h3> <p>Types:</p>    <pre>Port = port() | atom()
OsPid = integer() &gt;= 0 | undefined</pre>

<p><code class="code">OsPid</code> is the process identifier (or equivalent) of an OS process created with <code class="bold_code"><a href="#open_port-2"><span class="code">open_port({spawn | spawn_executable, Command}, Options)</span></a></code>. If the port is not the result of spawning an OS process, the value is <code class="code">undefined</code>.</p> <p>If the port identified by <code class="code">Port</code> is not open, <code class="code">undefined</code> is returned. If the port is closed and the calling process was previously linked to the port, the exit signal from the port is guaranteed to be delivered before <code class="code">port_info/2</code> returns <code class="code">undefined</code>.</p> <p>Failure: <code class="code">badarg</code> if <code class="code">Port</code> is not a local port identifier, or an atom.</p>  <h3 class="code">erlang:port_info(Port, Item :: output) -&gt;<br>                    {output, Bytes} | undefined</h3> <p>Types:</p>    <pre>Port = port() | atom()
Bytes = integer() &gt;= 0</pre>

<p><code class="code">Bytes</code> is the total number of bytes written to the port from Erlang processes using <code class="bold_code"><a href="#port_command-2"><span class="code">port_command/2</span></a></code>, <code class="bold_code"><a href="#port_command-3"><span class="code">port_command/3</span></a></code>, or <code class="code">Port ! {Owner, {command, Data}</code>.</p> <p>If the port identified by <code class="code">Port</code> is not open, <code class="code">undefined</code> is returned. If the port is closed and the calling process was previously linked to the port, the exit signal from the port is guaranteed to be delivered before <code class="code">port_info/2</code> returns <code class="code">undefined</code>.</p> <p>Failure: <code class="code">badarg</code> if <code class="code">Port</code> is not a local port identifier, or an atom.</p>  <h3 class="code">erlang:port_info(Port, Item :: parallelism) -&gt;<br>                    {parallelism, Boolean} | undefined</h3> <p>Types:</p>    <pre>Port = port() | atom()
Boolean = boolean()</pre>

<p><code class="code">Boolean</code> corresponds to the port parallelism hint used by this port. For more information, see option <code class="bold_code"><a href="#open_port_parallelism"><span class="code">parallelism</span></a></code> of <code class="bold_code"><a href="#open_port-2"><span class="code">open_port/2</span></a></code>.</p>  <h3 class="code">erlang:port_info(Port, Item :: queue_size) -&gt;<br>                    {queue_size, Bytes} | undefined</h3> <p>Types:</p>    <pre>Port = port() | atom()
Bytes = integer() &gt;= 0</pre>

<p><code class="code">Bytes</code> is the total number of bytes queued by the port using the ERTS driver queue implementation.</p> <p>If the port identified by <code class="code">Port</code> is not open, <code class="code">undefined</code> is returned. If the port is closed and the calling process was previously linked to the port, the exit signal from the port is guaranteed to be delivered before <code class="code">port_info/2</code> returns <code class="code">undefined</code>.</p> <p>Failure: <code class="code">badarg</code> if <code class="code">Port</code> is not a local port identifier, or an atom.</p>  <h3 class="code">erlang:port_info(Port, Item :: registered_name) -&gt;<br>                    {registered_name, RegisteredName} |<br>                    [] |<br>                    undefined</h3> <p>Types:</p>    <pre>Port = port() | atom()
RegisteredName = atom()</pre>

<p><code class="code">RegisteredName</code> is the registered name of the port. If the port has no registered name, <code class="code">[]</code> is returned.</p> <p>If the port identified by <code class="code">Port</code> is not open, <code class="code">undefined</code> is returned. If the port is closed and the calling process was previously linked to the port, the exit signal from the port is guaranteed to be delivered before <code class="code">port_info/2</code> returns <code class="code">undefined</code>.</p> <p>Failure: <code class="code">badarg</code> if <code class="code">Port</code> is not a local port identifier, or an atom.</p>  <h3 id="port_to_list-1" class="code">erlang:port_to_list(Port) -&gt; string()</h3> <p>Types:</p>   <pre>Port = port()</pre>

<p>Returns a string corresponding to the text representation of the port identifier <code class="code">Port</code>.</p> <div class="warning"> <div class="label">Warning</div> <div class="content">

<p>This BIF is intended for debugging. It is not to be used in application programs.</p> </div> </div>  <h3 id="ports-0" class="code">erlang:ports() -&gt; [port()]</h3> 
<p>Returns a list of port identifiers corresponding to all the ports existing on the local node.</p> <p>Notice that an exiting port exists, but is not open.</p>  <h3 id="pre_loaded-0" class="code">pre_loaded() -&gt; [module()]</h3> 
<p>Returns a list of Erlang modules that are preloaded in the system. As all loading of code is done through the file system, the file system must have been loaded previously. Hence, at least the module <code class="code">init</code> must be preloaded.</p>  <h3 id="process_display-2" class="code">erlang:process_display(Pid, Type) -&gt; true</h3> <p>Types:</p>    <pre>Pid = pid()
Type = backtrace</pre>

<p>Writes information about the local process <code class="code">Pid</code> on standard error. The only allowed value for the atom <code class="code">Type</code> is <code class="code">backtrace</code>, which shows the contents of the call stack, including information about the call chain, with the current function printed first. The format of the output is not further defined.</p>  <h3 id="process_flag-2" class="code">process_flag(Flag :: trap_exit, Boolean) -&gt; OldBoolean</h3> <p>Types:</p>    <pre>Boolean = OldBoolean = boolean()</pre>

<p>When <code class="code">trap_exit</code> is set to <code class="code">true</code>, exit signals arriving to a process are converted to <code class="code">{'EXIT', From, Reason}</code> messages, which can be received as ordinary messages. If <code class="code">trap_exit</code> is set to <code class="code">false</code>, the process exits if it receives an exit signal other than <code class="code">normal</code> and the exit signal is propagated to its linked processes. Application processes are normally not to trap exits.</p> <p>Returns the old value of the flag.</p> <p>See also <code class="bold_code"><a href="#exit-2"><span class="code">exit/2</span></a></code>.</p>  <h3 class="code">process_flag(Flag :: error_handler, Module) -&gt; OldModule</h3> <p>Types:</p>    <pre>Module = OldModule = atom()</pre>

<p>Used by a process to redefine the error handler for undefined function calls and undefined registered processes. Inexperienced users are not to use this flag, as code auto-loading depends on the correct operation of the error handling module.</p> <p>Returns the old value of the flag.</p>  <h3 class="code">process_flag(Flag :: min_heap_size, MinHeapSize) -&gt; OldMinHeapSize</h3> <p>Types:</p>    <pre>MinHeapSize = OldMinHeapSize = integer() &gt;= 0</pre>

<p>Changes the minimum heap size for the calling process.</p> <p>Returns the old value of the flag.</p>  <h3 class="code">process_flag(Flag :: min_bin_vheap_size, MinBinVHeapSize) -&gt;<br>                OldMinBinVHeapSize</h3> <p>Types:</p>    <pre>MinBinVHeapSize = OldMinBinVHeapSize = integer() &gt;= 0</pre>

<p>Changes the minimum binary virtual heap size for the calling process.</p> <p>Returns the old value of the flag.</p>  <h3 class="code">process_flag(Flag :: max_heap_size, MaxHeapSize) -&gt; OldMaxHeapSize</h3> <p>Types:</p>     <pre>MaxHeapSize = OldMaxHeapSize = max_heap_size()

max_heap_size() = 
    integer() &gt;= 0 |
    #{size =&gt; integer() &gt;= 0,
      kill =&gt; boolean(),
      error_logger =&gt; boolean()}</pre>

<p>This flag sets the maximum heap size for the calling process. If <code class="code">MaxHeapSize</code> is an integer, the system default values for <code class="code">kill</code> and <code class="code">error_logger</code> are used. </p> <dl> <dt><strong><code class="code">size</code></strong></dt> <dd> <p>The maximum size in words of the process. If set to zero, the heap size limit is disabled. <code class="code">badarg</code> is be thrown if the value is smaller than <code class="bold_code"><a href="#process_flag_min_heap_size"><span class="code">min_heap_size</span></a></code>. The size check is only done when a garbage collection is triggered.</p> <p><code class="code">size</code> is the entire heap of the process when garbage collection is triggered. This includes all generational heaps, the process stack, any <code class="bold_code"><a href="#process_flag_message_queue_data">messages that are considered to be part of the heap</a></code>, and any extra memory that the garbage collector needs during collection.</p> <p><code class="code">size</code> is the same as can be retrieved using <code class="bold_code"><a href="#process_info_total_heap_size"><span class="code">erlang:process_info(Pid, total_heap_size)</span></a></code>, or by adding <code class="code">heap_block_size</code>, <code class="code">old_heap_block_size</code> and <code class="code">mbuf_size</code> from <code class="bold_code"><a href="#process_info_garbage_collection_info"><span class="code">erlang:process_info(Pid, garbage_collection_info)</span></a></code>.</p> </dd> <dt><strong><code class="code">kill</code></strong></dt> <dd> <p>When set to <code class="code">true</code>, the runtime system sends an untrappable exit signal with reason <code class="code">kill</code> to the process if the maximum heap size is reached. The garbage collection that triggered the <code class="code">kill</code> is not completed, instead the process exits as soon as possible. When set to <code class="code">false</code>, no exit signal is sent to the process, instead it continues executing.</p> <p>If <code class="code">kill</code> is not defined in the map, the system default will be used. The default system default is <code class="code">true</code>. It can be changed by either option <code class="bold_code"><a href="../erl/#+hmaxk">+hmaxk</a></code> in <code class="code">erl(1)</code>, or <code class="bold_code"><a href="#system_flag_max_heap_size"><span class="code">erlang:system_flag(max_heap_size, MaxHeapSize)</span></a></code>.</p> </dd> <dt><strong><code class="code">error_logger</code></strong></dt> <dd> <p>When set to <code class="code">true</code>, the runtime system sends a message to the current <code class="bold_code"><span class="code">error_logger</span></code> containing details about the process when the maximum heap size is reached. One <code class="code">error_logger</code> report is sent each time the limit is reached.</p> <p>If <code class="code">error_logger</code> is not defined in the map, the system default is used. The default system default is <code class="code">true</code>. It can be changed by either the option <code class="bold_code"><a href="../erl/#+hmaxel">+hmaxel</a></code> int <code class="code">erl(1)</code>, or <code class="bold_code"><a href="#system_flag_max_heap_size"><span class="code">erlang:system_flag(max_heap_size, MaxHeapSize)</span></a></code>.</p> </dd> </dl> <p>The heap size of a process is quite hard to predict, especially the amount of memory that is used during the garbage collection. When contemplating using this option, it is recommended to first run it in production with <code class="code">kill</code> set to <code class="code">false</code> and inspect the <code class="code">error_logger</code> reports to see what the normal peak sizes of the processes in the system is and then tune the value accordingly. </p>  <h3 class="code">process_flag(Flag :: message_queue_data, MQD) -&gt; OldMQD</h3> <p>Types:</p>     <pre>MQD = OldMQD = <a href="#type-message_queue_data">message_queue_data()</a>

message_queue_data() = off_heap | on_heap</pre>

<p>This flag determines how messages in the message queue are stored, as follows:</p> <dl> <dt><strong><code class="code">off_heap</code></strong></dt> <dd> <p><strong>All</strong> messages in the message queue will be stored outside of the process heap. This implies that <strong>no</strong> messages in the message queue will be part of a garbage collection of the process.</p> </dd> <dt><strong><code class="code">on_heap</code></strong></dt> <dd> <p>All messages in the message queue will eventually be placed on heap. They can however temporarily be stored off heap. This is how messages always have been stored up until ERTS 8.0.</p> </dd> </dl> <p>The default <code class="code">message_queue_data</code> process flag is determined by command-line argument <code class="bold_code"><a href="../erl/#+hmqd"><span class="code">+hmqd</span></a></code> in <code class="code">erl(1)</code>.</p> <p>If the process potentially can get many messages, you are advised to set the flag to <code class="code">off_heap</code>. This because a garbage collection with many messages placed on the heap can become extremly expensive and the process can consume large amounts of memory. Performance of the actual message passing is however generally better when not using flag <code class="code">off_heap</code>.</p> <p>When changing this flag messages will be moved. This work has been initiated but not completed when this function call returns.</p> <p>Returns the old value of the flag.</p>  <h3 class="code">process_flag(Flag :: priority, Level) -&gt; OldLevel</h3> <p>Types:</p>     <pre>Level = OldLevel = priority_level()

priority_level() = low | normal | high | max</pre>

<p id="process_flag_priority"> Sets the process priority. <code class="code">Level</code> is an atom. Four priority levels exist: <code class="code">low</code>, <code class="code">normal</code>, <code class="code">high</code>, and <code class="code">max</code>. Default is <code class="code">normal</code>.</p> <div class="note"> <div class="label">Note</div> <div class="content">

<p>Priority level <code class="code">max</code> is reserved for internal use in the Erlang runtime system, and is <strong>not</strong> to be used by others.</p> </div> </div> <p>Internally in each priority level, processes are scheduled in a round robin fashion.</p> <p>Execution of processes on priority <code class="code">normal</code> and <code class="code">low</code> are interleaved. Processes on priority <code class="code">low</code> are selected for execution less frequently than processes on priority <code class="code">normal</code>.</p> <p>When runnable processes on priority <code class="code">high</code> exist, no processes on priority <code class="code">low</code> or <code class="code">normal</code> are selected for execution. Notice however that this does <strong>not</strong> mean that no processes on priority <code class="code">low</code> or <code class="code">normal</code> can run when processes are running on priority <code class="code">high</code>. On the runtime system with SMP support, more processes can be running in parallel than processes on priority <code class="code">high</code>. That is, a <code class="code">low</code> and a <code class="code">high</code> priority process can execute at the same time.</p> <p>When runnable processes on priority <code class="code">max</code> exist, no processes on priority <code class="code">low</code>, <code class="code">normal</code>, or <code class="code">high</code> are selected for execution. As with priority <code class="code">high</code>, processes on lower priorities can execute in parallel with processes on priority <code class="code">max</code>.</p> <p>Scheduling is pre-emptive. Regardless of priority, a process is pre-empted when it has consumed more than a certain number of reductions since the last time it was selected for execution.</p> <div class="note"> <div class="label">Note</div> <div class="content">

<p>Do not depend on the scheduling to remain exactly as it is today. Scheduling, at least on the runtime system with SMP support, is likely to be changed in a future release to use available processor cores better.</p> </div> </div> <p>There is <strong>no</strong> automatic mechanism for avoiding priority inversion, such as priority inheritance or priority ceilings. When using priorities, take this into account and handle such scenarios by yourself.</p> <p>Making calls from a <code class="code">high</code> priority process into code that you has no control over can cause the <code class="code">high</code> priority process to wait for a process with lower priority. That is, effectively decreasing the priority of the <code class="code">high</code> priority process during the call. Even if this is not the case with one version of the code that you have no control over, it can be the case in a future version of it. This can, for example, occur if a <code class="code">high</code> priority process triggers code loading, as the code server runs on priority <code class="code">normal</code>.</p> <p>Other priorities than <code class="code">normal</code> are normally not needed. When other priorities are used, use them with care, <strong>especially</strong> priority <code class="code">high</code>. A process on priority <code class="code">high</code> is only to perform work for short periods. Busy looping for long periods in a <code class="code">high</code> priority process causes most likely problems, as important OTP servers run on priority <code class="code">normal</code>.</p> <p>Returns the old value of the flag.</p>  <h3 class="code">process_flag(Flag :: save_calls, N) -&gt; OldN</h3> <p>Types:</p>    <pre>N = OldN = 0..10000</pre>

<p><code class="code">N</code> must be an integer in the interval 0..10000. If <code class="code">N</code> &gt; 0, call saving is made active for the process. This means that information about the <code class="code">N</code> most recent global function calls, BIF calls, sends, and receives made by the process are saved in a list, which can be retrieved with <code class="code">process_info(Pid, last_calls)</code>. A global function call is one in which the module of the function is explicitly mentioned. Only a fixed amount of information is saved, as follows:</p> <ul> <li><p>A tuple <code class="code">{Module, Function, Arity}</code> for function calls</p></li> <li><p>The atoms <code class="code">send</code>, <code class="code">'receive'</code>, and <code class="code">timeout</code> for sends and receives (<code class="code">'receive'</code> when a message is received and <code class="code">timeout</code> when a receive times out)</p></li> </ul> <p>If <code class="code">N</code> = 0, call saving is disabled for the process, which is the default. Whenever the size of the call saving list is set, its contents are reset.</p> <p>Returns the old value of the flag.</p>  <h3 class="code">process_flag(Flag :: sensitive, Boolean) -&gt; OldBoolean</h3> <p>Types:</p>    <pre>Boolean = OldBoolean = boolean()</pre>

<p>Sets or clears flag <code class="code">sensitive</code> for the current process. When a process has been marked as sensitive by calling <code class="code">process_flag(sensitive, true)</code>, features in the runtime system that can be used for examining the data or inner working of the process are silently disabled.</p> <p>Features that are disabled include (but are not limited to) the following:</p> <ul> <li><p>Tracing. Trace flags can still be set for the process, but no trace messages of any kind are generated. (If flag <code class="code">sensitive</code> is turned off, trace messages are again generated if any trace flags are set.)</p></li> <li><p>Sequential tracing. The sequential trace token is propagated as usual, but no sequential trace messages are generated.</p></li> </ul> <p><code class="code">process_info/1,2</code> cannot be used to read out the message queue or the process dictionary (both are returned as empty lists).</p> <p>Stack back-traces cannot be displayed for the process.</p> <p>In crash dumps, the stack, messages, and the process dictionary are omitted.</p> <p>If <code class="code">{save_calls,N}</code> has been set for the process, no function calls are saved to the call saving list. (The call saving list is not cleared. Also, send, receive, and time-out events are still added to the list.)</p> <p>Returns the old value of the flag.</p>  <h3 id="process_flag-3" class="code">process_flag(Pid, Flag, Value) -&gt; OldValue</h3> <p>Types:</p>      <pre>Pid = pid()
Flag = save_calls
Value = OldValue = integer() &gt;= 0</pre>

<p>Sets certain flags for the process <code class="code">Pid</code>, in the same manner as <code class="bold_code"><a href="#process_flag-2"><span class="code">process_flag/2</span></a></code>. Returns the old value of the flag. The valid values for <code class="code">Flag</code> are only a subset of those allowed in <code class="code">process_flag/2</code>, namely <code class="code">save_calls</code>.</p> <p>Failure: <code class="code">badarg</code> if <code class="code">Pid</code> is not a local process.</p>  <h3 id="process_info-1" class="code">process_info(Pid) -&gt; Info</h3> <p>Types:</p>          <pre>Pid = pid()
Info = [InfoTuple] | undefined
InfoTuple = process_info_result_item()
process_info_result_item() = 
    {backtrace, Bin :: binary()} |
    {binary,
     BinInfo ::
         [{integer() &gt;= 0,
           integer() &gt;= 0,
           integer() &gt;= 0}]} |
    {catchlevel, CatchLevel :: integer() &gt;= 0} |
    {current_function,
     {Module :: module(), Function :: atom(), Arity :: arity()}} |
    {current_location,
     {Module :: module(),
      Function :: atom(),
      Arity :: arity(),
      Location ::
          [{file, Filename :: string()} |
           {line, Line :: integer() &gt;= 1}]}} |
    {current_stacktrace, Stack :: [stack_item()]} |
    {dictionary, Dictionary :: [{Key :: term(), Value :: term()}]} |
    {error_handler, Module :: module()} |
    {garbage_collection, GCInfo :: [{atom(), integer() &gt;= 0}]} |
    {garbage_collection_info,
     GCInfo :: [{atom(), integer() &gt;= 0}]} |
    {group_leader, GroupLeader :: pid()} |
    {heap_size, Size :: integer() &gt;= 0} |
    {initial_call, mfa()} |
    {links, PidsAndPorts :: [pid() | port()]} |
    {last_calls, false | (Calls :: [mfa()])} |
    {memory, Size :: integer() &gt;= 0} |
    {message_queue_len, MessageQueueLen :: integer() &gt;= 0} |
    {messages, MessageQueue :: [term()]} |
    {min_heap_size, MinHeapSize :: integer() &gt;= 0} |
    {min_bin_vheap_size, MinBinVHeapSize :: integer() &gt;= 0} |
    {max_heap_size, MaxHeapSize :: max_heap_size()} |
    {monitored_by, Pids :: [pid()]} |
    {monitors,
     Monitors ::
         [{process | port,
           Pid ::
               pid() |
               port() |
               {RegName :: atom(), Node :: node()}}]} |
    {message_queue_data, MQD :: <a href="#type-message_queue_data">message_queue_data()</a>} |
    {priority, Level :: priority_level()} |
    {reductions, Number :: integer() &gt;= 0} |
    {registered_name, [] | (Atom :: atom())} |
    {sequential_trace_token,
     [] | (SequentialTraceToken :: term())} |
    {stack_size, Size :: integer() &gt;= 0} |
    {status,
     Status ::
         exiting |
         garbage_collecting |
         waiting |
         running |
         runnable |
         suspended} |
    {suspending,
     SuspendeeList ::
         [{Suspendee :: pid(),
           ActiveSuspendCount :: integer() &gt;= 0,
           OutstandingSuspendCount :: integer() &gt;= 0}]} |
    {total_heap_size, Size :: integer() &gt;= 0} |
    {trace, InternalTraceFlags :: integer() &gt;= 0} |
    {trap_exit, Boolean :: boolean()}
priority_level() = low | normal | high | max
stack_item() = 
    {Module :: module(),
     Function :: atom(),
     Arity :: arity() | (Args :: [term()]),
     Location ::
         [{file, Filename :: string()} |
          {line, Line :: integer() &gt;= 1}]}
max_heap_size() = 
    integer() &gt;= 0 |
    #{size =&gt; integer() &gt;= 0,
      kill =&gt; boolean(),
      error_logger =&gt; boolean()}
message_queue_data() = off_heap | on_heap</pre>

<p>Returns a list containing <code class="code">InfoTuple</code>s with miscellaneous information about the process identified by <code class="code">Pid</code>, or <code class="code">undefined</code> if the process is not alive.</p> <p>The order of the <code class="code">InfoTuple</code>s is undefined and all <code class="code">InfoTuple</code>s are not mandatory. The <code class="code">InfoTuple</code>s part of the result can be changed without prior notice.</p> <p>The <code class="code">InfoTuple</code>s with the following items are part of the result:</p> <ul> <li><code class="code">current_function</code></li> <li><code class="code">initial_call</code></li> <li><code class="code">status</code></li> <li><code class="code">message_queue_len</code></li> <li><code class="code">messages</code></li> <li><code class="code">links</code></li> <li><code class="code">dictionary</code></li> <li><code class="code">trap_exit</code></li> <li><code class="code">error_handler</code></li> <li><code class="code">priority</code></li> <li><code class="code">group_leader</code></li> <li><code class="code">total_heap_size</code></li> <li><code class="code">heap_size</code></li> <li><code class="code">stack_size</code></li> <li><code class="code">reductions</code></li> <li><code class="code">garbage_collection</code></li> </ul> <p>If the process identified by <code class="code">Pid</code> has a registered name, also an <code class="code">InfoTuple</code> with item <code class="code">registered_name</code> is included.</p> <p>For information about specific <code class="code">InfoTuple</code>s, see <code class="bold_code"><a href="#process_info-2"><span class="code">process_info/2</span></a></code>.</p> <div class="warning"> <div class="label">Warning</div> <div class="content">

<p>This BIF is intended for <strong>debugging only</strong>. For all other purposes, use <code class="bold_code"><a href="#process_info-2"><span class="code">process_info/2</span></a></code>.</p> </div> </div> <p>Failure: <code class="code">badarg</code> if <code class="code">Pid</code> is not a local process.</p>  <h3 id="process_info-2" class="code">process_info(Pid, Item) -&gt; InfoTuple | [] | undefined<br>process_info(Pid, ItemList) -&gt; InfoTupleList | [] | undefined</h3> <p>Types:</p>             <pre>Pid = pid()
ItemList = [Item]
Item = process_info_item()
InfoTupleList = [InfoTuple]
InfoTuple = process_info_result_item()
process_info_item() = 
    backtrace |
    binary |
    catchlevel |
    current_function |
    current_location |
    current_stacktrace |
    dictionary |
    error_handler |
    garbage_collection |
    garbage_collection_info |
    group_leader |
    heap_size |
    initial_call |
    links |
    last_calls |
    memory |
    message_queue_len |
    messages |
    min_heap_size |
    min_bin_vheap_size |
    monitored_by |
    monitors |
    message_queue_data |
    priority |
    reductions |
    registered_name |
    sequential_trace_token |
    stack_size |
    status |
    suspending |
    total_heap_size |
    trace |
    trap_exit
process_info_result_item() = 
    {backtrace, Bin :: binary()} |
    {binary,
     BinInfo ::
         [{integer() &gt;= 0,
           integer() &gt;= 0,
           integer() &gt;= 0}]} |
    {catchlevel, CatchLevel :: integer() &gt;= 0} |
    {current_function,
     {Module :: module(), Function :: atom(), Arity :: arity()}} |
    {current_location,
     {Module :: module(),
      Function :: atom(),
      Arity :: arity(),
      Location ::
          [{file, Filename :: string()} |
           {line, Line :: integer() &gt;= 1}]}} |
    {current_stacktrace, Stack :: [stack_item()]} |
    {dictionary, Dictionary :: [{Key :: term(), Value :: term()}]} |
    {error_handler, Module :: module()} |
    {garbage_collection, GCInfo :: [{atom(), integer() &gt;= 0}]} |
    {garbage_collection_info,
     GCInfo :: [{atom(), integer() &gt;= 0}]} |
    {group_leader, GroupLeader :: pid()} |
    {heap_size, Size :: integer() &gt;= 0} |
    {initial_call, mfa()} |
    {links, PidsAndPorts :: [pid() | port()]} |
    {last_calls, false | (Calls :: [mfa()])} |
    {memory, Size :: integer() &gt;= 0} |
    {message_queue_len, MessageQueueLen :: integer() &gt;= 0} |
    {messages, MessageQueue :: [term()]} |
    {min_heap_size, MinHeapSize :: integer() &gt;= 0} |
    {min_bin_vheap_size, MinBinVHeapSize :: integer() &gt;= 0} |
    {max_heap_size, MaxHeapSize :: max_heap_size()} |
    {monitored_by, Pids :: [pid()]} |
    {monitors,
     Monitors ::
         [{process | port,
           Pid ::
               pid() |
               port() |
               {RegName :: atom(), Node :: node()}}]} |
    {message_queue_data, MQD :: <a href="#type-message_queue_data">message_queue_data()</a>} |
    {priority, Level :: priority_level()} |
    {reductions, Number :: integer() &gt;= 0} |
    {registered_name, [] | (Atom :: atom())} |
    {sequential_trace_token,
     [] | (SequentialTraceToken :: term())} |
    {stack_size, Size :: integer() &gt;= 0} |
    {status,
     Status ::
         exiting |
         garbage_collecting |
         waiting |
         running |
         runnable |
         suspended} |
    {suspending,
     SuspendeeList ::
         [{Suspendee :: pid(),
           ActiveSuspendCount :: integer() &gt;= 0,
           OutstandingSuspendCount :: integer() &gt;= 0}]} |
    {total_heap_size, Size :: integer() &gt;= 0} |
    {trace, InternalTraceFlags :: integer() &gt;= 0} |
    {trap_exit, Boolean :: boolean()}
stack_item() = 
    {Module :: module(),
     Function :: atom(),
     Arity :: arity() | (Args :: [term()]),
     Location ::
         [{file, Filename :: string()} |
          {line, Line :: integer() &gt;= 1}]}
priority_level() = low | normal | high | max
max_heap_size() = 
    integer() &gt;= 0 |
    #{size =&gt; integer() &gt;= 0,
      kill =&gt; boolean(),
      error_logger =&gt; boolean()}
message_queue_data() = off_heap | on_heap</pre>

<p>Returns information about the process identified by <code class="code">Pid</code>, as specified by <code class="code">Item</code> or <code class="code">ItemList</code>. Returns <code class="code">undefined</code> if the process is not alive.</p> <p>If the process is alive and a single <code class="code">Item</code> is specified, the returned value is the corresponding <code class="code">InfoTuple</code>, unless <code class="code">Item =:= registered_name</code> and the process has no registered name. In this case, <code class="code">[]</code> is returned. This strange behavior is because of historical reasons, and is kept for backward compatibility.</p> <p>If <code class="code">ItemList</code> is specified, the result is <code class="code">InfoTupleList</code>. The <code class="code">InfoTuple</code>s in <code class="code">InfoTupleList</code> are included with the corresponding <code class="code">Item</code>s in the same order as the <code class="code">Item</code>s were included in <code class="code">ItemList</code>. Valid <code class="code">Item</code>s can be included multiple times in <code class="code">ItemList</code>.</p> <div class="note"> <div class="label">Note</div> <div class="content">

<p>If <code class="code">registered_name</code> is part of <code class="code">ItemList</code> and the process has no name registered, a <code class="code">{registered_name, []}</code>, <code class="code">InfoTuple</code> <strong>will</strong> be included in the resulting <code class="code">InfoTupleList</code>. This behavior is different when a single <code class="code">Item =:= registered_name</code> is specified, and when <code class="code">process_info/1</code> is used.</p> </div> </div> <p>Valid <code class="code">InfoTuple</code>s with corresponding <code class="code">Item</code>s:</p> <dl> <dt><strong><code class="code">{backtrace, Bin}</code></strong></dt> <dd> <p>Binary <code class="code">Bin</code> contains the same information as the output from <code class="code">erlang:process_display(Pid, backtrace)</code>. Use <code class="code">binary_to_list/1</code> to obtain the string of characters from the binary.</p> </dd> <dt><strong><code class="code">{binary, BinInfo}</code></strong></dt> <dd> <p><code class="code">BinInfo</code> is a list containing miscellaneous information about binaries currently referred to by this process. This <code class="code">InfoTuple</code> can be changed or removed without prior notice. In the current implementation <code class="code">BinInfo</code> is a list of tuples. The tuples contain; <code class="code">BinaryId</code>, <code class="code">BinarySize</code>, <code class="code">BinaryRefcCount</code>.</p> </dd> <dt><strong><code class="code">{catchlevel, CatchLevel}</code></strong></dt> <dd> <p><code class="code">CatchLevel</code> is the number of currently active catches in this process. This <code class="code">InfoTuple</code> can be changed or removed without prior notice.</p> </dd> <dt><strong><code class="code">{current_function, {Module, Function, Arity}}</code></strong></dt> <dd> <p><code class="code">Module</code>, <code class="code">Function</code>, <code class="code">Arity</code> is the current function call of the process.</p> </dd> <dt><strong><code class="code">{current_location, {Module, Function, Arity, Location}}</code></strong></dt> <dd> <p><code class="code">Module</code>, <code class="code">Function</code>, <code class="code">Arity</code> is the current function call of the process. <code class="code">Location</code> is a list of two-tuples describing the location in the source code.</p> </dd> <dt><strong><code class="code">{current_stacktrace, Stack}</code></strong></dt> <dd> <p>Returns the current call stack back-trace (<strong>stacktrace</strong>) of the process. The stack has the same format as returned by <code class="bold_code"><a href="#get_stacktrace-0"><span class="code">erlang:get_stacktrace/0</span></a></code>. The depth of the stacktrace is truncated according to the <code class="code">backtrace_depth</code> system flag setting.</p> </dd> <dt><strong><code class="code">{dictionary, Dictionary}</code></strong></dt> <dd> <p><code class="code">Dictionary</code> is the process dictionary.</p> </dd> <dt><strong><code class="code">{error_handler, Module}</code></strong></dt> <dd> <p><code class="code">Module</code> is the error handler module used by the process (for undefined function calls, for example).</p> </dd> <dt><strong><code class="code">{garbage_collection, GCInfo}</code></strong></dt> <dd> <p><code class="code">GCInfo</code> is a list containing miscellaneous information about garbage collection for this process. The content of <code class="code">GCInfo</code> can be changed without prior notice.</p> </dd> <dt><strong id="process_info_garbage_collection_info">  <code class="code">{garbage_collection_info, GCInfo}</code> </strong></dt> <dd> <p><code class="code">GCInfo</code> is a list containing miscellaneous detailed information about garbage collection for this process. The content of <code class="code">GCInfo</code> can be changed without prior notice. For details about the meaning of each item, see <code class="bold_code"><a href="#gc_minor_start"><span class="code">gc_minor_start</span></a></code> in <code class="bold_code"><a href="#trace-3"><span class="code">erlang:trace/3</span></a></code>.</p> </dd> <dt><strong><code class="code">{group_leader, GroupLeader}</code></strong></dt> <dd> <p><code class="code">GroupLeader</code> is the group leader for the I/O of the process.</p> </dd> <dt><strong><code class="code">{heap_size, Size}</code></strong></dt> <dd> <p><code class="code">Size</code> is the size in words of the youngest heap generation of the process. This generation includes the process stack. This information is highly implementation-dependent, and can change if the implementation changes.</p> </dd> <dt><strong><code class="code">{initial_call, {Module, Function, Arity}}</code></strong></dt> <dd> <p><code class="code">Module</code>, <code class="code">Function</code>, <code class="code">Arity</code> is the initial function call with which the process was spawned.</p> </dd> <dt><strong><code class="code">{links, PidsAndPorts}</code></strong></dt> <dd> <p><code class="code">PidsAndPorts</code> is a list of process identifiers and port identifiers, with processes or ports to which the process has a link.</p> </dd> <dt><strong><code class="code">{last_calls, false|Calls}</code></strong></dt> <dd> <p>The value is <code class="code">false</code> if call saving is not active for the process (see <code class="bold_code"><a href="#process_flag-3"><span class="code">process_flag/3</span></a></code>). If call saving is active, a list is returned, in which the last element is the most recent called.</p> </dd> <dt><strong><code class="code">{memory, Size}</code></strong></dt> <dd> <p><code class="code">Size</code> is the size in bytes of the process. This includes call stack, heap, and internal structures.</p> </dd> <dt><strong><code class="code">{message_queue_len, MessageQueueLen}</code></strong></dt> <dd> <p><code class="code">MessageQueueLen</code> is the number of messages currently in the message queue of the process. This is the length of the list <code class="code">MessageQueue</code> returned as the information item <code class="code">messages</code> (see below).</p> </dd> <dt><strong><code class="code">{messages, MessageQueue}</code></strong></dt> <dd> <p><code class="code">MessageQueue</code> is a list of the messages to the process, which have not yet been processed.</p> </dd> <dt><strong><code class="code">{min_heap_size, MinHeapSize}</code></strong></dt> <dd> <p><code class="code">MinHeapSize</code> is the minimum heap size for the process.</p> </dd> <dt><strong><code class="code">{min_bin_vheap_size, MinBinVHeapSize}</code></strong></dt> <dd> <p><code class="code">MinBinVHeapSize</code> is the minimum binary virtual heap size for the process.</p> </dd> <dt><strong><code class="code">{monitored_by, Pids}</code></strong></dt> <dd> <p>A list of process identifiers monitoring the process (with <code class="code">monitor/2</code>).</p> </dd> <dt><strong><code class="code">{monitors, Monitors}</code></strong></dt> <dd> <p>A list of monitors (started by <code class="code">monitor/2</code>) that are active for the process. For a local process monitor or a remote process monitor by a process identifier, the list consists of:</p> <dl> <dt><strong><code class="code">{process, Pid}</code></strong></dt> <dd>Process is monitored by pid.</dd> <dt><strong><code class="code">{process, {RegName, Node}}</code></strong></dt> <dd>Local or remote process is monitored by name.</dd> <dt><strong><code class="code">{port, PortId}</code></strong></dt> <dd>Local port is monitored by port id.</dd> <dt><strong><code class="code">{port, {RegName, Node}}</code></strong></dt> <dd>Local port is monitored by name. Please note, that remote port monitors are not supported, so <code class="code">Node</code> will always be the local node name.</dd> </dl> </dd> <dt><strong><code class="code">{message_queue_data, MQD}</code></strong></dt> <dd> <p>Returns the current state of process flag <code class="code">message_queue_data</code>. <code class="code">MQD</code> is either <code class="code">off_heap</code> or <code class="code">on_heap</code>. For more information, see the documentation of <code class="bold_code"><a href="#process_flag_message_queue_data"><span class="code">process_flag(message_queue_data, MQD)</span></a></code>.</p> </dd> <dt><strong><code class="code">{priority, Level}</code></strong></dt> <dd> <p><code class="code">Level</code> is the current priority level for the process. For more information on priorities, see <code class="bold_code"><a href="#process_flag_priority"><span class="code">process_flag(priority, Level)</span></a></code>.</p> </dd> <dt><strong><code class="code">{reductions, Number}</code></strong></dt> <dd> <p><code class="code">Number</code> is the number of reductions executed by the process.</p> </dd> <dt><strong><code class="code">{registered_name, Atom}</code></strong></dt> <dd> <p><code class="code">Atom</code> is the registered process name. If the process has no registered name, this tuple is not present in the list.</p> </dd> <dt><strong><code class="code">{sequential_trace_token, [] | SequentialTraceToken}</code></strong></dt> <dd> <p><code class="code">SequentialTraceToken</code> is the sequential trace token for the process. This <code class="code">InfoTuple</code> can be changed or removed without prior notice.</p> </dd> <dt><strong><code class="code">{stack_size, Size}</code></strong></dt> <dd> <p><code class="code">Size</code> is the stack size, in words, of the process.</p> </dd> <dt><strong><code class="code">{status, Status}</code></strong></dt> <dd> <p><code class="code">Status</code> is the status of the process and is one of the following:</p> <ul> <li><code class="code">exiting</code></li> <li><code class="code">garbage_collecting</code></li> <li> <code class="code">waiting</code> (for a message)</li> <li><code class="code">running</code></li> <li> <code class="code">runnable</code> (ready to run, but another process is running)</li> <li> <code class="code">suspended</code> (suspended on a "busy" port or by the BIF <code class="code">erlang:suspend_process/1,2</code>)</li> </ul> </dd> <dt><strong><code class="code">{suspending, SuspendeeList}</code></strong></dt> <dd> <p><code class="code">SuspendeeList</code> is a list of <code class="code">{Suspendee, ActiveSuspendCount, OutstandingSuspendCount}</code> tuples. <code class="code">Suspendee</code> is the process identifier of a process that has been, or is to be, suspended by the process identified by <code class="code">Pid</code> through the BIF <code class="bold_code"><a href="#suspend_process-2"><span class="code">erlang:suspend_process/2</span></a></code> or <code class="bold_code"><a href="#suspend_process-1"><span class="code">erlang:suspend_process/1</span></a></code>.</p> <p><code class="code">ActiveSuspendCount</code> is the number of times <code class="code">Suspendee</code> has been suspended by <code class="code">Pid</code>. <code class="code">OutstandingSuspendCount</code> is the number of not yet completed suspend requests sent by <code class="code">Pid</code>, that is:</p> <ul> <li> <p>If <code class="code">ActiveSuspendCount =/= 0</code>, <code class="code">Suspendee</code> is currently in the suspended state.</p> </li> <li> <p>If <code class="code">OutstandingSuspendCount =/= 0</code>, option <code class="code">asynchronous</code> of <code class="code">erlang:suspend_process/2</code> has been used and the suspendee has not yet been suspended by <code class="code">Pid</code>.</p> </li> </ul> <p>Notice that <code class="code">ActiveSuspendCount</code> and <code class="code">OutstandingSuspendCount</code> are not the total suspend count on <code class="code">Suspendee</code>, only the parts contributed by <code class="code">Pid</code>.</p> </dd> <dt><strong id="process_info_total_heap_size">  <code class="code">{total_heap_size, Size}</code> </strong></dt> <dd> <p><code class="code">Size</code> is the total size, in words, of all heap fragments of the process. This includes the process stack and any unreceived messages that are considered to be part of the heap.</p> </dd> <dt><strong><code class="code">{trace, InternalTraceFlags}</code></strong></dt> <dd> <p><code class="code">InternalTraceFlags</code> is an integer representing the internal trace flag for this process. This <code class="code">InfoTuple</code> can be changed or removed without prior notice.</p> </dd> <dt><strong><code class="code">{trap_exit, Boolean}</code></strong></dt> <dd> <p><code class="code">Boolean</code> is <code class="code">true</code> if the process is trapping exits, otherwise <code class="code">false</code>.</p> </dd> </dl> <p>Notice that not all implementations support all these <code class="code">Item</code>s.</p> <p>Failures:</p> <dl> <dt><strong><code class="code">badarg</code></strong></dt> <dd>If <code class="code">Pid</code> is not a local process.</dd> <dt><strong><code class="code">badarg</code></strong></dt> <dd>If <code class="code">Item</code> is an invalid item.</dd> </dl>  <h3 id="processes-0" class="code">processes() -&gt; [pid()]</h3> 
<p>Returns a list of process identifiers corresponding to all the processes currently existing on the local node.</p> <p>Notice that an exiting process exists, but is not alive. That is, <code class="code">is_process_alive/1</code> returns <code class="code">false</code> for an exiting process, but its process identifier is part of the result returned from <code class="code">processes/0</code>.</p> <p>Example:</p> <div class="example"><pre>
&gt; processes().
[&lt;0.0.0&gt;,&lt;0.2.0&gt;,&lt;0.4.0&gt;,&lt;0.5.0&gt;,&lt;0.7.0&gt;,&lt;0.8.0&gt;]</pre></div>  <h3 id="purge_module-1" class="code">purge_module(Module) -&gt; true</h3> <p>Types:</p>   <pre>Module = atom()</pre>

<p>Removes old code for <code class="code">Module</code>. Before this BIF is used, <code class="bold_code"><a href="#check_process_code-2"><span class="code">check_process_code/2</span></a></code>is to be called to check that no processes execute old code in the module.</p> <div class="warning"> <div class="label">Warning</div> <div class="content">

<p>This BIF is intended for the code server (see <code class="bold_code"><span class="code">code(3)</span></code>) and is not to be used elsewhere.</p> </div> </div> <div class="note"> <div class="label">Note</div> <div class="content">

<p>As from ERTS 8.0 (Erlang/OTP 19), any lingering processes that still execute the old code is killed by this function. In earlier versions, such incorrect use could cause much more fatal failures, like emulator crash.</p> </div> </div> <p>Failure: <code class="code">badarg</code> if there is no old code for <code class="code">Module</code>.</p>  <h3 id="put-2" class="code">put(Key, Val) -&gt; term()</h3> <p>Types:</p>    <pre>Key = Val = term()</pre>

<p>Adds a new <code class="code">Key</code> to the process dictionary, associated with the value <code class="code">Val</code>, and returns <code class="code">undefined</code>. If <code class="code">Key</code> exists, the old value is deleted and replaced by <code class="code">Val</code>, and the function returns the old value. Example:</p> <div class="example"><pre>
&gt; X = put(name, walrus), Y = put(name, carpenter),
Z = get(name),
{X, Y, Z}.
{undefined,walrus,carpenter}</pre></div> <div class="note"> <div class="label">Note</div> <div class="content">

<p>The values stored when <code class="code">put</code> is evaluated within the scope of a <code class="code">catch</code> are not retracted if a <code class="code">throw</code> is evaluated, or if an error occurs.</p> </div> </div>  <h3 id="raise-3" class="code">erlang:raise(Class, Reason, Stacktrace) -&gt; no_return()</h3> <p>Types:</p>      <pre>Class = error | exit | throw
Reason = term()
Stacktrace = raise_stacktrace()
raise_stacktrace() = 
    [{module(), atom(), arity() | [term()]} |
     {function(), [term()]}] |
    [{module(), atom(), arity() | [term()], [{atom(), term()}]} |
     {function(), [term()], [{atom(), term()}]}]</pre>

<p>Stops the execution of the calling process with an exception of the specified class, reason, and call stack backtrace (<strong>stacktrace</strong>).</p> <p><code class="code">Class</code> is <code class="code">error</code>, <code class="code">exit</code>, or <code class="code">throw</code>. So, if it were not for the stacktrace, <code class="code">erlang:raise(Class, Reason, Stacktrace)</code> is equivalent to <code class="code">erlang:Class(Reason)</code>.</p> <p><code class="code">Reason</code> is any term. <code class="code">Stacktrace</code> is a list as returned from <code class="code">get_stacktrace()</code>, that is, a list of four-tuples <code class="code">{Module, Function, Arity | Args, Location}</code>, where <code class="code">Module</code> and <code class="code">Function</code> are atoms, and the third element is an integer arity or an argument list. The stacktrace can also contain <code class="code">{Fun, Args, Location}</code> tuples, where <code class="code">Fun</code> is a local fun and <code class="code">Args</code> is an argument list.</p> <p>Element <code class="code">Location</code> at the end is optional. Omitting it is equivalent to specifying an empty list.</p> <p>The stacktrace is used as the exception stacktrace for the calling process; it is truncated to the current maximum stacktrace depth.</p> <p>As evaluating this function causes the process to terminate, it has no return value unless the arguments are invalid, in which case the function <strong>returns the error reason</strong> <code class="code">badarg</code>. If you want to be sure not to return, you can call <code class="code">error(erlang:raise(Class, Reason, Stacktrace))</code> and hope to distinguish exceptions later.</p>  <h3 id="read_timer-1" class="code">erlang:read_timer(TimerRef) -&gt; Result</h3> <p>Types:</p>     <pre>TimerRef = reference()
Time = integer() &gt;= 0
Result = Time | false</pre>

<p>Reads the state of a timer. The same as calling <code class="bold_code"><a href="#read_timer-2"><span class="code">erlang:read_timer(TimerRef, [])</span></a></code>.</p>  <h3 id="read_timer-2" class="code">erlang:read_timer(TimerRef, Options) -&gt; Result | ok</h3> <p>Types:</p>        <pre>TimerRef = reference()
Async = boolean()
Option = {async, Async}
Options = [Option]
Time = integer() &gt;= 0
Result = Time | false</pre>

<p>Reads the state of a timer that has been created by either <code class="bold_code"><a href="#start_timer-4"><span class="code">erlang:start_timer</span></a></code> or <code class="bold_code"><a href="#send_after-4"><span class="code">erlang:send_after</span></a></code>. <code class="code">TimerRef</code> identifies the timer, and was returned by the BIF that created the timer.</p> <p><code class="code">Options</code>:</p> <dl> <dt><strong><code class="code">{async, Async}</code></strong></dt> <dd> <p>Asynchronous request for state information. <code class="code">Async</code> defaults to <code class="code">false</code>, which causes the operation to be performed synchronously. In this case, the <code class="code">Result</code> is returned by <code class="code">erlang:read_timer</code>. When <code class="code">Async</code> is <code class="code">true</code>, <code class="code">erlang:read_timer</code> sends an asynchronous request for the state information to the timer service that manages the timer, and then returns <code class="code">ok</code>. A message on the format <code class="code">{read_timer, TimerRef, Result}</code> is sent to the caller of <code class="code">erlang:read_timer</code> when the operation has been processed.</p> </dd> </dl> <p>More <code class="code">Option</code>s can be added in the future.</p> <p>If <code class="code">Result</code> is an integer, it represents the time in milliseconds left until the timer expires.</p> <p>If <code class="code">Result</code> is <code class="code">false</code>, a timer corresponding to <code class="code">TimerRef</code> could not be found. This because the timer had expired, or been canceled, or because <code class="code">TimerRef</code> never has corresponded to a timer. Even if the timer has expired, it does not tell you whether or not the time-out message has arrived at its destination yet.</p> <div class="note"> <div class="label">Note</div> <div class="content">

<p>The timer service that manages the timer can be co-located with another scheduler than the scheduler that the calling process is executing on. If so, communication with the timer service takes much longer time than if it is located locally. If the calling process is in a critical path, and can do other things while waiting for the result of this operation, you want to use option <code class="code">{async, true}</code>. If using option <code class="code">{async, false}</code>, the calling process is blocked until the operation has been performed.</p> </div> </div> <p>See also <code class="bold_code"><a href="#send_after-4"><span class="code">erlang:send_after/4</span></a></code>, <code class="bold_code"><a href="#start_timer-4"><span class="code">erlang:start_timer/4</span></a></code>, and <code class="bold_code"><a href="#cancel_timer-2"><span class="code">erlang:cancel_timer/2</span></a></code>.</p>  <h3 id="ref_to_list-1" class="code">erlang:ref_to_list(Ref) -&gt; string()</h3> <p>Types:</p>   <pre>Ref = reference()</pre>

<p>Returns a string corresponding to the text representation of <code class="code">Ref</code>.</p> <div class="warning"> <div class="label">Warning</div> <div class="content">

<p>This BIF is intended for debugging and is not to be used in application programs.</p> </div> </div>  <h3 id="register-2" class="code">register(RegName, PidOrPort) -&gt; true</h3> <p>Types:</p>    <pre>RegName = atom()
PidOrPort = port() | pid()</pre>

<p>Associates the name <code class="code">RegName</code> with a process identifier (pid) or a port identifier. <code class="code">RegName</code>, which must be an atom, can be used instead of the pid or port identifier in send operator (<code class="code">RegName ! Message</code>). Example:</p> <div class="example"><pre>
&gt; register(db, Pid).
true</pre></div> <p>Failures:</p> <dl> <dt><strong><code class="code">badarg</code></strong></dt> <dd>If <code class="code">PidOrPort</code> is not an existing local process or port.</dd> <dt><strong><code class="code">badarg</code></strong></dt> <dd>If <code class="code">RegName</code> is already in use.</dd> <dt><strong><code class="code">badarg</code></strong></dt> <dd>If the process or port is already registered (already has a name).</dd> <dt><strong><code class="code">badarg</code></strong></dt> <dd>If <code class="code">RegName</code> is the atom <code class="code">undefined</code>.</dd> </dl>  <h3 id="registered-0" class="code">registered() -&gt; [RegName]</h3> <p>Types:</p>   <pre>RegName = atom()</pre>

<p>Returns a list of names that have been registered using <code class="bold_code"><a href="#register-2"><span class="code">register/2</span></a></code>, for example:</p> <div class="example"><pre>
&gt; registered().
[code_server, file_server, init, user, my_db]</pre></div>  <h3 id="resume_process-1" class="code">erlang:resume_process(Suspendee) -&gt; true</h3> <p>Types:</p>   <pre>Suspendee = pid()</pre>

<p>Decreases the suspend count on the process identified by <code class="code">Suspendee</code>. <code class="code">Suspendee</code> is previously to have been suspended through <code class="bold_code"><a href="#suspend_process-2"><span class="code">erlang:suspend_process/2</span></a></code> or <code class="bold_code"><a href="#suspend_process-1"><span class="code">erlang:suspend_process/1</span></a></code> by the process calling <code class="code">erlang:resume_process(Suspendee)</code>. When the suspend count on <code class="code">Suspendee</code> reaches zero, <code class="code">Suspendee</code> is resumed, that is, its state is changed from suspended into the state it had before it was suspended.</p> <div class="warning"> <div class="label">Warning</div> <div class="content">

<p>This BIF is intended for debugging only.</p> </div> </div> <p>Failures:</p> <dl> <dt><strong><code class="code">badarg</code></strong></dt> <dd> If <code class="code">Suspendee</code> is not a process identifier. </dd> <dt><strong><code class="code">badarg</code></strong></dt> <dd> If the process calling <code class="code">erlang:resume_process/1</code> had not previously increased the suspend count on the process identified by <code class="code">Suspendee</code>. </dd> <dt><strong><code class="code">badarg</code></strong></dt> <dd> If the process identified by <code class="code">Suspendee</code> is not alive. </dd> </dl>  <h3 id="round-1" class="code">round(Number) -&gt; integer()</h3> <p>Types:</p>   <pre>Number = number()</pre>

<p>Returns an integer by rounding <code class="code">Number</code>, for example:</p> <div class="example"><pre>
round(5.5).
6</pre></div> <p>Allowed in guard tests.</p>  <h3 id="self-0" class="code">self() -&gt; pid()</h3> 
<p>Returns the process identifier of the calling process, for example:</p> <div class="example"><pre>
&gt; self().
&lt;0.26.0&gt;</pre></div> <p>Allowed in guard tests.</p>  <h3 id="send-2" class="code">erlang:send(Dest, Msg) -&gt; Msg</h3> <p>Types:</p>     <pre>Dest = dst()
Msg = term()
dst() = 
    pid() |
    port() |
    (RegName :: atom()) |
    {RegName :: atom(), Node :: node()}</pre>

<p>Sends a message and returns <code class="code">Msg</code>. This is the same as <code class="code">Dest ! Msg</code>.</p> <p><code class="code">Dest</code> can be a remote or local process identifier, a (local) port, a locally registered name, or a tuple <code class="code">{RegName, Node}</code> for a registered name at another node.</p>  <h3 id="send-3" class="code">erlang:send(Dest, Msg, Options) -&gt; Res</h3> <p>Types:</p>       <pre>Dest = dst()
Msg = term()
Options = [nosuspend | noconnect]
Res = ok | nosuspend | noconnect
dst() = 
    pid() |
    port() |
    (RegName :: atom()) |
    {RegName :: atom(), Node :: node()}</pre>

<p>Either sends a message and returns <code class="code">ok</code>, or does not send the message but returns something else (see below). Otherwise the same as <code class="bold_code"><a href="#send-2"><span class="code">erlang:send/2</span></a></code>. For more detailed explanation and warnings, see <code class="bold_code"><a href="#send_nosuspend-2"><span class="code">erlang:send_nosuspend/2,3</span></a></code>.</p> <p>Options:</p> <dl> <dt><strong><code class="code">nosuspend</code></strong></dt> <dd>If the sender would have to be suspended to do the send, <code class="code">nosuspend</code> is returned instead. </dd> <dt><strong><code class="code">noconnect</code></strong></dt> <dd> If the destination node would have to be auto-connected to do the send, <code class="code">noconnect</code> is returned instead. </dd> </dl> <div class="warning"> <div class="label">Warning</div> <div class="content">

<p>As with <code class="code">erlang:send_nosuspend/2,3</code>: use with extreme care.</p> </div> </div>  <h3 id="send_after-3" class="code">erlang:send_after(Time, Dest, Msg) -&gt; TimerRef</h3> <p>Types:</p>      <pre>Time = integer() &gt;= 0
Dest = pid() | atom()
Msg = term()
TimerRef = reference()</pre>

<p>Starts a timer. The same as calling <code class="bold_code"><a href="#send_after-4"><span class="code">erlang:send_after(Time,Dest,Msg, [])</span></a></code>.</p>  <h3 id="send_after-4" class="code">erlang:send_after(Time, Dest, Msg, Options) -&gt; TimerRef</h3> <p>Types:</p>         <pre>Time = integer()
Dest = pid() | atom()
Msg = term()
Options = [Option]
Abs = boolean()
Option = {abs, Abs}
TimerRef = reference()</pre>

<p>Starts a timer. When the timer expires, the message <code class="code">Msg</code> is sent to the process identified by <code class="code">Dest</code>. Apart from the format of the time-out message, this function works exactly as <code class="bold_code"><a href="#start_timer-4"><span class="code">erlang:start_timer/4</span></a></code>.</p>  <h3 id="send_nosuspend-2" class="code">erlang:send_nosuspend(Dest, Msg) -&gt; boolean()</h3> <p>Types:</p>     <pre>Dest = dst()
Msg = term()
dst() = 
    pid() |
    port() |
    (RegName :: atom()) |
    {RegName :: atom(), Node :: node()}</pre>

<p>The same as <code class="bold_code"><a href="#send-3"><span class="code">erlang:send(Dest,Msg, [nosuspend])</span></a></code>, but returns <code class="code">true</code> if the message was sent and <code class="code">false</code> if the message was not sent because the sender would have had to be suspended.</p> <p>This function is intended for send operations to an unreliable remote node without ever blocking the sending (Erlang) process. If the connection to the remote node (usually not a real Erlang node, but a node written in C or Java) is overloaded, this function <strong>does not send the message</strong> and returns <code class="code">false</code>.</p> <p>The same occurs if <code class="code">Dest</code> refers to a local port that is busy. For all other destinations (allowed for the ordinary send operator <code class="code">'!'</code>), this function sends the message and returns <code class="code">true</code>.</p> <p>This function is only to be used in rare circumstances where a process communicates with Erlang nodes that can disappear without any trace, causing the TCP buffers and the drivers queue to be over-full before the node is shut down (because of tick time-outs) by <code class="code">net_kernel</code>. The normal reaction to take when this occurs is some kind of premature shutdown of the other node.</p> <p>Notice that ignoring the return value from this function would result in an <strong>unreliable</strong> message passing, which is contradictory to the Erlang programming model. The message is <strong>not</strong> sent if this function returns <code class="code">false</code>.</p> <p>In many systems, transient states of overloaded queues are normal. Although this function returns <code class="code">false</code> does not mean that the other node is guaranteed to be non-responsive, it could be a temporary overload. Also, a return value of <code class="code">true</code> does only mean that the message can be sent on the (TCP) channel without blocking; the message is not guaranteed to arrive at the remote node. For a disconnected non-responsive node, the return value is <code class="code">true</code> (mimics the behavior of operator <code class="code">!</code>). The expected behavior and the actions to take when the function returns <code class="code">false</code> are application- and hardware-specific.</p> <div class="warning"> <div class="label">Warning</div> <div class="content">

<p>Use with extreme care.</p> </div> </div>  <h3 id="send_nosuspend-3" class="code">erlang:send_nosuspend(Dest, Msg, Options) -&gt; boolean()</h3> <p>Types:</p>      <pre>Dest = dst()
Msg = term()
Options = [noconnect]
dst() = 
    pid() |
    port() |
    (RegName :: atom()) |
    {RegName :: atom(), Node :: node()}</pre>

<p>The same as <code class="bold_code"><a href="#send-3"><span class="code">erlang:send(Dest,Msg, [nosuspend |Options])</span></a></code>, but with a Boolean return value.</p> <p>This function behaves like <code class="bold_code"><a href="#send_nosuspend-2"><span class="code">erlang:send_nosuspend/2</span></a></code>, but takes a third parameter, a list of options. The only option is <code class="code">noconnect</code>, which makes the function return <code class="code">false</code> if the remote node is not currently reachable by the local node. The normal behavior is to try to connect to the node, which can stall the process during a short period. The use of option <code class="code">noconnect</code> makes it possible to be sure not to get the slightest delay when sending to a remote process. This is especially useful when communicating with nodes that expect to always be the connecting part (that is, nodes written in C or Java).</p> <p>Whenever the function returns <code class="code">false</code> (either when a suspend would occur or when <code class="code">noconnect</code> was specified and the node was not already connected), the message is guaranteed <strong>not</strong> to have been sent.</p> <div class="warning"> <div class="label">Warning</div> <div class="content">

<p>Use with extreme care.</p> </div> </div>  <h3 id="set_cookie-2" class="code">erlang:set_cookie(Node, Cookie) -&gt; true</h3> <p>Types:</p>    <pre>Node = node()
Cookie = atom()</pre>

<p>Sets the magic cookie of <code class="code">Node</code> to the atom <code class="code">Cookie</code>. If <code class="code">Node</code> is the local node, the function also sets the cookie of all other unknown nodes to <code class="code">Cookie</code> (see section <code class="bold_code">Distributed Erlang</code> in the Erlang Reference Manual in System Documentation).</p> <p>Failure: <code class="code">function_clause</code> if the local node is not alive.</p>  <h3 id="setelement-3" class="code">setelement(Index, Tuple1, Value) -&gt; Tuple2</h3> <p>Types:</p>  <pre>Index = integer() &gt;= 1</pre>
<p class="REFBODY">1..tuple_size(Tuple1</p>     <pre>Tuple1 = Tuple2 = tuple()

Value = term()</pre>

<p>Returns a tuple that is a copy of argument <code class="code">Tuple1</code> with the element specified by integer argument <code class="code">Index</code> (the first element is the element with index 1) replaced by argument <code class="code">Value</code>, for example:</p> <div class="example"><pre>
&gt; setelement(2, {10, green, bottles}, red).
{10,red,bottles}</pre></div>  <h3 id="size-1" class="code">size(Item) -&gt; integer() &gt;= 0</h3> <p>Types:</p>   <pre>Item = tuple() | binary()</pre>

<p>Returns the number of elements in a tuple or the number of bytes in a binary or bitstring, for example:</p> <div class="example"><pre>
&gt; size({morni, mulle, bwange}).
3
&gt; size(&lt;&lt;11, 22, 33&gt;&gt;).
3</pre></div> <p>For bitstrings, the number of whole bytes is returned. That is, if the number of bits in the bitstring is not divisible by 8, the resulting number of bytes is rounded <strong>down</strong>.</p> <p>Allowed in guard tests.</p> <p>See also <code class="bold_code"><a href="#tuple_size-1"><span class="code">tuple_size/1</span></a></code>, <code class="bold_code"><a href="#byte_size-1"><span class="code">byte_size/1</span></a></code>, and <code class="bold_code"><a href="#bit_size-1"><span class="code">bit_size/1</span></a></code>.</p>  <h3 id="spawn-1" class="code">spawn(Fun) -&gt; pid()</h3> <p>Types:</p>   <pre>Fun = function()</pre>

<p>Returns the process identifier of a new process started by the application of <code class="code">Fun</code> to the empty list <code class="code">[]</code>. Otherwise works like <code class="bold_code"><a href="#spawn-3"><span class="code">spawn/3</span></a></code>.</p>  <h3 id="spawn-2" class="code">spawn(Node, Fun) -&gt; pid()</h3> <p>Types:</p>    <pre>Node = node()
Fun = function()</pre>

<p>Returns the process identifier of a new process started by the application of <code class="code">Fun</code> to the empty list <code class="code">[]</code> on <code class="code">Node</code>. If <code class="code">Node</code> does not exist, a useless pid is returned. Otherwise works like <code class="bold_code"><a href="#spawn-3"><span class="code">spawn/3</span></a></code>.</p>  <h3 id="spawn-3" class="code">spawn(Module, Function, Args) -&gt; pid()</h3> <p>Types:</p>     <pre>Module = module()
Function = atom()
Args = [term()]</pre>

<p>Returns the process identifier of a new process started by the application of <code class="code">Module:Function</code> to <code class="code">Args</code>.</p> <p><code class="code">error_handler:undefined_function(Module, Function, Args)</code> is evaluated by the new process if <code class="code">Module:Function/Arity</code> does not exist (where <code class="code">Arity</code> is the length of <code class="code">Args</code>). The error handler can be redefined (see <code class="bold_code"><a href="#process_flag-2"><span class="code">process_flag/2</span></a></code>). If <code class="code">error_handler</code> is undefined, or the user has redefined the default <code class="code">error_handler</code> and its replacement is undefined, a failure with reason <code class="code">undef</code> occurs.</p> <p>Example:</p> <div class="example"><pre>
&gt; spawn(speed, regulator, [high_speed, thin_cut]).
&lt;0.13.1&gt;</pre></div>  <h3 id="spawn-4" class="code">spawn(Node, Module, Function, Args) -&gt; pid()</h3> <p>Types:</p>      <pre>Node = node()
Module = module()
Function = atom()
Args = [term()]</pre>

<p>Returns the process identifier (pid) of a new process started by the application of <code class="code">Module:Function</code> to <code class="code">Args</code> on <code class="code">Node</code>. If <code class="code">Node</code> does not exist, a useless pid is returned. Otherwise works like <code class="bold_code"><a href="#spawn-3"><span class="code">spawn/3</span></a></code>.</p>  <h3 id="spawn_link-1" class="code">spawn_link(Fun) -&gt; pid()</h3> <p>Types:</p>   <pre>Fun = function()</pre>

<p>Returns the process identifier of a new process started by the application of <code class="code">Fun</code> to the empty list <code class="code">[]</code>. A link is created between the calling process and the new process, atomically. Otherwise works like <code class="bold_code"><a href="#spawn-3"><span class="code">spawn/3</span></a></code>.</p>  <h3 id="spawn_link-2" class="code">spawn_link(Node, Fun) -&gt; pid()</h3> <p>Types:</p>    <pre>Node = node()
Fun = function()</pre>

<p>Returns the process identifier (pid) of a new process started by the application of <code class="code">Fun</code> to the empty list <code class="code">[]</code> on <code class="code">Node</code>. A link is created between the calling process and the new process, atomically. If <code class="code">Node</code> does not exist, a useless pid is returned and an exit signal with reason <code class="code">noconnection</code> is sent to the calling process. Otherwise works like <code class="bold_code"><a href="#spawn-3"><span class="code">spawn/3</span></a></code>.</p>  <h3 id="spawn_link-3" class="code">spawn_link(Module, Function, Args) -&gt; pid()</h3> <p>Types:</p>     <pre>Module = module()
Function = atom()
Args = [term()]</pre>

<p>Returns the process identifier of a new process started by the application of <code class="code">Module:Function</code> to <code class="code">Args</code>. A link is created between the calling process and the new process, atomically. Otherwise works like <code class="bold_code"><a href="#spawn-3"><span class="code">spawn/3</span></a></code>.</p>  <h3 id="spawn_link-4" class="code">spawn_link(Node, Module, Function, Args) -&gt; pid()</h3> <p>Types:</p>      <pre>Node = node()
Module = module()
Function = atom()
Args = [term()]</pre>

<p>Returns the process identifier (pid) of a new process started by the application of <code class="code">Module:Function</code> to <code class="code">Args</code> on <code class="code">Node</code>. A link is created between the calling process and the new process, atomically. If <code class="code">Node</code> does not exist, a useless pid is returned and an exit signal with reason <code class="code">noconnection</code> is sent to the calling process. Otherwise works like <code class="bold_code"><a href="#spawn-3"><span class="code">spawn/3</span></a></code>.</p>  <h3 id="spawn_monitor-1" class="code">spawn_monitor(Fun) -&gt; {pid(), reference()}</h3> <p>Types:</p>   <pre>Fun = function()</pre>

<p>Returns the process identifier of a new process, started by the application of <code class="code">Fun</code> to the empty list <code class="code">[]</code>, and a reference for a monitor created to the new process. Otherwise works like <code class="bold_code"><a href="#spawn-3"><span class="code">spawn/3</span></a></code>.</p>  <h3 id="spawn_monitor-3" class="code">spawn_monitor(Module, Function, Args) -&gt; {pid(), reference()}</h3> <p>Types:</p>     <pre>Module = module()
Function = atom()
Args = [term()]</pre>

<p>A new process is started by the application of <code class="code">Module:Function</code> to <code class="code">Args</code>. The process is monitored at the same time. Returns the process identifier and a reference for the monitor. Otherwise works like <code class="bold_code"><a href="#spawn-3"><span class="code">spawn/3</span></a></code>.</p>  <h3 id="spawn_opt-2" class="code">spawn_opt(Fun, Options) -&gt; pid() | {pid(), reference()}</h3> <p>Types:</p>        <pre>Fun = function()
Options = [spawn_opt_option()]
priority_level() = low | normal | high | max
max_heap_size() = 
    integer() &gt;= 0 |
    #{size =&gt; integer() &gt;= 0,
      kill =&gt; boolean(),
      error_logger =&gt; boolean()}
message_queue_data() = off_heap | on_heap
spawn_opt_option() = 
    link |
    monitor |
    {priority, Level :: priority_level()} |
    {fullsweep_after, Number :: integer() &gt;= 0} |
    {min_heap_size, Size :: integer() &gt;= 0} |
    {min_bin_vheap_size, VSize :: integer() &gt;= 0} |
    {max_heap_size, Size :: max_heap_size()} |
    {message_queue_data, MQD :: <a href="#type-message_queue_data">message_queue_data()</a>}</pre>

<p>Returns the process identifier (pid) of a new process started by the application of <code class="code">Fun</code> to the empty list <code class="code">[]</code>. Otherwise works like <code class="bold_code"><a href="#spawn_opt-4"><span class="code">spawn_opt/4</span></a></code>.</p> <p>If option <code class="code">monitor</code> is specified, the newly created process is monitored, and both the pid and reference for the monitor are returned.</p>  <h3 id="spawn_opt-3" class="code">spawn_opt(Node, Fun, Options) -&gt; pid() | {pid(), reference()}</h3> <p>Types:</p>         <pre>Node = node()
Fun = function()
Options = [spawn_opt_option()]
priority_level() = low | normal | high | max
max_heap_size() = 
    integer() &gt;= 0 |
    #{size =&gt; integer() &gt;= 0,
      kill =&gt; boolean(),
      error_logger =&gt; boolean()}
message_queue_data() = off_heap | on_heap
spawn_opt_option() = 
    link |
    monitor |
    {priority, Level :: priority_level()} |
    {fullsweep_after, Number :: integer() &gt;= 0} |
    {min_heap_size, Size :: integer() &gt;= 0} |
    {min_bin_vheap_size, VSize :: integer() &gt;= 0} |
    {max_heap_size, Size :: max_heap_size()} |
    {message_queue_data, MQD :: <a href="#type-message_queue_data">message_queue_data()</a>}</pre>

<p>Returns the process identifier (pid) of a new process started by the application of <code class="code">Fun</code> to the empty list <code class="code">[]</code> on <code class="code">Node</code>. If <code class="code">Node</code> does not exist, a useless pid is returned. Otherwise works like <code class="bold_code"><a href="#spawn_opt-4"><span class="code">spawn_opt/4</span></a></code>.</p>  <h3 id="spawn_opt-4" class="code">spawn_opt(Module, Function, Args, Options) -&gt;<br>             pid() | {pid(), reference()}</h3> <p>Types:</p>          <pre>Module = module()
Function = atom()
Args = [term()]
Options = [spawn_opt_option()]
priority_level() = low | normal | high | max
max_heap_size() = 
    integer() &gt;= 0 |
    #{size =&gt; integer() &gt;= 0,
      kill =&gt; boolean(),
      error_logger =&gt; boolean()}
message_queue_data() = off_heap | on_heap
spawn_opt_option() = 
    link |
    monitor |
    {priority, Level :: priority_level()} |
    {fullsweep_after, Number :: integer() &gt;= 0} |
    {min_heap_size, Size :: integer() &gt;= 0} |
    {min_bin_vheap_size, VSize :: integer() &gt;= 0} |
    {max_heap_size, Size :: max_heap_size()} |
    {message_queue_data, MQD :: <a href="#type-message_queue_data">message_queue_data()</a>}</pre>

<p>Works as <code class="bold_code"><a href="#spawn-3"><span class="code">spawn/3</span></a></code>, except that an extra option list is specified when creating the process.</p> <p>If option <code class="code">monitor</code> is specified, the newly created process is monitored, and both the pid and reference for the monitor are returned.</p> <p>Options:</p> <dl> <dt><strong><code class="code">link</code></strong></dt> <dd> <p>Sets a link to the parent process (like <code class="bold_code"><a href="#spawn_link-3"><span class="code">spawn_link/3</span></a></code> does).</p> </dd> <dt><strong><code class="code">monitor</code></strong></dt> <dd> <p>Monitors the new process (like <code class="bold_code"><a href="#monitor-2"><span class="code">monitor/2</span></a></code> does).</p> </dd> <dt><strong><code class="code">{priority, Level</code></strong></dt> <dd> <p>Sets the priority of the new process. Equivalent to executing <code class="bold_code"><a href="#process_flag_priority"><span class="code">process_flag(priority,Level)</span></a></code> in the start function of the new process, except that the priority is set before the process is selected for execution for the first time. For more information on priorities, see <code class="bold_code"><a href="#process_flag_priority"><span class="code">process_flag(priority,Level)</span></a></code>.</p> </dd> <dt><strong><code class="code">{fullsweep_after, Number}</code></strong></dt> <dd> <p>Useful only for performance tuning. Do not use this option unless you know that there is problem with execution times or memory consumption, and ensure that the option improves matters.</p> <p>The Erlang runtime system uses a generational garbage collection scheme, using an "old heap" for data that has survived at least one garbage collection. When there is no more room on the old heap, a fullsweep garbage collection is done.</p> <p>Option <code class="code">fullsweep_after</code> makes it possible to specify the maximum number of generational collections before forcing a fullsweep, even if there is room on the old heap. Setting the number to zero disables the general collection algorithm, that is, all live data is copied at every garbage collection.</p> <p>A few cases when it can be useful to change <code class="code">fullsweep_after</code>:</p> <ul> <li> <p>If binaries that are no longer used are to be thrown away as soon as possible. (Set <code class="code">Number</code> to zero.)</p> </li> <li> <p>A process that mostly have short-lived data is fullsweeped seldom or never, that is, the old heap contains mostly garbage. To ensure a fullsweep occasionally, set <code class="code">Number</code> to a suitable value, such as 10 or 20.</p> </li> <li>In embedded systems with a limited amount of RAM and no virtual memory, you might want to preserve memory by setting <code class="code">Number</code> to zero. (The value can be set globally, see <code class="bold_code"><a href="#system_flag-2"><span class="code">erlang:system_flag/2</span></a></code>.) </li> </ul> </dd> <dt><strong><code class="code">{min_heap_size, Size}</code></strong></dt> <dd> <p>Useful only for performance tuning. Do not use this option unless you know that there is problem with execution times or memory consumption, and ensure that the option improves matters.</p> <p>Gives a minimum heap size, in words. Setting this value higher than the system default can speed up some processes because less garbage collection is done. However, setting a too high value can waste memory and slow down the system because of worse data locality. Therefore, use this option only for fine-tuning an application and to measure the execution time with various <code class="code">Size</code> values.</p> </dd> <dt><strong><code class="code">{min_bin_vheap_size, VSize}</code></strong></dt> <dd> <p>Useful only for performance tuning. Do not use this option unless you know that there is problem with execution times or memory consumption, and ensure that the option improves matters.</p> <p>Gives a minimum binary virtual heap size, in words. Setting this value higher than the system default can speed up some processes because less garbage collection is done. However, setting a too high value can waste memory. Therefore, use this option only for fine-tuning an application and to measure the execution time with various <code class="code">VSize</code> values.</p> </dd> <dt><strong><code class="code">{max_heap_size, Size}</code></strong></dt> <dd> <p>Sets the <code class="code">max_heap_size</code> process flag. The default <code class="code">max_heap_size</code> is determined by command-line argument <code class="bold_code"><a href="../erl/#+hmax"><span class="code">+hmax</span></a></code> in <code class="code">erl(1)</code>. For more information, see the documentation of <code class="bold_code"><a href="#process_flag_max_heap_size"><span class="code">process_flag(max_heap_size,Size)</span></a></code>. </p> </dd> <dt><strong><code class="code">{message_queue_data, MQD}</code></strong></dt> <dd> <p>Sets the state of the <code class="code">message_queue_data</code> process flag. <code class="code">MQD</code> is to be either <code class="code">off_heap</code> or <code class="code">on_heap</code>. The default <code class="code">message_queue_data</code> process flag is determined by command-line argument <code class="bold_code"><a href="../erl/#+hmqd"><span class="code">+hmqd</span></a></code> in <code class="code">erl(1)</code>. For more information, see the documentation of <code class="bold_code"><a href="#process_flag_message_queue_data"><span class="code">process_flag(message_queue_data,MQD)</span></a></code>.</p> </dd> </dl>  <h3 id="spawn_opt-5" class="code">spawn_opt(Node, Module, Function, Args, Options) -&gt;<br>             pid() | {pid(), reference()}</h3> <p>Types:</p>           <pre>Node = node()
Module = module()
Function = atom()
Args = [term()]
Options = [spawn_opt_option()]
priority_level() = low | normal | high | max
max_heap_size() = 
    integer() &gt;= 0 |
    #{size =&gt; integer() &gt;= 0,
      kill =&gt; boolean(),
      error_logger =&gt; boolean()}
message_queue_data() = off_heap | on_heap
spawn_opt_option() = 
    link |
    monitor |
    {priority, Level :: priority_level()} |
    {fullsweep_after, Number :: integer() &gt;= 0} |
    {min_heap_size, Size :: integer() &gt;= 0} |
    {min_bin_vheap_size, VSize :: integer() &gt;= 0} |
    {max_heap_size, Size :: max_heap_size()} |
    {message_queue_data, MQD :: <a href="#type-message_queue_data">message_queue_data()</a>}</pre>

<p>Returns the process identifier (pid) of a new process started by the application of <code class="code">Module:Function</code> to <code class="code">Args</code> on <code class="code">Node</code>. If <code class="code">Node</code> does not exist, a useless pid is returned. Otherwise works like <code class="bold_code"><a href="#spawn_opt-4"><span class="code">spawn_opt/4</span></a></code>.</p> <div class="note"> <div class="label">Note</div> <div class="content">

<p>Option <code class="code">monitor</code> is not supported by <code class="code">spawn_opt/5</code>.</p> </div> </div>  <h3 id="split_binary-2" class="code">split_binary(Bin, Pos) -&gt; {binary(), binary()}</h3> <p>Types:</p>   <pre>Bin = binary()
Pos = integer() &gt;= 0</pre>
<p class="REFBODY">0..byte_size(Bin)</p>  
<p>Returns a tuple containing the binaries that are the result of splitting <code class="code">Bin</code> into two parts at position <code class="code">Pos</code>. This is not a destructive operation. After the operation, there are three binaries altogether. Example:</p> <div class="example"><pre>
&gt; B = list_to_binary("0123456789").
&lt;&lt;"0123456789"&gt;&gt;
&gt; byte_size(B).
10
&gt; {B1, B2} = split_binary(B,3).
{&lt;&lt;"012"&gt;&gt;,&lt;&lt;"3456789"&gt;&gt;}
&gt; byte_size(B1).
3
&gt; byte_size(B2).
7</pre></div>  <h3 id="start_timer-3" class="code">erlang:start_timer(Time, Dest, Msg) -&gt; TimerRef</h3> <p>Types:</p>      <pre>Time = integer() &gt;= 0
Dest = pid() | atom()
Msg = term()
TimerRef = reference()</pre>

<p>Starts a timer. The same as calling <code class="bold_code"><a href="#start_timer-4"><span class="code">erlang:start_timer(Time,Dest,Msg, [])</span></a></code>.</p>  <h3 id="start_timer-4" class="code">erlang:start_timer(Time, Dest, Msg, Options) -&gt; TimerRef</h3> <p>Types:</p>         <pre>Time = integer()
Dest = pid() | atom()
Msg = term()
Options = [Option]
Abs = boolean()
Option = {abs, Abs}
TimerRef = reference()</pre>

<p>Starts a timer. When the timer expires, the message <code class="code">{timeout, TimerRef, Msg}</code> is sent to the process identified by <code class="code">Dest</code>.</p> <p><code class="code">Option</code>s:</p> <dl> <dt><strong><code class="code">{abs, false}</code></strong></dt> <dd> <p>This is the default. It means the <code class="code">Time</code> value is interpreted as a time in milliseconds <strong>relative</strong> current <code class="bold_code"><a href="../time_correction/#Erlang_Monotonic_Time">Erlang monotonic time</a></code>.</p> </dd> <dt><strong><code class="code">{abs, true}</code></strong></dt> <dd> <p>Absolute <code class="code">Time</code> value. The <code class="code">Time</code> value is interpreted as an absolute Erlang monotonic time in milliseconds.</p> </dd> </dl> <p>More <code class="code">Option</code>s can be added in the future.</p> <p>The absolute point in time, the timer is set to expire on, must be in the interval <code class="code">[</code><code class="bold_code"><a href="#system_info_start_time"><span class="code">erlang:system_info(start_time)</span></a></code><code class="code">,</code><code class="bold_code"><a href="#system_info_end_time"><span class="code">erlang:system_info(end_time)</span></a></code><code class="code">]</code>. If a relative time is specified, the <code class="code">Time</code> value is not allowed to be negative.</p> <p>If <code class="code">Dest</code> is a <code class="code">pid()</code>, it must be a <code class="code">pid()</code> of a process created on the current runtime system instance. This process has either terminated or not. If <code class="code">Dest</code> is an <code class="code">atom()</code>, it is interpreted as the name of a locally registered process. The process referred to by the name is looked up at the time of timer expiration. No error is returned if the name does not refer to a process.</p> <p>If <code class="code">Dest</code> is a <code class="code">pid()</code>, the timer is automatically canceled if the process referred to by the <code class="code">pid()</code> is not alive, or if the process exits. This feature was introduced in ERTS 5.4.11. Notice that timers are not automatically canceled when <code class="code">Dest</code> is an <code class="code">atom()</code>.</p> <p>See also <code class="bold_code"><a href="#send_after-4"><span class="code">erlang:send_after/4</span></a></code>, <code class="bold_code"><a href="#cancel_timer-2"><span class="code">erlang:cancel_timer/2</span></a></code>, and <code class="bold_code"><a href="#read_timer-2"><span class="code">erlang:read_timer/2</span></a></code>.</p> <p>Failure: <code class="code">badarg</code> if the arguments do not satisfy the requirements specified here.</p>  <h3 id="statistics-1" class="code">statistics(Item :: active_tasks) -&gt; [ActiveTasks]</h3> <p>Types:</p>   <pre>ActiveTasks = integer() &gt;= 0</pre>

<p>Returns a list where each element represents the amount of active processes and ports on each run queue and its associated scheduler. That is, the number of processes and ports that are ready to run, or are currently running. The element location in the list corresponds to the scheduler and its run queue. The first element corresponds to scheduler number 1 and so on. The information is <strong>not</strong> gathered atomically. That is, the result is not necessarily a consistent snapshot of the state, but instead quite efficiently gathered.</p> <p>See also <code class="bold_code"><a href="#statistics_total_active_tasks"><span class="code">statistics(total_active_tasks)</span></a></code>, <code class="bold_code"><a href="#statistics_run_queue_lengths"><span class="code">statistics(run_queue_lengths)</span></a></code>, and <code class="bold_code"><a href="#statistics_total_run_queue_lengths"><span class="code">statistics(total_run_queue_lengths)</span></a></code>.</p>  <h3 class="code">statistics(Item :: context_switches) -&gt; {ContextSwitches, 0}</h3> <p>Types:</p>   <pre>ContextSwitches = integer() &gt;= 0</pre>

<p>Returns the total number of context switches since the system started.</p>  <h3 class="code">statistics(Item :: exact_reductions) -&gt;<br>              {Total_Exact_Reductions,<br>               Exact_Reductions_Since_Last_Call}</h3> <p>Types:</p>    <pre>Total_Exact_Reductions = Exact_Reductions_Since_Last_Call = integer() &gt;= 0</pre>

<p>Returns the number of exact reductions.</p> <div class="note"> <div class="label">Note</div> <div class="content">

<p><code class="code">statistics(exact_reductions)</code> is a more expensive operation than <code class="bold_code"><a href="#statistics_reductions">statistics(reductions)</a></code>, especially on an Erlang machine with SMP support.</p> </div> </div>  <h3 class="code">statistics(Item :: garbage_collection) -&gt;<br>              {Number_of_GCs, Words_Reclaimed, 0}</h3> <p>Types:</p>    <pre>Number_of_GCs = Words_Reclaimed = integer() &gt;= 0</pre>

<p>Returns information about garbage collection, for example:</p> <div class="example"><pre>
&gt; statistics(garbage_collection).
{85,23961,0}</pre></div> <p>This information can be invalid for some implementations.</p>  <h3 class="code">statistics(Item :: io) -&gt; {{input, Input}, {output, Output}}</h3> <p>Types:</p>    <pre>Input = Output = integer() &gt;= 0</pre>

<p>Returns <code class="code">Input</code>, which is the total number of bytes received through ports, and <code class="code">Output</code>, which is the total number of bytes output to ports.</p>  <h3 class="code">statistics(Item :: microstate_accounting) -&gt;<br>              [MSAcc_Thread] | undefined</h3> <p>Types:</p>       <pre>MSAcc_Thread = 
    #{type := MSAcc_Thread_Type,
      id := MSAcc_Thread_Id,
      counters := MSAcc_Counters}
MSAcc_Thread_Type = scheduler | async | aux
MSAcc_Thread_Id = integer() &gt;= 0
MSAcc_Counters = #{MSAcc_Thread_State =&gt; integer() &gt;= 0}
MSAcc_Thread_State = 
    alloc |
    aux |
    bif |
    busy_wait |
    check_io |
    emulator |
    ets |
    gc |
    gc_fullsweep |
    nif |
    other |
    port |
    send |
    sleep |
    timers</pre>

<p>Microstate accounting can be used to measure how much time the Erlang runtime system spends doing various tasks. It is designed to be as lightweight as possible, but some overhead exists when this is enabled. Microstate accounting is meant to be a profiling tool to help finding performance bottlenecks. To <code class="code">start</code>/<code class="code">stop</code>/<code class="code">reset</code> microstate accounting, use system flag <code class="bold_code"><a href="#system_flag_microstate_accounting"><span class="code">microstate_accounting</span></a></code>.</p> <p><code class="code">statistics(microstate_accounting)</code> returns a list of maps representing some of the OS threads within ERTS. Each map contains <code class="code">type</code> and <code class="code">id</code> fields that can be used to identify what thread it is, and also a counters field that contains data about how much time has been spent in the various states.</p> <p>Example:</p> <div class="example"><pre>
&gt; erlang:statistics(microstate_accounting).
[#{counters =&gt; #{aux =&gt; 1899182914,
                 check_io =&gt; 2605863602,
                 emulator =&gt; 45731880463,
                 gc =&gt; 1512206910,
                 other =&gt; 5421338456,
                 port =&gt; 221631,
                 sleep =&gt; 5150294100},
   id =&gt; 1,
   type =&gt; scheduler}|...]</pre></div> <p>The time unit is the same as returned by <code class="bold_code"><span class="code">os:perf_counter/0</span></code>. So, to convert it to milliseconds, you can do something like this:</p> <div class="example"><pre>
lists:map(
  fun(#{ counters := Cnt } = M) -&gt;
          MsCnt = maps:map(fun(_K, PerfCount) -&gt;
                                   erlang:convert_time_unit(PerfCount, perf_counter, 1000)
                           end, Cnt),
         M#{ counters := MsCnt }
  end, erlang:statistics(microstate_accounting)).</pre></div> <p>Notice that these values are not guaranteed to be the exact time spent in each state. This is because of various optimisation done to keep the overhead as small as possible.</p> <p><code class="code">MSAcc_Thread_Type</code>s:</p> <dl> <dt><strong><code class="code">scheduler</code></strong></dt> <dd>The main execution threads that do most of the work.</dd> <dt><strong><code class="code">dirty_cpu_scheduler</code></strong></dt> <dd>The threads for long running cpu intensive work.</dd> <dt><strong><code class="code">dirty_io_scheduler</code></strong></dt> <dd>The threads for long running I/O work.</dd> <dt><strong><code class="code">async</code></strong></dt> <dd>Async threads are used by various linked-in drivers (mainly the file drivers) do offload non-CPU intensive work.</dd> <dt><strong><code class="code">aux</code></strong></dt> <dd>Takes care of any work that is not specifically assigned to a scheduler.</dd> </dl> <p>The following <code class="code">MSAcc_Thread_State</code>s are available. All states are exclusive, meaning that a thread cannot be in two states at once. So, if you add the numbers of all counters in a thread, you get the total runtime for that thread.</p> <dl> <dt><strong><code class="code">aux</code></strong></dt> <dd>Time spent handling auxiliary jobs.</dd> <dt><strong><code class="code">check_io</code></strong></dt> <dd>Time spent checking for new I/O events.</dd> <dt><strong><code class="code">emulator</code></strong></dt> <dd>Time spent executing Erlang processes.</dd> <dt><strong><code class="code">gc</code></strong></dt> <dd>Time spent doing garbage collection. When extra states are enabled this is the time spent doing non-fullsweep garbage collections.</dd> <dt><strong><code class="code">other</code></strong></dt> <dd>Time spent doing unaccounted things.</dd> <dt><strong><code class="code">port</code></strong></dt> <dd>Time spent executing ports.</dd> <dt><strong><code class="code">sleep</code></strong></dt> <dd>Time spent sleeping.</dd> </dl> <p>More fine-grained <code class="code">MSAcc_Thread_State</code>s can be added through configure (such as <code class="code">./configure --with-microstate-accounting=extra</code>). Enabling these states causes performance degradation when microstate accounting is turned off and increases the overhead when it is turned on.</p> <dl> <dt><strong><code class="code">alloc</code></strong></dt> <dd>Time spent managing memory. Without extra states this time is spread out over all other states.</dd> <dt><strong><code class="code">bif</code></strong></dt> <dd>Time spent in BIFs. Without extra states this time is part of the <code class="code">emulator</code> state.</dd> <dt><strong><code class="code">busy_wait</code></strong></dt> <dd>Time spent busy waiting. This is also the state where a scheduler no longer reports that it is active when using <code class="bold_code"><a href="#statistics_scheduler_wall_time"><span class="code">statistics(scheduler_wall_time)</span></a></code>. So, if you add all other states but this and sleep, and then divide that by all time in the thread, you should get something very similar to the <code class="code">scheduler_wall_time</code> fraction. Without extra states this time is part of the <code class="code">other</code> state.</dd> <dt><strong><code class="code">ets</code></strong></dt> <dd>Time spent executing ETS BIFs. Without extra states this time is part of the <code class="code">emulator</code> state.</dd> <dt><strong><code class="code">gc_full</code></strong></dt> <dd>Time spent doing fullsweep garbage collection. Without extra states this time is part of the <code class="code">gc</code> state.</dd> <dt><strong><code class="code">nif</code></strong></dt> <dd>Time spent in NIFs. Without extra states this time is part of the <code class="code">emulator</code> state.</dd> <dt><strong><code class="code">send</code></strong></dt> <dd>Time spent sending messages (processes only). Without extra states this time is part of the <code class="code">emulator</code> state.</dd> <dt><strong><code class="code">timers</code></strong></dt> <dd>Time spent managing timers. Without extra states this time is part of the <code class="code">other</code> state.</dd> </dl> <p>The utility module <code class="bold_code"><span class="code">msacc(3)</span></code> can be used to more easily analyse these statistics.</p> <p>Returns <code class="code">undefined</code> if system flag <code class="bold_code"><a href="#system_flag_microstate_accounting"><span class="code">microstate_accounting</span></a></code> is turned off.</p> <p>The list of thread information is unsorted and can appear in different order between calls.</p> <div class="note"> <div class="label">Note</div> <div class="content">

<p>The threads and states are subject to change without any prior notice.</p> </div> </div>  <h3 class="code">statistics(Item :: reductions) -&gt;<br>              {Total_Reductions, Reductions_Since_Last_Call}</h3> <p>Types:</p>    <pre>Total_Reductions = Reductions_Since_Last_Call = integer() &gt;= 0</pre>

<p>Returns information about reductions, for example:</p> <div class="example"><pre>
&gt; statistics(reductions).
{2046,11}</pre></div> <div class="note"> <div class="label">Note</div> <div class="content">

<p>As from ERTS 5.5 (Erlang/OTP R11B), this value does not include reductions performed in current time slices of currently scheduled processes. If an exact value is wanted, use <code class="bold_code"><a href="#statistics_exact_reductions"><span class="code">statistics(exact_reductions)</span></a></code>.</p> </div> </div>  <h3 class="code">statistics(Item :: run_queue) -&gt; integer() &gt;= 0</h3> 
<p>Returns the total length of the run-queues. That is, the number of processes and ports that are ready to run on all available run-queues. The information is gathered atomically. That is, the result is a consistent snapshot of the state, but this operation is much more expensive compared to <code class="bold_code"><a href="#statistics_total_run_queue_lengths"><span class="code">statistics(total_run_queue_lengths)</span></a></code>, especially when a large amount of schedulers is used.</p>  <h3 class="code">statistics(Item :: run_queue_lengths) -&gt; [RunQueueLenght]</h3> <p>Types:</p>   <pre>RunQueueLenght = integer() &gt;= 0</pre>

<p>Returns a list where each element represents the amount of processes and ports ready to run for each run queue. The element location in the list corresponds to the run queue of a scheduler. The first element corresponds to the run queue of scheduler number 1 and so on. The information is <strong>not</strong> gathered atomically. That is, the result is not necessarily a consistent snapshot of the state, but instead quite efficiently gathered.</p> <p>See also <code class="bold_code"><a href="#statistics_total_run_queue_lengths"><span class="code">statistics(total_run_queue_lengths)</span></a></code>, <code class="bold_code"><a href="#statistics_active_tasks"><span class="code">statistics(active_tasks)</span></a></code>, and <code class="bold_code"><a href="#statistics_total_active_tasks"><span class="code">statistics(total_active_tasks)</span></a></code>.</p>  <h3 class="code">statistics(Item :: runtime) -&gt;<br>              {Total_Run_Time, Time_Since_Last_Call}</h3> <p>Types:</p>    <pre>Total_Run_Time = Time_Since_Last_Call = integer() &gt;= 0</pre>

<p>Returns information about runtime, in milliseconds.</p> <p>This is the sum of the runtime for all threads in the Erlang runtime system and can therefore be greater than the wall clock time.</p> <p>Example:</p> <div class="example"><pre>
&gt; statistics(runtime).
{1690,1620}</pre></div>  <h3 class="code">statistics(Item :: scheduler_wall_time) -&gt;<br>              [{SchedulerId, ActiveTime, TotalTime}] | undefined</h3> <p>Types:</p>     <pre>SchedulerId = integer() &gt;= 1
ActiveTime = TotalTime = integer() &gt;= 0</pre>

<p>Returns a list of tuples with <code class="code">{SchedulerId, ActiveTime, TotalTime}</code>, where <code class="code">SchedulerId</code> is an integer ID of the scheduler, <code class="code">ActiveTime</code> is the duration the scheduler has been busy, and <code class="code">TotalTime</code> is the total time duration since <code class="bold_code"><a href="#system_flag_scheduler_wall_time"><span class="code">scheduler_wall_time</span></a></code> activation. The time unit is undefined and can be subject to change between releases, OSs, and system restarts. <code class="code">scheduler_wall_time</code> is only to be used to calculate relative values for scheduler-utilization. <code class="code">ActiveTime</code> can never exceed <code class="code">TotalTime</code>.</p> <p>The definition of a busy scheduler is when it is not idle and is not scheduling (selecting) a process or port, that is:</p> <ul> <li>Executing process code</li> <li>Executing linked-in driver or NIF code</li> <li>Executing BIFs, or any other runtime handling</li> <li>Garbage collecting</li> <li>Handling any other memory management</li> </ul> <p>Notice that a scheduler can also be busy even if the OS has scheduled out the scheduler thread.</p> <p>Returns <code class="code">undefined</code> if system flag <code class="bold_code"><a href="#system_flag_scheduler_wall_time"><span class="code">scheduler_wall_time</span></a></code> is turned off.</p> <p>The list of scheduler information is unsorted and can appear in different order between calls.</p> <p>Using <code class="code">scheduler_wall_time</code> to calculate scheduler-utilization:</p> <div class="example"><pre>
&gt; erlang:system_flag(scheduler_wall_time, true).
false
&gt; Ts0 = lists:sort(erlang:statistics(scheduler_wall_time)), ok.
ok</pre></div> <p>Some time later the user takes another snapshot and calculates scheduler-utilization per scheduler, for example:</p> <div class="example"><pre>
&gt; Ts1 = lists:sort(erlang:statistics(scheduler_wall_time)), ok.
ok
&gt; lists:map(fun({{I, A0, T0}, {I, A1, T1}}) -&gt; {I, (A1 - A0)/(T1 - T0)} end, lists:zip(Ts0,Ts1)).
[{1,0.9743474730177548},
 {2,0.9744843782751444},
 {3,0.9995902361669045},
 {4,0.9738012596572161},
 {5,0.9717956667018103},
 {6,0.9739235846420741},
 {7,0.973237033077876},
 {8,0.9741297293248656}]</pre></div> <p>Using the same snapshots to calculate a total scheduler-utilization:</p> <div class="example"><pre>
&gt; {A, T} = lists:foldl(fun({{_, A0, T0}, {_, A1, T1}}, {Ai,Ti}) -&gt; {Ai + (A1 - A0), Ti + (T1 - T0)} end, {0, 0}, lists:zip(Ts0,Ts1)), A/T.
0.9769136803764825</pre></div> <div class="note"> <div class="label">Note</div> <div class="content">

<p><code class="code">scheduler_wall_time</code> is by default disabled. To enable it, use <code class="code">erlang:system_flag(scheduler_wall_time, true)</code>.</p> </div> </div>  <h3 class="code">statistics(Item :: total_active_tasks) -&gt; ActiveTasks</h3> <p>Types:</p>   <pre>ActiveTasks = integer() &gt;= 0</pre>

<p>Returns the total amount of active processes and ports in the system. That is, the number of processes and ports that are ready to run, or are currently running. The information is <strong>not</strong> gathered atomically. That is, the result is not necessarily a consistent snapshot of the state, but instead quite efficiently gathered.</p> <p>See also <code class="bold_code"><a href="#statistics_active_tasks"><span class="code">statistics(active_tasks)</span></a></code>, <code class="bold_code"><a href="#statistics_run_queue_lengths"><span class="code">statistics(run_queue_lengths)</span></a></code>, and <code class="bold_code"><a href="#statistics_total_run_queue_lengths"><span class="code">statistics(total_run_queue_lengths)</span></a></code>.</p>  <h3 class="code">statistics(Item :: total_run_queue_lengths) -&gt;<br>              TotalRunQueueLenghts</h3> <p>Types:</p>   <pre>TotalRunQueueLenghts = integer() &gt;= 0</pre>

<p>Returns the total length of the run queues. That is, the number of processes and ports that are ready to run on all available run queues. The information is <strong>not</strong> gathered atomically. That is, the result is not necessarily a consistent snapshot of the state, but much more efficiently gathered compared to <code class="bold_code"><a href="#statistics_run_queue"><span class="code">statistics(run_queue)</span></a></code>.</p> <p>See also <code class="bold_code"><a href="#statistics_run_queue_lengths"><span class="code">statistics(run_queue_lengths)</span></a></code>, <code class="bold_code"><a href="#statistics_total_active_tasks"><span class="code">statistics(total_active_tasks)</span></a></code>, and <code class="bold_code"><a href="#statistics_active_tasks"><span class="code">statistics(active_tasks)</span></a></code>.</p>  <h3 class="code">statistics(Item :: wall_clock) -&gt;<br>              {Total_Wallclock_Time,<br>               Wallclock_Time_Since_Last_Call}</h3> <p>Types:</p>    <pre>Total_Wallclock_Time = Wallclock_Time_Since_Last_Call = integer() &gt;= 0</pre>

<p>Returns information about wall clock. <code class="code">wall_clock</code> can be used in the same manner as <code class="code">runtime</code>, except that real time is measured as opposed to runtime or CPU time.</p>  <h3 id="suspend_process-1" class="code">erlang:suspend_process(Suspendee) -&gt; true</h3> <p>Types:</p>   <pre>Suspendee = pid()</pre>

<p>Suspends the process identified by <code class="code">Suspendee</code>. The same as calling <code class="bold_code"><a href="#suspend_process-2"><span class="code">erlang:suspend_process(Suspendee, [])</span></a></code>.</p> <div class="warning"> <div class="label">Warning</div> <div class="content">

<p>This BIF is intended for debugging only.</p> </div> </div>  <h3 id="suspend_process-2" class="code">erlang:suspend_process(Suspendee, OptList) -&gt; boolean()</h3> <p>Types:</p>     <pre>Suspendee = pid()
OptList = [Opt]
Opt = unless_suspending | asynchronous</pre>

<p>Increases the suspend count on the process identified by <code class="code">Suspendee</code> and puts it in the suspended state if it is not already in that state. A suspended process is not scheduled for execution until the process has been resumed.</p> <p>A process can be suspended by multiple processes and can be suspended multiple times by a single process. A suspended process does not leave the suspended state until its suspend count reaches zero. The suspend count of <code class="code">Suspendee</code> is decreased when <code class="bold_code"><a href="#resume_process-1"><span class="code">erlang:resume_process(Suspendee)</span></a></code> is called by the same process that called <code class="code">erlang:suspend_process(Suspendee)</code>. All increased suspend counts on other processes acquired by a process are automatically decreased when the process terminates.</p> <p>Options (<code class="code">Opt</code>s):</p> <dl> <dt><strong><code class="code">asynchronous</code></strong></dt> <dd> <p>A suspend request is sent to the process identified by <code class="code">Suspendee</code>. <code class="code">Suspendee</code> eventually suspends unless it is resumed before it could suspend. The caller of <code class="code">erlang:suspend_process/2</code> returns immediately, regardless of whether <code class="code">Suspendee</code> has suspended yet or not. The point in time when <code class="code">Suspendee</code> suspends cannot be deduced from other events in the system. It is only guaranteed that <code class="code">Suspendee</code> <strong>eventually</strong> suspends (unless it is resumed). If option <code class="code">asynchronous</code> has <strong>not</strong> been passed, the caller of <code class="code">erlang:suspend_process/2</code> is blocked until <code class="code">Suspendee</code> has suspended.</p> </dd> <dt><strong><code class="code">unless_suspending</code></strong></dt> <dd> <p>The process identified by <code class="code">Suspendee</code> is suspended unless the calling process already is suspending <code class="code">Suspendee</code>. If <code class="code">unless_suspending</code> is combined with option <code class="code">asynchronous</code>, a suspend request is sent unless the calling process already is suspending <code class="code">Suspendee</code> or if a suspend request already has been sent and is in transit. If the calling process already is suspending <code class="code">Suspendee</code>, or if combined with option <code class="code">asynchronous</code> and a send request already is in transit, <code class="code">false</code> is returned and the suspend count on <code class="code">Suspendee</code> remains unchanged.</p> </dd> </dl> <p>If the suspend count on the process identified by <code class="code">Suspendee</code> is increased, <code class="code">true</code> is returned, otherwise <code class="code">false</code>.</p> <div class="warning"> <div class="label">Warning</div> <div class="content">

<p>This BIF is intended for debugging only.</p> </div> </div> <p>Failures:</p> <dl> <dt><strong><code class="code">badarg</code></strong></dt> <dd> If <code class="code">Suspendee</code> is not a process identifier. </dd> <dt><strong><code class="code">badarg</code></strong></dt> <dd> If the process identified by <code class="code">Suspendee</code> is the same process as the process calling <code class="code">erlang:suspend_process/2</code>. </dd> <dt><strong><code class="code">badarg</code></strong></dt> <dd> If the process identified by <code class="code">Suspendee</code> is not alive. </dd> <dt><strong><code class="code">badarg</code></strong></dt> <dd> If the process identified by <code class="code">Suspendee</code> resides on another node. </dd> <dt><strong><code class="code">badarg</code></strong></dt> <dd> If <code class="code">OptList</code> is not a proper list of valid <code class="code">Opt</code>s. </dd> <dt><strong><code class="code">system_limit</code></strong></dt> <dd> If the process identified by <code class="code">Suspendee</code> has been suspended more times by the calling process than can be represented by the currently used internal data structures. The system limit is &gt; 2,000,000,000 suspends and will never be lower. </dd> </dl>  <h3 id="system_flag-2" class="code">erlang:system_flag(Flag :: backtrace_depth, Depth) -&gt; OldDepth</h3> <p>Types:</p>    <pre>Depth = OldDepth = integer() &gt;= 0</pre>

<p>Sets the maximum depth of call stack back-traces in the exit reason element of <code class="code">'EXIT'</code> tuples. The flag also limits the stacktrace depth returned by <code class="code">process_info</code> item <code class="code">current_stacktrace.</code></p> <p>Returns the old value of the flag.</p>  <h3 class="code">erlang:system_flag(Flag :: cpu_topology, CpuTopology) -&gt;<br>                      OldCpuTopology</h3> <p>Types:</p>         <pre>CpuTopology = OldCpuTopology = cpu_topology()

cpu_topology() = [LevelEntry :: level_entry()] | undefined
level_entry() = 
    {LevelTag :: level_tag(), SubLevel :: sub_level()} |
    {LevelTag :: level_tag(),
     InfoList :: info_list(),
     SubLevel :: sub_level()}
level_tag() = core | node | processor | thread
sub_level() = 
    [LevelEntry :: level_entry()] |
    (LogicalCpuId :: {logical, integer() &gt;= 0})
info_list() = []</pre>

<div class="warning"> <div class="label">Warning</div> <div class="content">

<p id="system_flag_cpu_topology"> <strong>This argument is deprecated.</strong> Instead of using this argument, use command-line argument <code class="bold_code"><span class="code">+sct</span></code> in <code class="code">erl(1)</code>.</p> <p>When this argument is removed, a final CPU topology to use is determined at emulator boot time.</p> </div> </div> <p>Sets the user-defined <code class="code">CpuTopology</code>. The user-defined CPU topology overrides any automatically detected CPU topology. By passing <code class="code">undefined</code> as <code class="code">CpuTopology</code>, the system reverts to the CPU topology automatically detected. The returned value equals the value returned from <code class="code">erlang:system_info(cpu_topology)</code> before the change was made.</p> <p>Returns the old value of the flag.</p> <p>The CPU topology is used when binding schedulers to logical processors. If schedulers are already bound when the CPU topology is changed, the schedulers are sent a request to rebind according to the new CPU topology.</p> <p>The user-defined CPU topology can also be set by passing command-line argument <code class="bold_code"><span class="code">+sct</span></code> to <code class="code">erl(1)</code>.</p> <p>For information on type <code class="code">CpuTopology</code> and more, see <code class="bold_code"><a href="#system_info_cpu_topology"><span class="code">erlang:system_info(cpu_topology)</span></a></code> as well as command-line flags <code class="bold_code"><span class="code">+sct</span></code> and <code class="bold_code"><span class="code">+sbt</span></code> in <code class="code">erl(1)</code>.</p>  <h3 class="code">erlang:system_flag(Flag :: dirty_cpu_schedulers_online,<br>                   DirtyCPUSchedulersOnline) -&gt;<br>                      OldDirtyCPUSchedulersOnline</h3> <p>Types:</p>    <pre>DirtyCPUSchedulersOnline = OldDirtyCPUSchedulersOnline = integer() &gt;= 1</pre>

<p id="system_flag_dirty_cpu_schedulers_online"> Sets the number of dirty CPU schedulers online. Range is <code class="code">1 &lt;= DirtyCPUSchedulersOnline &lt;= N</code>, where <code class="code">N</code> is the smallest of the return values of <code class="code">erlang:system_info(dirty_cpu_schedulers)</code> and <code class="code">erlang:system_info(schedulers_online)</code>.</p> <p>Returns the old value of the flag.</p> <p>The number of dirty CPU schedulers online can change if the number of schedulers online changes. For example, if 12 schedulers and 6 dirty CPU schedulers are online, and <code class="code">system_flag/2</code> is used to set the number of schedulers online to 6, then the number of dirty CPU schedulers online is automatically decreased by half as well, down to 3. Similarly, the number of dirty CPU schedulers online increases proportionally to increases in the number of schedulers online.</p> <div class="note"> <div class="label">Note</div> <div class="content">

<p>The dirty schedulers functionality is experimental. Enable support for dirty schedulers when building OTP to try out the functionality.</p> </div> </div> <p>For more information, see <code class="bold_code"><a href="#system_info_dirty_cpu_schedulers"><span class="code">erlang:system_info(dirty_cpu_schedulers)</span></a></code> and <code class="bold_code"><a href="#system_info_dirty_cpu_schedulers_online"><span class="code">erlang:system_info(dirty_cpu_schedulers_online)</span></a></code>.</p>  <h3 class="code">erlang:system_flag(Flag :: fullsweep_after, Number) -&gt; OldNumber</h3> <p>Types:</p>    <pre>Number = OldNumber = integer() &gt;= 0</pre>

<p>Sets system flag <code class="code">fullsweep_after</code>. <code class="code">Number</code> is a non-negative integer indicating how many times generational garbage collections can be done without forcing a fullsweep collection. The value applies to new processes, while processes already running are not affected.</p> <p>Returns the old value of the flag.</p> <p>In low-memory systems (especially without virtual memory), setting the value to <code class="code">0</code> can help to conserve memory.</p> <p>This value can also be set through (OS) environment variable <code class="code">ERL_FULLSWEEP_AFTER</code>.</p>  <h3 class="code">erlang:system_flag(Flag :: microstate_accounting, Action) -&gt;<br>                      OldState</h3> <p>Types:</p>    <pre>Action = true | false | reset
OldState = true | false</pre>

<p id="system_flag_microstate_accounting"> Turns on/off microstate accounting measurements. When passing reset, all counters are reset to 0.</p> <p>For more information see <code class="bold_code"><a href="#statistics_microstate_accounting"><span class="code">statistics(microstate_accounting)</span></a></code>.</p>  <h3 class="code">erlang:system_flag(Flag :: min_heap_size, MinHeapSize) -&gt;<br>                      OldMinHeapSize</h3> <p>Types:</p>    <pre>MinHeapSize = OldMinHeapSize = integer() &gt;= 0</pre>

<p>Sets the default minimum heap size for processes. The size is specified in words. The new <code class="code">min_heap_size</code> effects only processes spawned after the change of <code class="code">min_heap_size</code> has been made. <code class="code">min_heap_size</code> can be set for individual processes by using <code class="bold_code"><a href="#spawn_opt-4"><span class="code">spawn_opt/4</span></a></code> or <code class="bold_code"><a href="#process_flag-2"><span class="code">process_flag/2</span></a></code>.</p> <p>Returns the old value of the flag.</p>  <h3 class="code">erlang:system_flag(Flag :: min_bin_vheap_size, MinBinVHeapSize) -&gt;<br>                      OldMinBinVHeapSize</h3> <p>Types:</p>    <pre>MinBinVHeapSize = OldMinBinVHeapSize = integer() &gt;= 0</pre>

<p>Sets the default minimum binary virtual heap size for processes. The size is specified in words. The new <code class="code">min_bin_vhheap_size</code> effects only processes spawned after the change of <code class="code">min_bin_vheap_size</code> has been made. <code class="code">min_bin_vheap_size</code> can be set for individual processes by using <code class="bold_code"><a href="#spawn_opt-4"><span class="code">spawn_opt/2,3,4</span></a></code> or <code class="bold_code"><a href="#process_flag-2"><span class="code">process_flag/2</span></a></code>.</p> <p>Returns the old value of the flag.</p>  <h3 class="code">erlang:system_flag(Flag :: max_heap_size, MaxHeapSize) -&gt;<br>                      OldMaxHeapSize</h3> <p>Types:</p>     <pre>MaxHeapSize = OldMaxHeapSize = max_heap_size()

max_heap_size() = 
    integer() &gt;= 0 |
    #{size =&gt; integer() &gt;= 0,
      kill =&gt; boolean(),
      error_logger =&gt; boolean()}</pre>

<p> Sets the default maximum heap size settings for processes. The size is specified in words. The new <code class="code">max_heap_size</code> effects only processes spawned efter the change has been made. <code class="code">max_heap_size</code> can be set for individual processes using <code class="bold_code"><a href="#spawn_opt-4"><span class="code">spawn_opt/2,3,4</span></a></code> or <code class="bold_code"><a href="#process_flag_message_queue_data"><span class="code">process_flag/2</span></a></code>.</p> <p>Returns the old value of the flag.</p>  <h3 class="code">erlang:system_flag(Flag :: multi_scheduling, BlockState) -&gt;<br>                      OldBlockState</h3> <p>Types:</p>    <pre>BlockState = block | unblock | block_normal | unblock_normal
OldBlockState = blocked | disabled | enabled</pre>

<p id="system_flag_multi_scheduling"> If multi-scheduling is enabled, more than one scheduler thread is used by the emulator. Multi-scheduling can be blocked in two different ways. Either all schedulers but one is blocked, or all <strong>normal</strong> schedulers but one is blocked. When only normal schedulers are blocked, dirty schedulers are free to continue to schedule processes.</p> <p>If <code class="code">BlockState =:= block</code>, multi-scheduling is blocked. That is, one and only one scheduler thread will execute. If <code class="code">BlockState =:= unblock</code> and no one else blocks multi-scheduling, and this process has blocked only once, multi-scheduling is unblocked.</p> <p>If <code class="code">BlockState =:= block_normal</code>, normal multi-scheduling is blocked. That is, only one normal scheduler thread will execute, but multiple dirty schedulers can execute. If <code class="code">BlockState =:= unblock_normal</code> and no one else blocks normal multi-scheduling, and this process has blocked only once, normal multi-scheduling is unblocked.</p> <p>One process can block multi-scheduling and normal multi-scheduling multiple times. If a process has blocked multiple times, it must unblock exactly as many times as it has blocked before it has released its multi-scheduling block. If a process that has blocked multi-scheduling or normal multi-scheduling exits, it automatically releases its blocking of multi-scheduling and normal multi-scheduling.</p> <p>The return values are <code class="code">disabled</code>, <code class="code">blocked</code>, <code class="code">blocked_normal</code>, or <code class="code">enabled</code>. The returned value describes the state just after the call to <code class="code">erlang:system_flag(multi_scheduling, BlockState)</code> has been made. For information about the return values, see <code class="bold_code"><a href="#system_info_multi_scheduling"><span class="code">erlang:system_info(multi_scheduling)</span></a></code>.</p> <div class="note"> <div class="label">Note</div> <div class="content">

<p>Blocking of multi-scheduling and normal multi-scheduling is normally not needed. If you feel that you need to use these features, consider it a few more times again. Blocking multi-scheduling is only to be used as a last resort, as it is most likely a <strong>very inefficient</strong> way to solve the problem.</p> </div> </div> <p>See also <code class="bold_code"><a href="#system_info_multi_scheduling"><span class="code">erlang:system_info(multi_scheduling)</span></a></code>, <code class="bold_code"><a href="#system_info_normal_multi_scheduling_blockers"><span class="code">erlang:system_info(normal_multi_scheduling_blockers)</span></a></code>, <code class="bold_code"><a href="#system_info_multi_scheduling_blockers"><span class="code">erlang:system_info(multi_scheduling_blockers)</span></a></code>, and <code class="bold_code"><a href="#system_info_schedulers"><span class="code">erlang:system_info(schedulers)</span></a></code>.</p>  <h3 class="code">erlang:system_flag(Flag :: scheduler_bind_type, How) -&gt;<br>                      OldBindType</h3> <p>Types:</p>     <pre>How = scheduler_bind_type() | default_bind
OldBindType = scheduler_bind_type()
scheduler_bind_type() = 
    no_node_processor_spread |
    no_node_thread_spread |
    no_spread |
    processor_spread |
    spread |
    thread_spread |
    thread_no_node_processor_spread |
    unbound</pre>

<div class="warning"> <div class="label">Warning</div> <div class="content">

<p id="system_flag_scheduler_bind_type"> <strong>This argument is deprecated.</strong> Instead of using this argument, use command-line argument <code class="bold_code"><span class="code">+sbt</span></code> in <code class="code">erl(1)</code>. When this argument is removed, a final scheduler bind type to use is determined at emulator boot time.</p> </div> </div> <p>Controls if and how schedulers are bound to logical processors.</p> <p>When <code class="code">erlang:system_flag(scheduler_bind_type, How)</code> is called, an asynchronous signal is sent to all schedulers online, causing them to try to bind or unbind as requested.</p> <div class="note"> <div class="label">Note</div> <div class="content">

<p>If a scheduler fails to bind, this is often silently ignored, as it is not always possible to verify valid logical processor identifiers. If an error is reported, it is reported to <code class="code">error_logger</code>. To verify that the schedulers have bound as requested, call <code class="bold_code"><a href="#system_info_scheduler_bindings"><span class="code">erlang:system_info(scheduler_bindings)</span></a></code>.</p> </div> </div> <p>Schedulers can be bound on newer Linux, Solaris, FreeBSD, and Windows systems, but more systems will be supported in future releases.</p> <p>In order for the runtime system to be able to bind schedulers, the CPU topology must be known. If the runtime system fails to detect the CPU topology automatically, it can be defined. For more information on how to define the CPU topology, see command-line flag <code class="bold_code"><span class="code">+sct</span></code> in <code class="code">erl(1)</code>.</p> <p>The runtime system does by default <strong>not</strong> bind schedulers to logical processors.</p> <div class="note"> <div class="label">Note</div> <div class="content">

<p>If the Erlang runtime system is the only OS process binding threads to logical processors, this improves the performance of the runtime system. However, if other OS processes (for example, another Erlang runtime system) also bind threads to logical processors, there can be a performance penalty instead. Sometimes this performance penalty can be severe. If so, it is recommended to not bind the schedulers.</p> </div> </div> <p>Schedulers can be bound in different ways. Argument <code class="code">How</code> determines how schedulers are bound and can be any of the following:</p> <dl> <dt><strong><code class="code">unbound</code></strong></dt> <dd>Same as command-line argument <code class="bold_code"><span class="code">+sbt u</span></code> in <code class="code">erl(1)</code>. </dd> <dt><strong><code class="code">no_spread</code></strong></dt> <dd>Same as command-line argument <code class="bold_code"><span class="code">+sbt ns</span></code> in <code class="code">erl(1)</code>. </dd> <dt><strong><code class="code">thread_spread</code></strong></dt> <dd>Same as command-line argument <code class="bold_code"><span class="code">+sbt ts</span></code> in <code class="code">erl(1)</code>. </dd> <dt><strong><code class="code">processor_spread</code></strong></dt> <dd>Same as command-line argument <code class="bold_code"><span class="code">+sbt ps</span></code> in <code class="code">erl(1)</code>. </dd> <dt><strong><code class="code">spread</code></strong></dt> <dd>Same as command-line argument <code class="bold_code"><span class="code">+sbt s</span></code> in <code class="code">erl(1)</code>. </dd> <dt><strong><code class="code">no_node_thread_spread</code></strong></dt> <dd>Same as command-line argument <code class="bold_code"><span class="code">+sbt nnts</span></code> in <code class="code">erl(1)</code>. </dd> <dt><strong><code class="code">no_node_processor_spread</code></strong></dt> <dd>Same as command-line argument <code class="bold_code"><span class="code">+sbt nnps</span></code> in <code class="code">erl(1)</code>. </dd> <dt><strong><code class="code">thread_no_node_processor_spread</code></strong></dt> <dd>Same as command-line argument <code class="bold_code"><span class="code">+sbt tnnps</span></code> in <code class="code">erl(1)</code>. </dd> <dt><strong><code class="code">default_bind</code></strong></dt> <dd>Same as command-line argument <code class="bold_code"><span class="code">+sbt db</span></code> in <code class="code">erl(1)</code>. </dd> </dl> <p>The returned value equals <code class="code">How</code> before flag <code class="code">scheduler_bind_type</code> was changed.</p> <p>Failures:</p> <dl> <dt><strong><code class="code">notsup</code></strong></dt> <dd>If binding of schedulers is not supported. </dd> <dt><strong><code class="code">badarg</code></strong></dt> <dd>If <code class="code">How</code> is not one of the documented alternatives. </dd> <dt><strong><code class="code">badarg</code></strong></dt> <dd>If CPU topology information is unavailable. </dd> </dl> <p>The scheduler bind type can also be set by passing command-line argument <code class="bold_code"><span class="code">+sbt</span></code> to <code class="code">erl(1)</code>.</p> <p>For more information, see <code class="bold_code"><a href="#system_info_scheduler_bind_type"><span class="code">erlang:system_info(scheduler_bind_type)</span></a></code>, <code class="bold_code"><a href="#system_info_scheduler_bindings"><span class="code">erlang:system_info(scheduler_bindings)</span></a></code>, as well as command-line flags <code class="bold_code"><span class="code">+sbt</span></code> and <code class="bold_code"><span class="code">+sct</span></code> in <code class="code">erl(1)</code>.</p>  <h3 class="code">erlang:system_flag(Flag :: scheduler_wall_time, Boolean) -&gt;<br>                      OldBoolean</h3> <p>Types:</p>    <pre>Boolean = OldBoolean = boolean()</pre>

<p id="system_flag_scheduler_wall_time"> Turns on or off scheduler wall time measurements.</p> <p>For more information, see <code class="bold_code"><a href="#statistics_scheduler_wall_time"><span class="code">statistics(scheduler_wall_time)</span></a></code>.</p>  <h3 class="code">erlang:system_flag(Flag :: schedulers_online, SchedulersOnline) -&gt;<br>                      OldSchedulersOnline</h3> <p>Types:</p>    <pre>SchedulersOnline = OldSchedulersOnline = integer() &gt;= 1</pre>

<p id="system_flag_schedulers_online"> Sets the number of schedulers online. Range is <code class="code">1 &lt;= SchedulersOnline &lt;= erlang:system_info(schedulers)</code>.</p> <p>Returns the old value of the flag.</p> <p>If the emulator was built with support for <code class="bold_code"><a href="#system_flag_dirty_cpu_schedulers_online">dirty schedulers</a></code>, changing the number of schedulers online can also change the number of dirty CPU schedulers online. For example, if 12 schedulers and 6 dirty CPU schedulers are online, and <code class="code">system_flag/2</code> is used to set the number of schedulers online to 6, then the number of dirty CPU schedulers online is automatically decreased by half as well, down to 3. Similarly, the number of dirty CPU schedulers online increases proportionally to increases in the number of schedulers online.</p> <p>For more information, see <code class="bold_code"><a href="#system_info_schedulers"><span class="code">erlang:system_info(schedulers)</span></a></code> and <code class="bold_code"><a href="#system_info_schedulers_online"><span class="code">erlang:system_info(schedulers_online)</span></a></code>.</p>  <h3 class="code">erlang:system_flag(Flag :: trace_control_word, TCW) -&gt; OldTCW</h3> <p>Types:</p>    <pre>TCW = OldTCW = integer() &gt;= 0</pre>

<p>Sets the value of the node trace control word to <code class="code">TCW</code>, which is to be an unsigned integer. For more information, see function <code class="bold_code"><span class="code">set_tcw</span></code> in section "Match Specifications in Erlang" in the User's Guide.</p> <p>Returns the old value of the flag.</p>  <h3 class="code">erlang:system_flag(Flag :: time_offset, Value :: finalize) -&gt;<br>                      OldState</h3> <p>Types:</p>   <pre>OldState = preliminary | final | volatile</pre>

<p id="system_flag_time_offset"> Finalizes the <code class="bold_code"><a href="#time_offset-0">time offset</a></code> when <code class="bold_code"><a href="../time_correction/#Single_Time_Warp_Mode">single time warp mode</a></code> is used. If another time warp mode is used, the time offset state is left unchanged.</p> <p>Returns the old state identifier, that is:</p> <ul> <li> <p>If <code class="code">preliminary</code> is returned, finalization was performed and the time offset is now final.</p> </li> <li> <p>If <code class="code">final</code> is returned, the time offset was already in the final state. This either because another <code class="code">erlang:system_flag(time_offset, finalize)</code> call or because <code class="bold_code"><a href="../time_correction/#No_Time_Warp_Mode">no time warp mode</a></code> is used.</p> </li> <li> <p>If <code class="code">volatile</code> is returned, the time offset cannot be finalized because <code class="bold_code"><a href="../time_correction/#Multi_Time_Warp_Mode">multi-time warp mode</a></code> is used.</p> </li> </ul>  <h3 id="system_info-1" class="code">erlang:system_info(Item :: allocated_areas) -&gt; [tuple()]<br>erlang:system_info(Item :: allocator) -&gt;<br>                      {Allocator, Version, Features, Settings}<br>erlang:system_info(Item :: alloc_util_allocators) -&gt; [Alloc]<br>erlang:system_info(Item :: {allocator, Alloc}) -&gt; [term()]<br>erlang:system_info(Item :: {allocator_sizes, Alloc}) -&gt; [term()]</h3> <p>Types:</p>       <pre>Allocator = undefined | glibc
Version = [integer() &gt;= 0]
Features = [atom()]
Settings = 
    [{Subsystem :: atom(),
      [{Parameter :: atom(), Value :: term()}]}]
Alloc = atom()</pre>

<p>Returns various information about the allocators of the current system (emulator) as specified by <code class="code">Item</code>:</p>  <dl> <dt><strong><code class="code">allocated_areas</code></strong></dt> <dd> <p>Returns a list of tuples with information about miscellaneous allocated memory areas.</p> <p>Each tuple contains an atom describing the type of memory as first element and the amount of allocated memory in bytes as second element. When information about allocated and used memory is present, also a third element is present, containing the amount of used memory in bytes.</p> <p><code class="code">erlang:system_info(allocated_areas)</code> is intended for debugging, and the content is highly implementation-dependent. The content of the results therefore changes when needed without prior notice.</p> <p>Notice that the sum of these values is <strong>not</strong> the total amount of memory allocated by the emulator. Some values are part of other values, and some memory areas are not part of the result. For information about the total amount of memory allocated by the emulator, see <code class="bold_code"><a href="#memory-0"><span class="code">erlang:memory/0,1</span></a></code>.</p> </dd> <dt><strong><code class="code">allocator</code></strong></dt> <dd id="system_info_allocator">  <p>Returns <code class="code">{Allocator, Version, Features, Settings</code>, where:</p> <ul> <li> <p><code class="code">Allocator</code> corresponds to the <code class="code">malloc()</code> implementation used. If <code class="code">Allocator</code> equals <code class="code">undefined</code>, the <code class="code">malloc()</code> implementation used cannot be identified. <code class="code">glibc</code> can be identified.</p> </li> <li> <p><code class="code">Version</code> is a list of integers (but not a string) representing the version of the <code class="code">malloc()</code> implementation used.</p> </li> <li> <p><code class="code">Features</code> is a list of atoms representing the allocation features used.</p> </li> <li> <p><code class="code">Settings</code> is a list of subsystems, their configurable parameters, and used values. Settings can differ between different combinations of platforms, allocators, and allocation features. Memory sizes are given in bytes.</p> </li> </ul> <p>See also "System Flags Effecting erts_alloc" in <code class="bold_code"><span class="code">erts_alloc(3)</span></code>.</p> </dd> <dt><strong><code class="code">alloc_util_allocators</code></strong></dt> <dd id="system_info_alloc_util_allocators">  <p>Returns a list of the names of all allocators using the ERTS internal <code class="code">alloc_util</code> framework as atoms. For more information, see section <code class="bold_code">The alloc_util framework</code> in <code class="code">erts_alloc(3)</code>.</p> </dd> <dt><strong><code class="code">{allocator, Alloc}</code></strong></dt> <dd id="system_info_allocator_tuple">  <p>Returns information about the specified allocator. As from ERTS 5.6.1, the return value is a list of <code class="code">{instance, InstanceNo, InstanceInfo}</code> tuples, where <code class="code">InstanceInfo</code> contains information about a specific instance of the allocator. If <code class="code">Alloc</code> is not a recognized allocator, <code class="code">undefined</code> is returned. If <code class="code">Alloc</code> is disabled, <code class="code">false</code> is returned.</p> <p>Notice that the information returned is highly implementation-dependent and can be changed or removed at any time without prior notice. It was initially intended as a tool when developing new allocators, but as it can be of interest for others it has been briefly documented.</p> <p>The recognized allocators are listed in <code class="bold_code"><span class="code">erts_alloc(3)</span></code>. Information about super carriers can be obtained from ERTS 8.0 with <code class="code">{allocator, erts_mmap}</code> or from ERTS 5.10.4; the returned list when calling with <code class="code">{allocator, mseg_alloc}</code> also includes an <code class="code">{erts_mmap, _}</code> tuple as one element in the list.</p> <p>After reading the <code class="code">erts_alloc(3)</code> documentation, the returned information more or less speaks for itself, but it can be worth explaining some things. Call counts are presented by two values, the first value is giga calls, and the second value is calls. <code class="code">mbcs</code> and <code class="code">sbcs</code> denote multi-block carriers, and single-block carriers, respectively. Sizes are presented in bytes. When a size is not presented, it is the amount of something. Sizes and amounts are often presented by three values:</p> <ul> <li>The first is the current value.</li> <li>The second is the maximum value since the last call to <code class="code">erlang:system_info({allocator, Alloc})</code>.</li> <li>The third is the maximum value since the emulator was started.</li> </ul> <p>If only one value is present, it is the current value. <code class="code">fix_alloc</code> memory block types are presented by two values. The first value is the memory pool size and the second value is the used memory size.</p> </dd> <dt><strong><code class="code">{allocator_sizes, Alloc}</code></strong></dt> <dd id="system_info_allocator_sizes">  <p>Returns various size information for the specified allocator. The information returned is a subset of the information returned by <code class="bold_code"><a href="#system_info_allocator_tuple"><span class="code">erlang:system_info({allocator,Alloc})</span></a></code>.</p> </dd> </dl>  <h3 class="code">erlang:system_info(Item :: cpu_topology) -&gt; CpuTopology<br>erlang:system_info(Item ::<br>                       {cpu_topology, defined | detected | used}) -&gt;<br>                      CpuTopology</h3> <p>Types:</p>    All <pre>CpuTopology = cpu_topology()
cpu_topology() = [LevelEntry :: level_entry()] | undefined</pre>
<code class="code">LevelEntry</code>s of a list must contain the same <code class="code">LevelTag</code>, except on the top level where both <code class="code">node</code> and <code class="code">processor</code> <code class="code">LevelTag</code>s can coexist.    <pre>level_entry() = 
    {LevelTag :: level_tag(), SubLevel :: sub_level()} |
    {LevelTag :: level_tag(),
     InfoList :: info_list(),
     SubLevel :: sub_level()}</pre>
<code class="code">{LevelTag, SubLevel} == {LevelTag, [], SubLevel}</code>    More <pre>level_tag() = core | node | processor | thread</pre>
<code class="code">LevelTag</code>s can be introduced in a future release.     The <pre>sub_level() = 
    [LevelEntry :: level_entry()] |
    (LogicalCpuId :: {logical, integer() &gt;= 0})
info_list() = []</pre>
<code class="code">info_list()</code> can be extended in a future release.   
<p>Returns various information about the CPU topology of the current system (emulator) as specified by <code class="code">Item</code>:</p> <dl> <dt><strong><code class="code">cpu_topology</code></strong></dt> <dd> <p>Returns the <code class="code">CpuTopology</code> currently used by the emulator. The CPU topology is used when binding schedulers to logical processors. The CPU topology used is the <code class="bold_code"><a href="../erlang/#system_info_cpu_topology_defined">user-defined CPU topology</a></code>, if such exists, otherwise the <code class="bold_code"><a href="../erlang/#system_info_cpu_topology_detected">automatically detected CPU topology</a></code>, if such exists. If no CPU topology exists, <code class="code">undefined</code> is returned.</p> <p><code class="code">node</code> refers to Non-Uniform Memory Access (NUMA) nodes. <code class="code">thread</code> refers to hardware threads (for example, Intel hyper-threads).</p> <p>A level in term <code class="code">CpuTopology</code> can be omitted if only one entry exists and <code class="code">InfoList</code> is empty.</p> <p><code class="code">thread</code> can only be a sublevel to <code class="code">core</code>. <code class="code">core</code> can be a sublevel to <code class="code">processor</code> or <code class="code">node</code>. <code class="code">processor</code> can be on the top level or a sublevel to <code class="code">node</code>. <code class="code">node</code> can be on the top level or a sublevel to <code class="code">processor</code>. That is, NUMA nodes can be processor internal or processor external. A CPU topology can consist of a mix of processor internal and external NUMA nodes, as long as each logical CPU belongs to <strong>one</strong> NUMA node. Cache hierarchy is not part of the <code class="code">CpuTopology</code> type, but will be in a future release. Other things can also make it into the CPU topology in a future release. So, expect the <code class="code">CpuTopology</code> type to change.</p> </dd> <dt><strong><code class="code">{cpu_topology, defined}</code></strong></dt> <dd id="system_info_cpu_topology_defined">  <p>Returns the user-defined <code class="code">CpuTopology</code>. For more information, see command-line flag <code class="bold_code"><span class="code">+sct</span></code> in <code class="code">erl(1)</code> and argument <code class="bold_code"><a href="#system_info_cpu_topology"><span class="code">cpu_topology</span></a></code>.</p> </dd> <dt><strong><code class="code">{cpu_topology, detected}</code></strong></dt> <dd id="system_info_cpu_topology_detected">  <p>Returns the automatically detected <code class="code">CpuTopologyy</code>. The emulator detects the CPU topology on some newer Linux, Solaris, FreeBSD, and Windows systems. On Windows system with more than 32 logical processors, the CPU topology is not detected.</p> <p>For more information, see argument <code class="bold_code"><a href="#system_info_cpu_topology"><span class="code">cpu_topology</span></a></code>.</p> </dd> <dt><strong><code class="code">{cpu_topology, used}</code></strong></dt> <dd> <p>Returns <code class="code">CpuTopology</code> used by the emulator. For more information, see argument <code class="bold_code"><a href="#system_info_cpu_topology"><span class="code">cpu_topology</span></a></code>.</p> </dd> </dl>  <h3 class="code">erlang:system_info(Item :: fullsweep_after) -&gt;<br>                      {fullsweep_after, integer() &gt;= 0}<br>erlang:system_info(Item :: garbage_collection) -&gt;<br>                      [{atom(), integer()}]<br>erlang:system_info(Item :: max_heap_size) -&gt;<br>                      {max_heap_size,<br>                       MaxHeapSize :: max_heap_size()}<br>erlang:system_info(Item :: message_queue_data) -&gt;<br>                      <a href="#type-message_queue_data">message_queue_data()</a><br>erlang:system_info(Item :: min_heap_size) -&gt;<br>                      {min_heap_size,<br>                       MinHeapSize :: integer() &gt;= 1}<br>erlang:system_info(Item :: min_bin_vheap_size) -&gt;<br>                      {min_bin_vheap_size,<br>                       MinBinVHeapSize :: integer() &gt;= 1}</h3> <p>Types:</p>    <pre>message_queue_data() = off_heap | on_heap
max_heap_size() = 
    integer() &gt;= 0 |
    #{size =&gt; integer() &gt;= 0,
      kill =&gt; boolean(),
      error_logger =&gt; boolean()}</pre>

<p>Returns information about the default process heap settings:</p> <dl> <dt><strong><code class="code">fullsweep_after</code></strong></dt> <dd> <p>Returns <code class="code">{fullsweep_after, integer() &gt;= 0}</code>, which is the <code class="code">fullsweep_after</code> garbage collection setting used by default. For more information, see <code class="code">garbage_collection</code> described below.</p> </dd> <dt><strong><code class="code">garbage_collection</code></strong></dt> <dd> <p>Returns a list describing the default garbage collection settings. A process spawned on the local node by a <code class="code">spawn</code> or <code class="code">spawn_link</code> uses these garbage collection settings. The default settings can be changed by using <code class="bold_code"><a href="#system_flag-2"><span class="code">erlang:system_flag/2</span></a></code>. <code class="bold_code"><a href="#spawn_opt-4"><span class="code">spawn_opt/2,3,4</span></a></code> can spawn a process that does not use the default settings.</p> </dd> <dt><strong><code class="code">max_heap_size</code></strong></dt> <dd> <p>Returns <code class="code">{max_heap_size, MaxHeapSize}</code>, where <code class="code">MaxHeapSize</code> is the current system-wide maximum heap size settings for spawned processes. This setting can be set using the command-line flags <code class="bold_code"><a href="../erl/#+hmax"><span class="code">+hmax</span></a></code>, <code class="bold_code"><a href="../erl/#+hmaxk"><span class="code">+hmaxk</span></a></code> and <code class="bold_code"><a href="../erl/#+hmaxel"><span class="code">+hmaxel</span></a></code> in <code class="code">erl(1)</code>. It can also be changed at runtime using <code class="bold_code"><a href="#system_flag_max_heap_size"><span class="code">erlang:system_flag(max_heap_size, MaxHeapSize)</span></a></code>. For more details about the <code class="code">max_heap_size</code> process flag, see <code class="bold_code"><a href="#process_flag_max_heap_size"><span class="code">process_flag(max_heap_size, MaxHeapSize)</span></a></code>.</p> </dd> <dt><strong><code class="code">min_heap_size</code></strong></dt> <dd> <p>Returns <code class="code">{min_heap_size, MinHeapSize}</code>, where <code class="code">MinHeapSize</code> is the current system-wide minimum heap size for spawned processes.</p> </dd> <dt><strong id="system_info_message_queue_data"> <code class="code">message_queue_data</code></strong></dt> <dd> <p>Returns the default value of the <code class="code">message_queue_data</code> process flag, which is either <code class="code">off_heap</code> or <code class="code">on_heap</code>. This default is set by command-line argument <code class="bold_code"><a href="../erl/#+hmqd"><span class="code">+hmqd</span></a></code> in <code class="code">erl(1)</code>. For more information on the <code class="code">message_queue_data</code> process flag, see documentation of <code class="bold_code"><a href="#process_flag_message_queue_data"><span class="code">process_flag(message_queue_data, MQD)</span></a></code>.</p> </dd> <dt><strong><code class="code">min_bin_vheap_size</code></strong></dt> <dd> <p>Returns <code class="code">{min_bin_vheap_size, MinBinVHeapSize}</code>, where <code class="code">MinBinVHeapSize</code> is the current system-wide minimum binary virtual heap size for spawned processes.</p> </dd> </dl>  <h3 class="code">erlang:system_info(Item :: build_type) -&gt;<br>                      opt |<br>                      debug |<br>                      purify |<br>                      quantify |<br>                      purecov |<br>                      gcov |<br>                      valgrind |<br>                      gprof |<br>                      lcnt |<br>                      frmptr<br>erlang:system_info(Item :: c_compiler_used) -&gt; {atom(), term()}<br>erlang:system_info(Item :: check_io) -&gt; [term()]<br>erlang:system_info(Item :: compat_rel) -&gt; integer()<br>erlang:system_info(Item :: creation) -&gt; integer()<br>erlang:system_info(Item :: debug_compiled) -&gt; boolean()<br>erlang:system_info(Item :: delayed_node_table_gc) -&gt;<br>                      infinity | integer() &gt;= 0<br>erlang:system_info(Item :: dirty_cpu_schedulers) -&gt;<br>                      integer() &gt;= 0<br>erlang:system_info(Item :: dirty_cpu_schedulers_online) -&gt;<br>                      integer() &gt;= 0<br>erlang:system_info(Item :: dirty_io_schedulers) -&gt;<br>                      integer() &gt;= 0<br>erlang:system_info(Item :: dist) -&gt; binary()<br>erlang:system_info(Item :: dist_buf_busy_limit) -&gt;<br>                      integer() &gt;= 0<br>erlang:system_info(Item :: dist_ctrl) -&gt;<br>                      {Node :: node(),<br>                       ControllingEntity :: port() | pid()}<br>erlang:system_info(Item :: driver_version) -&gt; string()<br>erlang:system_info(Item :: dynamic_trace) -&gt;<br>                      none | dtrace | systemtap<br>erlang:system_info(Item :: dynamic_trace_probes) -&gt; boolean()<br>erlang:system_info(Item :: elib_malloc) -&gt; false<br>erlang:system_info(Item :: eager_check_io) -&gt; boolean()<br>erlang:system_info(Item :: ets_limit) -&gt; integer() &gt;= 1<br>erlang:system_info(Item :: heap_sizes) -&gt; [integer() &gt;= 0]<br>erlang:system_info(Item :: heap_type) -&gt; private<br>erlang:system_info(Item :: info) -&gt; binary()<br>erlang:system_info(Item :: kernel_poll) -&gt; boolean()<br>erlang:system_info(Item :: loaded) -&gt; binary()<br>erlang:system_info(Item ::<br>                       logical_processors |<br>                       logical_processors_available |<br>                       logical_processors_online) -&gt;<br>                      unknown | integer() &gt;= 1<br>erlang:system_info(Item :: machine) -&gt; string()<br>erlang:system_info(Item :: modified_timing_level) -&gt;<br>                      integer() | undefined<br>erlang:system_info(Item :: multi_scheduling) -&gt;<br>                      disabled |<br>                      blocked |<br>                      blocked_normal |<br>                      enabled<br>erlang:system_info(Item :: multi_scheduling_blockers) -&gt;<br>                      [Pid :: pid()]<br>erlang:system_info(Item :: nif_version) -&gt; string()<br>erlang:system_info(Item :: normal_multi_scheduling_blockers) -&gt;<br>                      [Pid :: pid()]<br>erlang:system_info(Item :: otp_release) -&gt; string()<br>erlang:system_info(Item :: os_monotonic_time_source) -&gt;<br>                      [{atom(), term()}]<br>erlang:system_info(Item :: os_system_time_source) -&gt;<br>                      [{atom(), term()}]<br>erlang:system_info(Item :: port_count) -&gt; integer() &gt;= 0<br>erlang:system_info(Item :: port_limit) -&gt; integer() &gt;= 1<br>erlang:system_info(Item :: process_count) -&gt; integer() &gt;= 1<br>erlang:system_info(Item :: process_limit) -&gt; integer() &gt;= 1<br>erlang:system_info(Item :: procs) -&gt; binary()<br>erlang:system_info(Item :: scheduler_bind_type) -&gt;<br>                      spread |<br>                      processor_spread |<br>                      thread_spread |<br>                      thread_no_node_processor_spread |<br>                      no_node_processor_spread |<br>                      no_node_thread_spread |<br>                      no_spread |<br>                      unbound<br>erlang:system_info(Item :: scheduler_bindings) -&gt; tuple()<br>erlang:system_info(Item :: scheduler_id) -&gt;<br>                      SchedulerId :: integer() &gt;= 1<br>erlang:system_info(Item :: schedulers | schedulers_online) -&gt;<br>                      integer() &gt;= 1<br>erlang:system_info(Item :: smp_support) -&gt; boolean()<br>erlang:system_info(Item :: start_time) -&gt; integer()<br>erlang:system_info(Item :: system_version) -&gt; string()<br>erlang:system_info(Item :: system_architecture) -&gt; string()<br>erlang:system_info(Item :: threads) -&gt; boolean()<br>erlang:system_info(Item :: thread_pool_size) -&gt; integer() &gt;= 0<br>erlang:system_info(Item :: time_correction) -&gt; true | false<br>erlang:system_info(Item :: time_offset) -&gt;<br>                      preliminary | final | volatile<br>erlang:system_info(Item :: time_warp_mode) -&gt;<br>                      no_time_warp |<br>                      single_time_warp |<br>                      multi_time_warp<br>erlang:system_info(Item :: tolerant_timeofday) -&gt;<br>                      enabled | disabled<br>erlang:system_info(Item :: trace_control_word) -&gt;<br>                      integer() &gt;= 0<br>erlang:system_info(Item :: update_cpu_info) -&gt; changed | unchanged<br>erlang:system_info(Item :: version) -&gt; string()</h3> 
<p>Returns various information about the current system (emulator) as specified by <code class="code">Item</code>:</p> <dl> <dt><strong><code class="code">allocated_areas</code>, <code class="code">allocator</code>, <code class="code">alloc_util_allocators</code>, <code class="code">allocator_sizes</code></strong></dt> <dd> <p>See <code class="bold_code"><a href="#system_info_allocator_tags">above</a></code>.</p> </dd> <dt><strong><code class="code">build_type</code></strong></dt> <dd> <p>Returns an atom describing the build type of the runtime system. This is normally the atom <code class="code">opt</code> for optimized. Other possible return values are <code class="code">debug</code>, <code class="code">purify</code>, <code class="code">quantify</code>, <code class="code">purecov</code>, <code class="code">gcov</code>, <code class="code">valgrind</code>, <code class="code">gprof</code>, and <code class="code">lcnt</code>. Possible return values can be added or removed at any time without prior notice.</p> </dd> <dt><strong><code class="code">c_compiler_used</code></strong></dt> <dd> <p>Returns a two-tuple describing the C compiler used when compiling the runtime system. The first element is an atom describing the name of the compiler, or <code class="code">undefined</code> if unknown. The second element is a term describing the version of the compiler, or <code class="code">undefined</code> if unknown.</p> </dd> <dt><strong><code class="code">check_io</code></strong></dt> <dd> <p>Returns a list containing miscellaneous information about the emulators internal I/O checking. Notice that the content of the returned list can vary between platforms and over time. It is only guaranteed that a list is returned.</p> </dd> <dt><strong><code class="code">compat_rel</code></strong></dt> <dd> <p>Returns the compatibility mode of the local node as an integer. The integer returned represents the Erlang/OTP release that the current emulator has been set to be backward compatible with. The compatibility mode can be configured at startup by using command-line flag <code class="bold_code"><span class="code">+R</span></code> in <code class="code">erl(1)</code>.</p> </dd> <dt><strong><code class="code">cpu_topology</code></strong></dt> <dd> <p>See <code class="bold_code"><a href="#system_info_cpu_topology_tags">above</a></code>.</p> </dd> <dt><strong><code class="code">creation</code></strong></dt> <dd> <p>Returns the creation of the local node as an integer. The creation is changed when a node is restarted. The creation of a node is stored in process identifiers, port identifiers, and references. This makes it (to some extent) possible to distinguish between identifiers from different incarnations of a node. The valid creations are integers in the range 1..3, but this will probably change in a future release. If the node is not alive, <code class="code">0</code> is returned.</p> </dd> <dt><strong><code class="code">debug_compiled</code></strong></dt> <dd> <p>Returns <code class="code">true</code> if the emulator has been debug-compiled, otherwise <code class="code">false</code>.</p> </dd> <dt><strong><code class="code">delayed_node_table_gc</code></strong></dt> <dd id="system_info_delayed_node_table_gc">  <p>Returns the amount of time in seconds garbage collection of an entry in a node table is delayed. This limit can be set on startup by passing command-line flag <code class="bold_code"><span class="code">+zdntgc</span></code> to <code class="code">erl(1)</code>. For more information, see the documentation of the command-line flag.</p> </dd> <dt><strong><code class="code">dirty_cpu_schedulers</code></strong></dt> <dd id="system_info_dirty_cpu_schedulers">  <p>Returns the number of dirty CPU scheduler threads used by the emulator. Dirty CPU schedulers execute CPU-bound native functions, such as NIFs, linked-in driver code, and BIFs that cannot be managed cleanly by the normal emulator schedulers.</p> <p>The number of dirty CPU scheduler threads is determined at emulator boot time and cannot be changed after that. However, the number of dirty CPU scheduler threads online can be changed at any time. The number of dirty CPU schedulers can be set at startup by passing command-line flag <code class="bold_code"><span class="code">+SDcpu</span></code> or <code class="bold_code"><span class="code">+SDPcpu</span></code> in <code class="code">erl(1)</code>.</p> <p>Notice that the dirty schedulers functionality is experimental. Enable support for dirty schedulers when building OTP to try out the functionality.</p> <p>See also <code class="bold_code"><a href="#system_flag_dirty_cpu_schedulers_online"><span class="code">erlang:system_flag(dirty_cpu_schedulers_online, DirtyCPUSchedulersOnline)</span></a></code>, <code class="bold_code"><a href="#system_info_dirty_cpu_schedulers_online"><span class="code">erlang:system_info(dirty_cpu_schedulers_online)</span></a></code>, <code class="bold_code"><a href="#system_info_dirty_io_schedulers"><span class="code">erlang:system_info(dirty_io_schedulers)</span></a></code>, <code class="bold_code"><a href="#system_info_schedulers"><span class="code">erlang:system_info(schedulers)</span></a></code>, <code class="bold_code"><a href="#system_info_schedulers_online"><span class="code">erlang:system_info(schedulers_online)</span></a></code>, and <code class="bold_code"><a href="#system_flag_schedulers_online"><span class="code">erlang:system_flag(schedulers_online, SchedulersOnline)</span></a></code>.</p> </dd> <dt><strong><code class="code">dirty_cpu_schedulers_online</code></strong></dt> <dd id="system_info_dirty_cpu_schedulers_online">  <p>Returns the number of dirty CPU schedulers online. The return value satisfies <code class="code">1 &lt;= DirtyCPUSchedulersOnline &lt;= N</code>, where <code class="code">N</code> is the smallest of the return values of <code class="code">erlang:system_info(dirty_cpu_schedulers)</code> and <code class="code">erlang:system_info(schedulers_online)</code>.</p> <p>The number of dirty CPU schedulers online can be set at startup by passing command-line flag <code class="bold_code"><span class="code">+SDcpu</span></code> in <code class="code">erl(1)</code>.</p> <p>Notice that the dirty schedulers functionality is experimental. Enable support for dirty schedulers when building OTP to try out the functionality.</p> <p>For more information, see <code class="bold_code"><a href="#system_info_dirty_cpu_schedulers"><span class="code">erlang:system_info(dirty_cpu_schedulers)</span></a></code>, <code class="bold_code"><a href="#system_info_dirty_io_schedulers"><span class="code">erlang:system_info(dirty_io_schedulers)</span></a></code>, <code class="bold_code"><a href="#system_info_schedulers_online"><span class="code">erlang:system_info(schedulers_online)</span></a></code>, and <code class="bold_code"><a href="#system_flag_dirty_cpu_schedulers_online"><span class="code">erlang:system_flag(dirty_cpu_schedulers_online, DirtyCPUSchedulersOnline)</span></a></code>.</p> </dd> <dt><strong><code class="code">dirty_io_schedulers</code></strong></dt> <dd id="system_info_dirty_io_schedulers">  <p>Returns the number of dirty I/O schedulers as an integer. Dirty I/O schedulers execute I/O-bound native functions, such as NIFs and linked-in driver code, which cannot be managed cleanly by the normal emulator schedulers.</p> <p>This value can be set at startup by passing command-line argument <code class="bold_code"><span class="code">+SDio</span></code> in <code class="code">erl(1)</code>.</p> <p>Notice that the dirty schedulers functionality is experimental. Enable support for dirty schedulers when building OTP to try out the functionality.</p> <p>For more information, see <code class="bold_code"><a href="#system_info_dirty_cpu_schedulers"><span class="code">erlang:system_info(dirty_cpu_schedulers)</span></a></code>, <code class="bold_code"><a href="#system_info_dirty_cpu_schedulers_online"><span class="code">erlang:system_info(dirty_cpu_schedulers_online)</span></a></code>, and <code class="bold_code"><a href="#system_flag_dirty_cpu_schedulers_online"><span class="code">erlang:system_flag(dirty_cpu_schedulers_online, DirtyCPUSchedulersOnline)</span></a></code>.</p> </dd> <dt><strong><code class="code">dist</code></strong></dt> <dd> <p>Returns a binary containing a string of distribution information formatted as in Erlang crash dumps. For more information, see section <code class="bold_code">How to interpret the Erlang crash dumps</code> in the User's Guide.</p> </dd> <dt><strong><code class="code">dist_buf_busy_limit</code></strong></dt> <dd id="system_info_dist_buf_busy_limit">  <p>Returns the value of the distribution buffer busy limit in bytes. This limit can be set at startup by passing command-line flag <code class="bold_code"><span class="code">+zdbbl</span></code> to <code class="code">erl(1)</code>.</p> </dd> <dt><strong><code class="code">dist_ctrl</code></strong></dt> <dd> <p>Returns a list of tuples <code class="code">{Node, ControllingEntity}</code>, one entry for each connected remote node. <code class="code">Node</code> is the node name and <code class="code">ControllingEntity</code> is the port or process identifier responsible for the communication to that node. More specifically, <code class="code">ControllingEntity</code> for nodes connected through TCP/IP (the normal case) is the socket used in communication with the specific node.</p> </dd> <dt><strong><code class="code">driver_version</code></strong></dt> <dd> <p>Returns a string containing the Erlang driver version used by the runtime system. It has the form <code class="bold_code">"&lt;major ver&gt;.&lt;minor ver&gt;"</code>.</p> </dd> <dt><strong><code class="code">dynamic_trace</code></strong></dt> <dd> <p>Returns an atom describing the dynamic trace framework compiled into the virtual machine. It can be <code class="code">dtrace</code>, <code class="code">systemtap</code>, or <code class="code">none</code>. For a commercial or standard build, it is always <code class="code">none</code>. The other return values indicate a custom configuration (for example, <code class="code">./configure --with-dynamic-trace=dtrace</code>). For more information about dynamic tracing, see <code class="bold_code"><span class="code">dyntrace(3)</span></code> manual page and the <code class="code">README.dtrace</code>/<code class="code">README.systemtap</code> files in the Erlang source code top directory.</p> </dd> <dt><strong><code class="code">dynamic_trace_probes</code></strong></dt> <dd> <p>Returns a <code class="code">boolean()</code> indicating if dynamic trace probes (<code class="code">dtrace</code> or <code class="code">systemtap</code>) are built into the emulator. This can only be <code class="code">true</code> if the virtual machine was built for dynamic tracing (that is, <code class="code">system_info(dynamic_trace)</code> returns <code class="code">dtrace</code> or <code class="code">systemtap</code>).</p> </dd> <dt><strong id="system_info_end_time"><code class="code">end_time</code></strong></dt> <dd> <p>The last <code class="bold_code"><a href="#monotonic_time-0">Erlang monotonic time</a></code> in <code class="code">native</code> <code class="bold_code"><a href="#type_time_unit">time unit</a></code> that can be represented internally in the current Erlang runtime system instance. The time between the <code class="bold_code"><a href="#system_info_start_time">start time</a></code> and the end time is at least a quarter of a millennium.</p> </dd> <dt><strong><code class="code">elib_malloc</code></strong></dt> <dd> <p>This option will be removed in a future release. The return value will always be <code class="code">false</code>, as the <code class="code">elib_malloc</code> allocator has been removed.</p> </dd> <dt><strong id="system_info_eager_check_io"> <code class="code">eager_check_io</code></strong></dt> <dd> <p>Returns the value of command-line flag <code class="bold_code"><a href="../erl/#+secio"><span class="code">+secio</span></a></code> in <code class="code">erl(1)</code>, which is either <code class="code">true</code> or <code class="code">false</code>. For information about the different values, see the documentation of the command-line flag.</p> </dd> <dt><strong><code class="code">ets_limit</code></strong></dt> <dd> <p>Returns the maximum number of ETS tables allowed. This limit can be increased at startup by passing command-line flag <code class="bold_code"><span class="code">+e</span></code> to <code class="code">erl(1)</code> or by setting environment variable <code class="code">ERL_MAX_ETS_TABLES</code> before starting the Erlang runtime system.</p> </dd> <dt><strong><code class="code">heap_sizes</code></strong></dt> <dd> <p>Returns a list of integers representing valid heap sizes in words. All Erlang heaps are sized from sizes in this list.</p> </dd> <dt><strong><code class="code">heap_type</code></strong></dt> <dd> <p>Returns the heap type used by the current emulator. One heap type exists:</p> <dl> <dt><strong><code class="code">private</code></strong></dt> <dd> Each process has a heap reserved for its use and no references between heaps of different processes are allowed. Messages passed between processes are copied between heaps. </dd> </dl> </dd> <dt><strong><code class="code">info</code></strong></dt> <dd> <p>Returns a binary containing a string of miscellaneous system information formatted as in Erlang crash dumps. For more information, see section <code class="bold_code">How to interpret the Erlang crash dumps</code> in the User's Guide.</p> </dd> <dt><strong><code class="code">kernel_poll</code></strong></dt> <dd> <p>Returns <code class="code">true</code> if the emulator uses some kind of kernel-poll implementation, otherwise <code class="code">false</code>.</p> </dd> <dt><strong><code class="code">loaded</code></strong></dt> <dd> <p>Returns a binary containing a string of loaded module information formatted as in Erlang crash dumps. For more information, see section <code class="bold_code">How to interpret the Erlang crash dumps</code> in the User's Guide.</p> </dd> <dt><strong><code class="code">logical_processors</code></strong></dt> <dd id="logical_processors">  <p>Returns the detected number of logical processors configured in the system. The return value is either an integer, or the atom <code class="code">unknown</code> if the emulator cannot detect the configured logical processors.</p> </dd> <dt><strong><code class="code">logical_processors_available</code></strong></dt> <dd id="logical_processors_available">  <p>Returns the detected number of logical processors available to the Erlang runtime system. The return value is either an integer, or the atom <code class="code">unknown</code> if the emulator cannot detect the available logical processors. The number of available logical processors is less than or equal to the number of <code class="bold_code"><a href="#logical_processors_online">logical processors online</a></code>.</p> </dd> <dt><strong><code class="code">logical_processors_online</code></strong></dt> <dd id="logical_processors_online">  <p>Returns the detected number of logical processors online on the system. The return value is either an integer, or the atom <code class="code">unknown</code> if the emulator cannot detect logical processors online. The number of logical processors online is less than or equal to the number of <code class="bold_code"><a href="#logical_processors">logical processors configured</a></code>.</p> </dd> <dt><strong><code class="code">machine</code></strong></dt> <dd> <p>Returns a string containing the Erlang machine name.</p> </dd> <dt><strong><code class="code">modified_timing_level</code></strong></dt> <dd> <p>Returns the modified timing-level (an integer) if modified timing is enabled, otherwise <code class="code">undefined</code>. For more information about modified timing, see command-line flag <code class="bold_code"><span class="code">+T</span></code> in <code class="code">erl(1)</code></p> </dd> <dt><strong><code class="code">multi_scheduling</code></strong></dt> <dd id="system_info_multi_scheduling">  <p>Returns one of the following:</p> <dl> <dt><strong><code class="code">disabled</code></strong></dt> <dd> <p>The emulator has only one scheduler thread. The emulator does not have SMP support, or have been started with only one scheduler thread.</p> </dd> <dt><strong><code class="code">blocked</code></strong></dt> <dd> <p>The emulator has more than one scheduler thread, but all scheduler threads except one are blocked. That is, only one scheduler thread schedules Erlang processes and executes Erlang code.</p> </dd> <dt><strong><code class="code">blocked_normal</code></strong></dt> <dd> <p>The emulator has more than one scheduler thread, but all normal scheduler threads except one are blocked. Notice that dirty schedulers are not blocked, and can schedule Erlang processes and execute native code.</p> </dd> <dt><strong><code class="code">enabled</code></strong></dt> <dd> <p>The emulator has more than one scheduler thread, and no scheduler threads are blocked. That is, all available scheduler threads schedule Erlang processes and execute Erlang code.</p> </dd> </dl> <p>See also <code class="bold_code"><a href="#system_flag_multi_scheduling"><span class="code">erlang:system_flag(multi_scheduling, BlockState)</span></a></code>, <code class="bold_code"><a href="#system_info_multi_scheduling_blockers"><span class="code">erlang:system_info(multi_scheduling_blockers)</span></a></code>, <code class="bold_code"><a href="#system_info_normal_multi_scheduling_blockers"><span class="code">erlang:system_info(normal_multi_scheduling_blockers)</span></a></code>, and <code class="bold_code"><a href="#system_info_schedulers"><span class="code">erlang:system_info(schedulers)</span></a></code>.</p> </dd> <dt><strong><code class="code">multi_scheduling_blockers</code></strong></dt> <dd id="system_info_multi_scheduling_blockers">  <p>Returns a list of <code class="code">Pid</code>s when multi-scheduling is blocked, otherwise the empty list is returned. The <code class="code">Pid</code>s in the list represent all the processes currently blocking multi-scheduling. A <code class="code">Pid</code> occurs only once in the list, even if the corresponding process has blocked multiple times.</p> <p>See also <code class="bold_code"><a href="#system_flag_multi_scheduling"><span class="code">erlang:system_flag(multi_scheduling, BlockState)</span></a></code>, <code class="bold_code"><a href="#system_info_multi_scheduling"><span class="code">erlang:system_info(multi_scheduling)</span></a></code>, <code class="bold_code"><a href="#system_info_normal_multi_scheduling_blockers"><span class="code">erlang:system_info(normal_multi_scheduling_blockers)</span></a></code>, and <code class="bold_code"><a href="#system_info_schedulers"><span class="code">erlang:system_info(schedulers)</span></a></code>.</p> </dd> <dt><strong><code class="code">nif_version</code></strong></dt> <dd> <p>Returns a string containing the version of the Erlang NIF interface used by the runtime system. It is on the form "&lt;major ver&gt;.&lt;minor ver&gt;".</p> </dd> <dt><strong><code class="code">normal_multi_scheduling_blockers</code></strong></dt> <dd id="system_info_normal_multi_scheduling_blockers">  <p>Returns a list of <code class="code">Pid</code>s when normal multi-scheduling is blocked (that is, all normal schedulers but one is blocked), otherwise the empty list is returned. The <code class="code">Pid</code>s in the list represent all the processes currently blocking normal multi-scheduling. A <code class="code">Pid</code> occurs only once in the list, even if the corresponding process has blocked multiple times.</p> <p>See also <code class="bold_code"><a href="#system_flag_multi_scheduling"><span class="code">erlang:system_flag(multi_scheduling, BlockState)</span></a></code>, <code class="bold_code"><a href="#system_info_multi_scheduling"><span class="code">erlang:system_info(multi_scheduling)</span></a></code>, <code class="bold_code"><a href="#system_info_multi_scheduling_blockers"><span class="code">erlang:system_info(multi_scheduling_blockers)</span></a></code>, and <code class="bold_code"><a href="#system_info_schedulers"><span class="code">erlang:system_info(schedulers)</span></a></code>.</p> </dd> <dt><strong id="system_info_otp_release"> <code class="code">otp_release</code></strong></dt> <dd id="system_info_otp_release">  <p>Returns a string containing the OTP release number of the OTP release that the currently executing ERTS application is part of.</p> <p>As from Erlang/OTP 17, the OTP release number corresponds to the major OTP version number. No <code class="code">erlang:system_info()</code> argument gives the exact OTP version. This is because the exact OTP version in the general case is difficult to determine. For more information, see the description of versions in <code class="bold_code">System principles</code> in System Documentation.</p> </dd> <dt><strong id="system_info_os_monotonic_time_source"> <code class="code">os_monotonic_time_source</code></strong></dt> <dd> <p>Returns a list containing information about the source of <code class="bold_code">OS monotonic time</code> that is used by the runtime system.</p> <p>If <code class="code">[]</code> is returned, no OS monotonic time is available. The list contains two-tuples with <code class="code">Key</code>s as first element, and <code class="code">Value</code>s as second element. The order of these tuples is undefined. The following tuples can be part of the list, but more tuples can be introduced in the future:</p> <dl> <dt><strong><code class="code">{function, Function}</code></strong></dt> <dd> <p><code class="code">Function</code> is the name of the function used. This tuple always exists if OS monotonic time is available to the runtime system.</p> </dd> <dt><strong><code class="code">{clock_id, ClockId}</code></strong></dt> <dd> <p>This tuple only exists if <code class="code">Function</code> can be used with different clocks. <code class="code">ClockId</code> corresponds to the clock identifier used when calling <code class="code">Function</code>.</p> </dd> <dt><strong><code class="code">{resolution, OsMonotonicTimeResolution}</code></strong></dt> <dd> <p>Highest possible <code class="bold_code"><a href="../time_correction/#Time_Resolution">resolution</a></code> of current OS monotonic time source as parts per second. If no resolution information can be retrieved from the OS, <code class="code">OsMonotonicTimeResolution</code> is set to the resolution of the time unit of <code class="code">Function</code>s return value. That is, the actual resolution can be lower than <code class="code">OsMonotonicTimeResolution</code>. Notice that the resolution does not say anything about the <code class="bold_code"><a href="../time_correction/#Time_Accuracy">accuracy</a></code> or whether the <code class="bold_code"><a href="../time_correction/#Time_Precision">precision</a></code> aligns with the resolution. You do, however, know that the precision is not better than <code class="code">OsMonotonicTimeResolution</code>.</p> </dd> <dt><strong><code class="code">{extended, Extended}</code></strong></dt> <dd> <p><code class="code">Extended</code> equals <code class="code">yes</code> if the range of time values has been extended; otherwise <code class="code">Extended</code> equals <code class="code">no</code>. The range must be extended if <code class="code">Function</code> returns values that wrap fast. This typically is the case when the return value is a 32-bit value.</p> </dd> <dt><strong><code class="code">{parallel, Parallel}</code></strong></dt> <dd> <p><code class="code">Parallel</code> equals <code class="code">yes</code> if <code class="code">Function</code> is called in parallel from multiple threads. If it is not called in parallel, because calls must be serialized, <code class="code">Parallel</code> equals <code class="code">no</code>.</p> </dd> <dt><strong><code class="code">{time, OsMonotonicTime}</code></strong></dt> <dd> <p><code class="code">OsMonotonicTime</code> equals current OS monotonic time in <code class="code">native</code> <code class="bold_code"><a href="#type_time_unit">time unit</a></code>.</p> </dd> </dl> </dd> <dt><strong id="system_info_os_system_time_source"> <code class="code">os_system_time_source</code></strong></dt> <dd> <p>Returns a list containing information about the source of <code class="bold_code">OS system time</code> that is used by the runtime system.</p> <p>The list contains two-tuples with <code class="code">Key</code>s as first element, and <code class="code">Value</code>s as second element. The order if these tuples is undefined. The following tuples can be part of the list, but more tuples can be introduced in the future:</p> <dl> <dt><strong><code class="code">{function, Function}</code></strong></dt> <dd> <p><code class="code">Function</code> is the name of the funcion used.</p> </dd> <dt><strong><code class="code">{clock_id, ClockId}</code></strong></dt> <dd> <p>Exists only if <code class="code">Function</code> can be used with different clocks. <code class="code">ClockId</code> corresponds to the clock identifier used when calling <code class="code">Function</code>.</p> </dd> <dt><strong><code class="code">{resolution, OsSystemTimeResolution}</code></strong></dt> <dd> <p>Highest possible <code class="bold_code"><a href="../time_correction/#Time_Resolution">resolution</a></code> of current OS system time source as parts per second. If no resolution information can be retrieved from the OS, <code class="code">OsSystemTimeResolution</code> is set to the resolution of the time unit of <code class="code">Function</code>s return value. That is, the actual resolution can be lower than <code class="code">OsSystemTimeResolution</code>. Notice that the resolution does not say anything about the <code class="bold_code"><a href="../time_correction/#Time_Accuracy">accuracy</a></code> or whether the <code class="bold_code"><a href="../time_correction/#Time_Precision">precision</a></code> do align with the resolution. You do, however, know that the precision is not better than <code class="code">OsSystemTimeResolution</code>.</p> </dd> <dt><strong><code class="code">{parallel, Parallel}</code></strong></dt> <dd> <p><code class="code">Parallel</code> equals <code class="code">yes</code> if <code class="code">Function</code> is called in parallel from multiple threads. If it is not called in parallel, because calls needs to be serialized, <code class="code">Parallel</code> equals <code class="code">no</code>.</p> </dd> <dt><strong><code class="code">{time, OsSystemTime}</code></strong></dt> <dd> <p><code class="code">OsSystemTime</code> equals current OS system time in <code class="code">native</code> <code class="bold_code"><a href="#type_time_unit">time unit</a></code>.</p> </dd> </dl> </dd> <dt><strong><code class="code">port_parallelism</code></strong></dt> <dd id="system_info_port_parallelism">  <p>Returns the default port parallelism scheduling hint used. For more information, see command-line argument <code class="bold_code"><a href="../erl/#+spp"><span class="code">+spp</span></a></code> in <code class="code">erl(1)</code>.</p> </dd> <dt><strong id="system_info_port_count"><code class="code">port_count</code></strong></dt> <dd> <p>Returns the number of ports currently existing at the local node. The value is given as an integer. This is the same value as returned by <code class="code">length(erlang:ports())</code>, but more efficient.</p> </dd> <dt><strong><code class="code">port_limit</code></strong></dt> <dd id="system_info_port_limit">  <p>Returns the maximum number of simultaneously existing ports at the local node as an integer. This limit can be configured at startup by using command-line flag <code class="bold_code"><a href="../erl/#+Q"><span class="code">+Q</span></a></code> in <code class="code">erl(1)</code>.</p> </dd> <dt><strong id="system_info_process_count"> <code class="code">process_count</code></strong></dt> <dd> <p>Returns the number of processes currently existing at the local node. The value is given as an integer. This is the same value as returned by <code class="code">length(processes())</code>, but more efficient.</p> </dd> <dt><strong><code class="code">process_limit</code></strong></dt> <dd id="system_info_process_limit">  <p>Returns the maximum number of simultaneously existing processes at the local node. The value is given as an integer. This limit can be configured at startup by using command-line flag <code class="bold_code"><a href="../erl/#+P"><span class="code">+P</span></a></code> in <code class="code">erl(1)</code>.</p> </dd> <dt><strong><code class="code">procs</code></strong></dt> <dd> <p>Returns a binary containing a string of process and port information formatted as in Erlang crash dumps. For more information, see section <code class="bold_code">How to interpret the Erlang crash dumps</code> in the User's Guide.</p> </dd> <dt><strong><code class="code">scheduler_bind_type</code></strong></dt> <dd id="system_info_scheduler_bind_type">  <p>Returns information about how the user has requested schedulers to be bound or not bound.</p> <p>Notice that although a user has requested schedulers to be bound, they can silently have failed to bind. To inspect the scheduler bindings, call <code class="bold_code"><a href="#system_info_scheduler_bindings"><span class="code">erlang:system_info(scheduler_bindings)</span></a></code>.</p> <p>For more information, see command-line argument <code class="bold_code"><span class="code">+sbt</span></code> in <code class="code">erl(1)</code> and <code class="bold_code"><a href="#system_info_scheduler_bindings"><span class="code">erlang:system_info(scheduler_bindings)</span></a></code>.</p> </dd> <dt><strong><code class="code">scheduler_bindings</code></strong></dt> <dd id="system_info_scheduler_bindings">  <p>Returns information about the currently used scheduler bindings.</p> <p>A tuple of a size equal to <code class="bold_code"><a href="#system_info_schedulers"><span class="code">erlang:system_info(schedulers)</span></a></code> is returned. The tuple elements are integers or the atom <code class="code">unbound</code>. Logical processor identifiers are represented as integers. The <code class="code">N</code>th element of the tuple equals the current binding for the scheduler with the scheduler identifier equal to <code class="code">N</code>. For example, if the schedulers are bound, <code class="code">element(erlang:system_info(scheduler_id), erlang:system_info(scheduler_bindings))</code> returns the identifier of the logical processor that the calling process is executing on.</p> <p>Notice that only schedulers online can be bound to logical processors.</p> <p>For more information, see command-line argument <code class="bold_code"><span class="code">+sbt</span></code> in <code class="code">erl(1)</code> and <code class="bold_code"><a href="#system_info_schedulers_online"><span class="code">erlang:system_info(schedulers_online)</span></a></code>.</p> </dd> <dt><strong><code class="code">scheduler_id</code></strong></dt> <dd id="system_info_scheduler_id">  <p>Returns the scheduler ID (<code class="code">SchedulerId</code>) of the scheduler thread that the calling process is executing on. <code class="code">SchedulerId</code> is a positive integer, where <code class="code">1 &lt;= SchedulerId &lt;= erlang:system_info(schedulers)</code>.</p> <p>See also <code class="bold_code"><a href="#system_info_schedulers"><span class="code">erlang:system_info(schedulers)</span></a></code>.</p> </dd> <dt><strong><code class="code">schedulers</code></strong></dt> <dd id="system_info_schedulers">  <p>Returns the number of scheduler threads used by the emulator. Scheduler threads online schedules Erlang processes and Erlang ports, and execute Erlang code and Erlang linked-in driver code.</p> <p>The number of scheduler threads is determined at emulator boot time and cannot be changed later. However, the number of schedulers online can be changed at any time.</p> <p>See also <code class="bold_code"><a href="#system_flag_schedulers_online"><span class="code">erlang:system_flag(schedulers_online, SchedulersOnline)</span></a></code>, <code class="bold_code"><a href="#system_info_schedulers_online"><span class="code">erlang:system_info(schedulers_online)</span></a></code>, <code class="bold_code"><a href="#system_info_scheduler_id"><span class="code">erlang:system_info(scheduler_id)</span></a></code>, <code class="bold_code"><a href="#system_flag_multi_scheduling"><span class="code">erlang:system_flag(multi_scheduling, BlockState)</span></a></code>, <code class="bold_code"><a href="#system_info_multi_scheduling"><span class="code">erlang:system_info(multi_scheduling)</span></a></code>, <code class="bold_code"><a href="#system_info_normal_multi_scheduling_blockers"><span class="code">erlang:system_info(normal_multi_scheduling_blockers)</span></a></code> and <code class="bold_code"><a href="#system_info_multi_scheduling_blockers"><span class="code">erlang:system_info(multi_scheduling_blockers)</span></a></code>. </p> </dd> <dt><strong><code class="code">schedulers_online</code></strong></dt> <dd id="system_info_schedulers_online">  <p>Returns the number of schedulers online. The scheduler identifiers of schedulers online satisfy the relationship <code class="code">1 &lt;= SchedulerId &lt;= erlang:system_info(schedulers_online)</code>.</p> <p>For more information, see <code class="bold_code"><a href="#system_info_schedulers"><span class="code">erlang:system_info(schedulers)</span></a></code> and <code class="bold_code"><a href="#system_flag_schedulers_online"><span class="code">erlang:system_flag(schedulers_online, SchedulersOnline)</span></a></code>.</p> </dd> <dt><strong><code class="code">smp_support</code></strong></dt> <dd> <p>Returns <code class="code">true</code> if the emulator has been compiled with SMP support, otherwise <code class="code">false</code> is returned.</p> </dd> <dt><strong id="system_info_start_time"><code class="code">start_time</code></strong></dt> <dd> <p>The <code class="bold_code"><a href="#monotonic_time-0">Erlang monotonic time</a></code> in <code class="code">native</code> <code class="bold_code"><a href="#type_time_unit">time unit</a></code> at the time when current Erlang runtime system instance started.</p> <p>See also <code class="bold_code"><a href="#system_info_end_time"><span class="code">erlang:system_info(end_time)</span></a></code>.</p> </dd> <dt><strong><code class="code">system_version</code></strong></dt> <dd> <p>Returns a string containing version number and some important properties, such as the number of schedulers.</p> </dd> <dt><strong><code class="code">system_architecture</code></strong></dt> <dd> <p>Returns a string containing the processor and OS architecture the emulator is built for.</p> </dd> <dt><strong><code class="code">threads</code></strong></dt> <dd> <p>Returns <code class="code">true</code> if the emulator has been compiled with thread support, otherwise <code class="code">false</code> is returned.</p> </dd> <dt><strong><code class="code">thread_pool_size</code></strong></dt> <dd id="system_info_thread_pool_size">  <p>Returns the number of async threads in the async thread pool used for asynchronous driver calls (<code class="bold_code"><span class="code">erl_driver:driver_async()</span></code>). The value is given as an integer.</p> </dd> <dt><strong><code class="code">time_correction</code></strong></dt> <dd id="system_info_time_correction">  <p>Returns a boolean value indicating whether <code class="bold_code"><a href="../time_correction/#Time_Correction">time correction</a></code> is enabled or not.</p> </dd> <dt><strong><code class="code">time_offset</code></strong></dt> <dd id="system_info_time_offset">  <p>Returns the state of the time offset:</p> <dl> <dt><strong><code class="code">preliminary</code></strong></dt> <dd> <p>The time offset is preliminary, and will be changed and finalized later. The preliminary time offset is used during the preliminary phase of the <code class="bold_code"><a href="../time_correction/#Single_Time_Warp_Mode">single time warp mode</a></code>.</p> </dd> <dt><strong><code class="code">final</code></strong></dt> <dd> <p>The time offset is final. This either because <code class="bold_code"><a href="../time_correction/#No_Time_Warp_Mode">no time warp mode</a></code> is used, or because the time offset have been finalized when <code class="bold_code"><a href="../time_correction/#Single_Time_Warp_Mode">single time warp mode</a></code> is used.</p> </dd> <dt><strong><code class="code">volatile</code></strong></dt> <dd> <p>The time offset is volatile. That is, it can change at any time. This is because <code class="bold_code"><a href="../time_correction/#Multi_Time_Warp_Mode">multi-time warp mode</a></code> is used.</p> </dd> </dl> </dd> <dt><strong id="system_info_time_warp_mode"> <code class="code">time_warp_mode</code></strong></dt> <dd> <p>Returns a value identifying the <code class="bold_code"><a href="../time_correction/#Time_Warp_Modes">time warp mode</a></code> that is used:</p> <dl> <dt><strong><code class="code">no_time_warp</code></strong></dt> <dd>The <code class="bold_code"><a href="../time_correction/#No_Time_Warp_Mode">no time warp mode</a></code> is used. </dd> <dt><strong><code class="code">single_time_warp</code></strong></dt> <dd>The <code class="bold_code"><a href="../time_correction/#Single_Time_Warp_Mode">single time warp mode</a></code> is used. </dd> <dt><strong><code class="code">multi_time_warp</code></strong></dt> <dd>The <code class="bold_code"><a href="../time_correction/#Multi_Time_Warp_Mode">multi-time warp mode</a></code> is used. </dd> </dl> </dd> <dt><strong><code class="code">tolerant_timeofday</code></strong></dt> <dd id="system_info_tolerant_timeofday">  <p>Returns whether a pre ERTS 7.0 backwards compatible compensation for sudden changes of system time is <code class="code">enabled</code> or <code class="code">disabled</code>. Such compensation is <code class="code">enabled</code> when the <code class="bold_code"><a href="#system_info_time_offset">time offset</a></code> is <code class="code">final</code>, and <code class="bold_code"><a href="#system_info_time_correction">time correction</a></code> is enabled.</p> </dd> <dt><strong><code class="code">trace_control_word</code></strong></dt> <dd> <p>Returns the value of the node trace control word. For more information, see function <code class="code">get_tcw</code> in section <code class="bold_code">Match Specifications in Erlang</code> in the User's Guide.</p> </dd> <dt><strong><code class="code">update_cpu_info</code></strong></dt> <dd id="update_cpu_info">  <p>The runtime system rereads the CPU information available and updates its internally stored information about the <code class="bold_code"><a href="#system_info_cpu_topology_detected">detected CPU topology</a></code> and the number of logical processors <code class="bold_code"><a href="#logical_processors">configured</a></code>, <code class="bold_code"><a href="#logical_processors_online">online</a></code>, and <code class="bold_code"><a href="#logical_processors_available">available</a></code>.</p> <p>If the CPU information has changed since the last time it was read, the atom <code class="code">changed</code> is returned, otherwise the atom <code class="code">unchanged</code>. If the CPU information has changed, you probably want to <code class="bold_code"><a href="#system_flag_schedulers_online">adjust the number of schedulers online</a></code>. You typically want to have as many schedulers online as <code class="bold_code"><a href="#logical_processors_available">logical processors available</a></code>.</p> </dd> <dt><strong><code class="code">version</code></strong></dt> <dd id="system_info_version">  <p>Returns a string containing the version number of the emulator.</p> </dd> <dt><strong><code class="code">wordsize</code></strong></dt> <dd> <p>Same as <code class="code">{wordsize, internal}</code>.</p> </dd> <dt><strong><code class="code">{wordsize, internal}</code></strong></dt> <dd> <p>Returns the size of Erlang term words in bytes as an integer, that is, 4 is returned on a 32-bit architecture, and 8 is returned on a pure 64-bit architecture. On a halfword 64-bit emulator, 4 is returned, as the Erlang terms are stored using a virtual word size of half the system word size.</p> </dd> <dt><strong><code class="code">{wordsize, external}</code></strong></dt> <dd> <p>Returns the true word size of the emulator, that is, the size of a pointer. The value is given in bytes as an integer. On a pure 32-bit architecture, 4 is returned. On both a half word and on a pure 64-bit architecture, 8 is returned.</p> </dd> </dl> <div class="note"> <div class="label">Note</div> <div class="content">

<p>Argument <code class="code">scheduler</code> has changed name to <code class="code">scheduler_id</code> to avoid mix up with argument <code class="code">schedulers</code>. Argument <code class="code">scheduler</code> was introduced in ERTS 5.5 and renamed in ERTS 5.5.1.</p> </div> </div>  <h3 id="system_monitor-0" class="code">erlang:system_monitor() -&gt; MonSettings</h3> <p>Types:</p>      <pre>MonSettings = undefined | {MonitorPid, Options}
MonitorPid = pid()
Options = [system_monitor_option()]
system_monitor_option() = 
    busy_port |
    busy_dist_port |
    {long_gc, integer() &gt;= 0} |
    {long_schedule, integer() &gt;= 0} |
    {large_heap, integer() &gt;= 0}</pre>

<p>Returns the current system monitoring settings set by <code class="bold_code"><a href="#system_monitor-2"><span class="code">erlang:system_monitor/2</span></a></code> as <code class="code">{MonitorPid, Options}</code>, or <code class="code">undefined</code> if no settings exist. The order of the options can be different from the one that was set.</p>  <h3 id="system_monitor-1" class="code">erlang:system_monitor(Arg) -&gt; MonSettings</h3> <p>Types:</p>       <pre>Arg = MonSettings = undefined | {MonitorPid, Options}

MonitorPid = pid()
Options = [system_monitor_option()]
system_monitor_option() = 
    busy_port |
    busy_dist_port |
    {long_gc, integer() &gt;= 0} |
    {long_schedule, integer() &gt;= 0} |
    {large_heap, integer() &gt;= 0}</pre>

<p>When called with argument <code class="code">undefined</code>, all system performance monitoring settings are cleared.</p> <p>Calling the function with <code class="code">{MonitorPid, Options}</code> as argument is the same as calling <code class="bold_code"><a href="#system_monitor-2"><span class="code">erlang:system_monitor(MonitorPid,Options)</span></a></code>.</p> <p>Returns the previous system monitor settings just like <code class="bold_code"><a href="#system_monitor-0"><span class="code">erlang:system_monitor/0</span></a></code>.</p>  <h3 id="system_monitor-2" class="code">erlang:system_monitor(MonitorPid, Options) -&gt; MonSettings</h3> <p>Types:</p>        <pre>MonitorPid = pid()
Options = [system_monitor_option()]
MonSettings = undefined | {OldMonitorPid, OldOptions}
OldMonitorPid = pid()
OldOptions = [system_monitor_option()]
system_monitor_option() = 
    busy_port |
    busy_dist_port |
    {long_gc, integer() &gt;= 0} |
    {long_schedule, integer() &gt;= 0} |
    {large_heap, integer() &gt;= 0}</pre>

<p>Sets the system performance monitoring options. <code class="code">MonitorPid</code> is a local process identifier (pid) receiving system monitor messages. The second argument is a list of monitoring options:</p> <dl> <dt><strong><code class="code">{long_gc, Time}</code></strong></dt> <dd> <p>If a garbage collection in the system takes at least <code class="code">Time</code> wall clock milliseconds, a message <code class="code">{monitor, GcPid, long_gc, Info}</code> is sent to <code class="code">MonitorPid</code>. <code class="code">GcPid</code> is the pid that was garbage collected. <code class="code">Info</code> is a list of two-element tuples describing the result of the garbage collection.</p> <p>One of the tuples is <code class="code">{timeout, GcTime}</code>, where <code class="code">GcTime</code> is the time for the garbage collection in milliseconds. The other tuples are tagged with <code class="code">heap_size</code>, <code class="code">heap_block_size</code>, <code class="code">stack_size</code>, <code class="code">mbuf_size</code>, <code class="code">old_heap_size</code>, and <code class="code">old_heap_block_size</code>. These tuples are explained in the description of trace message <code class="bold_code"><a href="#gc_minor_start"><span class="code">gc_minor_start</span></a></code> (see <code class="bold_code"><a href="#trace-3"><span class="code">erlang:trace/3</span></a></code>). New tuples can be added, and the order of the tuples in the <code class="code">Info</code> list can be changed at any time without prior notice.</p> </dd> <dt><strong><code class="code">{long_schedule, Time}</code></strong></dt> <dd> <p>If a process or port in the system runs uninterrupted for at least <code class="code">Time</code> wall clock milliseconds, a message <code class="code">{monitor, PidOrPort, long_schedule, Info}</code> is sent to <code class="code">MonitorPid</code>. <code class="code">PidOrPort</code> is the process or port that was running. <code class="code">Info</code> is a list of two-element tuples describing the event.</p> <p>If a <code class="code">pid()</code>, the tuples <code class="code">{timeout, Millis}</code>, <code class="code">{in, Location}</code>, and <code class="code">{out, Location}</code> are present, where <code class="code">Location</code> is either an MFA (<code class="code">{Module, Function, Arity}</code>) describing the function where the process was scheduled in/out, or the atom <code class="code">undefined</code>.</p> <p>If a <code class="code">port()</code>, the tuples <code class="code">{timeout, Millis}</code> and <code class="code">{port_op,Op}</code> are present. <code class="code">Op</code> is one of <code class="code">proc_sig</code>, <code class="code">timeout</code>, <code class="code">input</code>, <code class="code">output</code>, <code class="code">event</code>, or <code class="code">dist_cmd</code>, depending on which driver callback was executing.</p> <p><code class="code">proc_sig</code> is an internal operation and is never to appear, while the others represent the corresponding driver callbacks <code class="code">timeout</code>, <code class="code">ready_input</code>, <code class="code">ready_output</code>, <code class="code">event</code>, and <code class="code">outputv</code> (when the port is used by distribution). Value <code class="code">Millis</code> in tuple <code class="code">timeout</code> informs about the uninterrupted execution time of the process or port, which always is equal to or higher than the <code class="code">Time</code> value supplied when starting the trace. New tuples can be added to the <code class="code">Info</code> list in a future release. The order of the tuples in the list can be changed at any time without prior notice.</p> <p>This can be used to detect problems with NIFs or drivers that take too long to execute. 1 ms is considered a good maximum time for a driver callback or a NIF. However, a time-sharing system is usually to consider everything &lt; 100 ms as "possible" and fairly "normal". However, longer schedule times can indicate swapping or a misbehaving NIF/driver. Misbehaving NIFs and drivers can cause bad resource utilization and bad overall system performance.</p> </dd> <dt><strong><code class="code">{large_heap, Size}</code></strong></dt> <dd> <p>If a garbage collection in the system results in the allocated size of a heap being at least <code class="code">Size</code> words, a message <code class="code">{monitor, GcPid, large_heap, Info}</code> is sent to <code class="code">MonitorPid</code>. <code class="code">GcPid</code> and <code class="code">Info</code> are the same as for <code class="code">long_gc</code> earlier, except that the tuple tagged with <code class="code">timeout</code> is not present.</p> <p>The monitor message is sent if the sum of the sizes of all memory blocks allocated for all heap generations after a garbage collection is equal to or higher than <code class="code">Size</code>.</p> <p>When a process is killed by <code class="bold_code"><a href="#process_flag_max_heap_size"><span class="code">max_heap_size</span></a></code>, it is killed before the garbage collection is complete and thus no large heap message is sent.</p> </dd> <dt><strong><code class="code">busy_port</code></strong></dt> <dd> <p>If a process in the system gets suspended because it sends to a busy port, a message <code class="code">{monitor, SusPid, busy_port, Port}</code> is sent to <code class="code">MonitorPid</code>. <code class="code">SusPid</code> is the pid that got suspended when sending to <code class="code">Port</code>.</p> </dd> <dt><strong><code class="code">busy_dist_port</code></strong></dt> <dd> <p>If a process in the system gets suspended because it sends to a process on a remote node whose inter-node communication was handled by a busy port, a message <code class="code">{monitor, SusPid, busy_dist_port, Port}</code> is sent to <code class="code">MonitorPid</code>. <code class="code">SusPid</code> is the pid that got suspended when sending through the inter-node communication port <code class="code">Port</code>.</p> </dd> </dl> <p>Returns the previous system monitor settings just like <code class="bold_code"><a href="#system_monitor-0"><span class="code">erlang:system_monitor/0</span></a></code>.</p> <div class="note"> <div class="label">Note</div> <div class="content">

<p>If a monitoring process gets so large that it itself starts to cause system monitor messages when garbage collecting, the messages enlarge the process message queue and probably make the problem worse.</p> <p>Keep the monitoring process neat and do not set the system monitor limits too tight.</p> </div> </div> <p>Failures:</p> <dl> <dt><strong><code class="code">badarg</code></strong></dt> <dd>If <code class="code">MonitorPid</code> does not exist.</dd> <dt><strong><code class="code">badarg</code></strong></dt> <dd>If <code class="code">MonitorPid</code> is not a local process.</dd> </dl>  <h3 id="system_profile-0" class="code">erlang:system_profile() -&gt; ProfilerSettings</h3> <p>Types:</p>      <pre>ProfilerSettings = undefined | {ProfilerPid, Options}
ProfilerPid = pid() | port()
Options = [system_profile_option()]
system_profile_option() = 
    exclusive |
    runnable_ports |
    runnable_procs |
    scheduler |
    timestamp |
    monotonic_timestamp |
    strict_monotonic_timestamp</pre>

<p>Returns the current system profiling settings set by <code class="bold_code"><a href="#system_profile-2"><span class="code">erlang:system_profile/2</span></a></code> as <code class="code">{ProfilerPid, Options}</code>, or <code class="code">undefined</code> if there are no settings. The order of the options can be different from the one that was set.</p>  <h3 id="system_profile-2" class="code">erlang:system_profile(ProfilerPid, Options) -&gt; ProfilerSettings</h3> <p>Types:</p>      <pre>ProfilerPid = pid() | port() | undefined
Options = [system_profile_option()]
ProfilerSettings = 
    undefined | {pid() | port(), [system_profile_option()]}
system_profile_option() = 
    exclusive |
    runnable_ports |
    runnable_procs |
    scheduler |
    timestamp |
    monotonic_timestamp |
    strict_monotonic_timestamp</pre>

<p>Sets system profiler options. <code class="code">ProfilerPid</code> is a local process identifier (pid) or port receiving profiling messages. The receiver is excluded from all profiling. The second argument is a list of profiling options:</p> <dl> <dt><strong><code class="code">exclusive</code></strong></dt> <dd> <p>If a synchronous call to a port from a process is done, the calling process is considered not runnable during the call runtime to the port. The calling process is notified as <code class="code">inactive</code>, and later <code class="code">active</code> when the port callback returns.</p> </dd> <dt><strong><code class="code">monotonic_timestamp</code></strong></dt> <dd> <p>Time stamps in profile messages use <code class="bold_code"><a href="../time_correction/#Erlang_Monotonic_Time">Erlang monotonic time</a></code>. The time stamp (Ts) has the same format and value as produced by <code class="code">erlang:monotonic_time(nanosecond)</code>.</p> </dd> <dt><strong><code class="code">runnable_procs</code></strong></dt> <dd> <p>If a process is put into or removed from the run queue, a message, <code class="code">{profile, Pid, State, Mfa, Ts}</code>, is sent to <code class="code">ProfilerPid</code>. Running processes that are reinserted into the run queue after having been pre-empted do not trigger this message.</p> </dd> <dt><strong><code class="code">runnable_ports</code></strong></dt> <dd> <p>If a port is put into or removed from the run queue, a message, <code class="code">{profile, Port, State, 0, Ts}</code>, is sent to <code class="code">ProfilerPid</code>.</p> </dd> <dt><strong><code class="code">scheduler</code></strong></dt> <dd> <p>If a scheduler is put to sleep or awoken, a message, <code class="code">{profile, scheduler, Id, State, NoScheds, Ts}</code>, is sent to <code class="code">ProfilerPid</code>.</p> </dd> <dt><strong><code class="code">strict_monotonic_timestamp</code></strong></dt> <dd> <p>Time stamps in profile messages consist of <code class="bold_code"><a href="../time_correction/#Erlang_Monotonic_Time">Erlang monotonic time</a></code> and a monotonically increasing integer. The time stamp (Ts) has the same format and value as produced by <code class="code">{erlang:monotonic_time(nanosecond), erlang:unique_integer([monotonic])}</code>.</p> </dd> <dt><strong><code class="code">timestamp</code></strong></dt> <dd> <p>Time stamps in profile messages include a time stamp (Ts) that has the same form as returned by <code class="code">erlang:now()</code>. This is also the default if no time stamp flag is specified. If <code class="code">cpu_timestamp</code> has been enabled through <code class="bold_code"><span class="code">erlang:trace/3</span></code>, this also effects the time stamp produced in profiling messages when flag <code class="code">timestamp</code> is enabled.</p> </dd> </dl> <div class="note"> <div class="label">Note</div> <div class="content">

<p><code class="code">erlang:system_profile</code> behavior can change in a future release.</p> </div> </div>  <h3 id="system_time-0" class="code">erlang:system_time() -&gt; integer()</h3> 
<p>Returns current <code class="bold_code"><a href="../time_correction/#Erlang_System_Time">Erlang system time</a></code> in <code class="code">native</code> <code class="bold_code"><a href="#type_time_unit">time unit</a></code>.</p> <p>Calling <code class="code">erlang:system_time()</code> is equivalent to <code class="bold_code"><a href="#monotonic_time-0"><span class="code">erlang:monotonic_time()</span></a></code><code class="code">+</code><code class="bold_code"><a href="#time_offset-0"><span class="code">erlang:time_offset()</span></a></code>.</p> <div class="note"> <div class="label">Note</div> <div class="content">

<p>This time is <strong>not</strong> a monotonically increasing time in the general case. For more information, see the documentation of <code class="bold_code"><a href="../time_correction/#Time_Warp_Modes">time warp modes</a></code> in the User's Guide.</p> </div> </div>  <h3 id="system_time-1" class="code">erlang:system_time(Unit) -&gt; integer()</h3> <p>Types:</p>   <pre>Unit = <a href="#type-time_unit">time_unit()</a></pre>

<p>Returns current <code class="bold_code"><a href="../time_correction/#Erlang_System_Time">Erlang system time</a></code> converted into the <code class="code">Unit</code> passed as argument.</p> <p>Calling <code class="code">erlang:system_time(Unit)</code> is equivalent to <code class="bold_code"><a href="#convert_time_unit-3"><span class="code">erlang:convert_time_unit</span></a></code><code class="code">(</code><code class="bold_code"><a href="#system_time-0"><span class="code">erlang:system_time()</span></a></code><code class="code">, native, Unit)</code>.</p> <div class="note"> <div class="label">Note</div> <div class="content">

<p>This time is <strong>not</strong> a monotonically increasing time in the general case. For more information, see the documentation of <code class="bold_code"><a href="../time_correction/#Time_Warp_Modes">time warp modes</a></code> in the User's Guide.</p> </div> </div>  <h3 id="term_to_binary-1" class="code">term_to_binary(Term) -&gt; <a href="#type-ext_binary">ext_binary()</a>
</h3> <p>Types:</p>   <pre>Term = term()</pre>

<p>Returns a binary data object that is the result of encoding <code class="code">Term</code> according to the <code class="bold_code">Erlang external term format.</code></p> <p>This can be used for various purposes, for example, writing a term to a file in an efficient way, or sending an Erlang term to some type of communications channel not supported by distributed Erlang.</p> <div class="example"><pre>
&gt; Bin = term_to_binary(hello).
&lt;&lt;131,100,0,5,104,101,108,108,111&gt;&gt;
&gt; hello = binary_to_term(Bin).
hello
</pre></div> <p>See also <code class="bold_code"><a href="#binary_to_term-1"><span class="code">binary_to_term/1</span></a></code>.</p>  <h3 id="term_to_binary-2" class="code">term_to_binary(Term, Options) -&gt; <a href="#type-ext_binary">ext_binary()</a>
</h3> <p>Types:</p>    <pre>Term = term()
Options = 
    [compressed |
     {compressed, Level :: 0..9} |
     {minor_version, Version :: 0..1}]</pre>

<p>Returns a binary data object that is the result of encoding <code class="code">Term</code> according to the Erlang external term format.</p> <p>If option <code class="code">compressed</code> is provided, the external term format is compressed. The compressed format is automatically recognized by <code class="code">binary_to_term/1</code> as from Erlang/OTP R7B.</p> <p>A compression level can be specified by giving option <code class="code">{compressed, Level}</code>. <code class="code">Level</code> is an integer with range 0..9, where:</p> <ul> <li><p><code class="code">0</code> - No compression is done (it is the same as giving no <code class="code">compressed</code> option).</p></li> <li><p><code class="code">1</code> - Takes least time but may not compress as well as the higher levels.</p></li> <li><p><code class="code">6</code> - Default level when option <code class="code">compressed</code> is provided.</p></li> <li><p><code class="code">9</code> - Takes most time and tries to produce a smaller result. Notice "tries" in the preceding sentence; depending on the input term, level 9 compression either does or does not produce a smaller result than level 1 compression.</p></li> </ul> <p>Option <code class="code">{minor_version, Version}</code> can be used to control some encoding details. This option was introduced in Erlang/OTP R11B-4. The valid values for <code class="code">Version</code> are <code class="code">0</code> and <code class="code">1</code>.</p> <p>As from Erlang/OTP 17.0, <code class="code">{minor_version, 1}</code> is the default. It forces any floats in the term to be encoded in a more space-efficient and exact way (namely in the 64-bit IEEE format, rather than converted to a textual representation).</p> <p>As from Erlang/OTP R11B-4, <code class="code">binary_to_term/1</code> can decode this representation.</p> <p><code class="code">{minor_version, 0}</code> means that floats are encoded using a textual representation. This option is useful to ensure that releases before Erlang/OTP R11B-4 can decode resulting binary.</p> <p>See also <code class="bold_code"><a href="#binary_to_term-1"><span class="code">binary_to_term/1</span></a></code>.</p>  <h3 id="throw-1" class="code">throw(Any) -&gt; no_return()</h3> <p>Types:</p>   <pre>Any = term()</pre>

<p>A non-local return from a function. If evaluated within a <code class="code">catch</code>, <code class="code">catch</code> returns value <code class="code">Any</code>. Example:</p> <div class="example"><pre>
&gt; catch throw({hello, there}).
{hello,there}</pre></div> <p>Failure: <code class="code">nocatch</code> if not evaluated within a catch.</p>  <h3 id="time-0" class="code">time() -&gt; Time</h3> <p>Types:</p>   <pre>Time = calendar:time()</pre>

<p>Returns the current time as <code class="code">{Hour, Minute, Second}</code>.</p> <p>The time zone and Daylight Saving Time correction depend on the underlying OS. Example:</p> <div class="example"><pre>
&gt; time().
{9,42,44}</pre></div>  <h3 id="time_offset-0" class="code">erlang:time_offset() -&gt; integer()</h3> 
<p>Returns the current time offset between <code class="bold_code"><a href="../time_correction/#Erlang_Monotonic_Time">Erlang monotonic time</a></code> and <code class="bold_code"><a href="../time_correction/#Erlang_System_Time">Erlang system time</a></code> in <code class="code">native</code> <code class="bold_code"><a href="#type_time_unit">time unit</a></code>. Current time offset added to an Erlang monotonic time gives corresponding Erlang system time.</p> <p>The time offset may or may not change during operation depending on the <code class="bold_code"><a href="../time_correction/#Time_Warp_Modes">time warp mode</a></code> used.</p> <div class="note"> <div class="label">Note</div> <div class="content">

<p>A change in time offset can be observed at slightly different points in time by different processes.</p> <p>If the runtime system is in <code class="bold_code"><a href="../time_correction/#Multi_Time_Warp_Mode">multi-time warp mode</a></code>, the time offset is changed when the runtime system detects that the <code class="bold_code"><a href="../time_correction/#OS_System_Time">OS system time</a></code> has changed. The runtime system will, however, not detect this immediately when it occurs. A task checking the time offset is scheduled to execute at least once a minute; so, under normal operation this is to be detected within a minute, but during heavy load it can take longer time.</p> </div> </div>  <h3 id="time_offset-1" class="code">erlang:time_offset(Unit) -&gt; integer()</h3> <p>Types:</p>   <pre>Unit = <a href="#type-time_unit">time_unit()</a></pre>

<p>Returns the current time offset between <code class="bold_code"><a href="../time_correction/#Erlang_Monotonic_Time">Erlang monotonic time</a></code> and <code class="bold_code"><a href="../time_correction/#Erlang_System_Time">Erlang system time</a></code> converted into the <code class="code">Unit</code> passed as argument.</p> <p>Same as calling <code class="bold_code"><a href="#convert_time_unit-3"><span class="code">erlang:convert_time_unit</span></a></code><code class="code">(</code><code class="bold_code"><a href="#time_offset-0"><span class="code">erlang:time_offset()</span></a></code><code class="code">, native, Unit)</code> however optimized for commonly used <code class="code">Unit</code>s.</p>  <h3 id="timestamp-0" class="code">erlang:timestamp() -&gt; Timestamp</h3> <p>Types:</p>    <pre>Timestamp = <a href="#type-timestamp">timestamp()</a>
timestamp() = 
    {MegaSecs :: integer() &gt;= 0,
     Secs :: integer() &gt;= 0,
     MicroSecs :: integer() &gt;= 0}</pre>

<p>Returns current <code class="bold_code"><a href="../time_correction/#Erlang_System_Time">Erlang system time</a></code> on the format <code class="code">{MegaSecs, Secs, MicroSecs}</code>. This format is the same as <code class="bold_code"><span class="code">os:timestamp/0</span></code> and the deprecated <code class="bold_code"><a href="#now-0"><span class="code">erlang:now/0</span></a></code> use. The reason for the existence of <code class="code">erlang:timestamp()</code> is purely to simplify use for existing code that assumes this time stamp format. Current Erlang system time can more efficiently be retrieved in the time unit of your choice using <code class="bold_code"><a href="#system_time-1"><span class="code">erlang:system_time/1</span></a></code>.</p> <p>The <code class="code">erlang:timestamp()</code> BIF is equivalent to:</p> <div class="example"><pre>
timestamp() -&gt;
    ErlangSystemTime = erlang:system_time(microsecond),
    MegaSecs = ErlangSystemTime div 1000000000000,
    Secs = ErlangSystemTime div 1000000 - MegaSecs*1000000,
    MicroSecs = ErlangSystemTime rem 1000000,
    {MegaSecs, Secs, MicroSecs}.</pre></div> <p>It, however, uses a native implementation that does not build garbage on the heap and with slightly better performance.</p> <div class="note"> <div class="label">Note</div> <div class="content">

<p>This time is <strong>not</strong> a monotonically increasing time in the general case. For more information, see the documentation of <code class="bold_code"><a href="../time_correction/#Time_Warp_Modes">time warp modes</a></code> in the User's Guide.</p> </div> </div>  <h3 id="tl-1" class="code">tl(List) -&gt; term()</h3> <p>Types:</p>   <pre>List = [term(), ...]</pre>

<p>Returns the tail of <code class="code">List</code>, that is, the list minus the first element, for example:</p> <div class="example"><pre>
&gt; tl([geesties, guilies, beasties]).
[guilies, beasties]</pre></div> <p>Allowed in guard tests.</p> <p>Failure: <code class="code">badarg</code> if <code class="code">List</code> is the empty list <code class="code">[]</code>.</p>  <h3 id="trace-3" class="code">erlang:trace(PidPortSpec, How, FlagList) -&gt; integer()</h3> <p>Types:</p>      <pre>PidPortSpec = 
    pid() |
    port() |
    all |
    processes |
    ports |
    existing |
    existing_processes |
    existing_ports |
    new |
    new_processes |
    new_ports
How = boolean()
FlagList = [trace_flag()]
trace_flag() = 
    all |
    send |
    'receive' |
    procs |
    ports |
    call |
    arity |
    return_to |
    silent |
    running |
    exiting |
    running_procs |
    running_ports |
    garbage_collection |
    timestamp |
    cpu_timestamp |
    monotonic_timestamp |
    strict_monotonic_timestamp |
    set_on_spawn |
    set_on_first_spawn |
    set_on_link |
    set_on_first_link |
    {tracer, pid() | port()} |
    {tracer, module(), term()}</pre>

<p>Turns on (if <code class="code">How == true</code>) or off (if <code class="code">How == false</code>) the trace flags in <code class="code">FlagList</code> for the process or processes represented by <code class="code">PidPortSpec</code>.</p> <p><code class="code">PidPortSpec</code> is either a process identifier (pid) for a local process, a port identifier, or one of the following atoms:</p> <dl> <dt><strong><code class="code">all</code></strong></dt> <dd>All currently existing processes and ports and all that will be created in the future. </dd> <dt><strong><code class="code">processes</code></strong></dt> <dd>All currently existing processes and all that will be created in the future. </dd> <dt><strong><code class="code">ports</code></strong></dt> <dd>All currently existing ports and all that will be created in the future. </dd> <dt><strong><code class="code">existing</code></strong></dt> <dd>All currently existing processes and ports. </dd> <dt><strong><code class="code">existing_processes</code></strong></dt> <dd>All currently existing processes. </dd> <dt><strong><code class="code">existing_ports</code></strong></dt> <dd>All currently existing ports. </dd> <dt><strong><code class="code">new</code></strong></dt> <dd>All processes and ports that will be created in the future. </dd> <dt><strong><code class="code">new_processes</code></strong></dt> <dd>All processes that will be created in the future. </dd> <dt><strong><code class="code">new_ports</code></strong></dt> <dd>All ports that will be created in the future. </dd> </dl> <p><code class="code">FlagList</code> can contain any number of the following flags (the "message tags" refers to the list of <code class="bold_code"><a href="#trace_3_trace_messages"><span class="code">trace messages</span></a></code>):</p> <dl> <dt><strong><code class="code">all</code></strong></dt> <dd> <p>Sets all trace flags except <code class="code">tracer</code> and <code class="code">cpu_timestamp</code>, which are in their nature different than the others.</p> </dd> <dt><strong><code class="code">send</code></strong></dt> <dd> <p>Traces sending of messages.</p> <p>Message tags: <code class="bold_code"><a href="#trace_3_trace_messages_send"><span class="code">send</span></a></code> and <code class="bold_code"><a href="#trace_3_trace_messages_send_to_non_existing_process"><span class="code">send_to_non_existing_process</span></a></code>.</p> </dd> <dt><strong><code class="code">'receive'</code></strong></dt> <dd> <p>Traces receiving of messages.</p> <p>Message tags: <code class="bold_code"><a href="#trace_3_trace_messages_receive"><span class="code">'receive'</span></a></code>.</p> </dd> <dt><strong><code class="code">call</code></strong></dt> <dd> <p>Traces certain function calls. Specify which function calls to trace by calling <code class="bold_code"><a href="#trace_pattern-3"><span class="code">erlang:trace_pattern/3</span></a></code>.</p> <p>Message tags: <code class="bold_code"><a href="#trace_3_trace_messages_call"><span class="code">call</span></a></code> and <code class="bold_code"><a href="#trace_3_trace_messages_return_from"><span class="code">return_from</span></a></code>.</p> </dd> <dt><strong><code class="code">silent</code></strong></dt> <dd> <p>Used with the <code class="code">call</code> trace flag. The <code class="code">call</code>, <code class="code">return_from</code>, and <code class="code">return_to</code> trace messages are inhibited if this flag is set, but they are executed as normal if there are match specifications.</p> <p>Silent mode is inhibited by executing <code class="code">erlang:trace(_, false, [silent|_])</code>, or by a match specification executing the function <code class="code">{silent, false}</code>.</p> <p>The <code class="code">silent</code> trace flag facilitates setting up a trace on many or even all processes in the system. The trace can then be activated and deactivated using the match specification function <code class="code">{silent,Bool}</code>, giving a high degree of control of which functions with which arguments that trigger the trace.</p> <p>Message tags: <code class="bold_code"><a href="#trace_3_trace_messages_call"><span class="code">call</span></a></code>, <code class="bold_code"><a href="#trace_3_trace_messages_return_from"><span class="code">return_from</span></a></code>, and <code class="bold_code"><a href="#trace_3_trace_messages_return_to"><span class="code">return_to</span></a></code>. Or rather, the absence of.</p> </dd> <dt><strong><code class="code">return_to</code></strong></dt> <dd> <p>Used with the <code class="code">call</code> trace flag. Traces the return from a traced function back to its caller. Only works for functions traced with option <code class="code">local</code> to <code class="bold_code"><a href="#trace_pattern-3"><span class="code">erlang:trace_pattern/3</span></a></code>.</p> <p>The semantics is that a trace message is sent when a call traced function returns, that is, when a chain of tail recursive calls ends. Only one trace message is sent per chain of tail recursive calls, so the properties of tail recursiveness for function calls are kept while tracing with this flag. Using <code class="code">call</code> and <code class="code">return_to</code> trace together makes it possible to know exactly in which function a process executes at any time.</p> <p>To get trace messages containing return values from functions, use the <code class="code">{return_trace}</code> match specification action instead.</p> <p>Message tags: <code class="bold_code"><a href="#trace_3_trace_messages_return_to"><span class="code">return_to</span></a></code>.</p> </dd> <dt><strong><code class="code">procs</code></strong></dt> <dd> <p>Traces process-related events.</p> <p>Message tags: <code class="bold_code"><a href="#trace_3_trace_messages_spawn"><span class="code">spawn</span></a></code>, <code class="bold_code"><a href="#trace_3_trace_messages_spawned"><span class="code">spawned</span></a></code>, <code class="bold_code"><a href="#trace_3_trace_messages_exit"><span class="code">exit</span></a></code>, <code class="bold_code"><a href="#trace_3_trace_messages_register"><span class="code">register</span></a></code>, <code class="bold_code"><a href="#trace_3_trace_messages_unregister"><span class="code">unregister</span></a></code>, <code class="bold_code"><a href="#trace_3_trace_messages_link"><span class="code">link</span></a></code>, <code class="bold_code"><a href="#trace_3_trace_messages_unlink"><span class="code">unlink</span></a></code>, <code class="bold_code"><a href="#trace_3_trace_messages_getting_linked"><span class="code">getting_linked</span></a></code>, and <code class="bold_code"><a href="#trace_3_trace_messages_getting_unlinked"><span class="code">getting_unlinked</span></a></code>.</p> </dd> <dt><strong><code class="code">ports</code></strong></dt> <dd> <p>Traces port-related events.</p> <p>Message tags: <code class="bold_code"><a href="#trace_3_trace_messages_open"><span class="code">open</span></a></code>, <code class="bold_code"><a href="#trace_3_trace_messages_closed"><span class="code">closed</span></a></code>, <code class="bold_code"><a href="#trace_3_trace_messages_register"><span class="code">register</span></a></code>, <code class="bold_code"><a href="#trace_3_trace_messages_unregister"><span class="code">unregister</span></a></code>, <code class="bold_code"><a href="#trace_3_trace_messages_getting_linked"><span class="code">getting_linked</span></a></code>, and <code class="bold_code"><a href="#trace_3_trace_messages_getting_unlinked"><span class="code">getting_unlinked</span></a></code>.</p> </dd> <dt><strong><code class="code">running</code></strong></dt> <dd> <p>Traces scheduling of processes.</p> <p>Message tags: <code class="bold_code"><a href="#trace_3_trace_messages_in_proc"><span class="code">in</span></a></code> and <code class="bold_code"><a href="#trace_3_trace_messages_out_proc"><span class="code">out</span></a></code>.</p> </dd> <dt><strong><code class="code">exiting</code></strong></dt> <dd> <p>Traces scheduling of exiting processes.</p> <p>Message tags: <code class="bold_code"><a href="#trace_3_trace_messages_in_exiting_proc"><span class="code">in_exiting</span></a></code>, <code class="bold_code"><a href="#trace_3_trace_messages_out_exiting_proc"><span class="code">out_exiting</span></a></code>, and <code class="bold_code"><a href="#trace_3_trace_messages_out_exited_proc"><span class="code">out_exited</span></a></code>.</p> </dd> <dt><strong><code class="code">running_procs</code></strong></dt> <dd> <p>Traces scheduling of processes just like <code class="code">running</code>. However, this option also includes schedule events when the process executes within the context of a port without being scheduled out itself.</p> <p>Message tags: <code class="bold_code"><a href="#trace_3_trace_messages_in_proc"><span class="code">in</span></a></code> and <code class="bold_code"><a href="#trace_3_trace_messages_out_proc"><span class="code">out</span></a></code>.</p> </dd> <dt><strong><code class="code">running_ports</code></strong></dt> <dd> <p>Traces scheduling of ports.</p> <p>Message tags: <code class="bold_code"><a href="#trace_3_trace_messages_in_port"><span class="code">in</span></a></code> and <code class="bold_code"><a href="#trace_3_trace_messages_out_port"><span class="code">out</span></a></code>.</p> </dd> <dt><strong><code class="code">garbage_collection</code></strong></dt> <dd> <p>Traces garbage collections of processes.</p> <p>Message tags: <code class="bold_code"><a href="#trace_3_trace_messages_gc_minor_start"><span class="code">gc_minor_start</span></a></code>, <code class="bold_code"><a href="#trace_3_trace_messages_gc_max_heap_size"><span class="code">gc_max_heap_size</span></a></code>, and <code class="bold_code"><a href="#trace_3_trace_messages_gc_minor_end"><span class="code">gc_minor_end</span></a></code>.</p> </dd> <dt><strong><code class="code">timestamp</code></strong></dt> <dd> <p>Includes a time stamp in all trace messages. The time stamp (Ts) has the same form as returned by <code class="code">erlang:now()</code>.</p> </dd> <dt><strong><code class="code">cpu_timestamp</code></strong></dt> <dd> <p>A global trace flag for the Erlang node that makes all trace time stamps using flag <code class="code">timestamp</code> to be in CPU time, not wall clock time. That is, <code class="code">cpu_timestamp</code> is not be used if <code class="code">monotonic_timestamp</code> or <code class="code">strict_monotonic_timestamp</code> is enabled. Only allowed with <code class="code">PidPortSpec==all</code>. If the host machine OS does not support high-resolution CPU time measurements, <code class="code">trace/3</code> exits with <code class="code">badarg</code>. Notice that most OS do not synchronize this value across cores, so be prepared that time can seem to go backwards when using this option.</p> </dd> <dt><strong><code class="code">monotonic_timestamp</code></strong></dt> <dd> <p>Includes an <code class="bold_code"><a href="../time_correction/#Erlang_Monotonic_Time">Erlang monotonic time</a></code> time stamp in all trace messages. The time stamp (Ts) has the same format and value as produced by <code class="bold_code"><a href="#monotonic_time-1"><span class="code">erlang:monotonic_time(nanosecond)</span></a></code>. This flag overrides flag <code class="code">cpu_timestamp</code>.</p> </dd> <dt><strong><code class="code">strict_monotonic_timestamp</code></strong></dt> <dd> <p>Includes an time stamp consisting of <code class="bold_code"><a href="../time_correction/#Erlang_Monotonic_Time">Erlang monotonic time</a></code> and a monotonically increasing integer in all trace messages. The time stamp (Ts) has the same format and value as produced by <code class="code">{</code> <code class="bold_code"><a href="#monotonic_time-1"><span class="code">erlang:monotonic_time(nanosecond)</span></a></code><code class="code">,</code> <code class="bold_code"><a href="#unique_integer-1"><span class="code">erlang:unique_integer([monotonic])</span></a></code><code class="code">}</code>. This flag overrides flag <code class="code">cpu_timestamp</code>.</p> </dd> <dt><strong><code class="code">arity</code></strong></dt> <dd> <p>Used with the <code class="code">call</code> trace flag. <code class="code">{M, F, Arity}</code> is specified instead of <code class="code">{M, F, Args}</code> in call trace messages.</p> </dd> <dt><strong><code class="code">set_on_spawn</code></strong></dt> <dd> <p>Makes any process created by a traced process inherit its trace flags, including flag <code class="code">set_on_spawn</code>.</p> </dd> <dt><strong><code class="code">set_on_first_spawn</code></strong></dt> <dd> <p>Makes the first process created by a traced process inherit its trace flags, excluding flag <code class="code">set_on_first_spawn</code>.</p> </dd> <dt><strong><code class="code">set_on_link</code></strong></dt> <dd> <p>Makes any process linked by a traced process inherit its trace flags, including flag <code class="code">set_on_link</code>.</p> </dd> <dt><strong><code class="code">set_on_first_link</code></strong></dt> <dd> <p>Makes the first process linked to by a traced process inherit its trace flags, excluding flag <code class="code">set_on_first_link</code>.</p> </dd> <dt><strong><code class="code">{tracer, Tracer}</code></strong></dt> <dd> <p>Specifies where to send the trace messages. <code class="code">Tracer</code> must be the process identifier of a local process or the port identifier of a local port.</p> </dd> <dt><strong><code class="code">{tracer, TracerModule, TracerState}</code></strong></dt> <dd> <p>Specifies that a tracer module is to be called instead of sending a trace message. The tracer module can then ignore or change the trace message. For more details on how to write a tracer module, see <code class="bold_code"><span class="code">erl_tracer(3)</span></code>.</p> </dd> </dl> <p>If no <code class="code">tracer</code> is specified, the calling process receives all the trace messages.</p> <p>The effect of combining <code class="code">set_on_first_link</code> with <code class="code">set_on_link</code> is the same as <code class="code">set_on_first_link</code> alone. Likewise for <code class="code">set_on_spawn</code> and <code class="code">set_on_first_spawn</code>.</p> <p>The tracing process receives the <strong>trace messages</strong> described in the following list. <code class="code">Pid</code> is the process identifier of the traced process in which the traced event has occurred. The third tuple element is the message tag.</p> <p>If flag <code class="code">timestamp</code>, <code class="code">strict_monotonic_timestamp</code>, or <code class="code">monotonic_timestamp</code> is specified, the first tuple element is <code class="code">trace_ts</code> instead, and the time stamp is added as an extra element last in the message tuple. If multiple time stamp flags are passed, <code class="code">timestamp</code> has precedence over <code class="code">strict_monotonic_timestamp</code>, which in turn has precedence over <code class="code">monotonic_timestamp</code>. All time stamp flags are remembered, so if two are passed and the one with highest precedence later is disabled, the other one becomes active.</p> <p>Trace messages:</p>  <dl> <dt><strong id="trace_3_trace_messages_send">  <code class="code">{trace, PidPort, send, Msg, To}</code> </strong></dt> <dd> <p>When <code class="code">PidPort</code> sends message <code class="code">Msg</code> to process <code class="code">To</code>.</p> </dd> <dt><strong id="trace_3_trace_messages_send_to_non_existing_process">  <code class="code">{trace, PidPort, send_to_non_existing_process, Msg, To}</code> </strong></dt> <dd> <p>When <code class="code">PidPort</code> sends message <code class="code">Msg</code> to the non-existing process <code class="code">To</code>.</p> </dd> <dt><strong id="trace_3_trace_messages_receive">  <code class="code">{trace, PidPort, 'receive', Msg}</code> </strong></dt> <dd> <p>When <code class="code">PidPort</code> receives message <code class="code">Msg</code>. If <code class="code">Msg</code> is set to time-out, a receive statement can have timed out, or the process received a message with the payload <code class="code">timeout</code>.</p> </dd> <dt><strong id="trace_3_trace_messages_call">  <code class="code">{trace, Pid, call, {M, F, Args}}</code> </strong></dt> <dd> <p>When <code class="code">Pid</code> calls a traced function. The return values of calls are never supplied, only the call and its arguments.</p> <p>Trace flag <code class="code">arity</code> can be used to change the contents of this message, so that <code class="code">Arity</code> is specified instead of <code class="code">Args</code>.</p> </dd> <dt><strong id="trace_3_trace_messages_return_to">  <code class="code">{trace, Pid, return_to, {M, F, Arity}}</code> </strong></dt> <dd> <p>When <code class="code">Pid</code> returns <strong>to</strong> the specified function. This trace message is sent if both the flags <code class="code">call</code> and <code class="code">return_to</code> are set, and the function is set to be traced on <strong>local</strong> function calls. The message is only sent when returning from a chain of tail recursive function calls, where at least one call generated a <code class="code">call</code> trace message (that is, the functions match specification matched, and <code class="code">{message, false}</code> was not an action).</p> </dd> <dt><strong id="trace_3_trace_messages_return_from">  <code class="code">{trace, Pid, return_from, {M, F, Arity}, ReturnValue}</code> </strong></dt> <dd> <p>When <code class="code">Pid</code> returns <strong>from</strong> the specified function. This trace message is sent if flag <code class="code">call</code> is set, and the function has a match specification with a <code class="code">return_trace</code> or <code class="code">exception_trace</code> action.</p> </dd> <dt><strong id="trace_3_trace_messages_exception_from">  <code class="code">{trace, Pid, exception_from, {M, F, Arity}, {Class, Value}}</code> </strong></dt> <dd> <p>When <code class="code">Pid</code> exits <strong>from</strong> the specified function because of an exception. This trace message is sent if flag <code class="code">call</code> is set, and the function has a match specification with an <code class="code">exception_trace</code> action.</p> </dd> <dt><strong id="trace_3_trace_messages_spawn">  <code class="code">{trace, Pid, spawn, Pid2, {M, F, Args}}</code> </strong></dt> <dd> <p>When <code class="code">Pid</code> spawns a new process <code class="code">Pid2</code> with the specified function call as entry point.</p> <p><code class="code">Args</code> is supposed to be the argument list, but can be any term if the spawn is erroneous.</p> </dd> <dt><strong id="trace_3_trace_messages_spawned">  <code class="code">{trace, Pid, spawned, Pid2, {M, F, Args}}</code> </strong></dt> <dd> <p>When <code class="code">Pid</code> is spawned by process <code class="code">Pid2</code> with the specified function call as entry point.</p> <p><code class="code">Args</code> is supposed to be the argument list, but can be any term if the spawn is erroneous.</p> </dd> <dt><strong id="trace_3_trace_messages_exit">  <code class="code">{trace, Pid, exit, Reason}</code> </strong></dt> <dd> <p>When <code class="code">Pid</code> exits with reason <code class="code">Reason</code>.</p> </dd> <dt><strong id="trace_3_trace_messages_register">  <code class="code">{trace, PidPort, register, RegName}</code> </strong></dt> <dd> <p>When <code class="code">PidPort</code> gets the name <code class="code">RegName</code> registered.</p> </dd> <dt><strong id="trace_3_trace_messages_unregister">  <code class="code">{trace, PidPort, unregister, RegName}</code> </strong></dt> <dd> <p>When <code class="code">PidPort</code> gets the name <code class="code">RegName</code> unregistered. This is done automatically when a registered process or port exits.</p> </dd> <dt><strong id="trace_3_trace_messages_link">  <code class="code">{trace, Pid, link, Pid2}</code> </strong></dt> <dd> <p>When <code class="code">Pid</code> links to a process <code class="code">Pid2</code>.</p> </dd> <dt><strong id="trace_3_trace_messages_unlink">  <code class="code">{trace, Pid, unlink, Pid2}</code> </strong></dt> <dd> <p>When <code class="code">Pid</code> removes the link from a process <code class="code">Pid2</code>.</p> </dd> <dt><strong id="trace_3_trace_messages_getting_linked">  <code class="code">{trace, PidPort, getting_linked, Pid2}</code> </strong></dt> <dd> <p>When <code class="code">PidPort</code> gets linked to a process <code class="code">Pid2</code>.</p> </dd> <dt><strong id="trace_3_trace_messages_getting_unlinked">  <code class="code">{trace, PidPort, getting_unlinked, Pid2}</code> </strong></dt> <dd> <p>When <code class="code">PidPort</code> gets unlinked from a process <code class="code">Pid2</code>.</p> </dd> <dt><strong id="trace_3_trace_messages_exit">  <code class="code">{trace, Pid, exit, Reason}</code> </strong></dt> <dd> <p>When <code class="code">Pid</code> exits with reason <code class="code">Reason</code>.</p> </dd> <dt><strong id="trace_3_trace_messages_open">  <code class="code">{trace, Port, open, Pid, Driver}</code> </strong></dt> <dd> <p>When <code class="code">Pid</code> opens a new port <code class="code">Port</code> with the running <code class="code">Driver</code>.</p> <p><code class="code">Driver</code> is the name of the driver as an atom.</p> </dd> <dt><strong id="trace_3_trace_messages_closed">  <code class="code">{trace, Port, closed, Reason}</code> </strong></dt> <dd> <p>When <code class="code">Port</code> closes with <code class="code">Reason</code>.</p> </dd> <dt><strong id="trace_3_trace_messages_in_exiting_proc">   <code class="code">{trace, Pid, in | in_exiting, {M, F, Arity} | 0}</code> </strong></dt> <dd> <p>When <code class="code">Pid</code> is scheduled to run. The process runs in function <code class="code">{M, F, Arity}</code>. On some rare occasions, the current function cannot be determined, then the last element is <code class="code">0</code>.</p> </dd> <dt><strong id="trace_3_trace_messages_out_exited_proc">    <code class="code">{trace, Pid, out | out_exiting | out_exited, {M, F, Arity} | 0}</code> </strong></dt> <dd> <p>When <code class="code">Pid</code> is scheduled out. The process was running in function {M, F, Arity}. On some rare occasions, the current function cannot be determined, then the last element is <code class="code">0</code>.</p> </dd> <dt><strong id="trace_3_trace_messages_in_port">  <code class="code">{trace, Port, in, Command | 0}</code> </strong></dt> <dd> <p>When <code class="code">Port</code> is scheduled to run. <code class="code">Command</code> is the first thing the port will execute, it can however run several commands before being scheduled out. On some rare occasions, the current function cannot be determined, then the last element is <code class="code">0</code>.</p> <p>The possible commands are <code class="code">call</code>, <code class="code">close</code>, <code class="code">command</code>, <code class="code">connect</code>, <code class="code">control</code>, <code class="code">flush</code>, <code class="code">info</code>, <code class="code">link</code>, <code class="code">open</code>, and <code class="code">unlink</code>.</p> </dd> <dt><strong id="trace_3_trace_messages_out_port">  <code class="code">{trace, Port, out, Command | 0}</code> </strong></dt> <dd> <p>When <code class="code">Port</code> is scheduled out. The last command run was <code class="code">Command</code>. On some rare occasions, the current function cannot be determined, then the last element is <code class="code">0</code>. <code class="code">Command</code> can contain the same commands as <code class="code">in</code></p> </dd> <dt><strong id="trace_3_trace_messages_gc_minor_start">  <code class="code">{trace, Pid, gc_minor_start, Info}</code> </strong></dt> <dd id="gc_minor_start">  <p>Sent when a young garbage collection is about to be started. <code class="code">Info</code> is a list of two-element tuples, where the first element is a key, and the second is the value. Do not depend on any order of the tuples. The following keys are defined:</p> <dl> <dt><strong><code class="code">heap_size</code></strong></dt> <dd>The size of the used part of the heap.</dd> <dt><strong><code class="code">heap_block_size</code></strong></dt> <dd>The size of the memory block used for storing the heap and the stack.</dd> <dt><strong><code class="code">old_heap_size</code></strong></dt> <dd>The size of the used part of the old heap.</dd> <dt><strong><code class="code">old_heap_block_size</code></strong></dt> <dd>The size of the memory block used for storing the old heap.</dd> <dt><strong><code class="code">stack_size</code></strong></dt> <dd>The size of the stack.</dd> <dt><strong><code class="code">recent_size</code></strong></dt> <dd>The size of the data that survived the previous garbage collection.</dd> <dt><strong><code class="code">mbuf_size</code></strong></dt> <dd>The combined size of message buffers associated with the process.</dd> <dt><strong><code class="code">bin_vheap_size</code></strong></dt> <dd>The total size of unique off-heap binaries referenced from the process heap.</dd> <dt><strong><code class="code">bin_vheap_block_size</code></strong></dt> <dd>The total size of binaries allowed in the virtual heap in the process before doing a garbage collection.</dd> <dt><strong><code class="code">bin_old_vheap_size</code></strong></dt> <dd>The total size of unique off-heap binaries referenced from the process old heap.</dd> <dt><strong><code class="code">bin_old_vheap_block_size</code></strong></dt> <dd>The total size of binaries allowed in the virtual old heap in the process before doing a garbage collection.</dd> </dl> <p>All sizes are in words.</p> </dd> <dt><strong id="trace_3_trace_messages_gc_max_heap_size">  <code class="code">{trace, Pid, gc_max_heap_size, Info}</code> </strong></dt> <dd> <p>Sent when the <code class="bold_code"><a href="#process_flag_max_heap_size"><span class="code">max_heap_size</span></a></code> is reached during garbage collection. <code class="code">Info</code> contains the same kind of list as in message <code class="code">gc_start</code>, but the sizes reflect the sizes that triggered <code class="code">max_heap_size</code> to be reached.</p> </dd> <dt><strong id="trace_3_trace_messages_gc_minor_end">  <code class="code">{trace, Pid, gc_minor_end, Info}</code> </strong></dt> <dd> <p>Sent when young garbage collection is finished. <code class="code">Info</code> contains the same kind of list as in message <code class="code">gc_minor_start</code>, but the sizes reflect the new sizes after garbage collection.</p> </dd> <dt><strong id="trace_3_trace_messages_gc_major_start">  <code class="code">{trace, Pid, gc_major_start, Info}</code> </strong></dt> <dd> <p>Sent when fullsweep garbage collection is about to be started. <code class="code">Info</code> contains the same kind of list as in message <code class="code">gc_minor_start</code>.</p> </dd> <dt><strong id="trace_3_trace_messages_gc_major_end">  <code class="code">{trace, Pid, gc_major_end, Info}</code> </strong></dt> <dd> <p>Sent when fullsweep garbage collection is finished. <code class="code">Info</code> contains the same kind of list as in message <code class="code">gc_minor_start</code>, but the sizes reflect the new sizes after a fullsweep garbage collection.</p> </dd> </dl> <p>If the tracing process/port dies or the tracer module returns <code class="code">remove</code>, the flags are silently removed.</p> <p>Each process can only be traced by one tracer. Therefore, attempts to trace an already traced process fail.</p> <p>Returns a number indicating the number of processes that matched <code class="code">PidPortSpec</code>. If <code class="code">PidPortSpec</code> is a process identifier, the return value is <code class="code">1</code>. If <code class="code">PidPortSpec</code> is <code class="code">all</code> or <code class="code">existing</code>, the return value is the number of processes running. If <code class="code">PidPortSpec</code> is <code class="code">new</code>, the return value is <code class="code">0</code>.</p> <p>Failure: <code class="code">badarg</code> if the specified arguments are not supported. For example, <code class="code">cpu_timestamp</code> is not supported on all platforms.</p>  <h3 id="trace_delivered-1" class="code">erlang:trace_delivered(Tracee) -&gt; Ref</h3> <p>Types:</p>    <pre>Tracee = pid() | all
Ref = reference()</pre>

<p>The delivery of trace messages (generated by <code class="bold_code"><a href="#trace-3"><span class="code">erlang:trace/3</span></a></code>, <code class="bold_code"><span class="code">seq_trace(3)</span></code>, or <code class="bold_code"><a href="#system_profile-2"><span class="code">erlang:system_profile/2</span></a></code>) is dislocated on the time-line compared to other events in the system. If you know that <code class="code">Tracee</code> has passed some specific point in its execution, and you want to know when at least all trace messages corresponding to events up to this point have reached the tracer, use <code class="code">erlang:trace_delivered(Tracee)</code>.</p> <p>When it is guaranteed that all trace messages are delivered to the tracer up to the point that <code class="code">Tracee</code> reached at the time of the call to <code class="code">erlang:trace_delivered(Tracee)</code>, then a <code class="code">{trace_delivered, Tracee, Ref}</code> message is sent to the caller of <code class="code">erlang:trace_delivered(Tracee)</code> .</p> <p>Notice that message <code class="code">trace_delivered</code> does <strong>not</strong> imply that trace messages have been delivered. Instead it implies that all trace messages that <strong>are to be delivered</strong> have been delivered. It is not an error if <code class="code">Tracee</code> is not, and has not been traced by someone, but if this is the case, <strong>no</strong> trace messages have been delivered when the <code class="code">trace_delivered</code> message arrives.</p> <p>Notice that <code class="code">Tracee</code> must refer to a process currently or previously existing on the same node as the caller of <code class="code">erlang:trace_delivered(Tracee)</code> resides on. The special <code class="code">Tracee</code> atom <code class="code">all</code> denotes all processes that currently are traced in the node.</p> <p>When used together with a <code class="bold_code">Tracer Module</code>, any message sent in the trace callback is guaranteed to have reached its recipient before the <code class="code">trace_delivered</code> message is sent.</p> <p>Example: Process <code class="code">A</code> is <code class="code">Tracee</code>, port <code class="code">B</code> is tracer, and process <code class="code">C</code> is the port owner of <code class="code">B</code>. <code class="code">C</code> wants to close <code class="code">B</code> when <code class="code">A</code> exits. To ensure that the trace is not truncated, <code class="code">C</code> can call <code class="code">erlang:trace_delivered(A)</code> when <code class="code">A</code> exits, and wait for message <code class="code">{trace_delivered, A, Ref}</code> before closing <code class="code">B</code>.</p> <p>Failure: <code class="code">badarg</code> if <code class="code">Tracee</code> does not refer to a process (dead or alive) on the same node as the caller of <code class="code">erlang:trace_delivered(Tracee)</code> resides on.</p>  <h3 id="trace_info-2" class="code">erlang:trace_info(PidPortFuncEvent, Item) -&gt; Res</h3> <p>Types:</p>            <pre>PidPortFuncEvent = 
    pid() |
    port() |
    new |
    new_processes |
    new_ports |
    {Module, Function, Arity} |
    on_load |
    send |
    'receive'
Module = module()
Function = atom()
Arity = arity()
Item = 
    flags |
    tracer |
    traced |
    match_spec |
    meta |
    meta_match_spec |
    call_count |
    call_time |
    all
Res = trace_info_return()
trace_info_return() = 
    undefined |
    {flags, [trace_info_flag()]} |
    {tracer, pid() | port() | []} |
    {tracer, module(), term()} |
    trace_info_item_result() |
    {all, [trace_info_item_result()] | false | undefined}
trace_info_item_result() = 
    {traced, global | local | false | undefined} |
    {match_spec, trace_match_spec() | false | undefined} |
    {meta, pid() | port() | false | undefined | []} |
    {meta, module(), term()} |
    {meta_match_spec, trace_match_spec() | false | undefined} |
    {call_count, integer() &gt;= 0 | boolean() | undefined} |
    {call_time,
     [{pid(),
       integer() &gt;= 0,
       integer() &gt;= 0,
       integer() &gt;= 0}] |
     boolean() |
     undefined}
trace_info_flag() = 
    send |
    'receive' |
    set_on_spawn |
    call |
    return_to |
    procs |
    set_on_first_spawn |
    set_on_link |
    running |
    garbage_collection |
    timestamp |
    monotonic_timestamp |
    strict_monotonic_timestamp |
    arity
trace_match_spec() = 
    [{[term()] | '_' | match_variable(), [term()], [term()]}]
match_variable() = atom()</pre>
<p class="REFBODY"> Approximation of '$1' | '$2' | '$3' | ... </p>  
<p>Returns trace information about a port, process, function, or event.</p> <p><strong>To get information about a port or process</strong>, <code class="code">PidPortFuncEvent</code> is to be a process identifier (pid), port identifier, or one of the atoms <code class="code">new</code>, <code class="code">new_processes</code>, or <code class="code">new_ports</code>. The atom <code class="code">new</code> or <code class="code">new_processes</code> means that the default trace state for processes to be created is returned. The atom <code class="code">new_ports</code> means that the default trace state for ports to be created is returned.</p> <p>Valid <code class="code">Item</code>s for ports and processes:</p> <dl> <dt><strong><code class="code">flags</code></strong></dt> <dd> <p>Returns a list of atoms indicating what kind of traces is enabled for the process. The list is empty if no traces are enabled, and one or more of the followings atoms if traces are enabled: <code class="code">send</code>, <code class="code">'receive'</code>, <code class="code">set_on_spawn</code>, <code class="code">call</code>, <code class="code">return_to</code>, <code class="code">procs</code>, <code class="code">ports</code>, <code class="code">set_on_first_spawn</code>, <code class="code">set_on_link</code>, <code class="code">running</code>, <code class="code">running_procs</code>, <code class="code">running_ports</code>, <code class="code">silent</code>, <code class="code">exiting</code>, <code class="code">monotonic_timestamp</code>, <code class="code">strict_monotonic_timestamp</code>, <code class="code">garbage_collection</code>, <code class="code">timestamp</code>, and <code class="code">arity</code>. The order is arbitrary.</p> </dd> <dt><strong><code class="code">tracer</code></strong></dt> <dd> <p>Returns the identifier for process, port, or a tuple containing the tracer module and tracer state tracing this process. If this process is not traced, the return value is <code class="code">[]</code>.</p> </dd> </dl> <p><strong>To get information about a function</strong>, <code class="code">PidPortFuncEvent</code> is to be the three-element tuple <code class="code">{Module, Function, Arity}</code> or the atom <code class="code">on_load</code>. No wildcards are allowed. Returns <code class="code">undefined</code> if the function does not exist, or <code class="code">false</code> if the function is not traced. If <code class="code">PidPortFuncEvent</code> is <code class="code">on_load</code>, the information returned refers to the default value for code that will be loaded.</p> <p>Valid <code class="code">Item</code>s for functions:</p> <dl> <dt><strong><code class="code">traced</code></strong></dt> <dd> <p>Returns <code class="code">global</code> if this function is traced on global function calls, <code class="code">local</code> if this function is traced on local function calls (that is, local and global function calls), and <code class="code">false</code> if local or global function calls are not traced.</p> </dd> <dt><strong><code class="code">match_spec</code></strong></dt> <dd> <p>Returns the match specification for this function, if it has one. If the function is locally or globally traced but has no match specification defined, the returned value is <code class="code">[]</code>.</p> </dd> <dt><strong><code class="code">meta</code></strong></dt> <dd> <p>Returns the meta-trace tracer process, port, or trace module for this function, if it has one. If the function is not meta-traced, the returned value is <code class="code">false</code>. If the function is meta-traced but has once detected that the tracer process is invalid, the returned value is <code class="code">[]</code>.</p> </dd> <dt><strong><code class="code">meta_match_spec</code></strong></dt> <dd> <p>Returns the meta-trace match specification for this function, if it has one. If the function is meta-traced but has no match specification defined, the returned value is <code class="code">[]</code>.</p> </dd> <dt><strong><code class="code">call_count</code></strong></dt> <dd> <p>Returns the call count value for this function or <code class="code">true</code> for the pseudo function <code class="code">on_load</code> if call count tracing is active. Otherwise <code class="code">false</code> is returned.</p> <p>See also <code class="bold_code"><a href="#trace_pattern-3"><span class="code">erlang:trace_pattern/3</span></a></code>.</p> </dd> <dt><strong><code class="code">call_time</code></strong></dt> <dd> <p>Returns the call time values for this function or <code class="code">true</code> for the pseudo function <code class="code">on_load</code> if call time tracing is active. Otherwise <code class="code">false</code> is returned. The call time values returned, <code class="code">[{Pid, Count, S, Us}]</code>, is a list of each process that executed the function and its specific counters.</p> <p>See also <code class="bold_code"><a href="#trace_pattern-3"><span class="code">erlang:trace_pattern/3</span></a></code>.</p> </dd> <dt><strong><code class="code">all</code></strong></dt> <dd> <p>Returns a list containing the <code class="code">{Item, Value}</code> tuples for all other items, or returns <code class="code">false</code> if no tracing is active for this function.</p> </dd> </dl> <p><strong>To get information about an event</strong>, <code class="code">PidPortFuncEvent</code> is to be one of the atoms <code class="code">send</code> or <code class="code">'receive'</code>.</p> <p>One valid <code class="code">Item</code> for events exists:</p> <dl> <dt><strong><code class="code">match_spec</code></strong></dt> <dd> <p>Returns the match specification for this event, if it has one, or <code class="code">true</code> if no match specification has been set.</p> </dd> </dl> <p>The return value is <code class="code">{Item, Value}</code>, where <code class="code">Value</code> is the requested information as described earlier. If a pid for a dead process was specified, or the name of a non-existing function, <code class="code">Value</code> is <code class="code">undefined</code>.</p>  <h3 id="trace_pattern-2" class="code">erlang:trace_pattern(MFA, MatchSpec) -&gt; integer() &gt;= 0</h3> <p>Types:</p>      <pre>MFA = trace_pattern_mfa() | send | 'receive'
MatchSpec = 
    (MatchSpecList :: trace_match_spec()) |
    boolean() |
    restart |
    pause
trace_pattern_mfa() = {atom(), atom(), arity() | '_'} | on_load
trace_match_spec() = 
    [{[term()] | '_' | match_variable(), [term()], [term()]}]
match_variable() = atom()</pre>
<p class="REFBODY"> Approximation of '$1' | '$2' | '$3' | ... </p>  
<p>The same as <code class="bold_code"><a href="#trace_pattern-3"><span class="code">erlang:trace_pattern(Event, MatchSpec, [])</span></a></code>, retained for backward compatibility.</p>  <h3 id="trace_pattern-3" class="code">erlang:trace_pattern(MFA :: send, MatchSpec, FlagList :: []) -&gt;<br>                        integer() &gt;= 0</h3> <p>Types:</p>    <pre>MatchSpec = (MatchSpecList :: trace_match_spec()) | boolean()
trace_match_spec() = 
    [{[term()] | '_' | match_variable(), [term()], [term()]}]
match_variable() = atom()</pre>
<p class="REFBODY"> Approximation of '$1' | '$2' | '$3' | ... </p>  
<p>Sets trace pattern for <strong>message sending</strong>. Must be combined with <code class="bold_code"><a href="#trace-3"><span class="code">erlang:trace/3</span></a></code> to set the <code class="code">send</code> trace flag for one or more processes. By default all messages sent from <code class="code">send</code> traced processes are traced. To limit traced send events based on the message content, the sender and/or the receiver, use <code class="code">erlang:trace_pattern/3</code>.</p> <p>Argument <code class="code">MatchSpec</code> can take the following forms:</p> <dl> <dt><strong><code class="code">MatchSpecList</code></strong></dt> <dd> <p>A list of match specifications. The matching is done on the list <code class="code">[Receiver, Msg]</code>. <code class="code">Receiver</code> is the process or port identity of the receiver and <code class="code">Msg</code> is the message term. The pid of the sending process can be accessed with the guard function <code class="code">self/0</code>. An empty list is the same as <code class="code">true</code>. For more information, see section <code class="bold_code">Match Specifications in Erlang</code> in the User's Guide.</p> </dd> <dt><strong><code class="code">true</code></strong></dt> <dd> <p>Enables tracing for all sent messages (from <code class="code">send</code> traced processes). Any match specification is removed. <strong>This is the default</strong>.</p> </dd> <dt><strong><code class="code">false</code></strong></dt> <dd> <p>Disables tracing for all sent messages. Any match specification is removed.</p> </dd> </dl> <p>Argument <code class="code">FlagList</code> must be <code class="code">[]</code> for send tracing.</p> <p>The return value is always <code class="code">1</code>.</p> <p>Examples:</p> <p>Only trace messages to a specific process <code class="code">Pid</code>:</p> <div class="example"><pre>
&gt; erlang:trace_pattern(send, [{[Pid, '_'],[],[]}], []).
1</pre></div> <p>Only trace messages matching <code class="code">{reply, _}</code>:</p> <div class="example"><pre>
&gt; erlang:trace_pattern(send, [{['_', {reply,'_'}],[],[]}], []).
1</pre></div> <p>Only trace messages sent to the sender itself:</p> <div class="example"><pre>
&gt; erlang:trace_pattern(send, [{['$1', '_'],[{'=:=','$1',{self}}],[]}], []).
1</pre></div> <p>Only trace messages sent to other nodes:</p> <div class="example"><pre>
&gt; erlang:trace_pattern(send, [{['$1', '_'],[{'=/=',{node,'$1'},{node}}],[]}], []).
1</pre></div> <div class="note"> <div class="label">Note</div> <div class="content">

<p>A match specification for <code class="code">send</code> trace can use all guard and body functions except <code class="code">caller</code>.</p> </div> </div>  <h3 class="code">erlang:trace_pattern(MFA :: 'receive', MatchSpec, FlagList :: []) -&gt;<br>                        integer() &gt;= 0</h3> <p>Types:</p>    <pre>MatchSpec = (MatchSpecList :: trace_match_spec()) | boolean()
trace_match_spec() = 
    [{[term()] | '_' | match_variable(), [term()], [term()]}]
match_variable() = atom()</pre>
<p class="REFBODY"> Approximation of '$1' | '$2' | '$3' | ... </p>  
<p>Sets trace pattern for <strong>message receiving</strong>. Must be combined with <code class="bold_code"><a href="#trace-3"><span class="code">erlang:trace/3</span></a></code> to set the <code class="code">'receive'</code> trace flag for one or more processes. By default all messages received by <code class="code">'receive'</code> traced processes are traced. To limit traced receive events based on the message content, the sender and/or the receiver, use <code class="code">erlang:trace_pattern/3</code>.</p> <p>Argument <code class="code">MatchSpec</code> can take the following forms:</p> <dl> <dt><strong><code class="code">MatchSpecList</code></strong></dt> <dd> <p>A list of match specifications. The matching is done on the list <code class="code">[Node, Sender, Msg]</code>. <code class="code">Node</code> is the node name of the sender. <code class="code">Sender</code> is the process or port identity of the sender, or the atom <code class="code">undefined</code> if the sender is not known (which can be the case for remote senders). <code class="code">Msg</code> is the message term. The pid of the receiving process can be accessed with the guard function <code class="code">self/0</code>. An empty list is the same as <code class="code">true</code>. For more information, see section <code class="bold_code">Match Specifications in Erlang</code> in the User's Guide.</p> </dd> <dt><strong><code class="code">true</code></strong></dt> <dd> <p>Enables tracing for all received messages (to <code class="code">'receive'</code> traced processes). Any match specification is removed. <strong>This is the default</strong>.</p> </dd> <dt><strong><code class="code">false</code></strong></dt> <dd> <p>Disables tracing for all received messages. Any match specification is removed.</p> </dd> </dl> <p>Argument <code class="code">FlagList</code> must be <code class="code">[]</code> for receive tracing.</p> <p>The return value is always <code class="code">1</code>.</p> <p>Examples:</p> <p>Only trace messages from a specific process <code class="code">Pid</code>:</p> <div class="example"><pre>
&gt; erlang:trace_pattern('receive', [{['_',Pid, '_'],[],[]}], []).
1</pre></div> <p>Only trace messages matching <code class="code">{reply, _}</code>:</p> <div class="example"><pre>
&gt; erlang:trace_pattern('receive', [{['_','_', {reply,'_'}],[],[]}], []).
1</pre></div> <p>Only trace messages from other nodes:</p> <div class="example"><pre>
&gt; erlang:trace_pattern('receive', [{['$1', '_', '_'],[{'=/=','$1',{node}}],[]}], []).
1</pre></div> <div class="note"> <div class="label">Note</div> <div class="content">

<p>A match specification for <code class="code">'receive'</code> trace can use all guard and body functions except <code class="code">caller</code>, <code class="code">is_seq_trace</code>, <code class="code">get_seq_token</code>, <code class="code">set_seq_token</code>, <code class="code">enable_trace</code>, <code class="code">disable_trace</code>, <code class="code">trace</code>, <code class="code">silent</code>, and <code class="code">process_dump</code>.</p> </div> </div>  <h3 class="code">erlang:trace_pattern(MFA, MatchSpec, FlagList) -&gt;<br>                        integer() &gt;= 0</h3> <p>Types:</p>        <pre>MFA = trace_pattern_mfa()
MatchSpec = 
    (MatchSpecList :: trace_match_spec()) |
    boolean() |
    restart |
    pause
FlagList = [trace_pattern_flag()]
trace_pattern_mfa() = {atom(), atom(), arity() | '_'} | on_load
trace_match_spec() = 
    [{[term()] | '_' | match_variable(), [term()], [term()]}]
trace_pattern_flag() = 
    global |
    local |
    meta |
    {meta, Pid :: pid()} |
    {meta, TracerModule :: module(), TracerState :: term()} |
    call_count |
    call_time
match_variable() = atom()</pre>
<p class="REFBODY"> Approximation of '$1' | '$2' | '$3' | ... </p>  
<p>Enables or disables <strong>call tracing</strong> for one or more functions. Must be combined with <code class="bold_code"><a href="#trace-3"><span class="code">erlang:trace/3</span></a></code> to set the <code class="code">call</code> trace flag for one or more processes.</p> <p>Conceptually, call tracing works as follows. Inside the Erlang virtual machine, a set of processes and a set of functions are to be traced. If a traced process calls a traced function, the trace action is taken. Otherwise, nothing happens.</p> <p>To add or remove one or more processes to the set of traced processes, use <code class="bold_code"><a href="#trace-3"><span class="code">erlang:trace/3</span></a></code>.</p> <p>To add or remove functions to the set of traced functions, use <code class="code">erlang:trace_pattern/3</code>.</p> <p>The BIF <code class="code">erlang:trace_pattern/3</code> can also add match specifications to a function. A match specification comprises a pattern that the function arguments must match, a guard expression that must evaluate to <code class="code">true</code>, and an action to be performed. The default action is to send a trace message. If the pattern does not match or the guard fails, the action is not executed.</p> <p>Argument <code class="code">MFA</code> is to be a tuple, such as <code class="code">{Module, Function, Arity}</code>, or the atom <code class="code">on_load</code> (described below). It can be the module, function, and arity for a function (or a BIF in any module). The atom <code class="code">'_'</code> can be used as a wildcard in any of the following ways:</p> <dl> <dt><strong><code class="code">{Module,Function,'_'}</code></strong></dt> <dd> <p>All functions of any arity named <code class="code">Function</code> in module <code class="code">Module</code>.</p> </dd> <dt><strong><code class="code">{Module,'_','_'}</code></strong></dt> <dd> <p>All functions in module <code class="code">Module</code>.</p> </dd> <dt><strong><code class="code">{'_','_','_'}</code></strong></dt> <dd> <p>All functions in all loaded modules.</p> </dd> </dl> <p>Other combinations, such as <code class="code">{Module,'_',Arity}</code>, are not allowed. Local functions match wildcards only if option <code class="code">local</code> is in <code class="code">FlagList</code>.</p> <p>If argument <code class="code">MFA</code> is the atom <code class="code">on_load</code>, the match specification and flag list are used on all modules that are newly loaded.</p> <p>Argument <code class="code">MatchSpec</code> can take the following forms:</p> <dl> <dt><strong><code class="code">false</code></strong></dt> <dd> <p>Disables tracing for the matching functions. Any match specification is removed.</p> </dd> <dt><strong><code class="code">true</code></strong></dt> <dd> <p>Enables tracing for the matching functions. Any match specification is removed.</p> </dd> <dt><strong><code class="code">MatchSpecList</code></strong></dt> <dd> <p>A list of match specifications. An empty list is equivalent to <code class="code">true</code>. For a description of match specifications, see section <code class="bold_code">Match Specifications in Erlang</code> in the User's Guide.</p> </dd> <dt><strong><code class="code">restart</code></strong></dt> <dd> <p>For the <code class="code">FlagList</code> options <code class="code">call_count</code> and <code class="code">call_time</code>: restarts the existing counters. The behavior is undefined for other <code class="code">FlagList</code> options.</p> </dd> <dt><strong><code class="code">pause</code></strong></dt> <dd> <p>For the <code class="code">FlagList</code> options <code class="code">call_count</code> and <code class="code">call_time</code>: pauses the existing counters. The behavior is undefined for other <code class="code">FlagList</code> options.</p> </dd> </dl> <p>Parameter <code class="code">FlagList</code> is a list of options. The following are the valid options:</p> <dl> <dt><strong><code class="code">global</code></strong></dt> <dd> <p>Turns on or off call tracing for global function calls (that is, calls specifying the module explicitly). Only exported functions match and only global calls generate trace messages. <strong>This is the default</strong>.</p> </dd> <dt><strong><code class="code">local</code></strong></dt> <dd> <p>Turns on or off call tracing for all types of function calls. Trace messages are sent whenever any of the specified functions are called, regardless of how they are called. If flag <code class="code">return_to</code> is set for the process, a <code class="code">return_to</code> message is also sent when this function returns to its caller.</p> </dd> <dt><strong><code class="code">meta | {meta, Pid} | {meta, TracerModule, TracerState}</code> </strong></dt> <dd> <p>Turns on or off meta-tracing for all types of function calls. Trace messages are sent to the tracer whenever any of the specified functions are called. If no tracer is specified, <code class="code">self()</code> is used as a default tracer process.</p> <p>Meta-tracing traces all processes and does not care about the process trace flags set by <code class="code">erlang:trace/3</code>, the trace flags are instead fixed to <code class="code">[call, timestamp]</code>.</p> <p>The match specification function <code class="code">{return_trace}</code> works with meta-trace and sends its trace message to the same tracer.</p> </dd> <dt><strong><code class="code">call_count</code></strong></dt> <dd> <p>Starts (<code class="code">MatchSpec == true</code>) or stops (<code class="code">MatchSpec == false</code>) call count tracing for all types of function calls. For every function, a counter is incremented when the function is called, in any process. No process trace flags need to be activated.</p> <p>If call count tracing is started while already running, the count is restarted from zero. To pause running counters, use <code class="code">MatchSpec == pause</code>. Paused and running counters can be restarted from zero with <code class="code">MatchSpec == restart</code>.</p> <p>To read the counter value, use <code class="bold_code"><a href="#trace_info-2"><span class="code">erlang:trace_info/2</span></a></code>.</p> </dd> <dt><strong><code class="code">call_time</code></strong></dt> <dd> <p>Starts (<code class="code">MatchSpec == true</code>) or stops (<code class="code">MatchSpec == false</code>) call time tracing for all types of function calls. For every function, a counter is incremented when the function is called. Time spent in the function is accumulated in two other counters, seconds and microseconds. The counters are stored for each call traced process.</p> <p>If call time tracing is started while already running, the count and time restart from zero. To pause running counters, use <code class="code">MatchSpec == pause</code>. Paused and running counters can be restarted from zero with <code class="code">MatchSpec == restart</code>.</p> <p>To read the counter value, use <code class="bold_code"><a href="#trace_info-2"><span class="code">erlang:trace_info/2</span></a></code>.</p> </dd> </dl> <p>The options <code class="code">global</code> and <code class="code">local</code> are mutually exclusive, and <code class="code">global</code> is the default (if no options are specified). The options <code class="code">call_count</code> and <code class="code">meta</code> perform a kind of local tracing, and cannot be combined with <code class="code">global</code>. A function can be globally or locally traced. If global tracing is specified for a set of functions, then local, meta, call time, and call count tracing for the matching set of local functions is disabled, and conversely.</p> <p>When disabling trace, the option must match the type of trace set on the function. That is, local tracing must be disabled with option <code class="code">local</code> and global tracing with option <code class="code">global</code> (or no option), and so on.</p> <p>Part of a match specification list cannot be changed directly. If a function has a match specification, it can be replaced with a new one. To change an existing match specification, use the BIF <code class="bold_code"><a href="#trace_info-2"><span class="code">erlang:trace_info/2</span></a></code> to retrieve the existing match specification.</p> <p>Returns the number of functions matching argument <code class="code">MFA</code>. This is zero if none matched.</p>  <h3 id="trunc-1" class="code">trunc(Number) -&gt; integer()</h3> <p>Types:</p>   <pre>Number = number()</pre>

<p>Returns an integer by truncating <code class="code">Number</code>, for example:</p> <div class="example"><pre>
&gt; trunc(5.5).
5</pre></div> <p>Allowed in guard tests.</p>  <h3 id="tuple_size-1" class="code">tuple_size(Tuple) -&gt; integer() &gt;= 0</h3> <p>Types:</p>   <pre>Tuple = tuple()</pre>

<p>Returns an integer that is the number of elements in <code class="code">Tuple</code>, for example:</p> <div class="example"><pre>
&gt; tuple_size({morni, mulle, bwange}).
3</pre></div> <p>Allowed in guard tests.</p>  <h3 id="tuple_to_list-1" class="code">tuple_to_list(Tuple) -&gt; [term()]</h3> <p>Types:</p>   <pre>Tuple = tuple()</pre>

<p>Returns a list corresponding to <code class="code">Tuple</code>. <code class="code">Tuple</code> can contain any Erlang terms. Example:</p> <div class="example"><pre>
&gt; tuple_to_list({share, {'Ericsson_B', 163}}).
[share,{'Ericsson_B',163}]</pre></div>  <h3 id="unique_integer-0" class="code">erlang:unique_integer() -&gt; integer()</h3> 
<p>Generates and returns an <code class="bold_code">integer unique on current runtime system instance</code>. The same as calling <code class="bold_code"><a href="#unique_integer-1"><span class="code">erlang:unique_integer([])</span></a></code>.</p>  <h3 id="unique_integer-1" class="code">erlang:unique_integer(ModifierList) -&gt; integer()</h3> <p>Types:</p>    <pre>ModifierList = [Modifier]
Modifier = positive | monotonic</pre>

<p>Generates and returns an <code class="bold_code">integer unique on current runtime system instance</code>. The integer is unique in the sense that this BIF, using the same set of modifiers, does not return the same integer more than once on the current runtime system instance. Each integer value can of course be constructed by other means.</p> <p>By default, when <code class="code">[]</code> is passed as <code class="code">ModifierList</code>, both negative and positive integers can be returned. This to use the range of integers that do not need heap memory allocation as much as possible. By default the returned integers are also only guaranteed to be unique, that is, any returned integer can be smaller or larger than previously returned integers.</p> <p><code class="code">Modifier</code>s:</p> <dl> <dt><strong>positive</strong></dt> <dd> <p>Returns only positive integers.</p> <p>Notice that by passing the <code class="code">positive</code> modifier you will get heap allocated integers (bignums) quicker.</p> </dd> <dt><strong>monotonic</strong></dt> <dd> <p>Returns <code class="bold_code"><a href="../time_correction/#Strictly_Monotonically_Increasing">strictly monotonically increasing</a></code> integers corresponding to creation time. That is, the integer returned is always larger than previously returned integers on the current runtime system instance.</p> <p>These values can be used to determine order between events on the runtime system instance. That is, if both <code class="code">X = erlang:unique_integer([monotonic])</code> and <code class="code">Y = erlang:unique_integer([monotonic])</code> are executed by different processes (or the same process) on the same runtime system instance and <code class="code">X &lt; Y</code>, we know that <code class="code">X</code> was created before <code class="code">Y</code>.</p> <div class="warning"> <div class="label">Warning</div> <div class="content">

<p>Strictly monotonically increasing values are inherently quite expensive to generate and scales poorly. This is because the values need to be synchronized between CPU cores. That is, do not pass the <code class="code">monotonic</code> modifier unless you really need strictly monotonically increasing values.</p> </div> </div> </dd> </dl> <p>All valid <code class="code">Modifier</code>s can be combined. Repeated (valid) <code class="code">Modifier</code>s in the <code class="code">ModifierList</code> are ignored.</p> <div class="note"> <div class="label">Note</div> <div class="content">

<p>The set of integers returned by <code class="code">erlang:unique_integer/1</code> using different sets of <code class="code">Modifier</code>s <strong>will overlap</strong>. For example, by calling <code class="code">unique_integer([monotonic])</code>, and <code class="code">unique_integer([positive, monotonic])</code> repeatedly, you will eventually see some integers that are returned by both calls.</p> </div> </div> <p>Failures:</p> <dl> <dt><strong><code class="code">badarg</code></strong></dt> <dd>if <code class="code">ModifierList</code> is not a proper list.</dd> <dt><strong><code class="code">badarg</code></strong></dt> <dd>if <code class="code">Modifier</code> is not a valid modifier.</dd> </dl>  <h3 id="universaltime-0" class="code">erlang:universaltime() -&gt; DateTime</h3> <p>Types:</p>   <pre>DateTime = calendar:datetime()</pre>

<p>Returns the current date and time according to Universal Time Coordinated (UTC) in the form <code class="code">{{Year, Month, Day}, {Hour, Minute, Second}}</code> if supported by the underlying OS. Otherwise <code class="code">erlang:universaltime()</code> is equivalent to <code class="code">erlang:localtime()</code>. Example:</p> <div class="example"><pre>
&gt; erlang:universaltime().
{{1996,11,6},{14,18,43}}</pre></div>  <h3 id="universaltime_to_localtime-1" class="code">erlang:universaltime_to_localtime(Universaltime) -&gt; Localtime</h3> <p>Types:</p>    <pre>Localtime = Universaltime = calendar:datetime()</pre>

<p>Converts Universal Time Coordinated (UTC) date and time to local date and time in the form <code class="code">{{Year, Month, Day}, {Hour, Minute, Second}}</code> if supported by the underlying OS. Otherwise no conversion is done, and <code class="code">Universaltime</code> is returned. Example:</p> <div class="example"><pre>
&gt; erlang:universaltime_to_localtime({{1996,11,6},{14,18,43}}).
{{1996,11,7},{15,18,43}}</pre></div> <p>Failure: <code class="code">badarg</code> if <code class="code">Universaltime</code> denotes an invalid date and time.</p>  <h3 id="unlink-1" class="code">unlink(Id) -&gt; true</h3> <p>Types:</p>   <pre>Id = pid() | port()</pre>

<p>Removes the link, if there is one, between the calling process and the process or port referred to by <code class="code">Id</code>.</p> <p>Returns <code class="code">true</code> and does not fail, even if there is no link to <code class="code">Id</code>, or if <code class="code">Id</code> does not exist.</p> <p>Once <code class="code">unlink(Id)</code> has returned, it is guaranteed that the link between the caller and the entity referred to by <code class="code">Id</code> has no effect on the caller in the future (unless the link is setup again). If the caller is trapping exits, an <code class="code">{'EXIT', Id, _}</code> message from the link can have been placed in the caller's message queue before the call.</p> <p>Notice that the <code class="code">{'EXIT', Id, _}</code> message can be the result of the link, but can also be the result of <code class="code">Id</code> calling <code class="code">exit/2</code>. Therefore, it <strong>can</strong> be appropriate to clean up the message queue when trapping exits after the call to <code class="code">unlink(Id)</code>, as follows:</p> <div class="example"><pre>
unlink(Id),
receive
    {'EXIT', Id, _} -&gt;
        true
after 0 -&gt;
        true
end</pre></div> <div class="note"> <div class="label">Note</div> <div class="content">

<p>Before Erlang/OTP R11B (ERTS 5.5) <code class="code">unlink/1</code> behaved completely asynchronously, that is, the link was active until the "unlink signal" reached the linked entity. This had an undesirable effect, as you could never know when you were guaranteed <strong>not</strong> to be effected by the link.</p> <p>The current behavior can be viewed as two combined operations: asynchronously send an "unlink signal" to the linked entity and ignore any future results of the link.</p> </div> </div>  <h3 id="unregister-1" class="code">unregister(RegName) -&gt; true</h3> <p>Types:</p>   <pre>RegName = atom()</pre>

<p>Removes the registered name <code class="code">RegName</code> associated with a process identifier or a port identifier, for example:</p> <div class="example"><pre>
&gt; unregister(db).
true</pre></div> <p>Users are advised not to unregister system processes.</p> <p>Failure: <code class="code">badarg</code> if <code class="code">RegName</code> is not a registered name.</p>  <h3 id="whereis-1" class="code">whereis(RegName) -&gt; pid() | port() | undefined</h3> <p>Types:</p>   <pre>RegName = atom()</pre>

<p>Returns the process identifier or port identifier with the registered name <code class="code">RegName</code>. Returns <code class="code">undefined</code> if the name is not registered. Example:</p> <div class="example"><pre>
&gt; whereis(db).
&lt;0.43.0&gt;</pre></div>  <h3 id="yield-0" class="code">erlang:yield() -&gt; true</h3> 
<p>Voluntarily lets other processes (if any) get a chance to execute. Using this function is similar to <code class="code">receive after 1 -&gt; ok end</code>, except that <code class="code">yield()</code> is faster.</p> <div class="warning"> <div class="label">Warning</div> <div class="content">

<p>There is seldom or never any need to use this BIF, especially in the SMP emulator, as other processes have a chance to run in another scheduler thread anyway. Using this BIF without a thorough grasp of how the scheduler works can cause performance degradation.</p> </div> </div>
<div class="_attribution">
  <p class="_attribution-p">
    © 1999–2016 Ericsson AB<br>Licensed under the Apache License, Version 2.0.<br>
    
  </p>
</div>

			</div>
		</div>
	</section>

	</div>
</body>
</html>
