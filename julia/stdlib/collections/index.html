
<!DOCTYPE HTML>

<html lang="en">

<head>
  <meta charset="utf-8">
  <title>Collections and Data Structures - Julia - W3cubDocs</title>
  
  <meta name="description" content=" Sequential iteration is implemented by the methods start(), done(), and next(). The general for loop&#58; ">
  <meta name="keywords" content="collections, and, data, structures, -, julia">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="http://docs.w3cub.com/julia/stdlib/collections/">
  <link href="/favicon.png" rel="icon">
  <link type="text/css" rel="stylesheet" href="/assets/application-50364fff564ce3b6327021805f3f00e2957b441cf27f576a7dd4ff63bbc47047.css">
  <script type="text/javascript" src="/assets/application-db64bfd54ceb42be11af7995804cf4902548419ceb79d509b0b7d62c22d98e6f.js"></script>
  <script src="/json/julia.js"></script>
  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-71174418-1']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>


</head>

<body>
	<div class="_app">
	<header class="_header">
  
  <form class="_search">
    <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
    <a class="_search-clear"></a>
    <div class="_search-tag"></div>
  </form>
  
  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/julia/" class="_nav-link" title="" style="margin-left:0;">Julia</a></span>
  
  <nav class="_nav">
    <a href="/app/" class="_nav-link ">App</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		<div class="_list">
			
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<div class="_page _sphinx_simple">
				
<h1>Collections and Data Structures</h1>  <h2 id="stdlib-collections-iteration">Iteration</h2> <p id="iteration">Sequential iteration is implemented by the methods <a class="reference internal" href="#Base.start" title="Base.start"><code>start()</code></a>, <a class="reference internal" href="#Base.done" title="Base.done"><code>done()</code></a>, and <a class="reference internal" href="#Base.next" title="Base.next"><code>next()</code></a>. The general <code>for</code> loop:</p> <pre data-language="julia">for i = I   # or  "for i in I"
    # body
end
</pre> <p>is translated into:</p> <pre data-language="julia">state = start(I)
while !done(I, state)
    (i, state) = next(I, state)
    # body
end
</pre> <p>The <code>state</code> object may be anything, and should be chosen appropriately for each iterable type. See the <a class="reference internal" href="../../manual/interfaces/#man-interfaces-iteration"><span>manual section on the iteration interface</span></a> for more details about defining a custom iterable type.</p> <dl class="function"> <dt id="Base.start">
<code>start(iter) → state</code> </dt> <dd>
<p>Get initial iteration state for an iterable object.</p> </dd>
</dl> <dl class="function"> <dt id="Base.done">
<code>done(iter, state) → Bool</code> </dt> <dd>
<p>Test whether we are done iterating.</p> </dd>
</dl> <dl class="function"> <dt id="Base.next">
<code>next(iter, state) → item, state</code> </dt> <dd>
<p>For a given iterable object and iteration state, return the current item and the next iteration state.</p> </dd>
</dl> <dl class="function"> <dt id="Base.zip">
<code>zip(iters...)</code> </dt> <dd>
<p>For a set of iterable objects, returns an iterable of tuples, where the <code>i</code>th tuple contains the <code>i</code>th component of each input iterable.</p> <p>Note that <a class="reference internal" href="#Base.zip" title="Base.zip"><code>zip()</code></a> is its own inverse: <code>collect(zip(zip(a...)...)) == collect(a)</code>.</p> <pre data-language="julia">julia&gt; a = 1:5
1:5

julia&gt; b = ["e","d","b","c","a"]
5-element Array{String,1}:
 "e"
 "d"
 "b"
 "c"
 "a"

julia&gt; c = zip(a,b)
Base.Zip2{UnitRange{Int64},Array{String,1}}(1:5,String["e","d","b","c","a"])

julia&gt; length(c)
5

julia&gt; first(c)
(1,"e")
</pre> </dd>
</dl> <dl class="function"> <dt id="Base.enumerate">
<code>enumerate(iter)</code> </dt> <dd>
<p>An iterator that yields <code>(i, x)</code> where <code>i</code> is a counter starting at 1, and <code>x</code> is the <code>i</code>th value from the given iterator. It’s useful when you need not only the values <code>x</code> over which you are iterating, but also the number of iterations so far. Note that <code>i</code> may not be valid for indexing <code>iter</code>; it’s also possible that <code>x != iter[i]</code>, if <code>iter</code> has indices that do not start at 1.</p> <pre data-language="julia">julia&gt; a = ["a", "b", "c"];

julia&gt; for (index, value) in enumerate(a)
           println("$index $value")
       end
1 a
2 b
3 c
</pre> </dd>
</dl> <dl class="function"> <dt id="Base.rest">
<code>rest(iter, state)</code> </dt> <dd>
<p>An iterator that yields the same elements as <code>iter</code>, but starting at the given <code>state</code>.</p> </dd>
</dl> <dl class="function"> <dt id="Base.countfrom">
<code>countfrom(start=1, step=1)</code> </dt> <dd>
<p>An iterator that counts forever, starting at <code>start</code> and incrementing by <code>step</code>.</p> </dd>
</dl> <dl class="function"> <dt id="Base.take">
<code>take(iter, n)</code> </dt> <dd>
<p>An iterator that generates at most the first <code>n</code> elements of <code>iter</code>.</p> <pre data-language="julia">julia&gt; a = 1:2:11
1:2:11

julia&gt; collect(a)
6-element Array{Int64,1}:
  1
  3
  5
  7
  9
 11

julia&gt; collect(take(a,3))
3-element Array{Int64,1}:
 1
 3
 5
</pre> </dd>
</dl> <dl class="function"> <dt id="Base.drop">
<code>drop(iter, n)</code> </dt> <dd>
<p>An iterator that generates all but the first <code>n</code> elements of <code>iter</code>.</p> <pre data-language="julia">julia&gt; a = 1:2:11
1:2:11

julia&gt; collect(a)
6-element Array{Int64,1}:
  1
  3
  5
  7
  9
 11

julia&gt; collect(drop(a,4))
2-element Array{Int64,1}:
  9
 11
</pre> </dd>
</dl> <dl class="function"> <dt id="Base.cycle">
<code>cycle(iter)</code> </dt> <dd>
<p>An iterator that cycles through <code>iter</code> forever.</p> </dd>
</dl> <dl class="function"> <dt id="Base.repeated">
<code>repeated(x[, n::Int])</code> </dt> <dd>
<p>An iterator that generates the value <code>x</code> forever. If <code>n</code> is specified, generates <code>x</code> that many times (equivalent to <code>take(repeated(x), n)</code>).</p> </dd>
</dl> <dl class="function"> <dt id="Base.iteratorsize">
<code>iteratorsize(itertype::Type) → IteratorSize</code> </dt> <dd>
<p>Given the type of an iterator, returns one of the following values:</p> <ul class="simple"> <li>
<code>SizeUnknown()</code> if the length (number of elements) cannot be determined in advance.</li> <li>
<code>HasLength()</code> if there is a fixed, finite length.</li> <li>
<code>HasShape()</code> if there is a known length plus a notion of multidimensional shape (as for an array). In this case the <code>size</code> function is valid for the iterator.</li> <li>
<code>IsInfinite()</code> if the iterator yields values forever.</li> </ul> <p>The default value (for iterators that do not define this function) is <code>HasLength()</code>. This means that most iterators are assumed to implement <code>length</code>.</p> <p>This trait is generally used to select between algorithms that pre-allocate space for their result, and algorithms that resize their result incrementally.</p> </dd>
</dl> <dl class="function"> <dt id="Base.iteratoreltype">
<code>iteratoreltype(itertype::Type) → IteratorEltype</code> </dt> <dd>
<p>Given the type of an iterator, returns one of the following values:</p> <ul class="simple"> <li>
<code>EltypeUnknown()</code> if the type of elements yielded by the iterator is not known in advance.</li> <li>
<code>HasEltype()</code> if the element type is known, and <code>eltype</code> would return a meaningful value.</li> </ul> <p><code>HasEltype()</code> is the default, since iterators are assumed to implement <code>eltype</code>.</p> <p>This trait is generally used to select between algorithms that pre-allocate a specific type of result, and algorithms that pick a result type based on the types of yielded values.</p> </dd>
</dl> <p>Fully implemented by:</p> <ul class="simple"> <li><code>Range</code></li> <li><code>UnitRange</code></li> <li><code>Tuple</code></li> <li><code>Number</code></li> <li><code>AbstractArray</code></li> <li><a class="reference internal" href="#Base.IntSet" title="Base.IntSet"><code>IntSet</code></a></li> <li><code>ObjectIdDict</code></li> <li><a class="reference internal" href="#Base.Dict" title="Base.Dict"><code>Dict</code></a></li> <li><code>WeakKeyDict</code></li> <li><code>EachLine</code></li> <li><code>AbstractString</code></li> <li><a class="reference internal" href="#Base.Set" title="Base.Set"><code>Set</code></a></li> <li><a class="reference internal" href="../parallel/#Base.Task" title="Base.Task"><code>Task</code></a></li> </ul>   <h2 id="general-collections">General Collections</h2> <dl class="function"> <dt id="Base.isempty">
<code>isempty(collection) → Bool</code> </dt> <dd>
<p>Determine whether a collection is empty (has no elements).</p> <pre data-language="julia">julia&gt; isempty([])
true

julia&gt; isempty([1 2 3])
false
</pre> </dd>
</dl> <dl class="function"> <dt id="Base.empty!">
<code>empty!(collection) → collection</code> </dt> <dd>
<p>Remove all elements from a <code>collection</code>.</p> </dd>
</dl> <dl class="function"> <dt id="Base.length">
<code>length(collection) → Integer</code> </dt> <dd>
<p>For ordered, indexable collections, the maximum index <code>i</code> for which <code>getindex(collection, i)</code> is valid. For unordered collections, the number of elements.</p> </dd>
</dl> <dl class="function"> <dt id="Base.endof">
<code>endof(collection) → Integer</code> </dt> <dd>
<p>Returns the last index of the collection.</p> <pre data-language="julia">julia&gt; endof([1,2,4])
3
</pre> </dd>
</dl> <p>Fully implemented by:</p> <ul class="simple"> <li><code>Range</code></li> <li><code>UnitRange</code></li> <li><code>Tuple</code></li> <li><code>Number</code></li> <li><code>AbstractArray</code></li> <li><a class="reference internal" href="#Base.IntSet" title="Base.IntSet"><code>IntSet</code></a></li> <li><a class="reference internal" href="#Base.Dict" title="Base.Dict"><code>Dict</code></a></li> <li><code>WeakKeyDict</code></li> <li><code>AbstractString</code></li> <li><a class="reference internal" href="#Base.Set" title="Base.Set"><code>Set</code></a></li> </ul>   <h2 id="iterable-collections">Iterable Collections</h2> <dl class="function"> <dt id="Base.in">
<code>in(item, collection) → Bool</code> </dt> <dt id="Base.∈">
<code>∈(item, collection) → Bool</code> </dt> <dt id="Base.∋">
<code>∋(collection, item) → Bool</code> </dt> <dt id="Base.∉">
<code>∉(item, collection) → Bool</code> </dt> <dt id="Base.∌">
<code>∌(collection, item) → Bool</code> </dt> <dd>
<p>Determine whether an item is in the given collection, in the sense that it is <code>==</code> to one of the values generated by iterating over the collection. Some collections need a slightly different definition; for example <a class="reference internal" href="#Base.Set" title="Base.Set"><code>Set</code></a>s check whether the item <a class="reference internal" href="../base/#Base.isequal" title="Base.isequal"><code>isequal()</code></a> to one of the elements. <a class="reference internal" href="#Base.Dict" title="Base.Dict"><code>Dict</code></a>s look for <code>(key,value)</code> pairs, and the key is compared using <a class="reference internal" href="../base/#Base.isequal" title="Base.isequal"><code>isequal()</code></a>. To test for the presence of a key in a dictionary, use <a class="reference internal" href="#Base.haskey" title="Base.haskey"><code>haskey()</code></a> or <code>k in keys(dict)</code>.</p> </dd>
</dl> <dl class="function"> <dt id="Base.eltype">
<code>eltype(type)</code> </dt> <dd>
<p>Determine the type of the elements generated by iterating a collection of the given <code>type</code>. For associative collection types, this will be a <code>Pair{KeyType,ValType}</code>. The definition <code>eltype(x) = eltype(typeof(x))</code> is provided for convenience so that instances can be passed instead of types. However the form that accepts a type argument should be defined for new types.</p> </dd>
</dl> <dl class="function"> <dt id="Base.indexin">
<code>indexin(a, b)</code> </dt> <dd>
<p>Returns a vector containing the highest index in <code>b</code> for each value in <code>a</code> that is a member of <code>b</code> . The output vector contains 0 wherever <code>a</code> is not a member of <code>b</code>.</p> <pre data-language="julia">julia&gt; a = ['a', 'b', 'c', 'b', 'd', 'a'];

julia&gt; b = ['a','b','c'];

julia&gt; indexin(a,b)
6-element Array{Int64,1}:
 1
 2
 3
 2
 0
 1

julia&gt; indexin(b,a)
3-element Array{Int64,1}:
 6
 4
 3
</pre> </dd>
</dl> <dl class="function"> <dt id="Base.findin">
<code>findin(a, b)</code> </dt> <dd>
<p>Returns the indices of elements in collection <code>a</code> that appear in collection <code>b</code>.</p> <pre data-language="julia">julia&gt; a = collect(1:3:15)
5-element Array{Int64,1}:
  1
  4
  7
 10
 13

julia&gt; b = collect(2:4:10)
3-element Array{Int64,1}:
  2
  6
 10

julia&gt; findin(a,b) # 10 is the only common element
1-element Array{Int64,1}:
 4
</pre> </dd>
</dl> <dl class="function"> <dt id="Base.unique">
<code>unique(itr[, dim])</code> </dt> <dd>
<p>Returns an array containing only the unique elements of the iterable <code>itr</code>, in the order that the first of each set of equivalent elements originally appears. If <code>dim</code> is specified, returns unique regions of the array <code>itr</code> along <code>dim</code>.</p> </dd>
</dl> <dl class="function"> <dt>
<code>unique(itr)</code> </dt> <dd>
<p>Returns an array containing one value from <code>itr</code> for each unique value, as determined by <code>isequal</code>.</p> </dd>
</dl> <dl class="function"> <dt>
<code>unique(f, itr)</code> </dt> <dd>
<p>Returns an array containing one value from <code>itr</code> for each unique value produced by <code>f</code> applied to elements of <code>itr</code>.</p> </dd>
</dl> <dl class="function"> <dt id="Base.allunique">
<code>allunique(itr)</code> </dt> <dd>
<p>Return <code>true</code> if all values from <code>itr</code> are distinct when compared with <code>isequal</code>.</p> </dd>
</dl> <dl class="function"> <dt id="Base.reduce">
<code>reduce(op, v0, itr)</code> </dt> <dd>
<p>Reduce the given collection <code>ìtr</code> with the given binary operator <code>op</code>. <code>v0</code> must be a neutral element for <code>op</code> that will be returned for empty collections. It is unspecified whether <code>v0</code> is used for non-empty collections.</p> <p>Reductions for certain commonly-used operators have special implementations which should be used instead: <code>maximum(itr)</code>, <code>minimum(itr)</code>, <code>sum(itr)</code>, <code>prod(itr)</code>, <code>any(itr)</code>, <code>all(itr)</code>.</p> <p>The associativity of the reduction is implementation dependent. This means that you can’t use non-associative operations like <code>-</code> because it is undefined whether <code>reduce(-,[1,2,3])</code> should be evaluated as <code>(1-2)-3</code> or <code>1-(2-3)</code>. Use <code>foldl</code> or <code>foldr</code> instead for guaranteed left or right associativity.</p> <p>Some operations accumulate error, and parallelism will also be easier if the reduction can be executed in groups. Future versions of Julia might change the algorithm. Note that the elements are not reordered if you use an ordered collection.</p> </dd>
</dl> <dl class="function"> <dt>
<code>reduce(op, itr)</code> </dt> <dd>
<p>Like <code>reduce(op, v0, itr)</code>. This cannot be used with empty collections, except for some special cases (e.g. when <code>op</code> is one of <code>+</code>, <code>*</code>, <code>max</code>, <code>min</code>, <code>&amp;</code>, <code>|</code>) when Julia can determine the neutral element of <code>op</code>.</p> </dd>
</dl> <dl class="function"> <dt id="Base.foldl">
<code>foldl(op, v0, itr)</code> </dt> <dd>
<p>Like <a class="reference internal" href="#Base.reduce" title="Base.reduce"><code>reduce()</code></a>, but with guaranteed left associativity. <code>v0</code> will be used exactly once.</p> </dd>
</dl> <dl class="function"> <dt>
<code>foldl(op, itr)</code> </dt> <dd>
<p>Like <code>foldl(op, v0, itr)</code>, but using the first element of <code>itr</code> as <code>v0</code>. In general, this cannot be used with empty collections (see <code>reduce(op, itr)</code>).</p> </dd>
</dl> <dl class="function"> <dt id="Base.foldr">
<code>foldr(op, v0, itr)</code> </dt> <dd>
<p>Like <a class="reference internal" href="#Base.reduce" title="Base.reduce"><code>reduce()</code></a>, but with guaranteed right associativity. <code>v0</code> will be used exactly once.</p> </dd>
</dl> <dl class="function"> <dt>
<code>foldr(op, itr)</code> </dt> <dd>
<p>Like <code>foldr(op, v0, itr)</code>, but using the last element of <code>itr</code> as <code>v0</code>. In general, this cannot be used with empty collections (see <code>reduce(op, itr)</code>).</p> </dd>
</dl> <dl class="function"> <dt id="Base.maximum">
<code>maximum(itr)</code> </dt> <dd>
<p>Returns the largest element in a collection.</p> <pre data-language="julia">julia&gt; maximum(-20.5:10)
9.5

julia&gt; maximum([1,2,3])
3
</pre> </dd>
</dl> <dl class="function"> <dt>
<code>maximum(A, dims)</code> </dt> <dd>
<p>Compute the maximum value of an array over the given dimensions.</p> </dd>
</dl> <dl class="function"> <dt id="Base.maximum!">
<code>maximum!(r, A)</code> </dt> <dd>
<p>Compute the maximum value of <code>A</code> over the singleton dimensions of <code>r</code>, and write results to <code>r</code>.</p> </dd>
</dl> <dl class="function"> <dt id="Base.minimum">
<code>minimum(itr)</code> </dt> <dd>
<p>Returns the smallest element in a collection.</p> <pre data-language="julia">julia&gt; minimum(-20.5:10)
-20.5

julia&gt; minimum([1,2,3])
1
</pre> </dd>
</dl> <dl class="function"> <dt>
<code>minimum(A, dims)</code> </dt> <dd>
<p>Compute the minimum value of an array over the given dimensions.</p> </dd>
</dl> <dl class="function"> <dt id="Base.minimum!">
<code>minimum!(r, A)</code> </dt> <dd>
<p>Compute the minimum value of <code>A</code> over the singleton dimensions of <code>r</code>, and write results to <code>r</code>.</p> </dd>
</dl> <dl class="function"> <dt id="Base.extrema">
<code>extrema(itr) → Tuple</code> </dt> <dd>
<p>Compute both the minimum and maximum element in a single pass, and return them as a 2-tuple.</p> <pre data-language="julia">julia&gt; extrema(2:10)
(2,10)

julia&gt; extrema([9,pi,4.5])
(3.141592653589793,9.0)
</pre> </dd>
</dl> <dl class="function"> <dt>
<code>extrema(A, dims) → Array{Tuple}</code> </dt> <dd>
<p>Compute the minimum and maximum elements of an array over the given dimensions.</p> </dd>
</dl> <dl class="function"> <dt id="Base.indmax">
<code>indmax(itr) → Integer</code> </dt> <dd>
<p>Returns the index of the maximum element in a collection. The collection must not be empty.</p> <pre data-language="julia">julia&gt; indmax([8,0.1,-9,pi])
1
</pre> </dd>
</dl> <dl class="function"> <dt id="Base.indmin">
<code>indmin(itr) → Integer</code> </dt> <dd>
<p>Returns the index of the minimum element in a collection. The collection must not be empty.</p> <pre data-language="julia">julia&gt; indmin([8,0.1,-9,pi])
3
</pre> </dd>
</dl> <dl class="function"> <dt id="Base.findmax">
<code>findmax(itr) → (x, index)</code> </dt> <dd>
<p>Returns the maximum element and its index. The collection must not be empty.</p> <pre data-language="julia">julia&gt; findmax([8,0.1,-9,pi])
(8.0,1)
</pre> </dd>
</dl> <dl class="function"> <dt>
<code>findmax(A, region) → (maxval, index)</code> </dt> <dd>
<p>For an array input, returns the value and index of the maximum over the given region.</p> </dd>
</dl> <dl class="function"> <dt id="Base.findmin">
<code>findmin(itr) → (x, index)</code> </dt> <dd>
<p>Returns the minimum element and its index. The collection must not be empty.</p> <pre data-language="julia">julia&gt; findmin([8,0.1,-9,pi])
(-9.0,3)
</pre> </dd>
</dl> <dl class="function"> <dt>
<code>findmin(A, region) → (minval, index)</code> </dt> <dd>
<p>For an array input, returns the value and index of the minimum over the given region.</p> </dd>
</dl> <dl class="function"> <dt id="Base.findmax!">
<code>findmax!(rval, rind, A[, init=true]) → (maxval, index)</code> </dt> <dd>
<p>Find the maximum of <code>A</code> and the corresponding linear index along singleton dimensions of <code>rval</code> and <code>rind</code>, and store the results in <code>rval</code> and <code>rind</code>.</p> </dd>
</dl> <dl class="function"> <dt id="Base.findmin!">
<code>findmin!(rval, rind, A[, init=true]) → (minval, index)</code> </dt> <dd>
<p>Find the minimum of <code>A</code> and the corresponding linear index along singleton dimensions of <code>rval</code> and <code>rind</code>, and store the results in <code>rval</code> and <code>rind</code>.</p> </dd>
</dl> <dl class="function"> <dt id="Base.maxabs">
<code>maxabs(itr)</code> </dt> <dd>
<p>Compute the maximum absolute value of a collection of values.</p> <pre data-language="julia">julia&gt; maxabs([-1, 3, 4*im])
4.0
</pre> </dd>
</dl> <dl class="function"> <dt>
<code>maxabs(A, dims)</code> </dt> <dd>
<p>Compute the maximum absolute values over given dimensions.</p> </dd>
</dl> <dl class="function"> <dt id="Base.maxabs!">
<code>maxabs!(r, A)</code> </dt> <dd>
<p>Compute the maximum absolute values over the singleton dimensions of <code>r</code>, and write values to <code>r</code>.</p> </dd>
</dl> <dl class="function"> <dt id="Base.minabs">
<code>minabs(itr)</code> </dt> <dd>
<p>Compute the minimum absolute value of a collection of values.</p> <pre data-language="julia">julia&gt; minabs([-1, 3, 4*im])
1.0
</pre> </dd>
</dl> <dl class="function"> <dt>
<code>minabs(A, dims)</code> </dt> <dd>
<p>Compute the minimum absolute values over given dimensions.</p> </dd>
</dl> <dl class="function"> <dt id="Base.minabs!">
<code>minabs!(r, A)</code> </dt> <dd>
<p>Compute the minimum absolute values over the singleton dimensions of <code>r</code>, and write values to <code>r</code>.</p> </dd>
</dl> <dl class="function"> <dt id="Base.sum">
<code>sum(itr)</code> </dt> <dd>
<p>Returns the sum of all elements in a collection.</p> </dd>
</dl> <dl class="function"> <dt>
<code>sum(A, dims)</code> </dt> <dd>
<p>Sum elements of an array over the given dimensions.</p> </dd>
</dl> <dl class="function"> <dt id="Base.sum!">
<code>sum!(r, A)</code> </dt> <dd>
<p>Sum elements of <code>A</code> over the singleton dimensions of <code>r</code>, and write results to <code>r</code>.</p> </dd>
</dl> <dl class="function"> <dt>
<code>sum(f, itr)</code> </dt> <dd>
<p>Sum the results of calling function <code>f</code> on each element of <code>itr</code>.</p> </dd>
</dl> <dl class="function"> <dt id="Base.sumabs">
<code>sumabs(itr)</code> </dt> <dd>
<p>Sum absolute values of all elements in a collection. This is equivalent to <code>sum(abs(itr))</code> but faster.</p> </dd>
</dl> <dl class="function"> <dt>
<code>sumabs(A, dims)</code> </dt> <dd>
<p>Sum absolute values of elements of an array over the given dimensions.</p> </dd>
</dl> <dl class="function"> <dt id="Base.sumabs!">
<code>sumabs!(r, A)</code> </dt> <dd>
<p>Sum absolute values of elements of <code>A</code> over the singleton dimensions of <code>r</code>, and write results to <code>r</code>.</p> </dd>
</dl> <dl class="function"> <dt id="Base.sumabs2">
<code>sumabs2(itr)</code> </dt> <dd>
<p>Sum squared absolute values of all elements in a collection. This is equivalent to <code>sum(abs2(itr))</code> but faster.</p> </dd>
</dl> <dl class="function"> <dt>
<code>sumabs2(A, dims)</code> </dt> <dd>
<p>Sum squared absolute values of elements of an array over the given dimensions.</p> </dd>
</dl> <dl class="function"> <dt id="Base.sumabs2!">
<code>sumabs2!(r, A)</code> </dt> <dd>
<p>Sum squared absolute values of elements of <code>A</code> over the singleton dimensions of <code>r</code>, and write results to <code>r</code>.</p> </dd>
</dl> <dl class="function"> <dt id="Base.prod">
<code>prod(itr)</code> </dt> <dd>
<p>Returns the product of all elements of a collection.</p> </dd>
</dl> <dl class="function"> <dt>
<code>prod(A, dims)</code> </dt> <dd>
<p>Multiply elements of an array over the given dimensions.</p> </dd>
</dl> <dl class="function"> <dt id="Base.prod!">
<code>prod!(r, A)</code> </dt> <dd>
<p>Multiply elements of <code>A</code> over the singleton dimensions of <code>r</code>, and write results to <code>r</code>.</p> </dd>
</dl> <dl class="function"> <dt id="Base.any">
<code>any(itr) → Bool</code> </dt> <dd>
<p>Test whether any elements of a boolean collection are <code>true</code>.</p> </dd>
</dl> <dl class="function"> <dt>
<code>any(A, dims)</code> </dt> <dd>
<p>Test whether any values along the given dimensions of an array are <code>true</code>.</p> </dd>
</dl> <dl class="function"> <dt id="Base.any!">
<code>any!(r, A)</code> </dt> <dd>
<p>Test whether any values in <code>A</code> along the singleton dimensions of <code>r</code> are <code>true</code>, and write results to <code>r</code>.</p> </dd>
</dl> <dl class="function"> <dt id="Base.all">
<code>all(itr) → Bool</code> </dt> <dd>
<p>Test whether all elements of a boolean collection are <code>true</code>.</p> </dd>
</dl> <dl class="function"> <dt>
<code>all(A, dims)</code> </dt> <dd>
<p>Test whether all values along the given dimensions of an array are <code>true</code>.</p> </dd>
</dl> <dl class="function"> <dt id="Base.all!">
<code>all!(r, A)</code> </dt> <dd>
<p>Test whether all values in <code>A</code> along the singleton dimensions of <code>r</code> are <code>true</code>, and write results to <code>r</code>.</p> </dd>
</dl> <dl class="function"> <dt id="Base.count">
<code>count(p, itr) → Integer</code> </dt> <dd>
<p>Count the number of elements in <code>itr</code> for which predicate <code>p</code> returns <code>true</code>.</p> <pre data-language="julia">julia&gt; count(i-&gt;(4&lt;=i&lt;=6), [2,3,4,5,6])
3
</pre> </dd>
</dl> <dl class="function"> <dt>
<code>any(p, itr) → Bool</code> </dt> <dd>
<p>Determine whether predicate <code>p</code> returns <code>true</code> for any elements of <code>itr</code>.</p> <pre data-language="julia">julia&gt; any(i-&gt;(4&lt;=i&lt;=6), [3,5,7])
true
</pre> </dd>
</dl> <dl class="function"> <dt>
<code>all(p, itr) → Bool</code> </dt> <dd>
<p>Determine whether predicate <code>p</code> returns <code>true</code> for all elements of <code>itr</code>.</p> <pre data-language="julia">julia&gt; all(i-&gt;(4&lt;=i&lt;=6), [4,5,6])
true
</pre> </dd>
</dl> <dl class="function"> <dt id="Base.foreach">
<code>foreach(f, c...) → Void</code> </dt> <dd>
<p>Call function <code>f</code> on each element of iterable <code>c</code>. For multiple iterable arguments, <code>f</code> is called elementwise. <code>foreach</code> should be used instead of <code>map</code> when the results of <code>f</code> are not needed, for example in <code>foreach(println, array)</code>.</p> <pre data-language="julia">julia&gt; a = 1:3:7;

julia&gt; foreach(x-&gt;println(x^2),a)
1
16
49
</pre> </dd>
</dl> <dl class="function"> <dt id="Base.map">
<code>map(f, c...) → collection</code> </dt> <dd>
<p>Transform collection <code>c</code> by applying <code>f</code> to each element. For multiple collection arguments, apply <code>f</code> elementwise.</p> <pre data-language="julia">julia&gt; map((x) -&gt; x * 2, [1, 2, 3])
3-element Array{Int64,1}:
 2
 4
 6

julia&gt; map(+, [1, 2, 3], [10, 20, 30])
3-element Array{Int64,1}:
 11
 22
 33
</pre> </dd>
</dl> <dl class="function"> <dt id="Base.map!">
<code>map!(function, collection)</code> </dt> <dd>
<p>In-place version of <a class="reference internal" href="#Base.map" title="Base.map"><code>map()</code></a>.</p> </dd>
</dl> <dl class="function"> <dt>
<code>map!(function, destination, collection...)</code> </dt> <dd>
<p>Like <a class="reference internal" href="#Base.map" title="Base.map"><code>map()</code></a>, but stores the result in <code>destination</code> rather than a new collection. <code>destination</code> must be at least as large as the first collection.</p> </dd>
</dl> <dl class="function"> <dt id="Base.mapreduce">
<code>mapreduce(f, op, v0, itr)</code> </dt> <dd>
<p>Apply function <code>f</code> to each element in <code>itr</code>, and then reduce the result using the binary function <code>op</code>. <code>v0</code> must be a neutral element for <code>op</code> that will be returned for empty collections. It is unspecified whether <code>v0</code> is used for non-empty collections.</p> <p><a class="reference internal" href="#Base.mapreduce" title="Base.mapreduce"><code>mapreduce()</code></a> is functionally equivalent to calling <code>reduce(op, v0, map(f, itr))</code>, but will in general execute faster since no intermediate collection needs to be created. See documentation for <a class="reference internal" href="#Base.reduce" title="Base.reduce"><code>reduce()</code></a> and <a class="reference internal" href="#Base.map" title="Base.map"><code>map()</code></a>.</p> <pre data-language="julia">julia&gt; mapreduce(x-&gt;x^2, +, [1:3;]) # == 1 + 4 + 9
14
</pre> <p>The associativity of the reduction is implementation-dependent. Additionally, some implementations may reuse the return value of <code>f</code> for elements that appear multiple times in <code>itr</code>. Use <a class="reference internal" href="#Base.mapfoldl" title="Base.mapfoldl"><code>mapfoldl()</code></a> or <a class="reference internal" href="#Base.mapfoldr" title="Base.mapfoldr"><code>mapfoldr()</code></a> instead for guaranteed left or right associativity and invocation of <code>f</code> for every value.</p> </dd>
</dl> <dl class="function"> <dt>
<code>mapreduce(f, op, itr)</code> </dt> <dd>
<p>Like <code>mapreduce(f, op, v0, itr)</code>. In general, this cannot be used with empty collections (see <code>reduce(op, itr)</code>).</p> </dd>
</dl> <dl class="function"> <dt id="Base.mapfoldl">
<code>mapfoldl(f, op, v0, itr)</code> </dt> <dd>
<p>Like <a class="reference internal" href="#Base.mapreduce" title="Base.mapreduce"><code>mapreduce()</code></a>, but with guaranteed left associativity. <code>v0</code> will be used exactly once.</p> </dd>
</dl> <dl class="function"> <dt>
<code>mapfoldl(f, op, itr)</code> </dt> <dd>
<p>Like <code>mapfoldl(f, op, v0, itr)</code>, but using the first element of <code>itr</code> as <code>v0</code>. In general, this cannot be used with empty collections (see <code>reduce(op, itr)</code>).</p> </dd>
</dl> <dl class="function"> <dt id="Base.mapfoldr">
<code>mapfoldr(f, op, v0, itr)</code> </dt> <dd>
<p>Like <a class="reference internal" href="#Base.mapreduce" title="Base.mapreduce"><code>mapreduce()</code></a>, but with guaranteed right associativity. <code>v0</code> will be used exactly once.</p> </dd>
</dl> <dl class="function"> <dt>
<code>mapfoldr(f, op, itr)</code> </dt> <dd>
<p>Like <code>mapfoldr(f, op, v0, itr)</code>, but using the first element of <code>itr</code> as <code>v0</code>. In general, this cannot be used with empty collections (see <code>reduce(op, itr)</code>).</p> </dd>
</dl> <dl class="function"> <dt id="Base.first">
<code>first(coll)</code> </dt> <dd>
<p>Get the first element of an iterable collection. Returns the start point of a <code>Range</code> even if it is empty.</p> </dd>
</dl> <dl class="function"> <dt id="Base.last">
<code>last(coll)</code> </dt> <dd>
<p>Get the last element of an ordered collection, if it can be computed in O(1) time. This is accomplished by calling <a class="reference internal" href="#Base.endof" title="Base.endof"><code>endof()</code></a> to get the last index. Returns the end point of a <code>Range</code> even if it is empty.</p> </dd>
</dl> <dl class="function"> <dt id="Base.step">
<code>step(r)</code> </dt> <dd>
<p>Get the step size of a <code>Range</code> object.</p> <pre data-language="julia">julia&gt; step(1:10)
1

julia&gt; step(1:2:10)
2

julia&gt; step(2.5:0.3:10.9)
0.3

julia&gt; step(linspace(2.5,10.9,85))
0.1
</pre> </dd>
</dl> <dl class="function"> <dt id="Base.collect">
<code>collect(collection)</code> </dt> <dd>
<p>Return an <code>Array</code> of all items in a collection or iterator. For associative collections, returns <code>Pair{KeyType, ValType}</code>. If the argument is array-like or is an iterator with the <code>HasShape()</code> trait, the result will have the same shape and number of dimensions as the argument.</p> </dd>
</dl> <dl class="function"> <dt>
<code>collect(element_type, collection)</code> </dt> <dd>
<p>Return an <code>Array</code> with the given element type of all items in a collection or iterable. The result has the same shape and number of dimensions as <code>collection</code>.</p> </dd>
</dl> <dl class="function"> <dt id="Base.issubset">
<code>issubset(a, b)</code> </dt> <dt id="Base.⊆">
<code>⊆(a, b) → Bool</code> </dt> <dt id="Base.⊈">
<code>⊈(a, b) → Bool</code> </dt> <dt id="Base.⊊">
<code>⊊(a, b) → Bool</code> </dt> <dd>
<p>Determine whether every element of <code>a</code> is also in <code>b</code>, using <a class="reference internal" href="#Base.in" title="Base.in"><code>in()</code></a>.</p> </dd>
</dl> <dl class="function"> <dt id="Base.filter">
<code>filter(function, collection)</code> </dt> <dd>
<p>Return a copy of <code>collection</code>, removing elements for which <code>function</code> is <code>false</code>. For associative collections, the function is passed two arguments (key and value).</p> <pre data-language="julia">julia&gt; a = 1:10
1:10

julia&gt; filter(isodd, a)
5-element Array{Int64,1}:
 1
 3
 5
 7
 9
</pre> </dd>
</dl> <dl class="function"> <dt id="Base.filter!">
<code>filter!(function, collection)</code> </dt> <dd>
<p>Update <code>collection</code>, removing elements for which <code>function</code> is <code>false</code>. For associative collections, the function is passed two arguments (key and value).</p> </dd>
</dl>   <h2 id="indexable-collections">Indexable Collections</h2> <dl class="function"> <dt id="Base.getindex">
<code>getindex(collection, key...)</code> </dt> <dd>
<p>Retrieve the value(s) stored at the given key or index within a collection. The syntax <code>a[i,j,...]</code> is converted by the compiler to <code>getindex(a, i, j, ...)</code>.</p> </dd>
</dl> <dl class="function"> <dt id="Base.setindex!">
<code>setindex!(collection, value, key...)</code> </dt> <dd>
<p>Store the given value at the given key or index within a collection. The syntax <code>a[i,j,...] = x</code> is converted by the compiler to <code>(setindex!(a, x, i, j, ...); x)</code>.</p> </dd>
</dl> <p>Fully implemented by:</p> <ul class="simple"> <li><a class="reference internal" href="../arrays/#Base.Array" title="Base.Array"><code>Array</code></a></li> <li><code>BitArray</code></li> <li><code>AbstractArray</code></li> <li><code>SubArray</code></li> <li><code>ObjectIdDict</code></li> <li><a class="reference internal" href="#Base.Dict" title="Base.Dict"><code>Dict</code></a></li> <li><code>WeakKeyDict</code></li> <li><code>AbstractString</code></li> </ul> <p>Partially implemented by:</p> <ul class="simple"> <li><code>Range</code></li> <li><code>UnitRange</code></li> <li><code>Tuple</code></li> </ul>   <h2 id="associative-collections">Associative Collections</h2> <p><a class="reference internal" href="#Base.Dict" title="Base.Dict"><code>Dict</code></a> is the standard associative collection. Its implementation uses <a class="reference internal" href="../base/#Base.hash" title="Base.hash"><code>hash()</code></a> as the hashing function for the key, and <a class="reference internal" href="../base/#Base.isequal" title="Base.isequal"><code>isequal()</code></a> to determine equality. Define these two functions for custom types to override how they are stored in a hash table.</p> <p><code>ObjectIdDict</code> is a special hash table where the keys are always object identities.</p> <p><code>WeakKeyDict</code> is a hash table implementation where the keys are weak references to objects, and thus may be garbage collected even when referenced in a hash table.</p> <p><a class="reference internal" href="#Base.Dict" title="Base.Dict"><code>Dict</code></a>s can be created by passing pair objects constructed with <code>=&gt;()</code> to a <a class="reference internal" href="#Base.Dict" title="Base.Dict"><code>Dict</code></a> constructor: <code>Dict("A"=&gt;1, "B"=&gt;2)</code>. This call will attempt to infer type information from the keys and values (i.e. this example creates a <code>Dict{String, Int64}</code>). To explicitly specify types use the syntax <code>Dict{KeyType,ValueType}(...)</code>. For example, <code>Dict{String,Int32}("A"=&gt;1, "B"=&gt;2)</code>.</p> <p><a class="reference internal" href="#Base.Dict" title="Base.Dict"><code>Dict</code></a>s may also be created with generators. For example, <code>Dict(i =&gt; f(i) for i = 1:10)</code>.</p> <p>Given a dictionary <code>D</code>, the syntax <code>D[x]</code> returns the value of key <code>x</code> (if it exists) or throws an error, and <code>D[x] = y</code> stores the key-value pair <code>x =&gt; y</code> in <code>D</code> (replacing any existing value for the key <code>x</code>). Multiple arguments to <code>D[...]</code> are converted to tuples; for example, the syntax <code>D[x,y]</code> is equivalent to <code>D[(x,y)]</code>, i.e. it refers to the value keyed by the tuple <code>(x,y)</code>.</p> <dl class="function"> <dt id="Base.Dict">
<code>Dict([itr])</code> </dt> <dd>
<p><code>Dict{K,V}()</code> constructs a hash table with keys of type <code>K</code> and values of type <code>V</code>.</p> <p>Given a single iterable argument, constructs a <a class="reference internal" href="#Base.Dict" title="Base.Dict"><code>Dict</code></a> whose key-value pairs are taken from 2-tuples <code>(key,value)</code> generated by the argument.</p> <pre data-language="julia">julia&gt; Dict([("A", 1), ("B", 2)])
Dict{String,Int64} with 2 entries:
  "B" =&gt; 2
  "A" =&gt; 1
</pre> <p>Alternatively, a sequence of pair arguments may be passed.</p> <pre data-language="julia">julia&gt; Dict("A"=&gt;1, "B"=&gt;2)
Dict{String,Int64} with 2 entries:
  "B" =&gt; 2
  "A" =&gt; 1
</pre> </dd>
</dl> <dl class="function"> <dt id="Base.haskey">
<code>haskey(collection, key) → Bool</code> </dt> <dd>
<p>Determine whether a collection has a mapping for a given key.</p> </dd>
</dl> <dl class="function"> <dt id="Base.get">
<code>get(collection, key, default)</code> </dt> <dd>
<p>Return the value stored for the given key, or the given default value if no mapping for the key is present.</p> </dd>
</dl> <dl class="function"> <dt>
<code>get(f::Function, collection, key)</code> </dt> <dd>
<p>Return the value stored for the given key, or if no mapping for the key is present, return <code>f()</code>. Use <a class="reference internal" href="#Base.get!" title="Base.get!"><code>get!()</code></a> to also store the default value in the dictionary.</p> <p>This is intended to be called using <code>do</code> block syntax</p> <pre data-language="julia">get(dict, key) do
    # default value calculated here
    time()
end
</pre> </dd>
</dl> <dl class="function"> <dt id="Base.get!">
<code>get!(collection, key, default)</code> </dt> <dd>
<p>Return the value stored for the given key, or if no mapping for the key is present, store <code>key =&gt; default</code>, and return <code>default</code>.</p> </dd>
</dl> <dl class="function"> <dt>
<code>get!(f::Function, collection, key)</code> </dt> <dd>
<p>Return the value stored for the given key, or if no mapping for the key is present, store <code>key =&gt; f()</code>, and return <code>f()</code>.</p> <p>This is intended to be called using <code>do</code> block syntax:</p> <pre data-language="julia">get!(dict, key) do
    # default value calculated here
    time()
end
</pre> </dd>
</dl> <dl class="function"> <dt id="Base.getkey">
<code>getkey(collection, key, default)</code> </dt> <dd>
<p>Return the key matching argument <code>key</code> if one exists in <code>collection</code>, otherwise return <code>default</code>.</p> </dd>
</dl> <dl class="function"> <dt id="Base.delete!">
<code>delete!(collection, key)</code> </dt> <dd>
<p>Delete the mapping for the given key in a collection, and return the collection.</p> </dd>
</dl> <dl class="function"> <dt id="Base.pop!">
<code>pop!(collection, key[, default])</code> </dt> <dd>
<p>Delete and return the mapping for <code>key</code> if it exists in <code>collection</code>, otherwise return <code>default</code>, or throw an error if default is not specified.</p> </dd>
</dl> <dl class="function"> <dt id="Base.keys">
<code>keys(collection)</code> </dt> <dd>
<p>Return an iterator over all keys in a collection. <code>collect(keys(d))</code> returns an array of keys.</p> </dd>
</dl> <dl class="function"> <dt id="Base.values">
<code>values(collection)</code> </dt> <dd>
<p>Return an iterator over all values in a collection. <code>collect(values(d))</code> returns an array of values.</p> </dd>
</dl> <dl class="function"> <dt id="Base.merge">
<code>merge(collection, others...)</code> </dt> <dd>
<p>Construct a merged collection from the given collections. If necessary, the types of the resulting collection will be promoted to accommodate the types of the merged collections. If the same key is present in another collection, the value for that key will be the value it has in the last collection listed.</p> <pre data-language="julia">julia&gt; a = Dict("foo" =&gt; 0.0, "bar" =&gt; 42.0)
Dict{String,Float64} with 2 entries:
  "bar" =&gt; 42.0
  "foo" =&gt; 0.0

julia&gt; b = Dict("baz" =&gt; 17, "bar" =&gt; 4711)
Dict{String,Int64} with 2 entries:
  "bar" =&gt; 4711
  "baz" =&gt; 17

julia&gt; merge(a, b)
Dict{String,Float64} with 3 entries:
  "bar" =&gt; 4711.0
  "baz" =&gt; 17.0
  "foo" =&gt; 0.0

julia&gt; merge(b, a)
Dict{String,Float64} with 3 entries:
  "bar" =&gt; 42.0
  "baz" =&gt; 17.0
  "foo" =&gt; 0.0
</pre> </dd>
</dl> <dl class="function"> <dt id="Base.merge!">
<code>merge!(collection, others...)</code> </dt> <dd>
<p>Update collection with pairs from the other collections.</p> </dd>
</dl> <dl class="function"> <dt id="Base.sizehint!">
<code>sizehint!(s, n)</code> </dt> <dd>
<p>Suggest that collection <code>s</code> reserve capacity for at least <code>n</code> elements. This can improve performance.</p> </dd>
</dl> <dl class="function"> <dt id="Base.keytype">
<code>keytype(type)</code> </dt> <dd>
<p>Get the key type of an associative collection type. Behaves similarly to <code>eltype</code>.</p> </dd>
</dl> <dl class="function"> <dt id="Base.valtype">
<code>valtype(type)</code> </dt> <dd>
<p>Get the value type of an associative collection type. Behaves similarly to <code>eltype</code>.</p> </dd>
</dl> <p>Fully implemented by:</p> <ul class="simple"> <li><code>ObjectIdDict</code></li> <li><a class="reference internal" href="#Base.Dict" title="Base.Dict"><code>Dict</code></a></li> <li><code>WeakKeyDict</code></li> </ul> <p>Partially implemented by:</p> <ul class="simple"> <li><a class="reference internal" href="#Base.IntSet" title="Base.IntSet"><code>IntSet</code></a></li> <li><a class="reference internal" href="#Base.Set" title="Base.Set"><code>Set</code></a></li> <li><a class="reference internal" href="../base/#Base.EnvHash" title="Base.EnvHash"><code>EnvHash</code></a></li> <li><a class="reference internal" href="../arrays/#Base.Array" title="Base.Array"><code>Array</code></a></li> <li><code>BitArray</code></li> </ul>   <h2 id="set-like-collections">Set-Like Collections</h2> <dl class="function"> <dt id="Base.Set">
<code>Set([itr])</code> </dt> <dd>
<p>Construct a <a class="reference internal" href="#Base.Set" title="Base.Set"><code>Set</code></a> of the values generated by the given iterable object, or an empty set. Should be used instead of <a class="reference internal" href="#Base.IntSet" title="Base.IntSet"><code>IntSet</code></a> for sparse integer sets, or for sets of arbitrary objects.</p> </dd>
</dl> <dl class="function"> <dt id="Base.IntSet">
<code>IntSet([itr])</code> </dt> <dd>
<p>Construct a sorted set of positive <code>Int</code>s generated by the given iterable object, or an empty set. Implemented as a bit string, and therefore designed for dense integer sets. Only <code>Int</code>s greater than 0 can be stored. If the set will be sparse (for example holding a few very large integers), use <a class="reference internal" href="#Base.Set" title="Base.Set"><code>Set</code></a> instead.</p> </dd>
</dl> <dl class="function"> <dt id="Base.union">
<code>union(s1, s2...)</code> </dt> <dt id="Base.∪">
<code>∪(s1, s2...)</code> </dt> <dd>
<p>Construct the union of two or more sets. Maintains order with arrays.</p> </dd>
</dl> <dl class="function"> <dt id="Base.union!">
<code>union!(s, iterable)</code> </dt> <dd>
<p>Union each element of <code>iterable</code> into set <code>s</code> in-place.</p> </dd>
</dl> <dl class="function"> <dt id="Base.intersect">
<code>intersect(s1, s2...)</code> </dt> <dt id="Base.∩">
<code>∩(s1, s2)</code> </dt> <dd>
<p>Construct the intersection of two or more sets. Maintains order and multiplicity of the first argument for arrays and ranges.</p> </dd>
</dl> <dl class="function"> <dt id="Base.setdiff">
<code>setdiff(a, b)</code> </dt> <dd>
<p>Construct the set of elements in <code>a</code> but not <code>b</code>. Maintains order with arrays. Note that both arguments must be collections, and both will be iterated over. In particular, <code>setdiff(set,element)</code> where <code>element</code> is a potential member of <code>set</code>, will not work in general.</p> <pre data-language="julia">julia&gt; setdiff([1,2,3],[3,4,5])
2-element Array{Int64,1}:
 1
 2
</pre> </dd>
</dl> <dl class="function"> <dt id="Base.setdiff!">
<code>setdiff!(s, iterable)</code> </dt> <dd>
<p>Remove each element of <code>iterable</code> from set <code>s</code> in-place.</p> </dd>
</dl> <dl class="function"> <dt id="Base.symdiff">
<code>symdiff(a, b, rest...)</code> </dt> <dd>
<p>Construct the symmetric difference of elements in the passed in sets or arrays. Maintains order with arrays.</p> <pre data-language="julia">julia&gt; symdiff([1,2,3],[3,4,5],[4,5,6])
3-element Array{Int64,1}:
 1
 2
 6
</pre> </dd>
</dl> <dl class="function"> <dt id="Base.symdiff!">
<code>symdiff!(s, n)</code> </dt> <dd>
<p>The set <code>s</code> is destructively modified to toggle the inclusion of integer <code>n</code>.</p> </dd>
</dl> <dl class="function"> <dt>
<code>symdiff!(s, itr)</code> </dt> <dd>
<p>For each element in <code>itr</code>, destructively toggle its inclusion in set <code>s</code>.</p> </dd>
</dl> <dl class="function"> <dt>
<code>symdiff!(s1, s2)</code> </dt> <dd>
<p>Construct the symmetric difference of sets <code>s1</code> and <code>s2</code>, storing the result in <code>s1</code>.</p> </dd>
</dl> <dl class="function"> <dt id="Base.intersect!">
<code>intersect!(s1, s2)</code> </dt> <dd>
<p>Intersects sets <code>s1</code> and <code>s2</code> and overwrites the set <code>s1</code> with the result. If needed, <code>s1</code> will be expanded to the size of <code>s2</code>.</p> </dd>
</dl> <dl class="function"> <dt>
<code>issubset(A, S) → Bool</code> </dt> <dt>
<code>⊆(A, S) → Bool</code> </dt> <dd>
<p>Return <code>true</code> if <code>A</code> is a subset of or equal to <code>S</code>.</p> </dd>
</dl> <p>Fully implemented by:</p> <ul class="simple"> <li><a class="reference internal" href="#Base.IntSet" title="Base.IntSet"><code>IntSet</code></a></li> <li><a class="reference internal" href="#Base.Set" title="Base.Set"><code>Set</code></a></li> </ul> <p>Partially implemented by:</p> <ul class="simple"> <li><a class="reference internal" href="../arrays/#Base.Array" title="Base.Array"><code>Array</code></a></li> </ul>   <h2 id="dequeues">Dequeues</h2> <dl class="function"> <dt id="Base.push!">
<code>push!(collection, items...) → collection</code> </dt> <dd>
<p>Insert one or more <code>items</code> at the end of <code>collection</code>.</p> <pre data-language="julia">julia&gt; push!([1, 2, 3], 4, 5, 6)
6-element Array{Int64,1}:
 1
 2
 3
 4
 5
 6
</pre> <p>Use <a class="reference internal" href="#Base.append!" title="Base.append!"><code>append!()</code></a> to add all the elements of another collection to <code>collection</code>. The result of the preceding example is equivalent to <code>append!([1, 2, 3], [4, 5, 6])</code>.</p> </dd>
</dl> <dl class="function"> <dt>
<code>pop!(collection) → item</code> </dt> <dd>
<p>Remove the last item in <code>collection</code> and return it.</p> <pre data-language="julia">julia&gt; A=[1, 2, 3, 4, 5, 6]
6-element Array{Int64,1}:
 1
 2
 3
 4
 5
 6

julia&gt; pop!(A)
6

julia&gt; A
5-element Array{Int64,1}:
 1
 2
 3
 4
 5
</pre> </dd>
</dl> <dl class="function"> <dt id="Base.unshift!">
<code>unshift!(collection, items...) → collection</code> </dt> <dd>
<p>Insert one or more <code>items</code> at the beginning of <code>collection</code>.</p> <pre data-language="julia">julia&gt; unshift!([1, 2, 3, 4], 5, 6)
6-element Array{Int64,1}:
 5
 6
 1
 2
 3
 4
</pre> </dd>
</dl> <dl class="function"> <dt id="Base.shift!">
<code>shift!(collection) → item</code> </dt> <dd>
<p>Remove the first <code>item</code> from <code>collection</code>.</p> <pre data-language="julia">julia&gt; A = [1, 2, 3, 4, 5, 6]
6-element Array{Int64,1}:
 1
 2
 3
 4
 5
 6

julia&gt; shift!(A)
1

julia&gt; A
5-element Array{Int64,1}:
 2
 3
 4
 5
 6
</pre> </dd>
</dl> <dl class="function"> <dt id="Base.insert!">
<code>insert!(collection, index, item)</code> </dt> <dd>
<p>Insert an <code>item</code> into <code>collection</code> at the given <code>index</code>. <code>index</code> is the index of <code>item</code> in the resulting <code>collection</code>.</p> <pre data-language="julia">julia&gt; insert!([6, 5, 4, 2, 1], 4, 3)
6-element Array{Int64,1}:
 6
 5
 4
 3
 2
 1
</pre> </dd>
</dl> <dl class="function"> <dt id="Base.deleteat!">
<code>deleteat!(a::Vector, i::Integer)</code> </dt> <dd>
<p>Remove the item at the given <code>i</code> and return the modified <code>a</code>. Subsequent items are shifted to fill the resulting gap.</p> <pre data-language="julia">julia&gt; deleteat!([6, 5, 4, 3, 2, 1], 2)
5-element Array{Int64,1}:
 6
 4
 3
 2
 1
</pre> </dd>
</dl> <dl class="function"> <dt>
<code>deleteat!(a::Vector, inds)</code> </dt> <dd>
<p>Remove the items at the indices given by <code>inds</code>, and return the modified <code>a</code>. Subsequent items are shifted to fill the resulting gap. <code>inds</code> must be sorted and unique.</p> <pre data-language="julia">julia&gt; deleteat!([6, 5, 4, 3, 2, 1], 1:2:5)
3-element Array{Int64,1}:
 5
 3
 1

julia&gt; deleteat!([6, 5, 4, 3, 2, 1], (2, 2))
ERROR: ArgumentError: indices must be unique and sorted
 in deleteat!(::Array{Int64,1}, ::Tuple{Int64,Int64}) at ./array.jl:614
 ...
</pre> </dd>
</dl> <dl class="function"> <dt id="Base.splice!">
<code>splice!(collection, index[, replacement]) → item</code> </dt> <dd>
<p>Remove the item at the given index, and return the removed item. Subsequent items are shifted down to fill the resulting gap. If specified, replacement values from an ordered collection will be spliced in place of the removed item.</p> <pre data-language="julia">julia&gt; A = [6, 5, 4, 3, 2, 1]; splice!(A, 5)
2

julia&gt; A
5-element Array{Int64,1}:
 6
 5
 4
 3
 1

julia&gt; splice!(A, 5, -1)
1

julia&gt; A
5-element Array{Int64,1}:
  6
  5
  4
  3
 -1

julia&gt; splice!(A, 1, [-1, -2, -3])
6

julia&gt; A
7-element Array{Int64,1}:
 -1
 -2
 -3
  5
  4
  3
 -1
</pre> <p>To insert <code>replacement</code> before an index <code>n</code> without removing any items, use <code>splice!(collection, n:n-1, replacement)</code>.</p> </dd>
</dl> <dl class="function"> <dt>
<code>splice!(collection, range[, replacement]) → items</code> </dt> <dd>
<p>Remove items in the specified index range, and return a collection containing the removed items. Subsequent items are shifted down to fill the resulting gap. If specified, replacement values from an ordered collection will be spliced in place of the removed items.</p> <p>To insert <code>replacement</code> before an index <code>n</code> without removing any items, use <code>splice!(collection, n:n-1, replacement)</code>.</p> <pre data-language="julia">julia&gt; splice!(A, 4:3, 2)
0-element Array{Int64,1}

julia&gt; A
8-element Array{Int64,1}:
 -1
 -2
 -3
  2
  5
  4
  3
 -1
</pre> </dd>
</dl> <dl class="function"> <dt id="Base.resize!">
<code>resize!(collection, n) → collection</code> </dt> <dd>
<p>Resize <code>collection</code> to contain <code>n</code> elements. If <code>n</code> is smaller than the current collection length, the first <code>n</code> elements will be retained. If <code>n</code> is larger, the new elements are not guaranteed to be initialized.</p> <pre data-language="julia">julia&gt; resize!([6, 5, 4, 3, 2, 1], 3)
3-element Array{Int64,1}:
 6
 5
 4
</pre> <pre data-language="julia">julia&gt; resize!([6, 5, 4, 3, 2, 1], 8)
8-element Array{Int64,1}:
 6
 5
 4
 3
 2
 1
 0
 0
</pre> </dd>
</dl> <dl class="function"> <dt id="Base.append!">
<code>append!(collection, collection2) → collection.</code> </dt> <dd>
<p>Add the elements of <code>collection2</code> to the end of <code>collection</code>.</p> <pre data-language="julia">julia&gt; append!([1],[2,3])
3-element Array{Int64,1}:
 1
 2
 3
</pre> <pre data-language="julia">julia&gt; append!([1, 2, 3], [4, 5, 6])
6-element Array{Int64,1}:
 1
 2
 3
 4
 5
 6
</pre> <p>Use <a class="reference internal" href="#Base.push!" title="Base.push!"><code>push!()</code></a> to add individual items to <code>collection</code> which are not already themselves in another collection. The result is of the preceding example is equivalent to <code>push!([1, 2, 3], 4, 5, 6)</code>.</p> </dd>
</dl> <dl class="function"> <dt id="Base.prepend!">
<code>prepend!(collection, items) → collection</code> </dt> <dd>
<p>Insert the elements of <code>items</code> to the beginning of <code>collection</code>.</p> <pre data-language="julia">julia&gt; prepend!([3],[1,2])
3-element Array{Int64,1}:
 1
 2
 3
</pre> </dd>
</dl> <p>Fully implemented by:</p> <ul class="simple" id="module-Base.Collections"> <li>
<code>Vector</code> (a.k.a. 1-dimensional <a class="reference internal" href="../arrays/#Base.Array" title="Base.Array"><code>Array</code></a>)</li> <li>
<code>BitVector</code> (a.k.a. 1-dimensional <code>BitArray</code>)</li> </ul>   <h2 id="priorityqueue">PriorityQueue</h2> <p>The <a class="reference internal" href="#Base.Collections.PriorityQueue" title="Base.Collections.PriorityQueue"><code>PriorityQueue</code></a> type is available from the <code>Collections</code> module. It provides a basic priority queue implementation allowing for arbitrary key and priority types. Multiple identical keys are not permitted, but the priority of existing keys can be changed efficiently.</p> <dl class="function"> <dt id="Base.Collections.PriorityQueue">
<code>PriorityQueue(K, V[, ord])</code> </dt> <dd>
<p>Construct a new <a class="reference internal" href="#Base.Collections.PriorityQueue" title="Base.Collections.PriorityQueue"><code>PriorityQueue</code></a>, with keys of type <code>K</code> and values/priorites of type <code>V</code>. If an order is not given, the priority queue is min-ordered using the default comparison for <code>V</code>.</p> <p>A <code>PriorityQueue</code> acts like a <code>Dict</code>, mapping values to their priorities, with the addition of a <code>dequeue!</code> function to remove the lowest priority element.</p> <pre data-language="julia">julia&gt; a = Base.Collections.PriorityQueue(["a","b","c"],[2,3,1],Base.Order.Forward)
Base.Collections.PriorityQueue{String,Int64,Base.Order.ForwardOrdering} with 3 entries:
  "c" =&gt; 1
  "b" =&gt; 3
  "a" =&gt; 2
</pre> </dd>
</dl> <dl class="function"> <dt id="Base.Collections.enqueue!">
<code>enqueue!(pq, k, v)</code> </dt> <dd>
<p>Insert the a key <code>k</code> into a priority queue <code>pq</code> with priority <code>v</code>.</p> <pre data-language="julia">julia&gt; a = Base.Collections.PriorityQueue(["a","b","c"],[2,3,1],Base.Order.Forward)
Base.Collections.PriorityQueue{String,Int64,Base.Order.ForwardOrdering} with 3 entries:
  "c" =&gt; 1
  "b" =&gt; 3
  "a" =&gt; 2

julia&gt; Base.Collections.enqueue!(a, "d", 4)
Base.Collections.PriorityQueue{String,Int64,Base.Order.ForwardOrdering} with 4 entries:
  "c" =&gt; 1
  "b" =&gt; 3
  "a" =&gt; 2
  "d" =&gt; 4
</pre> </dd>
</dl> <dl class="function"> <dt id="Base.Collections.dequeue!">
<code>dequeue!(pq)</code> </dt> <dd>
<p>Remove and return the lowest priority key from a priority queue.</p> <pre data-language="julia">julia&gt; a = Base.Collections.PriorityQueue(["a","b","c"],[2,3,1],Base.Order.Forward)
Base.Collections.PriorityQueue{String,Int64,Base.Order.ForwardOrdering} with 3 entries:
  "c" =&gt; 1
  "b" =&gt; 3
  "a" =&gt; 2

julia&gt; Base.Collections.dequeue!(a)
"c"

julia&gt; a
Base.Collections.PriorityQueue{String,Int64,Base.Order.ForwardOrdering} with 2 entries:
  "b" =&gt; 3
  "a" =&gt; 2
</pre> </dd>
</dl> <dl class="function"> <dt id="Base.Collections.peek">
<code>peek(pq)</code> </dt> <dd>
<p>Return the lowest priority key from a priority queue without removing that key from the queue.</p> </dd>
</dl> <p><a class="reference internal" href="#Base.Collections.PriorityQueue" title="Base.Collections.PriorityQueue"><code>PriorityQueue</code></a> also behaves similarly to a <code>Dict</code> in that keys can be inserted and priorities accessed or changed using indexing notation.</p> <pre data-language="julia">julia&gt; # Julia code
       pq = Collections.PriorityQueue();

julia&gt; # Insert keys with associated priorities
       pq["a"] = 10; pq["b"] = 5; pq["c"] = 15; pq
Base.Collections.PriorityQueue{Any,Any,Base.Order.ForwardOrdering} with 3 entries:
  "c" =&gt; 15
  "b" =&gt; 5
  "a" =&gt; 10

julia&gt; # Change the priority of an existing key
       pq["a"] = 0; pq
Base.Collections.PriorityQueue{Any,Any,Base.Order.ForwardOrdering} with 3 entries:
  "c" =&gt; 15
  "b" =&gt; 5
  "a" =&gt; 0
</pre>   <h2 id="heap-functions">Heap Functions</h2> <p>Along with the <a class="reference internal" href="#Base.Collections.PriorityQueue" title="Base.Collections.PriorityQueue"><code>PriorityQueue</code></a> type, the <code>Collections</code> module provides lower level functions for performing binary heap operations on arrays. Each function takes an optional ordering argument. If not given, default ordering is used, so that elements popped from the heap are given in ascending order.</p> <dl class="function"> <dt id="Base.Collections.heapify">
<code>heapify(v, ord::Ordering=Forward)</code> </dt> <dd>
<p>Returns a new vector in binary heap order, optionally using the given ordering.</p> <pre data-language="julia">julia&gt; a = [1,3,4,5,2];

julia&gt; Base.Collections.heapify(a)
5-element Array{Int64,1}:
 1
 2
 4
 5
 3

julia&gt; Base.Collections.heapify(a, Base.Order.Reverse)
5-element Array{Int64,1}:
 5
 3
 4
 1
 2
</pre> </dd>
</dl> <dl class="function"> <dt id="Base.Collections.heapify!">
<code>heapify!(v, ord::Ordering=Forward)</code> </dt> <dd>
<p>In-place <a class="reference internal" href="#Base.Collections.heapify" title="Base.Collections.heapify"><code>heapify()</code></a>.</p> </dd>
</dl> <dl class="function"> <dt id="Base.Collections.isheap">
<code>isheap(v, ord::Ordering=Forward)</code> </dt> <dd>
<p>Return <code>true</code> if an array is heap-ordered according to the given order.</p> <pre data-language="julia">julia&gt; a = [1,2,3]
3-element Array{Int64,1}:
 1
 2
 3

julia&gt; Base.Collections.isheap(a,Base.Order.Forward)
true

julia&gt; Base.Collections.isheap(a,Base.Order.Reverse)
false
</pre> </dd>
</dl> <dl class="function"> <dt id="Base.Collections.heappush!">
<code>heappush!(v, x[, ord])</code> </dt> <dd>
<p>Given a binary heap-ordered array, push a new element <code>x</code>, preserving the heap property. For efficiency, this function does not check that the array is indeed heap-ordered.</p> </dd>
</dl> <dl class="function"> <dt id="Base.Collections.heappop!">
<code>heappop!(v[, ord])</code> </dt> <dd>
<p>Given a binary heap-ordered array, remove and return the lowest ordered element. For efficiency, this function does not check that the array is indeed heap-ordered.</p> </dd>
</dl>
<div class="_attribution">
  <p class="_attribution-p">
    © 2009–2016 Jeff Bezanson, Stefan Karpinski, Viral B. Shah, and other contributors<br>Licensed under the MIT License.<br>
    <a href="http://docs.julialang.org/en/release-0.5/stdlib/collections/" class="_attribution-link" target="_blank">http://docs.julialang.org/en/release-0.5/stdlib/collections/</a>
  </p>
</div>

			</div>
		</div>
	</section>

	</div>
</body>
</html>
