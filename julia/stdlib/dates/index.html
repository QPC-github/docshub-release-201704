
<!DOCTYPE HTML>

<html lang="en">

<head>
  <meta charset="utf-8">
  <title>Dates and Time - Julia - W3cubDocs</title>
  
  <meta name="description" content=" Period types represent discrete, human representations of time. ">
  <meta name="keywords" content="dates, and, time, -, julia">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="http://docs.w3cub.com/julia/stdlib/dates/">
  <link href="/favicon.png" rel="icon">
  <link type="text/css" rel="stylesheet" href="/assets/application-50364fff564ce3b6327021805f3f00e2957b441cf27f576a7dd4ff63bbc47047.css">
  <script type="text/javascript" src="/assets/application-db64bfd54ceb42be11af7995804cf4902548419ceb79d509b0b7d62c22d98e6f.js"></script>
  <script src="/json/julia.js"></script>
  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-71174418-1']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>


</head>

<body>
	<div class="_app">
	<header class="_header">
  
  <form class="_search">
    <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
    <a class="_search-clear"></a>
    <div class="_search-tag"></div>
  </form>
  
  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/julia/" class="_nav-link" title="" style="margin-left:0;">Julia</a></span>
  
  <nav class="_nav">
    <a href="/app/" class="_nav-link ">App</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		<div class="_list">
			
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<div class="_page _sphinx_simple">
				
<h1>Dates and Time</h1>  <h2 id="dates-and-time-types">Dates and Time Types</h2> <dl class="data"> <dt id="Dates.Period">
<code>Period</code> </dt> <dt id="Dates.Year">
<code>Year</code> </dt> <dt id="Dates.Month">
<code>Month</code> </dt> <dt id="Dates.Week">
<code>Week</code> </dt> <dt id="Dates.Day">
<code>Day</code> </dt> <dt id="Dates.Hour">
<code>Hour</code> </dt> <dt id="Dates.Minute">
<code>Minute</code> </dt> <dt id="Dates.Second">
<code>Second</code> </dt> <dt id="Dates.Millisecond">
<code>Millisecond</code> </dt> <dd>
<p><code>Period</code> types represent discrete, human representations of time.</p> </dd>
</dl> <dl class="type"> <dt id="Dates.CompoundPeriod">
<code>CompoundPeriod</code> </dt> <dd>
<p>A <code>CompoundPeriod</code> is useful for expressing time periods that are not a fixed multiple of smaller periods. For example, “a year and a day” is not a fixed number of days, but can be expressed using a <code>CompoundPeriod</code>. In fact, a <code>CompoundPeriod</code> is automatically generated by addition of different period types, e.g. <code>Year(1) + Day(1)</code> produces a <code>CompoundPeriod</code> result.</p> </dd>
</dl> <dl class="data"> <dt id="Dates.Instant">
<code>Instant</code> </dt> <dd>
<p><code>Instant</code> types represent integer-based, machine representations of time as continuous timelines starting from an epoch.</p> </dd>
</dl> <dl class="data"> <dt id="Dates.UTInstant{T}">
<code>UTInstant{T}</code> </dt> <dd>
<p>The <code>UTInstant</code> represents a machine timeline based on UT time (1 day = one revolution of the earth). The <code>T</code> is a <code>Period</code> parameter that indicates the resolution or precision of the instant.</p> </dd>
</dl> <dl class="data"> <dt id="Dates.TimeType">
<code>TimeType</code> </dt> <dd>
<p><code>TimeType</code> types wrap <code>Instant</code> machine instances to provide human representations of the machine instant. Both <code>DateTime</code> and <code>Date</code> are subtypes of <code>TimeType</code>.</p> </dd>
</dl> <dl class="data"> <dt id="Dates.DateTime">
<code>DateTime</code> </dt> <dd>
<p><code>DateTime</code> wraps a <code>UTInstant{Millisecond}</code> and interprets it according to the proleptic Gregorian calendar.</p> </dd>
</dl> <dl class="data"> <dt id="Dates.Date">
<code>Date</code> </dt> <dd>
<p><code>Date</code> wraps a <code>UTInstant{Day}</code> and interprets it according to the proleptic Gregorian calendar.</p> </dd>
</dl>   <h2 id="dates-functions">Dates Functions</h2> <p>All Dates functions are defined in the <code>Dates</code> module; note that only the <code>Date</code>, <code>DateTime</code>, and <code>now</code> functions are exported; to use all other <code>Dates</code> functions, you’ll need to prefix each function call with an explicit <code>Dates.</code>, e.g. <code>Dates.dayofweek(dt)</code>. Alternatively, you can write <code>using Base.Dates</code> to bring all exported functions into <code>Main</code> to be used without the <code>Dates.</code> prefix.</p> <dl class="function"> <dt>
<code>DateTime(y[, m, d, h, mi, s, ms]) → DateTime</code> </dt> <dd>
<p>Construct a <code>DateTime</code> type by parts. Arguments must be convertible to <code>Int64</code>.</p> </dd>
</dl> <dl class="function"> <dt>
<code>DateTime(periods::Period...) → DateTime</code> </dt> <dd>
<p>Construct a <code>DateTime</code> type by <code>Period</code> type parts. Arguments may be in any order. DateTime parts not provided will default to the value of <code>Dates.default(period)</code>.</p> </dd>
</dl> <dl class="function"> <dt>
<code>DateTime(f::Function, y[, m, d, h, mi, s]; step=Day(1), negate=false, limit=10000) → DateTime</code> </dt> <dd>
<p>Create a <code>DateTime</code> through the adjuster API. The starting point will be constructed from the provided <code>y, m, d...</code> arguments, and will be adjusted until <code>f::Function</code> returns <code>true</code>. The step size in adjusting can be provided manually through the <code>step</code> keyword. If <code>negate=true</code>, then the adjusting will stop when <code>f::Function</code> returns <code>false</code> instead of <code>true</code>. <code>limit</code> provides a limit to the max number of iterations the adjustment API will pursue before throwing an error (in the case that <code>f::Function</code> is never satisfied).</p> </dd>
</dl> <dl class="function"> <dt>
<code>DateTime(dt::Date) → DateTime</code> </dt> <dd>
<p>Converts a <code>Date</code> to a <code>DateTime</code>. The hour, minute, second, and millisecond parts of the new <code>DateTime</code> are assumed to be zero.</p> </dd>
</dl> <dl class="function" id="man-date-parsing"> <dt>
<code>DateTime(dt::AbstractString, format::AbstractString; locale="english") → DateTime</code> </dt> <dd>
<p>Construct a <code>DateTime</code> by parsing the <code>dt</code> date string following the pattern given in the <code>format</code> string. The following character codes can be used to construct the <code>format</code> string:</p> <table class="docutils">  <thead valign="bottom"> <tr class="row-odd">
<th class="head">Code</th> <th class="head">Matches</th> <th class="head">Comment</th> </tr> </thead>  <tr class="row-even">
<td><code>y</code></td> <td>1996, 96</td> <td>Returns year of 1996, 0096</td> </tr> <tr class="row-odd">
<td><code>Y</code></td> <td>1996, 96</td> <td>Returns year of 1996, 0096. Equivalent to <code>y</code>
</td> </tr> <tr class="row-even">
<td><code>m</code></td> <td>1, 01</td> <td>Matches 1 or 2-digit months</td> </tr> <tr class="row-odd">
<td><code>u</code></td> <td>Jan</td> <td>Matches abbreviated months according to the <code>locale</code> keyword</td> </tr> <tr class="row-even">
<td><code>U</code></td> <td>January</td> <td>Matches full month names according to the <code>locale</code> keyword</td> </tr> <tr class="row-odd">
<td><code>d</code></td> <td>1, 01</td> <td>Matches 1 or 2-digit days</td> </tr> <tr class="row-even">
<td><code>H</code></td> <td>00</td> <td>Matches hours</td> </tr> <tr class="row-odd">
<td><code>M</code></td> <td>00</td> <td>Matches minutes</td> </tr> <tr class="row-even">
<td><code>S</code></td> <td>00</td> <td>Matches seconds</td> </tr> <tr class="row-odd">
<td><code>s</code></td> <td>.500</td> <td>Matches milliseconds</td> </tr> <tr class="row-even">
<td><code>e</code></td> <td>Mon, Tues</td> <td>Matches abbreviated days of the week</td> </tr> <tr class="row-odd">
<td><code>E</code></td> <td>Monday</td> <td>Matches full name days of the week</td> </tr> <tr class="row-even">
<td><code>yyyymmdd</code></td> <td>19960101</td> <td>Matches fixed-width year, month, and day</td> </tr>  </table> <p>Characters not listed above are normally treated as delimiters between date and time slots. For example a <code>dt</code> string of “1996-01-15T00:00:00.0” would have a <code>format</code> string like “y-m-dTH:M:S.s”. If you need to use a code character as a delimiter you can escape it using backslash. The date “1995y01m” would have the format “y\ym\m”.</p> </dd>
</dl> <dl class="function" id="man-date-formatting"> <dt id="Dates.format">
<code>format(dt::TimeType, format::AbstractString; locale="english") → AbstractString</code> </dt> <dd>
<p>Construct a string by using a <code>TimeType</code> object and applying the provided <code>format</code>. The following character codes can be used to construct the <code>format</code> string:</p> <table class="docutils">  <thead valign="bottom"> <tr class="row-odd">
<th class="head">Code</th> <th class="head">Examples</th> <th class="head">Comment</th> </tr> </thead>  <tr class="row-even">
<td><code>y</code></td> <td>6</td> <td>Numeric year with a fixed width</td> </tr> <tr class="row-odd">
<td><code>Y</code></td> <td>1996</td> <td>Numeric year with a minimum width</td> </tr> <tr class="row-even">
<td><code>m</code></td> <td>1, 12</td> <td>Numeric month with a minimum width</td> </tr> <tr class="row-odd">
<td><code>u</code></td> <td>Jan</td> <td>Month name shortened to 3-chars according to the <code>locale</code>
</td> </tr> <tr class="row-even">
<td><code>U</code></td> <td>January</td> <td>Full month name according to the <code>locale</code> keyword</td> </tr> <tr class="row-odd">
<td><code>d</code></td> <td>1, 31</td> <td>Day of the month with a minimum width</td> </tr> <tr class="row-even">
<td><code>H</code></td> <td>0, 23</td> <td>Hour (24-hour clock) with a minimum width</td> </tr> <tr class="row-odd">
<td><code>M</code></td> <td>0, 59</td> <td>Minute with a minimum width</td> </tr> <tr class="row-even">
<td><code>S</code></td> <td>0, 59</td> <td>Second with a minimum width</td> </tr> <tr class="row-odd">
<td><code>s</code></td> <td>000, 500</td> <td>Millisecond with a minimum width of 3</td> </tr> <tr class="row-even">
<td><code>e</code></td> <td>Mon, Tue</td> <td>Abbreviated days of the week</td> </tr> <tr class="row-odd">
<td><code>E</code></td> <td>Monday</td> <td>Full day of week name</td> </tr>  </table> <p>The number of sequential code characters indicate the width of the code. A format of <code>yyyy-mm</code> specifies that the code <code>y</code> should have a width of four while <code>m</code> a width of two. Codes that yield numeric digits have an associated mode: fixed-width or minimum-width. The fixed-width mode left-pads the value with zeros when it is shorter than the specified width and truncates the value when longer. Minimum-width mode works the same as fixed-width except that it does not truncate values longer than the width.</p> <p>When creating a <code>format</code> you can use any non-code characters as a separator. For example to generate the string “1996-01-15T00:00:00” you could use <code>format</code>: “yyyy-mm-ddTHH:MM:SS”. Note that if you need to use a code character as a literal you can use the escape character backslash. The string “1996y01m” can be produced with the format “yyyy\ymm\m”.</p> </dd>
</dl> <dl class="function"> <dt id="Dates.DateFormat">
<code>DateFormat(format::AbstractString, locale::AbstractString="english") → DateFormat</code> </dt> <dd>
<p>Construct a date formatting object that can be used for parsing date strings or formatting a date object as a string. For details on the syntax for <code>format</code> see <a class="reference internal" href="#man-date-parsing"><span>parsing</span></a> and <a class="reference internal" href="#man-date-formatting"><span>formatting</span></a>.</p> </dd>
</dl> <dl class="function"> <dt>
<code>DateTime(dt::AbstractString, df::DateFormat) → DateTime</code> </dt> <dd>
<p>Construct a <code>DateTime</code> by parsing the <code>dt</code> date string following the pattern given in the <a class="reference internal" href="#Dates.DateFormat" title="Dates.DateFormat"><code>Dates.DateFormat()</code></a> object. Similar to <code>DateTime(::AbstractString, ::AbstractString)</code> but more efficient when repeatedly parsing similarly formatted date strings with a pre-created <code>DateFormat</code> object.</p> </dd>
</dl> <dl class="function"> <dt>
<code>Date(y[, m, d]) → Date</code> </dt> <dd>
<p>Construct a <code>Date</code> type by parts. Arguments must be convertible to <code>Int64</code>.</p> </dd>
</dl> <dl class="function"> <dt>
<code>Date(period::Period...) → Date</code> </dt> <dd>
<p>Construct a <code>Date</code> type by <code>Period</code> type parts. Arguments may be in any order. <code>Date</code> parts not provided will default to the value of <code>Dates.default(period)</code>.</p> </dd>
</dl> <dl class="function"> <dt>
<code>Date(f::Function, y[, m, d]; step=Day(1), negate=false, limit=10000) → Date</code> </dt> <dd>
<p>Create a <code>Date</code> through the adjuster API. The starting point will be constructed from the provided <code>y, m, d</code> arguments, and will be adjusted until <code>f::Function</code> returns <code>true</code>. The step size in adjusting can be provided manually through the <code>step</code> keyword. If <code>negate=true</code>, then the adjusting will stop when <code>f::Function</code> returns <code>false</code> instead of <code>true</code>. <code>limit</code> provides a limit to the max number of iterations the adjustment API will pursue before throwing an error (given that <code>f::Function</code> is never satisfied).</p> </dd>
</dl> <dl class="function"> <dt>
<code>Date(dt::DateTime) → Date</code> </dt> <dd>
<p>Converts a <code>DateTime</code> to a <code>Date</code>. The hour, minute, second, and millisecond parts of the <code>DateTime</code> are truncated, so only the year, month and day parts are used in construction.</p> </dd>
</dl> <dl class="function"> <dt>
<code>Date(dt::AbstractString, format::AbstractString; locale="english") → Date</code> </dt> <dd>
<p>Construct a <code>Date</code> object by parsing a <code>dt</code> date string following the pattern given in the <code>format</code> string. Follows the same conventions as <code>DateTime(::AbstractString, ::AbstractString)</code>.</p> </dd>
</dl> <dl class="function"> <dt>
<code>Date(dt::AbstractString, df::DateFormat) → Date</code> </dt> <dd>
<p>Parse a date from a date string <code>dt</code> using a <code>DateFormat</code> object <code>df</code>.</p> </dd>
</dl> <dl class="function"> <dt id="Dates.now">
<code>now() → DateTime</code> </dt> <dd>
<p>Returns a <code>DateTime</code> corresponding to the user’s system time including the system timezone locale.</p> </dd>
</dl> <dl class="function"> <dt>
<code>now(::Type{UTC}) → DateTime</code> </dt> <dd>
<p>Returns a <code>DateTime</code> corresponding to the user’s system time as UTC/GMT.</p> </dd>
</dl> <dl class="function"> <dt id="Dates.eps">
<code>eps(::DateTime) → Millisecond</code> </dt> <dt>
<code>eps(::Date) → Day</code> </dt> <dd>
<p>Returns <code>Millisecond(1)</code> for <code>DateTime</code> values and <code>Day(1)</code> for <code>Date</code> values.</p> </dd>
</dl>  <h3 id="accessor-functions">Accessor Functions</h3> <dl class="function"> <dt id="Dates.year">
<code>year(dt::TimeType) → Int64</code> </dt> <dd>
<p>The year of a <code>Date</code> or <code>DateTime</code> as an <code>Int64</code>.</p> </dd>
</dl> <dl class="function"> <dt id="Dates.month">
<code>month(dt::TimeType) → Int64</code> </dt> <dd>
<p>The month of a <code>Date</code> or <code>DateTime</code> as an <code>Int64</code>.</p> </dd>
</dl> <dl class="function"> <dt id="Dates.week">
<code>week(dt::TimeType) → Int64</code> </dt> <dd>
<p>Return the <a class="reference external" href="https://en.wikipedia.org/wiki/ISO_week_date" target="_blank">ISO week date</a> of a <code>Date</code> or <code>DateTime</code> as an <code>Int64</code>. Note that the first week of a year is the week that contains the first Thursday of the year which can result in dates prior to January 4th being in the last week of the previous year. For example <code>week(Date(2005,1,1))</code> is the 53rd week of 2004.</p> </dd>
</dl> <dl class="function"> <dt id="Dates.day">
<code>day(dt::TimeType) → Int64</code> </dt> <dd>
<p>The day of month of a <code>Date</code> or <code>DateTime</code> as an <code>Int64</code>.</p> </dd>
</dl> <dl class="function"> <dt id="Dates.hour">
<code>hour(dt::DateTime) → Int64</code> </dt> <dd>
<p>The hour of day of a <code>DateTime</code> as an <code>Int64</code>.</p> </dd>
</dl> <dl class="function"> <dt id="Dates.minute">
<code>minute(dt::DateTime) → Int64</code> </dt> <dd>
<p>The minute of a <code>DateTime</code> as an <code>Int64</code>.</p> </dd>
</dl> <dl class="function"> <dt id="Dates.second">
<code>second(dt::DateTime) → Int64</code> </dt> <dd>
<p>The second of a <code>DateTime</code> as an <code>Int64</code>.</p> </dd>
</dl> <dl class="function"> <dt id="Dates.millisecond">
<code>millisecond(dt::DateTime) → Int64</code> </dt> <dd>
<p>The millisecond of a <code>DateTime</code> as an <code>Int64</code>.</p> </dd>
</dl> <dl class="function"> <dt>
<code>Year(dt::TimeType) → Year</code> </dt> <dd>
<p>The year part of a <code>Date</code> or <code>DateTime</code> as a <code>Year</code>.</p> </dd>
</dl> <dl class="function"> <dt>
<code>Month(dt::TimeType) → Month</code> </dt> <dd>
<p>The month part of a <code>Date</code> or <code>DateTime</code> as a <code>Month</code>.</p> </dd>
</dl> <dl class="function"> <dt>
<code>Week(dt::TimeType) → Week</code> </dt> <dd>
<p>The week part of a <code>Date</code> or <code>DateTime</code> as a <code>Week</code>. For details see <a class="reference internal" href="#Dates.week" title="Dates.week"><code>week()</code></a>.</p> </dd>
</dl> <dl class="function"> <dt>
<code>Day(dt::TimeType) → Day</code> </dt> <dd>
<p>The day part of a <code>Date</code> or <code>DateTime</code> as a <code>Day</code>.</p> </dd>
</dl> <dl class="function"> <dt>
<code>Hour(dt::DateTime) → Hour</code> </dt> <dd>
<p>The hour part of a <code>DateTime</code> as a <code>Hour</code>.</p> </dd>
</dl> <dl class="function"> <dt>
<code>Minute(dt::DateTime) → Minute</code> </dt> <dd>
<p>The minute part of a <code>DateTime</code> as a <code>Minute</code>.</p> </dd>
</dl> <dl class="function"> <dt>
<code>Second(dt::DateTime) → Second</code> </dt> <dd>
<p>The second part of a <code>DateTime</code> as a <code>Second</code>.</p> </dd>
</dl> <dl class="function"> <dt>
<code>Millisecond(dt::DateTime) → Millisecond</code> </dt> <dd>
<p>The millisecond part of a <code>DateTime</code> as a <code>Millisecond</code>.</p> </dd>
</dl> <dl class="function"> <dt id="Dates.yearmonth">
<code>yearmonth(dt::TimeType) → (Int64, Int64)</code> </dt> <dd>
<p>Simultaneously return the year and month parts of a <code>Date</code> or <code>DateTime</code>.</p> </dd>
</dl> <dl class="function"> <dt id="Dates.monthday">
<code>monthday(dt::TimeType) → (Int64, Int64)</code> </dt> <dd>
<p>Simultaneously return the month and day parts of a <code>Date</code> or <code>DateTime</code>.</p> </dd>
</dl> <dl class="function"> <dt id="Dates.yearmonthday">
<code>yearmonthday(dt::TimeType) → (Int64, Int64, Int64)</code> </dt> <dd>
<p>Simultaneously return the year, month and day parts of a <code>Date</code> or <code>DateTime</code>.</p> </dd>
</dl>   <h3 id="query-functions">Query Functions</h3> <dl class="function"> <dt id="Dates.dayname">
<code>dayname(dt::TimeType; locale="english") → AbstractString</code> </dt> <dd>
<p>Return the full day name corresponding to the day of the week of the <code>Date</code> or <code>DateTime</code> in the given <code>locale</code>.</p> </dd>
</dl> <dl class="function"> <dt id="Dates.dayabbr">
<code>dayabbr(dt::TimeType; locale="english") → AbstractString</code> </dt> <dd>
<p>Return the abbreviated name corresponding to the day of the week of the <code>Date</code> or <code>DateTime</code> in the given <code>locale</code>.</p> </dd>
</dl> <dl class="function"> <dt id="Dates.dayofweek">
<code>dayofweek(dt::TimeType) → Int64</code> </dt> <dd>
<p>Returns the day of the week as an <code>Int64</code> with <code>1 = Monday, 2 = Tuesday, etc.</code>.</p> </dd>
</dl> <dl class="function"> <dt id="Dates.dayofmonth">
<code>dayofmonth(dt::TimeType) → Int64</code> </dt> <dd>
<p>The day of month of a <code>Date</code> or <code>DateTime</code> as an <code>Int64</code>.</p> </dd>
</dl> <dl class="function"> <dt id="Dates.dayofweekofmonth">
<code>dayofweekofmonth(dt::TimeType) → Int</code> </dt> <dd>
<p>For the day of week of <code>dt</code>, returns which number it is in <code>dt</code>‘s month. So if the day of the week of <code>dt</code> is Monday, then <code>1 = First Monday of the month, 2 = Second Monday of the month, etc.</code> In the range 1:5.</p> </dd>
</dl> <dl class="function"> <dt id="Dates.daysofweekinmonth">
<code>daysofweekinmonth(dt::TimeType) → Int</code> </dt> <dd>
<p>For the day of week of <code>dt</code>, returns the total number of that day of the week in <code>dt</code>‘s month. Returns 4 or 5. Useful in temporal expressions for specifying the last day of a week in a month by including <code>dayofweekofmonth(dt) == daysofweekinmonth(dt)</code> in the adjuster function.</p> </dd>
</dl> <dl class="function"> <dt id="Dates.monthname">
<code>monthname(dt::TimeType; locale="english") → AbstractString</code> </dt> <dd>
<p>Return the full name of the month of the <code>Date</code> or <code>DateTime</code> in the given <code>locale</code>.</p> </dd>
</dl> <dl class="function"> <dt id="Dates.monthabbr">
<code>monthabbr(dt::TimeType; locale="english") → AbstractString</code> </dt> <dd>
<p>Return the abbreviated month name of the <code>Date</code> or <code>DateTime</code> in the given <code>locale</code>.</p> </dd>
</dl> <dl class="function"> <dt id="Dates.daysinmonth">
<code>daysinmonth(dt::TimeType) → Int</code> </dt> <dd>
<p>Returns the number of days in the month of <code>dt</code>. Value will be 28, 29, 30, or 31.</p> </dd>
</dl> <dl class="function"> <dt id="Dates.isleapyear">
<code>isleapyear(dt::TimeType) → Bool</code> </dt> <dd>
<p>Returns <code>true</code> if the year of <code>dt</code> is a leap year.</p> </dd>
</dl> <dl class="function"> <dt id="Dates.dayofyear">
<code>dayofyear(dt::TimeType) → Int</code> </dt> <dd>
<p>Returns the day of the year for <code>dt</code> with January 1st being day 1.</p> </dd>
</dl> <dl class="function"> <dt id="Dates.daysinyear">
<code>daysinyear(dt::TimeType) → Int</code> </dt> <dd>
<p>Returns 366 if the year of <code>dt</code> is a leap year, otherwise returns 365.</p> </dd>
</dl> <dl class="function"> <dt id="Dates.quarterofyear">
<code>quarterofyear(dt::TimeType) → Int</code> </dt> <dd>
<p>Returns the quarter that <code>dt</code> resides in. Range of value is 1:4.</p> </dd>
</dl> <dl class="function"> <dt id="Dates.dayofquarter">
<code>dayofquarter(dt::TimeType) → Int</code> </dt> <dd>
<p>Returns the day of the current quarter of <code>dt</code>. Range of value is 1:92.</p> </dd>
</dl>   <h3 id="adjuster-functions">Adjuster Functions</h3> <dl class="function"> <dt id="Dates.trunc">
<code>trunc(dt::TimeType, ::Type{Period}) → TimeType</code> </dt> <dd>
<p>Truncates the value of <code>dt</code> according to the provided <code>Period</code> type. E.g. if <code>dt</code> is <code>1996-01-01T12:30:00</code>, then <code>trunc(dt,Day) == 1996-01-01T00:00:00</code>.</p> </dd>
</dl> <dl class="function"> <dt id="Dates.firstdayofweek">
<code>firstdayofweek(dt::TimeType) → TimeType</code> </dt> <dd>
<p>Adjusts <code>dt</code> to the Monday of its week.</p> </dd>
</dl> <dl class="function"> <dt id="Dates.lastdayofweek">
<code>lastdayofweek(dt::TimeType) → TimeType</code> </dt> <dd>
<p>Adjusts <code>dt</code> to the Sunday of its week.</p> </dd>
</dl> <dl class="function"> <dt id="Dates.firstdayofmonth">
<code>firstdayofmonth(dt::TimeType) → TimeType</code> </dt> <dd>
<p>Adjusts <code>dt</code> to the first day of its month.</p> </dd>
</dl> <dl class="function"> <dt id="Dates.lastdayofmonth">
<code>lastdayofmonth(dt::TimeType) → TimeType</code> </dt> <dd>
<p>Adjusts <code>dt</code> to the last day of its month.</p> </dd>
</dl> <dl class="function"> <dt id="Dates.firstdayofyear">
<code>firstdayofyear(dt::TimeType) → TimeType</code> </dt> <dd>
<p>Adjusts <code>dt</code> to the first day of its year.</p> </dd>
</dl> <dl class="function"> <dt id="Dates.lastdayofyear">
<code>lastdayofyear(dt::TimeType) → TimeType</code> </dt> <dd>
<p>Adjusts <code>dt</code> to the last day of its year.</p> </dd>
</dl> <dl class="function"> <dt id="Dates.firstdayofquarter">
<code>firstdayofquarter(dt::TimeType) → TimeType</code> </dt> <dd>
<p>Adjusts <code>dt</code> to the first day of its quarter.</p> </dd>
</dl> <dl class="function"> <dt id="Dates.lastdayofquarter">
<code>lastdayofquarter(dt::TimeType) → TimeType</code> </dt> <dd>
<p>Adjusts <code>dt</code> to the last day of its quarter.</p> </dd>
</dl> <dl class="function"> <dt id="Dates.tonext">
<code>tonext(dt::TimeType, dow::Int;same::Bool=false) → TimeType</code> </dt> <dd>
<p>Adjusts <code>dt</code> to the next day of week corresponding to <code>dow</code> with <code>1 = Monday, 2 = Tuesday, etc</code>. Setting <code>same=true</code> allows the current <code>dt</code> to be considered as the next <code>dow</code>, allowing for no adjustment to occur.</p> </dd>
</dl> <dl class="function"> <dt id="Dates.toprev">
<code>toprev(dt::TimeType, dow::Int;same::Bool=false) → TimeType</code> </dt> <dd>
<p>Adjusts <code>dt</code> to the previous day of week corresponding to <code>dow</code> with <code>1 = Monday, 2 = Tuesday, etc</code>. Setting <code>same=true</code> allows the current <code>dt</code> to be considered as the previous <code>dow</code>, allowing for no adjustment to occur.</p> </dd>
</dl> <dl class="function"> <dt id="Dates.tofirst">
<code>tofirst(dt::TimeType, dow::Int;of=Month) → TimeType</code> </dt> <dd>
<p>Adjusts <code>dt</code> to the first <code>dow</code> of its month. Alternatively, <code>of=Year</code> will adjust to the first <code>dow</code> of the year.</p> </dd>
</dl> <dl class="function"> <dt id="Dates.tolast">
<code>tolast(dt::TimeType, dow::Int;of=Month) → TimeType</code> </dt> <dd>
<p>Adjusts <code>dt</code> to the last <code>dow</code> of its month. Alternatively, <code>of=Year</code> will adjust to the last <code>dow</code> of the year.</p> </dd>
</dl> <dl class="function"> <dt>
<code>tonext(func::Function, dt::TimeType;step=Day(1), negate=false, limit=10000, same=false) → TimeType</code> </dt> <dd>
<p>Adjusts <code>dt</code> by iterating at most <code>limit</code> iterations by <code>step</code> increments until <code>func</code> returns <code>true</code>. <code>func</code> must take a single <code>TimeType</code> argument and return a <code>Bool</code>. <code>same</code> allows <code>dt</code> to be considered in satisfying <code>func</code>. <code>negate</code> will make the adjustment process terminate when <code>func</code> returns <code>false</code> instead of <code>true</code>.</p> </dd>
</dl> <dl class="function"> <dt>
<code>toprev(func::Function, dt::TimeType;step=Day(-1), negate=false, limit=10000, same=false) → TimeType</code> </dt> <dd>
<p>Adjusts <code>dt</code> by iterating at most <code>limit</code> iterations by <code>step</code> increments until <code>func</code> returns <code>true</code>. <code>func</code> must take a single <code>TimeType</code> argument and return a <code>Bool</code>. <code>same</code> allows <code>dt</code> to be considered in satisfying <code>func</code>. <code>negate</code> will make the adjustment process terminate when <code>func</code> returns <code>false</code> instead of <code>true</code>.</p> </dd>
</dl> <dl class="function"> <dt id="Dates.recur{T&lt;:TimeType}"><code>recur{T<:timetype dr::steprange limit="10000)" vector> </:timetype></code></dt> <dd>
<p><code>func</code> takes a single TimeType argument and returns a <code>Bool</code> indicating whether the input should be “included” in the final set. <code>recur</code> applies <code>func</code> over each element in the range of <code>dr</code>, including those elements for which <code>func</code> returns <code>true</code> in the resulting Array, unless <code>negate=true</code>, then only elements where <code>func</code> returns <code>false</code> are included.</p> </dd>
</dl>   <h3 id="periods">Periods</h3> <dl class="data"> <dt>
<code>Year(v)</code> </dt> <dt>
<code>Month(v)</code> </dt> <dt>
<code>Week(v)</code> </dt> <dt>
<code>Day(v)</code> </dt> <dt>
<code>Hour(v)</code> </dt> <dt>
<code>Minute(v)</code> </dt> <dt>
<code>Second(v)</code> </dt> <dt>
<code>Millisecond(v)</code> </dt> <dd>
<p>Construct a <code>Period</code> type with the given <code>v</code> value. Input must be losslessly convertible to an <code>Int64</code>.</p> </dd>
</dl> <dl class="function"> <dt>
<code>CompoundPeriod(periods) → CompoundPeriod</code> </dt> <dd>
<p>Construct a <code>CompoundPeriod</code> from a <code>Vector</code> of <code>Period</code>s. The constructor will automatically simplify the periods into a canonical form according to the following rules:</p> <ul class="simple"> <li>All <code>Period</code>s of the same type will be added together</li> <li>Any <code>Period</code> large enough be partially representable by a coarser <code>Period</code> will be broken into multiple <code>Period</code>s (eg. <code>Hour(30)</code> becomes <code>Day(1) + Hour(6)</code>)</li> <li>
<code>Period</code>s with opposite signs will be combined when possible (eg. <code>Hour(1) - Day(1)</code> becomes <code>-Hour(23)</code>)</li> </ul> <p>Due to the canonicalization, <code>CompoundPeriod</code> is also useful for converting time periods into more human-comprehensible forms.</p> <p><strong>Examples</strong></p> <pre data-language="julia">julia&gt; Dates.CompoundPeriod([Dates.Hour(12), Dates.Hour(13)])
1 day, 1 hour

julia&gt; Dates.CompoundPeriod([Dates.Hour(-1), Dates.Minute(1)])
-59 minutes

julia&gt; Dates.CompoundPeriod([Dates.Month(1), Dates.Week(-2)])
1 month, -2 weeks

julia&gt; Dates.CompoundPeriod(Dates.Minute(50000)))
4 weeks, 6 days, 17 hours, 20 minutes
</pre> </dd>
</dl> <dl class="function"> <dt id="Dates.default">
<code>default(p::Period) → Period</code> </dt> <dd>
<p>Returns a sensible “default” value for the input Period by returning <code>one(p)</code> for Year, Month, and Day, and <code>zero(p)</code> for Hour, Minute, Second, and Millisecond.</p> </dd>
</dl>   <h3 id="rounding-functions">Rounding Functions</h3> <p><code>Date</code> and <code>DateTime</code> values can be rounded to a specified resolution (e.g., 1 month or 15 minutes) with <code>floor</code>, <code>ceil</code>, or <code>round</code>.</p> <dl class="function"> <dt id="Dates.floor">
<code>floor(dt::TimeType, p::Period) → TimeType</code> </dt> <dd>
<p>Returns the nearest <code>Date</code> or <code>DateTime</code> less than or equal to <code>dt</code> at resolution <code>p</code>.</p> <p>For convenience, <code>p</code> may be a type instead of a value: <code>floor(dt, Dates.Hour)</code> is a shortcut for <code>floor(dt, Dates.Hour(1))</code>.</p> <pre data-language="julia">julia&gt; floor(Date(1985, 8, 16), Dates.Month)
1985-08-01

julia&gt; floor(DateTime(2013, 2, 13, 0, 31, 20), Dates.Minute(15))
2013-02-13T00:30:00

julia&gt; floor(DateTime(2016, 8, 6, 12, 0, 0), Dates.Day)
2016-08-06T00:00:00
</pre> </dd>
</dl> <dl class="function"> <dt id="Dates.ceil">
<code>ceil(dt::TimeType, p::Period) → TimeType</code> </dt> <dd>
<p>Returns the nearest <code>Date</code> or <code>DateTime</code> greater than or equal to <code>dt</code> at resolution <code>p</code>.</p> <p>For convenience, <code>p</code> may be a type instead of a value: <code>ceil(dt, Dates.Hour)</code> is a shortcut for <code>ceil(dt, Dates.Hour(1))</code>.</p> <pre data-language="julia">julia&gt; ceil(Date(1985, 8, 16), Dates.Month)
1985-09-01

julia&gt; ceil(DateTime(2013, 2, 13, 0, 31, 20), Dates.Minute(15))
2013-02-13T00:45:00

julia&gt; ceil(DateTime(2016, 8, 6, 12, 0, 0), Dates.Day)
2016-08-07T00:00:00
</pre> </dd>
</dl> <dl class="function"> <dt id="Dates.round">
<code>round(dt::TimeType, p::Period[, r::RoundingMode]) → TimeType</code> </dt> <dd>
<p>Returns the <code>Date</code> or <code>DateTime</code> nearest to <code>dt</code> at resolution <code>p</code>. By default (<code>RoundNearestTiesUp</code>), ties (e.g., rounding 9:30 to the nearest hour) will be rounded up.</p> <p>For convenience, <code>p</code> may be a type instead of a value: <code>round(dt, Dates.Hour)</code> is a shortcut for <code>round(dt, Dates.Hour(1))</code>.</p> <pre data-language="julia">julia&gt; round(Date(1985, 8, 16), Dates.Month)
1985-08-01

julia&gt; round(DateTime(2013, 2, 13, 0, 31, 20), Dates.Minute(15))
2013-02-13T00:30:00

julia&gt; round(DateTime(2016, 8, 6, 12, 0, 0), Dates.Day)
2016-08-07T00:00:00
</pre> <p>Valid rounding modes for <code>round(::TimeType, ::Period, ::RoundingMode)</code> are <code>RoundNearestTiesUp</code> (default), <code>RoundDown</code> (<code>floor</code>), and <code>RoundUp</code> (<code>ceil</code>).</p> </dd>
</dl> <p>The following functions are not exported:</p> <dl class="function"> <dt id="Dates.floorceil">
<code>floorceil(dt::TimeType, p::Period) → (TimeType, TimeType)</code> </dt> <dd>
<p>Simultaneously return the <code>floor</code> and <code>ceil</code> of a <code>Date</code> or <code>DateTime</code> at resolution <code>p</code>. More efficient than calling both <code>floor</code> and <code>ceil</code> individually.</p> </dd>
</dl> <dl class="function"> <dt id="Dates.epochdays2date">
<code>epochdays2date(days) → Date</code> </dt> <dd>
<p>Takes the number of days since the rounding epoch (<code>0000-01-01T00:00:00</code>) and returns the corresponding <code>Date</code>.</p> </dd>
</dl> <dl class="function"> <dt id="Dates.epochms2datetime">
<code>epochms2datetime(milliseconds) → DateTime</code> </dt> <dd>
<p>Takes the number of milliseconds since the rounding epoch (<code>0000-01-01T00:00:00</code>) and returns the corresponding <code>DateTime</code>.</p> </dd>
</dl> <dl class="function"> <dt id="Dates.date2epochdays">
<code>date2epochdays(dt::Date) → Int64</code> </dt> <dd>
<p>Takes the given <code>Date</code> and returns the number of days since the rounding epoch (<code>0000-01-01T00:00:00</code>) as an <code>Int64</code>.</p> </dd>
</dl> <dl class="function"> <dt id="Dates.datetime2epochms">
<code>datetime2epochms(dt::DateTime) → Int64</code> </dt> <dd>
<p>Takes the given <code>DateTime</code> and returns the number of milliseconds since the rounding epoch (<code>0000-01-01T00:00:00</code>) as an <code>Int64</code>.</p> </dd>
</dl>   <h3 id="conversion-functions">Conversion Functions</h3> <dl class="function"> <dt id="Dates.today">
<code>today() → Date</code> </dt> <dd>
<p>Returns the date portion of <code>now()</code>.</p> </dd>
</dl> <dl class="function"> <dt id="Dates.unix2datetime">
<code>unix2datetime(x) → DateTime</code> </dt> <dd>
<p>Takes the number of seconds since unix epoch <code>1970-01-01T00:00:00</code> and converts to the corresponding <code>DateTime</code>.</p> </dd>
</dl> <dl class="function"> <dt id="Dates.datetime2unix">
<code>datetime2unix(dt::DateTime) → Float64</code> </dt> <dd>
<p>Takes the given <code>DateTime</code> and returns the number of seconds since the unix epoch <code>1970-01-01T00:00:00</code> as a <code>Float64</code>.</p> </dd>
</dl> <dl class="function"> <dt id="Dates.julian2datetime">
<code>julian2datetime(julian_days) → DateTime</code> </dt> <dd>
<p>Takes the number of Julian calendar days since epoch <code>-4713-11-24T12:00:00</code> and returns the corresponding <code>DateTime</code>.</p> </dd>
</dl> <dl class="function"> <dt id="Dates.datetime2julian">
<code>datetime2julian(dt::DateTime) → Float64</code> </dt> <dd>
<p>Takes the given <code>DateTime</code> and returns the number of Julian calendar days since the julian epoch <code>-4713-11-24T12:00:00</code> as a <code>Float64</code>.</p> </dd>
</dl> <dl class="function"> <dt id="Dates.rata2datetime">
<code>rata2datetime(days) → DateTime</code> </dt> <dd>
<p>Takes the number of Rata Die days since epoch <code>0000-12-31T00:00:00</code> and returns the corresponding <code>DateTime</code>.</p> </dd>
</dl> <dl class="function"> <dt id="Dates.datetime2rata">
<code>datetime2rata(dt::TimeType) → Int64</code> </dt> <dd>
<p>Returns the number of Rata Die days since epoch from the given <code>Date</code> or <code>DateTime</code>.</p> </dd>
</dl>   <h3 id="constants">Constants</h3> <p>Days of the Week:</p> <table class="docutils">  <thead valign="bottom"> <tr class="row-odd">
<th class="head">Variable</th> <th class="head">Abbr.</th> <th class="head">Value (Int)</th> </tr> </thead>  <tr class="row-even">
<td><code>Monday</code></td> <td><code>Mon</code></td> <td>1</td> </tr> <tr class="row-odd">
<td><code>Tuesday</code></td> <td><code>Tue</code></td> <td>2</td> </tr> <tr class="row-even">
<td><code>Wednesday</code></td> <td><code>Wed</code></td> <td>3</td> </tr> <tr class="row-odd">
<td><code>Thursday</code></td> <td><code>Thu</code></td> <td>4</td> </tr> <tr class="row-even">
<td><code>Friday</code></td> <td><code>Fri</code></td> <td>5</td> </tr> <tr class="row-odd">
<td><code>Saturday</code></td> <td><code>Sat</code></td> <td>6</td> </tr> <tr class="row-even">
<td><code>Sunday</code></td> <td><code>Sun</code></td> <td>7</td> </tr>  </table> <p>Months of the Year:</p> <table class="docutils">  <thead valign="bottom"> <tr class="row-odd">
<th class="head">Variable</th> <th class="head">Abbr.</th> <th class="head">Value (Int)</th> </tr> </thead>  <tr class="row-even">
<td><code>January</code></td> <td><code>Jan</code></td> <td>1</td> </tr> <tr class="row-odd">
<td><code>February</code></td> <td><code>Feb</code></td> <td>2</td> </tr> <tr class="row-even">
<td><code>March</code></td> <td><code>Mar</code></td> <td>3</td> </tr> <tr class="row-odd">
<td><code>April</code></td> <td><code>Apr</code></td> <td>4</td> </tr> <tr class="row-even">
<td><code>May</code></td> <td><code>May</code></td> <td>5</td> </tr> <tr class="row-odd">
<td><code>June</code></td> <td><code>Jun</code></td> <td>6</td> </tr> <tr class="row-even">
<td><code>July</code></td> <td><code>Jul</code></td> <td>7</td> </tr> <tr class="row-odd">
<td><code>August</code></td> <td><code>Aug</code></td> <td>8</td> </tr> <tr class="row-even">
<td><code>September</code></td> <td><code>Sep</code></td> <td>9</td> </tr> <tr class="row-odd">
<td><code>October</code></td> <td><code>Oct</code></td> <td>10</td> </tr> <tr class="row-even">
<td><code>November</code></td> <td><code>Nov</code></td> <td>11</td> </tr> <tr class="row-odd">
<td><code>December</code></td> <td><code>Dec</code></td> <td>12</td> </tr>  </table>
<div class="_attribution">
  <p class="_attribution-p">
    © 2009–2016 Jeff Bezanson, Stefan Karpinski, Viral B. Shah, and other contributors<br>Licensed under the MIT License.<br>
    <a href="http://docs.julialang.org/en/release-0.5/stdlib/dates/" class="_attribution-link" target="_blank">http://docs.julialang.org/en/release-0.5/stdlib/dates/</a>
  </p>
</div>

			</div>
		</div>
	</section>

	</div>
</body>
</html>
