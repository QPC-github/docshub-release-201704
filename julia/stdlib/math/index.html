
<!DOCTYPE HTML>

<html lang="en">

<head>
  <meta charset="utf-8">
  <title>Mathematics - Julia - W3cubDocs</title>
  
  <meta name="description" content=" Unary minus operator. ">
  <meta name="keywords" content="mathematics, -, julia">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="http://docs.w3cub.com/julia/stdlib/math/">
  <link href="/favicon.png" rel="icon">
  <link type="text/css" rel="stylesheet" href="/assets/application-50364fff564ce3b6327021805f3f00e2957b441cf27f576a7dd4ff63bbc47047.css">
  <script type="text/javascript" src="/assets/application-db64bfd54ceb42be11af7995804cf4902548419ceb79d509b0b7d62c22d98e6f.js"></script>
  <script src="/json/julia.js"></script>
  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-71174418-1']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>


</head>

<body>
	<div class="_app">
	<header class="_header">
  
  <form class="_search">
    <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
    <a class="_search-clear"></a>
    <div class="_search-tag"></div>
  </form>
  
  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/julia/" class="_nav-link" title="" style="margin-left:0;">Julia</a></span>
  
  <nav class="_nav">
    <a href="/app/" class="_nav-link ">App</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		<div class="_list">
			
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<div class="_page _sphinx_simple">
				
<h1>Mathematics</h1>  <h2 id="id1">Mathematical Operators</h2> <dl class="function" id="mathematical-operators"> <dt id="Base.-">
<code>-(x)</code> </dt> <dd>
<p>Unary minus operator.</p> </dd>
</dl> <dl class="function" id="id2"> <dt id="Base.+">
<code>+(x, y...)</code> </dt> <dd>
<p>Addition operator. <code>x+y+z+...</code> calls this function with all arguments, i.e. <code>+(x, y, z, ...)</code>.</p> </dd>
</dl> <dl class="function" id="id3"> <dt>
<code>-(x, y)</code> </dt> <dd>
<p>Subtraction operator.</p> </dd>
</dl> <dl class="function" id="id4"> <dt id="Base.*">
<code>*(x, y...)</code> </dt> <dd>
<p>Multiplication operator. <code>x*y*z*...</code> calls this function with all arguments, i.e. <code>*(x, y, z, ...)</code>.</p> </dd>
</dl> <dl class="function" id="id5"> <dt id="Base./">
<code>/(x, y)</code> </dt> <dd>
<p>Right division operator: multiplication of <code>x</code> by the inverse of <code>y</code> on the right. Gives floating-point results for integer arguments.</p> </dd>
</dl> <dl class="function" id="id6"> <dt id="Base.\">
<code>\(x, y)</code> </dt> <dd>
<p>Left division operator: multiplication of <code>y</code> by the inverse of <code>x</code> on the left. Gives floating-point results for integer arguments.</p> </dd>
</dl> <dl class="function" id="id7"> <dt id="Base.^">
<code>^(x, y)</code> </dt> <dd>
<p>Exponentiation operator.</p> </dd>
</dl> <dl class="function" id="id8"> <dt id="Base..+">
<code>.+(x, y)</code> </dt> <dd>
<p>Element-wise addition operator.</p> </dd>
</dl> <dl class="function" id="id9"> <dt id="Base..-">
<code>.-(x, y)</code> </dt> <dd>
<p>Element-wise subtraction operator.</p> </dd>
</dl> <dl class="function" id="id10"> <dt id="Base..*">
<code>.*(x, y)</code> </dt> <dd>
<p>Element-wise multiplication operator.</p> </dd>
</dl> <dl class="function" id="id11"> <dt id="Base../">
<code>./(x, y)</code> </dt> <dd>
<p>Element-wise right division operator.</p> </dd>
</dl> <dl class="function" id="id12"> <dt id="Base..\">
<code>.\(x, y)</code> </dt> <dd>
<p>Element-wise left division operator.</p> </dd>
</dl> <dl class="function" id="id13"> <dt id="Base..^">
<code>.^(x, y)</code> </dt> <dd>
<p>Element-wise exponentiation operator.</p> </dd>
</dl> <dl class="function"> <dt id="Base.fma">
<code>fma(x, y, z)</code> </dt> <dd>
<p>Computes <code>x*y+z</code> without rounding the intermediate result <code>x*y</code>. On some systems this is significantly more expensive than <code>x*y+z</code>. <code>fma</code> is used to improve accuracy in certain algorithms. See <code>muladd</code>.</p> </dd>
</dl> <dl class="function"> <dt id="Base.muladd">
<code>muladd(x, y, z)</code> </dt> <dd>
<p>Combined multiply-add, computes <code>x*y+z</code> in an efficient manner. This may on some systems be equivalent to <code>x*y+z</code>, or to <code>fma(x,y,z)</code>. <code>muladd</code> is used to improve performance. See <code>fma</code>.</p> </dd>
</dl> <dl class="function"> <dt id="Base.div">
<code>div(x, y)</code> </dt> <dt id="Base.÷">
<code>÷(x, y)</code> </dt> <dd>
<p>The quotient from Euclidean division. Computes <code>x/y</code>, truncated to an integer.</p> </dd>
</dl> <dl class="function"> <dt id="Base.fld">
<code>fld(x, y)</code> </dt> <dd>
<p>Largest integer less than or equal to <code>x/y</code>.</p> </dd>
</dl> <dl class="function"> <dt id="Base.cld">
<code>cld(x, y)</code> </dt> <dd>
<p>Smallest integer larger than or equal to <code>x/y</code>.</p> </dd>
</dl> <dl class="function"> <dt id="Base.mod">
<code>mod(x, y)</code> </dt> <dd>
<p>Modulus after flooring division, returning in the range <span class="math">\([0,y)\)</span>, if <code>y</code> is positive, or <span class="math">\((y,0]\)</span> if <code>y</code> is negative.</p> <pre data-language="julia">x == fld(x,y)*y + mod(x,y)
</pre> </dd>
</dl> <dl class="function"> <dt id="Base.mod2pi">
<code>mod2pi(x)</code> </dt> <dd>
<p>Modulus after division by <code>2π</code>, returning in the range <span class="math">\([0,2π)\)</span>.</p> <p>This function computes a floating point representation of the modulus after division by numerically exact <code>2π</code>, and is therefore not exactly the same as <code>mod(x,2π)</code>, which would compute the modulus of <code>x</code> relative to division by the floating-point number <code>2π</code>.</p> </dd>
</dl> <dl class="function"> <dt id="Base.rem">
<code>rem(x, y)</code> </dt> <dt id="Base.%">
<code>%(x, y)</code> </dt> <dd>
<p>Remainder from Euclidean division, returning a value of the same sign as <code>x</code>, and smaller in magnitude than <code>y</code>. This value is always exact.</p> <pre data-language="julia">x == div(x,y)*y + rem(x,y)
</pre> </dd>
</dl> <dl class="function"> <dt id="Base.divrem">
<code>divrem(x, y)</code> </dt> <dd>
<p>The quotient and remainder from Euclidean division. Equivalent to <code>(div(x,y), rem(x,y))</code> or <code>(x÷y, x%y)</code>.</p> </dd>
</dl> <dl class="function"> <dt id="Base.fldmod">
<code>fldmod(x, y)</code> </dt> <dd>
<p>The floored quotient and modulus after division. Equivalent to <code>(fld(x,y), mod(x,y))</code>.</p> </dd>
</dl> <dl class="function"> <dt id="Base.fld1">
<code>fld1(x, y)</code> </dt> <dd>
<p>Flooring division, returning a value consistent with <code>mod1(x,y)</code></p> <pre data-language="julia">x == fld(x,y)*y + mod(x,y)
x == (fld1(x,y)-1)*y + mod1(x,y)
</pre> </dd>
</dl> <dl class="function"> <dt id="Base.mod1">
<code>mod1(x, y)</code> </dt> <dd>
<p>Modulus after flooring division, returning a value <code>r</code> such that <code>mod(r, y) == mod(x, y)</code> in the range <span class="math">\((0, y]\)</span> for positive <code>y</code> and in the range <span class="math">\([y,0)\)</span> for negative <code>y</code>.</p> </dd>
</dl> <dl class="function"> <dt id="Base.fldmod1">
<code>fldmod1(x, y)</code> </dt> <dd>
<p>Return <code>(fld1(x,y), mod1(x,y))</code>.</p> </dd>
</dl> <dl class="function" id="id14"> <dt id="Base.//">
<code>//(num, den)</code> </dt> <dd>
<p>Divide two integers or rational numbers, giving a <code>Rational</code> result.</p> </dd>
</dl> <dl class="function"> <dt id="Base.rationalize"><code>rationalize([T<:integer tol::real="eps(x))&lt;/code"> </:integer></code></dt> <dd>
<p>Approximate floating point number <code>x</code> as a <code>Rational</code> number with components of the given integer type. The result will differ from <code>x</code> by no more than <code>tol</code>. If <code>T</code> is not provided, it defaults to <code>Int</code>.</p> <pre data-language="julia">julia&gt; rationalize(5.6)
28//5

julia&gt; a = rationalize(BigInt, 10.3)
103//10

julia&gt; typeof(num(a))
BigInt
</pre> </dd>
</dl> <dl class="function"> <dt id="Base.num">
<code>num(x)</code> </dt> <dd>
<p>Numerator of the rational representation of <code>x</code>.</p> </dd>
</dl> <dl class="function"> <dt id="Base.den">
<code>den(x)</code> </dt> <dd>
<p>Denominator of the rational representation of <code>x</code>.</p> </dd>
</dl> <dl class="function" id="id15"> <dt id="Base.&lt;&lt;"><code>&lt; </code></dt> <dd>
<p>Left bit shift operator, <code>x &lt;&lt; n</code>. For <code>n &gt;= 0</code>, the result is <code>x</code> shifted left by <code>n</code> bits, filling with <code>0</code>s. This is equivalent to <code>x * 2^n</code>. For <code>n &lt; 0</code>, this is equivalent to <code>x &gt;&gt; -n</code>.</p> <pre data-language="julia">julia&gt; Int8(3) &lt;&lt; 2
12

julia&gt; bits(Int8(3))
"00000011"

julia&gt; bits(Int8(12))
"00001100"
</pre> <p>See also <a class="reference internal" href="#Base.&gt;&gt;" title="Base.&gt;&gt;"><code>&gt;&gt;()</code></a>, <a class="reference internal" href="#Base.&gt;&gt;&gt;" title="Base.&gt;&gt;&gt;"><code>&gt;&gt;&gt;()</code></a>.</p> </dd>
</dl> <dl class="function" id="id16"> <dt id="Base.&gt;&gt;">
<code>&gt;&gt;(x, n)</code> </dt> <dd>
<p>Right bit shift operator, <code>x &gt;&gt; n</code>. For <code>n &gt;= 0</code>, the result is <code>x</code> shifted right by <code>n</code> bits, where <code>n &gt;= 0</code>, filling with <code>0</code>s if <code>x &gt;= 0</code>, <code>1</code>s if <code>x &lt; 0</code>, preserving the sign of <code>x</code>. This is equivalent to <code>fld(x, 2^n)</code>. For <code>n &lt; 0</code>, this is equivalent to <code>x &lt;&lt; -n</code>.</p> <pre data-language="julia">julia&gt; Int8(13) &gt;&gt; 2
3

julia&gt; bits(Int8(13))
"00001101"

julia&gt; bits(Int8(3))
"00000011"

julia&gt; Int8(-14) &gt;&gt; 2
-4

julia&gt; bits(Int8(-14))
"11110010"

julia&gt; bits(Int8(-4))
"11111100"
</pre> <p>See also <a class="reference internal" href="#Base.&gt;&gt;&gt;" title="Base.&gt;&gt;&gt;"><code>&gt;&gt;&gt;()</code></a>, <a class="reference internal" href="#Base.&lt;&lt;" title="Base.&lt;&lt;"><code>&lt;&lt;()</code></a>.</p> </dd>
</dl> <dl class="function" id="id17"> <dt id="Base.&gt;&gt;&gt;">
<code>&gt;&gt;&gt;(x, n)</code> </dt> <dd>
<p>Unsigned right bit shift operator, <code>x &gt;&gt;&gt; n</code>. For <code>n &gt;= 0</code>, the result is <code>x</code> shifted right by <code>n</code> bits, where <code>n &gt;= 0</code>, filling with <code>0</code>s. For <code>n &lt; 0</code>, this is equivalent to <code>x &lt;&lt; -n</code>.</p> <p>For <code>Unsigned</code> integer types, this is equivalent to <a class="reference internal" href="#Base.&gt;&gt;" title="Base.&gt;&gt;"><code>&gt;&gt;()</code></a>. For <code>Signed</code> integer types, this is equivalent to <code>signed(unsigned(x) &gt;&gt; n)</code>.</p> <pre data-language="julia">julia&gt; Int8(-14) &gt;&gt;&gt; 2
60

julia&gt; bits(Int8(-14))
"11110010"

julia&gt; bits(Int8(60))
"00111100"
</pre> <p><code>BigInt</code>s are treated as if having infinite size, so no filling is required and this is equivalent to <a class="reference internal" href="#Base.&gt;&gt;" title="Base.&gt;&gt;"><code>&gt;&gt;()</code></a>.</p> <p>See also <a class="reference internal" href="#Base.&gt;&gt;" title="Base.&gt;&gt;"><code>&gt;&gt;()</code></a>, <a class="reference internal" href="#Base.&lt;&lt;" title="Base.&lt;&lt;"><code>&lt;&lt;()</code></a>.</p> </dd>
</dl> <dl class="function" id="id18"> <dt id="Base.:">
<code>:(start, [step, ]stop)</code> </dt> <dd>
<p>Range operator. <code>a:b</code> constructs a range from <code>a</code> to <code>b</code> with a step size of 1, and <code>a:s:b</code> is similar but uses a step size of <code>s</code>. These syntaxes call the function <code>colon</code>. The colon is also used in indexing to select whole dimensions.</p> </dd>
</dl> <dl class="function"> <dt id="Base.colon">
<code>colon(start, [step, ]stop)</code> </dt> <dd>
<p>Called by <code>:</code> syntax for constructing ranges.</p> </dd>
</dl> <dl class="function"> <dt id="Base.range">
<code>range(start, [step, ]length)</code> </dt> <dd>
<p>Construct a range by length, given a starting value and optional step (defaults to 1).</p> </dd>
</dl> <dl class="function"> <dt id="Base.Base.OneTo">
<code>Base.OneTo(n)</code> </dt> <dd>
<p>Define an <code>AbstractUnitRange</code> that behaves like <code>1:n</code>, with the added distinction that the lower limit is guaranteed (by the type system) to be 1.</p> </dd>
</dl> <dl class="function" id="id19"> <dt id="Base.==">
<code>==(x, y)</code> </dt> <dd>
<p>Generic equality operator, giving a single <code>Bool</code> result. Falls back to <code>===</code>. Should be implemented for all types with a notion of equality, based on the abstract value that an instance represents. For example, all numeric types are compared by numeric value, ignoring type. Strings are compared as sequences of characters, ignoring encoding.</p> <p>Follows IEEE semantics for floating-point numbers.</p> <p>Collections should generally implement <code>==</code> by calling <code>==</code> recursively on all contents.</p> <p>New numeric types should implement this function for two arguments of the new type, and handle comparison to other types via promotion rules where possible.</p> </dd>
</dl> <dl class="function" id="id20"> <dt id="Base.!=">
<code>!=(x, y)</code> </dt> <dt id="Base.≠">
<code>≠(x, y)</code> </dt> <dd>
<p>Not-equals comparison operator. Always gives the opposite answer as <code>==</code>. New types should generally not implement this, and rely on the fallback definition <code>!=(x,y) = !(x==y)</code> instead.</p> </dd>
</dl> <dl class="function" id="id21"> <dt id="Base.===">
<code>===(x, y)</code> </dt> <dt id="Base.≡">
<code>≡(x, y)</code> </dt> <dd>
<p>See the <a class="reference internal" href="../base/#Base.is" title="Base.is"><code>is()</code></a> operator.</p> </dd>
</dl> <dl class="function" id="id22"> <dt id="Base.!==">
<code>!==(x, y)</code> </dt> <dt id="Base.≢">
<code>≢(x, y)</code> </dt> <dd>
<p>Equivalent to <code>!is(x, y)</code>.</p> </dd>
</dl> <dl class="function" id="id23">  <dd>
<p>Less-than comparison operator. New numeric types should implement this function for two arguments of the new type. Because of the behavior of floating-point NaN values, <code>&lt;</code> implements a partial order. Types with a canonical partial order should implement <code>&lt;</code>, and types with a canonical total order should implement <code>isless</code>.</p> </dd>
</dl> <dl class="function" id="id24"> <dt id="Base.&lt;=">
<code>&lt;=(x, y)</code> </dt> <dt id="Base.≤">
<code>≤(x, y)</code> </dt> <dd>
<p>Less-than-or-equals comparison operator.</p> </dd>
</dl> <dl class="function" id="id25"> <dt id="Base.&gt;">
<code>&gt;(x, y)</code> </dt> <dd>
<p>Greater-than comparison operator. Generally, new types should implement <code>&lt;</code> instead of this function, and rely on the fallback definition <code>&gt;(x,y) = y&lt;x</code>.</p> </dd>
</dl> <dl class="function" id="id26"> <dt id="Base.&gt;=">
<code>&gt;=(x, y)</code> </dt> <dt id="Base.≥">
<code>≥(x, y)</code> </dt> <dd>
<p>Greater-than-or-equals comparison operator.</p> </dd>
</dl> <dl class="function" id="id27"> <dt id="Base..==">
<code>.==(x, y)</code> </dt> <dd>
<p>Element-wise equality comparison operator.</p> </dd>
</dl> <dl class="function" id="id28"> <dt id="Base..!=">
<code>.!=(x, y)</code> </dt> <dt id="Base..≠">
<code>.≠(x, y)</code> </dt> <dd>
<p>Element-wise not-equals comparison operator.</p> </dd>
</dl> <dl class="function" id="id29"> <dt id="Base..&lt;"><code>. </code></dt> <dd>
<p>Element-wise less-than comparison operator.</p> </dd>
</dl> <dl class="function" id="id30"> <dt id="Base..&lt;=">
<code>.&lt;=(x, y)</code> </dt> <dt id="Base..≤">
<code>.≤(x, y)</code> </dt> <dd>
<p>Element-wise less-than-or-equals comparison operator.</p> </dd>
</dl> <dl class="function" id="id31"> <dt id="Base..&gt;">
<code>.&gt;(x, y)</code> </dt> <dd>
<p>Element-wise greater-than comparison operator.</p> </dd>
</dl> <dl class="function" id="id32"> <dt id="Base..&gt;=">
<code>.&gt;=(x, y)</code> </dt> <dt id="Base..≥">
<code>.≥(x, y)</code> </dt> <dd>
<p>Element-wise greater-than-or-equals comparison operator.</p> </dd>
</dl> <dl class="function"> <dt id="Base.cmp">
<code>cmp(x, y)</code> </dt> <dd>
<p>Return -1, 0, or 1 depending on whether <code>x</code> is less than, equal to, or greater than <code>y</code>, respectively. Uses the total order implemented by <code>isless</code>. For floating-point numbers, uses <code>&lt;</code> but throws an error for unordered arguments.</p> </dd>
</dl> <dl class="function" id="id33"> <dt id="Base.~">
<code>~(x)</code> </dt> <dd>
<p>Bitwise not.</p> </dd>
</dl> <dl class="function" id="id34"> <dt id="Base.&amp;">
<code>&amp;(x, y)</code> </dt> <dd>
<p>Bitwise and.</p> </dd>
</dl> <dl class="function" id="id35"> <dt id="Base.|">
<code>|(x, y)</code> </dt> <dd>
<p>Bitwise or.</p> </dd>
</dl> <dl class="function" id="id36"> <dt id="Base.$">
<code>$(x, y)</code> </dt> <dd>
<p>Bitwise exclusive or.</p> </dd>
</dl> <dl class="function" id="id37"> <dt id="Base.!">
<code>!(x)</code> </dt> <dd>
<p>Boolean not.</p> </dd>
</dl> <dl class="function" id="id38"> <dt>
<code>x &amp;&amp; y</code> </dt> <dd>
<p>Short-circuiting boolean AND.</p> </dd>
</dl> <dl class="function" id="id39"> <dt>
<code>x || y</code> </dt> <dd>
<p>Short-circuiting boolean OR.</p> </dd>
</dl>   <h2 id="mathematical-functions">Mathematical Functions</h2> <dl class="function"> <dt id="Base.isapprox">
<code>isapprox(x, y; rtol::Real=sqrt(eps), atol::Real=0)</code> </dt> <dd>
<p>Inexact equality comparison: <code>true</code> if <code>norm(x-y) &lt;= atol + rtol*max(norm(x), norm(y))</code>. The default <code>atol</code> is zero and the default <code>rtol</code> depends on the types of <code>x</code> and <code>y</code>.</p> <p>For real or complex floating-point values, <code>rtol</code> defaults to <code>sqrt(eps(typeof(real(x-y))))</code>. This corresponds to requiring equality of about half of the significand digits. For other types, <code>rtol</code> defaults to zero.</p> <p><code>x</code> and <code>y</code> may also be arrays of numbers, in which case <code>norm</code> defaults to <code>vecnorm</code> but may be changed by passing a <code>norm::Function</code> keyword argument. (For numbers, <code>norm</code> is the same thing as <code>abs</code>.) When <code>x</code> and <code>y</code> are arrays, if <code>norm(x-y)</code> is not finite (i.e. <code>±Inf</code> or <code>NaN</code>), the comparison falls back to checking whether all elements of <code>x</code> and <code>y</code> are approximately equal component-wise.</p> <p>The binary operator <code>≈</code> is equivalent to <code>isapprox</code> with the default arguments, and <code>x ≉ y</code> is equivalent to <code>!isapprox(x,y)</code>.</p> </dd>
</dl> <dl class="function"> <dt id="Base.sin">
<code>sin(x)</code> </dt> <dd>
<p>Compute sine of <code>x</code>, where <code>x</code> is in radians.</p> </dd>
</dl> <dl class="function"> <dt id="Base.cos">
<code>cos(x)</code> </dt> <dd>
<p>Compute cosine of <code>x</code>, where <code>x</code> is in radians.</p> </dd>
</dl> <dl class="function"> <dt id="Base.tan">
<code>tan(x)</code> </dt> <dd>
<p>Compute tangent of <code>x</code>, where <code>x</code> is in radians.</p> </dd>
</dl> <dl class="function"> <dt id="Base.sind">
<code>sind(x)</code> </dt> <dd>
<p>Compute sine of <code>x</code>, where <code>x</code> is in degrees.</p> </dd>
</dl> <dl class="function"> <dt id="Base.cosd">
<code>cosd(x)</code> </dt> <dd>
<p>Compute cosine of <code>x</code>, where <code>x</code> is in degrees.</p> </dd>
</dl> <dl class="function"> <dt id="Base.tand">
<code>tand(x)</code> </dt> <dd>
<p>Compute tangent of <code>x</code>, where <code>x</code> is in degrees.</p> </dd>
</dl> <dl class="function"> <dt id="Base.sinpi">
<code>sinpi(x)</code> </dt> <dd>
<p>Compute <span class="math">\(\sin(\pi x)\)</span> more accurately than <code>sin(pi*x)</code>, especially for large <code>x</code>.</p> </dd>
</dl> <dl class="function"> <dt id="Base.cospi">
<code>cospi(x)</code> </dt> <dd>
<p>Compute <span class="math">\(\cos(\pi x)\)</span> more accurately than <code>cos(pi*x)</code>, especially for large <code>x</code>.</p> </dd>
</dl> <dl class="function"> <dt id="Base.sinh">
<code>sinh(x)</code> </dt> <dd>
<p>Compute hyperbolic sine of <code>x</code>.</p> </dd>
</dl> <dl class="function"> <dt id="Base.cosh">
<code>cosh(x)</code> </dt> <dd>
<p>Compute hyperbolic cosine of <code>x</code>.</p> </dd>
</dl> <dl class="function"> <dt id="Base.tanh">
<code>tanh(x)</code> </dt> <dd>
<p>Compute hyperbolic tangent of <code>x</code>.</p> </dd>
</dl> <dl class="function"> <dt id="Base.asin">
<code>asin(x)</code> </dt> <dd>
<p>Compute the inverse sine of <code>x</code>, where the output is in radians.</p> </dd>
</dl> <dl class="function"> <dt id="Base.acos">
<code>acos(x)</code> </dt> <dd>
<p>Compute the inverse cosine of <code>x</code>, where the output is in radians</p> </dd>
</dl> <dl class="function"> <dt id="Base.atan">
<code>atan(x)</code> </dt> <dd>
<p>Compute the inverse tangent of <code>x</code>, where the output is in radians.</p> </dd>
</dl> <dl class="function"> <dt id="Base.atan2">
<code>atan2(y, x)</code> </dt> <dd>
<p>Compute the inverse tangent of <code>y/x</code>, using the signs of both <code>x</code> and <code>y</code> to determine the quadrant of the return value.</p> </dd>
</dl> <dl class="function"> <dt id="Base.asind">
<code>asind(x)</code> </dt> <dd>
<p>Compute the inverse sine of <code>x</code>, where the output is in degrees.</p> </dd>
</dl> <dl class="function"> <dt id="Base.acosd">
<code>acosd(x)</code> </dt> <dd>
<p>Compute the inverse cosine of <code>x</code>, where the output is in degrees.</p> </dd>
</dl> <dl class="function"> <dt id="Base.atand">
<code>atand(x)</code> </dt> <dd>
<p>Compute the inverse tangent of <code>x</code>, where the output is in degrees.</p> </dd>
</dl> <dl class="function"> <dt id="Base.sec">
<code>sec(x)</code> </dt> <dd>
<p>Compute the secant of <code>x</code>, where <code>x</code> is in radians.</p> </dd>
</dl> <dl class="function"> <dt id="Base.csc">
<code>csc(x)</code> </dt> <dd>
<p>Compute the cosecant of <code>x</code>, where <code>x</code> is in radians.</p> </dd>
</dl> <dl class="function"> <dt id="Base.cot">
<code>cot(x)</code> </dt> <dd>
<p>Compute the cotangent of <code>x</code>, where <code>x</code> is in radians.</p> </dd>
</dl> <dl class="function"> <dt id="Base.secd">
<code>secd(x)</code> </dt> <dd>
<p>Compute the secant of <code>x</code>, where <code>x</code> is in degrees.</p> </dd>
</dl> <dl class="function"> <dt id="Base.cscd">
<code>cscd(x)</code> </dt> <dd>
<p>Compute the cosecant of <code>x</code>, where <code>x</code> is in degrees.</p> </dd>
</dl> <dl class="function"> <dt id="Base.cotd">
<code>cotd(x)</code> </dt> <dd>
<p>Compute the cotangent of <code>x</code>, where <code>x</code> is in degrees.</p> </dd>
</dl> <dl class="function"> <dt id="Base.asec">
<code>asec(x)</code> </dt> <dd>
<p>Compute the inverse secant of <code>x</code>, where the output is in radians.</p> </dd>
</dl> <dl class="function"> <dt id="Base.acsc">
<code>acsc(x)</code> </dt> <dd>
<p>Compute the inverse cosecant of <code>x</code>, where the output is in radians.</p> </dd>
</dl> <dl class="function"> <dt id="Base.acot">
<code>acot(x)</code> </dt> <dd>
<p>Compute the inverse cotangent of <code>x</code>, where the output is in radians.</p> </dd>
</dl> <dl class="function"> <dt id="Base.asecd">
<code>asecd(x)</code> </dt> <dd>
<p>Compute the inverse secant of <code>x</code>, where the output is in degrees.</p> </dd>
</dl> <dl class="function"> <dt id="Base.acscd">
<code>acscd(x)</code> </dt> <dd>
<p>Compute the inverse cosecant of <code>x</code>, where the output is in degrees.</p> </dd>
</dl> <dl class="function"> <dt id="Base.acotd">
<code>acotd(x)</code> </dt> <dd>
<p>Compute the inverse cotangent of <code>x</code>, where the output is in degrees.</p> </dd>
</dl> <dl class="function"> <dt id="Base.sech">
<code>sech(x)</code> </dt> <dd>
<p>Compute the hyperbolic secant of <code>x</code></p> </dd>
</dl> <dl class="function"> <dt id="Base.csch">
<code>csch(x)</code> </dt> <dd>
<p>Compute the hyperbolic cosecant of <code>x</code>.</p> </dd>
</dl> <dl class="function"> <dt id="Base.coth">
<code>coth(x)</code> </dt> <dd>
<p>Compute the hyperbolic cotangent of <code>x</code>.</p> </dd>
</dl> <dl class="function"> <dt id="Base.asinh">
<code>asinh(x)</code> </dt> <dd>
<p>Compute the inverse hyperbolic sine of <code>x</code>.</p> </dd>
</dl> <dl class="function"> <dt id="Base.acosh">
<code>acosh(x)</code> </dt> <dd>
<p>Compute the inverse hyperbolic cosine of <code>x</code>.</p> </dd>
</dl> <dl class="function"> <dt id="Base.atanh">
<code>atanh(x)</code> </dt> <dd>
<p>Compute the inverse hyperbolic tangent of <code>x</code>.</p> </dd>
</dl> <dl class="function"> <dt id="Base.asech">
<code>asech(x)</code> </dt> <dd>
<p>Compute the inverse hyperbolic secant of <code>x</code>.</p> </dd>
</dl> <dl class="function"> <dt id="Base.acsch">
<code>acsch(x)</code> </dt> <dd>
<p>Compute the inverse hyperbolic cosecant of <code>x</code>.</p> </dd>
</dl> <dl class="function"> <dt id="Base.acoth">
<code>acoth(x)</code> </dt> <dd>
<p>Compute the inverse hyperbolic cotangent of <code>x</code>.</p> </dd>
</dl> <dl class="function"> <dt id="Base.sinc">
<code>sinc(x)</code> </dt> <dd>
<p>Compute <span class="math">\(\sin(\pi x) / (\pi x)\)</span> if <span class="math">\(x \neq 0\)</span>, and <span class="math">\(1\)</span> if <span class="math">\(x = 0\)</span>.</p> </dd>
</dl> <dl class="function"> <dt id="Base.cosc">
<code>cosc(x)</code> </dt> <dd>
<p>Compute <span class="math">\(\cos(\pi x) / x - \sin(\pi x) / (\pi x^2)\)</span> if <span class="math">\(x \neq 0\)</span>, and <span class="math">\(0\)</span> if <span class="math">\(x = 0\)</span>. This is the derivative of <code>sinc(x)</code>.</p> </dd>
</dl> <dl class="function"> <dt id="Base.deg2rad">
<code>deg2rad(x)</code> </dt> <dd>
<p>Convert <code>x</code> from degrees to radians.</p> </dd>
</dl> <dl class="function"> <dt id="Base.rad2deg">
<code>rad2deg(x)</code> </dt> <dd>
<p>Convert <code>x</code> from radians to degrees.</p> </dd>
</dl> <dl class="function"> <dt id="Base.hypot">
<code>hypot(x, y)</code> </dt> <dd>
<p>Compute the hypotenuse <span class="math">\(\sqrt{x^2+y^2}\)</span> avoiding overflow and underflow.</p> </dd>
</dl> <dl class="function"> <dt>
<code>hypot(x...)</code> </dt> <dd>
<p>Compute the hypotenuse <span class="math">\(\sqrt{\sum x_i^2}\)</span> avoiding overflow and underflow.</p> </dd>
</dl> <dl class="function"> <dt id="Base.log">
<code>log(x)</code> </dt> <dd>
<p>Compute the natural logarithm of <code>x</code>. Throws <code>DomainError</code> for negative <code>Real</code> arguments. Use complex negative arguments to obtain complex results.</p> <p>There is an experimental variant in the <code>Base.Math.JuliaLibm</code> module, which is typically faster and more accurate.</p> </dd>
</dl> <dl class="function"> <dt>
<code>log(b, x)</code> </dt> <dd>
<p>Compute the base <code>b</code> logarithm of <code>x</code>. Throws <code>DomainError</code> for negative <code>Real</code> arguments.</p> <pre data-language="julia">julia&gt; log(4,8)
1.5

julia&gt; log(4,2)
0.5
</pre> <div class="admonition note"> <p class="first admonition-title">Note</p> <p>If <code>b</code> is a power of 2 or 10, <code>log2</code> or <code>log10</code> should be used, as these will typically be faster and more accurate. For example,</p> <pre data-language="julia">julia&gt; log(100,1000000)
2.9999999999999996

julia&gt; log10(1000000)/2
3.0
</pre> </div> </dd>
</dl> <dl class="function"> <dt id="Base.log2">
<code>log2(x)</code> </dt> <dd>
<p>Compute the logarithm of <code>x</code> to base 2. Throws <code>DomainError</code> for negative <code>Real</code> arguments.</p> </dd>
</dl> <dl class="function"> <dt id="Base.log10">
<code>log10(x)</code> </dt> <dd>
<p>Compute the logarithm of <code>x</code> to base 10. Throws <code>DomainError</code> for negative <code>Real</code> arguments.</p> </dd>
</dl> <dl class="function"> <dt id="Base.log1p">
<code>log1p(x)</code> </dt> <dd>
<p>Accurate natural logarithm of <code>1+x</code>. Throws <code>DomainError</code> for <code>Real</code> arguments less than -1.</p> <p>There is an experimental variant in the <code>Base.Math.JuliaLibm</code> module, which is typically faster and more accurate.</p> </dd>
</dl> <dl class="function"> <dt id="Base.frexp">
<code>frexp(val)</code> </dt> <dd>
<p>Return <code>(x,exp)</code> such that <code>x</code> has a magnitude in the interval <span class="math">\([1/2, 1)\)</span> or 0, and val = <span class="math">\(x \times 2^{exp}\)</span>.</p> </dd>
</dl> <dl class="function"> <dt id="Base.exp">
<code>exp(x)</code> </dt> <dd>
<p>Compute <span class="math">\(e^x\)</span>.</p> </dd>
</dl> <dl class="function"> <dt id="Base.exp2">
<code>exp2(x)</code> </dt> <dd>
<p>Compute <span class="math">\(2^x\)</span>.</p> </dd>
</dl> <dl class="function"> <dt id="Base.exp10">
<code>exp10(x)</code> </dt> <dd>
<p>Compute <span class="math">\(10^x\)</span>.</p> </dd>
</dl> <dl class="function"> <dt id="Base.ldexp">
<code>ldexp(x, n)</code> </dt> <dd>
<p>Compute <span class="math">\(x \times 2^n\)</span>.</p> </dd>
</dl> <dl class="function"> <dt id="Base.modf">
<code>modf(x)</code> </dt> <dd>
<p>Return a tuple (fpart,ipart) of the fractional and integral parts of a number. Both parts have the same sign as the argument.</p> </dd>
</dl> <dl class="function"> <dt id="Base.expm1">
<code>expm1(x)</code> </dt> <dd>
<p>Accurately compute <span class="math">\(e^x-1\)</span>.</p> </dd>
</dl> <dl class="function"> <dt id="Base.round">
<code>round([T, ]x[, digits[, base]][, r::RoundingMode])</code> </dt> <dd>
<p>Rounds <code>x</code> to an integer value according to the provided <a class="reference internal" href="#Base.RoundingMode" title="Base.RoundingMode"><code>RoundingMode</code></a>, returning a value of the same type as <code>x</code>. When not specifying a rounding mode the global mode will be used (see <a class="reference internal" href="../numbers/#Base.rounding" title="Base.rounding"><code>rounding()</code></a>), which by default is round to the nearest integer (<a class="reference internal" href="#Base.RoundNearest" title="Base.RoundNearest"><code>RoundNearest</code></a> mode), with ties (fractional values of 0.5) being rounded to the nearest even integer.</p> <pre data-language="julia">julia&gt; round(1.7)
2.0

julia&gt; round(1.5)
2.0

julia&gt; round(2.5)
2.0
</pre> <p>The optional <a class="reference internal" href="#Base.RoundingMode" title="Base.RoundingMode"><code>RoundingMode</code></a> argument will change how the number gets rounded.</p> <p><code>round(T, x, [r::RoundingMode])</code> converts the result to type <code>T</code>, throwing an <a class="reference internal" href="../base/#Base.InexactError" title="Base.InexactError"><code>InexactError</code></a> if the value is not representable.</p> <p><code>round(x, digits)</code> rounds to the specified number of digits after the decimal place (or before if negative). <code>round(x, digits, base)</code> rounds using a base other than 10.</p> <pre data-language="julia">julia&gt; round(pi, 2)
3.14

julia&gt; round(pi, 3, 2)
3.125
</pre> <div class="admonition note"> <p class="first admonition-title">Note</p> <p>Rounding to specified digits in bases other than 2 can be inexact when operating on binary floating point numbers. For example, the <code>Float64</code> value represented by <code>1.15</code> is actually <em>less</em> than 1.15, yet will be rounded to 1.2.</p> <pre data-language="julia">julia&gt; x = 1.15
1.15

julia&gt; @sprintf "%.20f" x
"1.14999999999999991118"

julia&gt; x &lt; 115//100
true

julia&gt; round(x, 1)
1.2
</pre> </div> </dd>
</dl> <dl class="type"> <dt id="Base.RoundingMode">
<code>RoundingMode</code> </dt> <dd>
<p>A type used for controlling the rounding mode of floating point operations (via <a class="reference internal" href="../numbers/#Base.rounding" title="Base.rounding"><code>rounding()</code></a>/<a class="reference internal" href="../numbers/#Base.setrounding" title="Base.setrounding"><code>setrounding()</code></a> functions), or as optional arguments for rounding to the nearest integer (via the <a class="reference internal" href="#Base.round" title="Base.round"><code>round()</code></a> function).</p> <p>Currently supported rounding modes are:</p> <ul class="simple"> <li>
<a class="reference internal" href="#Base.RoundNearest" title="Base.RoundNearest"><code>RoundNearest</code></a> (default)</li> <li><a class="reference internal" href="#Base.RoundNearestTiesAway" title="Base.RoundNearestTiesAway"><code>RoundNearestTiesAway</code></a></li> <li><a class="reference internal" href="#Base.RoundNearestTiesUp" title="Base.RoundNearestTiesUp"><code>RoundNearestTiesUp</code></a></li> <li><a class="reference internal" href="#Base.RoundToZero" title="Base.RoundToZero"><code>RoundToZero</code></a></li> <li>
<code>RoundFromZero</code> (<code>BigFloat</code> only)</li> <li><a class="reference internal" href="#Base.RoundUp" title="Base.RoundUp"><code>RoundUp</code></a></li> <li><a class="reference internal" href="#Base.RoundDown" title="Base.RoundDown"><code>RoundDown</code></a></li> </ul> </dd>
</dl> <dl class="data"> <dt id="Base.RoundNearest">
<code>RoundNearest</code> </dt> <dd>
<p>The default rounding mode. Rounds to the nearest integer, with ties (fractional values of 0.5) being rounded to the nearest even integer.</p> </dd>
</dl> <dl class="data"> <dt id="Base.RoundNearestTiesAway">
<code>RoundNearestTiesAway</code> </dt> <dd>
<p>Rounds to nearest integer, with ties rounded away from zero (C/C++ <a class="reference internal" href="#Base.round" title="Base.round"><code>round()</code></a> behaviour).</p> </dd>
</dl> <dl class="data"> <dt id="Base.RoundNearestTiesUp">
<code>RoundNearestTiesUp</code> </dt> <dd>
<p>Rounds to nearest integer, with ties rounded toward positive infinity (Java/JavaScript <a class="reference internal" href="#Base.round" title="Base.round"><code>round()</code></a> behaviour).</p> </dd>
</dl> <dl class="data"> <dt id="Base.RoundToZero">
<code>RoundToZero</code> </dt> <dd>
<p><a class="reference internal" href="#Base.round" title="Base.round"><code>round()</code></a> using this rounding mode is an alias for <a class="reference internal" href="#Base.trunc" title="Base.trunc"><code>trunc()</code></a>.</p> </dd>
</dl> <dl class="data"> <dt id="Base.RoundUp">
<code>RoundUp</code> </dt> <dd>
<p><a class="reference internal" href="#Base.round" title="Base.round"><code>round()</code></a> using this rounding mode is an alias for <a class="reference internal" href="#Base.ceil" title="Base.ceil"><code>ceil()</code></a>.</p> </dd>
</dl> <dl class="data"> <dt id="Base.RoundDown">
<code>RoundDown</code> </dt> <dd>
<p><a class="reference internal" href="#Base.round" title="Base.round"><code>round()</code></a> using this rounding mode is an alias for <a class="reference internal" href="#Base.floor" title="Base.floor"><code>floor()</code></a>.</p> </dd>
</dl> <dl class="function"> <dt>
<code>round(z, RoundingModeReal, RoundingModeImaginary)</code> </dt> <dd>
<p>Returns the nearest integral value of the same type as the complex-valued <code>z</code> to <code>z</code>, breaking ties using the specified <a class="reference internal" href="#Base.RoundingMode" title="Base.RoundingMode"><code>RoundingMode</code></a>s. The first <a class="reference internal" href="#Base.RoundingMode" title="Base.RoundingMode"><code>RoundingMode</code></a> is used for rounding the real components while the second is used for rounding the imaginary components.</p> </dd>
</dl> <dl class="function"> <dt id="Base.ceil">
<code>ceil([T, ]x[, digits[, base]])</code> </dt> <dd>
<p><code>ceil(x)</code> returns the nearest integral value of the same type as <code>x</code> that is greater than or equal to <code>x</code>.</p> <p><code>ceil(T, x)</code> converts the result to type <code>T</code>, throwing an <code>InexactError</code> if the value is not representable.</p> <p><code>digits</code> and <code>base</code> work as for <a class="reference internal" href="#Base.round" title="Base.round"><code>round()</code></a>.</p> </dd>
</dl> <dl class="function"> <dt id="Base.floor">
<code>floor([T, ]x[, digits[, base]])</code> </dt> <dd>
<p><code>floor(x)</code> returns the nearest integral value of the same type as <code>x</code> that is less than or equal to <code>x</code>.</p> <p><code>floor(T, x)</code> converts the result to type <code>T</code>, throwing an <code>InexactError</code> if the value is not representable.</p> <p><code>digits</code> and <code>base</code> work as for <a class="reference internal" href="#Base.round" title="Base.round"><code>round()</code></a>.</p> </dd>
</dl> <dl class="function"> <dt id="Base.trunc">
<code>trunc([T, ]x[, digits[, base]])</code> </dt> <dd>
<p><code>trunc(x)</code> returns the nearest integral value of the same type as <code>x</code> whose absolute value is less than or equal to <code>x</code>.</p> <p><code>trunc(T, x)</code> converts the result to type <code>T</code>, throwing an <code>InexactError</code> if the value is not representable.</p> <p><code>digits</code> and <code>base</code> work as for <a class="reference internal" href="#Base.round" title="Base.round"><code>round()</code></a>.</p> </dd>
</dl> <dl class="function"> <dt id="Base.unsafe_trunc">
<code>unsafe_trunc(T, x)</code> </dt> <dd>
<p><code>unsafe_trunc(T, x)</code> returns the nearest integral value of type <code>T</code> whose absolute value is less than or equal to <code>x</code>. If the value is not representable by <code>T</code>, an arbitrary value will be returned.</p> </dd>
</dl> <dl class="function"> <dt id="Base.signif">
<code>signif(x, digits[, base])</code> </dt> <dd>
<p>Rounds (in the sense of <code>round</code>) <code>x</code> so that there are <code>digits</code> significant digits, under a base <code>base</code> representation, default 10. E.g., <code>signif(123.456, 2)</code> is <code>120.0</code>, and <code>signif(357.913, 4, 2)</code> is <code>352.0</code>.</p> </dd>
</dl> <dl class="function"> <dt id="Base.min">
<code>min(x, y, ...)</code> </dt> <dd>
<p>Return the minimum of the arguments. Operates elementwise over arrays.</p> </dd>
</dl> <dl class="function"> <dt id="Base.max">
<code>max(x, y, ...)</code> </dt> <dd>
<p>Return the maximum of the arguments. Operates elementwise over arrays.</p> </dd>
</dl> <dl class="function"> <dt id="Base.minmax">
<code>minmax(x, y)</code> </dt> <dd>
<p>Return <code>(min(x,y), max(x,y))</code>. See also: <a class="reference internal" href="../collections/#Base.extrema" title="Base.extrema"><code>extrema()</code></a> that returns <code>(minimum(x), maximum(x))</code>.</p> <pre data-language="julia">julia&gt; minmax('c','b')
('b','c')
</pre> </dd>
</dl> <dl class="function"> <dt id="Base.clamp">
<code>clamp(x, lo, hi)</code> </dt> <dd>
<p>Return <code>x</code> if <code>lo &lt;= x &lt;= hi</code>. If <code>x &lt; lo</code>, return <code>lo</code>. If <code>x &gt; hi</code>, return <code>hi</code>. Arguments are promoted to a common type. Operates elementwise over <code>x</code> if <code>x</code> is an array.</p> <pre data-language="julia">julia&gt; clamp([pi, 1.0, big(10.)], 2., 9.)
3-element Array{BigFloat,1}:
 3.141592653589793238462643383279502884197169399375105820974944592307816406286198
 2.000000000000000000000000000000000000000000000000000000000000000000000000000000
 9.000000000000000000000000000000000000000000000000000000000000000000000000000000
</pre> </dd>
</dl> <dl class="function"> <dt id="Base.clamp!">
<code>clamp!(array::AbstractArray, lo, hi)</code> </dt> <dd>
<p>Restrict values in <code>array</code> to the specified range, in-place. See also <a class="reference internal" href="#Base.clamp" title="Base.clamp"><code>clamp()</code></a>.</p> </dd>
</dl> <dl class="function"> <dt id="Base.abs">
<code>abs(x)</code> </dt> <dd>
<p>The absolute value of <code>x</code>.</p> <p>When <code>abs</code> is applied to signed integers, overflow may occur, resulting in the return of a negative value. This overflow occurs only when <code>abs</code> is applied to the minimum representable value of a signed integer. That is, when <code>x == typemin(typeof(x))</code>, <code>abs(x) == x &lt; 0</code>, not <code>-x</code> as might be expected.</p> </dd>
</dl> <dl class="function"> <dt id="Base.Base.checked_abs">
<code>Base.checked_abs(x)</code> </dt> <dd>
<p>Calculates <code>abs(x)</code>, checking for overflow errors where applicable. For example, standard two’s complement signed integers (e.g. <code>Int</code>) cannot represent <code>abs(typemin(Int))</code>, thus leading to an overflow.</p> <p>The overflow protection may impose a perceptible performance penalty.</p> </dd>
</dl> <dl class="function"> <dt id="Base.Base.checked_neg">
<code>Base.checked_neg(x)</code> </dt> <dd>
<p>Calculates <code>-x</code>, checking for overflow errors where applicable. For example, standard two’s complement signed integers (e.g. <code>Int</code>) cannot represent <code>-typemin(Int)</code>, thus leading to an overflow.</p> <p>The overflow protection may impose a perceptible performance penalty.</p> </dd>
</dl> <dl class="function"> <dt id="Base.Base.checked_add">
<code>Base.checked_add(x, y)</code> </dt> <dd>
<p>Calculates <code>x+y</code>, checking for overflow errors where applicable.</p> <p>The overflow protection may impose a perceptible performance penalty.</p> </dd>
</dl> <dl class="function"> <dt id="Base.Base.checked_sub">
<code>Base.checked_sub(x, y)</code> </dt> <dd>
<p>Calculates <code>x-y</code>, checking for overflow errors where applicable.</p> <p>The overflow protection may impose a perceptible performance penalty.</p> </dd>
</dl> <dl class="function"> <dt id="Base.Base.checked_mul">
<code>Base.checked_mul(x, y)</code> </dt> <dd>
<p>Calculates <code>x*y</code>, checking for overflow errors where applicable.</p> <p>The overflow protection may impose a perceptible performance penalty.</p> </dd>
</dl> <dl class="function"> <dt id="Base.Base.checked_div">
<code>Base.checked_div(x, y)</code> </dt> <dd>
<p>Calculates <code>div(x,y)</code>, checking for overflow errors where applicable.</p> <p>The overflow protection may impose a perceptible performance penalty.</p> </dd>
</dl> <dl class="function"> <dt id="Base.Base.checked_rem">
<code>Base.checked_rem(x, y)</code> </dt> <dd>
<p>Calculates <code>x%y</code>, checking for overflow errors where applicable.</p> <p>The overflow protection may impose a perceptible performance penalty.</p> </dd>
</dl> <dl class="function"> <dt id="Base.Base.checked_fld">
<code>Base.checked_fld(x, y)</code> </dt> <dd>
<p>Calculates <code>fld(x,y)</code>, checking for overflow errors where applicable.</p> <p>The overflow protection may impose a perceptible performance penalty.</p> </dd>
</dl> <dl class="function"> <dt id="Base.Base.checked_mod">
<code>Base.checked_mod(x, y)</code> </dt> <dd>
<p>Calculates <code>mod(x,y)</code>, checking for overflow errors where applicable.</p> <p>The overflow protection may impose a perceptible performance penalty.</p> </dd>
</dl> <dl class="function"> <dt id="Base.Base.checked_cld">
<code>Base.checked_cld(x, y)</code> </dt> <dd>
<p>Calculates <code>cld(x,y)</code>, checking for overflow errors where applicable.</p> <p>The overflow protection may impose a perceptible performance penalty.</p> </dd>
</dl> <dl class="function"> <dt id="Base.abs2">
<code>abs2(x)</code> </dt> <dd>
<p>Squared absolute value of <code>x</code>.</p> </dd>
</dl> <dl class="function"> <dt id="Base.copysign">
<code>copysign(x, y)</code> </dt> <dd>
<p>Return <code>x</code> such that it has the same sign as <code>y</code></p> </dd>
</dl> <dl class="function"> <dt id="Base.sign">
<code>sign(x)</code> </dt> <dd>
<p>Return zero if <code>x==0</code> and <span class="math">\(x/|x|\)</span> otherwise (i.e., ±1 for real <code>x</code>).</p> </dd>
</dl> <dl class="function"> <dt id="Base.signbit">
<code>signbit(x)</code> </dt> <dd>
<p>Returns <code>true</code> if the value of the sign of <code>x</code> is negative, otherwise <code>false</code>.</p> </dd>
</dl> <dl class="function"> <dt id="Base.flipsign">
<code>flipsign(x, y)</code> </dt> <dd>
<p>Return <code>x</code> with its sign flipped if <code>y</code> is negative. For example <code>abs(x) = flipsign(x,x)</code>.</p> </dd>
</dl> <dl class="function"> <dt id="Base.sqrt">
<code>sqrt(x)</code> </dt> <dd>
<p>Return <span class="math">\(\sqrt{x}\)</span>. Throws <code>DomainError</code> for negative <code>Real</code> arguments. Use complex negative arguments instead. The prefix operator <code>√</code> is equivalent to <code>sqrt</code>.</p> </dd>
</dl> <dl class="function"> <dt id="Base.isqrt">
<code>isqrt(n)</code> </dt> <dd>
<p>Integer square root: the largest integer <code>m</code> such that <code>m*m &lt;= n</code>.</p> </dd>
</dl> <dl class="function"> <dt id="Base.cbrt">
<code>cbrt(x)</code> </dt> <dd>
<p>Return <span class="math">\(x^{1/3}\)</span>. The prefix operator <code>∛</code> is equivalent to <code>cbrt</code>.</p> </dd>
</dl> <dl class="function"> <dt id="Base.erf">
<code>erf(x)</code> </dt> <dd>
<p>Compute the error function of <code>x</code>, defined by <span class="math">\(\frac{2}{\sqrt{\pi}} \int_0^x e^{-t^2} dt\)</span> for arbitrary complex <code>x</code>.</p> </dd>
</dl> <dl class="function"> <dt id="Base.erfc">
<code>erfc(x)</code> </dt> <dd>
<p>Compute the complementary error function of <code>x</code>, defined by <span class="math">\(1 - \operatorname{erf}(x)\)</span>.</p> </dd>
</dl> <dl class="function"> <dt id="Base.erfcx">
<code>erfcx(x)</code> </dt> <dd>
<p>Compute the scaled complementary error function of <code>x</code>, defined by <span class="math">\(e^{x^2} \operatorname{erfc}(x)\)</span>. Note also that <span class="math">\(\operatorname{erfcx}(-ix)\)</span> computes the Faddeeva function <span class="math">\(w(x)\)</span>.</p> </dd>
</dl> <dl class="function"> <dt id="Base.erfi">
<code>erfi(x)</code> </dt> <dd>
<p>Compute the imaginary error function of <code>x</code>, defined by <span class="math">\(-i \operatorname{erf}(ix)\)</span>.</p> </dd>
</dl> <dl class="function"> <dt id="Base.dawson">
<code>dawson(x)</code> </dt> <dd>
<p>Compute the Dawson function (scaled imaginary error function) of <code>x</code>, defined by <span class="math">\(\frac{\sqrt{\pi}}{2} e^{-x^2} \operatorname{erfi}(x)\)</span>.</p> </dd>
</dl> <dl class="function"> <dt id="Base.erfinv">
<code>erfinv(x)</code> </dt> <dd>
<p>Compute the inverse error function of a real <code>x</code>, defined by <span class="math">\(\operatorname{erf}(\operatorname{erfinv}(x)) = x\)</span>.</p> </dd>
</dl> <dl class="function"> <dt id="Base.erfcinv">
<code>erfcinv(x)</code> </dt> <dd>
<p>Compute the inverse error complementary function of a real <code>x</code>, defined by <span class="math">\(\operatorname{erfc}(\operatorname{erfcinv}(x)) = x\)</span>.</p> </dd>
</dl> <dl class="function"> <dt id="Base.real">
<code>real(z)</code> </dt> <dd>
<p>Return the real part of the complex number <code>z</code>.</p> </dd>
</dl> <dl class="function"> <dt id="Base.imag">
<code>imag(z)</code> </dt> <dd>
<p>Return the imaginary part of the complex number <code>z</code>.</p> </dd>
</dl> <dl class="function"> <dt id="Base.reim">
<code>reim(z)</code> </dt> <dd>
<p>Return both the real and imaginary parts of the complex number <code>z</code>.</p> </dd>
</dl> <dl class="function"> <dt id="Base.conj">
<code>conj(z)</code> </dt> <dd>
<p>Compute the complex conjugate of a complex number <code>z</code>.</p> </dd>
</dl> <dl class="function"> <dt id="Base.angle">
<code>angle(z)</code> </dt> <dd>
<p>Compute the phase angle in radians of a complex number <code>z</code>.</p> </dd>
</dl> <dl class="function"> <dt id="Base.cis">
<code>cis(z)</code> </dt> <dd>
<p>Return <span class="math">\(\exp(iz)\)</span>.</p> </dd>
</dl> <dl class="function"> <dt id="Base.binomial">
<code>binomial(n, k)</code> </dt> <dd>
<p>Number of ways to choose <code>k</code> out of <code>n</code> items.</p> </dd>
</dl> <dl class="function"> <dt id="Base.factorial">
<code>factorial(n)</code> </dt> <dd>
<p>Factorial of <code>n</code>. If <code>n</code> is an <code>Integer</code>, the factorial is computed as an integer (promoted to at least 64 bits). Note that this may overflow if <code>n</code> is not small, but you can use <code>factorial(big(n))</code> to compute the result exactly in arbitrary precision. If <code>n</code> is not an <code>Integer</code>, <code>factorial(n)</code> is equivalent to <a class="reference internal" href="#Base.gamma" title="Base.gamma"><code>gamma(n+1)</code></a>.</p> </dd>
</dl> <dl class="function"> <dt id="Base.gcd">
<code>gcd(x, y)</code> </dt> <dd>
<p>Greatest common (positive) divisor (or zero if <code>x</code> and <code>y</code> are both zero).</p> </dd>
</dl> <dl class="function"> <dt id="Base.lcm">
<code>lcm(x, y)</code> </dt> <dd>
<p>Least common (non-negative) multiple.</p> </dd>
</dl> <dl class="function"> <dt id="Base.gcdx">
<code>gcdx(x, y)</code> </dt> <dd>
<p>Computes the greatest common (positive) divisor of <code>x</code> and <code>y</code> and their Bézout coefficients, i.e. the integer coefficients <code>u</code> and <code>v</code> that satisfy <span class="math">\(ux+vy = d = gcd(x,y)\)</span>. <span class="math">\(gcdx(x,y)\)</span> returns <span class="math">\((d,u,v)\)</span>.</p> <pre data-language="julia">julia&gt; gcdx(12, 42)
(6,-3,1)
</pre> <pre data-language="julia">julia&gt; gcdx(240, 46)
(2,-9,47)
</pre> <div class="admonition note"> <p class="first admonition-title">Note</p> <p class="last">Bézout coefficients are <em>not</em> uniquely defined. <code>gcdx</code> returns the minimal Bézout coefficients that are computed by the extended Euclidean algorithm. (Ref: D. Knuth, TAoCP, 2/e, p. 325, Algorithm X.) For signed integers, these coefficients <code>u</code> and <code>v</code> are minimal in the sense that <span class="math">\(|u| &lt; |y/d|\)</span> and <span class="math">\(|v| &lt; |x/d|\)</span>. Furthermore, the signs of <code>u</code> and <code>v</code> are chosen so that <code>d</code> is positive. For unsigned integers, the coefficients <code>u</code> and <code>v</code> might be near their <code>typemax</code>, and the identity then holds only via the unsigned integers’ modulo arithmetic.</p> </div> </dd>
</dl> <dl class="function"> <dt id="Base.ispow2">
<code>ispow2(n) → Bool</code> </dt> <dd>
<p>Test whether <code>n</code> is a power of two.</p> </dd>
</dl> <dl class="function"> <dt id="Base.nextpow2">
<code>nextpow2(n)</code> </dt> <dd>
<p>The smallest power of two not less than <code>n</code>. Returns 0 for <code>n==0</code>, and returns <code>-nextpow2(-n)</code> for negative arguments.</p> </dd>
</dl> <dl class="function"> <dt id="Base.prevpow2">
<code>prevpow2(n)</code> </dt> <dd>
<p>The largest power of two not greater than <code>n</code>. Returns 0 for <code>n==0</code>, and returns <code>-prevpow2(-n)</code> for negative arguments.</p> </dd>
</dl> <dl class="function"> <dt id="Base.nextpow">
<code>nextpow(a, x)</code> </dt> <dd>
<p>The smallest <code>a^n</code> not less than <code>x</code>, where <code>n</code> is a non-negative integer. <code>a</code> must be greater than 1, and <code>x</code> must be greater than 0.</p> </dd>
</dl> <dl class="function"> <dt id="Base.prevpow">
<code>prevpow(a, x)</code> </dt> <dd>
<p>The largest <code>a^n</code> not greater than <code>x</code>, where <code>n</code> is a non-negative integer. <code>a</code> must be greater than 1, and <code>x</code> must not be less than 1.</p> </dd>
</dl> <dl class="function"> <dt id="Base.nextprod">
<code>nextprod([k_1, k_2, ..., ]n)</code> </dt> <dd>
<p>Next integer not less than <code>n</code> that can be written as <span class="math">\(\prod k_i^{p_i}\)</span> for integers <span class="math">\(p_1\)</span>, <span class="math">\(p_2\)</span>, etc.</p> </dd>
</dl> <dl class="function"> <dt id="Base.invmod">
<code>invmod(x, m)</code> </dt> <dd>
<p>Take the inverse of <code>x</code> modulo <code>m</code>: <code>y</code> such that <span class="math">\(x y = 1 \pmod m\)</span>, with <span class="math">\(div(x,y) = 0\)</span>. This is undefined for <span class="math">\(m = 0\)</span>, or if <span class="math">\(gcd(x,m) \neq 1\)</span>.</p> </dd>
</dl> <dl class="function"> <dt id="Base.powermod">
<code>powermod(x, p, m)</code> </dt> <dd>
<p>Compute <span class="math">\(x^p \pmod m\)</span>.</p> </dd>
</dl> <dl class="function"> <dt id="Base.gamma">
<code>gamma(x)</code> </dt> <dd>
<p>Compute the gamma function of <code>x</code>.</p> </dd>
</dl> <dl class="function"> <dt id="Base.lgamma">
<code>lgamma(x)</code> </dt> <dd>
<p>Compute the logarithm of the absolute value of <a class="reference internal" href="#Base.gamma" title="Base.gamma"><code>gamma()</code></a> for <code>Real</code> <code>x</code>, while for <code>Complex</code> <code>x</code> it computes the logarithm of <code>gamma(x)</code>.</p> </dd>
</dl> <dl class="function"> <dt id="Base.lfact">
<code>lfact(x)</code> </dt> <dd>
<p>Compute the logarithmic factorial of <code>x</code></p> </dd>
</dl> <dl class="function"> <dt id="Base.digamma">
<code>digamma(x)</code> </dt> <dd>
<p>Compute the digamma function of <code>x</code> (the logarithmic derivative of <code>gamma(x)</code>)</p> </dd>
</dl> <dl class="function"> <dt id="Base.invdigamma">
<code>invdigamma(x)</code> </dt> <dd>
<p>Compute the inverse digamma function of <code>x</code>.</p> </dd>
</dl> <dl class="function"> <dt id="Base.trigamma">
<code>trigamma(x)</code> </dt> <dd>
<p>Compute the trigamma function of <code>x</code> (the logarithmic second derivative of <code>gamma(x)</code>).</p> </dd>
</dl> <dl class="function"> <dt id="Base.polygamma">
<code>polygamma(m, x)</code> </dt> <dd>
<p>Compute the polygamma function of order <code>m</code> of argument <code>x</code> (the <code>(m+1)th</code> derivative of the logarithm of <code>gamma(x)</code>)</p> </dd>
</dl> <dl class="function"> <dt id="Base.airy">
<code>airy(k, x)</code> </dt> <dd>
<p>The <code>k</code>th derivative of the Airy function <span class="math">\(\operatorname{Ai}(x)\)</span>.</p> </dd>
</dl> <dl class="function"> <dt id="Base.airyai">
<code>airyai(x)</code> </dt> <dd>
<p>Airy function <span class="math">\(\operatorname{Ai}(x)\)</span>.</p> </dd>
</dl> <dl class="function"> <dt id="Base.airyprime">
<code>airyprime(x)</code> </dt> <dd>
<p>Airy function derivative <span class="math">\(\operatorname{Ai}'(x)\)</span>.</p> </dd>
</dl> <dl class="function"> <dt id="Base.airyaiprime">
<code>airyaiprime(x)</code> </dt> <dd>
<p>Airy function derivative <span class="math">\(\operatorname{Ai}'(x)\)</span>.</p> </dd>
</dl> <dl class="function"> <dt id="Base.airybi">
<code>airybi(x)</code> </dt> <dd>
<p>Airy function <span class="math">\(\operatorname{Bi}(x)\)</span>.</p> </dd>
</dl> <dl class="function"> <dt id="Base.airybiprime">
<code>airybiprime(x)</code> </dt> <dd>
<p>Airy function derivative <span class="math">\(\operatorname{Bi}'(x)\)</span>.</p> </dd>
</dl> <dl class="function"> <dt id="Base.airyx">
<code>airyx(k, x)</code> </dt> <dd>
<p>scaled <code>k</code>th derivative of the Airy function, return <span class="math">\(\operatorname{Ai}(x) e^{\frac{2}{3} x \sqrt{x}}\)</span> for <code>k == 0 || k == 1</code>, and <span class="math">\(\operatorname{Ai}(x) e^{- \left| \operatorname{Re} \left( \frac{2}{3} x \sqrt{x} \right) \right|}\)</span> for <code>k == 2 || k == 3</code>.</p> </dd>
</dl> <dl class="function"> <dt id="Base.besselj0">
<code>besselj0(x)</code> </dt> <dd>
<p>Bessel function of the first kind of order 0, <span class="math">\(J_0(x)\)</span>.</p> </dd>
</dl> <dl class="function"> <dt id="Base.besselj1">
<code>besselj1(x)</code> </dt> <dd>
<p>Bessel function of the first kind of order 1, <span class="math">\(J_1(x)\)</span>.</p> </dd>
</dl> <dl class="function"> <dt id="Base.besselj">
<code>besselj(nu, x)</code> </dt> <dd>
<p>Bessel function of the first kind of order <code>nu</code>, <span class="math">\(J_\nu(x)\)</span>.</p> </dd>
</dl> <dl class="function"> <dt id="Base.besseljx">
<code>besseljx(nu, x)</code> </dt> <dd>
<p>Scaled Bessel function of the first kind of order <code>nu</code>, <span class="math">\(J_\nu(x) e^{- | \operatorname{Im}(x) |}\)</span>.</p> </dd>
</dl> <dl class="function"> <dt id="Base.bessely0">
<code>bessely0(x)</code> </dt> <dd>
<p>Bessel function of the second kind of order 0, <span class="math">\(Y_0(x)\)</span>.</p> </dd>
</dl> <dl class="function"> <dt id="Base.bessely1">
<code>bessely1(x)</code> </dt> <dd>
<p>Bessel function of the second kind of order 1, <span class="math">\(Y_1(x)\)</span>.</p> </dd>
</dl> <dl class="function"> <dt id="Base.bessely">
<code>bessely(nu, x)</code> </dt> <dd>
<p>Bessel function of the second kind of order <code>nu</code>, <span class="math">\(Y_\nu(x)\)</span>.</p> </dd>
</dl> <dl class="function"> <dt id="Base.besselyx">
<code>besselyx(nu, x)</code> </dt> <dd>
<p>Scaled Bessel function of the second kind of order <code>nu</code>, <span class="math">\(Y_\nu(x) e^{- | \operatorname{Im}(x) |}\)</span>.</p> </dd>
</dl> <dl class="function"> <dt id="Base.hankelh1">
<code>hankelh1(nu, x)</code> </dt> <dd>
<p>Bessel function of the third kind of order <code>nu</code>, <span class="math">\(H^{(1)}_\nu(x)\)</span>.</p> </dd>
</dl> <dl class="function"> <dt id="Base.hankelh1x">
<code>hankelh1x(nu, x)</code> </dt> <dd>
<p>Scaled Bessel function of the third kind of order <code>nu</code>, <span class="math">\(H^{(1)}_\nu(x) e^{-x i}\)</span>.</p> </dd>
</dl> <dl class="function"> <dt id="Base.hankelh2">
<code>hankelh2(nu, x)</code> </dt> <dd>
<p>Bessel function of the third kind of order <code>nu</code>, <span class="math">\(H^{(2)}_\nu(x)\)</span>.</p> </dd>
</dl> <dl class="function"> <dt id="Base.hankelh2x">
<code>hankelh2x(nu, x)</code> </dt> <dd>
<p>Scaled Bessel function of the third kind of order <code>nu</code>, <span class="math">\(H^{(2)}_\nu(x) e^{x i}\)</span>.</p> </dd>
</dl> <dl class="function"> <dt id="Base.besselh">
<code>besselh(nu, [k=1, ]x)</code> </dt> <dd>
<p>Bessel function of the third kind of order <code>nu</code> (the Hankel function). <code>k</code> is either 1 or 2, selecting <a class="reference internal" href="#Base.hankelh1" title="Base.hankelh1"><code>hankelh1()</code></a> or <a class="reference internal" href="#Base.hankelh2" title="Base.hankelh2"><code>hankelh2()</code></a>, respectively. <code>k</code> defaults to 1 if it is omitted. (See also <a class="reference internal" href="#Base.besselhx" title="Base.besselhx"><code>besselhx()</code></a> for an exponentially scaled variant.)</p> </dd>
</dl> <dl class="function"> <dt id="Base.besselhx">
<code>besselhx(nu, [k=1, ]z)</code> </dt> <dd>
<p>Compute the scaled Hankel function <span class="math">\(\exp(∓iz) H_ν^{(k)}(z)\)</span>, where <span class="math">\(k\)</span> is 1 or 2, <span class="math">\(H_ν^{(k)}(z)\)</span> is <code>besselh(nu, k, z)</code>, and <span class="math">\(∓\)</span> is <span class="math">\(-\)</span> for <span class="math">\(k=1\)</span> and <span class="math">\(+\)</span> for <span class="math">\(k=2\)</span>. <code>k</code> defaults to 1 if it is omitted.</p> <p>The reason for this function is that <span class="math">\(H_ν^{(k)}(z)\)</span> is asymptotically proportional to <span class="math">\(\exp(∓iz)/\sqrt{z}\)</span> for large <span class="math">\(|z|\)</span>, and so the <a class="reference internal" href="#Base.besselh" title="Base.besselh"><code>besselh()</code></a> function is susceptible to overflow or underflow when <code>z</code> has a large imaginary part. The <code>besselhx</code> function cancels this exponential factor (analytically), so it avoids these problems.</p> </dd>
</dl> <dl class="function"> <dt id="Base.besseli">
<code>besseli(nu, x)</code> </dt> <dd>
<p>Modified Bessel function of the first kind of order <code>nu</code>, <span class="math">\(I_\nu(x)\)</span>.</p> </dd>
</dl> <dl class="function"> <dt id="Base.besselix">
<code>besselix(nu, x)</code> </dt> <dd>
<p>Scaled modified Bessel function of the first kind of order <code>nu</code>, <span class="math">\(I_\nu(x) e^{- | \operatorname{Re}(x) |}\)</span>.</p> </dd>
</dl> <dl class="function"> <dt id="Base.besselk">
<code>besselk(nu, x)</code> </dt> <dd>
<p>Modified Bessel function of the second kind of order <code>nu</code>, <span class="math">\(K_\nu(x)\)</span>.</p> </dd>
</dl> <dl class="function"> <dt id="Base.besselkx">
<code>besselkx(nu, x)</code> </dt> <dd>
<p>Scaled modified Bessel function of the second kind of order <code>nu</code>, <span class="math">\(K_\nu(x) e^x\)</span>.</p> </dd>
</dl> <dl class="function"> <dt id="Base.beta">
<code>beta(x, y)</code> </dt> <dd>
<p>Euler integral of the first kind <span class="math">\(\operatorname{B}(x,y) = \Gamma(x)\Gamma(y)/\Gamma(x+y)\)</span>.</p> </dd>
</dl> <dl class="function"> <dt id="Base.lbeta">
<code>lbeta(x, y)</code> </dt> <dd>
<p>Natural logarithm of the absolute value of the beta function <span class="math">\(\log(|\operatorname{B}(x,y)|)\)</span>.</p> </dd>
</dl> <dl class="function"> <dt id="Base.eta">
<code>eta(x)</code> </dt> <dd>
<p>Dirichlet eta function <span class="math">\(\eta(s) = \sum^\infty_{n=1}(-1)^{n-1}/n^{s}\)</span>.</p> </dd>
</dl> <dl class="function"> <dt id="Base.zeta">
<code>zeta(s)</code> </dt> <dd>
<p>Riemann zeta function <span class="math">\(\zeta(s)\)</span>.</p> </dd>
</dl> <dl class="function"> <dt>
<code>zeta(s, z)</code> </dt> <dd>
<p>Generalized zeta function <span class="math">\(\zeta(s, z)\)</span>, defined by the sum <span class="math">\(\sum_{k=0}^\infty ((k+z)^2)^{-s/2}\)</span>, where any term with <span class="math">\(k+z=0\)</span> is excluded. For <span class="math">\(\Re z &gt; 0\)</span>, this definition is equivalent to the Hurwitz zeta function <span class="math">\(\sum_{k=0}^\infty (k+z)^{-s}\)</span>. For <span class="math">\(z=1\)</span>, it yields the Riemann zeta function <span class="math">\(\zeta(s)\)</span>.</p> </dd>
</dl> <dl class="function"> <dt id="Base.ndigits">
<code>ndigits(n, b = 10)</code> </dt> <dd>
<p>Compute the number of digits in number <code>n</code> written in base <code>b</code>.</p> </dd>
</dl> <dl class="function"> <dt id="Base.widemul">
<code>widemul(x, y)</code> </dt> <dd>
<p>Multiply <code>x</code> and <code>y</code>, giving the result as a larger type.</p> </dd>
</dl> <dl class="function"> <dt id="Base.@evalpoly">
<code>@evalpoly(z, c...)</code> </dt> <dd>
<p>Evaluate the polynomial <span class="math">\(\sum_k c[k] z^{k-1}\)</span> for the coefficients <code>c[1]</code>, <code>c[2]</code>, ...; that is, the coefficients are given in ascending order by power of <code>z</code>. This macro expands to efficient inline code that uses either Horner’s method or, for complex <code>z</code>, a more efficient Goertzel-like algorithm.</p> </dd>
</dl>   <h2 id="statistics">Statistics</h2> <dl class="function"> <dt id="Base.mean">
<code>mean(v[, region])</code> </dt> <dd>
<p>Compute the mean of whole array <code>v</code>, or optionally along the dimensions in <code>region</code>.</p> <div class="admonition note"> <p class="first admonition-title">Note</p> <p class="last">Julia does not ignore <code>NaN</code> values in the computation. For applications requiring the handling of missing data, the <code>DataArrays.jl</code> package is recommended.</p> </div> </dd>
</dl> <dl class="function"> <dt>
<code>mean(f::Function, v)</code> </dt> <dd>
<p>Apply the function <code>f</code> to each element of <code>v</code> and take the mean.</p> </dd>
</dl> <dl class="function"> <dt id="Base.mean!">
<code>mean!(r, v)</code> </dt> <dd>
<p>Compute the mean of <code>v</code> over the singleton dimensions of <code>r</code>, and write results to <code>r</code>.</p> </dd>
</dl> <dl class="function"> <dt id="Base.std">
<code>std(v[, region]; corrected::Bool=true, mean=nothing)</code> </dt> <dd>
<p>Compute the sample standard deviation of a vector or array <code>v</code>, optionally along dimensions in <code>region</code>. The algorithm returns an estimator of the generative distribution’s standard deviation under the assumption that each entry of <code>v</code> is an IID drawn from that generative distribution. This computation is equivalent to calculating <code>sqrt(sum((v - mean(v)).^2) / (length(v) - 1))</code>. A pre-computed <code>mean</code> may be provided. If <code>corrected</code> is <code>true</code>, then the sum is scaled with <code>n-1</code>, whereas the sum is scaled with <code>n</code> if <code>corrected</code> is <code>false</code> where <code>n = length(x)</code>.</p> <div class="admonition note"> <p class="first admonition-title">Note</p> <p class="last">Julia does not ignore <code>NaN</code> values in the computation. For applications requiring the handling of missing data, the <code>DataArrays.jl</code> package is recommended.</p> </div> </dd>
</dl> <dl class="function"> <dt id="Base.stdm">
<code>stdm(v, m::Number; corrected::Bool=true)</code> </dt> <dd>
<p>Compute the sample standard deviation of a vector <code>v</code> with known mean <code>m</code>. If <code>corrected</code> is <code>true</code>, then the sum is scaled with <code>n-1</code>, whereas the sum is scaled with <code>n</code> if <code>corrected</code> is <code>false</code> where <code>n = length(x)</code>.</p> <div class="admonition note"> <p class="first admonition-title">Note</p> <p class="last">Julia does not ignore <code>NaN</code> values in the computation. For applications requiring the handling of missing data, the <code>DataArrays.jl</code> package is recommended.</p> </div> </dd>
</dl> <dl class="function"> <dt id="Base.var">
<code>var(v[, region])</code> </dt> <dd>
<p>Compute the sample variance of a vector or array <code>v</code>, optionally along dimensions in <code>region</code>. The algorithm will return an estimator of the generative distribution’s variance under the assumption that each entry of <code>v</code> is an IID drawn from that generative distribution. This computation is equivalent to calculating <code>sumabs2(v - mean(v)) / (length(v) - 1)</code>. Note: Julia does not ignore <code>NaN</code> values in the computation. For applications requiring the handling of missing data, the <code>DataArray</code> package is recommended.</p> </dd>
</dl> <dl class="function"> <dt id="Base.varm">
<code>varm(v, m[, region]; corrected::Bool=true)</code> </dt> <dd>
<p>Compute the sample variance of a collection <code>v</code> with known mean(s) <code>m</code>, optionally over <code>region</code>. <code>m</code> may contain means for each dimension of <code>v</code>. If <code>corrected</code> is <code>true</code>, then the sum is scaled with <code>n-1</code>, whereas the sum is scaled with <code>n</code> if <code>corrected</code> is <code>false</code> where <code>n = length(x)</code>.</p> <div class="admonition note"> <p class="first admonition-title">Note</p> <p class="last">Julia does not ignore <code>NaN</code> values in the computation. For applications requiring the handling of missing data, the <code>DataArrays.jl</code> package is recommended.</p> </div> </dd>
</dl> <dl class="function"> <dt id="Base.middle">
<code>middle(x)</code> </dt> <dd>
<p>Compute the middle of a scalar value, which is equivalent to <code>x</code> itself, but of the type of <code>middle(x, x)</code> for consistency.</p> </dd>
</dl> <dl class="function"> <dt>
<code>middle(x, y)</code> </dt> <dd>
<p>Compute the middle of two reals <code>x</code> and <code>y</code>, which is equivalent in both value and type to computing their mean (<code>(x + y) / 2</code>).</p> </dd>
</dl> <dl class="function"> <dt>
<code>middle(range)</code> </dt> <dd>
<p>Compute the middle of a range, which consists of computing the mean of its extrema. Since a range is sorted, the mean is performed with the first and last element.</p> <pre data-language="julia">julia&gt; middle(1:10)
5.5
</pre> </dd>
</dl> <dl class="function"> <dt>
<code>middle(a)</code> </dt> <dd>
<p>Compute the middle of an array <code>a</code>, which consists of finding its extrema and then computing their mean.</p> <pre data-language="julia">julia&gt; a = [1,2,3.6,10.9]
4-element Array{Float64,1}:
  1.0
  2.0
  3.6
 10.9

julia&gt; middle(a)
5.95
</pre> </dd>
</dl> <dl class="function"> <dt id="Base.median">
<code>median(v[, region])</code> </dt> <dd>
<p>Compute the median of an entire array <code>v</code>, or, optionally, along the dimensions in <code>region</code>. For an even number of elements no exact median element exists, so the result is equivalent to calculating mean of two median elements.</p> <div class="admonition note"> <p class="first admonition-title">Note</p> <p class="last">Julia does not ignore <code>NaN</code> values in the computation. For applications requiring the handling of missing data, the <code>DataArrays.jl</code> package is recommended.</p> </div> </dd>
</dl> <dl class="function"> <dt id="Base.median!">
<code>median!(v)</code> </dt> <dd>
<p>Like <code>median</code>, but may overwrite the input vector.</p> </dd>
</dl> <dl class="function"> <dt id="Base.midpoints">
<code>midpoints(e)</code> </dt> <dd>
<p>Compute the midpoints of the bins with edges <code>e</code>. The result is a vector/range of length <code>length(e) - 1</code>. Note: Julia does not ignore <code>NaN</code> values in the computation.</p> </dd>
</dl> <dl class="function"> <dt id="Base.quantile">
<code>quantile(v, p; sorted=false)</code> </dt> <dd>
<p>Compute the quantile(s) of a vector <code>v</code> at a specified probability or vector <code>p</code>. The keyword argument <code>sorted</code> indicates whether <code>v</code> can be assumed to be sorted.</p> <p>The <code>p</code> should be on the interval [0,1], and <code>v</code> should not have any <code>NaN</code> values.</p> <p>Quantiles are computed via linear interpolation between the points <code>((k-1)/(n-1), v[k])</code>, for <code>k = 1:n</code> where <code>n = length(v)</code>. This corresponds to Definition 7 of Hyndman and Fan (1996), and is the same as the R default.</p> <div class="admonition note"> <p class="first admonition-title">Note</p> <p class="last">Julia does not ignore <code>NaN</code> values in the computation. For applications requiring the handling of missing data, the <code>DataArrays.jl</code> package is recommended. <code>quantile</code> will throw an <code>ArgumentError</code> in the presence of <code>NaN</code> values in the data array.</p> </div> <ul class="simple"> <li>Hyndman, R.J and Fan, Y. (1996) “Sample Quantiles in Statistical Packages”, <em>The American Statistician</em>, Vol. 50, No. 4, pp. 361-365</li> </ul> </dd>
</dl> <dl class="function"> <dt id="Base.quantile!">
<code>quantile!([q, ]v, p; sorted=false)</code> </dt> <dd>
<p>Compute the quantile(s) of a vector <code>v</code> at the probabilities <code>p</code>, with optional output into array <code>q</code> (if not provided, a new output array is created). The keyword argument <code>sorted</code> indicates whether <code>v</code> can be assumed to be sorted; if <code>false</code> (the default), then the elements of <code>v</code> may be partially sorted.</p> <p>The elements of <code>p</code> should be on the interval [0,1], and <code>v</code> should not have any <code>NaN</code> values.</p> <p>Quantiles are computed via linear interpolation between the points <code>((k-1)/(n-1), v[k])</code>, for <code>k = 1:n</code> where <code>n = length(v)</code>. This corresponds to Definition 7 of Hyndman and Fan (1996), and is the same as the R default.</p> <div class="admonition note"> <p class="first admonition-title">Note</p> <p class="last">Julia does not ignore <code>NaN</code> values in the computation. For applications requiring the handling of missing data, the <code>DataArrays.jl</code> package is recommended. <code>quantile!</code> will throw an <code>ArgumentError</code> in the presence of <code>NaN</code> values in the data array.</p> </div> <ul class="simple"> <li>Hyndman, R.J and Fan, Y. (1996) “Sample Quantiles in Statistical Packages”, <em>The American Statistician</em>, Vol. 50, No. 4, pp. 361-365</li> </ul> </dd>
</dl> <dl class="function"> <dt id="Base.cov">
<code>cov(x[, corrected=true])</code> </dt> <dd>
<p>Compute the variance of the vector <code>x</code>. If <code>corrected</code> is <code>true</code> (the default) then the sum is scaled with <code>n-1</code>, whereas the sum is scaled with <code>n</code> if <code>corrected</code> is <code>false</code> where <code>n = length(x)</code>.</p> </dd>
</dl> <dl class="function"> <dt>
<code>cov(X[, vardim=1, corrected=true])</code> </dt> <dd>
<p>Compute the covariance matrix of the matrix <code>X</code> along the dimension <code>vardim</code>. If <code>corrected</code> is <code>true</code> (the default) then the sum is scaled with <code>n-1</code>, whereas the sum is scaled with <code>n</code> if <code>corrected</code> is <code>false</code> where <code>n = size(X, vardim)</code>.</p> </dd>
</dl> <dl class="function"> <dt>
<code>cov(x, y[, corrected=true])</code> </dt> <dd>
<p>Compute the covariance between the vectors <code>x</code> and <code>y</code>. If <code>corrected</code> is <code>true</code> (the default) then the sum is scaled with <code>n-1</code>, whereas the sum is scaled with <code>n</code> if <code>corrected</code> is <code>false</code> where <code>n = length(x) = length(y)</code>.</p> </dd>
</dl> <dl class="function"> <dt>
<code>cov(X, Y[, vardim=1, corrected=true])</code> </dt> <dd>
<p>Compute the covariance between the vectors or matrices <code>X</code> and <code>Y</code> along the dimension <code>vardim</code>. If <code>corrected</code> is <code>true</code> (the default) then the sum is scaled with <code>n-1</code>, whereas the sum is scaled with <code>n</code> if <code>corrected</code> is <code>false</code> where <code>n = size(X, vardim) = size(Y, vardim)</code>.</p> </dd>
</dl> <dl class="function"> <dt id="Base.cor">
<code>cor(x)</code> </dt> <dd>
<p>Return the number one.</p> </dd>
</dl> <dl class="function"> <dt>
<code>cor(X[, vardim=1])</code> </dt> <dd>
<p>Compute the Pearson correlation matrix of the matrix <code>X</code> along the dimension <code>vardim</code>.</p> </dd>
</dl> <dl class="function"> <dt>
<code>cor(x, y)</code> </dt> <dd>
<p>Compute the Pearson correlation between the vectors <code>x</code> and <code>y</code>.</p> </dd>
</dl> <dl class="function"> <dt>
<code>cor(X, Y[, vardim=1])</code> </dt> <dd>
<p>Compute the Pearson correlation between the vectors or matrices <code>X</code> and <code>Y</code> along the dimension <code>vardim</code>.</p> </dd>
</dl>   <h2 id="signal-processing">Signal Processing</h2> <p>Fast Fourier transform (FFT) functions in Julia are implemented by calling functions from <a class="reference external" href="http://www.fftw.org" target="_blank">FFTW</a>.</p> <dl class="function"> <dt id="Base.fft">
<code>fft(A[, dims])</code> </dt> <dd>
<p>Performs a multidimensional FFT of the array <code>A</code>. The optional <code>dims</code> argument specifies an iterable subset of dimensions (e.g. an integer, range, tuple, or array) to transform along. Most efficient if the size of <code>A</code> along the transformed dimensions is a product of small primes; see <code>nextprod()</code>. See also <code>plan_fft()</code> for even greater efficiency.</p> <p>A one-dimensional FFT computes the one-dimensional discrete Fourier transform (DFT) as defined by</p> <div class="math"> \[\operatorname{DFT}(A)[k] = \sum_{n=1}^{\operatorname{length}(A)} \exp\left(-i\frac{2\pi (n-1)(k-1)}{\operatorname{length}(A)} \right) A[n].\]</div> <p>A multidimensional FFT simply performs this operation along each transformed dimension of <code>A</code>.</p> <div class="admonition note"> <p class="first admonition-title">Note</p> <ul class="last simple"> <li>Julia starts FFTW up with 1 thread by default. Higher performance is usually possible by increasing number of threads. Use <code>FFTW.set_num_threads(Sys.CPU_CORES)</code> to use as many threads as cores on your system.</li> <li>This performs a multidimensional FFT by default. FFT libraries in other languages such as Python and Octave perform a one-dimensional FFT along the first non-singleton dimension of the array. This is worth noting while performing comparisons. For more details, refer to the <a class="reference internal" href="../../manual/noteworthy-differences/#man-noteworthy-differences"><span>Noteworthy Differences from other Languages</span></a> section of the manual.</li> </ul> </div> </dd>
</dl> <dl class="function"> <dt id="Base.fft!">
<code>fft!(A[, dims])</code> </dt> <dd>
<p>Same as <a class="reference internal" href="#Base.fft" title="Base.fft"><code>fft()</code></a>, but operates in-place on <code>A</code>, which must be an array of complex floating-point numbers.</p> </dd>
</dl> <dl class="function"> <dt id="Base.ifft">
<code>ifft(A[, dims])</code> </dt> <dd>
<p>Multidimensional inverse FFT.</p> <p>A one-dimensional inverse FFT computes</p> <div class="math"> \[\operatorname{IDFT}(A)[k] = \frac{1}{\operatorname{length}(A)} \sum_{n=1}^{\operatorname{length}(A)} \exp\left(+i\frac{2\pi (n-1)(k-1)} {\operatorname{length}(A)} \right) A[n].\]</div> <p>A multidimensional inverse FFT simply performs this operation along each transformed dimension of <code>A</code>.</p> </dd>
</dl> <dl class="function"> <dt id="Base.ifft!">
<code>ifft!(A[, dims])</code> </dt> <dd>
<p>Same as <a class="reference internal" href="#Base.ifft" title="Base.ifft"><code>ifft()</code></a>, but operates in-place on <code>A</code>.</p> </dd>
</dl> <dl class="function"> <dt id="Base.bfft">
<code>bfft(A[, dims])</code> </dt> <dd>
<p>Similar to <a class="reference internal" href="#Base.ifft" title="Base.ifft"><code>ifft()</code></a>, but computes an unnormalized inverse (backward) transform, which must be divided by the product of the sizes of the transformed dimensions in order to obtain the inverse. (This is slightly more efficient than <a class="reference internal" href="#Base.ifft" title="Base.ifft"><code>ifft()</code></a> because it omits a scaling step, which in some applications can be combined with other computational steps elsewhere.)</p> <div class="math"> \[\operatorname{BDFT}(A)[k] = \operatorname{length}(A) \operatorname{IDFT}(A)[k]\]</div> </dd>
</dl> <dl class="function"> <dt id="Base.bfft!">
<code>bfft!(A[, dims])</code> </dt> <dd>
<p>Same as <a class="reference internal" href="#Base.bfft" title="Base.bfft"><code>bfft()</code></a>, but operates in-place on <code>A</code>.</p> </dd>
</dl> <dl class="function"> <dt id="Base.plan_fft">
<code>plan_fft(A [, dims]; flags=FFTW.ESTIMATE; timelimit=Inf)</code> </dt> <dd>
<p>Pre-plan an optimized FFT along given dimensions (<code>dims</code>) of arrays matching the shape and type of <code>A</code>. (The first two arguments have the same meaning as for <a class="reference internal" href="#Base.fft" title="Base.fft"><code>fft()</code></a>.) Returns an object <code>P</code> which represents the linear operator computed by the FFT, and which contains all of the information needed to compute <code>fft(A, dims)</code> quickly.</p> <p>To apply <code>P</code> to an array <code>A</code>, use <code>P * A</code>; in general, the syntax for applying plans is much like that of matrices. (A plan can only be applied to arrays of the same size as the <code>A</code> for which the plan was created.) You can also apply a plan with a preallocated output array <code>Â</code> by calling <code>A_mul_B!(Â, plan, A)</code>. (For <code>A_mul_B!</code>, however, the input array <code>A</code> must be a complex floating-point array like the output <code>Â</code>.) You can compute the inverse-transform plan by <code>inv(P)</code> and apply the inverse plan with <code>P \ Â</code> (the inverse plan is cached and reused for subsequent calls to <code>inv</code> or <code>\</code>), and apply the inverse plan to a pre-allocated output array <code>A</code> with <code>A_ldiv_B!(A, P, Â)</code>.</p> <p>The <code>flags</code> argument is a bitwise-or of FFTW planner flags, defaulting to <code>FFTW.ESTIMATE</code>. e.g. passing <code>FFTW.MEASURE</code> or <code>FFTW.PATIENT</code> will instead spend several seconds (or more) benchmarking different possible FFT algorithms and picking the fastest one; see the FFTW manual for more information on planner flags. The optional <code>timelimit</code> argument specifies a rough upper bound on the allowed planning time, in seconds. Passing <code>FFTW.MEASURE</code> or <code>FFTW.PATIENT</code> may cause the input array <code>A</code> to be overwritten with zeros during plan creation.</p> <p><a class="reference internal" href="#Base.plan_fft!" title="Base.plan_fft!"><code>plan_fft!()</code></a> is the same as <a class="reference internal" href="#Base.plan_fft" title="Base.plan_fft"><code>plan_fft()</code></a> but creates a plan that operates in-place on its argument (which must be an array of complex floating-point numbers). <a class="reference internal" href="#Base.plan_ifft" title="Base.plan_ifft"><code>plan_ifft()</code></a> and so on are similar but produce plans that perform the equivalent of the inverse transforms <a class="reference internal" href="#Base.ifft" title="Base.ifft"><code>ifft()</code></a> and so on.</p> </dd>
</dl> <dl class="function"> <dt id="Base.plan_ifft">
<code>plan_ifft(A [, dims]; flags=FFTW.ESTIMATE; timelimit=Inf)</code> </dt> <dd>
<p>Same as <a class="reference internal" href="#Base.plan_fft" title="Base.plan_fft"><code>plan_fft()</code></a>, but produces a plan that performs inverse transforms <a class="reference internal" href="#Base.ifft" title="Base.ifft"><code>ifft()</code></a>.</p> </dd>
</dl> <dl class="function"> <dt id="Base.plan_bfft">
<code>plan_bfft(A [, dims]; flags=FFTW.ESTIMATE; timelimit=Inf)</code> </dt> <dd>
<p>Same as <a class="reference internal" href="#Base.plan_fft" title="Base.plan_fft"><code>plan_fft()</code></a>, but produces a plan that performs an unnormalized backwards transform <a class="reference internal" href="#Base.bfft" title="Base.bfft"><code>bfft()</code></a>.</p> </dd>
</dl> <dl class="function"> <dt id="Base.plan_fft!">
<code>plan_fft!(A [, dims]; flags=FFTW.ESTIMATE; timelimit=Inf)</code> </dt> <dd>
<p>Same as <a class="reference internal" href="#Base.plan_fft" title="Base.plan_fft"><code>plan_fft()</code></a>, but operates in-place on <code>A</code>.</p> </dd>
</dl> <dl class="function"> <dt id="Base.plan_ifft!">
<code>plan_ifft!(A [, dims]; flags=FFTW.ESTIMATE; timelimit=Inf)</code> </dt> <dd>
<p>Same as <a class="reference internal" href="#Base.plan_ifft" title="Base.plan_ifft"><code>plan_ifft()</code></a>, but operates in-place on <code>A</code>.</p> </dd>
</dl> <dl class="function"> <dt id="Base.plan_bfft!">
<code>plan_bfft!(A [, dims]; flags=FFTW.ESTIMATE; timelimit=Inf)</code> </dt> <dd>
<p>Same as <a class="reference internal" href="#Base.plan_bfft" title="Base.plan_bfft"><code>plan_bfft()</code></a>, but operates in-place on <code>A</code>.</p> </dd>
</dl> <dl class="function"> <dt id="Base.rfft">
<code>rfft(A[, dims])</code> </dt> <dd>
<p>Multidimensional FFT of a real array <code>A</code>, exploiting the fact that the transform has conjugate symmetry in order to save roughly half the computational time and storage costs compared with <a class="reference internal" href="#Base.fft" title="Base.fft"><code>fft()</code></a>. If <code>A</code> has size <code>(n_1, ..., n_d)</code>, the result has size <code>(div(n_1,2)+1, ..., n_d)</code>.</p> <p>The optional <code>dims</code> argument specifies an iterable subset of one or more dimensions of <code>A</code> to transform, similar to <a class="reference internal" href="#Base.fft" title="Base.fft"><code>fft()</code></a>. Instead of (roughly) halving the first dimension of <code>A</code> in the result, the <code>dims[1]</code> dimension is (roughly) halved in the same way.</p> </dd>
</dl> <dl class="function"> <dt id="Base.irfft">
<code>irfft(A, d[, dims])</code> </dt> <dd>
<p>Inverse of <a class="reference internal" href="#Base.rfft" title="Base.rfft"><code>rfft()</code></a>: for a complex array <code>A</code>, gives the corresponding real array whose FFT yields <code>A</code> in the first half. As for <a class="reference internal" href="#Base.rfft" title="Base.rfft"><code>rfft()</code></a>, <code>dims</code> is an optional subset of dimensions to transform, defaulting to <code>1:ndims(A)</code>.</p> <p><code>d</code> is the length of the transformed real array along the <code>dims[1]</code> dimension, which must satisfy <code>div(d,2)+1 == size(A,dims[1])</code>. (This parameter cannot be inferred from <code>size(A)</code> since both <code>2*size(A,dims[1])-2</code> as well as <code>2*size(A,dims[1])-1</code> are valid sizes for the transformed real array.)</p> </dd>
</dl> <dl class="function"> <dt id="Base.brfft">
<code>brfft(A, d[, dims])</code> </dt> <dd>
<p>Similar to <a class="reference internal" href="#Base.irfft" title="Base.irfft"><code>irfft()</code></a> but computes an unnormalized inverse transform (similar to <a class="reference internal" href="#Base.bfft" title="Base.bfft"><code>bfft()</code></a>), which must be divided by the product of the sizes of the transformed dimensions (of the real output array) in order to obtain the inverse transform.</p> </dd>
</dl> <dl class="function"> <dt id="Base.plan_rfft">
<code>plan_rfft(A [, dims]; flags=FFTW.ESTIMATE; timelimit=Inf)</code> </dt> <dd>
<p>Pre-plan an optimized real-input FFT, similar to <a class="reference internal" href="#Base.plan_fft" title="Base.plan_fft"><code>plan_fft()</code></a> except for <a class="reference internal" href="#Base.rfft" title="Base.rfft"><code>rfft()</code></a> instead of <a class="reference internal" href="#Base.fft" title="Base.fft"><code>fft()</code></a>. The first two arguments, and the size of the transformed result, are the same as for <a class="reference internal" href="#Base.rfft" title="Base.rfft"><code>rfft()</code></a>.</p> </dd>
</dl> <dl class="function"> <dt id="Base.plan_brfft">
<code>plan_brfft(A, d [, dims]; flags=FFTW.ESTIMATE; timelimit=Inf)</code> </dt> <dd>
<p>Pre-plan an optimized real-input unnormalized transform, similar to <a class="reference internal" href="#Base.plan_rfft" title="Base.plan_rfft"><code>plan_rfft()</code></a> except for <a class="reference internal" href="#Base.brfft" title="Base.brfft"><code>brfft()</code></a> instead of <a class="reference internal" href="#Base.rfft" title="Base.rfft"><code>rfft()</code></a>. The first two arguments and the size of the transformed result, are the same as for <a class="reference internal" href="#Base.brfft" title="Base.brfft"><code>brfft()</code></a>.</p> </dd>
</dl> <dl class="function"> <dt id="Base.plan_irfft">
<code>plan_irfft(A, d [, dims]; flags=FFTW.ESTIMATE; timelimit=Inf)</code> </dt> <dd>
<p>Pre-plan an optimized inverse real-input FFT, similar to <a class="reference internal" href="#Base.plan_rfft" title="Base.plan_rfft"><code>plan_rfft()</code></a> except for <a class="reference internal" href="#Base.irfft" title="Base.irfft"><code>irfft()</code></a> and <a class="reference internal" href="#Base.brfft" title="Base.brfft"><code>brfft()</code></a>, respectively. The first three arguments have the same meaning as for <a class="reference internal" href="#Base.irfft" title="Base.irfft"><code>irfft()</code></a>.</p> </dd>
</dl> <dl class="function"> <dt id="Base.dct">
<code>dct(A[, dims])</code> </dt> <dd>
<p>Performs a multidimensional type-II discrete cosine transform (DCT) of the array <code>A</code>, using the unitary normalization of the DCT. The optional <code>dims</code> argument specifies an iterable subset of dimensions (e.g. an integer, range, tuple, or array) to transform along. Most efficient if the size of <code>A</code> along the transformed dimensions is a product of small primes; see <a class="reference internal" href="#Base.nextprod" title="Base.nextprod"><code>nextprod()</code></a>. See also <a class="reference internal" href="#Base.plan_dct" title="Base.plan_dct"><code>plan_dct()</code></a> for even greater efficiency.</p> </dd>
</dl> <dl class="function"> <dt id="Base.dct!">
<code>dct!(A[, dims])</code> </dt> <dd>
<p>Same as <a class="reference internal" href="#Base.dct!" title="Base.dct!"><code>dct!()</code></a>, except that it operates in-place on <code>A</code>, which must be an array of real or complex floating-point values.</p> </dd>
</dl> <dl class="function"> <dt id="Base.idct">
<code>idct(A[, dims])</code> </dt> <dd>
<p>Computes the multidimensional inverse discrete cosine transform (DCT) of the array <code>A</code> (technically, a type-III DCT with the unitary normalization). The optional <code>dims</code> argument specifies an iterable subset of dimensions (e.g. an integer, range, tuple, or array) to transform along. Most efficient if the size of <code>A</code> along the transformed dimensions is a product of small primes; see <a class="reference internal" href="#Base.nextprod" title="Base.nextprod"><code>nextprod()</code></a>. See also <a class="reference internal" href="#Base.plan_idct" title="Base.plan_idct"><code>plan_idct()</code></a> for even greater efficiency.</p> </dd>
</dl> <dl class="function"> <dt id="Base.idct!">
<code>idct!(A[, dims])</code> </dt> <dd>
<p>Same as <a class="reference internal" href="#Base.idct!" title="Base.idct!"><code>idct!()</code></a>, but operates in-place on <code>A</code>.</p> </dd>
</dl> <dl class="function"> <dt id="Base.plan_dct">
<code>plan_dct(A[, dims[, flags[, timelimit]]])</code> </dt> <dd>
<p>Pre-plan an optimized discrete cosine transform (DCT), similar to <a class="reference internal" href="#Base.plan_fft" title="Base.plan_fft"><code>plan_fft()</code></a> except producing a function that computes <a class="reference internal" href="#Base.dct" title="Base.dct"><code>dct()</code></a>. The first two arguments have the same meaning as for <a class="reference internal" href="#Base.dct" title="Base.dct"><code>dct()</code></a>.</p> </dd>
</dl> <dl class="function"> <dt id="Base.plan_dct!">
<code>plan_dct!(A[, dims[, flags[, timelimit]]])</code> </dt> <dd>
<p>Same as <a class="reference internal" href="#Base.plan_dct" title="Base.plan_dct"><code>plan_dct()</code></a>, but operates in-place on <code>A</code>.</p> </dd>
</dl> <dl class="function"> <dt id="Base.plan_idct">
<code>plan_idct(A[, dims[, flags[, timelimit]]])</code> </dt> <dd>
<p>Pre-plan an optimized inverse discrete cosine transform (DCT), similar to <a class="reference internal" href="#Base.plan_fft" title="Base.plan_fft"><code>plan_fft()</code></a> except producing a function that computes <a class="reference internal" href="#Base.idct" title="Base.idct"><code>idct()</code></a>. The first two arguments have the same meaning as for <a class="reference internal" href="#Base.idct" title="Base.idct"><code>idct()</code></a>.</p> </dd>
</dl> <dl class="function"> <dt id="Base.plan_idct!">
<code>plan_idct!(A[, dims[, flags[, timelimit]]])</code> </dt> <dd>
<p>Same as <a class="reference internal" href="#Base.plan_idct" title="Base.plan_idct"><code>plan_idct()</code></a>, but operates in-place on <code>A</code>.</p> </dd>
</dl> <dl class="function"> <dt id="Base.fftshift">
<code>fftshift(x)</code> </dt> <dd>
<p>Swap the first and second halves of each dimension of <code>x</code>.</p> </dd>
</dl> <dl class="function"> <dt>
<code>fftshift(x, dim)</code> </dt> <dd>
<p>Swap the first and second halves of the given dimension of array <code>x</code>.</p> </dd>
</dl> <dl class="function"> <dt id="Base.ifftshift">
<code>ifftshift(x[, dim])</code> </dt> <dd>
<p>Undoes the effect of <code>fftshift</code>.</p> </dd>
</dl> <dl class="function"> <dt id="Base.filt">
<code>filt(b, a, x[, si])</code> </dt> <dd>
<p>Apply filter described by vectors <code>a</code> and <code>b</code> to vector <code>x</code>, with an optional initial filter state vector <code>si</code> (defaults to zeros).</p> </dd>
</dl> <dl class="function"> <dt id="Base.filt!">
<code>filt!(out, b, a, x[, si])</code> </dt> <dd>
<p>Same as <a class="reference internal" href="#Base.filt" title="Base.filt"><code>filt()</code></a> but writes the result into the <code>out</code> argument, which may alias the input <code>x</code> to modify it in-place.</p> </dd>
</dl> <dl class="function"> <dt id="Base.deconv">
<code>deconv(b, a)</code> </dt> <dd>
<p>Construct vector <code>c</code> such that <code>b = conv(a,c) + r</code>. Equivalent to polynomial division.</p> </dd>
</dl> <dl class="function"> <dt id="Base.conv">
<code>conv(u, v)</code> </dt> <dd>
<p>Convolution of two vectors. Uses FFT algorithm.</p> </dd>
</dl> <dl class="function"> <dt id="Base.conv2">
<code>conv2(u, v, A)</code> </dt> <dd>
<p>2-D convolution of the matrix <code>A</code> with the 2-D separable kernel generated by the vectors <code>u</code> and <code>v</code>. Uses 2-D FFT algorithm.</p> </dd>
</dl> <dl class="function"> <dt>
<code>conv2(B, A)</code> </dt> <dd>
<p>2-D convolution of the matrix <code>B</code> with the matrix <code>A</code>. Uses 2-D FFT algorithm.</p> </dd>
</dl> <dl class="function"> <dt id="Base.xcorr">
<code>xcorr(u, v)</code> </dt> <dd>
<p>Compute the cross-correlation of two vectors.</p> </dd>
</dl> <p>The following functions are defined within the <code>Base.FFTW</code> module.</p> <dl class="function"> <dt id="Base.FFTW.r2r">
<code>r2r(A, kind[, dims])</code> </dt> <dd>
<p>Performs a multidimensional real-input/real-output (r2r) transform of type <code>kind</code> of the array <code>A</code>, as defined in the FFTW manual. <code>kind</code> specifies either a discrete cosine transform of various types (<code>FFTW.REDFT00</code>, <code>FFTW.REDFT01</code>, <code>FFTW.REDFT10</code>, or <code>FFTW.REDFT11</code>), a discrete sine transform of various types (<code>FFTW.RODFT00</code>, <code>FFTW.RODFT01</code>, <code>FFTW.RODFT10</code>, or <code>FFTW.RODFT11</code>), a real-input DFT with halfcomplex-format output (<code>FFTW.R2HC</code> and its inverse <code>FFTW.HC2R</code>), or a discrete Hartley transform (<code>FFTW.DHT</code>). The <code>kind</code> argument may be an array or tuple in order to specify different transform types along the different dimensions of <code>A</code>; <code>kind[end]</code> is used for any unspecified dimensions. See the FFTW manual for precise definitions of these transform types, at <a class="reference external" href="http://www.fftw.org/doc" target="_blank">http://www.fftw.org/doc</a>.</p> <p>The optional <code>dims</code> argument specifies an iterable subset of dimensions (e.g. an integer, range, tuple, or array) to transform along. <code>kind[i]</code> is then the transform type for <code>dims[i]</code>, with <code>kind[end]</code> being used for <code>i &gt; length(kind)</code>.</p> <p>See also <a class="reference internal" href="#Base.FFTW.plan_r2r" title="Base.FFTW.plan_r2r"><code>plan_r2r()</code></a> to pre-plan optimized r2r transforms.</p> </dd>
</dl> <dl class="function"> <dt id="Base.FFTW.r2r!">
<code>r2r!(A, kind[, dims])</code> </dt> <dd>
<p>Same as <a class="reference internal" href="#Base.FFTW.r2r" title="Base.FFTW.r2r"><code>r2r()</code></a>, but operates in-place on <code>A</code>, which must be an array of real or complex floating-point numbers.</p> </dd>
</dl> <dl class="function"> <dt id="Base.FFTW.plan_r2r">
<code>plan_r2r(A, kind[, dims[, flags[, timelimit]]])</code> </dt> <dd>
<p>Pre-plan an optimized r2r transform, similar to <a class="reference internal" href="#Base.plan_fft" title="Base.plan_fft"><code>Base.plan_fft()</code></a> except that the transforms (and the first three arguments) correspond to <a class="reference internal" href="#Base.FFTW.r2r" title="Base.FFTW.r2r"><code>r2r()</code></a> and <a class="reference internal" href="#Base.FFTW.r2r!" title="Base.FFTW.r2r!"><code>r2r!()</code></a>, respectively.</p> </dd>
</dl> <dl class="function"> <dt id="Base.FFTW.plan_r2r!">
<code>plan_r2r!(A, kind[, dims[, flags[, timelimit]]])</code> </dt> <dd>
<p>Similar to <a class="reference internal" href="#Base.plan_fft" title="Base.plan_fft"><code>Base.plan_fft()</code></a>, but corresponds to <a class="reference internal" href="#Base.FFTW.r2r!" title="Base.FFTW.r2r!"><code>r2r!()</code></a>.</p> </dd>
</dl>   <h2 id="numerical-integration">Numerical Integration</h2> <p>Although several external packages are available for numeric integration and solution of ordinary differential equations, we also provide some built-in integration support in Julia.</p> <dl class="function"> <dt id="Base.quadgk">
<code>quadgk(f, a, b, c...; reltol=sqrt(eps), abstol=0, maxevals=10^7, order=7, norm=vecnorm)</code> </dt> <dd>
<p>Numerically integrate the function <code>f(x)</code> from <code>a</code> to <code>b</code>, and optionally over additional intervals <code>b</code> to <code>c</code> and so on. Keyword options include a relative error tolerance <code>reltol</code> (defaults to <code>sqrt(eps)</code> in the precision of the endpoints), an absolute error tolerance <code>abstol</code> (defaults to 0), a maximum number of function evaluations <code>maxevals</code> (defaults to <code>10^7</code>), and the <code>order</code> of the integration rule (defaults to 7).</p> <p>Returns a pair <code>(I,E)</code> of the estimated integral <code>I</code> and an estimated upper bound on the absolute error <code>E</code>. If <code>maxevals</code> is not exceeded then <code>E &lt;= max(abstol, reltol*norm(I))</code> will hold. (Note that it is useful to specify a positive <code>abstol</code> in cases where <code>norm(I)</code> may be zero.)</p> <p>The endpoints <code>a</code> et cetera can also be complex (in which case the integral is performed over straight-line segments in the complex plane). If the endpoints are <code>BigFloat</code>, then the integration will be performed in <code>BigFloat</code> precision as well.</p> <div class="admonition note"> <p class="first admonition-title">Note</p> <p class="last">It is advisable to increase the integration <code>order</code> in rough proportion to the precision, for smooth integrands.</p> </div> <p>More generally, the precision is set by the precision of the integration endpoints (promoted to floating-point types).</p> <p>The integrand <code>f(x)</code> can return any numeric scalar, vector, or matrix type, or in fact any type supporting <code>+</code>, <code>-</code>, multiplication by real values, and a <code>norm</code> (i.e., any normed vector space). Alternatively, a different norm can be specified by passing a <code>norm</code>-like function as the <code>norm</code> keyword argument (which defaults to <code>vecnorm</code>).</p> <div class="admonition note"> <p class="first admonition-title">Note</p> <p class="last">Only one-dimensional integrals are provided by this function. For multi-dimensional integration (cubature), there are many different algorithms (often much better than simple nested 1d integrals) and the optimal choice tends to be very problem-dependent. See the Julia external-package listing for available algorithms for multidimensional integration or other specialized tasks (such as integrals of highly oscillatory or singular functions).</p> </div> <p>The algorithm is an adaptive Gauss-Kronrod integration technique: the integral in each interval is estimated using a Kronrod rule (<code>2*order+1</code> points) and the error is estimated using an embedded Gauss rule (<code>order</code> points). The interval with the largest error is then subdivided into two intervals and the process is repeated until the desired error tolerance is achieved.</p> <p>These quadrature rules work best for smooth functions within each interval, so if your function has a known discontinuity or other singularity, it is best to subdivide your interval to put the singularity at an endpoint. For example, if <code>f</code> has a discontinuity at <code>x=0.7</code> and you want to integrate from 0 to 1, you should use <code>quadgk(f, 0,0.7,1)</code> to subdivide the interval at the point of discontinuity. The integrand is never evaluated exactly at the endpoints of the intervals, so it is possible to integrate functions that diverge at the endpoints as long as the singularity is integrable (for example, a <code>log(x)</code> or <code>1/sqrt(x)</code> singularity).</p> <p>For real-valued endpoints, the starting and/or ending points may be infinite. (A coordinate transformation is performed internally to map the infinite interval to a finite one.)</p> </dd>
</dl>
<div class="_attribution">
  <p class="_attribution-p">
    © 2009–2016 Jeff Bezanson, Stefan Karpinski, Viral B. Shah, and other contributors<br>Licensed under the MIT License.<br>
    <a href="http://docs.julialang.org/en/release-0.5/stdlib/math/" class="_attribution-link" target="_blank">http://docs.julialang.org/en/release-0.5/stdlib/math/</a>
  </p>
</div>

			</div>
		</div>
	</section>

	</div>
</body>
</html>
