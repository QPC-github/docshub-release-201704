
<!DOCTYPE HTML>

<html lang="en">

<head>
  <meta charset="utf-8">
  <title>Filesystem - Julia - W3cubDocs</title>
  
  <meta name="description" content=" Get the current working directory. ">
  <meta name="keywords" content="filesystem, -, julia">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="http://docs.w3cub.com/julia/stdlib/file/">
  <link href="/favicon.png" rel="icon">
  <link type="text/css" rel="stylesheet" href="/assets/application-50364fff564ce3b6327021805f3f00e2957b441cf27f576a7dd4ff63bbc47047.css">
  <script type="text/javascript" src="/assets/application-db64bfd54ceb42be11af7995804cf4902548419ceb79d509b0b7d62c22d98e6f.js"></script>
  <script src="/json/julia.js"></script>
  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-71174418-1']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>


</head>

<body>
	<div class="_app">
	<header class="_header">
  
  <form class="_search">
    <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
    <a class="_search-clear"></a>
    <div class="_search-tag"></div>
  </form>
  
  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/julia/" class="_nav-link" title="" style="margin-left:0;">Julia</a></span>
  
  <nav class="_nav">
    <a href="/app/" class="_nav-link ">App</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		<div class="_list">
			
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<div class="_page _sphinx_simple">
				
<h1>Filesystem</h1> <dl class="function"> <dt id="Base.pwd">
<code>pwd() → AbstractString</code> </dt> <dd>
<p>Get the current working directory.</p> </dd>
</dl> <dl class="function"> <dt id="Base.cd">
<code>cd([dir::AbstractString=homedir()])</code> </dt> <dd>
<p>Set the current working directory.</p> </dd>
</dl> <dl class="function"> <dt>
<code>cd(f[, dir=homedir()])</code> </dt> <dd>
<p>Temporarily changes the current working directory and applies function <code>f</code> before returning.</p> </dd>
</dl> <dl class="function"> <dt id="Base.readdir">
<code>readdir([dir]) → Vector{String}</code> </dt> <dd>
<p>Returns the files and directories in the directory <code>dir</code> (or the current working directory if not given).</p> </dd>
</dl> <dl class="function"> <dt id="Base.walkdir">
<code>walkdir(dir; topdown=true, follow_symlinks=false, onerror=throw)</code> </dt> <dd>
<p>The walkdir method return an iterator that walks the directory tree of a directory. The iterator returns a tuple containing <code>(rootpath, dirs, files)</code>. The directory tree can be traversed top-down or bottom-up. If walkdir encounters a SystemError it will raise the error. A custom error handling function can be provided through <code>onerror</code> keyword argument, the function is called with a SystemError as argument.</p> <pre data-language="julia">for (root, dirs, files) in walkdir(".")
    println("Directories in $root")
    for dir in dirs
        println(joinpath(root, dir)) # path to directories
    end
    println("Files in $root")
    for file in files
        println(joinpath(root, file)) # path to files
    end
end
</pre> </dd>
</dl> <dl class="function"> <dt id="Base.mkdir">
<code>mkdir(path[, mode])</code> </dt> <dd>
<p>Make a new directory with name <code>path</code> and permissions <code>mode</code>. <code>mode</code> defaults to <code>0o777</code>, modified by the current file creation mask.</p> </dd>
</dl> <dl class="function"> <dt id="Base.mkpath">
<code>mkpath(path[, mode])</code> </dt> <dd>
<p>Create all directories in the given <code>path</code>, with permissions <code>mode</code>. <code>mode</code> defaults to <code>0o777</code>, modified by the current file creation mask.</p> </dd>
</dl> <dl class="function"> <dt id="Base.symlink">
<code>symlink(target, link)</code> </dt> <dd>
<p>Creates a symbolic link to <code>target</code> with the name <code>link</code>.</p> <div class="admonition note"> <p class="first admonition-title">Note</p> <p class="last">This function raises an error under operating systems that do not support soft symbolic links, such as Windows XP.</p> </div> </dd>
</dl> <dl class="function"> <dt id="Base.readlink">
<code>readlink(path) → AbstractString</code> </dt> <dd>
<p>Returns the value of a symbolic link <code>path</code>.</p> </dd>
</dl> <dl class="function"> <dt id="Base.chmod">
<code>chmod(path, mode; recursive=false)</code> </dt> <dd>
<p>Change the permissions mode of <code>path</code> to <code>mode</code>. Only integer <code>mode</code>s (e.g. <code>0o777</code>) are currently supported. If <code>recursive=true</code> and the path is a directory all permissions in that directory will be recursively changed.</p> </dd>
</dl> <dl class="function"> <dt id="Base.chown">
<code>chown(path, owner, group=-1)</code> </dt> <dd>
<p>Change the owner and/or group of <code>path</code> to <code>owner</code> and/or <code>group</code>. If the value entered for <code>owner</code> or <code>group</code> is <code>-1</code> the corresponding ID will not change. Only integer <code>owner</code>s and <code>group</code>s are currently supported.</p> </dd>
</dl> <dl class="function"> <dt id="Base.stat">
<code>stat(file)</code> </dt> <dd>
<p>Returns a structure whose fields contain information about the file. The fields of the structure are:</p> <table class="docutils">  <thead valign="bottom"> <tr class="row-odd">
<th class="head">Name</th> <th class="head">Description</th> </tr> </thead>  <tr class="row-even">
<td>size</td> <td>The size (in bytes) of the file</td> </tr> <tr class="row-odd">
<td>device</td> <td>ID of the device that contains the file</td> </tr> <tr class="row-even">
<td>inode</td> <td>The inode number of the file</td> </tr> <tr class="row-odd">
<td>mode</td> <td>The protection mode of the file</td> </tr> <tr class="row-even">
<td>nlink</td> <td>The number of hard links to the file</td> </tr> <tr class="row-odd">
<td>uid</td> <td>The user id of the owner of the file</td> </tr> <tr class="row-even">
<td>gid</td> <td>The group id of the file owner</td> </tr> <tr class="row-odd">
<td>rdev</td> <td>If this file refers to a device, the ID of the device it refers to</td> </tr> <tr class="row-even">
<td>blksize</td> <td>The file-system preferred block size for the file</td> </tr> <tr class="row-odd">
<td>blocks</td> <td>The number of such blocks allocated</td> </tr> <tr class="row-even">
<td>mtime</td> <td>Unix timestamp of when the file was last modified</td> </tr> <tr class="row-odd">
<td>ctime</td> <td>Unix timestamp of when the file was created</td> </tr>  </table> </dd>
</dl> <dl class="function"> <dt id="Base.lstat">
<code>lstat(file)</code> </dt> <dd>
<p>Like stat, but for symbolic links gets the info for the link itself rather than the file it refers to. This function must be called on a file path rather than a file object or a file descriptor.</p> </dd>
</dl> <dl class="function"> <dt id="Base.ctime">
<code>ctime(file)</code> </dt> <dd>
<p>Equivalent to <code>stat(file).ctime</code></p> </dd>
</dl> <dl class="function"> <dt id="Base.mtime">
<code>mtime(file)</code> </dt> <dd>
<p>Equivalent to <code>stat(file).mtime</code>.</p> </dd>
</dl> <dl class="function"> <dt id="Base.filemode">
<code>filemode(file)</code> </dt> <dd>
<p>Equivalent to <code>stat(file).mode</code></p> </dd>
</dl> <dl class="function"> <dt id="Base.filesize">
<code>filesize(path...)</code> </dt> <dd>
<p>Equivalent to <code>stat(file).size</code>.</p> </dd>
</dl> <dl class="function"> <dt id="Base.uperm">
<code>uperm(file)</code> </dt> <dd>
<p>Gets the permissions of the owner of the file as a bitfield of</p> <table class="docutils">  <thead valign="bottom"> <tr class="row-odd">
<th class="head">Value</th> <th class="head">Description</th> </tr> </thead>  <tr class="row-even">
<td>01</td> <td>Execute Permission</td> </tr> <tr class="row-odd">
<td>02</td> <td>Write Permission</td> </tr> <tr class="row-even">
<td>04</td> <td>Read Permission</td> </tr>  </table> <p>For allowed arguments, see <code>stat</code>.</p> </dd>
</dl> <dl class="function"> <dt id="Base.gperm">
<code>gperm(file)</code> </dt> <dd>
<p>Like uperm but gets the permissions of the group owning the file.</p> </dd>
</dl> <dl class="function"> <dt id="Base.operm">
<code>operm(file)</code> </dt> <dd>
<p>Like uperm but gets the permissions for people who neither own the file nor are a member of the group owning the file</p> </dd>
</dl> <dl class="function"> <dt id="Base.cp">
<code>cp(src::AbstractString, dst::AbstractString; remove_destination::Bool=false, follow_symlinks::Bool=false)</code> </dt> <dd>
<p>Copy the file, link, or directory from <em>src</em> to <em>dest</em>. <code>remove_destination=true</code> will first remove an existing <code>dst</code>.</p> <p>If <code>follow_symlinks=false</code>, and <code>src</code> is a symbolic link, <code>dst</code> will be created as a symbolic link. If <code>follow_symlinks=true</code> and <code>src</code> is a symbolic link, <code>dst</code> will be a copy of the file or directory <code>src</code> refers to.</p> </dd>
</dl> <dl class="function"> <dt id="Base.download">
<code>download(url[, localfile])</code> </dt> <dd>
<p>Download a file from the given url, optionally renaming it to the given local file name. Note that this function relies on the availability of external tools such as <code>curl</code>, <code>wget</code> or <code>fetch</code> to download the file and is provided for convenience. For production use or situations in which more options are needed, please use a package that provides the desired functionality instead.</p> </dd>
</dl> <dl class="function"> <dt id="Base.mv">
<code>mv(src::AbstractString, dst::AbstractString; remove_destination::Bool=false)</code> </dt> <dd>
<p>Move the file, link, or directory from <code>src</code> to <code>dst</code>. <code>remove_destination=true</code> will first remove an existing <code>dst</code>.</p> </dd>
</dl> <dl class="function"> <dt id="Base.rm">
<code>rm(path::AbstractString; force=false, recursive=false)</code> </dt> <dd>
<p>Delete the file, link, or empty directory at the given path. If <code>force=true</code> is passed, a non-existing path is not treated as error. If <code>recursive=true</code> is passed and the path is a directory, then all contents are removed recursively.</p> </dd>
</dl> <dl class="function"> <dt id="Base.touch">
<code>touch(path::AbstractString)</code> </dt> <dd>
<p>Update the last-modified timestamp on a file to the current time.</p> </dd>
</dl> <dl class="function"> <dt id="Base.tempname">
<code>tempname()</code> </dt> <dd>
<p>Generate a unique temporary file path.</p> </dd>
</dl> <dl class="function"> <dt id="Base.tempdir">
<code>tempdir()</code> </dt> <dd>
<p>Obtain the path of a temporary directory (possibly shared with other processes).</p> </dd>
</dl> <dl class="function"> <dt id="Base.mktemp">
<code>mktemp([parent=tempdir()])</code> </dt> <dd>
<p>Returns <code>(path, io)</code>, where <code>path</code> is the path of a new temporary file in <code>parent</code> and <code>io</code> is an open file object for this path.</p> </dd>
</dl> <dl class="function"> <dt>
<code>mktemp(f::Function[, parent=tempdir()])</code> </dt> <dd>
<p>Apply the function <code>f</code> to the result of <code>mktemp(parent)</code> and remove the temporary file upon completion.</p> </dd>
</dl> <dl class="function"> <dt id="Base.mktempdir">
<code>mktempdir([parent=tempdir()])</code> </dt> <dd>
<p>Create a temporary directory in the <code>parent</code> directory and return its path.</p> </dd>
</dl> <dl class="function"> <dt>
<code>mktempdir(f::Function[, parent=tempdir()])</code> </dt> <dd>
<p>Apply the function <code>f</code> to the result of <code>mktempdir(parent)</code> and remove the temporary directory upon completion.</p> </dd>
</dl> <dl class="function"> <dt id="Base.isblockdev">
<code>isblockdev(path) → Bool</code> </dt> <dd>
<p>Returns <code>true</code> if <code>path</code> is a block device, <code>false</code> otherwise.</p> </dd>
</dl> <dl class="function"> <dt id="Base.ischardev">
<code>ischardev(path) → Bool</code> </dt> <dd>
<p>Returns <code>true</code> if <code>path</code> is a character device, <code>false</code> otherwise.</p> </dd>
</dl> <dl class="function"> <dt id="Base.isdir">
<code>isdir(path) → Bool</code> </dt> <dd>
<p>Returns <code>true</code> if <code>path</code> is a directory, <code>false</code> otherwise.</p> </dd>
</dl> <dl class="function"> <dt id="Base.isfifo">
<code>isfifo(path) → Bool</code> </dt> <dd>
<p>Returns <code>true</code> if <code>path</code> is a FIFO, <code>false</code> otherwise.</p> </dd>
</dl> <dl class="function"> <dt id="Base.isfile">
<code>isfile(path) → Bool</code> </dt> <dd>
<p>Returns <code>true</code> if <code>path</code> is a regular file, <code>false</code> otherwise.</p> </dd>
</dl> <dl class="function"> <dt id="Base.islink">
<code>islink(path) → Bool</code> </dt> <dd>
<p>Returns <code>true</code> if <code>path</code> is a symbolic link, <code>false</code> otherwise.</p> </dd>
</dl> <dl class="function"> <dt id="Base.ismount">
<code>ismount(path) → Bool</code> </dt> <dd>
<p>Returns <code>true</code> if <code>path</code> is a mount point, <code>false</code> otherwise.</p> </dd>
</dl> <dl class="function"> <dt id="Base.ispath">
<code>ispath(path) → Bool</code> </dt> <dd>
<p>Returns <code>true</code> if <code>path</code> is a valid filesystem path, <code>false</code> otherwise.</p> </dd>
</dl> <dl class="function"> <dt id="Base.issetgid">
<code>issetgid(path) → Bool</code> </dt> <dd>
<p>Returns <code>true</code> if <code>path</code> has the setgid flag set, <code>false</code> otherwise.</p> </dd>
</dl> <dl class="function"> <dt id="Base.issetuid">
<code>issetuid(path) → Bool</code> </dt> <dd>
<p>Returns <code>true</code> if <code>path</code> has the setuid flag set, <code>false</code> otherwise.</p> </dd>
</dl> <dl class="function"> <dt id="Base.issocket">
<code>issocket(path) → Bool</code> </dt> <dd>
<p>Returns <code>true</code> if <code>path</code> is a socket, <code>false</code> otherwise.</p> </dd>
</dl> <dl class="function"> <dt id="Base.issticky">
<code>issticky(path) → Bool</code> </dt> <dd>
<p>Returns <code>true</code> if <code>path</code> has the sticky bit set, <code>false</code> otherwise.</p> </dd>
</dl> <dl class="function"> <dt id="Base.homedir">
<code>homedir() → AbstractString</code> </dt> <dd>
<p>Return the current user’s home directory.</p> </dd>
</dl> <dl class="function"> <dt id="Base.dirname">
<code>dirname(path::AbstractString) → AbstractString</code> </dt> <dd>
<p>Get the directory part of a path.</p> </dd>
</dl> <dl class="function"> <dt id="Base.basename">
<code>basename(path::AbstractString) → AbstractString</code> </dt> <dd>
<p>Get the file name part of a path.</p> </dd>
</dl> <dl class="function"> <dt id="Base.@__FILE__">
<code>@__FILE__() → AbstractString</code> </dt> <dd>
<p><code>@__FILE__</code> expands to a string with the absolute file path of the file containing the macro. Returns <code>nothing</code> if run from a REPL or an empty string if evaluated by <code>julia -e &lt;expr&gt;</code>. Alternatively see <a class="reference internal" href="../constants/#Base.PROGRAM_FILE" title="Base.PROGRAM_FILE"><code>PROGRAM_FILE</code></a>.</p> </dd>
</dl> <dl class="function"> <dt id="Base.@__LINE__">
<code>@__LINE__() → Int</code> </dt> <dd>
<p><code>@__LINE__</code> expands to the line number of the call-site.</p> </dd>
</dl> <dl class="function"> <dt id="Base.isabspath">
<code>isabspath(path::AbstractString) → Bool</code> </dt> <dd>
<p>Determines whether a path is absolute (begins at the root directory).</p> </dd>
</dl> <dl class="function"> <dt id="Base.isdirpath">
<code>isdirpath(path::AbstractString) → Bool</code> </dt> <dd>
<p>Determines whether a path refers to a directory (for example, ends with a path separator).</p> </dd>
</dl> <dl class="function"> <dt id="Base.joinpath">
<code>joinpath(parts...) → AbstractString</code> </dt> <dd>
<p>Join path components into a full path. If some argument is an absolute path, then prior components are dropped.</p> </dd>
</dl> <dl class="function"> <dt id="Base.abspath">
<code>abspath(path::AbstractString) → AbstractString</code> </dt> <dd>
<p>Convert a path to an absolute path by adding the current directory if necessary.</p> </dd>
</dl> <dl class="function"> <dt id="Base.normpath">
<code>normpath(path::AbstractString) → AbstractString</code> </dt> <dd>
<p>Normalize a path, removing ”.” and ”..” entries.</p> </dd>
</dl> <dl class="function"> <dt id="Base.realpath">
<code>realpath(path::AbstractString) → AbstractString</code> </dt> <dd>
<p>Canonicalize a path by expanding symbolic links and removing ”.” and ”..” entries.</p> </dd>
</dl> <dl class="function"> <dt id="Base.relpath">
<code>relpath(path::AbstractString, startpath::AbstractString = ".") → AbstractString</code> </dt> <dd>
<p>Return a relative filepath to path either from the current directory or from an optional start directory. This is a path computation: the filesystem is not accessed to confirm the existence or nature of path or startpath.</p> </dd>
</dl> <dl class="function"> <dt id="Base.expanduser">
<code>expanduser(path::AbstractString) → AbstractString</code> </dt> <dd>
<p>On Unix systems, replace a tilde character at the start of a path with the current user’s home directory.</p> </dd>
</dl> <dl class="function"> <dt id="Base.splitdir">
<code>splitdir(path::AbstractString) → (AbstractString,AbstractString)</code> </dt> <dd>
<p>Split a path into a tuple of the directory name and file name.</p> </dd>
</dl> <dl class="function"> <dt id="Base.splitdrive">
<code>splitdrive(path::AbstractString) → (AbstractString,AbstractString)</code> </dt> <dd>
<p>On Windows, split a path into the drive letter part and the path part. On Unix systems, the first component is always the empty string.</p> </dd>
</dl> <dl class="function"> <dt id="Base.splitext">
<code>splitext(path::AbstractString) → (AbstractString,AbstractString)</code> </dt> <dd>
<p>If the last component of a path contains a dot, split the path into everything before the dot and everything including and after the dot. Otherwise, return a tuple of the argument unmodified and the empty string.</p> </dd>
</dl>
<div class="_attribution">
  <p class="_attribution-p">
    © 2009–2016 Jeff Bezanson, Stefan Karpinski, Viral B. Shah, and other contributors<br>Licensed under the MIT License.<br>
    <a href="http://docs.julialang.org/en/release-0.5/stdlib/file/" class="_attribution-link" target="_blank">http://docs.julialang.org/en/release-0.5/stdlib/file/</a>
  </p>
</div>

			</div>
		</div>
	</section>

	</div>
</body>
</html>
