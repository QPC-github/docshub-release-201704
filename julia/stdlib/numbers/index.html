
<!DOCTYPE HTML>

<html lang="en">

<head>
  <meta charset="utf-8">
  <title>Numbers - Julia - W3cubDocs</title>
  
  <meta name="description" content=" Bool Int8 UInt8 Int16 UInt16 Int32 UInt32 Int64 UInt64 Int128 UInt128 Float16 Float32 Float64 Complex64 Complex128 ">
  <meta name="keywords" content="numbers, -, julia">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="http://docs.w3cub.com/julia/stdlib/numbers/">
  <link href="/favicon.png" rel="icon">
  <link type="text/css" rel="stylesheet" href="/assets/application-50364fff564ce3b6327021805f3f00e2957b441cf27f576a7dd4ff63bbc47047.css">
  <script type="text/javascript" src="/assets/application-db64bfd54ceb42be11af7995804cf4902548419ceb79d509b0b7d62c22d98e6f.js"></script>
  <script src="/json/julia.js"></script>
  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-71174418-1']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>


</head>

<body>
	<div class="_app">
	<header class="_header">
  
  <form class="_search">
    <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
    <a class="_search-clear"></a>
    <div class="_search-tag"></div>
  </form>
  
  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/julia/" class="_nav-link" title="" style="margin-left:0;">Julia</a></span>
  
  <nav class="_nav">
    <a href="/app/" class="_nav-link ">App</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		<div class="_list">
			
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<div class="_page _sphinx_simple">
				
<h1>Numbers</h1>  <h2 id="standard-numeric-types">Standard Numeric Types</h2> <p><code>Bool</code> <code>Int8</code> <code>UInt8</code> <code>Int16</code> <code>UInt16</code> <code>Int32</code> <code>UInt32</code> <code>Int64</code> <code>UInt64</code> <code>Int128</code> <code>UInt128</code> <code>Float16</code> <code>Float32</code> <code>Float64</code> <code>Complex64</code> <code>Complex128</code></p>   <h2 id="data-formats">Data Formats</h2> <dl class="function"> <dt id="Base.bin">
<code>bin(n[, pad])</code> </dt> <dd>
<p>Convert an integer to a binary string, optionally specifying a number of digits to pad to.</p> </dd>
</dl> <dl class="function"> <dt id="Base.hex">
<code>hex(n[, pad])</code> </dt> <dd>
<p>Convert an integer to a hexadecimal string, optionally specifying a number of digits to pad to.</p> </dd>
</dl> <dl class="function"> <dt id="Base.dec">
<code>dec(n[, pad])</code> </dt> <dd>
<p>Convert an integer to a decimal string, optionally specifying a number of digits to pad to.</p> </dd>
</dl> <dl class="function"> <dt id="Base.oct">
<code>oct(n[, pad])</code> </dt> <dd>
<p>Convert an integer to an octal string, optionally specifying a number of digits to pad to.</p> </dd>
</dl> <dl class="function"> <dt id="Base.base">
<code>base(base, n[, pad])</code> </dt> <dd>
<p>Convert an integer to a string in the given base, optionally specifying a number of digits to pad to.</p> </dd>
</dl> <dl class="function"> <dt id="Base.digits">
<code>digits([T, ]n[, base][, pad])</code> </dt> <dd>
<p>Returns an array with element type <code>T</code> (default <code>Int</code>) of the digits of <code>n</code> in the given base, optionally padded with zeros to a specified size. More significant digits are at higher indexes, such that <code>n == sum([digits[k]*base^(k-1) for k=1:length(digits)])</code>.</p> </dd>
</dl> <dl class="function"> <dt id="Base.digits!">
<code>digits!(array, n[, base])</code> </dt> <dd>
<p>Fills an array of the digits of <code>n</code> in the given base. More significant digits are at higher indexes. If the array length is insufficient, the least significant digits are filled up to the array length. If the array length is excessive, the excess portion is filled with zeros.</p> </dd>
</dl> <dl class="function"> <dt id="Base.bits">
<code>bits(n)</code> </dt> <dd>
<p>A string giving the literal bit representation of a number.</p> </dd>
</dl> <dl class="function"> <dt id="Base.parse">
<code>parse(type, str[, base])</code> </dt> <dd>
<p>Parse a string as a number. If the type is an integer type, then a base can be specified (the default is 10). If the type is a floating point type, the string is parsed as a decimal floating point number. If the string does not contain a valid number, an error is raised.</p> </dd>
</dl> <dl class="function"> <dt id="Base.tryparse">
<code>tryparse(type, str[, base])</code> </dt> <dd>
<p>Like <code>parse</code>, but returns a <code>Nullable</code> of the requested type. The result will be null if the string does not contain a valid number.</p> </dd>
</dl> <dl class="function"> <dt id="Base.big">
<code>big(x)</code> </dt> <dd>
<p>Convert a number to a maximum precision representation (typically <code>BigInt</code> or <code>BigFloat</code>). See <code>BigFloat</code> for information about some pitfalls with floating-point numbers.</p> </dd>
</dl> <dl class="function"> <dt id="Base.signed">
<code>signed(x)</code> </dt> <dd>
<p>Convert a number to a signed integer. If the argument is unsigned, it is reinterpreted as signed without checking for overflow.</p> </dd>
</dl> <dl class="function"> <dt id="Base.unsigned">
<code>unsigned(x) → Unsigned</code> </dt> <dd>
<p>Convert a number to an unsigned integer. If the argument is signed, it is reinterpreted as unsigned without checking for negative values.</p> </dd>
</dl> <dl class="function"> <dt id="Base.float">
<code>float(x)</code> </dt> <dd>
<p>Convert a number, array, or string to a <code>AbstractFloat</code> data type. For numeric data, the smallest suitable <code>AbstractFloat</code> type is used. Converts strings to <code>Float64</code>.</p> </dd>
</dl> <dl class="function"> <dt id="Base.significand">
<code>significand(x)</code> </dt> <dd>
<p>Extract the <code>significand(s)</code> (a.k.a. mantissa), in binary representation, of a floating-point number or array. If <code>x</code> is a non-zero finite number, then the result will be a number of the same type on the interval <span class="math">\([1,2)\)</span>. Otherwise <code>x</code> is returned.</p> <pre data-language="julia">julia&gt; significand(15.2)/15.2
0.125

julia&gt; significand(15.2)*8
15.2
</pre> </dd>
</dl> <dl class="function"> <dt id="Base.exponent">
<code>exponent(x) → Int</code> </dt> <dd>
<p>Get the exponent of a normalized floating-point number.</p> </dd>
</dl> <dl class="function"> <dt id="Base.complex">
<code>complex(r[, i])</code> </dt> <dd>
<p>Convert real numbers or arrays to complex. <code>i</code> defaults to zero.</p> </dd>
</dl> <dl class="function"> <dt id="Base.bswap">
<code>bswap(n)</code> </dt> <dd>
<p>Byte-swap an integer.</p> </dd>
</dl> <dl class="function"> <dt id="Base.num2hex">
<code>num2hex(f)</code> </dt> <dd>
<p>Get a hexadecimal string of the binary representation of a floating point number.</p> </dd>
</dl> <dl class="function"> <dt id="Base.hex2num">
<code>hex2num(str)</code> </dt> <dd>
<p>Convert a hexadecimal string to the floating point number it represents.</p> </dd>
</dl> <dl class="function"> <dt id="Base.hex2bytes">
<code>hex2bytes(s::AbstractString)</code> </dt> <dd>
<p>Convert an arbitrarily long hexadecimal string to its binary representation. Returns an <code>Array{UInt8,1}</code>, i.e. an array of bytes.</p> </dd>
</dl> <dl class="function"> <dt id="Base.bytes2hex">
<code>bytes2hex(bin_arr::Array{UInt8, 1})</code> </dt> <dd>
<p>Convert an array of bytes to its hexadecimal representation. All characters are in lower-case. Returns a <code>String</code>.</p> </dd>
</dl>   <h2 id="general-number-functions-and-constants">General Number Functions and Constants</h2> <dl class="function"> <dt id="Base.one">
<code>one(x)</code> </dt> <dd>
<p>Get the multiplicative identity element for the type of <code>x</code> (<code>x</code> can also specify the type itself). For matrices, returns an identity matrix of the appropriate size and type.</p> </dd>
</dl> <dl class="function"> <dt id="Base.zero">
<code>zero(x)</code> </dt> <dd>
<p>Get the additive identity element for the type of <code>x</code> (<code>x</code> can also specify the type itself).</p> </dd>
</dl> <dl class="data"> <dt id="Base.pi">
<code>pi</code> </dt> <dt id="Base.π">
<code>π</code> </dt> <dd>
<p>The constant pi.</p> </dd>
</dl> <dl class="data"> <dt id="Base.im">
<code>im</code> </dt> <dd>
<p>The imaginary unit.</p> </dd>
</dl> <dl class="data"> <dt id="Base.e">
<code>e</code> </dt> <dt id="Base.eu">
<code>eu</code> </dt> <dd>
<p>The constant e.</p> </dd>
</dl> <dl class="data"> <dt id="Base.catalan">
<code>catalan</code> </dt> <dd>
<p>Catalan’s constant.</p> </dd>
</dl> <dl class="data"> <dt id="Base.γ">
<code>γ</code> </dt> <dt id="Base.eulergamma">
<code>eulergamma</code> </dt> <dd>
<p>Euler’s constant.</p> </dd>
</dl> <dl class="data"> <dt id="Base.φ">
<code>φ</code> </dt> <dt id="Base.golden">
<code>golden</code> </dt> <dd>
<p>The golden ratio.</p> </dd>
</dl> <dl class="data"> <dt id="Base.Inf">
<code>Inf</code> </dt> <dd>
<p>Positive infinity of type <code>Float64</code>.</p> </dd>
</dl> <dl class="data"> <dt id="Base.Inf32">
<code>Inf32</code> </dt> <dd>
<p>Positive infinity of type <code>Float32</code>.</p> </dd>
</dl> <dl class="data"> <dt id="Base.Inf16">
<code>Inf16</code> </dt> <dd>
<p>Positive infinity of type <code>Float16</code>.</p> </dd>
</dl> <dl class="data"> <dt id="Base.NaN">
<code>NaN</code> </dt> <dd>
<p>A not-a-number value of type <code>Float64</code>.</p> </dd>
</dl> <dl class="data"> <dt id="Base.NaN32">
<code>NaN32</code> </dt> <dd>
<p>A not-a-number value of type <code>Float32</code>.</p> </dd>
</dl> <dl class="data"> <dt id="Base.NaN16">
<code>NaN16</code> </dt> <dd>
<p>A not-a-number value of type <code>Float16</code>.</p> </dd>
</dl> <dl class="function"> <dt id="Base.issubnormal">
<code>issubnormal(f) → Bool</code> </dt> <dd>
<p>Test whether a floating point number is subnormal.</p> </dd>
</dl> <dl class="function"> <dt id="Base.isfinite">
<code>isfinite(f) → Bool</code> </dt> <dd>
<p>Test whether a number is finite</p> </dd>
</dl> <dl class="function"> <dt id="Base.isinf">
<code>isinf(f) → Bool</code> </dt> <dd>
<p>Test whether a number is infinite.</p> </dd>
</dl> <dl class="function"> <dt id="Base.isnan">
<code>isnan(f) → Bool</code> </dt> <dd>
<p>Test whether a floating point number is not a number (NaN).</p> </dd>
</dl> <dl class="function"> <dt id="Base.nextfloat">
<code>nextfloat(x::AbstractFloat)</code> </dt> <dd>
<p>Returns the smallest floating point number <code>y</code> of the same type as <code>x</code> such <code>x &lt; y</code>. If no such <code>y</code> exists (e.g. if <code>x</code> is <code>Inf</code> or <code>NaN</code>), then returns <code>x</code>.</p> </dd>
</dl> <dl class="function"> <dt id="Base.prevfloat">
<code>prevfloat(x::AbstractFloat)</code> </dt> <dd>
<p>Returns the largest floating point number <code>y</code> of the same type as <code>x</code> such <code>y &lt; x</code>. If no such <code>y</code> exists (e.g. if <code>x</code> is <code>-Inf</code> or <code>NaN</code>), then returns <code>x</code>.</p> </dd>
</dl> <dl class="function"> <dt>
<code>nextfloat(x::AbstractFloat, n::Integer)</code> </dt> <dd>
<p>The result of <code>n</code> iterative applications of <code>nextfloat</code> to <code>x</code> if <code>n &gt;= 0</code>, or <code>-n</code> applications of <code>prevfloat</code> if <code>n &lt; 0</code>.</p> </dd>
</dl> <dl class="function"> <dt id="Base.isinteger">
<code>isinteger(x) → Bool</code> </dt> <dd>
<p>Test whether <code>x</code> or all its elements are numerically equal to some integer</p> </dd>
</dl> <dl class="function"> <dt id="Base.isreal">
<code>isreal(x) → Bool</code> </dt> <dd>
<p>Test whether <code>x</code> or all its elements are numerically equal to some real number.</p> </dd>
</dl> <dl class="function"> <dt id="Base.isimag">
<code>isimag(z) → Bool</code> </dt> <dd>
<p>Test whether <code>z</code> is purely imaginary, i.e. has a real part equal to 0.</p> </dd>
</dl> <dl class="function"> <dt id="Base.Float32">
<code>Float32(x[, mode::RoundingMode])</code> </dt> <dd>
<p>Create a Float32 from <code>x</code>. If <code>x</code> is not exactly representable then <code>mode</code> determines how <code>x</code> is rounded.</p> <pre data-language="julia">julia&gt; Float32(1/3, RoundDown)
0.3333333f0

julia&gt; Float32(1/3, RoundUp)
0.33333334f0
</pre> <p>See <a class="reference internal" href="../math/#Base.RoundingMode" title="Base.RoundingMode"><code>RoundingMode</code></a> for available rounding modes.</p> </dd>
</dl> <dl class="function"> <dt id="Base.Float64">
<code>Float64(x[, mode::RoundingMode])</code> </dt> <dd>
<p>Create a Float64 from <code>x</code>. If <code>x</code> is not exactly representable then <code>mode</code> determines how <code>x</code> is rounded.</p> <pre data-language="julia">julia&gt; Float64(pi, RoundDown)
3.141592653589793

julia&gt; Float64(pi, RoundUp)
3.1415926535897936
</pre> <p>See <a class="reference internal" href="../math/#Base.RoundingMode" title="Base.RoundingMode"><code>RoundingMode</code></a> for available rounding modes.</p> </dd>
</dl> <dl class="function"> <dt id="Base.BigInt">
<code>BigInt(x)</code> </dt> <dd>
<p>Create an arbitrary precision integer. <code>x</code> may be an <code>Int</code> (or anything that can be converted to an <code>Int</code>). The usual mathematical operators are defined for this type, and results are promoted to a <code>BigInt</code>.</p> <p>Instances can be constructed from strings via <a class="reference internal" href="#Base.parse" title="Base.parse"><code>parse()</code></a>, or using the <code>big</code> string literal.</p> </dd>
</dl> <dl class="function"> <dt id="Base.BigFloat">
<code>BigFloat(x)</code> </dt> <dd>
<p>Create an arbitrary precision floating point number. <code>x</code> may be an <code>Integer</code>, a <code>Float64</code> or a <code>BigInt</code>. The usual mathematical operators are defined for this type, and results are promoted to a <code>BigFloat</code>.</p> <p>Note that because decimal literals are converted to floating point numbers when parsed, <code>BigFloat(2.1)</code> may not yield what you expect. You may instead prefer to initialize constants from strings via <a class="reference internal" href="#Base.parse" title="Base.parse"><code>parse()</code></a>, or using the <code>big</code> string literal.</p> <pre data-language="julia">julia&gt; BigFloat(2.1)
2.100000000000000088817841970012523233890533447265625000000000000000000000000000

julia&gt; big"2.1"
2.099999999999999999999999999999999999999999999999999999999999999999999999999986
</pre> </dd>
</dl> <dl class="function"> <dt id="Base.rounding">
<code>rounding(T)</code> </dt> <dd>
<p>Get the current floating point rounding mode for type <code>T</code>, controlling the rounding of basic arithmetic functions (<a class="reference internal" href="../math/#Base.+" title="Base.+"><code>+()</code></a>, <a class="reference internal" href="../math/#Base.-" title="Base.-"><code>-()</code></a>, <a class="reference internal" href="../strings/#Base.*" title="Base.*"><code>*()</code></a>, <a class="reference internal" href="../math/#Base./" title="Base./"><code>/()</code></a> and <a class="reference internal" href="../math/#Base.sqrt" title="Base.sqrt"><code>sqrt()</code></a>) and type conversion.</p> <p>See <a class="reference internal" href="../math/#Base.RoundingMode" title="Base.RoundingMode"><code>RoundingMode</code></a> for available modes.</p> </dd>
</dl> <dl class="function"> <dt id="Base.setrounding">
<code>setrounding(T, mode)</code> </dt> <dd>
<p>Set the rounding mode of floating point type <code>T</code>, controlling the rounding of basic arithmetic functions (<a class="reference internal" href="../math/#Base.+" title="Base.+"><code>+()</code></a>, <a class="reference internal" href="../math/#Base.-" title="Base.-"><code>-()</code></a>, <a class="reference internal" href="../strings/#Base.*" title="Base.*"><code>*()</code></a>, <a class="reference internal" href="../math/#Base./" title="Base./"><code>/()</code></a> and <a class="reference internal" href="../math/#Base.sqrt" title="Base.sqrt"><code>sqrt()</code></a>) and type conversion. Other numerical functions may give incorrect or invalid values when using rounding modes other than the default <code>RoundNearest</code>.</p> <p>Note that this may affect other types, for instance changing the rounding mode of <code>Float64</code> will change the rounding mode of <code>Float32</code>. See <a class="reference internal" href="../math/#Base.RoundingMode" title="Base.RoundingMode"><code>RoundingMode</code></a> for available modes.</p> <div class="admonition warning"> <p class="first admonition-title">Warning</p> <p class="last">This feature is still experimental, and may give unexpected or incorrect values.</p> </div> </dd>
</dl> <dl class="function"> <dt>
<code>setrounding(f::Function, T, mode)</code> </dt> <dd>
<p>Change the rounding mode of floating point type <code>T</code> for the duration of <code>f</code>. It is logically equivalent to:</p> <pre data-language="julia">old = rounding(T)
setrounding(T, mode)
f()
setrounding(T, old)
</pre> <p>See <a class="reference internal" href="../math/#Base.RoundingMode" title="Base.RoundingMode"><code>RoundingMode</code></a> for available rounding modes.</p> <div class="admonition warning"> <p class="first admonition-title">Warning</p> <p>This feature is still experimental, and may give unexpected or incorrect values. A known problem is the interaction with compiler optimisations, e.g.</p> <pre data-language="julia">julia&gt; setrounding(Float64,RoundDown) do
    1.1 + 0.1
end
1.2000000000000002
</pre> <p>Here the compiler is <em>constant folding</em>, that is evaluating a known constant expression at compile time, however the rounding mode is only changed at runtime, so this is not reflected in the function result. This can be avoided by moving constants outside the expression, e.g.</p> <pre data-language="julia">julia&gt; x = 1.1; y = 0.1;

julia&gt; setrounding(Float64,RoundDown) do
    x + y
end
1.2
</pre> </div> </dd>
</dl> <dl class="function"> <dt id="Base.get_zero_subnormals">
<code>get_zero_subnormals() → Bool</code> </dt> <dd>
<p>Returns <code>false</code> if operations on subnormal floating-point values (“denormals”) obey rules for IEEE arithmetic, and <code>true</code> if they might be converted to zeros.</p> </dd>
</dl> <dl class="function"> <dt id="Base.set_zero_subnormals">
<code>set_zero_subnormals(yes::Bool) → Bool</code> </dt> <dd>
<p>If <code>yes</code> is <code>false</code>, subsequent floating-point operations follow rules for IEEE arithmetic on subnormal values (“denormals”). Otherwise, floating-point operations are permitted (but not required) to convert subnormal inputs or outputs to zero. Returns <code>true</code> unless <code>yes==true</code> but the hardware does not support zeroing of subnormal numbers.</p> <p><code>set_zero_subnormals(true)</code> can speed up some computations on some hardware. However, it can break identities such as <code>(x-y==0) == (x==y)</code>.</p> </dd>
</dl>  <h3 id="integers">Integers</h3> <dl class="function"> <dt id="Base.count_ones">
<code>count_ones(x::Integer) → Integer</code> </dt> <dd>
<p>Number of ones in the binary representation of <code>x</code>.</p> <pre data-language="julia">julia&gt; count_ones(7)
3
</pre> </dd>
</dl> <dl class="function"> <dt id="Base.count_zeros">
<code>count_zeros(x::Integer) → Integer</code> </dt> <dd>
<p>Number of zeros in the binary representation of <code>x</code>.</p> <pre data-language="julia">julia&gt; count_zeros(Int32(2 ^ 16 - 1))
16
</pre> </dd>
</dl> <dl class="function"> <dt id="Base.leading_zeros">
<code>leading_zeros(x::Integer) → Integer</code> </dt> <dd>
<p>Number of zeros leading the binary representation of <code>x</code>.</p> <pre data-language="julia">julia&gt; leading_zeros(Int32(1))
31
</pre> </dd>
</dl> <dl class="function"> <dt id="Base.leading_ones">
<code>leading_ones(x::Integer) → Integer</code> </dt> <dd>
<p>Number of ones leading the binary representation of <code>x</code>.</p> <pre data-language="julia">julia&gt; leading_ones(UInt32(2 ^ 32 - 2))
31
</pre> </dd>
</dl> <dl class="function"> <dt id="Base.trailing_zeros">
<code>trailing_zeros(x::Integer) → Integer</code> </dt> <dd>
<p>Number of zeros trailing the binary representation of <code>x</code>.</p> <pre data-language="julia">julia&gt; trailing_zeros(2)
1
</pre> </dd>
</dl> <dl class="function"> <dt id="Base.trailing_ones">
<code>trailing_ones(x::Integer) → Integer</code> </dt> <dd>
<p>Number of ones trailing the binary representation of <code>x</code>.</p> <pre data-language="julia">julia&gt; trailing_ones(3)
2
</pre> </dd>
</dl> <dl class="function"> <dt id="Base.isodd">
<code>isodd(x::Integer) → Bool</code> </dt> <dd>
<p>Returns <code>true</code> if <code>x</code> is odd (that is, not divisible by 2), and <code>false</code> otherwise.</p> <pre data-language="julia">julia&gt; isodd(9)
true

julia&gt; isodd(10)
false
</pre> </dd>
</dl> <dl class="function"> <dt id="Base.iseven">
<code>iseven(x::Integer) → Bool</code> </dt> <dd>
<p>Returns <code>true</code> is <code>x</code> is even (that is, divisible by 2), and <code>false</code> otherwise.</p> <pre data-language="julia">julia&gt; iseven(9)
false

julia&gt; iseven(10)
true
</pre> </dd>
</dl>    <h2 id="bigfloats">BigFloats</h2> <p>The <code>BigFloat</code> type implements arbitrary-precision floating-point arithmetic using the <a class="reference external" href="http://www.mpfr.org/" target="_blank">GNU MPFR library</a>.</p> <dl class="function"> <dt id="Base.precision">
<code>precision(num::AbstractFloat)</code> </dt> <dd>
<p>Get the precision of a floating point number, as defined by the effective number of bits in the mantissa.</p> </dd>
</dl> <dl class="function"> <dt>
<code>precision(BigFloat)</code> </dt> <dd>
<p>Get the precision (in bits) currently used for <code>BigFloat</code> arithmetic.</p> </dd>
</dl> <dl class="function"> <dt id="Base.setprecision">
<code>setprecision([T=BigFloat, ]precision::Int)</code> </dt> <dd>
<p>Set the precision (in bits) to be used for <code>T</code> arithmetic.</p> </dd>
</dl> <dl class="function"> <dt>
<code>setprecision(f::Function, [T=BigFloat, ]precision::Integer)</code> </dt> <dd>
<p>Change the <code>T</code> arithmetic precision (in bits) for the duration of <code>f</code>. It is logically equivalent to:</p> <pre data-language="julia">old = precision(BigFloat)
setprecision(BigFloat, precision)
f()
setprecision(BigFloat, old)
</pre> <p>Often used as <code>setprecision(T, precision) do ... end</code></p> </dd>
</dl>   <h2 id="id1">Random Numbers</h2> <p id="random-numbers">Random number generation in Julia uses the <a class="reference external" href="http://www.math.sci.hiroshima-u.ac.jp/~m-mat/MT/SFMT/#dSFMT" target="_blank">Mersenne Twister library</a> via <code>MersenneTwister</code> objects. Julia has a global RNG, which is used by default. Other RNG types can be plugged in by inheriting the <code>AbstractRNG</code> type; they can then be used to have multiple streams of random numbers. Besides <code>MersenneTwister</code>, Julia also provides the <code>RandomDevice</code> RNG type, which is a wrapper over the OS provided entropy.</p> <p>Most functions related to random generation accept an optional <code>AbstractRNG</code> as the first argument, <code>rng</code> , which defaults to the global one if not provided. Morever, some of them accept optionally dimension specifications <code>dims...</code> (which can be given as a tuple) to generate arrays of random values.</p> <p>A <code>MersenneTwister</code> or <code>RandomDevice</code> RNG can generate random numbers of the following types: <code>Float16</code>, <code>Float32</code>, <code>Float64</code>, <code>Bool</code>, <code>Int8</code>, <code>UInt8</code>, <code>Int16</code>, <code>UInt16</code>, <code>Int32</code>, <code>UInt32</code>, <code>Int64</code>, <code>UInt64</code>, <code>Int128</code>, <code>UInt128</code>, <code>BigInt</code> (or complex numbers of those types). Random floating point numbers are generated uniformly in <span class="math">\([0, 1)\)</span>. As <code>BigInt</code> represents unbounded integers, the interval must be specified (e.g. <code>rand(big(1:6))</code>).</p> <dl class="function"> <dt id="Base.srand">
<code>srand([rng][, seed])</code> </dt> <dd>
<p>Reseed the random number generator. If a <code>seed</code> is provided, the RNG will give a reproducible sequence of numbers, otherwise Julia will get entropy from the system. For <code>MersenneTwister</code>, the <code>seed</code> may be a non-negative integer, a vector of <code>UInt32</code> integers or a filename, in which case the seed is read from a file. <code>RandomDevice</code> does not support seeding.</p> </dd>
</dl> <dl class="function"> <dt id="Base.MersenneTwister">
<code>MersenneTwister([seed])</code> </dt> <dd>
<p>Create a <code>MersenneTwister</code> RNG object. Different RNG objects can have their own seeds, which may be useful for generating different streams of random numbers.</p> </dd>
</dl> <dl class="function"> <dt id="Base.RandomDevice">
<code>RandomDevice()</code> </dt> <dd>
<p>Create a <code>RandomDevice</code> RNG object. Two such objects will always generate different streams of random numbers.</p> </dd>
</dl> <dl class="function"> <dt id="Base.rand">
<code>rand([rng][, S][, dims...])</code> </dt> <dd>
<p>Pick a random element or array of random elements from the set of values specified by <code>S</code>; <code>S</code> can be</p> <ul class="simple"> <li>an indexable collection (for example <code>1:n</code> or <code>['x','y','z']</code>), or</li> <li>a type: the set of values to pick from is then equivalent to <code>typemin(S):typemax(S)</code> for integers (this is not applicable to <code>BigInt</code>), and to <span class="math">\([0, 1)\)</span> for floating point numbers;</li> </ul> <p><code>S</code> defaults to <code>Float64</code>.</p> </dd>
</dl> <dl class="function"> <dt id="Base.rand!">
<code>rand!([rng, ]A[, coll])</code> </dt> <dd>
<p>Populate the array <code>A</code> with random values. If the indexable collection <code>coll</code> is specified, the values are picked randomly from <code>coll</code>. This is equivalent to <code>copy!(A, rand(rng, coll, size(A)))</code> or <code>copy!(A, rand(rng, eltype(A), size(A)))</code> but without allocating a new array.</p> </dd>
</dl> <dl class="function"> <dt id="Base.bitrand">
<code>bitrand([rng][, dims...])</code> </dt> <dd>
<p>Generate a <code>BitArray</code> of random boolean values.</p> </dd>
</dl> <dl class="function"> <dt id="Base.randn">
<code>randn([rng][, T=Float64][, dims...])</code> </dt> <dd>
<p>Generate a normally-distributed random number of type <code>T</code> with mean 0 and standard deviation 1. Optionally generate an array of normally-distributed random numbers. The <code>Base</code> module currently provides an implementation for the types <code>Float16</code>, <code>Float32</code>, and <code>Float64</code> (the default).</p> </dd>
</dl> <dl class="function"> <dt id="Base.randn!">
<code>randn!([rng, ]A::AbstractArray) → A</code> </dt> <dd>
<p>Fill the array <code>A</code> with normally-distributed (mean 0, standard deviation 1) random numbers. Also see the <code>rand</code> function.</p> </dd>
</dl> <dl class="function"> <dt id="Base.randexp">
<code>randexp([rng][, T=Float64][, dims...])</code> </dt> <dd>
<p>Generate a random number of type <code>T</code> according to the exponential distribution with scale 1. Optionally generate an array of such random numbers. The <code>Base</code> module currently provides an implementation for the types <code>Float16</code>, <code>Float32</code>, and <code>Float64</code> (the default).</p> </dd>
</dl> <dl class="function"> <dt id="Base.randexp!">
<code>randexp!([rng, ]A::AbstractArray) → A</code> </dt> <dd>
<p>Fill the array <code>A</code> with random numbers following the exponential distribution (with scale 1).</p> </dd>
</dl> <dl class="function"> <dt id="Base.randjump">
<code>randjump(r::MersenneTwister, jumps[, jumppoly]) → Vector{MersenneTwister}</code> </dt> <dd>
<p>Create an array of the size <code>jumps</code> of initialized <code>MersenneTwister</code> RNG objects where the first RNG object given as a parameter and following <code>MersenneTwister</code> RNGs in the array initialized such that a state of the RNG object in the array would be moved forward (without generating numbers) from a previous RNG object array element on a particular number of steps encoded by the jump polynomial <code>jumppoly</code>.</p> <p>Default jump polynomial moves forward <code>MersenneTwister</code> RNG state by 10^20 steps.</p> </dd>
</dl>
<div class="_attribution">
  <p class="_attribution-p">
    © 2009–2016 Jeff Bezanson, Stefan Karpinski, Viral B. Shah, and other contributors<br>Licensed under the MIT License.<br>
    <a href="http://docs.julialang.org/en/release-0.5/stdlib/numbers/" class="_attribution-link" target="_blank">http://docs.julialang.org/en/release-0.5/stdlib/numbers/</a>
  </p>
</div>

			</div>
		</div>
	</section>

	</div>
</body>
</html>
