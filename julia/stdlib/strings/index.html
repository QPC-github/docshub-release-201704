
<!DOCTYPE HTML>

<html lang="en">

<head>
  <meta charset="utf-8">
  <title>Strings - Julia - W3cubDocs</title>
  
  <meta name="description" content=" The number of characters in string s. ">
  <meta name="keywords" content="strings, -, julia">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="http://docs.w3cub.com/julia/stdlib/strings/">
  <link href="/favicon.png" rel="icon">
  <link type="text/css" rel="stylesheet" href="/assets/application-50364fff564ce3b6327021805f3f00e2957b441cf27f576a7dd4ff63bbc47047.css">
  <script type="text/javascript" src="/assets/application-db64bfd54ceb42be11af7995804cf4902548419ceb79d509b0b7d62c22d98e6f.js"></script>
  <script src="/json/julia.js"></script>
  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-71174418-1']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>


</head>

<body>
	<div class="_app">
	<header class="_header">
  
  <form class="_search">
    <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
    <a class="_search-clear"></a>
    <div class="_search-tag"></div>
  </form>
  
  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/julia/" class="_nav-link" title="" style="margin-left:0;">Julia</a></span>
  
  <nav class="_nav">
    <a href="/app/" class="_nav-link ">App</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		<div class="_list">
			
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<div class="_page _sphinx_simple">
				
<h1>Strings</h1> <dl class="function"> <dt id="Base.length">
<code>length(s)</code> </dt> <dd>
<p>The number of characters in string <code>s</code>.</p> </dd>
</dl> <dl class="function"> <dt id="Base.sizeof">
<code>sizeof(s::AbstractString)</code> </dt> <dd>
<p>The number of bytes in string <code>s</code>.</p> </dd>
</dl> <dl class="function"> <dt id="Base.*">
<code>*(s, t)</code> </dt> <dd>
<p>Concatenate strings. The <code>*</code> operator is an alias to this function.</p> <pre data-language="julia">julia&gt; "Hello " * "world"
"Hello world"
</pre> </dd>
</dl> <dl class="function"> <dt id="Base.^">
<code>^(s, n)</code> </dt> <dd>
<p>Repeat <code>n</code> times the string <code>s</code>. The <code>repeat</code> function is an alias to this operator.</p> <pre data-language="julia">julia&gt; "Test "^3
"Test Test Test "
</pre> </dd>
</dl> <dl class="function"> <dt id="Base.string">
<code>string(xs...)</code> </dt> <dd>
<p>Create a string from any values using the <code>print</code> function.</p> </dd>
</dl> <dl class="function"> <dt id="Base.repr">
<code>repr(x)</code> </dt> <dd>
<p>Create a string from any value using the <code>showall</code> function.</p> </dd>
</dl> <dl class="function"> <dt id="Base.String">
<code>String(s::AbstractString)</code> </dt> <dd>
<p>Convert a string to a contiguous byte array representation encoded as UTF-8 bytes. This representation is often appropriate for passing strings to C.</p> </dd>
</dl> <dl class="function"> <dt id="Base.transcode">
<code>transcode(T, src)</code> </dt> <dd>
<p>Convert string data between Unicode encodings. <code>src</code> is either a <code>String</code> or a <code>Vector{UIntXX}</code> of UTF-XX code units, where <code>XX</code> is 8, 16, or 32. <code>T</code> indicates the encoding of the return value: <code>String</code> to return a (UTF-8 encoded) <code>String</code> or <code>UIntXX</code> to return a <code>Vector{UIntXX}</code> of UTF-<code>XX</code> data. (The alias <code>Cwchar_t</code> can also be used as the integer type, for converting <code>wchar_t*</code> strings used by external C libraries.)</p> <p>The <code>transcode</code> function succeeds as long as the input data can be reasonably represented in the target encoding; it always succeeds for conversions between UTF-XX encodings, even for invalid Unicode data.</p> <p>Only conversion to/from UTF-8 is currently supported.</p> </dd>
</dl> <dl class="function"> <dt id="Base.unsafe_string">
<code>unsafe_string(p::Ptr{UInt8}[, length::Integer])</code> </dt> <dd>
<p>Copy a string from the address of a C-style (NUL-terminated) string encoded as UTF-8. (The pointer can be safely freed afterwards.) If <code>length</code> is specified (the length of the data in bytes), the string does not have to be NUL-terminated.</p> <p>This function is labelled “unsafe” because it will crash if <code>p</code> is not a valid memory address to data of the requested length.</p> <p>See also <a class="reference internal" href="#Base.unsafe_wrap" title="Base.unsafe_wrap"><code>unsafe_wrap()</code></a>, which takes a pointer and wraps a string object around it without making a copy.</p> </dd>
</dl> <dl class="function"> <dt id="Base.unsafe_wrap">
<code>unsafe_wrap(String, p::Ptr{UInt8}, [length, ]own=false)</code> </dt> <dd>
<p>Wrap a pointer <code>p</code> to an array of bytes in a <code>String</code> object, interpreting the bytes as UTF-8 encoded characters <em>without making a copy</em>. The optional <code>length</code> argument indicates the length in bytes of the pointer’s data; if it is omitted, the data is assumed to be NUL-terminated. The <code>own</code> argument optionally specifies whether Julia should take ownership of the memory, calling <code>free</code> on the pointer when the array is no longer referenced.</p> <p>This function is labelled “unsafe” because it will crash if <code>p</code> is not a valid memory address to data of the requested length.</p> <p>See also <a class="reference internal" href="#Base.unsafe_string" title="Base.unsafe_string"><code>unsafe_string()</code></a>, which takes a pointer and makes a copy of the data.</p> </dd>
</dl> <dl class="function"> <dt id="Base.ascii">
<code>ascii(s::AbstractString)</code> </dt> <dd>
<p>Convert a string to <code>String</code> type and check that it contains only ASCII data, otherwise throwing an <code>ArgumentError</code> indicating the position of the first non-ASCII byte.</p> </dd>
</dl> <dl class="function"> <dt id="Base.@r_str">
<code>@r_str() → Regex</code> </dt> <dd>
<p>Construct a regex, such as <code>r"^[a-z]*$"</code>. The regex also accepts one or more flags, listed after the ending quote, to change its behaviour:</p> <ul class="simple"> <li>
<code>i</code> enables case-insensitive matching</li> <li>
<code>m</code> treats the <code>^</code> and <code>$</code> tokens as matching the start and end of individual lines, as opposed to the whole string.</li> <li>
<code>s</code> allows the <code>.</code> modifier to match newlines.</li> <li>
<code>x</code> enables “comment mode”: whitespace is enabled except when escaped with <code>\</code>, and <code>#</code> is treated as starting a comment.</li> </ul> <p>For example, this regex has all three flags enabled:</p> <pre data-language="julia">julia&gt; match(r"a+.*b+.*?d$"ism, "Goodbye,\nOh, angry,\nBad world\n")
RegexMatch("angry,\nBad world")
</pre> </dd>
</dl> <dl class="function"> <dt id="Base.@html_str">
<code>@html_str() → Docs.HTML</code> </dt> <dd>
<p>Create an <code>HTML</code> object from a literal string.</p> </dd>
</dl> <dl class="function"> <dt id="Base.@text_str">
<code>@text_str() → Docs.Text</code> </dt> <dd>
<p>Create a <code>Text</code> object from a literal string.</p> </dd>
</dl> <dl class="function"> <dt id="Base.normalize_string">
<code>normalize_string(s, normalform::Symbol)</code> </dt> <dd>
<p>Normalize the string <code>s</code> according to one of the four “normal forms” of the Unicode standard: <code>normalform</code> can be <code>:NFC</code>, <code>:NFD</code>, <code>:NFKC</code>, or <code>:NFKD</code>. Normal forms C (canonical composition) and D (canonical decomposition) convert different visually identical representations of the same abstract string into a single canonical form, with form C being more compact. Normal forms KC and KD additionally canonicalize “compatibility equivalents”: they convert characters that are abstractly similar but visually distinct into a single canonical choice (e.g. they expand ligatures into the individual characters), with form KC being more compact.</p> <p>Alternatively, finer control and additional transformations may be be obtained by calling <code>normalize_string(s; keywords...)</code>, where any number of the following boolean keywords options (which all default to <code>false</code> except for <code>compose</code>) are specified:</p> <ul class="simple"> <li>
<code>compose=false</code>: do not perform canonical composition</li> <li>
<code>decompose=true</code>: do canonical decomposition instead of canonical composition (<code>compose=true</code> is ignored if present)</li> <li>
<code>compat=true</code>: compatibility equivalents are canonicalized</li> <li>
<code>casefold=true</code>: perform Unicode case folding, e.g. for case-insensitive string comparison</li> <li>
<code>newline2lf=true</code>, <code>newline2ls=true</code>, or <code>newline2ps=true</code>: convert various newline sequences (LF, CRLF, CR, NEL) into a linefeed (LF), line-separation (LS), or paragraph-separation (PS) character, respectively</li> <li>
<code>stripmark=true</code>: strip diacritical marks (e.g. accents)</li> <li>
<code>stripignore=true</code>: strip Unicode’s “default ignorable” characters (e.g. the soft hyphen or the left-to-right marker)</li> <li>
<code>stripcc=true</code>: strip control characters; horizontal tabs and form feeds are converted to spaces; newlines are also converted to spaces unless a newline-conversion flag was specified</li> <li>
<code>rejectna=true</code>: throw an error if unassigned code points are found</li> <li>
<code>stable=true</code>: enforce Unicode Versioning Stability</li> </ul> <p>For example, NFKC corresponds to the options <code>compose=true, compat=true, stable=true</code>.</p> </dd>
</dl> <dl class="function"> <dt id="Base.graphemes">
<code>graphemes(s) → iterator over substrings of s</code> </dt> <dd>
<p>Returns an iterator over substrings of <code>s</code> that correspond to the extended graphemes in the string, as defined by Unicode UAX #29. (Roughly, these are what users would perceive as single characters, even though they may contain more than one codepoint; for example a letter combined with an accent mark is a single grapheme.)</p> </dd>
</dl> <dl class="function"> <dt id="Base.isvalid">
<code>isvalid(value) → Bool</code> </dt> <dd>
<p>Returns <code>true</code> if the given value is valid for its type, which currently can be either <code>Char</code> or <code>String</code>.</p> </dd>
</dl> <dl class="function"> <dt>
<code>isvalid(T, value) → Bool</code> </dt> <dd>
<p>Returns <code>true</code> if the given value is valid for that type. Types currently can be either <code>Char</code> or <code>String</code>. Values for <code>Char</code> can be of type <code>Char</code> or <code>UInt32</code>. Values for <code>String</code> can be of that type, or <code>Vector{UInt8}</code>.</p> </dd>
</dl> <dl class="function"> <dt>
<code>isvalid(str, i)</code> </dt> <dd>
<p>Tells whether index <code>i</code> is valid for the given string.</p> </dd>
</dl> <dl class="function"> <dt id="Base.is_assigned_char">
<code>is_assigned_char(c) → Bool</code> </dt> <dd>
<p>Returns <code>true</code> if the given char or integer is an assigned Unicode code point.</p> </dd>
</dl> <dl class="function"> <dt id="Base.ismatch">
<code>ismatch(r::Regex, s::AbstractString) → Bool</code> </dt> <dd>
<p>Test whether a string contains a match of the given regular expression.</p> </dd>
</dl> <dl class="function"> <dt id="Base.match">
<code>match(r::Regex, s::AbstractString[, idx::Integer[, addopts]])</code> </dt> <dd>
<p>Search for the first match of the regular expression <code>r</code> in <code>s</code> and return a <code>RegexMatch</code> object containing the match, or nothing if the match failed. The matching substring can be retrieved by accessing <code>m.match</code> and the captured sequences can be retrieved by accessing <code>m.captures</code> The optional <code>idx</code> argument specifies an index at which to start the search.</p> </dd>
</dl> <dl class="function"> <dt id="Base.eachmatch">
<code>eachmatch(r::Regex, s::AbstractString[, overlap::Bool=false])</code> </dt> <dd>
<p>Search for all matches of a the regular expression <code>r</code> in <code>s</code> and return a iterator over the matches. If overlap is <code>true</code>, the matching sequences are allowed to overlap indices in the original string, otherwise they must be from distinct character ranges.</p> </dd>
</dl> <dl class="function"> <dt id="Base.matchall">
<code>matchall(r::Regex, s::AbstractString[, overlap::Bool=false]) → Vector{AbstractString}</code> </dt> <dd>
<p>Return a vector of the matching substrings from eachmatch.</p> </dd>
</dl> <dl class="function"> <dt id="Base.lpad">
<code>lpad(string, n, p)</code> </dt> <dd>
<p>Make a string at least <code>n</code> columns wide when printed, by padding on the left with copies of <code>p</code>.</p> </dd>
</dl> <dl class="function"> <dt id="Base.rpad">
<code>rpad(string, n, p)</code> </dt> <dd>
<p>Make a string at least <code>n</code> columns wide when printed, by padding on the right with copies of <code>p</code>.</p> </dd>
</dl> <dl class="function"> <dt id="Base.search">
<code>search(string, chars[, start])</code> </dt> <dd>
<p>Search for the first occurrence of the given characters within the given string. The second argument may be a single character, a vector or a set of characters, a string, or a regular expression (though regular expressions are only allowed on contiguous strings, such as ASCII or UTF-8 strings). The third argument optionally specifies a starting index. The return value is a range of indexes where the matching sequence is found, such that <code>s[search(s,x)] == x</code>:</p> <p><code>search(string, "substring")</code> = <code>start:end</code> such that <code>string[start:end] == "substring"</code>, or <code>0:-1</code> if unmatched.</p> <p><code>search(string, 'c')</code> = <code>index</code> such that <code>string[index] == 'c'</code>, or <code>0</code> if unmatched.</p> </dd>
</dl> <dl class="function"> <dt id="Base.rsearch">
<code>rsearch(string, chars[, start])</code> </dt> <dd>
<p>Similar to <code>search</code>, but returning the last occurrence of the given characters within the given string, searching in reverse from <code>start</code>.</p> </dd>
</dl> <dl class="function"> <dt id="Base.searchindex">
<code>searchindex(string, substring[, start])</code> </dt> <dd>
<p>Similar to <code>search</code>, but return only the start index at which the substring is found, or <code>0</code> if it is not.</p> </dd>
</dl> <dl class="function"> <dt id="Base.rsearchindex">
<code>rsearchindex(string, substring[, start])</code> </dt> <dd>
<p>Similar to <code>rsearch</code>, but return only the start index at which the substring is found, or <code>0</code> if it is not.</p> </dd>
</dl> <dl class="function"> <dt id="Base.contains">
<code>contains(haystack, needle)</code> </dt> <dd>
<p>Determine whether the second argument is a substring of the first.</p> </dd>
</dl> <dl class="function"> <dt id="Base.reverse">
<code>reverse(s::AbstractString) → AbstractString</code> </dt> <dd>
<p>Reverses a string.</p> </dd>
</dl> <dl class="function"> <dt id="Base.replace">
<code>replace(string, pat, r[, n])</code> </dt> <dd>
<p>Search for the given pattern <code>pat</code>, and replace each occurrence with <code>r</code>. If <code>n</code> is provided, replace at most <code>n</code> occurrences. As with search, the second argument may be a single character, a vector or a set of characters, a string, or a regular expression. If <code>r</code> is a function, each occurrence is replaced with <code>r(s)</code> where <code>s</code> is the matched substring. If <code>pat</code> is a regular expression and <code>r</code> is a <code>SubstitutionString</code>, then capture group references in <code>r</code> are replaced with the corresponding matched text.</p> </dd>
</dl> <dl class="function"> <dt id="Base.split">
<code>split(string, [chars]; limit=0, keep=true)</code> </dt> <dd>
<p>Return an array of substrings by splitting the given string on occurrences of the given character delimiters, which may be specified in any of the formats allowed by <code>search</code>‘s second argument (i.e. a single character, collection of characters, string, or regular expression). If <code>chars</code> is omitted, it defaults to the set of all space characters, and <code>keep</code> is taken to be <code>false</code>. The two keyword arguments are optional: they are a maximum size for the result and a flag determining whether empty fields should be kept in the result.</p> </dd>
</dl> <dl class="function"> <dt id="Base.rsplit">
<code>rsplit(string, [chars]; limit=0, keep=true)</code> </dt> <dd>
<p>Similar to <code>split</code>, but starting from the end of the string.</p> </dd>
</dl> <dl class="function"> <dt id="Base.strip">
<code>strip(string[, chars])</code> </dt> <dd>
<p>Return <code>string</code> with any leading and trailing whitespace removed. If <code>chars</code> (a character, or vector or set of characters) is provided, instead remove characters contained in it.</p> </dd>
</dl> <dl class="function"> <dt id="Base.lstrip">
<code>lstrip(string[, chars])</code> </dt> <dd>
<p>Return <code>string</code> with any leading whitespace removed. If <code>chars</code> (a character, or vector or set of characters) is provided, instead remove characters contained in it.</p> </dd>
</dl> <dl class="function"> <dt id="Base.rstrip">
<code>rstrip(string[, chars])</code> </dt> <dd>
<p>Return <code>string</code> with any trailing whitespace removed. If <code>chars</code> (a character, or vector or set of characters) is provided, instead remove characters contained in it.</p> </dd>
</dl> <dl class="function"> <dt id="Base.startswith">
<code>startswith(string, prefix)</code> </dt> <dd>
<p>Returns <code>true</code> if <code>string</code> starts with <code>prefix</code>. If <code>prefix</code> is a vector or set of characters, tests whether the first character of <code>string</code> belongs to that set.</p> </dd>
</dl> <dl class="function"> <dt id="Base.endswith">
<code>endswith(string, suffix)</code> </dt> <dd>
<p>Returns <code>true</code> if <code>string</code> ends with <code>suffix</code>. If <code>suffix</code> is a vector or set of characters, tests whether the last character of <code>string</code> belongs to that set.</p> </dd>
</dl> <dl class="function"> <dt id="Base.uppercase">
<code>uppercase(string)</code> </dt> <dd>
<p>Returns <code>string</code> with all characters converted to uppercase.</p> </dd>
</dl> <dl class="function"> <dt id="Base.lowercase">
<code>lowercase(string)</code> </dt> <dd>
<p>Returns <code>string</code> with all characters converted to lowercase.</p> </dd>
</dl> <dl class="function"> <dt id="Base.ucfirst">
<code>ucfirst(string)</code> </dt> <dd>
<p>Returns <code>string</code> with the first character converted to uppercase.</p> </dd>
</dl> <dl class="function"> <dt id="Base.lcfirst">
<code>lcfirst(string)</code> </dt> <dd>
<p>Returns <code>string</code> with the first character converted to lowercase.</p> </dd>
</dl> <dl class="function"> <dt id="Base.join">
<code>join(strings, delim[, last])</code> </dt> <dd>
<p>Join an array of <code>strings</code> into a single string, inserting the given delimiter between adjacent strings. If <code>last</code> is given, it will be used instead of <code>delim</code> between the last two strings. For example</p> <pre data-language="julia">join(["apples", "bananas", "pineapples"], ", ", " and ") == "apples, bananas and pineapples"
</pre> <p><code>strings</code> can be any iterable over elements <code>x</code> which are convertible to strings via <code>print(io::IOBuffer, x)</code>.</p> </dd>
</dl> <dl class="function"> <dt id="Base.chop">
<code>chop(string)</code> </dt> <dd>
<p>Remove the last character from a string.</p> </dd>
</dl> <dl class="function"> <dt id="Base.chomp">
<code>chomp(string)</code> </dt> <dd>
<p>Remove a single trailing newline from a string.</p> </dd>
</dl> <dl class="function"> <dt id="Base.ind2chr">
<code>ind2chr(string, i)</code> </dt> <dd>
<p>Convert a byte index to a character index.</p> </dd>
</dl> <dl class="function"> <dt id="Base.chr2ind">
<code>chr2ind(string, i)</code> </dt> <dd>
<p>Convert a character index to a byte index.</p> </dd>
</dl> <dl class="function"> <dt id="Base.nextind">
<code>nextind(str, i)</code> </dt> <dd>
<p>Get the next valid string index after <code>i</code>. Returns a value greater than <code>endof(str)</code> at or after the end of the string.</p> </dd>
</dl> <dl class="function"> <dt id="Base.prevind">
<code>prevind(str, i)</code> </dt> <dd>
<p>Get the previous valid string index before <code>i</code>. Returns a value less than <code>1</code> at the beginning of the string.</p> </dd>
</dl> <dl class="function"> <dt id="Base.randstring">
<code>randstring([rng, ]len=8)</code> </dt> <dd>
<p>Create a random ASCII string of length <code>len</code>, consisting of upper- and lower-case letters and the digits 0-9. The optional <code>rng</code> argument specifies a random number generator, see <a class="reference internal" href="../numbers/#random-numbers"><span>Random Numbers</span></a>.</p> </dd>
</dl> <dl class="function"> <dt id="Base.charwidth">
<code>charwidth(c)</code> </dt> <dd>
<p>Gives the number of columns needed to print a character.</p> </dd>
</dl> <dl class="function"> <dt id="Base.strwidth">
<code>strwidth(s)</code> </dt> <dd>
<p>Gives the number of columns needed to print a string.</p> </dd>
</dl> <dl class="function"> <dt id="Base.isalnum">
<code>isalnum(c::Union{Char, AbstractString}) → Bool</code> </dt> <dd>
<p>Tests whether a character is alphanumeric, or whether this is true for all elements of a string. A character is classified as alphabetic if it belongs to the Unicode general category Letter or Number, i.e. a character whose category code begins with ‘L’ or ‘N’.</p> </dd>
</dl> <dl class="function"> <dt id="Base.isalpha">
<code>isalpha(c::Union{Char, AbstractString}) → Bool</code> </dt> <dd>
<p>Tests whether a character is alphabetic, or whether this is true for all elements of a string. A character is classified as alphabetic if it belongs to the Unicode general category Letter, i.e. a character whose category code begins with ‘L’.</p> </dd>
</dl> <dl class="function"> <dt id="Base.isascii">
<code>isascii(c::Union{Char, AbstractString}) → Bool</code> </dt> <dd>
<p>Tests whether a character belongs to the ASCII character set, or whether this is true for all elements of a string.</p> </dd>
</dl> <dl class="function"> <dt id="Base.iscntrl">
<code>iscntrl(c::Union{Char, AbstractString}) → Bool</code> </dt> <dd>
<p>Tests whether a character is a control character, or whether this is true for all elements of a string. Control characters are the non-printing characters of the Latin-1 subset of Unicode.</p> </dd>
</dl> <dl class="function"> <dt id="Base.isdigit">
<code>isdigit(c::Union{Char, AbstractString}) → Bool</code> </dt> <dd>
<p>Tests whether a character is a numeric digit (0-9), or whether this is true for all elements of a string.</p> </dd>
</dl> <dl class="function"> <dt id="Base.isgraph">
<code>isgraph(c::Union{Char, AbstractString}) → Bool</code> </dt> <dd>
<p>Tests whether a character is printable, and not a space, or whether this is true for all elements of a string. Any character that would cause a printer to use ink should be classified with <code>isgraph(c)==true</code>.</p> </dd>
</dl> <dl class="function"> <dt id="Base.islower">
<code>islower(c::Union{Char, AbstractString}) → Bool</code> </dt> <dd>
<p>Tests whether a character is a lowercase letter, or whether this is true for all elements of a string. A character is classified as lowercase if it belongs to Unicode category Ll, Letter: Lowercase.</p> </dd>
</dl> <dl class="function"> <dt id="Base.isnumber">
<code>isnumber(c::Union{Char, AbstractString}) → Bool</code> </dt> <dd>
<p>Tests whether a character is numeric, or whether this is true for all elements of a string. A character is classified as numeric if it belongs to the Unicode general category Number, i.e. a character whose category code begins with ‘N’.</p> </dd>
</dl> <dl class="function"> <dt id="Base.isprint">
<code>isprint(c::Union{Char, AbstractString}) → Bool</code> </dt> <dd>
<p>Tests whether a character is printable, including spaces, but not a control character. For strings, tests whether this is true for all elements of the string.</p> </dd>
</dl> <dl class="function"> <dt id="Base.ispunct">
<code>ispunct(c::Union{Char, AbstractString}) → Bool</code> </dt> <dd>
<p>Tests whether a character belongs to the Unicode general category Punctuation, i.e. a character whose category code begins with ‘P’. For strings, tests whether this is true for all elements of the string.</p> </dd>
</dl> <dl class="function"> <dt id="Base.isspace">
<code>isspace(c::Union{Char, AbstractString}) → Bool</code> </dt> <dd>
<p>Tests whether a character is any whitespace character. Includes ASCII characters ‘\t’, ‘\n’, ‘\v’, ‘\f’, ‘\r’, and ‘ ‘, Latin-1 character U+0085, and characters in Unicode category Zs. For strings, tests whether this is true for all elements of the string.</p> </dd>
</dl> <dl class="function"> <dt id="Base.isupper">
<code>isupper(c::Union{Char, AbstractString}) → Bool</code> </dt> <dd>
<p>Tests whether a character is an uppercase letter, or whether this is true for all elements of a string. A character is classified as uppercase if it belongs to Unicode category Lu, Letter: Uppercase, or Lt, Letter: Titlecase.</p> </dd>
</dl> <dl class="function"> <dt id="Base.isxdigit">
<code>isxdigit(c::Union{Char, AbstractString}) → Bool</code> </dt> <dd>
<p>Tests whether a character is a valid hexadecimal digit, or whether this is true for all elements of a string.</p> </dd>
</dl> <dl class="function"> <dt id="Base.Symbol">
<code>Symbol(x...) → Symbol</code> </dt> <dd>
<p>Create a <code>Symbol</code> by concatenating the string representations of the arguments together.</p> </dd>
</dl> <dl class="function"> <dt id="Base.escape_string">
<code>escape_string(str::AbstractString) → AbstractString</code> </dt> <dd>
<p>General escaping of traditional C and Unicode escape sequences.</p> </dd>
</dl> <dl class="function"> <dt id="Base.unescape_string">
<code>unescape_string(s::AbstractString) → AbstractString</code> </dt> <dd>
<p>General unescaping of traditional C and Unicode escape sequences. Reverse of <a class="reference internal" href="#Base.escape_string" title="Base.escape_string"><code>escape_string()</code></a>. See also <a class="reference internal" href="#Base.unescape_string" title="Base.unescape_string"><code>unescape_string()</code></a>.</p> </dd>
</dl>
<div class="_attribution">
  <p class="_attribution-p">
    © 2009–2016 Jeff Bezanson, Stefan Karpinski, Viral B. Shah, and other contributors<br>Licensed under the MIT License.<br>
    <a href="http://docs.julialang.org/en/release-0.5/stdlib/strings/" class="_attribution-link" target="_blank">http://docs.julialang.org/en/release-0.5/stdlib/strings/</a>
  </p>
</div>

			</div>
		</div>
	</section>

	</div>
</body>
</html>
