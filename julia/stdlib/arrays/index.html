
<!DOCTYPE HTML>

<html lang="en">

<head>
  <meta charset="utf-8">
  <title>Arrays - Julia - W3cubDocs</title>
  
  <meta name="description" content=" Returns the number of dimensions of A. ">
  <meta name="keywords" content="arrays, -, julia">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="http://docs.w3cub.com/julia/stdlib/arrays/">
  <link href="/favicon.png" rel="icon">
  <link type="text/css" rel="stylesheet" href="/assets/application-50364fff564ce3b6327021805f3f00e2957b441cf27f576a7dd4ff63bbc47047.css">
  <script type="text/javascript" src="/assets/application-db64bfd54ceb42be11af7995804cf4902548419ceb79d509b0b7d62c22d98e6f.js"></script>
  <script src="/json/julia.js"></script>
  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-71174418-1']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>


</head>

<body>
	<div class="_app">
	<header class="_header">
  
  <form class="_search">
    <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
    <a class="_search-clear"></a>
    <div class="_search-tag"></div>
  </form>
  
  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/julia/" class="_nav-link" title="" style="margin-left:0;">Julia</a></span>
  
  <nav class="_nav">
    <a href="/app/" class="_nav-link ">App</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		<div class="_list">
			
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<div class="_page _sphinx_simple">
				
<h1 id="stdlib-arrays">Arrays</h1>  <h2 id="basic-functions">Basic functions</h2> <dl class="function"> <dt id="Base.ndims">
<code>ndims(A::AbstractArray) → Integer</code> </dt> <dd>
<p>Returns the number of dimensions of <code>A</code>.</p> <pre data-language="julia">julia&gt; A = ones(3,4,5);

julia&gt; ndims(A)
3
</pre> </dd>
</dl> <dl class="function"> <dt id="Base.size">
<code>size(A::AbstractArray[, dim...])</code> </dt> <dd>
<p>Returns a tuple containing the dimensions of <code>A</code>. Optionally you can specify the dimension(s) you want the length of, and get the length of that dimension, or a tuple of the lengths of dimensions you asked for.</p> <pre data-language="julia">julia&gt; A = ones(2,3,4);

julia&gt; size(A, 2)
3

julia&gt; size(A,3,2)
(4,3)
</pre> </dd>
</dl> <dl class="function"> <dt id="Base.indices">
<code>indices(A)</code> </dt> <dd>
<p>Returns the tuple of valid indices for array <code>A</code>.</p> </dd>
</dl> <dl class="function"> <dt>
<code>indices(A, d)</code> </dt> <dd>
<p>Returns the valid range of indices for array <code>A</code> along dimension <code>d</code>.</p> </dd>
</dl> <dl class="function"> <dt id="Base.length">
<code>length(A::AbstractArray) → Integer</code> </dt> <dd>
<p>Returns the number of elements in <code>A</code>.</p> <pre data-language="julia">julia&gt; A = ones(3,4,5);

julia&gt; length(A)
60
</pre> </dd>
</dl> <dl class="function"> <dt id="Base.eachindex">
<code>eachindex(A...)</code> </dt> <dd>
<p>Creates an iterable object for visiting each index of an AbstractArray <code>A</code> in an efficient manner. For array types that have opted into fast linear indexing (like <code>Array</code>), this is simply the range <code>1:length(A)</code>. For other array types, this returns a specialized Cartesian range to efficiently index into the array with indices specified for every dimension. For other iterables, including strings and dictionaries, this returns an iterator object supporting arbitrary index types (e.g. unevenly spaced or non-integer indices).</p> <p>Example for a sparse 2-d array:</p> <pre data-language="julia">julia&gt; A = sparse([1, 1, 2], [1, 3, 1], [1, 2, -5])
2×3 sparse matrix with 3 Int64 nonzero entries:
        [1, 1]  =  1
        [2, 1]  =  -5
        [1, 3]  =  2

julia&gt; for iter in eachindex(A)
           @show iter.I[1], iter.I[2]
           @show A[iter]
       end
(iter.I[1],iter.I[2]) = (1,1)
A[iter] = 1
(iter.I[1],iter.I[2]) = (2,1)
A[iter] = -5
(iter.I[1],iter.I[2]) = (1,2)
A[iter] = 0
(iter.I[1],iter.I[2]) = (2,2)
A[iter] = 0
(iter.I[1],iter.I[2]) = (1,3)
A[iter] = 2
(iter.I[1],iter.I[2]) = (2,3)
A[iter] = 0
</pre> <p>If you supply more than one <code>AbstractArray</code> argument, <code>eachindex</code> will create an iterable object that is fast for all arguments (a <code>UnitRange</code> if all inputs have fast linear indexing, a CartesianRange otherwise). If the arrays have different sizes and/or dimensionalities, <code>eachindex</code> returns an iterable that spans the largest range along each dimension.</p> </dd>
</dl> <dl class="function"> <dt id="Base.linearindices">
<code>linearindices(A)</code> </dt> <dd>
<p>Returns a <code>UnitRange</code> specifying the valid range of indices for <code>A[i]</code> where <code>i</code> is an <code>Int</code>. For arrays with conventional indexing (indices start at 1), or any multidimensional array, this is <code>1:length(A)</code>; however, for one-dimensional arrays with unconventional indices, this is <code>indices(A, 1)</code>.</p> <p>Calling this function is the “safe” way to write algorithms that exploit linear indexing.</p> </dd>
</dl> <dl class="function"> <dt id="Base.Base.linearindexing">
<code>Base.linearindexing(A)</code> </dt> <dd>
<p><code>linearindexing</code> defines how an AbstractArray most efficiently accesses its elements. If <code>Base.linearindexing(A)</code> returns <code>Base.LinearFast()</code>, this means that linear indexing with only one index is an efficient operation. If it instead returns <code>Base.LinearSlow()</code> (by default), this means that the array intrinsically accesses its elements with indices specified for every dimension. Since converting a linear index to multiple indexing subscripts is typically very expensive, this provides a traits-based mechanism to enable efficient generic code for all array types.</p> <p>An abstract array subtype <code>MyArray</code> that wishes to opt into fast linear indexing behaviors should define <code>linearindexing</code> in the type-domain:</p> <pre data-language="julia">Base.linearindexing{T&lt;:MyArray}(::Type{T}) = Base.LinearFast()
</pre> </dd>
</dl> <dl class="function"> <dt id="Base.countnz">
<code>countnz(A)</code> </dt> <dd>
<p>Counts the number of nonzero values in array <code>A</code> (dense or sparse). Note that this is not a constant-time operation. For sparse matrices, one should usually use <code>nnz</code>, which returns the number of stored values.</p> </dd>
</dl> <dl class="function"> <dt id="Base.conj!">
<code>conj!(A)</code> </dt> <dd>
<p>Convert an array to its complex conjugate in-place.</p> </dd>
</dl> <dl class="function"> <dt id="Base.stride">
<code>stride(A, k::Integer)</code> </dt> <dd>
<p>Returns the distance in memory (in number of elements) between adjacent elements in dimension <code>k</code>.</p> <pre data-language="julia">julia&gt; A = ones(3,4,5);

julia&gt; stride(A,2)
3

julia&gt; stride(A,3)
12
</pre> </dd>
</dl> <dl class="function"> <dt id="Base.strides">
<code>strides(A)</code> </dt> <dd>
<p>Returns a tuple of the memory strides in each dimension.</p> <pre data-language="julia">julia&gt; A = ones(3,4,5);

julia&gt; strides(A)
(1,3,12)
</pre> </dd>
</dl> <dl class="function"> <dt id="Base.ind2sub">
<code>ind2sub(dims, index) → subscripts</code> </dt> <dd>
<p>Returns a tuple of subscripts into an array with dimensions <code>dims</code>, corresponding to the linear index <code>index</code>.</p> <p><strong>Example</strong>:</p> <pre data-language="julia">i, j, ... = ind2sub(size(A), indmax(A))
</pre> <p>provides the indices of the maximum element.</p> </dd>
</dl> <dl class="function"> <dt>
<code>ind2sub(a, index) → subscripts</code> </dt> <dd>
<p>Returns a tuple of subscripts into array <code>a</code> corresponding to the linear index <code>index</code>.</p> </dd>
</dl> <dl class="function"> <dt id="Base.sub2ind">
<code>sub2ind(dims, i, j, k...) → index</code> </dt> <dd>
<p>The inverse of <code>ind2sub</code>, returns the linear index corresponding to the provided subscripts.</p> </dd>
</dl> <dl class="function"> <dt id="Base.LinAlg.checksquare">
<code>LinAlg.checksquare(A)</code> </dt> <dd>
<p>Check that a matrix is square, then return its common dimension. For multiple arguments, return a vector.</p> </dd>
</dl>   <h2 id="constructors">Constructors</h2> <dl class="function"> <dt id="Base.Array">
<code>Array(dims)</code> </dt> <dd>
<p><code>Array{T}(dims)</code> constructs an uninitialized dense array with element type <code>T</code>. <code>dims</code> may be a tuple or a series of integer arguments. The syntax <code>Array(T, dims)</code> is also available, but deprecated.</p> </dd>
</dl> <dl class="function"> <dt id="Base.getindex">
<code>getindex(type[, elements...])</code> </dt> <dd>
<p>Construct a 1-d array of the specified type. This is usually called with the syntax <code>Type[]</code>. Element values can be specified using <code>Type[a,b,c,...]</code>.</p> </dd>
</dl> <dl class="function"> <dt id="Base.zeros">
<code>zeros(type, dims)</code> </dt> <dd>
<p>Create an array of all zeros of specified type. The type defaults to Float64 if not specified.</p> </dd>
</dl> <dl class="function"> <dt>
<code>zeros(A)</code> </dt> <dd>
<p>Create an array of all zeros with the same element type and shape as <code>A</code>.</p> </dd>
</dl> <dl class="function"> <dt id="Base.ones">
<code>ones(type, dims)</code> </dt> <dd>
<p>Create an array of all ones of specified type. The type defaults to <code>Float64</code> if not specified.</p> </dd>
</dl> <dl class="function"> <dt>
<code>ones(A)</code> </dt> <dd>
<p>Create an array of all ones with the same element type and shape as <code>A</code>.</p> </dd>
</dl> <dl class="function"> <dt id="Base.trues">
<code>trues(dims)</code> </dt> <dd>
<p>Create a <code>BitArray</code> with all values set to <code>true</code>.</p> </dd>
</dl> <dl class="function"> <dt>
<code>trues(A)</code> </dt> <dd>
<p>Create a <code>BitArray</code> with all values set to <code>true</code> of the same shape as <code>A</code>.</p> </dd>
</dl> <dl class="function"> <dt id="Base.falses">
<code>falses(dims)</code> </dt> <dd>
<p>Create a <code>BitArray</code> with all values set to <code>false</code>.</p> </dd>
</dl> <dl class="function"> <dt>
<code>falses(A)</code> </dt> <dd>
<p>Create a <code>BitArray</code> with all values set to <code>false</code> of the same shape as <code>A</code>.</p> </dd>
</dl> <dl class="function"> <dt id="Base.fill">
<code>fill(x, dims)</code> </dt> <dd>
<p>Create an array filled with the value <code>x</code>. For example, <code>fill(1.0, (10,10))</code> returns a 10×10 array of floats, with each element initialized to <code>1.0</code>.</p> <p>If <code>x</code> is an object reference, all elements will refer to the same object. <code>fill(Foo(), dims)</code> will return an array filled with the result of evaluating <code>Foo()</code> once.</p> </dd>
</dl> <dl class="function"> <dt id="Base.fill!">
<code>fill!(A, x)</code> </dt> <dd>
<p>Fill array <code>A</code> with the value <code>x</code>. If <code>x</code> is an object reference, all elements will refer to the same object. <code>fill!(A, Foo())</code> will return <code>A</code> filled with the result of evaluating <code>Foo()</code> once.</p> </dd>
</dl> <dl class="function"> <dt id="Base.reshape">
<code>reshape(A, dims)</code> </dt> <dd>
<p>Create an array with the same data as the given array, but with different dimensions.</p> </dd>
</dl> <dl class="function"> <dt id="Base.similar">
<code>similar(array[, element_type=eltype(array)][, dims=size(array)])</code> </dt> <dd>
<p>Create an uninitialized mutable array with the given element type and size, based upon the given source array. The second and third arguments are both optional, defaulting to the given array’s <code>eltype</code> and <code>size</code>. The dimensions may be specified either as a single tuple argument or as a series of integer arguments.</p> <p>Custom AbstractArray subtypes may choose which specific array type is best-suited to return for the given element type and dimensionality. If they do not specialize this method, the default is an <code>Array{element_type}(dims...)</code>.</p> <p>For example, <code>similar(1:10, 1, 4)</code> returns an uninitialized <code>Array{Int,2}</code> since ranges are neither mutable nor support 2 dimensions:</p> <pre data-language="julia">julia&gt; similar(1:10, 1, 4)
1×4 Array{Int64,2}:
 4419743872  4374413872  4419743888  0
</pre> <p>Conversely, <code>similar(trues(10,10), 2)</code> returns an uninitialized <code>BitVector</code> with two elements since <code>BitArray</code>s are both mutable and can support 1-dimensional arrays:</p> <pre data-language="julia">julia&gt; similar(trues(10,10), 2)
2-element BitArray{1}:
 false
 false
</pre> <p>Since <code>BitArray</code>s can only store elements of type <code>Bool</code>, however, if you request a different element type it will create a regular <code>Array</code> instead:</p> <pre data-language="julia">julia&gt; similar(falses(10), Float64, 2, 4)
2×4 Array{Float64,2}:
 2.18425e-314  2.18425e-314  2.18425e-314  2.18425e-314
 2.18425e-314  2.18425e-314  2.18425e-314  2.18425e-314
</pre> </dd>
</dl> <dl class="function"> <dt>
<code>similar(storagetype, indices)</code> </dt> <dd>
<p>Create an uninitialized mutable array analogous to that specified by <code>storagetype</code>, but with <code>indices</code> specified by the last argument. <code>storagetype</code> might be a type or a function.</p> <p><strong>Examples</strong>:</p> <pre data-language="julia">similar(Array{Int}, indices(A))
</pre> <p>creates an array that “acts like” an <code>Array{Int}</code> (and might indeed be backed by one), but which is indexed identically to <code>A</code>. If <code>A</code> has conventional indexing, this will be identical to <code>Array{Int}(size(A))</code>, but if <code>A</code> has unconventional indexing then the indices of the result will match <code>A</code>.</p> <pre data-language="julia">similar(BitArray, (indices(A, 2),))
</pre> <p>would create a 1-dimensional logical array whose indices match those of the columns of <code>A</code>.</p> <pre data-language="julia">similar(dims-&gt;zeros(Int, dims), indices(A))
</pre> <p>would create an array of <code>Int</code>, initialized to zero, matching the indices of <code>A</code>.</p> </dd>
</dl> <dl class="function"> <dt id="Base.reinterpret">
<code>reinterpret(type, A)</code> </dt> <dd>
<p>Change the type-interpretation of a block of memory. For example, <code>reinterpret(Float32, UInt32(7))</code> interprets the 4 bytes corresponding to <code>UInt32(7)</code> as a <code>Float32</code>. For arrays, this constructs an array with the same binary data as the given array, but with the specified element type.</p> </dd>
</dl> <dl class="function"> <dt id="Base.eye">
<code>eye([T::Type=Float64, ]n::Integer)</code> </dt> <dd>
<p><code>n</code>-by-<code>n</code> identity matrix. The default element type is <code>Float64</code>.</p> </dd>
</dl> <dl class="function"> <dt>
<code>eye([T::Type=Float64, ]m::Integer, n::Integer)</code> </dt> <dd>
<p><code>m</code>-by-<code>n</code> identity matrix. The default element type is <code>Float64</code>.</p> </dd>
</dl> <dl class="function"> <dt>
<code>eye(A)</code> </dt> <dd>
<p>Constructs an identity matrix of the same dimensions and type as <code>A</code>.</p> <pre data-language="julia">julia&gt; A = [1 2 3; 4 5 6; 7 8 9]
3×3 Array{Int64,2}:
 1  2  3
 4  5  6
 7  8  9

julia&gt; eye(A)
3×3 Array{Int64,2}:
 1  0  0
 0  1  0
 0  0  1
</pre> <p>Note the difference from <a class="reference internal" href="#Base.ones" title="Base.ones"><code>ones()</code></a>.</p> </dd>
</dl> <dl class="function"> <dt id="Base.linspace">
<code>linspace(start, stop, n=50)</code> </dt> <dd>
<p>Construct a range of <code>n</code> linearly spaced elements from <code>start</code> to <code>stop</code>.</p> </dd>
</dl> <dl class="function"> <dt id="Base.logspace">
<code>logspace(start, stop, n=50)</code> </dt> <dd>
<p>Construct a vector of <code>n</code> logarithmically spaced numbers from <code>10^start</code> to <code>10^stop</code>.</p> </dd>
</dl>   <h2 id="mathematical-operators-and-functions">Mathematical operators and functions</h2> <p>All mathematical operations and functions are supported for arrays</p> <dl class="function"> <dt id="Base.broadcast">
<code>broadcast(f, As...)</code> </dt> <dd>
<p>Broadcasts the arrays <code>As</code> to a common size by expanding singleton dimensions, and returns an array of the results <code>f(as...)</code> for each position.</p> </dd>
</dl> <dl class="function"> <dt id="Base.broadcast!">
<code>broadcast!(f, dest, As...)</code> </dt> <dd>
<p>Like <code>broadcast</code>, but store the result of <code>broadcast(f, As...)</code> in the <code>dest</code> array. Note that <code>dest</code> is only used to store the result, and does not supply arguments to <code>f</code> unless it is also listed in the <code>As</code>, as in <code>broadcast!(f, A, A, B)</code> to perform <code>A[:] = broadcast(f, A, B)</code>.</p> </dd>
</dl> <dl class="function"> <dt id="Base.bitbroadcast">
<code>bitbroadcast(f, As...)</code> </dt> <dd>
<p>Like <code>broadcast</code>, but allocates a <code>BitArray</code> to store the result, rather then an <code>Array</code>.</p> </dd>
</dl>   <h2 id="indexing-assignment-and-concatenation">Indexing, Assignment, and Concatenation</h2> <dl class="function"> <dt>
<code>getindex(A, inds...)</code> </dt> <dd>
<p>Returns a subset of array <code>A</code> as specified by <code>inds</code>, where each <code>ind</code> may be an <code>Int</code>, a <code>Range</code>, or a <code>Vector</code>. See the manual section on <a class="reference internal" href="../../manual/arrays/#man-array-indexing"><span>array indexing</span></a> for details.</p> </dd>
</dl> <dl class="function"> <dt id="Base.view">
<code>view(A, inds...)</code> </dt> <dd>
<p>Like <a class="reference internal" href="../collections/#Base.getindex" title="Base.getindex"><code>getindex()</code></a>, but returns a view into the parent array <code>A</code> with the given indices instead of making a copy. Calling <a class="reference internal" href="../collections/#Base.getindex" title="Base.getindex"><code>getindex()</code></a> or <a class="reference internal" href="../collections/#Base.setindex!" title="Base.setindex!"><code>setindex!()</code></a> on the returned <code>SubArray</code> computes the indices to the parent array on the fly without checking bounds.</p> </dd>
</dl> <dl class="function"> <dt>
<code>@view A[inds...]</code> </dt> <dd>
<p>Creates a <code>SubArray</code> from an indexing expression. This can only be applied directly to a reference expression (e.g. <code>@view A[1,2:end]</code>), and should <em>not</em> be used as the target of an assignment (e.g. <code>@view(A[1,2:end]) = ...</code>).</p> </dd>
</dl> <dl class="function"> <dt id="Base.parent">
<code>parent(A)</code> </dt> <dd>
<p>Returns the “parent array” of an array view type (e.g., <code>SubArray</code>), or the array itself if it is not a view.</p> </dd>
</dl> <dl class="function"> <dt id="Base.parentindexes">
<code>parentindexes(A)</code> </dt> <dd>
<p>From an array view <code>A</code>, returns the corresponding indexes in the parent.</p> </dd>
</dl> <dl class="function"> <dt id="Base.slicedim">
<code>slicedim(A, d, i)</code> </dt> <dd>
<p>Return all the data of <code>A</code> where the index for dimension <code>d</code> equals <code>i</code>. Equivalent to <code>A[:,:,...,i,:,:,...]</code> where <code>i</code> is in position <code>d</code>.</p> </dd>
</dl> <dl class="function"> <dt id="Base.setindex!">
<code>setindex!(A, X, inds...)</code> </dt> <dd>
<p>Store values from array <code>X</code> within some subset of <code>A</code> as specified by <code>inds</code>.</p> </dd>
</dl> <dl class="function"> <dt id="Base.broadcast_getindex">
<code>broadcast_getindex(A, inds...)</code> </dt> <dd>
<p>Broadcasts the <code>inds</code> arrays to a common size like <code>broadcast</code>, and returns an array of the results <code>A[ks...]</code>, where <code>ks</code> goes over the positions in the broadcast.</p> </dd>
</dl> <dl class="function"> <dt id="Base.broadcast_setindex!">
<code>broadcast_setindex!(A, X, inds...)</code> </dt> <dd>
<p>Broadcasts the <code>X</code> and <code>inds</code> arrays to a common size and stores the value from each position in <code>X</code> at the indices given by the same positions in <code>inds</code>.</p> </dd>
</dl> <dl class="function"> <dt id="Base.isassigned">
<code>isassigned(array, i) → Bool</code> </dt> <dd>
<p>Tests whether the given array has a value associated with index <code>i</code>. Returns <code>false</code> if the index is out of bounds, or has an undefined reference.</p> </dd>
</dl> <dl class="function"> <dt id="Base.cat">
<code>cat(dims, A...)</code> </dt> <dd>
<p>Concatenate the input arrays along the specified dimensions in the iterable <code>dims</code>. For dimensions not in <code>dims</code>, all input arrays should have the same size, which will also be the size of the output array along that dimension. For dimensions in <code>dims</code>, the size of the output array is the sum of the sizes of the input arrays along that dimension. If <code>dims</code> is a single number, the different arrays are tightly stacked along that dimension. If <code>dims</code> is an iterable containing several dimensions, this allows one to construct block diagonal matrices and their higher-dimensional analogues by simultaneously increasing several dimensions for every new input array and putting zero blocks elsewhere. For example, <code>cat([1,2], matrices...)</code> builds a block diagonal matrix, i.e. a block matrix with <code>matrices[1]</code>, <code>matrices[2]</code>, ... as diagonal blocks and matching zero blocks away from the diagonal.</p> </dd>
</dl> <dl class="function"> <dt id="Base.vcat">
<code>vcat(A...)</code> </dt> <dd>
<p>Concatenate along dimension 1.</p> <pre data-language="julia">julia&gt; a = [1 2 3 4 5]
1×5 Array{Int64,2}:
 1  2  3  4  5

julia&gt; b = [6 7 8 9 10; 11 12 13 14 15]
2×5 Array{Int64,2}:
  6   7   8   9  10
 11  12  13  14  15

julia&gt; vcat(a,b)
3×5 Array{Int64,2}:
  1   2   3   4   5
  6   7   8   9  10
 11  12  13  14  15

julia&gt; c = ([1 2 3], [4 5 6])
(
[1 2 3],

[4 5 6])

julia&gt; vcat(c...)
2×3 Array{Int64,2}:
 1  2  3
 4  5  6
</pre> </dd>
</dl> <dl class="function"> <dt id="Base.hcat">
<code>hcat(A...)</code> </dt> <dd>
<p>Concatenate along dimension 2.</p> <pre data-language="julia">julia&gt; a = [1; 2; 3; 4; 5]
5-element Array{Int64,1}:
 1
 2
 3
 4
 5

julia&gt; b = [6 7; 8 9; 10 11; 12 13; 14 15]
5×2 Array{Int64,2}:
  6   7
  8   9
 10  11
 12  13
 14  15

julia&gt; hcat(a,b)
5×3 Array{Int64,2}:
 1   6   7
 2   8   9
 3  10  11
 4  12  13
 5  14  15

julia&gt; c = ([1; 2; 3], [4; 5; 6])
([1,2,3],[4,5,6])

julia&gt; hcat(c...)
3×2 Array{Int64,2}:
 1  4
 2  5
 3  6
</pre> </dd>
</dl> <dl class="function"> <dt id="Base.hvcat">
<code>hvcat(rows::Tuple{Vararg{Int}}, values...)</code> </dt> <dd>
<p>Horizontal and vertical concatenation in one call. This function is called for block matrix syntax. The first argument specifies the number of arguments to concatenate in each block row.</p> <pre data-language="julia">julia&gt; a, b, c, d, e, f = 1, 2, 3, 4, 5, 6
(1,2,3,4,5,6)

julia&gt; [a b c; d e f]
2×3 Array{Int64,2}:
 1  2  3
 4  5  6

julia&gt; hvcat((3,3), a,b,c,d,e,f)
2×3 Array{Int64,2}:
 1  2  3
 4  5  6

julia&gt; [a b;c d; e f]
3×2 Array{Int64,2}:
 1  2
 3  4
 5  6

julia&gt; hvcat((2,2,2), a,b,c,d,e,f)
3×2 Array{Int64,2}:
 1  2
 3  4
 5  6
</pre> <p>If the first argument is a single integer <code>n</code>, then all block rows are assumed to have <code>n</code> block columns.</p> </dd>
</dl> <dl class="function"> <dt id="Base.flipdim">
<code>flipdim(A, d)</code> </dt> <dd>
<p>Reverse <code>A</code> in dimension <code>d</code>.</p> <pre data-language="julia">julia&gt; b = [1 2; 3 4]
2×2 Array{Int64,2}:
 1  2
 3  4

julia&gt; flipdim(b,2)
2×2 Array{Int64,2}:
 2  1
 4  3
</pre> </dd>
</dl> <dl class="function"> <dt id="Base.circshift">
<code>circshift(A, shifts)</code> </dt> <dd>
<p>Circularly shift the data in an array. The second argument is a vector giving the amount to shift in each dimension.</p> <pre data-language="julia">julia&gt; b = reshape(collect(1:16), (4,4))
4×4 Array{Int64,2}:
 1  5   9  13
 2  6  10  14
 3  7  11  15
 4  8  12  16

julia&gt; circshift(b, (0,2))
4×4 Array{Int64,2}:
  9  13  1  5
 10  14  2  6
 11  15  3  7
 12  16  4  8

julia&gt; circshift(b, (-1,0))
4×4 Array{Int64,2}:
 2  6  10  14
 3  7  11  15
 4  8  12  16
 1  5   9  13
</pre> </dd>
</dl> <dl class="function"> <dt id="Base.find">
<code>find(A)</code> </dt> <dd>
<p>Return a vector of the linear indexes of the non-zeros in <code>A</code> (determined by <code>A[i]!=0</code>). A common use of this is to convert a boolean array to an array of indexes of the <code>true</code> elements. If there are no non-zero elements of <code>A</code>, <code>find</code> returns an empty array.</p> <pre data-language="julia">julia&gt; A = [true false; false true]
2×2 Array{Bool,2}:
  true  false
 false   true

julia&gt; find(A)
2-element Array{Int64,1}:
 1
 4
</pre> </dd>
</dl> <dl class="function"> <dt>
<code>find(f::Function, A)</code> </dt> <dd>
<p>Return a vector <code>I</code> of the linear indexes of <code>A</code> where <code>f(A[I])</code> returns <code>true</code>. If there are no such elements of <code>A</code>, find returns an empty array.</p> <pre data-language="julia">julia&gt; A = [1 2; 3 4]
2×2 Array{Int64,2}:
 1  2
 3  4

julia&gt; find(isodd,A)
2-element Array{Int64,1}:
 1
 2
</pre> </dd>
</dl> <dl class="function"> <dt id="Base.findn">
<code>findn(A)</code> </dt> <dd>
<p>Return a vector of indexes for each dimension giving the locations of the non-zeros in <code>A</code> (determined by <code>A[i]!=0</code>). If there are no non-zero elements of <code>A</code>, <code>findn</code> returns a 2-tuple of empty arrays.</p> <pre data-language="julia">julia&gt; A = [1 2 0; 0 0 3; 0 4 0]
3×3 Array{Int64,2}:
 1  2  0
 0  0  3
 0  4  0

julia&gt; findn(A)
([1,1,3,2],[1,2,2,3])

julia&gt; A = zeros(2,2)
2×2 Array{Float64,2}:
 0.0  0.0
 0.0  0.0

julia&gt; findn(A)
(Int64[],Int64[])
</pre> </dd>
</dl> <dl class="function"> <dt id="Base.findnz">
<code>findnz(A)</code> </dt> <dd>
<p>Return a tuple <code>(I, J, V)</code> where <code>I</code> and <code>J</code> are the row and column indexes of the non-zero values in matrix <code>A</code>, and <code>V</code> is a vector of the non-zero values.</p> <pre data-language="julia">julia&gt; A = [1 2 0; 0 0 3; 0 4 0]
3×3 Array{Int64,2}:
 1  2  0
 0  0  3
 0  4  0

julia&gt; findnz(A)
([1,1,3,2],[1,2,2,3],[1,2,4,3])
</pre> </dd>
</dl> <dl class="function"> <dt id="Base.findfirst">
<code>findfirst(A)</code> </dt> <dd>
<p>Return the linear index of the first non-zero value in <code>A</code> (determined by <code>A[i]!=0</code>). Returns <code>0</code> if no such value is found.</p> <pre data-language="julia">julia&gt; A = [0 0; 1 0]
2×2 Array{Int64,2}:
 0  0
 1  0

julia&gt; findfirst(A)
2
</pre> </dd>
</dl> <dl class="function"> <dt>
<code>findfirst(A, v)</code> </dt> <dd>
<p>Return the linear index of the first element equal to <code>v</code> in <code>A</code>. Returns <code>0</code> if <code>v</code> is not found.</p> <pre data-language="julia">julia&gt; A = [4 6; 2 2]
2×2 Array{Int64,2}:
 4  6
 2  2

julia&gt; findfirst(A,2)
2

julia&gt; findfirst(A,3)
0
</pre> </dd>
</dl> <dl class="function"> <dt>
<code>findfirst(predicate::Function, A)</code> </dt> <dd>
<p>Return the linear index of the first element of <code>A</code> for which <code>predicate</code> returns <code>true</code>. Returns <code>0</code> if there is no such element.</p> <pre data-language="julia">julia&gt; A = [1 4; 2 2]
2×2 Array{Int64,2}:
 1  4
 2  2

julia&gt; findfirst(iseven, A)
2

julia&gt; findfirst(x -&gt; x&gt;10, A)
0
</pre> </dd>
</dl> <dl class="function"> <dt id="Base.findlast">
<code>findlast(A)</code> </dt> <dd>
<p>Return the linear index of the last non-zero value in <code>A</code> (determined by <code>A[i]!=0</code>). Returns <code>0</code> if there is no non-zero value in <code>A</code>.</p> <pre data-language="julia">julia&gt; A = [1 0; 1 0]
2×2 Array{Int64,2}:
 1  0
 1  0

julia&gt; findlast(A)
2

julia&gt; A = zeros(2,2)
2×2 Array{Float64,2}:
 0.0  0.0
 0.0  0.0

julia&gt; findlast(A)
0
</pre> </dd>
</dl> <dl class="function"> <dt>
<code>findlast(A, v)</code> </dt> <dd>
<p>Return the linear index of the last element equal to <code>v</code> in <code>A</code>. Returns <code>0</code> if there is no element of <code>A</code> equal to <code>v</code>.</p> <pre data-language="julia">julia&gt; A = [1 2; 2 1]
2×2 Array{Int64,2}:
 1  2
 2  1

julia&gt; findlast(A,1)
4

julia&gt; findlast(A,2)
3

julia&gt; findlast(A,3)
0
</pre> </dd>
</dl> <dl class="function"> <dt>
<code>findlast(predicate::Function, A)</code> </dt> <dd>
<p>Return the linear index of the last element of <code>A</code> for which <code>predicate</code> returns <code>true</code>. Returns <code>0</code> if there is no such element.</p> <pre data-language="julia">julia&gt; A = [1 2; 3 4]
2×2 Array{Int64,2}:
 1  2
 3  4

julia&gt; findlast(isodd, A)
2

julia&gt; findlast(x -&gt; x &gt; 5, A)
0
</pre> </dd>
</dl> <dl class="function"> <dt id="Base.findnext">
<code>findnext(A, i::Integer)</code> </dt> <dd>
<p>Find the next linear index &gt;= <code>i</code> of a non-zero element of <code>A</code>, or <code>0</code> if not found.</p> <pre data-language="julia">julia&gt; A = [0 0; 1 0]
2×2 Array{Int64,2}:
 0  0
 1  0

julia&gt; findnext(A,1)
2

julia&gt; findnext(A,3)
0
</pre> </dd>
</dl> <dl class="function"> <dt>
<code>findnext(predicate::Function, A, i::Integer)</code> </dt> <dd>
<p>Find the next linear index &gt;= <code>i</code> of an element of <code>A</code> for which <code>predicate</code> returns <code>true</code>, or <code>0</code> if not found.</p> <pre data-language="julia">julia&gt; A = [1 4; 2 2]
2×2 Array{Int64,2}:
 1  4
 2  2

julia&gt; findnext(isodd, A, 1)
1

julia&gt; findnext(isodd, A, 2)
0
</pre> </dd>
</dl> <dl class="function"> <dt>
<code>findnext(A, v, i::Integer)</code> </dt> <dd>
<p>Find the next linear index &gt;= <code>i</code> of an element of <code>A</code> equal to <code>v</code> (using <code>==</code>), or <code>0</code> if not found.</p> <pre data-language="julia">julia&gt; A = [1 4; 2 2]
2×2 Array{Int64,2}:
 1  4
 2  2

julia&gt; findnext(A,4,4)
0

julia&gt; findnext(A,4,3)
3
</pre> </dd>
</dl> <dl class="function"> <dt id="Base.findprev">
<code>findprev(A, i::Integer)</code> </dt> <dd>
<p>Find the previous linear index &lt;= <code>i</code> of a non-zero element of <code>A</code>, or <code>0</code> if not found.</p> <pre data-language="julia">julia&gt; A = [0 0; 1 2]
2×2 Array{Int64,2}:
 0  0
 1  2

julia&gt; findprev(A,2)
2

julia&gt; findprev(A,1)
0
</pre> </dd>
</dl> <dl class="function"> <dt>
<code>findprev(predicate::Function, A, i::Integer)</code> </dt> <dd>
<p>Find the previous linear index &lt;= <code>i</code> of an element of <code>A</code> for which <code>predicate</code> returns <code>true</code>, or <code>0</code> if not found.</p> <pre data-language="julia">julia&gt; A = [4 6; 1 2]
2×2 Array{Int64,2}:
 4  6
 1  2

julia&gt; findprev(isodd, A, 1)
0

julia&gt; findprev(isodd, A, 3)
2
</pre> </dd>
</dl> <dl class="function"> <dt>
<code>findprev(A, v, i::Integer)</code> </dt> <dd>
<p>Find the previous linear index &lt;= <code>i</code> of an element of <code>A</code> equal to <code>v</code> (using <code>==</code>), or <code>0</code> if not found.</p> <pre data-language="julia">julia&gt; A = [0 0; 1 2]
2×2 Array{Int64,2}:
 0  0
 1  2

julia&gt; findprev(A, 1, 4)
2

julia&gt; findprev(A, 1, 1)
0
</pre> </dd>
</dl> <dl class="function"> <dt id="Base.permutedims">
<code>permutedims(A, perm)</code> </dt> <dd>
<p>Permute the dimensions of array <code>A</code>. <code>perm</code> is a vector specifying a permutation of length <code>ndims(A)</code>. This is a generalization of transpose for multi-dimensional arrays. Transpose is equivalent to <code>permutedims(A, [2,1])</code>.</p> </dd>
</dl> <dl class="function"> <dt id="Base.ipermutedims">
<code>ipermutedims(A, perm)</code> </dt> <dd>
<p>Like <a class="reference internal" href="#Base.permutedims" title="Base.permutedims"><code>permutedims()</code></a>, except the inverse of the given permutation is applied.</p> </dd>
</dl> <dl class="function"> <dt id="Base.permutedims!">
<code>permutedims!(dest, src, perm)</code> </dt> <dd>
<p>Permute the dimensions of array <code>src</code> and store the result in the array <code>dest</code>. <code>perm</code> is a vector specifying a permutation of length <code>ndims(src)</code>. The preallocated array <code>dest</code> should have <code>size(dest) == size(src)[perm]</code> and is completely overwritten. No in-place permutation is supported and unexpected results will happen if <code>src</code> and <code>dest</code> have overlapping memory regions.</p> </dd>
</dl> <dl class="function"> <dt id="Base.squeeze">
<code>squeeze(A, dims)</code> </dt> <dd>
<p>Remove the dimensions specified by <code>dims</code> from array <code>A</code>. Elements of <code>dims</code> must be unique and within the range <code>1:ndims(A)</code>. <code>size(A,i)</code> must equal 1 for all <code>i</code> in <code>dims</code>.</p> <pre data-language="julia">julia&gt; a = reshape(collect(1:4),(2,2,1,1))
2×2×1×1 Array{Int64,4}:
[:, :, 1, 1] =
 1  3
 2  4

julia&gt; squeeze(a,3)
2×2×1 Array{Int64,3}:
[:, :, 1] =
 1  3
 2  4
</pre> </dd>
</dl> <dl class="function"> <dt id="Base.vec">
<code>vec(a::AbstractArray) → Vector</code> </dt> <dd>
<p>Reshape array <code>a</code> as a one-dimensional column vector.</p> <pre data-language="julia">julia&gt; a = [1 2 3; 4 5 6]
2×3 Array{Int64,2}:
 1  2  3
 4  5  6

julia&gt; vec(a)
6-element Array{Int64,1}:
 1
 4
 2
 5
 3
 6
</pre> </dd>
</dl> <dl class="function"> <dt id="Base.promote_shape">
<code>promote_shape(s1, s2)</code> </dt> <dd>
<p>Check two array shapes for compatibility, allowing trailing singleton dimensions, and return whichever shape has more dimensions.</p> </dd>
</dl> <dl class="function"> <dt id="Base.checkbounds">
<code>checkbounds(A, I...)</code> </dt> <dd>
<p>Throw an error if the specified indices <code>I</code> are not in bounds for the given array <code>A</code>.</p> </dd>
</dl> <dl class="function"> <dt>
<code>checkbounds(Bool, A, I...)</code> </dt> <dd>
<p>Return <code>true</code> if the specified indices <code>I</code> are in bounds for the given array <code>A</code>. Subtypes of <code>AbstractArray</code> should specialize this method if they need to provide custom bounds checking behaviors; however, in many cases one can rely on <code>A</code>‘s indices and <code>checkindex</code>.</p> <p>See also <code>checkindex</code>.</p> </dd>
</dl> <dl class="function"> <dt id="Base.checkindex">
<code>checkindex(Bool, inds::AbstractUnitRange, index)</code> </dt> <dd>
<p>Return <code>true</code> if the given <code>index</code> is within the bounds of <code>inds</code>. Custom types that would like to behave as indices for all arrays can extend this method in order to provide a specialized bounds checking implementation.</p> </dd>
</dl> <dl class="function"> <dt id="Base.randsubseq">
<code>randsubseq(A, p) → Vector</code> </dt> <dd>
<p>Return a vector consisting of a random subsequence of the given array <code>A</code>, where each element of <code>A</code> is included (in order) with independent probability <code>p</code>. (Complexity is linear in <code>p*length(A)</code>, so this function is efficient even if <code>p</code> is small and <code>A</code> is large.) Technically, this process is known as “Bernoulli sampling” of <code>A</code>.</p> </dd>
</dl> <dl class="function"> <dt id="Base.randsubseq!">
<code>randsubseq!(S, A, p)</code> </dt> <dd>
<p>Like <code>randsubseq</code>, but the results are stored in <code>S</code> (which is resized as needed).</p> </dd>
</dl>   <h2 id="array-functions">Array functions</h2> <dl class="function"> <dt id="Base.cumprod">
<code>cumprod(A, dim=1)</code> </dt> <dd>
<p>Cumulative product along a dimension <code>dim</code> (defaults to 1). See also <a class="reference internal" href="#Base.cumprod!" title="Base.cumprod!"><code>cumprod!()</code></a> to use a preallocated output array, both for performance and to control the precision of the output (e.g. to avoid overflow).</p> <pre data-language="julia">julia&gt; a = [1 2 3; 4 5 6]
2×3 Array{Int64,2}:
 1  2  3
 4  5  6

julia&gt; cumprod(a,1)
2×3 Array{Int64,2}:
 1   2   3
 4  10  18

julia&gt; cumprod(a,2)
2×3 Array{Int64,2}:
 1   2    6
 4  20  120
</pre> </dd>
</dl> <dl class="function"> <dt id="Base.cumprod!">
<code>cumprod!(B, A[, dim])</code> </dt> <dd>
<p>Cumulative product of <code>A</code> along a dimension, storing the result in <code>B</code>. The dimension defaults to 1.</p> </dd>
</dl> <dl class="function"> <dt id="Base.cumsum">
<code>cumsum(A, dim=1)</code> </dt> <dd>
<p>Cumulative sum along a dimension <code>dim</code> (defaults to 1). See also <a class="reference internal" href="#Base.cumsum!" title="Base.cumsum!"><code>cumsum!()</code></a> to use a preallocated output array, both for performance and to control the precision of the output (e.g. to avoid overflow).</p> <pre data-language="julia">julia&gt; a = [1 2 3; 4 5 6]
2×3 Array{Int64,2}:
 1  2  3
 4  5  6

julia&gt; cumsum(a,1)
2×3 Array{Int64,2}:
 1  2  3
 5  7  9

julia&gt; cumsum(a,2)
2×3 Array{Int64,2}:
 1  3   6
 4  9  15
</pre> </dd>
</dl> <dl class="function"> <dt id="Base.cumsum!">
<code>cumsum!(B, A[, dim])</code> </dt> <dd>
<p>Cumulative sum of <code>A</code> along a dimension, storing the result in <code>B</code>. The dimension defaults to 1.</p> </dd>
</dl> <dl class="function"> <dt id="Base.cumsum_kbn">
<code>cumsum_kbn(A[, dim])</code> </dt> <dd>
<p>Cumulative sum along a dimension, using the Kahan-Babuska-Neumaier compensated summation algorithm for additional accuracy. The dimension defaults to 1.</p> </dd>
</dl> <dl class="function"> <dt id="Base.cummin">
<code>cummin(A[, dim])</code> </dt> <dd>
<p>Cumulative minimum along a dimension. The dimension defaults to 1.</p> </dd>
</dl> <dl class="function"> <dt id="Base.cummax">
<code>cummax(A[, dim])</code> </dt> <dd>
<p>Cumulative maximum along a dimension. The dimension defaults to 1.</p> </dd>
</dl> <dl class="function"> <dt id="Base.diff">
<code>diff(A[, dim])</code> </dt> <dd>
<p>Finite difference operator of matrix or vector.</p> </dd>
</dl> <dl class="function"> <dt id="Base.gradient">
<code>gradient(F[, h])</code> </dt> <dd>
<p>Compute differences along vector <code>F</code>, using <code>h</code> as the spacing between points. The default spacing is one.</p> </dd>
</dl> <dl class="function"> <dt id="Base.rot180">
<code>rot180(A)</code> </dt> <dd>
<p>Rotate matrix <code>A</code> 180 degrees.</p> <pre data-language="julia">julia&gt; a = [1 2; 3 4]
2×2 Array{Int64,2}:
 1  2
 3  4

julia&gt; rot180(a)
2×2 Array{Int64,2}:
 4  3
 2  1
</pre> </dd>
</dl> <dl class="function"> <dt>
<code>rot180(A, k)</code> </dt> <dd>
<p>Rotate matrix <code>A</code> 180 degrees an integer <code>k</code> number of times. If <code>k</code> is even, this is equivalent to a <code>copy</code>.</p> <pre data-language="julia">julia&gt; a = [1 2; 3 4]
2×2 Array{Int64,2}:
 1  2
 3  4

julia&gt; rot180(a,1)
2×2 Array{Int64,2}:
 4  3
 2  1

julia&gt; rot180(a,2)
2×2 Array{Int64,2}:
 1  2
 3  4
</pre> </dd>
</dl> <dl class="function"> <dt id="Base.rotl90">
<code>rotl90(A)</code> </dt> <dd>
<p>Rotate matrix <code>A</code> left 90 degrees.</p> <pre data-language="julia">julia&gt; a = [1 2; 3 4]
2×2 Array{Int64,2}:
 1  2
 3  4

julia&gt; rotl90(a)
2×2 Array{Int64,2}:
 2  4
 1  3
</pre> </dd>
</dl> <dl class="function"> <dt>
<code>rotl90(A, k)</code> </dt> <dd>
<p>Rotate matrix <code>A</code> left 90 degrees an integer <code>k</code> number of times. If <code>k</code> is zero or a multiple of four, this is equivalent to a <code>copy</code>.</p> <pre data-language="julia">julia&gt; a = [1 2; 3 4]
2×2 Array{Int64,2}:
 1  2
 3  4

julia&gt; rotl90(a,1)
2×2 Array{Int64,2}:
 2  4
 1  3

julia&gt; rotl90(a,2)
2×2 Array{Int64,2}:
 4  3
 2  1

julia&gt; rotl90(a,3)
2×2 Array{Int64,2}:
 3  1
 4  2

julia&gt; rotl90(a,4)
2×2 Array{Int64,2}:
 1  2
 3  4
</pre> </dd>
</dl> <dl class="function"> <dt id="Base.rotr90">
<code>rotr90(A)</code> </dt> <dd>
<p>Rotate matrix <code>A</code> right 90 degrees.</p> <pre data-language="julia">julia&gt; a = [1 2; 3 4]
2×2 Array{Int64,2}:
 1  2
 3  4

julia&gt; rotr90(a)
2×2 Array{Int64,2}:
 3  1
 4  2
</pre> </dd>
</dl> <dl class="function"> <dt>
<code>rotr90(A, k)</code> </dt> <dd>
<p>Rotate matrix <code>A</code> right 90 degrees an integer <code>k</code> number of times. If <code>k</code> is zero or a multiple of four, this is equivalent to a <code>copy</code>.</p> <pre data-language="julia">julia&gt; a = [1 2; 3 4]
2×2 Array{Int64,2}:
 1  2
 3  4

julia&gt; rotr90(a,1)
2×2 Array{Int64,2}:
 3  1
 4  2

julia&gt; rotr90(a,2)
2×2 Array{Int64,2}:
 4  3
 2  1

julia&gt; rotr90(a,3)
2×2 Array{Int64,2}:
 2  4
 1  3

julia&gt; rotr90(a,4)
2×2 Array{Int64,2}:
 1  2
 3  4
</pre> </dd>
</dl> <dl class="function"> <dt id="Base.reducedim">
<code>reducedim(f, A, region[, v0])</code> </dt> <dd>
<p>Reduce 2-argument function <code>f</code> along dimensions of <code>A</code>. <code>region</code> is a vector specifying the dimensions to reduce, and <code>v0</code> is the initial value to use in the reductions. For <code>+</code>, <code>*</code>, <code>max</code> and <code>min</code> the <code>v0</code> argument is optional.</p> <p>The associativity of the reduction is implementation-dependent; if you need a particular associativity, e.g. left-to-right, you should write your own loop. See documentation for <a class="reference internal" href="../collections/#Base.reduce" title="Base.reduce"><code>reduce()</code></a>.</p> <pre data-language="julia">julia&gt; a = reshape(collect(1:16), (4,4))
4×4 Array{Int64,2}:
 1  5   9  13
 2  6  10  14
 3  7  11  15
 4  8  12  16

julia&gt; reducedim(max, a, 2)
4×1 Array{Int64,2}:
 13
 14
 15
 16

julia&gt; reducedim(max, a, 1)
1×4 Array{Int64,2}:
 4  8  12  16
</pre> </dd>
</dl> <dl class="function"> <dt id="Base.mapreducedim">
<code>mapreducedim(f, op, A, region[, v0])</code> </dt> <dd>
<p>Evaluates to the same as <code>reducedim(op, map(f, A), region, f(v0))</code>, but is generally faster because the intermediate array is avoided.</p> <pre data-language="julia">julia&gt; a = reshape(collect(1:16), (4,4))
4×4 Array{Int64,2}:
 1  5   9  13
 2  6  10  14
 3  7  11  15
 4  8  12  16

julia&gt; mapreducedim(isodd, *, a, 1)
1×4 Array{Bool,2}:
 false  false  false  false

julia&gt; mapreducedim(isodd, |, a, 1, true)
1×4 Array{Bool,2}:
 true  true  true  true
</pre> </dd>
</dl> <dl class="function"> <dt id="Base.mapslices">
<code>mapslices(f, A, dims)</code> </dt> <dd>
<p>Transform the given dimensions of array <code>A</code> using function <code>f</code>. <code>f</code> is called on each slice of <code>A</code> of the form <code>A[...,:,...,:,...]</code>. <code>dims</code> is an integer vector specifying where the colons go in this expression. The results are concatenated along the remaining dimensions. For example, if <code>dims</code> is <code>[1,2]</code> and <code>A</code> is 4-dimensional, <code>f</code> is called on <code>A[:,:,i,j]</code> for all <code>i</code> and <code>j</code>.</p> <pre data-language="julia">julia&gt; a = reshape(collect(1:16),(2,2,2,2))
2×2×2×2 Array{Int64,4}:
[:, :, 1, 1] =
 1  3
 2  4

[:, :, 2, 1] =
 5  7
 6  8

[:, :, 1, 2] =
  9  11
 10  12

[:, :, 2, 2] =
 13  15
 14  16

julia&gt; mapslices(sum, a, [1,2])
1×1×2×2 Array{Int64,4}:
[:, :, 1, 1] =
 10

[:, :, 2, 1] =
 26

[:, :, 1, 2] =
 42

[:, :, 2, 2] =
 58
</pre> </dd>
</dl> <dl class="function"> <dt id="Base.sum_kbn">
<code>sum_kbn(A)</code> </dt> <dd>
<p>Returns the sum of all array elements, using the Kahan-Babuska-Neumaier compensated summation algorithm for additional accuracy.</p> </dd>
</dl>   <h2 id="combinatorics">Combinatorics</h2> <dl class="function"> <dt id="Base.randperm">
<code>randperm([rng, ]n)</code> </dt> <dd>
<p>Construct a random permutation of length <code>n</code>. The optional <code>rng</code> argument specifies a random number generator (see <a class="reference internal" href="../numbers/#random-numbers"><span>Random Numbers</span></a>). To randomly permute a arbitrary vector, see <a class="reference internal" href="#Base.shuffle" title="Base.shuffle"><code>shuffle()</code></a> or <a class="reference internal" href="#Base.shuffle!" title="Base.shuffle!"><code>shuffle!()</code></a>.</p> </dd>
</dl> <dl class="function"> <dt id="Base.invperm">
<code>invperm(v)</code> </dt> <dd>
<p>Return the inverse permutation of <code>v</code></p> </dd>
</dl> <dl class="function"> <dt id="Base.isperm">
<code>isperm(v) → Bool</code> </dt> <dd>
<p>Returns <code>true</code> if <code>v</code> is a valid permutation.</p> </dd>
</dl> <dl class="function"> <dt id="Base.permute!">
<code>permute!(v, p)</code> </dt> <dd>
<p>Permute vector <code>v</code> in-place, according to permutation <code>p</code>. No checking is done to verify that <code>p</code> is a permutation.</p> <p>To return a new permutation, use <code>v[p]</code>. Note that this is generally faster than <code>permute!(v,p)</code> for large vectors.</p> </dd>
</dl> <dl class="function"> <dt id="Base.ipermute!">
<code>ipermute!(v, p)</code> </dt> <dd>
<p>Like <code>permute!</code>, but the inverse of the given permutation is applied.</p> </dd>
</dl> <dl class="function"> <dt id="Base.randcycle">
<code>randcycle([rng, ]n)</code> </dt> <dd>
<p>Construct a random cyclic permutation of length <code>n</code>. The optional <code>rng</code> argument specifies a random number generator, see <a class="reference internal" href="../numbers/#random-numbers"><span>Random Numbers</span></a>.</p> </dd>
</dl> <dl class="function"> <dt id="Base.shuffle">
<code>shuffle([rng, ]v)</code> </dt> <dd>
<p>Return a randomly permuted copy of <code>v</code>. The optional <code>rng</code> argument specifies a random number generator (see <a class="reference internal" href="../numbers/#random-numbers"><span>Random Numbers</span></a>). To permute <code>v</code> in-place, see <a class="reference internal" href="#Base.shuffle!" title="Base.shuffle!"><code>shuffle!()</code></a>. To obtain randomly permuted indices, see <a class="reference internal" href="#Base.randperm" title="Base.randperm"><code>randperm()</code></a>.</p> </dd>
</dl> <dl class="function"> <dt id="Base.shuffle!">
<code>shuffle!([rng, ]v)</code> </dt> <dd>
<p>In-place version of <a class="reference internal" href="#Base.shuffle" title="Base.shuffle"><code>shuffle()</code></a>: randomly permute the array <code>v</code> in-place, optionally supplying the random-number generator <code>rng</code>.</p> </dd>
</dl> <dl class="function"> <dt id="Base.reverse">
<code>reverse(v[, start=1[, stop=length(v)]])</code> </dt> <dd>
<p>Return a copy of <code>v</code> reversed from start to stop.</p> </dd>
</dl> <dl class="function"> <dt id="Base.reverseind">
<code>reverseind(v, i)</code> </dt> <dd>
<p>Given an index <code>i</code> in <code>reverse(v)</code>, return the corresponding index in <code>v</code> so that <code>v[reverseind(v,i)] == reverse(v)[i]</code>. (This can be nontrivial in the case where <code>v</code> is a Unicode string.)</p> </dd>
</dl> <dl class="function"> <dt id="Base.reverse!">
<code>reverse!(v[, start=1[, stop=length(v)]]) → v</code> </dt> <dd>
<p>In-place version of <a class="reference internal" href="../strings/#Base.reverse" title="Base.reverse"><code>reverse()</code></a>.</p> </dd>
</dl>   <h2 id="bitarrays">BitArrays</h2> <p>BitArrays are space-efficient “packed” boolean arrays, which store one bit per boolean value. They can be used similarly to <code>Array{Bool}</code> arrays (which store one byte per boolean value), and can be converted to/from the latter via <code>Array(bitarray)</code> and <code>BitArray(array)</code>, respectively.</p> <dl class="function"> <dt id="Base.flipbits!">
<code>flipbits!(B::BitArray{N}) → BitArray{N}</code> </dt> <dd>
<p>Performs a bitwise not operation on <code>B</code>. See <a class="reference internal" href="../math/#id33"><span>~ operator</span></a>.</p> <pre data-language="julia">julia&gt; A = trues(2,2)
2×2 BitArray{2}:
 true  true
 true  true

julia&gt; flipbits!(A)
2×2 BitArray{2}:
 false  false
 false  false
</pre> </dd>
</dl> <dl class="function"> <dt id="Base.rol!">
<code>rol!(dest::BitVector, src::BitVector, i::Integer) → BitVector</code> </dt> <dd>
<p>Performs a left rotation operation on <code>src</code> and puts the result into <code>dest</code>. <code>i</code> controls how far to rotate the bits.</p> </dd>
</dl> <dl class="function"> <dt>
<code>rol!(B::BitVector, i::Integer) → BitVector</code> </dt> <dd>
<p>Performs a left rotation operation in-place on <code>B</code>. <code>i</code> controls how far to rotate the bits.</p> </dd>
</dl> <dl class="function"> <dt id="Base.rol">
<code>rol(B::BitVector, i::Integer) → BitVector</code> </dt> <dd>
<p>Performs a left rotation operation, returning a new <code>BitVector</code>. <code>i</code> controls how far to rotate the bits. See also <a class="reference internal" href="#Base.rol!" title="Base.rol!"><code>rol!()</code></a>.</p> <pre data-language="julia">julia&gt; A = BitArray([true, true, false, false, true])
5-element BitArray{1}:
  true
  true
 false
 false
  true

julia&gt; rol(A,1)
5-element BitArray{1}:
  true
 false
 false
  true
  true

julia&gt; rol(A,2)
5-element BitArray{1}:
 false
 false
  true
  true
  true

julia&gt; rol(A,5)
5-element BitArray{1}:
  true
  true
 false
 false
  true
</pre> </dd>
</dl> <dl class="function"> <dt id="Base.ror!">
<code>ror!(dest::BitVector, src::BitVector, i::Integer) → BitVector</code> </dt> <dd>
<p>Performs a right rotation operation on <code>src</code> and puts the result into <code>dest</code>. <code>i</code> controls how far to rotate the bits.</p> </dd>
</dl> <dl class="function"> <dt>
<code>ror!(B::BitVector, i::Integer) → BitVector</code> </dt> <dd>
<p>Performs a right rotation operation in-place on <code>B</code>. <code>i</code> controls how far to rotate the bits.</p> </dd>
</dl> <dl class="function"> <dt id="Base.ror">
<code>ror(B::BitVector, i::Integer) → BitVector</code> </dt> <dd>
<p>Performs a right rotation operation on <code>B</code>, returning a new <code>BitVector</code>. <code>i</code> controls how far to rotate the bits. See also <a class="reference internal" href="#Base.ror!" title="Base.ror!"><code>ror!()</code></a>.</p> <pre data-language="julia">julia&gt; A = BitArray([true, true, false, false, true])
5-element BitArray{1}:
  true
  true
 false
 false
  true

julia&gt; ror(A,1)
5-element BitArray{1}:
  true
  true
  true
 false
 false

julia&gt; ror(A,2)
5-element BitArray{1}:
 false
  true
  true
  true
 false

julia&gt; ror(A,5)
5-element BitArray{1}:
  true
  true
 false
 false
  true
</pre> </dd>
</dl>   <h2 id="stdlib-sparse">Sparse Vectors and Matrices</h2> <p id="sparse-vectors-and-matrices">Sparse vectors and matrices largely support the same set of operations as their dense counterparts. The following functions are specific to sparse arrays.</p> <dl class="function"> <dt id="Base.sparse">
<code>sparse(I, J, V[, m, n, combine])</code> </dt> <dd>
<p>Create a sparse matrix <code>S</code> of dimensions <code>m x n</code> such that <code>S[I[k], J[k]] = V[k]</code>. The <code>combine</code> function is used to combine duplicates. If <code>m</code> and <code>n</code> are not specified, they are set to <code>maximum(I)</code> and <code>maximum(J)</code> respectively. If the <code>combine</code> function is not supplied, <code>combine</code> defaults to <code>+</code> unless the elements of <code>V</code> are Booleans in which case <code>combine</code> defaults to <code>|</code>. All elements of <code>I</code> must satisfy <code>1 &lt;= I[k] &lt;= m</code>, and all elements of <code>J</code> must satisfy <code>1 &lt;= J[k] &lt;= n</code>. Numerical zeros in (<code>I</code>, <code>J</code>, <code>V</code>) are retained as structural nonzeros; to drop numerical zeros, use <a class="reference internal" href="#Base.dropzeros!" title="Base.dropzeros!"><code>dropzeros!()</code></a>.</p> <p>For additional documentation and an expert driver, see <code>Base.SparseArrays.sparse!</code>.</p> </dd>
</dl> <dl class="function"> <dt id="Base.sparsevec">
<code>sparsevec(I, V[, m, combine])</code> </dt> <dd>
<p>Create a sparse vector <code>S</code> of length <code>m</code> such that <code>S[I[k]] = V[k]</code>. Duplicates are combined using the <code>combine</code> function, which defaults to <code>+</code> if no <code>combine</code> argument is provided, unless the elements of <code>V</code> are Booleans in which case <code>combine</code> defaults to <code>|</code>.</p> </dd>
</dl> <dl class="function"> <dt>
<code>sparsevec(D::Dict[, m])</code> </dt> <dd>
<p>Create a sparse vector of length <code>m</code> where the nonzero indices are keys from the dictionary, and the nonzero values are the values from the dictionary.</p> </dd>
</dl> <dl class="function"> <dt id="Base.issparse">
<code>issparse(S)</code> </dt> <dd>
<p>Returns <code>true</code> if <code>S</code> is sparse, and <code>false</code> otherwise.</p> </dd>
</dl> <dl class="function"> <dt>
<code>sparse(A)</code> </dt> <dd>
<p>Convert an AbstractMatrix <code>A</code> into a sparse matrix.</p> </dd>
</dl> <dl class="function"> <dt>
<code>sparsevec(A)</code> </dt> <dd>
<p>Convert a vector <code>A</code> into a sparse vector of length <code>m</code>.</p> </dd>
</dl> <dl class="function"> <dt id="Base.full">
<code>full(S)</code> </dt> <dd>
<p>Convert a sparse matrix or vector <code>S</code> into a dense matrix or vector.</p> </dd>
</dl> <dl class="function"> <dt id="Base.nnz">
<code>nnz(A)</code> </dt> <dd>
<p>Returns the number of stored (filled) elements in a sparse array.</p> </dd>
</dl> <dl class="function"> <dt id="Base.spzeros">
<code>spzeros([type, ]m[, n])</code> </dt> <dd>
<p>Create a sparse vector of length <code>m</code> or sparse matrix of size <code>m x n</code>. This sparse array will not contain any nonzero values. No storage will be allocated for nonzero values during construction. The type defaults to <code>Float64</code> if not specified.</p> </dd>
</dl> <dl class="function"> <dt id="Base.spones">
<code>spones(S)</code> </dt> <dd>
<p>Create a sparse array with the same structure as that of <code>S</code>, but with every nonzero element having the value <code>1.0</code>.</p> <pre data-language="julia">julia&gt; A = sparse([1,2,3,4],[2,4,3,1],[5.,4.,3.,2.])
4×4 sparse matrix with 4 Float64 nonzero entries:
        [4, 1]  =  2.0
        [1, 2]  =  5.0
        [3, 3]  =  3.0
        [2, 4]  =  4.0

julia&gt; spones(A)
4×4 sparse matrix with 4 Float64 nonzero entries:
        [4, 1]  =  1.0
        [1, 2]  =  1.0
        [3, 3]  =  1.0
        [2, 4]  =  1.0
</pre> <p>Note the difference from <a class="reference internal" href="#Base.speye" title="Base.speye"><code>speye()</code></a>.</p> </dd>
</dl> <dl class="function"> <dt id="Base.speye">
<code>speye([type, ]m[, n])</code> </dt> <dd>
<p>Create a sparse identity matrix of size <code>m x m</code>. When <code>n</code> is supplied, create a sparse identity matrix of size <code>m x n</code>. The type defaults to <code>Float64</code> if not specified.</p> </dd>
</dl> <dl class="function"> <dt>
<code>speye(S)</code> </dt> <dd>
<p>Create a sparse identity matrix with the same size as <code>S</code>.</p> <pre data-language="julia">julia&gt; A = sparse([1,2,3,4],[2,4,3,1],[5.,4.,3.,2.])
4×4 sparse matrix with 4 Float64 nonzero entries:
        [4, 1]  =  2.0
        [1, 2]  =  5.0
        [3, 3]  =  3.0
        [2, 4]  =  4.0

julia&gt; speye(A)
4×4 sparse matrix with 4 Float64 nonzero entries:
        [1, 1]  =  1.0
        [2, 2]  =  1.0
        [3, 3]  =  1.0
        [4, 4]  =  1.0
</pre> <p>Note the difference from <a class="reference internal" href="#Base.spones" title="Base.spones"><code>spones()</code></a>.</p> </dd>
</dl> <dl class="function"> <dt id="Base.spdiagm">
<code>spdiagm(B, d[, m, n])</code> </dt> <dd>
<p>Construct a sparse diagonal matrix. <code>B</code> is a tuple of vectors containing the diagonals and <code>d</code> is a tuple containing the positions of the diagonals. In the case the input contains only one diagonal, <code>B</code> can be a vector (instead of a tuple) and <code>d</code> can be the diagonal position (instead of a tuple), defaulting to 0 (diagonal). Optionally, <code>m</code> and <code>n</code> specify the size of the resulting sparse matrix.</p> <pre data-language="julia">julia&gt; spdiagm(([1,2,3,4],[4,3,2,1]),(-1,1))
5×5 sparse matrix with 8 Int64 nonzero entries:
        [2, 1]  =  1
        [1, 2]  =  4
        [3, 2]  =  2
        [2, 3]  =  3
        [4, 3]  =  3
        [3, 4]  =  2
        [5, 4]  =  4
        [4, 5]  =  1
</pre> </dd>
</dl> <dl class="function"> <dt id="Base.sprand">
<code>sprand([rng, ][type, ]m, [n, ]p::AbstractFloat[, rfn])</code> </dt> <dd>
<p>Create a random length <code>m</code> sparse vector or <code>m</code> by <code>n</code> sparse matrix, in which the probability of any element being nonzero is independently given by <code>p</code> (and hence the mean density of nonzeros is also exactly <code>p</code>). Nonzero values are sampled from the distribution specified by <code>rfn</code> and have the type <code>type</code>. The uniform distribution is used in case <code>rfn</code> is not specified. The optional <code>rng</code> argument specifies a random number generator, see <a class="reference internal" href="../numbers/#random-numbers"><span>Random Numbers</span></a>.</p> </dd>
</dl> <dl class="function"> <dt id="Base.sprandn">
<code>sprandn([rng, ]m, [n, ]p::AbstractFloat)</code> </dt> <dd>
<p>Create a random sparse vector of length <code>m</code> or sparse matrix of size <code>m</code> by <code>n</code> with the specified (independent) probability <code>p</code> of any entry being nonzero, where nonzero values are sampled from the normal distribution. The optional <code>rng</code> argument specifies a random number generator, see <a class="reference internal" href="../numbers/#random-numbers"><span>Random Numbers</span></a>.</p> </dd>
</dl> <dl class="function"> <dt id="Base.nonzeros">
<code>nonzeros(A)</code> </dt> <dd>
<p>Return a vector of the structural nonzero values in sparse array <code>A</code>. This includes zeros that are explicitly stored in the sparse array. The returned vector points directly to the internal nonzero storage of <code>A</code>, and any modifications to the returned vector will mutate <code>A</code> as well. See <a class="reference internal" href="#Base.rowvals" title="Base.rowvals"><code>rowvals()</code></a> and <a class="reference internal" href="#Base.nzrange" title="Base.nzrange"><code>nzrange()</code></a>.</p> </dd>
</dl> <dl class="function"> <dt id="Base.rowvals">
<code>rowvals(A::SparseMatrixCSC)</code> </dt> <dd>
<p>Return a vector of the row indices of <code>A</code>. Any modifications to the returned vector will mutate <code>A</code> as well. Providing access to how the row indices are stored internally can be useful in conjunction with iterating over structural nonzero values. See also <a class="reference internal" href="#Base.nonzeros" title="Base.nonzeros"><code>nonzeros()</code></a> and <a class="reference internal" href="#Base.nzrange" title="Base.nzrange"><code>nzrange()</code></a>.</p> </dd>
</dl> <dl class="function"> <dt id="Base.nzrange">
<code>nzrange(A::SparseMatrixCSC, col)</code> </dt> <dd>
<p>Return the range of indices to the structural nonzero values of a sparse matrix column. In conjunction with <a class="reference internal" href="#Base.nonzeros" title="Base.nonzeros"><code>nonzeros()</code></a> and <a class="reference internal" href="#Base.rowvals" title="Base.rowvals"><code>rowvals()</code></a>, this allows for convenient iterating over a sparse matrix :</p> <pre data-language="julia">A = sparse(I,J,V)
rows = rowvals(A)
vals = nonzeros(A)
m, n = size(A)
for i = 1:n
   for j in nzrange(A, i)
      row = rows[j]
      val = vals[j]
      # perform sparse wizardry...
   end
end
</pre> </dd>
</dl> <dl class="function"> <dt id="Base.dropzeros!">
<code>dropzeros!(A::SparseMatrixCSC, trim::Bool = true)</code> </dt> <dd>
<p>Removes stored numerical zeros from <code>A</code>, optionally trimming resulting excess space from <code>A.rowval</code> and <code>A.nzval</code> when <code>trim</code> is <code>true</code>.</p> <p>For an out-of-place version, see <a class="reference internal" href="#Base.dropzeros" title="Base.dropzeros"><code>dropzeros()</code></a>. For algorithmic information, see <code>Base.SparseArrays.fkeep!()</code>.</p> </dd>
</dl> <dl class="function"> <dt id="Base.dropzeros">
<code>dropzeros(A::SparseMatrixCSC, trim::Bool = true)</code> </dt> <dd>
<p>Generates a copy of <code>A</code> and removes stored numerical zeros from that copy, optionally trimming excess space from the result’s <code>rowval</code> and <code>nzval</code> arrays when <code>trim</code> is <code>true</code>.</p> <p>For an in-place version and algorithmic information, see <a class="reference internal" href="#Base.dropzeros!" title="Base.dropzeros!"><code>dropzeros!()</code></a>.</p> </dd>
</dl> <dl class="function"> <dt>
<code>dropzeros!(x::SparseVector, trim::Bool = true)</code> </dt> <dd>
<p>Removes stored numerical zeros from <code>x</code>, optionally trimming resulting excess space from <code>x.nzind</code> and <code>x.nzval</code> when <code>trim</code> is <code>true</code>.</p> <p>For an out-of-place version, see <code>Base.SparseArrays.dropzeros()</code>. For algorithmic information, see <code>Base.SparseArrays.fkeep!()</code>.</p> </dd>
</dl> <dl class="function"> <dt>
<code>dropzeros(x::SparseVector, trim::Bool = true)</code> </dt> <dd>
<p>Generates a copy of <code>x</code> and removes numerical zeros from that copy, optionally trimming excess space from the result’s <code>nzind</code> and <code>nzval</code> arrays when <code>trim</code> is <code>true</code>.</p> <p>For an in-place version and algorithmic information, see <code>Base.SparseArrays.dropzeros!()</code>.</p> </dd>
</dl> <dl class="function"> <dt><code>permute{Tv,Ti,Tp<:integer p::abstractvector> </:integer></code></dt> <dt id="Base.q::AbstractVector{Tq})">
<code>q::AbstractVector{Tq})()</code> </dt> <dd>
<p>Bilaterally permute <code>A</code>, returning <code>PAQ</code> (<code>A[p,q]</code>). Column-permutation <code>q</code>‘s length must match <code>A</code>‘s column count (<code>length(q) == A.n</code>). Row-permutation <code>p</code>‘s length must match <code>A</code>‘s row count (<code>length(p) == A.m</code>).</p> <p>For expert drivers and additional information, see <code>Base.SparseArrays.permute!()</code>.</p> </dd>
</dl> <dl class="function"> <dt><code>permute!{Tv,Ti,Tp<:integer a::sparsematrixcsc> </:integer></code></dt> <dt>
<code>p::AbstractVector{Tp}, q::AbstractVector{Tq}[, C::SparseMatrixCSC{Tv,Ti}])</code> </dt> <dd>
<p>Bilaterally permute <code>A</code>, storing result <code>PAQ</code> (<code>A[p,q]</code>) in <code>X</code>. Stores intermediate result <code>(AQ)^T</code> (<code>transpose(A[:,q])</code>) in optional argument <code>C</code> if present. Requires that none of <code>X</code>, <code>A</code>, and, if present, <code>C</code> alias each other; to store result <code>PAQ</code> back into <code>A</code>, use the following method lacking <code>X</code>:</p> <pre data-language="julia">permute!{Tv,Ti,Tp&lt;:Integer,Tq&lt;:Integer}(A::SparseMatrixCSC{Tv,Ti}, p::AbstractVector{Tp},
    q::AbstractVector{Tq}[, C::SparseMatrixCSC{Tv,Ti}[, workcolptr::Vector{Ti}]])
</pre> <p><code>X</code>‘s dimensions must match those of <code>A</code> (<code>X.m == A.m</code> and <code>X.n == A.n</code>), and <code>X</code> must have enough storage to accommodate all allocated entries in <code>A</code> (<code>length(X.rowval) &gt;= nnz(A)</code> and <code>length(X.nzval) &gt;= nnz(A)</code>). Column-permutation <code>q</code>‘s length must match <code>A</code>‘s column count (<code>length(q) == A.n</code>). Row-permutation <code>p</code>‘s length must match <code>A</code>‘s row count (<code>length(p) == A.m</code>).</p> <p><code>C</code>‘s dimensions must match those of <code>transpose(A)</code> (<code>C.m == A.n</code> and <code>C.n == A.m</code>), and <code>C</code> must have enough storage to accommodate all allocated entries in <code>A</code> (<code>length(C.rowval)</code> &gt;= nnz(A)``and``length(C.nzval) &gt;= nnz(A)`).</p> <p>For additional (algorithmic) information, and for versions of these methods that forgo argument checking, see (unexported) parent methods <code>Base.SparseArrays.unchecked_noalias_permute!()</code> and <code>Base.SparseArrays.unchecked_aliasing_permute!()</code>.</p> <p>See also: <code>Base.SparseArrays.permute()</code></p> </dd>
</dl>
<div class="_attribution">
  <p class="_attribution-p">
    © 2009–2016 Jeff Bezanson, Stefan Karpinski, Viral B. Shah, and other contributors<br>Licensed under the MIT License.<br>
    <a href="http://docs.julialang.org/en/release-0.5/stdlib/arrays/" class="_attribution-link" target="_blank">http://docs.julialang.org/en/release-0.5/stdlib/arrays/</a>
  </p>
</div>

			</div>
		</div>
	</section>

	</div>
</body>
</html>
