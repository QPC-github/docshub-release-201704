
<!DOCTYPE HTML>

<html lang="en">

<head>
  <meta charset="utf-8">
  <title>Mathematical Operations and Elementary Functions - Julia - W3cubDocs</title>
  
  <meta name="description" content="Julia provides a complete collection of basic arithmetic and bitwise operators across all of its numeric primitive types, as well as providing &hellip;">
  <meta name="keywords" content="mathematical, operations, and, elementary, functions, -, julia">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="http://docs.w3cub.com/julia/manual/mathematical-operations/">
  <link href="/favicon.png" rel="icon">
  <link type="text/css" rel="stylesheet" href="/assets/application-50364fff564ce3b6327021805f3f00e2957b441cf27f576a7dd4ff63bbc47047.css">
  <script type="text/javascript" src="/assets/application-db64bfd54ceb42be11af7995804cf4902548419ceb79d509b0b7d62c22d98e6f.js"></script>
  <script src="/json/julia.js"></script>
  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-71174418-1']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>


</head>

<body>
	<div class="_app">
	<header class="_header">
  
  <form class="_search">
    <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
    <a class="_search-clear"></a>
    <div class="_search-tag"></div>
  </form>
  
  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/julia/" class="_nav-link" title="" style="margin-left:0;">Julia</a></span>
  
  <nav class="_nav">
    <a href="/app/" class="_nav-link ">App</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		<div class="_list">
			
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<div class="_page _sphinx_simple">
				
<h1 id="man-mathematical-operations">Mathematical Operations and Elementary Functions</h1> <p>Julia provides a complete collection of basic arithmetic and bitwise operators across all of its numeric primitive types, as well as providing portable, efficient implementations of a comprehensive collection of standard mathematical functions.</p>  <h2 id="arithmetic-operators">Arithmetic Operators</h2> <p>The following <a class="reference external" href="https://en.wikipedia.org/wiki/Arithmetic#Arithmetic_operations" target="_blank">arithmetic operators</a> are supported on all primitive numeric types:</p> <table class="docutils">  <thead valign="bottom"> <tr class="row-odd">
<th class="head">Expression</th> <th class="head">Name</th> <th class="head">Description</th> </tr> </thead>  <tr class="row-even">
<td><code>+x</code></td> <td>unary plus</td> <td>the identity operation</td> </tr> <tr class="row-odd">
<td><code>-x</code></td> <td>unary minus</td> <td>maps values to their additive inverses</td> </tr> <tr class="row-even">
<td><code>x + y</code></td> <td>binary plus</td> <td>performs addition</td> </tr> <tr class="row-odd">
<td><code>x - y</code></td> <td>binary minus</td> <td>performs subtraction</td> </tr> <tr class="row-even">
<td><code>x * y</code></td> <td>times</td> <td>performs multiplication</td> </tr> <tr class="row-odd">
<td><code>x / y</code></td> <td>divide</td> <td>performs division</td> </tr> <tr class="row-even">
<td><code>x \ y</code></td> <td>inverse divide</td> <td>equivalent to <code>y / x</code>
</td> </tr> <tr class="row-odd">
<td><code>x ^ y</code></td> <td>power</td> <td>raises <code>x</code> to the <code>y</code>th power</td> </tr> <tr class="row-even">
<td><code>x % y</code></td> <td>remainder</td> <td>equivalent to <code>rem(x,y)</code>
</td> </tr>  </table> <p>as well as the negation on <code>Bool</code> types:</p> <table class="docutils">  <thead valign="bottom"> <tr class="row-odd">
<th class="head">Expression</th> <th class="head">Name</th> <th class="head">Description</th> </tr> </thead>  <tr class="row-even">
<td><code>!x</code></td> <td>negation</td> <td>changes <code>true</code> to <code>false</code> and vice versa</td> </tr>  </table> <p>Julia’s promotion system makes arithmetic operations on mixtures of argument types “just work” naturally and automatically. See <a class="reference internal" href="../conversion-and-promotion/#man-conversion-and-promotion"><span>Conversion and Promotion</span></a> for details of the promotion system.</p> <p>Here are some simple examples using arithmetic operators:</p> <pre data-language="julia">julia&gt; 1 + 2 + 3
6

julia&gt; 1 - 2
-1

julia&gt; 3*2/12
0.5
</pre> <p>(By convention, we tend to space operators more tightly if they get applied before other nearby operators. For instance, we would generally write <code>-x + 2</code> to reflect that first <code>x</code> gets negated, and then <code>2</code> is added to that result.)</p>   <h2 id="bitwise-operators">Bitwise Operators</h2> <p>The following <a class="reference external" href="https://en.wikipedia.org/wiki/Bitwise_operation#Bitwise_operators" target="_blank">bitwise operators</a> are supported on all primitive integer types:</p> <table class="docutils">  <thead valign="bottom"> <tr class="row-odd">
<th class="head">Expression</th> <th class="head">Name</th> </tr> </thead>  <tr class="row-even">
<td><code>~x</code></td> <td>bitwise not</td> </tr> <tr class="row-odd">
<td><code>x &amp; y</code></td> <td>bitwise and</td> </tr> <tr class="row-even">
<td><code>x | y</code></td> <td>bitwise or</td> </tr> <tr class="row-odd">
<td><code>x $ y</code></td> <td>bitwise xor (exclusive or)</td> </tr> <tr class="row-even">
<td><code>x &gt;&gt;&gt; y</code></td> <td>
<a class="reference external" href="https://en.wikipedia.org/wiki/Logical_shift" target="_blank">logical shift</a> right</td> </tr> <tr class="row-odd">
<td><code>x &gt;&gt; y</code></td> <td>
<a class="reference external" href="https://en.wikipedia.org/wiki/Arithmetic_shift" target="_blank">arithmetic shift</a> right</td> </tr> <tr class="row-even">
<td><code>x &lt;&lt; y</code></td> <td>logical/arithmetic shift left</td> </tr>  </table> <p>Here are some examples with bitwise operators:</p> <pre data-language="julia">julia&gt; ~123
-124

julia&gt; 123 &amp; 234
106

julia&gt; 123 | 234
251

julia&gt; 123 $ 234
145

julia&gt; ~UInt32(123)
0xffffff84

julia&gt; ~UInt8(123)
0x84
</pre>   <h2 id="updating-operators">Updating operators</h2> <p>Every binary arithmetic and bitwise operator also has an updating version that assigns the result of the operation back into its left operand. The updating version of the binary operator is formed by placing a <code>=</code> immediately after the operator. For example, writing <code>x += 3</code> is equivalent to writing <code>x = x + 3</code>:</p> <pre data-language="julia">julia&gt; x = 1
1

julia&gt; x += 3
4

julia&gt; x
4
</pre> <p>The updating versions of all the binary arithmetic and bitwise operators are:</p> <pre data-language="julia">+=  -=  *=  /=  \=  ÷=  %=  ^=  &amp;=  |=  $=  &gt;&gt;&gt;=  &gt;&gt;=  &lt;&lt;=
</pre> <div class="admonition note"> <p class="first admonition-title">Note</p> <p>An updating operator rebinds the variable on the left-hand side. As a result, the type of the variable may change.</p> <pre data-language="julia">julia&gt; x = 0x01; typeof(x)
UInt8

julia&gt; x *= 2 #Same as x = x * 2
2

julia&gt; isa(x, Int)
true
</pre> </div>   <h2 id="man-numeric-comparisons">Numeric Comparisons</h2> <p id="numeric-comparisons">Standard comparison operations are defined for all the primitive numeric types:</p> <table class="docutils">  <thead valign="bottom"> <tr class="row-odd">
<th class="head">Operator</th> <th class="head">Name</th> </tr> </thead>  <tr class="row-even">
<td><a class="reference internal" href="../../stdlib/math/#Base.==" title="Base.=="><code>==</code></a></td> <td>equality</td> </tr> <tr class="row-odd">
<td>
<a class="reference internal" href="../../stdlib/math/#Base.!=" title="Base.!="><code>!=</code></a> <a class="reference internal" href="#" title="Base.≠"><code>≠</code></a>
</td> <td>inequality</td> </tr> <tr class="row-even">
<td><a class="reference internal" href="#" title="Base.&lt;"><code>&lt;</code></a></td> <td>less than</td> </tr> <tr class="row-odd">
<td>
<a class="reference internal" href="#" title="Base.&lt;="><code>&lt;=</code></a> <a class="reference internal" href="#" title="Base.≤"><code>≤</code></a>
</td> <td>less than or equal to</td> </tr> <tr class="row-even">
<td><a class="reference internal" href="#" title="Base.&gt;"><code>&gt;</code></a></td> <td>greater than</td> </tr> <tr class="row-odd">
<td>
<a class="reference internal" href="#" title="Base.&gt;="><code>&gt;=</code></a> <a class="reference internal" href="#" title="Base.≥"><code>≥</code></a>
</td> <td>greater than or equal to</td> </tr>  </table> <p>Here are some simple examples:</p> <pre data-language="julia">julia&gt; 1 == 1
true

julia&gt; 1 == 2
false

julia&gt; 1 != 2
true

julia&gt; 1 == 1.0
true

julia&gt; 1 &lt; 2
true

julia&gt; 1.0 &gt; 3
false

julia&gt; 1 &gt;= 1.0
true

julia&gt; -1 &lt;= 1
true

julia&gt; -1 &lt;= -1
true

julia&gt; -1 &lt;= -2
false

julia&gt; 3 &lt; -0.5
false
</pre> <p>Integers are compared in the standard manner — by comparison of bits. Floating-point numbers are compared according to the <a class="reference external" href="https://en.wikipedia.org/wiki/IEEE_754-2008" target="_blank">IEEE 754 standard</a>:</p> <ul class="simple"> <li>Finite numbers are ordered in the usual manner.</li> <li>Positive zero is equal but not greater than negative zero.</li> <li>
<code>Inf</code> is equal to itself and greater than everything else except <code>NaN</code>.</li> <li>
<code>-Inf</code> is equal to itself and less then everything else except <code>NaN</code>.</li> <li>
<code>NaN</code> is not equal to, not less than, and not greater than anything, including itself.</li> </ul> <p>The last point is potentially surprising and thus worth noting:</p> <pre data-language="julia">julia&gt; NaN == NaN
false

julia&gt; NaN != NaN
true

julia&gt; NaN &lt; NaN
false

julia&gt; NaN &gt; NaN
false
</pre> <p>and can cause especial headaches with <a class="reference internal" href="../arrays/#man-arrays"><span>Arrays</span></a>:</p> <pre data-language="julia">julia&gt; [1 NaN] == [1 NaN]
false
</pre> <p>Julia provides additional functions to test numbers for special values, which can be useful in situations like hash key comparisons:</p> <table class="docutils">  <thead valign="bottom"> <tr class="row-odd">
<th class="head">Function</th> <th class="head">Tests if</th> </tr> </thead>  <tr class="row-even">
<td><a class="reference internal" href="../../stdlib/base/#Base.isequal" title="Base.isequal"><code>isequal(x, y)</code></a></td> <td>
<code>x</code> and <code>y</code> are identical</td> </tr> <tr class="row-odd">
<td><a class="reference internal" href="../../stdlib/numbers/#Base.isfinite" title="Base.isfinite"><code>isfinite(x)</code></a></td> <td>
<code>x</code> is a finite number</td> </tr> <tr class="row-even">
<td><a class="reference internal" href="../../stdlib/numbers/#Base.isinf" title="Base.isinf"><code>isinf(x)</code></a></td> <td>
<code>x</code> is infinite</td> </tr> <tr class="row-odd">
<td><a class="reference internal" href="../../stdlib/numbers/#Base.isnan" title="Base.isnan"><code>isnan(x)</code></a></td> <td>
<code>x</code> is not a number</td> </tr>  </table> <p><a class="reference internal" href="../../stdlib/base/#Base.isequal" title="Base.isequal"><code>isequal()</code></a> considers <code>NaN</code>s equal to each other:</p> <pre data-language="julia">julia&gt; isequal(NaN,NaN)
true

julia&gt; isequal([1 NaN], [1 NaN])
true

julia&gt; isequal(NaN,NaN32)
true
</pre> <p><a class="reference internal" href="../../stdlib/base/#Base.isequal" title="Base.isequal"><code>isequal()</code></a> can also be used to distinguish signed zeros:</p> <pre data-language="julia">julia&gt; -0.0 == 0.0
true

julia&gt; isequal(-0.0, 0.0)
false
</pre> <p>Mixed-type comparisons between signed integers, unsigned integers, and floats can be tricky. A great deal of care has been taken to ensure that Julia does them correctly.</p> <p>For other types, <a class="reference internal" href="../../stdlib/base/#Base.isequal" title="Base.isequal"><code>isequal()</code></a> defaults to calling <a class="reference internal" href="../../stdlib/math/#Base.==" title="Base.=="><code>==()</code></a>, so if you want to define equality for your own types then you only need to add a <a class="reference internal" href="../../stdlib/math/#Base.==" title="Base.=="><code>==()</code></a> method. If you define your own equality function, you should probably define a corresponding <a class="reference internal" href="../../stdlib/base/#Base.hash" title="Base.hash"><code>hash()</code></a> method to ensure that <code>isequal(x,y)</code> implies <code>hash(x) == hash(y)</code>.</p>  <h3 id="chaining-comparisons">Chaining comparisons</h3> <p>Unlike most languages, with the <a class="reference external" href="https://en.wikipedia.org/wiki/Python_syntax_and_semantics#Comparison_operators" target="_blank">notable exception of Python</a>, comparisons can be arbitrarily chained:</p> <pre data-language="julia">julia&gt; 1 &lt; 2 &lt;= 2 &lt; 3 == 3 &gt; 2 &gt;= 1 == 1 &lt; 3 != 5
true
</pre> <p>Chaining comparisons is often quite convenient in numerical code. Chained comparisons use the <code>&amp;&amp;</code> operator for scalar comparisons, and the <a class="reference internal" href="../../stdlib/math/#Base.&amp;" title="Base.&amp;"><code>&amp;</code></a> operator for elementwise comparisons, which allows them to work on arrays. For example, <code>0 .&lt; A .&lt; 1</code> gives a boolean array whose entries are true where the corresponding elements of <code>A</code> are between 0 and 1.</p> <p>The operator <a class="reference internal" href="#" title="Base..&lt;"><code>.&lt;</code></a> is intended for array objects; the operation <code>A .&lt; B</code> is valid only if <code>A</code> and <code>B</code> have the same dimensions. The operator returns an array with boolean entries and with the same dimensions as <code>A</code> and <code>B</code>. Such operators are called <em>elementwise</em>; Julia offers a suite of elementwise operators: <a class="reference internal" href="../../stdlib/math/#Base..*" title="Base..*"><code>.*</code></a>, <a class="reference internal" href="../../stdlib/math/#Base..+" title="Base..+"><code>.+</code></a>, etc. Some of the elementwise operators can take a scalar operand such as the example <code>0 .&lt; A .&lt; 1</code> in the preceding paragraph. This notation means that the scalar operand should be replicated for each entry of the array.</p> <p>Note the evaluation behavior of chained comparisons:</p> <pre data-language="julia">julia&gt; v(x) = (println(x); x)
v (generic function with 1 method)

julia&gt; v(1) &lt; v(2) &lt;= v(3)
2
1
3
true

julia&gt; v(1) &gt; v(2) &lt;= v(3)
2
1
false
</pre> <p>The middle expression is only evaluated once, rather than twice as it would be if the expression were written as <code>v(1) &lt; v(2) &amp;&amp; v(2) &lt;= v(3)</code>. However, the order of evaluations in a chained comparison is undefined. It is strongly recommended not to use expressions with side effects (such as printing) in chained comparisons. If side effects are required, the short-circuit <code>&amp;&amp;</code> operator should be used explicitly (see <a class="reference internal" href="../control-flow/#man-short-circuit-evaluation"><span>Short-Circuit Evaluation</span></a>).</p>   <h3 id="operator-precedence">Operator Precedence</h3> <p>Julia applies the following order of operations, from highest precedence to lowest:</p> <table class="docutils">  <thead valign="bottom"> <tr class="row-odd">
<th class="head">Category</th> <th class="head">Operators</th> </tr> </thead>  <tr class="row-even">
<td>Syntax</td> <td>
<code>.</code> followed by <code>::</code>
</td> </tr> <tr class="row-odd">
<td>Exponentiation</td> <td>
<code>^</code> and its elementwise equivalent <code>.^</code>
</td> </tr> <tr class="row-even">
<td>Fractions</td> <td>
<code>//</code> and <code>.//</code>
</td> </tr> <tr class="row-odd">
<td>Multiplication</td> <td>
<code>* / % &amp; \</code> and <code>.* ./ .% .\</code>
</td> </tr> <tr class="row-even">
<td>Bitshifts</td> <td>
<code>&lt;&lt; &gt;&gt; &gt;&gt;&gt;</code> and <code>.&lt;&lt; .&gt;&gt; .&gt;&gt;&gt;</code>
</td> </tr> <tr class="row-odd">
<td>Addition</td> <td>
<code>+ - | $</code> and <code>.+ .-</code>
</td> </tr> <tr class="row-even">
<td>Syntax</td> <td>
<code>: ..</code> followed by <code>|&gt;</code>
</td> </tr> <tr class="row-odd">
<td>Comparisons</td> <td>
<code>&gt; &lt; &gt;= &lt;= == === != !== &lt;:</code> and <code>.&gt; .&lt; .&gt;= .&lt;= .== .!=</code>
</td> </tr> <tr class="row-even">
<td>Control flow</td> <td>
<code>&amp;&amp;</code> followed by <code>||</code> followed by <code>?</code>
</td> </tr> <tr class="row-odd">
<td>Assignments</td> <td>
<code>= += -= *= /= //= \= ^= ÷= %= |= &amp;= $= &lt;&lt;= &gt;&gt;= &gt;&gt;&gt;=</code> and <code>.+= .-= .*= ./= .//= .\= .^= .÷= .%=</code>
</td> </tr>  </table>   <h3 id="man-elementary-functions">Elementary Functions</h3> <p id="elementary-functions">Julia provides a comprehensive collection of mathematical functions and operators. These mathematical operations are defined over as broad a class of numerical values as permit sensible definitions, including integers, floating-point numbers, rationals, and complexes, wherever such definitions make sense.</p> <p>Moreover, these functions (like any Julia function) can be applied in “vectorized” fashion to arrays and other collections with the syntax <code>f.(A)</code>, e.g. <code>sin.(A)</code> will compute the elementwise sine of each element of an array <code>A</code>. See <a class="reference internal" href="../functions/#man-dot-vectorizing"><span>Dot Syntax for Vectorizing Functions</span></a>:.</p>    <h2 id="man-numerical-conversions">Numerical Conversions</h2> <p id="numerical-conversions">Julia supports three forms of numerical conversion, which differ in their handling of inexact conversions.</p> <ul class="simple"> <li>The notation <code>T(x)</code> or <code>convert(T,x)</code> converts <code>x</code> to a value of type <code>T</code>.<ul> <li>If <code>T</code> is a floating-point type, the result is the nearest representable value, which could be positive or negative infinity.</li> <li>If <code>T</code> is an integer type, an <code>InexactError</code> is raised if <code>x</code> is not representable by <code>T</code>.</li> </ul> </li> <li>
<code>x % T</code> converts an integer <code>x</code> to a value of integer type <code>T</code> congruent to <code>x</code> modulo <code>2^n</code>, where <code>n</code> is the number of bits in <code>T</code>. In other words, the binary representation is truncated to fit.</li> <li>The <a class="reference internal" href="#man-rounding-functions"><span>Rounding functions</span></a> take a type <code>T</code> as an optional argument. For example, <code>round(Int,x)</code> is a shorthand for <code>Int(round(x))</code>.</li> </ul> <p>The following examples show the different forms.</p> <pre data-language="julia">julia&gt; Int8(127)
127

julia&gt; Int8(128)
ERROR: InexactError()
 in Int8(::Int64) at ./sysimg.jl:53
 ...

julia&gt; Int8(127.0)
127

julia&gt; Int8(3.14)
ERROR: InexactError()
 in Int8(::Float64) at ./sysimg.jl:53
 ...

julia&gt; Int8(128.0)
ERROR: InexactError()
 in Int8(::Float64) at ./sysimg.jl:53
 ...

julia&gt; 127 % Int8
127

julia&gt; 128 % Int8
-128

julia&gt; round(Int8,127.4)
127

julia&gt; round(Int8,127.6)
ERROR: InexactError()
 in trunc(::Type{Int8}, ::Float64) at ./float.jl:458
 in round(::Type{Int8}, ::Float64) at ./float.jl:211
 ...
</pre> <p>See <a class="reference internal" href="../conversion-and-promotion/#man-conversion-and-promotion"><span>Conversion and Promotion</span></a> for how to define your own conversions and promotions.</p>  <h3 id="man-rounding-functions">Rounding functions</h3> <table class="docutils" id="rounding-functions">  <thead valign="bottom"> <tr class="row-odd">
<th class="head">Function</th> <th class="head">Description</th> <th class="head">Return type</th> </tr> </thead>  <tr class="row-even">
<td><a class="reference internal" href="../../stdlib/math/#Base.round" title="Base.round"><code>round(x)</code></a></td> <td>round <code>x</code> to the nearest integer</td> <td><code>typeof(x)</code></td> </tr> <tr class="row-odd">
<td><a class="reference internal" href="../../stdlib/math/#Base.round" title="Base.round"><code>round(T, x)</code></a></td> <td>round <code>x</code> to the nearest integer</td> <td><code>T</code></td> </tr> <tr class="row-even">
<td><a class="reference internal" href="../../stdlib/math/#Base.floor" title="Base.floor"><code>floor(x)</code></a></td> <td>round <code>x</code> towards <code>-Inf</code>
</td> <td><code>typeof(x)</code></td> </tr> <tr class="row-odd">
<td><a class="reference internal" href="../../stdlib/math/#Base.floor" title="Base.floor"><code>floor(T, x)</code></a></td> <td>round <code>x</code> towards <code>-Inf</code>
</td> <td><code>T</code></td> </tr> <tr class="row-even">
<td><a class="reference internal" href="../../stdlib/math/#Base.ceil" title="Base.ceil"><code>ceil(x)</code></a></td> <td>round <code>x</code> towards <code>+Inf</code>
</td> <td><code>typeof(x)</code></td> </tr> <tr class="row-odd">
<td><a class="reference internal" href="../../stdlib/math/#Base.ceil" title="Base.ceil"><code>ceil(T, x)</code></a></td> <td>round <code>x</code> towards <code>+Inf</code>
</td> <td><code>T</code></td> </tr> <tr class="row-even">
<td><a class="reference internal" href="../../stdlib/math/#Base.trunc" title="Base.trunc"><code>trunc(x)</code></a></td> <td>round <code>x</code> towards zero</td> <td><code>typeof(x)</code></td> </tr> <tr class="row-odd">
<td><a class="reference internal" href="../../stdlib/math/#Base.trunc" title="Base.trunc"><code>trunc(T, x)</code></a></td> <td>round <code>x</code> towards zero</td> <td><code>T</code></td> </tr>  </table>   <h3 id="division-functions">Division functions</h3> <table class="docutils">  <thead valign="bottom"> <tr class="row-odd">
<th class="head">Function</th> <th class="head">Description</th> </tr> </thead>  <tr class="row-even">
<td><a class="reference internal" href="../../stdlib/math/#Base.div" title="Base.div"><code>div(x,y)</code></a></td> <td>truncated division; quotient rounded towards zero</td> </tr> <tr class="row-odd">
<td><a class="reference internal" href="../../stdlib/math/#Base.fld" title="Base.fld"><code>fld(x,y)</code></a></td> <td>floored division; quotient rounded towards <code>-Inf</code>
</td> </tr> <tr class="row-even">
<td><a class="reference internal" href="../../stdlib/math/#Base.cld" title="Base.cld"><code>cld(x,y)</code></a></td> <td>ceiling division; quotient rounded towards <code>+Inf</code>
</td> </tr> <tr class="row-odd">
<td><a class="reference internal" href="../../stdlib/math/#Base.rem" title="Base.rem"><code>rem(x,y)</code></a></td> <td>remainder; satisfies <code>x == div(x,y)*y + rem(x,y)</code>; sign matches <code>x</code>
</td> </tr> <tr class="row-even">
<td><a class="reference internal" href="../../stdlib/math/#Base.mod" title="Base.mod"><code>mod(x,y)</code></a></td> <td>modulus; satisfies <code>x == fld(x,y)*y + mod(x,y)</code>; sign matches <code>y</code>
</td> </tr> <tr class="row-odd">
<td><a class="reference internal" href="../../stdlib/math/#Base.mod1" title="Base.mod1"><code>mod1(x,y)</code></a></td> <td>
<code>mod()</code> with offset 1; returns <code>r∈(0,y]</code> for <code>y&gt;0</code> or <code>r∈[y,0)</code> for <code>y&lt;0</code>, where <code>mod(r, y) == mod(x, y)</code>
</td> </tr> <tr class="row-even">
<td><a class="reference internal" href="../../stdlib/math/#Base.mod2pi" title="Base.mod2pi"><code>mod2pi(x)</code></a></td> <td>modulus with respect to 2pi; <code>0 &lt;= mod2pi(x)  &lt; 2pi</code>
</td> </tr> <tr class="row-odd">
<td><a class="reference internal" href="../../stdlib/math/#Base.divrem" title="Base.divrem"><code>divrem(x,y)</code></a></td> <td>returns <code>(div(x,y),rem(x,y))</code>
</td> </tr> <tr class="row-even">
<td><a class="reference internal" href="../../stdlib/math/#Base.fldmod" title="Base.fldmod"><code>fldmod(x,y)</code></a></td> <td>returns <code>(fld(x,y),mod(x,y))</code>
</td> </tr> <tr class="row-odd">
<td><a class="reference internal" href="../../stdlib/math/#Base.gcd" title="Base.gcd"><code>gcd(x,y...)</code></a></td> <td>greatest positive common divisor of <code>x</code>, <code>y</code>,...</td> </tr> <tr class="row-even">
<td><a class="reference internal" href="../../stdlib/math/#Base.lcm" title="Base.lcm"><code>lcm(x,y...)</code></a></td> <td>least positive common multiple of <code>x</code>, <code>y</code>,...</td> </tr>  </table>   <h3 id="sign-and-absolute-value-functions">Sign and absolute value functions</h3> <table class="docutils">  <thead valign="bottom"> <tr class="row-odd">
<th class="head">Function</th> <th class="head">Description</th> </tr> </thead>  <tr class="row-even">
<td><a class="reference internal" href="../../stdlib/math/#Base.abs" title="Base.abs"><code>abs(x)</code></a></td> <td>a positive value with the magnitude of <code>x</code>
</td> </tr> <tr class="row-odd">
<td><a class="reference internal" href="../../stdlib/math/#Base.abs2" title="Base.abs2"><code>abs2(x)</code></a></td> <td>the squared magnitude of <code>x</code>
</td> </tr> <tr class="row-even">
<td><a class="reference internal" href="../../stdlib/math/#Base.sign" title="Base.sign"><code>sign(x)</code></a></td> <td>indicates the sign of <code>x</code>, returning -1, 0, or +1</td> </tr> <tr class="row-odd">
<td><a class="reference internal" href="../../stdlib/math/#Base.signbit" title="Base.signbit"><code>signbit(x)</code></a></td> <td>indicates whether the sign bit is on (true) or off (false)</td> </tr> <tr class="row-even">
<td><a class="reference internal" href="../../stdlib/math/#Base.copysign" title="Base.copysign"><code>copysign(x,y)</code></a></td> <td>a value with the magnitude of <code>x</code> and the sign of <code>y</code>
</td> </tr> <tr class="row-odd">
<td><a class="reference internal" href="../../stdlib/math/#Base.flipsign" title="Base.flipsign"><code>flipsign(x,y)</code></a></td> <td>a value with the magnitude of <code>x</code> and the sign of <code>x*y</code>
</td> </tr>  </table>   <h3 id="powers-logs-and-roots">Powers, logs and roots</h3> <table class="docutils">  <thead valign="bottom"> <tr class="row-odd">
<th class="head">Function</th> <th class="head">Description</th> </tr> </thead>  <tr class="row-even">
<td>
<a class="reference internal" href="../../stdlib/math/#Base.sqrt" title="Base.sqrt"><code>sqrt(x)</code></a> <code>√x</code>
</td> <td>square root of <code>x</code>
</td> </tr> <tr class="row-odd">
<td>
<a class="reference internal" href="../../stdlib/math/#Base.cbrt" title="Base.cbrt"><code>cbrt(x)</code></a> <code>∛x</code>
</td> <td>cube root of <code>x</code>
</td> </tr> <tr class="row-even">
<td><a class="reference internal" href="../../stdlib/math/#Base.hypot" title="Base.hypot"><code>hypot(x,y)</code></a></td> <td>hypotenuse of right-angled triangle with other sides of length <code>x</code> and <code>y</code>
</td> </tr> <tr class="row-odd">
<td><a class="reference internal" href="../../stdlib/math/#Base.exp" title="Base.exp"><code>exp(x)</code></a></td> <td>natural exponential function at <code>x</code>
</td> </tr> <tr class="row-even">
<td><a class="reference internal" href="../../stdlib/math/#Base.expm1" title="Base.expm1"><code>expm1(x)</code></a></td> <td>accurate <code>exp(x)-1</code> for <code>x</code> near zero</td> </tr> <tr class="row-odd">
<td><a class="reference internal" href="../../stdlib/math/#Base.ldexp" title="Base.ldexp"><code>ldexp(x,n)</code></a></td> <td>
<code>x*2^n</code> computed efficiently for integer values of <code>n</code>
</td> </tr> <tr class="row-even">
<td><a class="reference internal" href="../../stdlib/math/#Base.log" title="Base.log"><code>log(x)</code></a></td> <td>natural logarithm of <code>x</code>
</td> </tr> <tr class="row-odd">
<td><a class="reference internal" href="../../stdlib/math/#Base.log" title="Base.log"><code>log(b,x)</code></a></td> <td>base <code>b</code> logarithm of <code>x</code>
</td> </tr> <tr class="row-even">
<td><a class="reference internal" href="../../stdlib/math/#Base.log2" title="Base.log2"><code>log2(x)</code></a></td> <td>base 2 logarithm of <code>x</code>
</td> </tr> <tr class="row-odd">
<td><a class="reference internal" href="../../stdlib/math/#Base.log10" title="Base.log10"><code>log10(x)</code></a></td> <td>base 10 logarithm of <code>x</code>
</td> </tr> <tr class="row-even">
<td><a class="reference internal" href="../../stdlib/math/#Base.log1p" title="Base.log1p"><code>log1p(x)</code></a></td> <td>accurate <code>log(1+x)</code> for <code>x</code> near zero</td> </tr> <tr class="row-odd">
<td><a class="reference internal" href="../../stdlib/numbers/#Base.exponent" title="Base.exponent"><code>exponent(x)</code></a></td> <td>binary exponent of <code>x</code>
</td> </tr> <tr class="row-even">
<td><a class="reference internal" href="../../stdlib/numbers/#Base.significand" title="Base.significand"><code>significand(x)</code></a></td> <td>binary significand (a.k.a. mantissa) of a floating-point number <code>x</code>
</td> </tr>  </table> <p>For an overview of why functions like <a class="reference internal" href="../../stdlib/math/#Base.hypot" title="Base.hypot"><code>hypot()</code></a>, <a class="reference internal" href="../../stdlib/math/#Base.expm1" title="Base.expm1"><code>expm1()</code></a>, and <a class="reference internal" href="../../stdlib/math/#Base.log1p" title="Base.log1p"><code>log1p()</code></a> are necessary and useful, see John D. Cook’s excellent pair of blog posts on the subject: <a class="reference external" href="http://www.johndcook.com/blog/2010/06/07/math-library-functions-that-seem-unnecessary/" target="_blank">expm1, log1p, erfc</a>, and <a class="reference external" href="http://www.johndcook.com/blog/2010/06/02/whats-so-hard-about-finding-a-hypotenuse/" target="_blank">hypot</a>.</p>   <h3 id="trigonometric-and-hyperbolic-functions">Trigonometric and hyperbolic functions</h3> <p>All the standard trigonometric and hyperbolic functions are also defined:</p> <pre data-language="julia">sin    cos    tan    cot    sec    csc
sinh   cosh   tanh   coth   sech   csch
asin   acos   atan   acot   asec   acsc
asinh  acosh  atanh  acoth  asech  acsch
sinc   cosc   atan2
</pre> <p>These are all single-argument functions, with the exception of <a class="reference external" href="https://en.wikipedia.org/wiki/Atan2" target="_blank">atan2</a>, which gives the angle in <a class="reference external" href="https://en.wikipedia.org/wiki/Radian" target="_blank">radians</a> between the <em>x</em>-axis and the point specified by its arguments, interpreted as <em>x</em> and <em>y</em> coordinates.</p> <p>Additionally, <a class="reference internal" href="../../stdlib/math/#Base.sinpi" title="Base.sinpi"><code>sinpi(x)</code></a> and <a class="reference internal" href="../../stdlib/math/#Base.cospi" title="Base.cospi"><code>cospi(x)</code></a> are provided for more accurate computations of <a class="reference internal" href="../../stdlib/math/#Base.sin" title="Base.sin"><code>sin(pi*x)</code></a> and <a class="reference internal" href="../../stdlib/math/#Base.cos" title="Base.cos"><code>cos(pi*x)</code></a> respectively.</p> <p>In order to compute trigonometric functions with degrees instead of radians, suffix the function with <code>d</code>. For example, <a class="reference internal" href="../../stdlib/math/#Base.sind" title="Base.sind"><code>sind(x)</code></a> computes the sine of <code>x</code> where <code>x</code> is specified in degrees. The complete list of trigonometric functions with degree variants is:</p> <pre data-language="julia">sind   cosd   tand   cotd   secd   cscd
asind  acosd  atand  acotd  asecd  acscd
</pre>   <h3 id="special-functions">Special functions</h3> <table class="docutils">  <thead valign="bottom"> <tr class="row-odd">
<th class="head">Function</th> <th class="head">Description</th> </tr> </thead>  <tr class="row-even">
<td><a class="reference internal" href="../../stdlib/math/#Base.erf" title="Base.erf"><code>erf(x)</code></a></td> <td>
<a class="reference external" href="https://en.wikipedia.org/wiki/Error_function" target="_blank">error function</a> at <code>x</code>
</td> </tr> <tr class="row-odd">
<td><a class="reference internal" href="../../stdlib/math/#Base.erfc" title="Base.erfc"><code>erfc(x)</code></a></td> <td>complementary error function, i.e. the accurate version of <code>1-erf(x)</code> for large <code>x</code>
</td> </tr> <tr class="row-even">
<td><a class="reference internal" href="../../stdlib/math/#Base.erfinv" title="Base.erfinv"><code>erfinv(x)</code></a></td> <td>inverse function to <a class="reference internal" href="../../stdlib/math/#Base.erf" title="Base.erf"><code>erf()</code></a>
</td> </tr> <tr class="row-odd">
<td><code>erfcinv(x)</code></td> <td>inverse function to <a class="reference internal" href="../../stdlib/math/#Base.erfc" title="Base.erfc"><code>erfc()</code></a>
</td> </tr> <tr class="row-even">
<td><a class="reference internal" href="../../stdlib/math/#Base.erfi" title="Base.erfi"><code>erfi(x)</code></a></td> <td>imaginary error function defined as <code>-im * erf(x * im)</code>, where <a class="reference internal" href="../../stdlib/numbers/#Base.im" title="Base.im"><code>im</code></a> is the imaginary unit</td> </tr> <tr class="row-odd">
<td><a class="reference internal" href="../../stdlib/math/#Base.erfcx" title="Base.erfcx"><code>erfcx(x)</code></a></td> <td>scaled complementary error function, i.e. accurate <code>exp(x^2) * erfc(x)</code> for large <code>x</code>
</td> </tr> <tr class="row-even">
<td><a class="reference internal" href="../../stdlib/math/#Base.dawson" title="Base.dawson"><code>dawson(x)</code></a></td> <td>scaled imaginary error function, a.k.a. Dawson function, i.e. accurate <code>exp(-x^2) * erfi(x) * sqrt(pi) / 2</code> for large <code>x</code>
</td> </tr> <tr class="row-odd">
<td><a class="reference internal" href="../../stdlib/math/#Base.gamma" title="Base.gamma"><code>gamma(x)</code></a></td> <td>
<a class="reference external" href="https://en.wikipedia.org/wiki/Gamma_function" target="_blank">gamma function</a> at <code>x</code>
</td> </tr> <tr class="row-even">
<td><a class="reference internal" href="../../stdlib/math/#Base.lgamma" title="Base.lgamma"><code>lgamma(x)</code></a></td> <td>accurate <code>log(gamma(x))</code> for large <code>x</code>
</td> </tr> <tr class="row-odd">
<td><a class="reference internal" href="../../stdlib/math/#Base.lfact" title="Base.lfact"><code>lfact(x)</code></a></td> <td>accurate <code>log(factorial(x))</code> for large <code>x</code>; same as <code>lgamma(x+1)</code> for <code>x &gt; 1</code>, zero otherwise</td> </tr> <tr class="row-even">
<td><a class="reference internal" href="../../stdlib/math/#Base.digamma" title="Base.digamma"><code>digamma(x)</code></a></td> <td>
<a class="reference external" href="https://en.wikipedia.org/wiki/Digamma_function" target="_blank">digamma function</a> (i.e. the derivative of <a class="reference internal" href="../../stdlib/math/#Base.lgamma" title="Base.lgamma"><code>lgamma()</code></a>) at <code>x</code>
</td> </tr> <tr class="row-odd">
<td><a class="reference internal" href="../../stdlib/math/#Base.beta" title="Base.beta"><code>beta(x,y)</code></a></td> <td>
<a class="reference external" href="https://en.wikipedia.org/wiki/Beta_function" target="_blank">beta function</a> at <code>x,y</code>
</td> </tr> <tr class="row-even">
<td><a class="reference internal" href="../../stdlib/math/#Base.lbeta" title="Base.lbeta"><code>lbeta(x,y)</code></a></td> <td>accurate <code>log(beta(x,y))</code> for large <code>x</code> or <code>y</code>
</td> </tr> <tr class="row-odd">
<td><a class="reference internal" href="../../stdlib/math/#Base.eta" title="Base.eta"><code>eta(x)</code></a></td> <td>
<a class="reference external" href="https://en.wikipedia.org/wiki/Dirichlet_eta_function" target="_blank">Dirichlet eta function</a> at <code>x</code>
</td> </tr> <tr class="row-even">
<td><a class="reference internal" href="../../stdlib/math/#Base.zeta" title="Base.zeta"><code>zeta(x)</code></a></td> <td>
<a class="reference external" href="https://en.wikipedia.org/wiki/Riemann_zeta_function" target="_blank">Riemann zeta function</a> at <code>x</code>
</td> </tr> <tr class="row-odd">
<td>
<a class="reference internal" href="../../stdlib/math/#Base.airy" title="Base.airy"><code>airy(z)</code></a>, <a class="reference internal" href="../../stdlib/math/#Base.airyai" title="Base.airyai"><code>airyai(z)</code></a>, <code>airy(0,z)</code>
</td> <td>
<a class="reference external" href="https://en.wikipedia.org/wiki/Airy_function" target="_blank">Airy Ai function</a> at <code>z</code>
</td> </tr> <tr class="row-even">
<td>
<a class="reference internal" href="../../stdlib/math/#Base.airyprime" title="Base.airyprime"><code>airyprime(z)</code></a>, <a class="reference internal" href="../../stdlib/math/#Base.airyaiprime" title="Base.airyaiprime"><code>airyaiprime(z)</code></a>, <code>airy(1,z)</code>
</td> <td>derivative of the Airy Ai function at <code>z</code>
</td> </tr> <tr class="row-odd">
<td>
<a class="reference internal" href="../../stdlib/math/#Base.airybi" title="Base.airybi"><code>airybi(z)</code></a>, <code>airy(2,z)</code>
</td> <td>
<a class="reference external" href="https://en.wikipedia.org/wiki/Airy_function" target="_blank">Airy Bi function</a> at <code>z</code>
</td> </tr> <tr class="row-even">
<td>
<a class="reference internal" href="../../stdlib/math/#Base.airybiprime" title="Base.airybiprime"><code>airybiprime(z)</code></a>, <code>airy(3,z)</code>
</td> <td>derivative of the Airy Bi function at <code>z</code>
</td> </tr> <tr class="row-odd">
<td>
<a class="reference internal" href="../../stdlib/math/#Base.airyx" title="Base.airyx"><code>airyx(z)</code></a>, <code>airyx(k,z)</code>
</td> <td>scaled Airy AI function and <code>k</code> th derivatives at <code>z</code>
</td> </tr> <tr class="row-even">
<td><a class="reference internal" href="../../stdlib/math/#Base.besselj" title="Base.besselj"><code>besselj(nu,z)</code></a></td> <td>
<a class="reference external" href="https://en.wikipedia.org/wiki/Bessel_function" target="_blank">Bessel function</a> of the first kind of order <code>nu</code> at <code>z</code>
</td> </tr> <tr class="row-odd">
<td><a class="reference internal" href="../../stdlib/math/#Base.besselj0" title="Base.besselj0"><code>besselj0(z)</code></a></td> <td><code>besselj(0,z)</code></td> </tr> <tr class="row-even">
<td><a class="reference internal" href="../../stdlib/math/#Base.besselj1" title="Base.besselj1"><code>besselj1(z)</code></a></td> <td><code>besselj(1,z)</code></td> </tr> <tr class="row-odd">
<td><a class="reference internal" href="../../stdlib/math/#Base.besseljx" title="Base.besseljx"><code>besseljx(nu,z)</code></a></td> <td>scaled Bessel function of the first kind of order <code>nu</code> at <code>z</code>
</td> </tr> <tr class="row-even">
<td><a class="reference internal" href="../../stdlib/math/#Base.bessely" title="Base.bessely"><code>bessely(nu,z)</code></a></td> <td>
<a class="reference external" href="https://en.wikipedia.org/wiki/Bessel_function" target="_blank">Bessel function</a> of the second kind of order <code>nu</code> at <code>z</code>
</td> </tr> <tr class="row-odd">
<td><a class="reference internal" href="../../stdlib/math/#Base.bessely0" title="Base.bessely0"><code>bessely0(z)</code></a></td> <td><code>bessely(0,z)</code></td> </tr> <tr class="row-even">
<td><a class="reference internal" href="../../stdlib/math/#Base.bessely0" title="Base.bessely0"><code>bessely1(z)</code></a></td> <td><code>bessely(1,z)</code></td> </tr> <tr class="row-odd">
<td><a class="reference internal" href="../../stdlib/math/#Base.besselyx" title="Base.besselyx"><code>besselyx(nu,z)</code></a></td> <td>scaled Bessel function of the second kind of order <code>nu</code> at <code>z</code>
</td> </tr> <tr class="row-even">
<td><a class="reference internal" href="../../stdlib/math/#Base.besselh" title="Base.besselh"><code>besselh(nu,k,z)</code></a></td> <td>
<a class="reference external" href="https://en.wikipedia.org/wiki/Bessel_function" target="_blank">Bessel function</a> of the third kind (a.k.a. Hankel function) of order <code>nu</code> at <code>z</code>; <code>k</code> must be either <code>1</code> or <code>2</code>
</td> </tr> <tr class="row-odd">
<td><a class="reference internal" href="../../stdlib/math/#Base.hankelh1" title="Base.hankelh1"><code>hankelh1(nu,z)</code></a></td> <td><code>besselh(nu, 1, z)</code></td> </tr> <tr class="row-even">
<td><a class="reference internal" href="../../stdlib/math/#Base.hankelh1x" title="Base.hankelh1x"><code>hankelh1x(nu,z)</code></a></td> <td>scaled <code>besselh(nu, 1, z)</code>
</td> </tr> <tr class="row-odd">
<td><a class="reference internal" href="../../stdlib/math/#Base.hankelh2" title="Base.hankelh2"><code>hankelh2(nu,z)</code></a></td> <td><code>besselh(nu, 2, z)</code></td> </tr> <tr class="row-even">
<td><a class="reference internal" href="../../stdlib/math/#Base.hankelh2x" title="Base.hankelh2x"><code>hankelh2x(nu,z)</code></a></td> <td>scaled <code>besselh(nu, 2, z)</code>
</td> </tr> <tr class="row-odd">
<td><a class="reference internal" href="../../stdlib/math/#Base.besseli" title="Base.besseli"><code>besseli(nu,z)</code></a></td> <td>modified <a class="reference external" href="https://en.wikipedia.org/wiki/Bessel_function" target="_blank">Bessel function</a> of the first kind of order <code>nu</code> at <code>z</code>
</td> </tr> <tr class="row-even">
<td><a class="reference internal" href="../../stdlib/math/#Base.besselix" title="Base.besselix"><code>besselix(nu,z)</code></a></td> <td>scaled modified Bessel function of the first kind of order <code>nu</code> at <code>z</code>
</td> </tr> <tr class="row-odd">
<td><a class="reference internal" href="../../stdlib/math/#Base.besselk" title="Base.besselk"><code>besselk(nu,z)</code></a></td> <td>modified <a class="reference external" href="https://en.wikipedia.org/wiki/Bessel_function" target="_blank">Bessel function</a> of the second kind of order <code>nu</code> at <code>z</code>
</td> </tr> <tr class="row-even">
<td><a class="reference internal" href="../../stdlib/math/#Base.besselkx" title="Base.besselkx"><code>besselkx(nu,z)</code></a></td> <td>scaled modified Bessel function of the second kind of order <code>nu</code> at <code>z</code>
</td> </tr>  </table>
<div class="_attribution">
  <p class="_attribution-p">
    © 2009–2016 Jeff Bezanson, Stefan Karpinski, Viral B. Shah, and other contributors<br>Licensed under the MIT License.<br>
    <a href="http://docs.julialang.org/en/release-0.5/manual/mathematical-operations/" class="_attribution-link" target="_blank">http://docs.julialang.org/en/release-0.5/manual/mathematical-operations/</a>
  </p>
</div>

			</div>
		</div>
	</section>

	</div>
</body>
</html>
