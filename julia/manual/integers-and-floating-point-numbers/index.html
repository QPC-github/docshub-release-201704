
<!DOCTYPE HTML>

<html lang="en">

<head>
  <meta charset="utf-8">
  <title>Integers and Floating-Point Numbers - Julia - W3cubDocs</title>
  
  <meta name="description" content="Integers and floating-point values are the basic building blocks of arithmetic and computation. Built-in representations of such values are called &hellip;">
  <meta name="keywords" content="integers, and, floating-point, numbers, -, julia">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="http://docs.w3cub.com/julia/manual/integers-and-floating-point-numbers/">
  <link href="/favicon.png" rel="icon">
  <link type="text/css" rel="stylesheet" href="/assets/application-50364fff564ce3b6327021805f3f00e2957b441cf27f576a7dd4ff63bbc47047.css">
  <script type="text/javascript" src="/assets/application-db64bfd54ceb42be11af7995804cf4902548419ceb79d509b0b7d62c22d98e6f.js"></script>
  <script src="/json/julia.js"></script>
  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-71174418-1']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>


</head>

<body>
	<div class="_app">
	<header class="_header">
  
  <form class="_search">
    <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
    <a class="_search-clear"></a>
    <div class="_search-tag"></div>
  </form>
  
  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/julia/" class="_nav-link" title="" style="margin-left:0;">Julia</a></span>
  
  <nav class="_nav">
    <a href="/app/" class="_nav-link ">App</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		<div class="_list">
			
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<div class="_page _sphinx_simple">
				
<h1 id="man-integers-and-floating-point-numbers">Integers and Floating-Point Numbers</h1> <p>Integers and floating-point values are the basic building blocks of arithmetic and computation. Built-in representations of such values are called numeric primitives, while representations of integers and floating-point numbers as immediate values in code are known as numeric literals. For example, <code>1</code> is an integer literal, while <code>1.0</code> is a floating-point literal; their binary in-memory representations as objects are numeric primitives.</p> <p>Julia provides a broad range of primitive numeric types, and a full complement of arithmetic and bitwise operators as well as standard mathematical functions are defined over them. These map directly onto numeric types and operations that are natively supported on modern computers, thus allowing Julia to take full advantage of computational resources. Additionally, Julia provides software support for <a class="reference internal" href="#man-arbitrary-precision-arithmetic"><span>Arbitrary Precision Arithmetic</span></a>, which can handle operations on numeric values that cannot be represented effectively in native hardware representations, but at the cost of relatively slower performance.</p> <p>The following are Julia’s primitive numeric types:</p> <ul class="simple"> <li><strong>Integer types:</strong></li> </ul> <table class="docutils">  <thead valign="bottom"> <tr class="row-odd">
<th class="head">Type</th> <th class="head">Signed?</th> <th class="head">Number of bits</th> <th class="head">Smallest value</th> <th class="head">Largest value</th> </tr> </thead>  <tr class="row-even">
<td><code>Int8</code></td> <td>✓</td> <td>8</td> <td>-2^7</td> <td>2^7 - 1</td> </tr> <tr class="row-odd">
<td><code>UInt8</code></td> <td> </td> <td>8</td> <td>0</td> <td>2^8 - 1</td> </tr> <tr class="row-even">
<td><code>Int16</code></td> <td>✓</td> <td>16</td> <td>-2^15</td> <td>2^15 - 1</td> </tr> <tr class="row-odd">
<td><code>UInt16</code></td> <td> </td> <td>16</td> <td>0</td> <td>2^16 - 1</td> </tr> <tr class="row-even">
<td><code>Int32</code></td> <td>✓</td> <td>32</td> <td>-2^31</td> <td>2^31 - 1</td> </tr> <tr class="row-odd">
<td><code>UInt32</code></td> <td> </td> <td>32</td> <td>0</td> <td>2^32 - 1</td> </tr> <tr class="row-even">
<td><code>Int64</code></td> <td>✓</td> <td>64</td> <td>-2^63</td> <td>2^63 - 1</td> </tr> <tr class="row-odd">
<td><code>UInt64</code></td> <td> </td> <td>64</td> <td>0</td> <td>2^64 - 1</td> </tr> <tr class="row-even">
<td><code>Int128</code></td> <td>✓</td> <td>128</td> <td>-2^127</td> <td>2^127 - 1</td> </tr> <tr class="row-odd">
<td><code>UInt128</code></td> <td> </td> <td>128</td> <td>0</td> <td>2^128 - 1</td> </tr> <tr class="row-even">
<td><code>Bool</code></td> <td>N/A</td> <td>8</td> <td>
<code>false</code> (0)</td> <td>
<code>true</code> (1)</td> </tr>  </table> <ul class="simple"> <li><strong>Floating-point types:</strong></li> </ul> <table class="docutils">  <thead valign="bottom"> <tr class="row-odd">
<th class="head">Type</th> <th class="head">Precision</th> <th class="head">Number of bits</th> </tr> </thead>  <tr class="row-even">
<td><code>Float16</code></td> <td><a class="reference external" href="https://en.wikipedia.org/wiki/Half-precision_floating-point_format" target="_blank">half</a></td> <td>16</td> </tr> <tr class="row-odd">
<td><a class="reference internal" href="../../stdlib/numbers/#Base.Float32" title="Base.Float32"><code>Float32</code></a></td> <td><a class="reference external" href="https://en.wikipedia.org/wiki/Single_precision_floating-point_format" target="_blank">single</a></td> <td>32</td> </tr> <tr class="row-even">
<td><a class="reference internal" href="../../stdlib/numbers/#Base.Float64" title="Base.Float64"><code>Float64</code></a></td> <td><a class="reference external" href="https://en.wikipedia.org/wiki/Double_precision_floating-point_format" target="_blank">double</a></td> <td>64</td> </tr>  </table> <p>Additionally, full support for <a class="reference internal" href="../complex-and-rational-numbers/#man-complex-and-rational-numbers"><span>Complex and Rational Numbers</span></a> is built on top of these primitive numeric types. All numeric types interoperate naturally without explicit casting, thanks to a flexible, user-extensible <a class="reference internal" href="../conversion-and-promotion/#man-conversion-and-promotion"><span>type promotion system</span></a>.</p>  <h2 id="integers">Integers</h2> <p>Literal integers are represented in the standard manner:</p> <pre data-language="julia">julia&gt; 1
1

julia&gt; 1234
1234
</pre> <p>The default type for an integer literal depends on whether the target system has a 32-bit architecture or a 64-bit architecture:</p> <pre data-language="julia"># 32-bit system:
julia&gt; typeof(1)
Int32

# 64-bit system:
julia&gt; typeof(1)
Int64
</pre> <p>The Julia internal variable <a class="reference internal" href="../../stdlib/constants/#Base.Sys.WORD_SIZE" title="Base.Sys.WORD_SIZE"><code>Sys.WORD_SIZE</code></a> indicates whether the target system is 32-bit or 64-bit.:</p> <pre data-language="julia"># 32-bit system:
julia&gt; Sys.WORD_SIZE
32

# 64-bit system:
julia&gt; Sys.WORD_SIZE
64
</pre> <p>Julia also defines the types <code>Int</code> and <code>UInt</code>, which are aliases for the system’s signed and unsigned native integer types respectively.:</p> <pre data-language="julia"># 32-bit system:
julia&gt; Int
Int32
julia&gt; UInt
UInt32


# 64-bit system:
julia&gt; Int
Int64
julia&gt; UInt
UInt64
</pre> <p>Larger integer literals that cannot be represented using only 32 bits but can be represented in 64 bits always create 64-bit integers, regardless of the system type:</p> <pre data-language="julia"># 32-bit or 64-bit system:
julia&gt; typeof(3000000000)
Int64
</pre> <p>Unsigned integers are input and output using the <code>0x</code> prefix and hexadecimal (base 16) digits <code>0-9a-f</code> (the capitalized digits <code>A-F</code> also work for input). The size of the unsigned value is determined by the number of hex digits used:</p> <pre data-language="julia">julia&gt; 0x1
0x01

julia&gt; typeof(ans)
UInt8

julia&gt; 0x123
0x0123

julia&gt; typeof(ans)
UInt16

julia&gt; 0x1234567
0x01234567

julia&gt; typeof(ans)
UInt32

julia&gt; 0x123456789abcdef
0x0123456789abcdef

julia&gt; typeof(ans)
UInt64
</pre> <p>This behavior is based on the observation that when one uses unsigned hex literals for integer values, one typically is using them to represent a fixed numeric byte sequence, rather than just an integer value.</p> <p>Recall that the variable <a class="reference internal" href="../../stdlib/base/#Base.ans" title="Base.ans"><code>ans</code></a> is set to the value of the last expression evaluated in an interactive session. This does not occur when Julia code is run in other ways.</p> <p>Binary and octal literals are also supported:</p> <pre data-language="julia">julia&gt; 0b10
0x02

julia&gt; typeof(ans)
UInt8

julia&gt; 0o10
0x08

julia&gt; typeof(ans)
UInt8
</pre> <p>The minimum and maximum representable values of primitive numeric types such as integers are given by the <a class="reference internal" href="../../stdlib/base/#Base.typemin" title="Base.typemin"><code>typemin()</code></a> and <a class="reference internal" href="../../stdlib/base/#Base.typemax" title="Base.typemax"><code>typemax()</code></a> functions:</p> <pre data-language="julia">julia&gt; (typemin(Int32), typemax(Int32))
(-2147483648,2147483647)

julia&gt; for T in [Int8,Int16,Int32,Int64,Int128,UInt8,UInt16,UInt32,UInt64,UInt128]
         println("$(lpad(T,7)): [$(typemin(T)),$(typemax(T))]")
       end
   Int8: [-128,127]
  Int16: [-32768,32767]
  Int32: [-2147483648,2147483647]
  Int64: [-9223372036854775808,9223372036854775807]
 Int128: [-170141183460469231731687303715884105728,170141183460469231731687303715884105727]
  UInt8: [0,255]
 UInt16: [0,65535]
 UInt32: [0,4294967295]
 UInt64: [0,18446744073709551615]
UInt128: [0,340282366920938463463374607431768211455]
</pre> <p>The values returned by <a class="reference internal" href="../../stdlib/base/#Base.typemin" title="Base.typemin"><code>typemin()</code></a> and <a class="reference internal" href="../../stdlib/base/#Base.typemax" title="Base.typemax"><code>typemax()</code></a> are always of the given argument type. (The above expression uses several features we have yet to introduce, including <a class="reference internal" href="../control-flow/#man-loops"><span>for loops</span></a>, <a class="reference internal" href="../strings/#man-strings"><span>Strings</span></a>, and <a class="reference internal" href="../strings/#man-string-interpolation"><span>Interpolation</span></a>, but should be easy enough to understand for users with some existing programming experience.)</p>  <h3 id="overflow-behavior">Overflow behavior</h3> <p>In Julia, exceeding the maximum representable value of a given type results in a wraparound behavior:</p> <pre data-language="julia">julia&gt; x = typemax(Int64)
9223372036854775807

julia&gt; x + 1
-9223372036854775808

julia&gt; x + 1 == typemin(Int64)
true
</pre> <p>Thus, arithmetic with Julia integers is actually a form of <a class="reference external" href="https://en.wikipedia.org/wiki/Modular_arithmetic" target="_blank">modular arithmetic</a>. This reflects the characteristics of the underlying arithmetic of integers as implemented on modern computers. In applications where overflow is possible, explicit checking for wraparound produced by overflow is essential; otherwise, the <code>BigInt</code> type in <a class="reference internal" href="#man-arbitrary-precision-arithmetic"><span>Arbitrary Precision Arithmetic</span></a> is recommended instead.</p>   <h3 id="division-errors">Division errors</h3> <p>Integer division (the <code>div</code> function) has two exceptional cases: dividing by zero, and dividing the lowest negative number (<a class="reference internal" href="../../stdlib/base/#Base.typemin" title="Base.typemin"><code>typemin()</code></a>) by -1. Both of these cases throw a <a class="reference internal" href="../../stdlib/base/#Base.DivideError" title="Base.DivideError"><code>DivideError</code></a>. The remainder and modulus functions (<code>rem</code> and <code>mod</code>) throw a <a class="reference internal" href="../../stdlib/base/#Base.DivideError" title="Base.DivideError"><code>DivideError</code></a> when their second argument is zero.</p>    <h2 id="floating-point-numbers">Floating-Point Numbers</h2> <p>Literal floating-point numbers are represented in the standard formats:</p> <pre data-language="julia">julia&gt; 1.0
1.0

julia&gt; 1.
1.0

julia&gt; 0.5
0.5

julia&gt; .5
0.5

julia&gt; -1.23
-1.23

julia&gt; 1e10
1.0e10

julia&gt; 2.5e-4
0.00025
</pre> <p>The above results are all <code>Float64</code> values. Literal <code>Float32</code> values can be entered by writing an <code>f</code> in place of <code>e</code>:</p> <pre data-language="julia">julia&gt; 0.5f0
0.5f0

julia&gt; typeof(ans)
Float32

julia&gt; 2.5f-4
0.00025f0
</pre> <p>Values can be converted to <code>Float32</code> easily:</p> <pre data-language="julia">julia&gt; Float32(-1.5)
-1.5f0

julia&gt; typeof(ans)
Float32
</pre> <p>Hexadecimal floating-point literals are also valid, but only as <code>Float64</code> values:</p> <pre data-language="julia">julia&gt; 0x1p0
1.0

julia&gt; 0x1.8p3
12.0

julia&gt; 0x.4p-1
0.125

julia&gt; typeof(ans)
Float64
</pre> <p>Half-precision floating-point numbers are also supported (<code>Float16</code>), but only as a storage format. In calculations they’ll be converted to <code>Float32</code>:</p> <pre data-language="julia">julia&gt; sizeof(Float16(4.))
2

julia&gt; 2*Float16(4.)
8.0f0
</pre> <p>The underscore <code>_</code> can be used as digit separator:</p> <pre data-language="julia">julia&gt; 10_000, 0.000_000_005, 0xdead_beef, 0b1011_0010
(10000,5.0e-9,0xdeadbeef,0xb2)
</pre>  <h3 id="floating-point-zero">Floating-point zero</h3> <p>Floating-point numbers have <a class="reference external" href="https://en.wikipedia.org/wiki/Signed_zero" target="_blank">two zeros</a>, positive zero and negative zero. They are equal to each other but have different binary representations, as can be seen using the <code>bits</code> function: :</p> <pre data-language="julia">julia&gt; 0.0 == -0.0
true

julia&gt; bits(0.0)
"0000000000000000000000000000000000000000000000000000000000000000"

julia&gt; bits(-0.0)
"1000000000000000000000000000000000000000000000000000000000000000"
</pre>   <h3 id="man-special-floats">Special floating-point values</h3> <p id="special-floating-point-values">There are three specified standard floating-point values that do not correspond to any point on the real number line:</p> <table class="docutils">  <thead valign="bottom"> <tr class="row-odd">
<th class="head" colspan="3">Special value</th> <th class="head">Name</th> <th class="head">Description</th> </tr> <tr class="row-even">
<th class="head"><code>Float16</code></th> <th class="head"><code>Float32</code></th> <th class="head"><code>Float64</code></th> <th class="head"> </th> <th class="head"> </th> </tr> </thead>  <tr class="row-odd">
<td><code>Inf16</code></td> <td><code>Inf32</code></td> <td><code>Inf</code></td> <td>positive infinity</td> <td>a value greater than all finite floating-point values</td> </tr> <tr class="row-even">
<td><code>-Inf16</code></td> <td><code>-Inf32</code></td> <td><code>-Inf</code></td> <td>negative infinity</td> <td>a value less than all finite floating-point values</td> </tr> <tr class="row-odd">
<td><code>NaN16</code></td> <td><code>NaN32</code></td> <td><code>NaN</code></td> <td>not a number</td> <td>a value not <code>==</code> to any floating-point value (including itself)</td> </tr>  </table> <p>For further discussion of how these non-finite floating-point values are ordered with respect to each other and other floats, see <a class="reference internal" href="../mathematical-operations/#man-numeric-comparisons"><span>Numeric Comparisons</span></a>. By the <a class="reference external" href="https://en.wikipedia.org/wiki/IEEE_754-2008" target="_blank">IEEE 754 standard</a>, these floating-point values are the results of certain arithmetic operations:</p> <pre data-language="julia">julia&gt; 1/Inf
0.0

julia&gt; 1/0
Inf

julia&gt; -5/0
-Inf

julia&gt; 0.000001/0
Inf

julia&gt; 0/0
NaN

julia&gt; 500 + Inf
Inf

julia&gt; 500 - Inf
-Inf

julia&gt; Inf + Inf
Inf

julia&gt; Inf - Inf
NaN

julia&gt; Inf * Inf
Inf

julia&gt; Inf / Inf
NaN

julia&gt; 0 * Inf
NaN
</pre> <p>The <a class="reference internal" href="../../stdlib/base/#Base.typemin" title="Base.typemin"><code>typemin()</code></a> and <a class="reference internal" href="../../stdlib/base/#Base.typemax" title="Base.typemax"><code>typemax()</code></a> functions also apply to floating-point types:</p> <pre data-language="julia">julia&gt; (typemin(Float16),typemax(Float16))
(-Inf16,Inf16)

julia&gt; (typemin(Float32),typemax(Float32))
(-Inf32,Inf32)

julia&gt; (typemin(Float64),typemax(Float64))
(-Inf,Inf)
</pre>   <h3 id="machine-epsilon">Machine epsilon</h3> <p>Most real numbers cannot be represented exactly with floating-point numbers, and so for many purposes it is important to know the distance between two adjacent representable floating-point numbers, which is often known as <a class="reference external" href="https://en.wikipedia.org/wiki/Machine_epsilon" target="_blank">machine epsilon</a>.</p> <p>Julia provides <a class="reference internal" href="../../stdlib/base/#Base.eps" title="Base.eps"><code>eps()</code></a>, which gives the distance between <code>1.0</code> and the next larger representable floating-point value:</p> <pre data-language="julia">julia&gt; eps(Float32)
1.1920929f-7

julia&gt; eps(Float64)
2.220446049250313e-16

julia&gt; eps() # same as eps(Float64)
2.220446049250313e-16
</pre> <p>These values are <code>2.0^-23</code> and <code>2.0^-52</code> as <code>Float32</code> and <code>Float64</code> values, respectively. The <a class="reference internal" href="../../stdlib/base/#Base.eps" title="Base.eps"><code>eps()</code></a> function can also take a floating-point value as an argument, and gives the absolute difference between that value and the next representable floating point value. That is, <code>eps(x)</code> yields a value of the same type as <code>x</code> such that <code>x + eps(x)</code> is the next representable floating-point value larger than <code>x</code>:</p> <pre data-language="julia">julia&gt; eps(1.0)
2.220446049250313e-16

julia&gt; eps(1000.)
1.1368683772161603e-13

julia&gt; eps(1e-27)
1.793662034335766e-43

julia&gt; eps(0.0)
5.0e-324
</pre> <p>The distance between two adjacent representable floating-point numbers is not constant, but is smaller for smaller values and larger for larger values. In other words, the representable floating-point numbers are densest in the real number line near zero, and grow sparser exponentially as one moves farther away from zero. By definition, <code>eps(1.0)</code> is the same as <code>eps(Float64)</code> since <code>1.0</code> is a 64-bit floating-point value.</p> <p>Julia also provides the <a class="reference internal" href="../../stdlib/numbers/#Base.nextfloat" title="Base.nextfloat"><code>nextfloat()</code></a> and <a class="reference internal" href="../../stdlib/numbers/#Base.prevfloat" title="Base.prevfloat"><code>prevfloat()</code></a> functions which return the next largest or smallest representable floating-point number to the argument respectively: :</p> <pre data-language="julia">julia&gt; x = 1.25f0
1.25f0

julia&gt; nextfloat(x)
1.2500001f0

julia&gt; prevfloat(x)
1.2499999f0

julia&gt; bits(prevfloat(x))
"00111111100111111111111111111111"

julia&gt; bits(x)
"00111111101000000000000000000000"

julia&gt; bits(nextfloat(x))
"00111111101000000000000000000001"
</pre> <p>This example highlights the general principle that the adjacent representable floating-point numbers also have adjacent binary integer representations.</p>   <h3 id="rounding-modes">Rounding modes</h3> <p>If a number doesn’t have an exact floating-point representation, it must be rounded to an appropriate representable value, however, if wanted, the manner in which this rounding is done can be changed according to the rounding modes presented in the <a class="reference external" href="https://en.wikipedia.org/wiki/IEEE_754-2008" target="_blank">IEEE 754 standard</a>.</p> <pre data-language="julia">julia&gt; x = 1.1; y = 0.1;

julia&gt; x + y
1.2000000000000002

julia&gt; setrounding(Float64,RoundDown) do
           x + y
       end
1.2
</pre> <p>The default mode used is always <a class="reference internal" href="../../stdlib/math/#Base.RoundNearest" title="Base.RoundNearest"><code>RoundNearest</code></a>, which rounds to the nearest representable value, with ties rounded towards the nearest value with an even least significant bit.</p> <div class="admonition warning"> <p class="first admonition-title">Warning</p> <p class="last">Rounding is generally only correct for basic arithmetic functions (<a class="reference internal" href="../../stdlib/math/#Base.+" title="Base.+"><code>+()</code></a>, <a class="reference internal" href="../../stdlib/math/#Base.-" title="Base.-"><code>-()</code></a>, <a class="reference internal" href="../../stdlib/strings/#Base.*" title="Base.*"><code>*()</code></a>, <a class="reference internal" href="../../stdlib/math/#Base./" title="Base./"><code>/()</code></a> and <a class="reference internal" href="../../stdlib/math/#Base.sqrt" title="Base.sqrt"><code>sqrt()</code></a>) and type conversion operations. Many other functions assume the default <a class="reference internal" href="../../stdlib/math/#Base.RoundNearest" title="Base.RoundNearest"><code>RoundNearest</code></a> mode is set, and can give erroneous results when operating under other rounding modes.</p> </div>   <h3 id="background-and-references">Background and References</h3> <p>Floating-point arithmetic entails many subtleties which can be surprising to users who are unfamiliar with the low-level implementation details. However, these subtleties are described in detail in most books on scientific computation, and also in the following references:</p> <ul class="simple"> <li>The definitive guide to floating point arithmetic is the <a class="reference external" href="http://standards.ieee.org/findstds/standard/754-2008.html" target="_blank">IEEE 754-2008 Standard</a>; however, it is not available for free online.</li> <li>For a brief but lucid presentation of how floating-point numbers are represented, see John D. Cook’s <a class="reference external" href="http://www.johndcook.com/blog/2009/04/06/anatomy-of-a-floating-point-number/" target="_blank">article</a> on the subject as well as his <a class="reference external" href="http://www.johndcook.com/blog/2009/04/06/numbers-are-a-leaky-abstraction/" target="_blank">introduction</a> to some of the issues arising from how this representation differs in behavior from the idealized abstraction of real numbers.</li> <li>Also recommended is Bruce Dawson’s <a class="reference external" href="https://randomascii.wordpress.com/2012/05/20/thats-not-normalthe-performance-of-odd-floats/" target="_blank">series of blog posts on floating-point numbers</a>.</li> <li>For an excellent, in-depth discussion of floating-point numbers and issues of numerical accuracy encountered when computing with them, see David Goldberg’s paper <a class="reference external" href="http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.22.6768&amp;rep=rep1&amp;type=pdf" target="_blank">What Every Computer Scientist Should Know About Floating-Point Arithmetic</a>.</li> <li>For even more extensive documentation of the history of, rationale for, and issues with floating-point numbers, as well as discussion of many other topics in numerical computing, see the <a class="reference external" href="https://people.eecs.berkeley.edu/~wkahan/" target="_blank">collected writings</a> of <a class="reference external" href="https://en.wikipedia.org/wiki/William_Kahan" target="_blank">William Kahan</a>, commonly known as the “Father of Floating-Point”. Of particular interest may be <a class="reference external" href="https://people.eecs.berkeley.edu/~wkahan/ieee754status/754story.html" target="_blank">An Interview with the Old Man of Floating-Point</a>.</li> </ul>    <h2 id="man-arbitrary-precision-arithmetic">Arbitrary Precision Arithmetic</h2> <p id="arbitrary-precision-arithmetic">To allow computations with arbitrary-precision integers and floating point numbers, Julia wraps the <a class="reference external" href="https://gmplib.org" target="_blank">GNU Multiple Precision Arithmetic Library (GMP)</a> and the <a class="reference external" href="http://www.mpfr.org" target="_blank">GNU MPFR Library</a>, respectively. The <a class="reference internal" href="../../stdlib/numbers/#Base.BigInt" title="Base.BigInt"><code>BigInt</code></a> and <a class="reference internal" href="../../stdlib/numbers/#Base.BigFloat" title="Base.BigFloat"><code>BigFloat</code></a> types are available in Julia for arbitrary precision integer and floating point numbers respectively.</p> <p>Constructors exist to create these types from primitive numerical types, and <a class="reference internal" href="../../stdlib/numbers/#Base.parse" title="Base.parse"><code>parse()</code></a> can be use to construct them from <code>AbstractString</code>s. Once created, they participate in arithmetic with all other numeric types thanks to Julia’s <a class="reference internal" href="../conversion-and-promotion/#man-conversion-and-promotion"><span>type promotion and conversion mechanism</span></a>:</p> <pre data-language="julia">julia&gt; BigInt(typemax(Int64)) + 1
9223372036854775808

julia&gt; parse(BigInt, "123456789012345678901234567890") + 1
123456789012345678901234567891

julia&gt; parse(BigFloat, "1.23456789012345678901")
1.234567890123456789010000000000000000000000000000000000000000000000000000000004

julia&gt; BigFloat(2.0^66) / 3
2.459565876494606882133333333333333333333333333333333333333333333333333333333344e+19

julia&gt; factorial(BigInt(40))
815915283247897734345611269596115894272000000000
</pre> <p>However, type promotion between the primitive types above and <a class="reference internal" href="../../stdlib/numbers/#Base.BigInt" title="Base.BigInt"><code>BigInt</code></a>/<a class="reference internal" href="../../stdlib/numbers/#Base.BigFloat" title="Base.BigFloat"><code>BigFloat</code></a> is not automatic and must be explicitly stated.</p> <pre data-language="julia">julia&gt; x = typemin(Int64)
-9223372036854775808

julia&gt; x = x - 1
9223372036854775807

julia&gt; typeof(x)
Int64

julia&gt; y = BigInt(typemin(Int64))
-9223372036854775808

julia&gt; y = y - 1
-9223372036854775809

julia&gt; typeof(y)
BigInt
</pre> <p>The default precision (in number of bits of the significand) and rounding mode of <a class="reference internal" href="../../stdlib/numbers/#Base.BigFloat" title="Base.BigFloat"><code>BigFloat</code></a> operations can be changed globally by calling <a class="reference internal" href="../../stdlib/numbers/#Base.setprecision" title="Base.setprecision"><code>setprecision()</code></a> and <a class="reference internal" href="../../stdlib/numbers/#Base.setrounding" title="Base.setrounding"><code>setrounding()</code></a>, and all further calculations will take these changes in account. Alternatively, the precision or the rounding can be changed only within the execution of a particular block of code by using the same functions with a <code>do</code> block:</p> <pre data-language="julia">julia&gt; setrounding(BigFloat, RoundUp) do
       BigFloat(1) + parse(BigFloat, "0.1")
       end
1.100000000000000000000000000000000000000000000000000000000000000000000000000003

julia&gt; setrounding(BigFloat, RoundDown) do
       BigFloat(1) + parse(BigFloat, "0.1")
       end
1.099999999999999999999999999999999999999999999999999999999999999999999999999986

julia&gt; setprecision(40) do
       BigFloat(1) + parse(BigFloat, "0.1")
       end
1.1000000000004
</pre>   <h2 id="man-numeric-literal-coefficients">Numeric Literal Coefficients</h2> <p id="numeric-literal-coefficients">To make common numeric formulas and expressions clearer, Julia allows variables to be immediately preceded by a numeric literal, implying multiplication. This makes writing polynomial expressions much cleaner:</p> <pre data-language="julia">julia&gt; x = 3
3

julia&gt; 2x^2 - 3x + 1
10

julia&gt; 1.5x^2 - .5x + 1
13.0
</pre> <p>It also makes writing exponential functions more elegant:</p> <pre data-language="julia">julia&gt; 2^2x
64
</pre> <p>The precedence of numeric literal coefficients is the same as that of unary operators such as negation. So <code>2^3x</code> is parsed as <code>2^(3x)</code>, and <code>2x^3</code> is parsed as <code>2*(x^3)</code>.</p> <p>Numeric literals also work as coefficients to parenthesized expressions:</p> <pre data-language="julia">julia&gt; 2(x-1)^2 - 3(x-1) + 1
3
</pre> <p>Additionally, parenthesized expressions can be used as coefficients to variables, implying multiplication of the expression by the variable:</p> <pre data-language="julia">julia&gt; (x-1)x
6
</pre> <p>Neither juxtaposition of two parenthesized expressions, nor placing a variable before a parenthesized expression, however, can be used to imply multiplication:</p> <pre data-language="julia">julia&gt; (x-1)(x+1)
ERROR: MethodError: objects of type Int64 are not callable
...

julia&gt; x(x+1)
ERROR: MethodError: objects of type Int64 are not callable
...
</pre> <p>Both expressions are interpreted as function application: any expression that is not a numeric literal, when immediately followed by a parenthetical, is interpreted as a function applied to the values in parentheses (see <a class="reference internal" href="../functions/#man-functions"><span>Functions</span></a> for more about functions). Thus, in both of these cases, an error occurs since the left-hand value is not a function.</p> <p>The above syntactic enhancements significantly reduce the visual noise incurred when writing common mathematical formulae. Note that no whitespace may come between a numeric literal coefficient and the identifier or parenthesized expression which it multiplies.</p>  <h3 id="syntax-conflicts">Syntax Conflicts</h3> <p>Juxtaposed literal coefficient syntax may conflict with two numeric literal syntaxes: hexadecimal integer literals and engineering notation for floating-point literals. Here are some situations where syntactic conflicts arise:</p> <ul class="simple"> <li>The hexadecimal integer literal expression <code>0xff</code> could be interpreted as the numeric literal <code>0</code> multiplied by the variable <code>xff</code>.</li> <li>The floating-point literal expression <code>1e10</code> could be interpreted as the numeric literal <code>1</code> multiplied by the variable <code>e10</code>, and similarly with the equivalent <code>E</code> form.</li> </ul> <p>In both cases, we resolve the ambiguity in favor of interpretation as a numeric literals:</p> <ul class="simple"> <li>Expressions starting with <code>0x</code> are always hexadecimal literals.</li> <li>Expressions starting with a numeric literal followed by <code>e</code> or <code>E</code> are always floating-point literals.</li> </ul>    <h2 id="literal-zero-and-one">Literal zero and one</h2> <p>Julia provides functions which return literal 0 and 1 corresponding to a specified type or the type of a given variable.</p> <table class="docutils">  <thead valign="bottom"> <tr class="row-odd">
<th class="head">Function</th> <th class="head">Description</th> </tr> </thead>  <tr class="row-even">
<td><a class="reference internal" href="../../stdlib/numbers/#Base.zero" title="Base.zero"><code>zero(x)</code></a></td> <td>Literal zero of type <code>x</code> or type of variable <code>x</code>
</td> </tr> <tr class="row-odd">
<td><a class="reference internal" href="../../stdlib/numbers/#Base.one" title="Base.one"><code>one(x)</code></a></td> <td>Literal one of type <code>x</code> or type of variable <code>x</code>
</td> </tr>  </table> <p>These functions are useful in <a class="reference internal" href="../mathematical-operations/#man-numeric-comparisons"><span>Numeric Comparisons</span></a> to avoid overhead from unnecessary <a class="reference internal" href="../conversion-and-promotion/#man-conversion-and-promotion"><span>type conversion</span></a>.</p> <p>Examples:</p> <pre data-language="julia">julia&gt; zero(Float32)
0.0f0

julia&gt; zero(1.0)
0.0

julia&gt; one(Int32)
1

julia&gt; one(BigFloat)
1.000000000000000000000000000000000000000000000000000000000000000000000000000000
</pre>
<div class="_attribution">
  <p class="_attribution-p">
    © 2009–2016 Jeff Bezanson, Stefan Karpinski, Viral B. Shah, and other contributors<br>Licensed under the MIT License.<br>
    <a href="http://docs.julialang.org/en/release-0.5/manual/integers-and-floating-point-numbers/" class="_attribution-link" target="_blank">http://docs.julialang.org/en/release-0.5/manual/integers-and-floating-point-numbers/</a>
  </p>
</div>

			</div>
		</div>
	</section>

	</div>
</body>
</html>
