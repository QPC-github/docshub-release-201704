
<!DOCTYPE HTML>

<html lang="en">

<head>
  <meta charset="utf-8">
  <title>Multi-dimensional Arrays - Julia - W3cubDocs</title>
  
  <meta name="description" content="Julia, like most technical computing languages, provides a first-class array implementation. Most technical computing languages pay a lot of &hellip;">
  <meta name="keywords" content="multi-dimensional, arrays, -, julia">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="http://docs.w3cub.com/julia/manual/arrays/">
  <link href="/favicon.png" rel="icon">
  <link type="text/css" rel="stylesheet" href="/assets/application-50364fff564ce3b6327021805f3f00e2957b441cf27f576a7dd4ff63bbc47047.css">
  <script type="text/javascript" src="/assets/application-db64bfd54ceb42be11af7995804cf4902548419ceb79d509b0b7d62c22d98e6f.js"></script>
  <script src="/json/julia.js"></script>
  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-71174418-1']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>


</head>

<body>
	<div class="_app">
	<header class="_header">
  
  <form class="_search">
    <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
    <a class="_search-clear"></a>
    <div class="_search-tag"></div>
  </form>
  
  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/julia/" class="_nav-link" title="" style="margin-left:0;">Julia</a></span>
  
  <nav class="_nav">
    <a href="/app/" class="_nav-link ">App</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		<div class="_list">
			
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<div class="_page _sphinx_simple">
				
<h1 id="man-arrays">Multi-dimensional Arrays</h1> <p>Julia, like most technical computing languages, provides a first-class array implementation. Most technical computing languages pay a lot of attention to their array implementation at the expense of other containers. Julia does not treat arrays in any special way. The array library is implemented almost completely in Julia itself, and derives its performance from the compiler, just like any other code written in Julia. As such, it’s also possible to define custom array types by inheriting from <code>AbstractArray.</code> See the <a class="reference internal" href="../interfaces/#man-interfaces-abstractarray"><span>manual section on the AbstractArray interface</span></a> for more details on implementing a custom array type.</p> <p>An array is a collection of objects stored in a multi-dimensional grid. In the most general case, an array may contain objects of type <code>Any</code>. For most computational purposes, arrays should contain objects of a more specific type, such as <code>Float64</code> or <code>Int32</code>.</p> <p>In general, unlike many other technical computing languages, Julia does not expect programs to be written in a vectorized style for performance. Julia’s compiler uses type inference and generates optimized code for scalar array indexing, allowing programs to be written in a style that is convenient and readable, without sacrificing performance, and using less memory at times.</p> <p>In Julia, all arguments to functions are passed by reference. Some technical computing languages pass arrays by value, and this is convenient in many cases. In Julia, modifications made to input arrays within a function will be visible in the parent function. The entire Julia array library ensures that inputs are not modified by library functions. User code, if it needs to exhibit similar behavior, should take care to create a copy of inputs that it may modify.</p>  <h2 id="arrays">Arrays</h2>  <h3 id="basic-functions">Basic Functions</h3> <table class="docutils">  <thead valign="bottom"> <tr class="row-odd">
<th class="head">Function</th> <th class="head">Description</th> </tr> </thead>  <tr class="row-even">
<td><a class="reference internal" href="../../stdlib/collections/#Base.eltype" title="Base.eltype"><code>eltype(A)</code></a></td> <td>the type of the elements contained in <code>A</code>
</td> </tr> <tr class="row-odd">
<td><a class="reference internal" href="../../stdlib/strings/#Base.length" title="Base.length"><code>length(A)</code></a></td> <td>the number of elements in <code>A</code>
</td> </tr> <tr class="row-even">
<td><a class="reference internal" href="../../stdlib/arrays/#Base.ndims" title="Base.ndims"><code>ndims(A)</code></a></td> <td>the number of dimensions of <code>A</code>
</td> </tr> <tr class="row-odd">
<td><a class="reference internal" href="../../stdlib/arrays/#Base.size" title="Base.size"><code>size(A)</code></a></td> <td>a tuple containing the dimensions of <code>A</code>
</td> </tr> <tr class="row-even">
<td><a class="reference internal" href="../../stdlib/arrays/#Base.size" title="Base.size"><code>size(A,n)</code></a></td> <td>the size of <code>A</code> along a particular dimension</td> </tr> <tr class="row-odd">
<td><a class="reference internal" href="../../stdlib/arrays/#Base.indices" title="Base.indices"><code>indices(A)</code></a></td> <td>a tuple containing the valid indices of <code>A</code>
</td> </tr> <tr class="row-even">
<td><a class="reference internal" href="../../stdlib/arrays/#Base.indices" title="Base.indices"><code>indices(A,n)</code></a></td> <td>a range expressing the valid indices along dimension <code>n</code>
</td> </tr> <tr class="row-odd">
<td><a class="reference internal" href="../../stdlib/arrays/#Base.eachindex" title="Base.eachindex"><code>eachindex(A)</code></a></td> <td>an efficient iterator for visiting each position in <code>A</code>
</td> </tr> <tr class="row-even">
<td><a class="reference internal" href="../../stdlib/arrays/#Base.stride" title="Base.stride"><code>stride(A,k)</code></a></td> <td>the stride (linear index distance between adjacent elements) along dimension <code>k</code>
</td> </tr> <tr class="row-odd">
<td><a class="reference internal" href="../../stdlib/arrays/#Base.strides" title="Base.strides"><code>strides(A)</code></a></td> <td>a tuple of the strides in each dimension</td> </tr>  </table>   <h3 id="construction-and-initialization">Construction and Initialization</h3> <p>Many functions for constructing and initializing arrays are provided. In the following list of such functions, calls with a <code>dims...</code> argument can either take a single tuple of dimension sizes or a series of dimension sizes passed as a variable number of arguments.</p> <table class="docutils">  <thead valign="bottom"> <tr class="row-odd">
<th class="head">Function</th> <th class="head">Description</th> </tr> </thead>  <tr class="row-even">
<td><a class="reference internal" href="../../stdlib/arrays/#Base.Array" title="Base.Array"><code>Array{type}(dims...)</code></a></td> <td>an uninitialized dense array</td> </tr> <tr class="row-odd">
<td><a class="reference internal" href="../../stdlib/arrays/#Base.zeros" title="Base.zeros"><code>zeros(type, dims...)</code></a></td> <td>an array of all zeros of specified type, defaults to <code>Float64</code> if <code>type</code> not specified</td> </tr> <tr class="row-even">
<td><a class="reference internal" href="../../stdlib/arrays/#Base.zeros" title="Base.zeros"><code>zeros(A)</code></a></td> <td>an array of all zeros of same element type and shape of <code>A</code>
</td> </tr> <tr class="row-odd">
<td><a class="reference internal" href="../../stdlib/arrays/#Base.ones" title="Base.ones"><code>ones(type, dims...)</code></a></td> <td>an array of all ones of specified type, defaults to <code>Float64</code> if <code>type</code> not specified</td> </tr> <tr class="row-even">
<td><a class="reference internal" href="../../stdlib/arrays/#Base.ones" title="Base.ones"><code>ones(A)</code></a></td> <td>an array of all ones of same element type and shape of <code>A</code>
</td> </tr> <tr class="row-odd">
<td><a class="reference internal" href="../../stdlib/arrays/#Base.trues" title="Base.trues"><code>trues(dims...)</code></a></td> <td>a <code>Bool</code> array with all values <code>true</code>
</td> </tr> <tr class="row-even">
<td><a class="reference internal" href="../../stdlib/arrays/#Base.trues" title="Base.trues"><code>trues(A)</code></a></td> <td>a <code>Bool</code> array with all values <code>true</code> and the shape of <code>A</code>
</td> </tr> <tr class="row-odd">
<td><a class="reference internal" href="../../stdlib/arrays/#Base.falses" title="Base.falses"><code>falses(dims...)</code></a></td> <td>a <code>Bool</code> array with all values <code>false</code>
</td> </tr> <tr class="row-even">
<td><a class="reference internal" href="../../stdlib/arrays/#Base.falses" title="Base.falses"><code>falses(A)</code></a></td> <td>a <code>Bool</code> array with all values <code>false</code> and the shape of <code>A</code>
</td> </tr> <tr class="row-odd">
<td><a class="reference internal" href="../../stdlib/arrays/#Base.reshape" title="Base.reshape"><code>reshape(A, dims...)</code></a></td> <td>an array with the same data as the given array, but with different dimensions.</td> </tr> <tr class="row-even">
<td><a class="reference internal" href="../../stdlib/base/#Base.copy" title="Base.copy"><code>copy(A)</code></a></td> <td>copy <code>A</code>
</td> </tr> <tr class="row-odd">
<td><a class="reference internal" href="../../stdlib/base/#Base.deepcopy" title="Base.deepcopy"><code>deepcopy(A)</code></a></td> <td>copy <code>A</code>, recursively copying its elements</td> </tr> <tr class="row-even">
<td><a class="reference internal" href="../../stdlib/arrays/#Base.similar" title="Base.similar"><code>similar(A, element_type, dims...)</code></a></td> <td>an uninitialized array of the same type as the given array (dense, sparse, etc.), but with the specified element type and dimensions. The second and third arguments are both optional, defaulting to the element type and dimensions of <code>A</code> if omitted.</td> </tr> <tr class="row-odd">
<td><a class="reference internal" href="../../stdlib/arrays/#Base.reinterpret" title="Base.reinterpret"><code>reinterpret(type, A)</code></a></td> <td>an array with the same binary data as the given array, but with the specified element type</td> </tr> <tr class="row-even">
<td><a class="reference internal" href="../../stdlib/numbers/#Base.rand" title="Base.rand"><code>rand(dims)</code></a></td> <td>
<a class="reference internal" href="../../stdlib/arrays/#Base.Array" title="Base.Array"><code>Array</code></a> of <code>Float64</code>s with random, iid <a class="footnote-reference" href="#iid" id="id1">[1]</a> and uniformly distributed values in the half-open interval <span class="math">\([0, 1)\)</span>
</td> </tr> <tr class="row-odd">
<td><a class="reference internal" href="../../stdlib/numbers/#Base.randn" title="Base.randn"><code>randn(dims)</code></a></td> <td>
<a class="reference internal" href="../../stdlib/arrays/#Base.Array" title="Base.Array"><code>Array</code></a> of <code>Float64</code>s with random, iid and standard normally distributed random values</td> </tr> <tr class="row-even">
<td><a class="reference internal" href="../../stdlib/arrays/#Base.eye" title="Base.eye"><code>eye(n)</code></a></td> <td>
<code>n</code>-by-<code>n</code> identity matrix</td> </tr> <tr class="row-odd">
<td><a class="reference internal" href="../../stdlib/arrays/#Base.eye" title="Base.eye"><code>eye(m, n)</code></a></td> <td>
<code>m</code>-by-<code>n</code> identity matrix</td> </tr> <tr class="row-even">
<td><a class="reference internal" href="../../stdlib/arrays/#Base.linspace" title="Base.linspace"><code>linspace(start, stop, n)</code></a></td> <td>range of <code>n</code> linearly spaced elements from <code>start</code> to <code>stop</code>
</td> </tr> <tr class="row-odd">
<td><a class="reference internal" href="../../stdlib/arrays/#Base.fill!" title="Base.fill!"><code>fill!(A, x)</code></a></td> <td>fill the array <code>A</code> with the value <code>x</code>
</td> </tr> <tr class="row-even">
<td><a class="reference internal" href="../../stdlib/arrays/#Base.fill" title="Base.fill"><code>fill(x, dims)</code></a></td> <td>create an array filled with the value <code>x</code>
</td> </tr>  </table> <table class="docutils footnote" frame="void" id="iid" rules="none">   <tr>
<td class="label"><a class="fn-backref" href="#id1">[1]</a></td>
<td>
<em>iid</em>, independently and identically distributed.</td>
</tr>  </table> <p>The syntax <code>[A, B, C, ...]</code> constructs a 1-d array (vector) of its arguments.</p>   <h3 id="concatenation">Concatenation</h3> <p>Arrays can be constructed and also concatenated using the following functions:</p> <table class="docutils">  <thead valign="bottom"> <tr class="row-odd">
<th class="head">Function</th> <th class="head">Description</th> </tr> </thead>  <tr class="row-even">
<td><a class="reference internal" href="../../stdlib/arrays/#Base.cat" title="Base.cat"><code>cat(k, A...)</code></a></td> <td>concatenate input n-d arrays along the dimension <code>k</code>
</td> </tr> <tr class="row-odd">
<td><a class="reference internal" href="../../stdlib/arrays/#Base.vcat" title="Base.vcat"><code>vcat(A...)</code></a></td> <td>shorthand for <code>cat(1, A...)</code>
</td> </tr> <tr class="row-even">
<td><a class="reference internal" href="../../stdlib/arrays/#Base.hcat" title="Base.hcat"><code>hcat(A...)</code></a></td> <td>shorthand for <code>cat(2, A...)</code>
</td> </tr>  </table> <p>Scalar values passed to these functions are treated as 1-element arrays.</p> <p>The concatenation functions are used so often that they have special syntax:</p> <table class="docutils">  <thead valign="bottom"> <tr class="row-odd">
<th class="head">Expression</th> <th class="head">Calls</th> </tr> </thead>  <tr class="row-even">
<td><code>[A; B; C; ...]</code></td> <td><a class="reference internal" href="../../stdlib/arrays/#Base.vcat" title="Base.vcat"><code>vcat()</code></a></td> </tr> <tr class="row-odd">
<td><code>[A B C ...]</code></td> <td><a class="reference internal" href="../../stdlib/arrays/#Base.hcat" title="Base.hcat"><code>hcat()</code></a></td> </tr> <tr class="row-even">
<td><code>[A B; C D; ...]</code></td> <td><a class="reference internal" href="../../stdlib/arrays/#Base.hvcat" title="Base.hvcat"><code>hvcat()</code></a></td> </tr>  </table> <p><a class="reference internal" href="../../stdlib/arrays/#Base.hvcat" title="Base.hvcat"><code>hvcat()</code></a> concatenates in both dimension 1 (with semicolons) and dimension 2 (with spaces).</p>   <h3 id="typed-array-initializers">Typed array initializers</h3> <p>An array with a specific element type can be constructed using the syntax <code>T[A, B, C, ...]</code>. This will construct a 1-d array with element type <code>T</code>, initialized to contain elements <code>A</code>, <code>B</code>, <code>C</code>, etc. For example <code>Any[x, y, z]</code> constructs a heterogeneous array that can contain any values.</p> <p>Concatenation syntax can similarly be prefixed with a type to specify the element type of the result.</p> <pre data-language="julia">julia&gt; [[1 2] [3 4]]
1×4 Array{Int64,2}:
 1  2  3  4

julia&gt; Int8[[1 2] [3 4]]
1×4 Array{Int8,2}:
 1  2  3  4
</pre>   <h3 id="id2">Comprehensions</h3> <p id="comprehensions">Comprehensions provide a general and powerful way to construct arrays. Comprehension syntax is similar to set construction notation in mathematics:</p> <pre data-language="julia">A = [ F(x,y,...) for x=rx, y=ry, ... ]
</pre> <p>The meaning of this form is that <code>F(x,y,...)</code> is evaluated with the variables <code>x</code>, <code>y</code>, etc. taking on each value in their given list of values. Values can be specified as any iterable object, but will commonly be ranges like <code>1:n</code> or <code>2:(n-1)</code>, or explicit arrays of values like <code>[1.2, 3.4, 5.7]</code>. The result is an N-d dense array with dimensions that are the concatenation of the dimensions of the variable ranges <code>rx</code>, <code>ry</code>, etc. and each <code>F(x,y,...)</code> evaluation returns a scalar.</p> <p>The following example computes a weighted average of the current element and its left and right neighbor along a 1-d grid. :</p> <pre data-language="julia">julia&gt; x = rand(8)
8-element Array{Float64,1}:
 0.843025
 0.869052
 0.365105
 0.699456
 0.977653
 0.994953
 0.41084
 0.809411

julia&gt; [ 0.25*x[i-1] + 0.5*x[i] + 0.25*x[i+1] for i=2:length(x)-1 ]
6-element Array{Float64,1}:
 0.736559
 0.57468
 0.685417
 0.912429
 0.8446
 0.656511
</pre> <p>The resulting array type depends on the types of the computed elements. In order to control the type explicitly, a type can be prepended to the comprehension. For example, we could have requested the result in single precision by writing:</p> <pre data-language="julia">Float32[ 0.25*x[i-1] + 0.5*x[i] + 0.25*x[i+1] for i=2:length(x)-1 ]
</pre>   <h3 id="man-generator-expressions">Generator Expressions</h3> <p id="generator-expressions">Comprehensions can also be written without the enclosing square brackets, producing an object known as a generator. This object can be iterated to produce values on demand, instead of allocating an array and storing them in advance (see <a class="reference internal" href="../interfaces/#man-interfaces-iteration"><span>Iteration</span></a>). For example, the following expression sums a series without allocating memory:</p> <pre data-language="julia">julia&gt; sum(1/n^2 for n=1:1000)
1.6439345666815615
</pre> <p>When writing a generator expression with multiple dimensions inside an argument list, parentheses are needed to separate the generator from subsequent arguments:</p> <pre data-language="julia">julia&gt; map(tuple, 1/(i+j) for i=1:2, j=1:2, [1:4;])
ERROR: syntax: invalid iteration specification
</pre> <p>All comma-separated expressions after <code>for</code> are interpreted as ranges. Adding parentheses lets us add a third argument to <code>map</code>:</p> <pre data-language="julia">julia&gt; map(tuple, (1/(i+j) for i=1:2, j=1:2), [1 3; 2 4])
2×2 Array{Tuple{Float64,Int64},2}:
 (0.5,1)       (0.333333,3)
 (0.333333,2)  (0.25,4)
</pre> <p>Ranges in generators and comprehensions can depend on previous ranges by writing multiple <code>for</code> keywords:</p> <pre data-language="julia">julia&gt; [(i,j) for i=1:3 for j=1:i]
6-element Array{Tuple{Int64,Int64},1}:
 (1,1)
 (2,1)
 (2,2)
 (3,1)
 (3,2)
 (3,3)
</pre> <p>In such cases, the result is always 1-d.</p> <p>Generated values can be filtered using the <code>if</code> keyword:</p> <pre data-language="julia">julia&gt; [(i,j) for i=1:3 for j=1:i if i+j == 4]
2-element Array{Tuple{Int64,Int64},1}:
 (2,2)
 (3,1)
</pre>   <h3 id="man-array-indexing">Indexing</h3> <p id="indexing">The general syntax for indexing into an n-dimensional array A is:</p> <pre data-language="julia">X = A[I_1, I_2, ..., I_n]
</pre> <p>where each <code>I_k</code> may be:</p> <ol class="arabic simple"> <li>A scalar integer</li> <li>A <code>Range</code> of the form <code>a:b</code>, or <code>a:b:c</code>
</li> <li>A <code>:</code> or <code>Colon()</code> to select entire dimensions</li> <li>An arbitrary integer array, including the empty array <code>[]</code>
</li> <li>A boolean array to select a vector of elements at its <code>true</code> indices</li> </ol> <p>If all the indices are scalars, then the result <code>X</code> is a single element from the array <code>A</code>. Otherwise, <code>X</code> is an array with the same number of dimensions as the sum of the dimensionalities of all the indices.</p> <p>If all indices are vectors, for example, then the shape of <code>X</code> would be <code>(length(I_1), length(I_2), ..., length(I_n))</code>, with location <code>(i_1, i_2, ..., i_n)</code> of <code>X</code> containing the value <code>A[I_1[i_1], I_2[i_2], ..., I_n[i_n]]</code>. If <code>I_1</code> is changed to a two-dimensional matrix, then <code>X</code> becomes an <code>n+1</code>-dimensional array of shape <code>(size(I_1, 1), size(I_1, 2), length(I_2), ..., length(I_n))</code>. The matrix adds a dimension. The location <code>(i_1, i_2, i_3, ..., i_{n+1})</code> contains the value at <code>A[I_1[i_1, i_2], I_2[i_3], ..., I_n[i_{n+1}]]</code>. All dimensions indexed with scalars are dropped. For example, the result of <code>A[2, I, 3]</code> is an array with size <code>size(I)</code>. Its <code>i</code>th element is populated by <code>A[2, I[i], 3]</code>.</p> <p>Indexing by a boolean array <code>B</code> is effectively the same as indexing by the vector that is returned by <a class="reference internal" href="../../stdlib/arrays/#Base.find" title="Base.find"><code>find(B)</code></a>. Often referred to as logical indexing, this selects elements at the indices where the values are <code>true</code>, akin to a mask. A logical index must be a vector of the same length as the dimension it indexes into, or it must be the only index provided and match the size and dimensionality of the array it indexes into. It is generally more efficient to use boolean arrays as indices directly instead of first calling <a class="reference internal" href="../../stdlib/arrays/#Base.find" title="Base.find"><code>find()</code></a>.</p> <p>Additionally, single elements of a multidimensional array can be indexed as <code>x = A[I]</code>, where <code>I</code> is a <code>CartesianIndex</code>. It effectively behaves like an <code>n</code>-tuple of integers spanning multiple dimensions of <code>A</code>. See <a class="reference internal" href="#man-array-iteration"><span>Iteration</span></a> below.</p> <p>As a special part of this syntax, the <code>end</code> keyword may be used to represent the last index of each dimension within the indexing brackets, as determined by the size of the innermost array being indexed. Indexing syntax without the <code>end</code> keyword is equivalent to a call to <code>getindex</code>:</p> <pre data-language="julia">X = getindex(A, I_1, I_2, ..., I_n)
</pre> <p>Example:</p> <pre data-language="julia">julia&gt; x = reshape(1:16, 4, 4)
4×4 Base.ReshapedArray{Int64,2,UnitRange{Int64},Tuple{}}:
 1  5   9  13
 2  6  10  14
 3  7  11  15
 4  8  12  16

julia&gt; x[2:3, 2:end-1]
2×2 Array{Int64,2}:
 6  10
 7  11

julia&gt; x[map(ispow2, x)]
5-element Array{Int64,1}:
  1
  2
  4
  8
 16

julia&gt; x[1, [2 3; 4 1]]
2×2 Array{Int64,2}:
  5  9
 13  1
</pre> <p>Empty ranges of the form <code>n:n-1</code> are sometimes used to indicate the inter-index location between <code>n-1</code> and <code>n</code>. For example, the <a class="reference internal" href="../../stdlib/sort/#Base.searchsorted" title="Base.searchsorted"><code>searchsorted()</code></a> function uses this convention to indicate the insertion point of a value not found in a sorted array:</p> <pre data-language="julia">julia&gt; a = [1,2,5,6,7];

julia&gt; searchsorted(a, 3)
3:2
</pre>   <h3 id="assignment">Assignment</h3> <p>The general syntax for assigning values in an n-dimensional array A is:</p> <pre data-language="julia">A[I_1, I_2, ..., I_n] = X
</pre> <p>where each <code>I_k</code> may be:</p> <ol class="arabic simple"> <li>A scalar integer</li> <li>A <code>Range</code> of the form <code>a:b</code>, or <code>a:b:c</code>
</li> <li>A <code>:</code> or <code>Colon()</code> to select entire dimensions</li> <li>An arbitrary integer array, including the empty array <code>[]</code>
</li> <li>A boolean array to select elements at its <code>true</code> indices</li> </ol> <p>If <code>X</code> is an array, it must have the same number of elements as the product of the lengths of the indices: <code>prod(length(I_1), length(I_2), ..., length(I_n))</code>. The value in location <code>I_1[i_1], I_2[i_2], ..., I_n[i_n]</code> of <code>A</code> is overwritten with the value <code>X[i_1, i_2, ..., i_n]</code>. If <code>X</code> is not an array, its value is written to all referenced locations of <code>A</code>.</p> <p>A boolean array used as an index behaves as in <a class="reference internal" href="../../stdlib/collections/#Base.getindex" title="Base.getindex"><code>getindex()</code></a>, behaving as though it is first transformed with <a class="reference internal" href="../../stdlib/arrays/#Base.find" title="Base.find"><code>find()</code></a>.</p> <p>Index assignment syntax is equivalent to a call to <a class="reference internal" href="../../stdlib/collections/#Base.setindex!" title="Base.setindex!"><code>setindex!()</code></a>:</p> <pre data-language="julia">setindex!(A, X, I_1, I_2, ..., I_n)
</pre> <p>Example:</p> <pre data-language="julia">julia&gt; x = collect(reshape(1:9, 3, 3))
3×3 Array{Int64,2}:
 1  4  7
 2  5  8
 3  6  9

julia&gt; x[1:2, 2:3] = -1
-1

julia&gt; x
3×3 Array{Int64,2}:
 1  -1  -1
 2  -1  -1
 3   6   9
</pre>   <h3 id="man-array-iteration">Iteration</h3> <p id="iteration">The recommended ways to iterate over a whole array are</p> <pre data-language="julia">for a in A
    # Do something with the element a
end

for i in eachindex(A)
    # Do something with i and/or A[i]
end
</pre> <p>The first construct is used when you need the value, but not index, of each element. In the second construct, <code>i</code> will be an <code>Int</code> if <code>A</code> is an array type with fast linear indexing; otherwise, it will be a <code>CartesianIndex</code>:</p> <pre data-language="julia">A = rand(4,3)
B = view(A, 1:3, 2:3)
julia&gt; for i in eachindex(B)
           @show i
       end
       i = Base.IteratorsMD.CartesianIndex_2(1,1)
       i = Base.IteratorsMD.CartesianIndex_2(2,1)
       i = Base.IteratorsMD.CartesianIndex_2(3,1)
       i = Base.IteratorsMD.CartesianIndex_2(1,2)
       i = Base.IteratorsMD.CartesianIndex_2(2,2)
       i = Base.IteratorsMD.CartesianIndex_2(3,2)
</pre> <p>In contrast with <code>for i = 1:length(A)</code>, iterating with <code>eachindex</code> provides an efficient way to iterate over any array type.</p>   <h3 id="array-traits">Array traits</h3> <p>If you write a custom <code>AbstractArray</code> type, you can specify that it has fast linear indexing using</p> <pre data-language="julia">Base.linearindexing{T&lt;:MyArray}(::Type{T}) = LinearFast()
</pre> <p>This setting will cause <code>eachindex</code> iteration over a <code>MyArray</code> to use integers. If you don’t specify this trait, the default value <code>LinearSlow()</code> is used.</p>   <h3 id="vectorized-operators-and-functions">Vectorized Operators and Functions</h3> <p>The following operators are supported for arrays. The dot version of a binary operator should be used for elementwise operations.</p> <ol class="arabic simple"> <li>Unary arithmetic — <code>-</code>, <code>+</code>, <code>!</code>
</li> <li>Binary arithmetic — <code>+</code>, <code>-</code>, <code>*</code>, <code>.*</code>, <code>/</code>, <code>./</code>, <code>\</code>, <code>.\</code>, <code>^</code>, <code>.^</code>, <code>div</code>, <code>mod</code>
</li> <li>Comparison — <code>.==</code>, <code>.!=</code>, <code>.&lt;</code>, <code>.&lt;=</code>, <code>.&gt;</code>, <code>.&gt;=</code>
</li> <li>Unary Boolean or bitwise — <code>~</code>
</li> <li>Binary Boolean or bitwise — <code>&amp;</code>, <code>|</code>, <code>$</code>
</li> </ol> <p>Some operators without dots operate elementwise anyway when one argument is a scalar. These operators are <code>*</code>, <code>+</code>, <code>-</code>, and the bitwise operators. The operators <code>/</code> and <code>\</code> operate elementwise when the denominator is a scalar.</p> <p>Note that comparisons such as <code>==</code> operate on whole arrays, giving a single boolean answer. Use dot operators for elementwise comparisons.</p> <p>The following built-in functions are also vectorized, whereby the functions act elementwise:</p> <pre data-language="julia">abs abs2 angle cbrt
airy airyai airyaiprime airybi airybiprime airyprime
acos acosh asin asinh atan atan2 atanh
acsc acsch asec asech acot acoth
cos  cospi cosh  sin  sinpi sinh  tan  tanh  sinc  cosc
csc  csch  sec  sech  cot  coth
acosd asind atand asecd acscd acotd
cosd  sind  tand  secd  cscd  cotd
besselh besseli besselj besselj0 besselj1 besselk bessely bessely0 bessely1
exp  erf  erfc  erfinv erfcinv exp2  expm1
beta dawson digamma erfcx erfi
exponent eta zeta gamma
hankelh1 hankelh2
 ceil  floor  round  trunc
isfinite isinf isnan
lbeta lfact lgamma
log log10 log1p log2
copysign max min significand
sqrt hypot
</pre> <p>Note that there is a difference between <a class="reference internal" href="../../stdlib/math/#Base.min" title="Base.min"><code>min()</code></a> and <a class="reference internal" href="../../stdlib/math/#Base.max" title="Base.max"><code>max()</code></a>, which operate elementwise over multiple array arguments, and <a class="reference internal" href="../../stdlib/collections/#Base.minimum" title="Base.minimum"><code>minimum()</code></a> and <a class="reference internal" href="../../stdlib/collections/#Base.maximum" title="Base.maximum"><code>maximum()</code></a>, which find the smallest and largest values within an array.</p> <p>Julia provides the <code>@vectorize_1arg()</code> and <code>@vectorize_2arg()</code> macros to automatically vectorize any function of one or two arguments respectively. Each of these takes two arguments, namely the <code>Type</code> of argument (which is usually chosen to be the most general possible) and the name of the function to vectorize. Here is a simple example:</p> <pre data-language="julia">julia&gt; square(x) = x^2
square (generic function with 1 method)

julia&gt; @vectorize_1arg Number square
square (generic function with 2 methods)

julia&gt; methods(square)
# 2 methods for generic function "square":
square{T&lt;:Number}(x::AbstractArray{T,N&lt;:Any}) at operators.jl:555
square(x) at none:1

julia&gt; square([1 2 4; 5 6 7])
2×3 Array{Int64,2}:
  1   4  16
 25  36  49
</pre>   <h3 id="man-broadcasting">Broadcasting</h3> <p id="broadcasting">It is sometimes useful to perform element-by-element binary operations on arrays of different sizes, such as adding a vector to each column of a matrix. An inefficient way to do this would be to replicate the vector to the size of the matrix:</p> <pre data-language="julia">julia&gt; a = rand(2,1); A = rand(2,3);

julia&gt; repmat(a,1,3)+A
2×3 Array{Float64,2}:
 1.20813  1.82068  1.25387
 1.56851  1.86401  1.67846
</pre> <p>This is wasteful when dimensions get large, so Julia offers <a class="reference internal" href="../../stdlib/arrays/#Base.broadcast" title="Base.broadcast"><code>broadcast()</code></a>, which expands singleton dimensions in array arguments to match the corresponding dimension in the other array without using extra memory, and applies the given function elementwise:</p> <pre data-language="julia">julia&gt; broadcast(+, a, A)
2×3 Array{Float64,2}:
 1.20813  1.82068  1.25387
 1.56851  1.86401  1.67846

julia&gt; b = rand(1,2)
1×2 Array{Float64,2}:
 0.867535  0.00457906

julia&gt; broadcast(+, a, b)
2×2 Array{Float64,2}:
 1.71056  0.847604
 1.73659  0.873631
</pre> <p>Elementwise operators such as <code>.+</code> and <code>.*</code> perform broadcasting if necessary. There is also a <a class="reference internal" href="../../stdlib/arrays/#Base.broadcast!" title="Base.broadcast!"><code>broadcast!()</code></a> function to specify an explicit destination, and <a class="reference internal" href="../../stdlib/arrays/#Base.broadcast_getindex" title="Base.broadcast_getindex"><code>broadcast_getindex()</code></a> and <a class="reference internal" href="../../stdlib/arrays/#Base.broadcast_setindex!" title="Base.broadcast_setindex!"><code>broadcast_setindex!()</code></a> that broadcast the indices before indexing. Moreover, <code>f.(args...)</code> is equivalent to <code>broadcast(f, args...)</code>, providing a convenient syntax to broadcast any function (<a class="reference internal" href="../functions/#man-dot-vectorizing"><span>Dot Syntax for Vectorizing Functions</span></a>).</p>   <h3 id="implementation">Implementation</h3> <p>The base array type in Julia is the abstract type <code>AbstractArray{T,N}</code>. It is parametrized by the number of dimensions <code>N</code> and the element type <code>T</code>. <code>AbstractVector</code> and <code>AbstractMatrix</code> are aliases for the 1-d and 2-d cases. Operations on <code>AbstractArray</code> objects are defined using higher level operators and functions, in a way that is independent of the underlying storage. These operations generally work correctly as a fallback for any specific array implementation.</p> <p>The <code>AbstractArray</code> type includes anything vaguely array-like, and implementations of it might be quite different from conventional arrays. For example, elements might be computed on request rather than stored. However, any concrete <code>AbstractArray{T,N}</code> type should generally implement at least <a class="reference internal" href="../../stdlib/arrays/#Base.size" title="Base.size"><code>size(A)</code></a> (returning an <code>Int</code> tuple), <a class="reference internal" href="../../stdlib/collections/#Base.getindex" title="Base.getindex"><code>getindex(A,i)</code></a> and <a class="reference internal" href="../../stdlib/collections/#Base.getindex" title="Base.getindex"><code>getindex(A,i1,...,iN)</code></a>; mutable arrays should also implement <a class="reference internal" href="../../stdlib/collections/#Base.setindex!" title="Base.setindex!"><code>setindex!()</code></a>. It is recommended that these operations have nearly constant time complexity, or technically Õ(1) complexity, as otherwise some array functions may be unexpectedly slow. Concrete types should also typically provide a <a class="reference internal" href="../../stdlib/arrays/#Base.similar" title="Base.similar"><code>similar(A,T=eltype(A),dims=size(A))</code></a> method, which is used to allocate a similar array for <a class="reference internal" href="../../stdlib/base/#Base.copy" title="Base.copy"><code>copy()</code></a> and other out-of-place operations. No matter how an <code>AbstractArray{T,N}</code> is represented internally, <code>T</code> is the type of object returned by <em>integer</em> indexing (<code>A[1,
..., 1]</code>, when <code>A</code> is not empty) and <code>N</code> should be the length of the tuple returned by <a class="reference internal" href="../../stdlib/arrays/#Base.size" title="Base.size"><code>size()</code></a>.</p> <p><code>DenseArray</code> is an abstract subtype of <code>AbstractArray</code> intended to include all arrays that are laid out at regular offsets in memory, and which can therefore be passed to external C and Fortran functions expecting this memory layout. Subtypes should provide a method <a class="reference internal" href="../../stdlib/arrays/#Base.stride" title="Base.stride"><code>stride(A,k)</code></a> that returns the “stride” of dimension <code>k</code>: increasing the index of dimension <code>k</code> by <code>1</code> should increase the index <code>i</code> of <a class="reference internal" href="../../stdlib/collections/#Base.getindex" title="Base.getindex"><code>getindex(A,i)</code></a> by <a class="reference internal" href="../../stdlib/arrays/#Base.stride" title="Base.stride"><code>stride(A,k)</code></a>. If a pointer conversion method <a class="reference internal" href="../../stdlib/c/#Base.unsafe_convert" title="Base.unsafe_convert"><code>Base.unsafe_convert(Ptr{T}, A)</code></a> is provided, the memory layout should correspond in the same way to these strides.</p> <p>The <a class="reference internal" href="../../stdlib/arrays/#Base.Array" title="Base.Array"><code>Array</code></a> type is a specific instance of <code>DenseArray</code> where elements are stored in column-major order (see additional notes in <a class="reference internal" href="../performance-tips/#man-performance-tips"><span>Performance Tips</span></a>). <code>Vector</code> and <code>Matrix</code> are aliases for the 1-d and 2-d cases. Specific operations such as scalar indexing, assignment, and a few other basic storage-specific operations are all that have to be implemented for <a class="reference internal" href="../../stdlib/arrays/#Base.Array" title="Base.Array"><code>Array</code></a>, so that the rest of the array library can be implemented in a generic manner.</p> <p><code>SubArray</code> is a specialization of <code>AbstractArray</code> that performs indexing by reference rather than by copying. A <code>SubArray</code> is created with the <a class="reference internal" href="../../stdlib/arrays/#Base.view" title="Base.view"><code>view()</code></a> function, which is called the same way as <a class="reference internal" href="../../stdlib/collections/#Base.getindex" title="Base.getindex"><code>getindex()</code></a> (with an array and a series of index arguments). The result of <a class="reference internal" href="../../stdlib/arrays/#Base.view" title="Base.view"><code>view()</code></a> looks the same as the result of <a class="reference internal" href="../../stdlib/collections/#Base.getindex" title="Base.getindex"><code>getindex()</code></a>, except the data is left in place. <a class="reference internal" href="../../stdlib/arrays/#Base.view" title="Base.view"><code>view()</code></a> stores the input index vectors in a <code>SubArray</code> object, which can later be used to index the original array indirectly.</p> <p><code>StridedVector</code> and <code>StridedMatrix</code> are convenient aliases defined to make it possible for Julia to call a wider range of BLAS and LAPACK functions by passing them either <a class="reference internal" href="../../stdlib/arrays/#Base.Array" title="Base.Array"><code>Array</code></a> or <code>SubArray</code> objects, and thus saving inefficiencies from memory allocation and copying.</p> <p>The following example computes the QR decomposition of a small section of a larger array, without creating any temporaries, and by calling the appropriate LAPACK function with the right leading dimension size and stride parameters.</p> <pre data-language="julia">julia&gt; a = rand(10,10)
10×10 Array{Float64,2}:
 0.561255   0.226678   0.203391  0.308912   …  0.750307  0.235023   0.217964
 0.718915   0.537192   0.556946  0.996234      0.666232  0.509423   0.660788
 0.493501   0.0565622  0.118392  0.493498      0.262048  0.940693   0.252965
 0.0470779  0.736979   0.264822  0.228787      0.161441  0.897023   0.567641
 0.343935   0.32327    0.795673  0.452242      0.468819  0.628507   0.511528
 0.935597   0.991511   0.571297  0.74485    …  0.84589   0.178834   0.284413
 0.160706   0.672252   0.133158  0.65554       0.371826  0.770628   0.0531208
 0.306617   0.836126   0.301198  0.0224702     0.39344   0.0370205  0.536062
 0.890947   0.168877   0.32002   0.486136      0.096078  0.172048   0.77672
 0.507762   0.573567   0.220124  0.165816      0.211049  0.433277   0.539476

julia&gt; b = view(a, 2:2:8,2:2:4)
4×2 SubArray{Float64,2,Array{Float64,2},Tuple{StepRange{Int64,Int64},StepRange{Int64,Int64}},false}:
 0.537192  0.996234
 0.736979  0.228787
 0.991511  0.74485
 0.836126  0.0224702

julia&gt; (q,r) = qr(b);

julia&gt; q
4×2 Array{Float64,2}:
 -0.338809   0.78934
 -0.464815  -0.230274
 -0.625349   0.194538
 -0.527347  -0.534856

julia&gt; r
2×2 Array{Float64,2}:
 -1.58553  -0.921517
  0.0       0.866567
</pre>    <h2 id="sparse-matrices">Sparse Matrices</h2> <p><a class="reference external" href="https://en.wikipedia.org/wiki/Sparse_matrix" target="_blank">Sparse matrices</a> are matrices that contain enough zeros that storing them in a special data structure leads to savings in space and execution time. Sparse matrices may be used when operations on the sparse representation of a matrix lead to considerable gains in either time or space when compared to performing the same operations on a dense matrix.</p>  <h3 id="compressed-sparse-column-csc-storage">Compressed Sparse Column (CSC) Storage</h3> <p>In Julia, sparse matrices are stored in the <a class="reference external" href="https://en.wikipedia.org/wiki/Sparse_matrix#Compressed_sparse_column_.28CSC_or_CCS.29" target="_blank">Compressed Sparse Column (CSC) format</a>. Julia sparse matrices have the type <code>SparseMatrixCSC{Tv,Ti}</code>, where <code>Tv</code> is the type of the nonzero values, and <code>Ti</code> is the integer type for storing column pointers and row indices.:</p> <pre data-language="julia">type SparseMatrixCSC{Tv,Ti&lt;:Integer} &lt;: AbstractSparseMatrix{Tv,Ti}
    m::Int                  # Number of rows
    n::Int                  # Number of columns
    colptr::Vector{Ti}      # Column i is in colptr[i]:(colptr[i+1]-1)
    rowval::Vector{Ti}      # Row values of nonzeros
    nzval::Vector{Tv}       # Nonzero values
end
</pre> <p>The compressed sparse column storage makes it easy and quick to access the elements in the column of a sparse matrix, whereas accessing the sparse matrix by rows is considerably slower. Operations such as insertion of nonzero values one at a time in the CSC structure tend to be slow. This is because all elements of the sparse matrix that are beyond the point of insertion have to be moved one place over.</p> <p>All operations on sparse matrices are carefully implemented to exploit the CSC data structure for performance, and to avoid expensive operations.</p> <p>If you have data in CSC format from a different application or library, and wish to import it in Julia, make sure that you use 1-based indexing. The row indices in every column need to be sorted. If your <code>SparseMatrixCSC</code> object contains unsorted row indices, one quick way to sort them is by doing a double transpose.</p> <p>In some applications, it is convenient to store explicit zero values in a <code>SparseMatrixCSC</code>. These <em>are</em> accepted by functions in <code>Base</code> (but there is no guarantee that they will be preserved in mutating operations). Such explicitly stored zeros are treated as structural nonzeros by many routines. The <a class="reference internal" href="../../stdlib/arrays/#Base.nnz" title="Base.nnz"><code>nnz()</code></a> function returns the number of elements explicitly stored in the sparse data structure, including structural nonzeros. In order to count the exact number of actual values that are nonzero, use <a class="reference internal" href="../../stdlib/arrays/#Base.countnz" title="Base.countnz"><code>countnz()</code></a>, which inspects every stored element of a sparse matrix.</p>   <h3 id="sparse-matrix-constructors">Sparse matrix constructors</h3> <p>The simplest way to create sparse matrices is to use functions equivalent to the <a class="reference internal" href="../../stdlib/arrays/#Base.zeros" title="Base.zeros"><code>zeros()</code></a> and <a class="reference internal" href="../../stdlib/arrays/#Base.eye" title="Base.eye"><code>eye()</code></a> functions that Julia provides for working with dense matrices. To produce sparse matrices instead, you can use the same names with an <code>sp</code> prefix:</p> <pre data-language="julia">julia&gt; spzeros(3,5)
3×5 sparse matrix with 0 Float64 nonzero entries

julia&gt; speye(3,5)
3×5 sparse matrix with 3 Float64 nonzero entries:
        [1, 1]  =  1.0
        [2, 2]  =  1.0
        [3, 3]  =  1.0
</pre> <p>The <a class="reference internal" href="../../stdlib/arrays/#Base.sparse" title="Base.sparse"><code>sparse()</code></a> function is often a handy way to construct sparse matrices. It takes as its input a vector <code>I</code> of row indices, a vector <code>J</code> of column indices, and a vector <code>V</code> of nonzero values. <code>sparse(I,J,V)</code> constructs a sparse matrix such that <code>S[I[k], J[k]] = V[k]</code>.</p> <pre data-language="julia">julia&gt; I = [1, 4, 3, 5]; J = [4, 7, 18, 9]; V = [1, 2, -5, 3];

julia&gt; S = sparse(I,J,V)
5×18 sparse matrix with 4 Int64 nonzero entries:
        [1 ,  4]  =  1
        [4 ,  7]  =  2
        [5 ,  9]  =  3
        [3 , 18]  =  -5
</pre> <p>The inverse of the <a class="reference internal" href="../../stdlib/arrays/#Base.sparse" title="Base.sparse"><code>sparse()</code></a> function is <a class="reference internal" href="../../stdlib/arrays/#Base.findn" title="Base.findn"><code>findn()</code></a>, which retrieves the inputs used to create the sparse matrix.</p> <pre data-language="julia">julia&gt; findn(S)
([1,4,5,3],[4,7,9,18])

julia&gt; findnz(S)
([1,4,5,3],[4,7,9,18],[1,2,3,-5])
</pre> <p>Another way to create sparse matrices is to convert a dense matrix into a sparse matrix using the <a class="reference internal" href="../../stdlib/arrays/#Base.sparse" title="Base.sparse"><code>sparse()</code></a> function:</p> <pre data-language="julia">julia&gt; sparse(eye(5))
5×5 sparse matrix with 5 Float64 nonzero entries:
        [1, 1]  =  1.0
        [2, 2]  =  1.0
        [3, 3]  =  1.0
        [4, 4]  =  1.0
        [5, 5]  =  1.0
</pre> <p>You can go in the other direction using the <a class="reference internal" href="../../stdlib/linalg/#Base.full" title="Base.full"><code>full()</code></a> function. The <a class="reference internal" href="../../stdlib/arrays/#Base.issparse" title="Base.issparse"><code>issparse()</code></a> function can be used to query if a matrix is sparse.</p> <pre data-language="julia">julia&gt; issparse(speye(5))
true
</pre>   <h3 id="sparse-matrix-operations">Sparse matrix operations</h3> <p>Arithmetic operations on sparse matrices also work as they do on dense matrices. Indexing of, assignment into, and concatenation of sparse matrices work in the same way as dense matrices. Indexing operations, especially assignment, are expensive, when carried out one element at a time. In many cases it may be better to convert the sparse matrix into <code>(I,J,V)</code> format using <a class="reference internal" href="../../stdlib/arrays/#Base.findnz" title="Base.findnz"><code>findnz()</code></a>, manipulate the non-zeroes or the structure in the dense vectors <code>(I,J,V)</code>, and then reconstruct the sparse matrix.</p>   <h3 id="correspondence-of-dense-and-sparse-methods">Correspondence of dense and sparse methods</h3> <p>The following table gives a correspondence between built-in methods on sparse matrices and their corresponding methods on dense matrix types. In general, methods that generate sparse matrices differ from their dense counterparts in that the resulting matrix follows the same sparsity pattern as a given sparse matrix <code>S</code>, or that the resulting sparse matrix has density <code>d</code>, i.e. each matrix element has a probability <code>d</code> of being non-zero.</p> <p>Details can be found in the <a class="reference internal" href="../../stdlib/arrays/#stdlib-sparse"><span>Sparse Vectors and Matrices</span></a> section of the standard library reference.</p> <table class="docutils">  <thead valign="bottom"> <tr class="row-odd">
<th class="head">Sparse</th> <th class="head">Dense</th> <th class="head">Description</th> </tr> </thead>  <tr class="row-even">
<td><a class="reference internal" href="../../stdlib/arrays/#Base.spzeros" title="Base.spzeros"><code>spzeros(m,n)</code></a></td> <td><a class="reference internal" href="../../stdlib/arrays/#Base.zeros" title="Base.zeros"><code>zeros(m,n)</code></a></td> <td>Creates a <em>m</em>-by-<em>n</em> matrix of zeros. (<a class="reference internal" href="../../stdlib/arrays/#Base.spzeros" title="Base.spzeros"><code>spzeros(m,n)</code></a> is empty.)</td> </tr> <tr class="row-odd">
<td><a class="reference internal" href="../../stdlib/arrays/#Base.spones" title="Base.spones"><code>spones(S)</code></a></td> <td><a class="reference internal" href="../../stdlib/arrays/#Base.ones" title="Base.ones"><code>ones(m,n)</code></a></td> <td>Creates a matrix filled with ones. Unlike the dense version, <a class="reference internal" href="../../stdlib/arrays/#Base.spones" title="Base.spones"><code>spones()</code></a> has the same sparsity pattern as <em>S</em>.</td> </tr> <tr class="row-even">
<td><a class="reference internal" href="../../stdlib/arrays/#Base.speye" title="Base.speye"><code>speye(n)</code></a></td> <td><a class="reference internal" href="../../stdlib/arrays/#Base.eye" title="Base.eye"><code>eye(n)</code></a></td> <td>Creates a <em>n</em>-by-<em>n</em> identity matrix.</td> </tr> <tr class="row-odd">
<td><a class="reference internal" href="../../stdlib/linalg/#Base.full" title="Base.full"><code>full(S)</code></a></td> <td><a class="reference internal" href="../../stdlib/arrays/#Base.sparse" title="Base.sparse"><code>sparse(A)</code></a></td> <td>Interconverts between dense and sparse formats.</td> </tr> <tr class="row-even">
<td><a class="reference internal" href="../../stdlib/arrays/#Base.sprand" title="Base.sprand"><code>sprand(m,n,d)</code></a></td> <td><a class="reference internal" href="../../stdlib/numbers/#Base.rand" title="Base.rand"><code>rand(m,n)</code></a></td> <td>Creates a <em>m</em>-by-<em>n</em> random matrix (of density <em>d</em>) with iid non-zero elements distributed uniformly on the half-open interval <span class="math">\([0, 1)\)</span>.</td> </tr> <tr class="row-odd">
<td><a class="reference internal" href="../../stdlib/arrays/#Base.sprandn" title="Base.sprandn"><code>sprandn(m,n,d)</code></a></td> <td><a class="reference internal" href="../../stdlib/numbers/#Base.randn" title="Base.randn"><code>randn(m,n)</code></a></td> <td>Creates a <em>m</em>-by-<em>n</em> random matrix (of density <em>d</em>) with iid non-zero elements distributed according to the standard normal (Gaussian) distribution.</td> </tr> <tr class="row-even">
<td><a class="reference internal" href="../../stdlib/arrays/#Base.sprandn" title="Base.sprandn"><code>sprandn(m,n,d,X)</code></a></td> <td><a class="reference internal" href="../../stdlib/numbers/#Base.randn" title="Base.randn"><code>randn(m,n,X)</code></a></td> <td>Creates a <em>m</em>-by-<em>n</em> random matrix (of density <em>d</em>) with iid non-zero elements distributed according to the <em>X</em> distribution. (Requires the <code>Distributions</code> package.)</td> </tr>  </table>
<div class="_attribution">
  <p class="_attribution-p">
    © 2009–2016 Jeff Bezanson, Stefan Karpinski, Viral B. Shah, and other contributors<br>Licensed under the MIT License.<br>
    <a href="http://docs.julialang.org/en/release-0.5/manual/arrays/" class="_attribution-link" target="_blank">http://docs.julialang.org/en/release-0.5/manual/arrays/</a>
  </p>
</div>

			</div>
		</div>
	</section>

	</div>
</body>
</html>
