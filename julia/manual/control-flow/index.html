
<!DOCTYPE HTML>

<html lang="en">

<head>
  <meta charset="utf-8">
  <title>Control Flow - Julia - W3cubDocs</title>
  
  <meta name="description" content=" Julia provides a variety of control flow constructs&#58; ">
  <meta name="keywords" content="control, flow, -, julia">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="http://docs.w3cub.com/julia/manual/control-flow/">
  <link href="/favicon.png" rel="icon">
  <link type="text/css" rel="stylesheet" href="/assets/application-50364fff564ce3b6327021805f3f00e2957b441cf27f576a7dd4ff63bbc47047.css">
  <script type="text/javascript" src="/assets/application-db64bfd54ceb42be11af7995804cf4902548419ceb79d509b0b7d62c22d98e6f.js"></script>
  <script src="/json/julia.js"></script>
  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-71174418-1']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>


</head>

<body>
	<div class="_app">
	<header class="_header">
  
  <form class="_search">
    <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
    <a class="_search-clear"></a>
    <div class="_search-tag"></div>
  </form>
  
  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/julia/" class="_nav-link" title="" style="margin-left:0;">Julia</a></span>
  
  <nav class="_nav">
    <a href="/app/" class="_nav-link ">App</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		<div class="_list">
			
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<div class="_page _sphinx_simple">
				
<h1 id="man-control-flow">Control Flow</h1> <p>Julia provides a variety of control flow constructs:</p> <ul class="simple"> <li>
<a class="reference internal" href="#man-compound-expressions"><span>Compound Expressions</span></a>: <code>begin</code> and <code>(;)</code>.</li> <li>
<a class="reference internal" href="#man-conditional-evaluation"><span>Conditional Evaluation</span></a>: <code>if</code>-<code>elseif</code>-<code>else</code> and <code>?:</code> (ternary operator).</li> <li>
<a class="reference internal" href="#man-short-circuit-evaluation"><span>Short-Circuit Evaluation</span></a>: <code>&amp;&amp;</code>, <code>||</code> and chained comparisons.</li> <li>
<a class="reference internal" href="#man-loops"><span>Repeated Evaluation: Loops</span></a>: <code>while</code> and <code>for</code>.</li> <li>
<a class="reference internal" href="#man-exception-handling"><span>Exception Handling</span></a>: <code>try</code>-<code>catch</code>, <a class="reference internal" href="../../stdlib/base/#Base.error" title="Base.error"><code>error()</code></a> and <a class="reference internal" href="../../stdlib/base/#Base.throw" title="Base.throw"><code>throw()</code></a>.</li> <li>
<a class="reference internal" href="#man-tasks"><span>Tasks (aka Coroutines)</span></a>: <a class="reference internal" href="../../stdlib/parallel/#Base.yieldto" title="Base.yieldto"><code>yieldto()</code></a>.</li> </ul> <p>The first five control flow mechanisms are standard to high-level programming languages. <a class="reference internal" href="../../stdlib/parallel/#Base.Task" title="Base.Task"><code>Task</code></a>s are not so standard: they provide non-local control flow, making it possible to switch between temporarily-suspended computations. This is a powerful construct: both exception handling and cooperative multitasking are implemented in Julia using tasks. Everyday programming requires no direct usage of tasks, but certain problems can be solved much more easily by using tasks.</p>  <h2 id="man-compound-expressions">Compound Expressions</h2> <p id="compound-expressions">Sometimes it is convenient to have a single expression which evaluates several subexpressions in order, returning the value of the last subexpression as its value. There are two Julia constructs that accomplish this: <code>begin</code> blocks and <code>(;)</code> chains. The value of both compound expression constructs is that of the last subexpression. Here’s an example of a <code>begin</code> block:</p> <pre data-language="julia">julia&gt; z = begin
         x = 1
         y = 2
         x + y
       end
3
</pre> <p>Since these are fairly small, simple expressions, they could easily be placed onto a single line, which is where the <code>(;)</code> chain syntax comes in handy:</p> <pre data-language="julia">julia&gt; z = (x = 1; y = 2; x + y)
3
</pre> <p>This syntax is particularly useful with the terse single-line function definition form introduced in <a class="reference internal" href="../functions/#man-functions"><span>Functions</span></a>. Although it is typical, there is no requirement that <code>begin</code> blocks be multiline or that <code>(;)</code> chains be single-line:</p> <pre data-language="julia">julia&gt; begin x = 1; y = 2; x + y end
3

julia&gt; (x = 1;
        y = 2;
        x + y)
3
</pre>   <h2 id="man-conditional-evaluation">Conditional Evaluation</h2> <p id="conditional-evaluation">Conditional evaluation allows portions of code to be evaluated or not evaluated depending on the value of a boolean expression. Here is the anatomy of the <code>if</code>-<code>elseif</code>-<code>else</code> conditional syntax:</p> <pre data-language="julia">if x &lt; y
  println("x is less than y")
elseif x &gt; y
  println("x is greater than y")
else
  println("x is equal to y")
end
</pre> <p>If the condition expression <code>x &lt; y</code> is <code>true</code>, then the corresponding block is evaluated; otherwise the condition expression <code>x &gt; y</code> is evaluated, and if it is <code>true</code>, the corresponding block is evaluated; if neither expression is true, the <code>else</code> block is evaluated. Here it is in action:</p> <pre data-language="julia">julia&gt; function test(x, y)
         if x &lt; y
           println("x is less than y")
         elseif x &gt; y
           println("x is greater than y")
         else
           println("x is equal to y")
         end
       end
test (generic function with 1 method)

julia&gt; test(1, 2)
x is less than y

julia&gt; test(2, 1)
x is greater than y

julia&gt; test(1, 1)
x is equal to y
</pre> <p>The <code>elseif</code> and <code>else</code> blocks are optional, and as many <code>elseif</code> blocks as desired can be used. The condition expressions in the <code>if</code>-<code>elseif</code>-<code>else</code> construct are evaluated until the first one evaluates to <code>true</code>, after which the associated block is evaluated, and no further condition expressions or blocks are evaluated.</p> <p><code>if</code> blocks are “leaky”, i.e. they do not introduce a local scope. This means that new variables defined inside the <code>ìf</code> clauses can be used after the <code>if</code> block, even if they weren’t defined before. So, we could have defined the <code>test</code> function above as</p> <pre data-language="julia">julia&gt; function test(x,y)
         if x &lt; y
           relation = "less than"
         elseif x == y
           relation = "equal to"
         else
           relation = "greater than"
         end
         println("x is ", relation, " y.")
       end
test (generic function with 1 method)
</pre> <p>The variable <code>relation</code> is declared inside the <code>if</code> block, but used outside. However, when depending on this behavior, make sure all possible code paths define a value for the variable. The following change to the above function results in a runtime error</p> <pre data-language="julia">julia&gt; function test(x,y)
         if x &lt; y
           relation = "less than"
         elseif x == y
           relation = "equal to"
         end
         println("x is ", relation, " y.")
       end
test (generic function with 1 method)

julia&gt; test(1,2)
x is less than y.

julia&gt; test(2,1)
ERROR: UndefVarError: relation not defined
 in test(::Int64, ::Int64) at ./none:7
 ...
</pre> <p><code>if</code> blocks also return a value, which may seem unintuitive to users coming from many other languages. This value is simply the return value of the last executed statement in the branch that was chosen, so</p> <pre data-language="julia">julia&gt; x = 3
3

julia&gt; if x &gt; 0
           "positive!"
       else
           "negative..."
       end
"positive!"
</pre> <p>Note that very short conditional statements (one-liners) are frequently expressed using Short-Circuit Evaluation in Julia, as outlined in the next section.</p> <p>Unlike C, MATLAB, Perl, Python, and Ruby — but like Java, and a few other stricter, typed languages — it is an error if the value of a conditional expression is anything but <code>true</code> or <code>false</code>:</p> <pre data-language="julia">julia&gt; if 1
         println("true")
       end
ERROR: TypeError: non-boolean (Int64) used in boolean context
 ...
</pre> <p>This error indicates that the conditional was of the wrong type: <code>Int64</code> rather than the required <code>Bool</code>.</p> <p>The so-called “ternary operator”, <code>?:</code>, is closely related to the <code>if</code>-<code>elseif</code>-<code>else</code> syntax, but is used where a conditional choice between single expression values is required, as opposed to conditional execution of longer blocks of code. It gets its name from being the only operator in most languages taking three operands:</p> <pre data-language="julia">a ? b : c
</pre> <p>The expression <code>a</code>, before the <code>?</code>, is a condition expression, and the ternary operation evaluates the expression <code>b</code>, before the <code>:</code>, if the condition <code>a</code> is <code>true</code> or the expression <code>c</code>, after the <code>:</code>, if it is <code>false</code>.</p> <p>The easiest way to understand this behavior is to see an example. In the previous example, the <code>println</code> call is shared by all three branches: the only real choice is which literal string to print. This could be written more concisely using the ternary operator. For the sake of clarity, let’s try a two-way version first:</p> <pre data-language="julia">julia&gt; x = 1; y = 2;

julia&gt; println(x &lt; y ? "less than" : "not less than")
less than

julia&gt; x = 1; y = 0;

julia&gt; println(x &lt; y ? "less than" : "not less than")
not less than
</pre> <p>If the expression <code>x &lt; y</code> is true, the entire ternary operator expression evaluates to the string <code>"less than"</code> and otherwise it evaluates to the string <code>"not less than"</code>. The original three-way example requires chaining multiple uses of the ternary operator together:</p> <pre data-language="julia">julia&gt; test(x, y) = println(x &lt; y ? "x is less than y"    :
                            x &gt; y ? "x is greater than y" : "x is equal to y")
test (generic function with 1 method)

julia&gt; test(1, 2)
x is less than y

julia&gt; test(2, 1)
x is greater than y

julia&gt; test(1, 1)
x is equal to y
</pre> <p>To facilitate chaining, the operator associates from right to left.</p> <p>It is significant that like <code>if</code>-<code>elseif</code>-<code>else</code>, the expressions before and after the <code>:</code> are only evaluated if the condition expression evaluates to <code>true</code> or <code>false</code>, respectively:</p> <pre data-language="julia">julia&gt; v(x) = (println(x); x)
v (generic function with 1 method)


julia&gt; 1 &lt; 2 ? v("yes") : v("no")
yes
"yes"

julia&gt; 1 &gt; 2 ? v("yes") : v("no")
no
"no"
</pre>   <h2 id="man-short-circuit-evaluation">Short-Circuit Evaluation</h2> <p id="short-circuit-evaluation">Short-circuit evaluation is quite similar to conditional evaluation. The behavior is found in most imperative programming languages having the <code>&amp;&amp;</code> and <code>||</code> boolean operators: in a series of boolean expressions connected by these operators, only the minimum number of expressions are evaluated as are necessary to determine the final boolean value of the entire chain. Explicitly, this means that:</p> <ul class="simple"> <li>In the expression <code>a &amp;&amp; b</code>, the subexpression <code>b</code> is only evaluated if <code>a</code> evaluates to <code>true</code>.</li> <li>In the expression <code>a || b</code>, the subexpression <code>b</code> is only evaluated if <code>a</code> evaluates to <code>false</code>.</li> </ul> <p>The reasoning is that <code>a &amp;&amp; b</code> must be <code>false</code> if <code>a</code> is <code>false</code>, regardless of the value of <code>b</code>, and likewise, the value of <code>a || b</code> must be true if <code>a</code> is <code>true</code>, regardless of the value of <code>b</code>. Both <code>&amp;&amp;</code> and <code>||</code> associate to the right, but <code>&amp;&amp;</code> has higher precedence than <code>||</code> does. It’s easy to experiment with this behavior:</p> <pre data-language="julia">julia&gt; t(x) = (println(x); true)
t (generic function with 1 method)

julia&gt; f(x) = (println(x); false)
f (generic function with 1 method)

julia&gt; t(1) &amp;&amp; t(2)
1
2
true

julia&gt; t(1) &amp;&amp; f(2)
1
2
false

julia&gt; f(1) &amp;&amp; t(2)
1
false

julia&gt; f(1) &amp;&amp; f(2)
1
false

julia&gt; t(1) || t(2)
1
true

julia&gt; t(1) || f(2)
1
true

julia&gt; f(1) || t(2)
1
2
true

julia&gt; f(1) || f(2)
1
2
false
</pre> <p>You can easily experiment in the same way with the associativity and precedence of various combinations of <code>&amp;&amp;</code> and <code>||</code> operators.</p> <p>This behavior is frequently used in Julia to form an alternative to very short <code>if</code> statements. Instead of <code>if &lt;cond&gt; &lt;statement&gt; end</code>, one can write <code>&lt;cond&gt; &amp;&amp; &lt;statement&gt;</code> (which could be read as: &lt;cond&gt; <em>and then</em> &lt;statement&gt;). Similarly, instead of <code>if ! &lt;cond&gt; &lt;statement&gt; end</code>, one can write <code>&lt;cond&gt; || &lt;statement&gt;</code> (which could be read as: &lt;cond&gt; <em>or else</em> &lt;statement&gt;).</p> <p>For example, a recursive factorial routine could be defined like this:</p> <pre data-language="julia">julia&gt; function fact(n::Int)
           n &gt;= 0 || error("n must be non-negative")
           n == 0 &amp;&amp; return 1
           n * fact(n-1)
       end
fact (generic function with 1 method)

julia&gt; fact(5)
120

julia&gt; fact(0)
1

julia&gt; fact(-1)
ERROR: n must be non-negative
 in fact(::Int64) at ./none:2
 ...
</pre> <p>Boolean operations <em>without</em> short-circuit evaluation can be done with the bitwise boolean operators introduced in <a class="reference internal" href="../mathematical-operations/#man-mathematical-operations"><span>Mathematical Operations and Elementary Functions</span></a>: <code>&amp;</code> and <code>|</code>. These are normal functions, which happen to support infix operator syntax, but always evaluate their arguments:</p> <pre data-language="julia">julia&gt; f(1) &amp; t(2)
1
2
false

julia&gt; t(1) | t(2)
1
2
true
</pre> <p>Just like condition expressions used in <code>if</code>, <code>elseif</code> or the ternary operator, the operands of <code>&amp;&amp;</code> or <code>||</code> must be boolean values (<code>true</code> or <code>false</code>). Using a non-boolean value anywhere except for the last entry in a conditional chain is an error:</p> <pre data-language="julia">julia&gt; 1 &amp;&amp; true
ERROR: TypeError: non-boolean (Int64) used in boolean context
 ...
</pre> <p>On the other hand, any type of expression can be used at the end of a conditional chain. It will be evaluated and returned depending on the preceding conditionals:</p> <pre data-language="julia">julia&gt; true &amp;&amp; (x = rand(2,2))
2×2 Array{Float64,2}:
 0.768448  0.673959
 0.940515  0.395453

julia&gt; false &amp;&amp; (x = rand(2,2))
false
</pre>   <h2 id="man-loops">Repeated Evaluation: Loops</h2> <p id="repeated-evaluation-loops">There are two constructs for repeated evaluation of expressions: the <code>while</code> loop and the <code>for</code> loop. Here is an example of a <code>while</code> loop:</p> <pre data-language="julia">julia&gt; i = 1;

julia&gt; while i &lt;= 5
         println(i)
         i += 1
       end
1
2
3
4
5
</pre> <p>The <code>while</code> loop evaluates the condition expression (<code>i &lt;= 5</code> in this case), and as long it remains <code>true</code>, keeps also evaluating the body of the <code>while</code> loop. If the condition expression is <code>false</code> when the <code>while</code> loop is first reached, the body is never evaluated.</p> <p>The <code>for</code> loop makes common repeated evaluation idioms easier to write. Since counting up and down like the above <code>while</code> loop does is so common, it can be expressed more concisely with a <code>for</code> loop:</p> <pre data-language="julia">julia&gt; for i = 1:5
         println(i)
       end
1
2
3
4
5
</pre> <p>Here the <code>1:5</code> is a <code>Range</code> object, representing the sequence of numbers 1, 2, 3, 4, 5. The <code>for</code> loop iterates through these values, assigning each one in turn to the variable <code>i</code>. One rather important distinction between the previous <code>while</code> loop form and the <code>for</code> loop form is the scope during which the variable is visible. If the variable <code>i</code> has not been introduced in an other scope, in the <code>for</code> loop form, it is visible only inside of the <code>for</code> loop, and not afterwards. You’ll either need a new interactive session instance or a different variable name to test this:</p> <pre data-language="julia">julia&gt; for j = 1:5
         println(j)
       end
1
2
3
4
5

julia&gt; j
ERROR: UndefVarError: j not defined
 ...
</pre> <p>See <a class="reference internal" href="../variables-and-scoping/#man-variables-and-scoping"><span>Scope of Variables</span></a> for a detailed explanation of variable scope and how it works in Julia.</p> <p>In general, the <code>for</code> loop construct can iterate over any container. In these cases, the alternative (but fully equivalent) keyword <code>in</code> or <code>∈</code> is typically used instead of <code>=</code>, since it makes the code read more clearly:</p> <pre data-language="julia">julia&gt; for i in [1,4,0]
         println(i)
       end
1
4
0

julia&gt; for s ∈ ["foo","bar","baz"]
         println(s)
       end
foo
bar
baz
</pre> <p>Various types of iterable containers will be introduced and discussed in later sections of the manual (see, e.g., <a class="reference internal" href="../arrays/#man-arrays"><span>Multi-dimensional Arrays</span></a>).</p> <p>It is sometimes convenient to terminate the repetition of a <code>while</code> before the test condition is falsified or stop iterating in a <code>for</code> loop before the end of the iterable object is reached. This can be accomplished with the <code>break</code> keyword:</p> <pre data-language="julia">julia&gt; i = 1;

julia&gt; while true
         println(i)
         if i &gt;= 5
           break
         end
         i += 1
       end
1
2
3
4
5

julia&gt; for i = 1:1000
         println(i)
         if i &gt;= 5
           break
         end
       end
1
2
3
4
5
</pre> <p>The above <code>while</code> loop would never terminate on its own, and the <code>for</code> loop would iterate up to 1000. These loops are both exited early by using the <code>break</code> keyword.</p> <p>In other circumstances, it is handy to be able to stop an iteration and move on to the next one immediately. The <code>continue</code> keyword accomplishes this:</p> <pre data-language="julia">julia&gt; for i = 1:10
         if i % 3 != 0
           continue
         end
         println(i)
       end
3
6
9
</pre> <p>This is a somewhat contrived example since we could produce the same behavior more clearly by negating the condition and placing the <code>println</code> call inside the <code>if</code> block. In realistic usage there is more code to be evaluated after the <code>continue</code>, and often there are multiple points from which one calls <code>continue</code>.</p> <p>Multiple nested <code>for</code> loops can be combined into a single outer loop, forming the cartesian product of its iterables:</p> <pre data-language="julia">julia&gt; for i = 1:2, j = 3:4
         println((i, j))
       end
(1,3)
(1,4)
(2,3)
(2,4)
</pre> <p>A <code>break</code> statement inside such a loop exits the entire nest of loops, not just the inner one.</p>   <h2 id="man-exception-handling">Exception Handling</h2> <p id="exception-handling">When an unexpected condition occurs, a function may be unable to return a reasonable value to its caller. In such cases, it may be best for the exceptional condition to either terminate the program, printing a diagnostic error message, or if the programmer has provided code to handle such exceptional circumstances, allow that code to take the appropriate action.</p>  <h3 id="built-in-exceptions">Built-in <code>Exception</code>s</h3> <p><code>Exception</code>s are thrown when an unexpected condition has occurred. The built-in <code>Exception</code>s listed below all interrupt the normal flow of control.</p> <table class="docutils">  <thead valign="bottom"> <tr class="row-odd">
<th class="head"><code>Exception</code></th> </tr> </thead>  <tr class="row-even">
<td><a class="reference internal" href="../../stdlib/base/#Base.ArgumentError" title="Base.ArgumentError"><code>ArgumentError</code></a></td> </tr> <tr class="row-odd">
<td><a class="reference internal" href="../../stdlib/base/#Base.BoundsError" title="Base.BoundsError"><code>BoundsError</code></a></td> </tr> <tr class="row-even">
<td><code>CompositeException</code></td> </tr> <tr class="row-odd">
<td><a class="reference internal" href="../../stdlib/base/#Base.DivideError" title="Base.DivideError"><code>DivideError</code></a></td> </tr> <tr class="row-even">
<td><a class="reference internal" href="../../stdlib/base/#Base.DomainError" title="Base.DomainError"><code>DomainError</code></a></td> </tr> <tr class="row-odd">
<td><a class="reference internal" href="../../stdlib/base/#Base.EOFError" title="Base.EOFError"><code>EOFError</code></a></td> </tr> <tr class="row-even">
<td><a class="reference internal" href="../../stdlib/base/#Base.ErrorException" title="Base.ErrorException"><code>ErrorException</code></a></td> </tr> <tr class="row-odd">
<td><a class="reference internal" href="../../stdlib/base/#Base.InexactError" title="Base.InexactError"><code>InexactError</code></a></td> </tr> <tr class="row-even">
<td><a class="reference internal" href="../../stdlib/base/#Base.InitError" title="Base.InitError"><code>InitError</code></a></td> </tr> <tr class="row-odd">
<td><a class="reference internal" href="../../stdlib/base/#Base.InterruptException" title="Base.InterruptException"><code>InterruptException</code></a></td> </tr> <tr class="row-even">
<td><code>InvalidStateException</code></td> </tr> <tr class="row-odd">
<td><a class="reference internal" href="../../stdlib/base/#Base.KeyError" title="Base.KeyError"><code>KeyError</code></a></td> </tr> <tr class="row-even">
<td><a class="reference internal" href="../../stdlib/base/#Base.LoadError" title="Base.LoadError"><code>LoadError</code></a></td> </tr> <tr class="row-odd">
<td><a class="reference internal" href="../../stdlib/base/#Base.OutOfMemoryError" title="Base.OutOfMemoryError"><code>OutOfMemoryError</code></a></td> </tr> <tr class="row-even">
<td><a class="reference internal" href="../../stdlib/base/#Base.ReadOnlyMemoryError" title="Base.ReadOnlyMemoryError"><code>ReadOnlyMemoryError</code></a></td> </tr> <tr class="row-odd">
<td><a class="reference internal" href="../../stdlib/parallel/#Base.RemoteException" title="Base.RemoteException"><code>RemoteException</code></a></td> </tr> <tr class="row-even">
<td><a class="reference internal" href="../../stdlib/base/#Base.MethodError" title="Base.MethodError"><code>MethodError</code></a></td> </tr> <tr class="row-odd">
<td><a class="reference internal" href="../../stdlib/base/#Base.OverflowError" title="Base.OverflowError"><code>OverflowError</code></a></td> </tr> <tr class="row-even">
<td><a class="reference internal" href="../../stdlib/base/#Base.ParseError" title="Base.ParseError"><code>ParseError</code></a></td> </tr> <tr class="row-odd">
<td><a class="reference internal" href="../../stdlib/base/#Base.SystemError" title="Base.SystemError"><code>SystemError</code></a></td> </tr> <tr class="row-even">
<td><a class="reference internal" href="../../stdlib/base/#Base.TypeError" title="Base.TypeError"><code>TypeError</code></a></td> </tr> <tr class="row-odd">
<td><a class="reference internal" href="../../stdlib/base/#Base.UndefRefError" title="Base.UndefRefError"><code>UndefRefError</code></a></td> </tr> <tr class="row-even">
<td><a class="reference internal" href="../../stdlib/base/#Base.UndefVarError" title="Base.UndefVarError"><code>UndefVarError</code></a></td> </tr> <tr class="row-odd">
<td><code>UnicodeError</code></td> </tr>  </table> <p>For example, the <a class="reference internal" href="../../stdlib/math/#Base.sqrt" title="Base.sqrt"><code>sqrt()</code></a> function throws a <a class="reference internal" href="../../stdlib/base/#Base.DomainError" title="Base.DomainError"><code>DomainError</code></a> if applied to a negative real value:</p> <pre data-language="julia">julia&gt; sqrt(-1)
ERROR: DomainError:
sqrt will only return a complex result if called with a complex argument. Try sqrt(complex(x)).
 in sqrt(::Int64) at ./math.jl:211
 ...
</pre> <p>You may define your own exceptions in the following way:</p> <pre data-language="julia">julia&gt; type MyCustomException &lt;: Exception end
</pre>   <h3 id="the-throw-function">The <a class="reference internal" href="../../stdlib/base/#Base.throw" title="Base.throw"><code>throw()</code></a> function</h3> <p>Exceptions can be created explicitly with <a class="reference internal" href="../../stdlib/base/#Base.throw" title="Base.throw"><code>throw()</code></a>. For example, a function defined only for nonnegative numbers could be written to <a class="reference internal" href="../../stdlib/base/#Base.throw" title="Base.throw"><code>throw()</code></a> a <a class="reference internal" href="../../stdlib/base/#Base.DomainError" title="Base.DomainError"><code>DomainError</code></a> if the argument is negative:</p> <pre data-language="julia">julia&gt; f(x) = x&gt;=0 ? exp(-x) : throw(DomainError())
f (generic function with 1 method)

julia&gt; f(1)
0.36787944117144233

julia&gt; f(-1)
ERROR: DomainError:
 in f(::Int64) at ./none:1
 ...
</pre> <p>Note that <a class="reference internal" href="../../stdlib/base/#Base.DomainError" title="Base.DomainError"><code>DomainError</code></a> without parentheses is not an exception, but a type of exception. It needs to be called to obtain an <code>Exception</code> object:</p> <pre data-language="julia">julia&gt; typeof(DomainError()) &lt;: Exception
true

julia&gt; typeof(DomainError) &lt;: Exception
false
</pre> <p>Additionally, some exception types take one or more arguments that are used for error reporting:</p> <pre data-language="julia">julia&gt; throw(UndefVarError(:x))
ERROR: UndefVarError: x not defined
 ...
</pre> <p>This mechanism can be implemented easily by custom exception types following the way <a class="reference internal" href="../../stdlib/base/#Base.UndefVarError" title="Base.UndefVarError"><code>UndefVarError</code></a> is written:</p> <pre data-language="julia">julia&gt; type MyUndefVarError &lt;: Exception
           var::Symbol
       end
julia&gt; Base.showerror(io::IO, e::MyUndefVarError) = print(io, e.var, " not defined");
</pre>   <h3 id="errors">Errors</h3> <p>The <a class="reference internal" href="../../stdlib/base/#Base.error" title="Base.error"><code>error()</code></a> function is used to produce an <a class="reference internal" href="../../stdlib/base/#Base.ErrorException" title="Base.ErrorException"><code>ErrorException</code></a> that interrupts the normal flow of control.</p> <p>Suppose we want to stop execution immediately if the square root of a negative number is taken. To do this, we can define a fussy version of the <a class="reference internal" href="../../stdlib/math/#Base.sqrt" title="Base.sqrt"><code>sqrt()</code></a> function that raises an error if its argument is negative:</p> <pre data-language="julia">julia&gt; fussy_sqrt(x) = x &gt;= 0 ? sqrt(x) : error("negative x not allowed")
fussy_sqrt (generic function with 1 method)

julia&gt; fussy_sqrt(2)
1.4142135623730951

julia&gt; fussy_sqrt(-1)
ERROR: negative x not allowed
 in fussy_sqrt(::Int64) at ./none:1
 ...
</pre> <p>If <code>fussy_sqrt</code> is called with a negative value from another function, instead of trying to continue execution of the calling function, it returns immediately, displaying the error message in the interactive session:</p> <pre data-language="julia">julia&gt; function verbose_fussy_sqrt(x)
         println("before fussy_sqrt")
         r = fussy_sqrt(x)
         println("after fussy_sqrt")
         return r
       end
verbose_fussy_sqrt (generic function with 1 method)

julia&gt; verbose_fussy_sqrt(2)
before fussy_sqrt
after fussy_sqrt
1.4142135623730951

julia&gt; verbose_fussy_sqrt(-1)
before fussy_sqrt
ERROR: negative x not allowed
 in fussy_sqrt at ./none:1 [inlined]
 in verbose_fussy_sqrt(::Int64) at ./none:3
 ...
</pre>   <h3 id="warnings-and-informational-messages">Warnings and informational messages</h3> <p>Julia also provides other functions that write messages to the standard error I/O, but do not throw any <code>Exception</code>s and hence do not interrupt execution:</p> <pre data-language="julia">julia&gt; info("Hi"); 1+1
INFO: Hi
2

julia&gt; warn("Hi"); 1+1
WARNING: Hi
2

julia&gt; error("Hi"); 1+1
ERROR: Hi
 in error(::String) at ./error.jl:21
 ...
</pre>   <h3 id="the-try-catch-statement">The <code>try/catch</code> statement</h3> <p>The <code>try/catch</code> statement allows for <code>Exception</code>s to be tested for. For example, a customized square root function can be written to automatically call either the real or complex square root method on demand using <code>Exception</code>s :</p> <pre data-language="julia">julia&gt; f(x) = try
         sqrt(x)
       catch
         sqrt(complex(x, 0))
       end
f (generic function with 1 method)

julia&gt; f(1)
1.0

julia&gt; f(-1)
0.0 + 1.0im
</pre> <p>It is important to note that in real code computing this function, one would compare <code>x</code> to zero instead of catching an exception. The exception is much slower than simply comparing and branching.</p> <p><code>try/catch</code> statements also allow the <code>Exception</code> to be saved in a variable. In this contrived example, the following example calculates the square root of the second element of <code>x</code> if <code>x</code> is indexable, otherwise assumes <code>x</code> is a real number and returns its square root:</p> <pre data-language="julia">julia&gt; sqrt_second(x) = try
         sqrt(x[2])
       catch y
         if isa(y, DomainError)
           sqrt(complex(x[2], 0))
         elseif isa(y, BoundsError)
           sqrt(x)
         end
       end
sqrt_second (generic function with 1 method)

julia&gt; sqrt_second([1 4])
2.0

julia&gt; sqrt_second([1 -4])
0.0 + 2.0im

julia&gt; sqrt_second(9)
3.0

julia&gt; sqrt_second(-9)
ERROR: DomainError:
 in sqrt_second(::Int64) at ./none:7
 ...
</pre> <p>Note that the symbol following <code>catch</code> will always be interpreted as a name for the exception, so care is needed when writing <code>try/catch</code> expressions on a single line. The following code will <em>not</em> work to return the value of <code>x</code> in case of an error:</p> <pre data-language="julia">try bad() catch x end
</pre> <p>Instead, use a semicolon or insert a line break after <code>catch</code>:</p> <pre data-language="julia">try bad() catch; x end

try bad()
catch
  x
end
</pre> <p>The <code>catch</code> clause is not strictly necessary; when omitted, the default return value is <code>nothing</code>.</p> <pre data-language="julia">julia&gt; try error() end #Returns nothing
</pre> <p>The power of the <code>try/catch</code> construct lies in the ability to unwind a deeply nested computation immediately to a much higher level in the stack of calling functions. There are situations where no error has occurred, but the ability to unwind the stack and pass a value to a higher level is desirable. Julia provides the <a class="reference internal" href="../../stdlib/base/#Base.rethrow" title="Base.rethrow"><code>rethrow()</code></a>, <a class="reference internal" href="../../stdlib/base/#Base.backtrace" title="Base.backtrace"><code>backtrace()</code></a> and <a class="reference internal" href="../../stdlib/base/#Base.catch_backtrace" title="Base.catch_backtrace"><code>catch_backtrace()</code></a> functions for more advanced error handling.</p>   <h3 id="finally-clauses">finally Clauses</h3> <p>In code that performs state changes or uses resources like files, there is typically clean-up work (such as closing files) that needs to be done when the code is finished. Exceptions potentially complicate this task, since they can cause a block of code to exit before reaching its normal end. The <code>finally</code> keyword provides a way to run some code when a given block of code exits, regardless of how it exits.</p> <p>For example, here is how we can guarantee that an opened file is closed:</p> <pre data-language="julia">f = open("file")
try
    # operate on file f
finally
    close(f)
end
</pre> <p>When control leaves the <code>try</code> block (for example due to a <code>return</code>, or just finishing normally), <code>close(f)</code> will be executed. If the <code>try</code> block exits due to an exception, the exception will continue propagating. A <code>catch</code> block may be combined with <code>try</code> and <code>finally</code> as well. In this case the <code>finally</code> block will run after <code>catch</code> has handled the error.</p>    <h2 id="man-tasks">Tasks (aka Coroutines)</h2> <p id="tasks-aka-coroutines">Tasks are a control flow feature that allows computations to be suspended and resumed in a flexible manner. This feature is sometimes called by other names, such as symmetric coroutines, lightweight threads, cooperative multitasking, or one-shot continuations.</p> <p>When a piece of computing work (in practice, executing a particular function) is designated as a <a class="reference internal" href="../../stdlib/parallel/#Base.Task" title="Base.Task"><code>Task</code></a>, it becomes possible to interrupt it by switching to another <a class="reference internal" href="../../stdlib/parallel/#Base.Task" title="Base.Task"><code>Task</code></a>. The original <a class="reference internal" href="../../stdlib/parallel/#Base.Task" title="Base.Task"><code>Task</code></a> can later be resumed, at which point it will pick up right where it left off. At first, this may seem similar to a function call. However there are two key differences. First, switching tasks does not use any space, so any number of task switches can occur without consuming the call stack. Second, switching among tasks can occur in any order, unlike function calls, where the called function must finish executing before control returns to the calling function.</p> <p>This kind of control flow can make it much easier to solve certain problems. In some problems, the various pieces of required work are not naturally related by function calls; there is no obvious “caller” or “callee” among the jobs that need to be done. An example is the producer-consumer problem, where one complex procedure is generating values and another complex procedure is consuming them. The consumer cannot simply call a producer function to get a value, because the producer may have more values to generate and so might not yet be ready to return. With tasks, the producer and consumer can both run as long as they need to, passing values back and forth as necessary.</p> <p>Julia provides the functions <a class="reference internal" href="../../stdlib/parallel/#Base.produce" title="Base.produce"><code>produce()</code></a> and <a class="reference internal" href="../../stdlib/parallel/#Base.consume" title="Base.consume"><code>consume()</code></a> for solving this problem. A producer is a function that calls <a class="reference internal" href="../../stdlib/parallel/#Base.produce" title="Base.produce"><code>produce()</code></a> on each value it needs to produce:</p> <pre data-language="julia">julia&gt; function producer()
         produce("start")
         for n=1:4
           produce(2n)
         end
         produce("stop")
       end;
</pre> <p>To consume values, first the producer is wrapped in a <a class="reference internal" href="../../stdlib/parallel/#Base.Task" title="Base.Task"><code>Task</code></a>, then <a class="reference internal" href="../../stdlib/parallel/#Base.consume" title="Base.consume"><code>consume()</code></a> is called repeatedly on that object:</p> <pre data-language="julia">julia&gt; p = Task(producer);

julia&gt; consume(p)
"start"

julia&gt; consume(p)
2

julia&gt; consume(p)
4

julia&gt; consume(p)
6

julia&gt; consume(p)
8

julia&gt; consume(p)
"stop"
</pre> <p>One way to think of this behavior is that <code>producer</code> was able to return multiple times. Between calls to <a class="reference internal" href="../../stdlib/parallel/#Base.produce" title="Base.produce"><code>produce()</code></a>, the producer’s execution is suspended and the consumer has control.</p> <p>A Task can be used as an iterable object in a <code>for</code> loop, in which case the loop variable takes on all the produced values:</p> <pre data-language="julia">julia&gt; for x in Task(producer)
         println(x)
       end
start
2
4
6
8
stop
</pre> <p>Note that the <a class="reference internal" href="../../stdlib/parallel/#Base.Task" title="Base.Task"><code>Task()</code></a> constructor expects a 0-argument function. A common pattern is for the producer to be parameterized, in which case a partial function application is needed to create a 0-argument <a class="reference internal" href="../functions/#man-anonymous-functions"><span>anonymous function</span></a>. This can be done either directly or by use of a convenience macro:</p> <pre data-language="julia">function mytask(myarg)
    ...
end

taskHdl = Task(() -&gt; mytask(7))
# or, equivalently
taskHdl = @task mytask(7)
</pre> <p><a class="reference internal" href="../../stdlib/parallel/#Base.produce" title="Base.produce"><code>produce()</code></a> and <a class="reference internal" href="../../stdlib/parallel/#Base.consume" title="Base.consume"><code>consume()</code></a> do not launch threads that can run on separate CPUs. True kernel threads are discussed under the topic of <a class="reference internal" href="../parallel-computing/#man-parallel-computing"><span>Parallel Computing</span></a>.</p>  <h3 id="core-task-operations">Core task operations</h3> <p>While <a class="reference internal" href="../../stdlib/parallel/#Base.produce" title="Base.produce"><code>produce()</code></a> and <a class="reference internal" href="../../stdlib/parallel/#Base.consume" title="Base.consume"><code>consume()</code></a> illustrate the essential nature of tasks, they are actually implemented as library functions using a more primitive function, <a class="reference internal" href="../../stdlib/parallel/#Base.yieldto" title="Base.yieldto"><code>yieldto()</code></a>. <code>yieldto(task,value)</code> suspends the current task, switches to the specified <code>task</code>, and causes that task’s last <a class="reference internal" href="../../stdlib/parallel/#Base.yieldto" title="Base.yieldto"><code>yieldto()</code></a> call to return the specified <code>value</code>. Notice that <a class="reference internal" href="../../stdlib/parallel/#Base.yieldto" title="Base.yieldto"><code>yieldto()</code></a> is the only operation required to use task-style control flow; instead of calling and returning we are always just switching to a different task. This is why this feature is also called “symmetric coroutines”; each task is switched to and from using the same mechanism.</p> <p><a class="reference internal" href="../../stdlib/parallel/#Base.yieldto" title="Base.yieldto"><code>yieldto()</code></a> is powerful, but most uses of tasks do not invoke it directly. Consider why this might be. If you switch away from the current task, you will probably want to switch back to it at some point, but knowing when to switch back, and knowing which task has the responsibility of switching back, can require considerable coordination. For example, <a class="reference internal" href="../../stdlib/parallel/#Base.produce" title="Base.produce"><code>produce()</code></a> needs to maintain some state to remember who the consumer is. Not needing to manually keep track of the consuming task is what makes <a class="reference internal" href="../../stdlib/parallel/#Base.produce" title="Base.produce"><code>produce()</code></a> easier to use than <a class="reference internal" href="../../stdlib/parallel/#Base.yieldto" title="Base.yieldto"><code>yieldto()</code></a>.</p> <p>In addition to <a class="reference internal" href="../../stdlib/parallel/#Base.yieldto" title="Base.yieldto"><code>yieldto()</code></a>, a few other basic functions are needed to use tasks effectively.</p> <ul class="simple"> <li>
<a class="reference internal" href="../../stdlib/parallel/#Base.current_task" title="Base.current_task"><code>current_task()</code></a> gets a reference to the currently-running task.</li> <li>
<a class="reference internal" href="../../stdlib/parallel/#Base.istaskdone" title="Base.istaskdone"><code>istaskdone()</code></a> queries whether a task has exited.</li> <li>
<a class="reference internal" href="../../stdlib/parallel/#Base.istaskstarted" title="Base.istaskstarted"><code>istaskstarted()</code></a> queries whether a task has run yet.</li> <li>
<a class="reference internal" href="../../stdlib/parallel/#Base.task_local_storage" title="Base.task_local_storage"><code>task_local_storage()</code></a> manipulates a key-value store specific to the current task.</li> </ul>   <h3 id="tasks-and-events">Tasks and events</h3> <p>Most task switches occur as a result of waiting for events such as I/O requests, and are performed by a scheduler included in the standard library. The scheduler maintains a queue of runnable tasks, and executes an event loop that restarts tasks based on external events such as message arrival.</p> <p>The basic function for waiting for an event is <a class="reference internal" href="../../stdlib/parallel/#Base.wait" title="Base.wait"><code>wait()</code></a>. Several objects implement <a class="reference internal" href="../../stdlib/parallel/#Base.wait" title="Base.wait"><code>wait()</code></a>; for example, given a <code>Process</code> object, <a class="reference internal" href="../../stdlib/parallel/#Base.wait" title="Base.wait"><code>wait()</code></a> will wait for it to exit. <a class="reference internal" href="../../stdlib/parallel/#Base.wait" title="Base.wait"><code>wait()</code></a> is often implicit; for example, a <a class="reference internal" href="../../stdlib/parallel/#Base.wait" title="Base.wait"><code>wait()</code></a> can happen inside a call to <a class="reference internal" href="../../stdlib/io-network/#Base.read" title="Base.read"><code>read()</code></a> to wait for data to be available.</p> <p>In all of these cases, <a class="reference internal" href="../../stdlib/parallel/#Base.wait" title="Base.wait"><code>wait()</code></a> ultimately operates on a <a class="reference internal" href="../../stdlib/parallel/#Base.Condition" title="Base.Condition"><code>Condition</code></a> object, which is in charge of queueing and restarting tasks. When a task calls <a class="reference internal" href="../../stdlib/parallel/#Base.wait" title="Base.wait"><code>wait()</code></a> on a <a class="reference internal" href="../../stdlib/parallel/#Base.Condition" title="Base.Condition"><code>Condition</code></a>, the task is marked as non-runnable, added to the condition’s queue, and switches to the scheduler. The scheduler will then pick another task to run, or block waiting for external events. If all goes well, eventually an event handler will call <a class="reference internal" href="../../stdlib/parallel/#Base.notify" title="Base.notify"><code>notify()</code></a> on the condition, which causes tasks waiting for that condition to become runnable again.</p> <p>A task created explicitly by calling <a class="reference internal" href="../../stdlib/parallel/#Base.Task" title="Base.Task"><code>Task</code></a> is initially not known to the scheduler. This allows you to manage tasks manually using <a class="reference internal" href="../../stdlib/parallel/#Base.yieldto" title="Base.yieldto"><code>yieldto()</code></a> if you wish. However, when such a task waits for an event, it still gets restarted automatically when the event happens, as you would expect. It is also possible to make the scheduler run a task whenever it can, without necessarily waiting for any events. This is done by calling <a class="reference internal" href="../../stdlib/parallel/#Base.schedule" title="Base.schedule"><code>schedule()</code></a>, or using the <a class="reference internal" href="../../stdlib/parallel/#Base.@schedule" title="Base.@schedule"><code>@schedule</code></a> or <a class="reference internal" href="../../stdlib/parallel/#Base.@async" title="Base.@async"><code>@async</code></a> macros (see <a class="reference internal" href="../parallel-computing/#man-parallel-computing"><span>Parallel Computing</span></a> for more details).</p>   <h3 id="task-states">Task states</h3> <p>Tasks have a <code>state</code> field that describes their execution status. A task state is one of the following symbols:</p> <table class="docutils">  <thead valign="bottom"> <tr class="row-odd">
<th class="head">Symbol</th> <th class="head">Meaning</th> </tr> </thead>  <tr class="row-even">
<td><code>:runnable</code></td> <td>Currently running, or available to be switched to</td> </tr> <tr class="row-odd">
<td><code>:waiting</code></td> <td>Blocked waiting for a specific event</td> </tr> <tr class="row-even">
<td><code>:queued</code></td> <td>In the scheduler’s run queue about to be restarted</td> </tr> <tr class="row-odd">
<td><code>:done</code></td> <td>Successfully finished executing</td> </tr> <tr class="row-even">
<td><code>:failed</code></td> <td>Finished with an uncaught exception</td> </tr>  </table>
<div class="_attribution">
  <p class="_attribution-p">
    © 2009–2016 Jeff Bezanson, Stefan Karpinski, Viral B. Shah, and other contributors<br>Licensed under the MIT License.<br>
    <a href="http://docs.julialang.org/en/release-0.5/manual/control-flow/" class="_attribution-link" target="_blank">http://docs.julialang.org/en/release-0.5/manual/control-flow/</a>
  </p>
</div>

			</div>
		</div>
	</section>

	</div>
</body>
</html>
