
<!DOCTYPE HTML>

<html lang="en">

<head>
  <meta charset="utf-8">
  <title>Complex and Rational Numbers - Julia - W3cubDocs</title>
  
  <meta name="description" content="Julia ships with predefined types representing both complex and rational numbers, and supports all standard mathematical operations on them. &hellip;">
  <meta name="keywords" content="complex, and, rational, numbers, -, julia">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="http://docs.w3cub.com/julia/manual/complex-and-rational-numbers/">
  <link href="/favicon.png" rel="icon">
  <link type="text/css" rel="stylesheet" href="/assets/application-50364fff564ce3b6327021805f3f00e2957b441cf27f576a7dd4ff63bbc47047.css">
  <script type="text/javascript" src="/assets/application-db64bfd54ceb42be11af7995804cf4902548419ceb79d509b0b7d62c22d98e6f.js"></script>
  <script src="/json/julia.js"></script>
  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-71174418-1']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>


</head>

<body>
	<div class="_app">
	<header class="_header">
  
  <form class="_search">
    <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
    <a class="_search-clear"></a>
    <div class="_search-tag"></div>
  </form>
  
  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/julia/" class="_nav-link" title="" style="margin-left:0;">Julia</a></span>
  
  <nav class="_nav">
    <a href="/app/" class="_nav-link ">App</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		<div class="_list">
			
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<div class="_page _sphinx_simple">
				
<h1 id="man-complex-and-rational-numbers">Complex and Rational Numbers</h1> <p>Julia ships with predefined types representing both complex and rational numbers, and supports all <a class="reference internal" href="../mathematical-operations/#man-mathematical-operations"><span>standard mathematical operations</span></a> on them. <a class="reference internal" href="../conversion-and-promotion/#man-conversion-and-promotion"><span>Conversion and Promotion</span></a> are defined so that operations on any combination of predefined numeric types, whether primitive or composite, behave as expected.</p>  <h2 id="man-complex-numbers">Complex Numbers</h2> <p id="complex-numbers">The global constant <a class="reference internal" href="../../stdlib/numbers/#Base.im" title="Base.im"><code>im</code></a> is bound to the complex number <em>i</em>, representing the principal square root of -1. It was deemed harmful to co-opt the name <code>i</code> for a global constant, since it is such a popular index variable name. Since Julia allows numeric literals to be <a class="reference internal" href="../integers-and-floating-point-numbers/#man-numeric-literal-coefficients"><span>juxtaposed with identifiers as coefficients</span></a>, this binding suffices to provide convenient syntax for complex numbers, similar to the traditional mathematical notation:</p> <pre data-language="julia">julia&gt; 1 + 2im
1 + 2im
</pre> <p>You can perform all the standard arithmetic operations with complex numbers:</p> <pre data-language="julia">julia&gt; (1 + 2im)*(2 - 3im)
8 + 1im

julia&gt; (1 + 2im)/(1 - 2im)
-0.6 + 0.8im

julia&gt; (1 + 2im) + (1 - 2im)
2 + 0im

julia&gt; (-3 + 2im) - (5 - 1im)
-8 + 3im

julia&gt; (-1 + 2im)^2
-3 - 4im

julia&gt; (-1 + 2im)^2.5
2.7296244647840084 - 6.960664459571898im

julia&gt; (-1 + 2im)^(1 + 1im)
-0.27910381075826657 + 0.08708053414102428im

julia&gt; 3(2 - 5im)
6 - 15im

julia&gt; 3(2 - 5im)^2
-63 - 60im

julia&gt; 3(2 - 5im)^-1.0
0.20689655172413796 + 0.5172413793103449im
</pre> <p>The promotion mechanism ensures that combinations of operands of different types just work:</p> <pre data-language="julia">julia&gt; 2(1 - 1im)
2 - 2im

julia&gt; (2 + 3im) - 1
1 + 3im

julia&gt; (1 + 2im) + 0.5
1.5 + 2.0im

julia&gt; (2 + 3im) - 0.5im
2.0 + 2.5im

julia&gt; 0.75(1 + 2im)
0.75 + 1.5im

julia&gt; (2 + 3im) / 2
1.0 + 1.5im

julia&gt; (1 - 3im) / (2 + 2im)
-0.5 - 1.0im

julia&gt; 2im^2
-2 + 0im

julia&gt; 1 + 3/4im
1.0 - 0.75im
</pre> <p>Note that <code>3/4im == 3/(4*im) == -(3/4*im)</code>, since a literal coefficient binds more tightly than division.</p> <p>Standard functions to manipulate complex values are provided:</p> <pre data-language="julia">julia&gt; real(1 + 2im)
1

julia&gt; imag(1 + 2im)
2

julia&gt; conj(1 + 2im)
1 - 2im

julia&gt; abs(1 + 2im)
2.23606797749979

julia&gt; abs2(1 + 2im)
5

julia&gt; angle(1 + 2im)
1.1071487177940904
</pre> <p>As usual, the absolute value (<a class="reference internal" href="../../stdlib/math/#Base.abs" title="Base.abs"><code>abs()</code></a>) of a complex number is its distance from zero. <a class="reference internal" href="../../stdlib/math/#Base.abs2" title="Base.abs2"><code>abs2()</code></a> gives the square of the absolute value, and is of particular use for complex numbers where it avoids taking a square root. <a class="reference internal" href="../../stdlib/math/#Base.angle" title="Base.angle"><code>angle()</code></a> returns the phase angle in radians (also known as the <em>argument</em> or <em>arg</em> function). The full gamut of other <a class="reference internal" href="../mathematical-operations/#man-elementary-functions"><span>Elementary Functions</span></a> is also defined for complex numbers:</p> <pre data-language="julia">julia&gt; sqrt(1im)
0.7071067811865476 + 0.7071067811865475im

julia&gt; sqrt(1 + 2im)
1.272019649514069 + 0.7861513777574233im

julia&gt; cos(1 + 2im)
2.0327230070196656 - 3.0518977991518im

julia&gt; exp(1 + 2im)
-1.1312043837568135 + 2.4717266720048188im

julia&gt; sinh(1 + 2im)
-0.4890562590412937 + 1.4031192506220405im
</pre> <p>Note that mathematical functions typically return real values when applied to real numbers and complex values when applied to complex numbers. For example, <a class="reference internal" href="../../stdlib/math/#Base.sqrt" title="Base.sqrt"><code>sqrt()</code></a> behaves differently when applied to <code>-1</code> versus <code>-1 + 0im</code> even though <code>-1 == -1 + 0im</code>:</p> <pre data-language="julia">julia&gt; sqrt(-1)
ERROR: DomainError:
sqrt will only return a complex result if called with a complex argument. Try sqrt(complex(x)).
 in sqrt(::Int64) at ./math.jl:211
 ...

julia&gt; sqrt(-1 + 0im)
0.0 + 1.0im
</pre> <p>The <a class="reference internal" href="../integers-and-floating-point-numbers/#man-numeric-literal-coefficients"><span>literal numeric coefficient notation</span></a> does not work when constructing complex number from variables. Instead, the multiplication must be explicitly written out:</p> <pre data-language="julia">julia&gt; a = 1; b = 2; a + b*im
1 + 2im
</pre> <p>However, this is <em>not</em> recommended; Use the <a class="reference internal" href="../../stdlib/numbers/#Base.complex" title="Base.complex"><code>complex()</code></a> function instead to construct a complex value directly from its real and imaginary parts.:</p> <pre data-language="julia">julia&gt; complex(a,b)
1 + 2im
</pre> <p>This construction avoids the multiplication and addition operations.</p> <p><a class="reference internal" href="../../stdlib/numbers/#Base.Inf" title="Base.Inf"><code>Inf</code></a> and <a class="reference internal" href="../../stdlib/numbers/#Base.NaN" title="Base.NaN"><code>NaN</code></a> propagate through complex numbers in the real and imaginary parts of a complex number as described in the <a class="reference internal" href="../integers-and-floating-point-numbers/#man-special-floats"><span>Special floating-point values</span></a> section:</p> <pre data-language="julia">julia&gt; 1 + Inf*im
1.0 + Inf*im

julia&gt; 1 + NaN*im
1.0 + NaN*im
</pre>   <h2 id="man-rational-numbers">Rational Numbers</h2> <p id="rational-numbers">Julia has a rational number type to represent exact ratios of integers. Rationals are constructed using the <a class="reference internal" href="../../stdlib/math/#Base.//" title="Base.//"><code>//</code></a> operator:</p> <pre data-language="julia">julia&gt; 2//3
2//3
</pre> <p>If the numerator and denominator of a rational have common factors, they are reduced to lowest terms such that the denominator is non-negative:</p> <pre data-language="julia">julia&gt; 6//9
2//3

julia&gt; -4//8
-1//2

julia&gt; 5//-15
-1//3

julia&gt; -4//-12
1//3
</pre> <p>This normalized form for a ratio of integers is unique, so equality of rational values can be tested by checking for equality of the numerator and denominator. The standardized numerator and denominator of a rational value can be extracted using the <a class="reference internal" href="../../stdlib/math/#Base.num" title="Base.num"><code>num()</code></a> and <a class="reference internal" href="../../stdlib/math/#Base.den" title="Base.den"><code>den()</code></a> functions:</p> <pre data-language="julia">julia&gt; num(2//3)
2

julia&gt; den(2//3)
3
</pre> <p>Direct comparison of the numerator and denominator is generally not necessary, since the standard arithmetic and comparison operations are defined for rational values:</p> <pre data-language="julia">julia&gt; 2//3 == 6//9
true

julia&gt; 2//3 == 9//27
false

julia&gt; 3//7 &lt; 1//2
true

julia&gt; 3//4 &gt; 2//3
true

julia&gt; 2//4 + 1//6
2//3

julia&gt; 5//12 - 1//4
1//6

julia&gt; 5//8 * 3//12
5//32

julia&gt; 6//5 / 10//7
21//25
</pre> <p>Rationals can be easily converted to floating-point numbers:</p> <pre data-language="julia">julia&gt; float(3//4)
0.75
</pre> <p>Conversion from rational to floating-point respects the following identity for any integral values of <code>a</code> and <code>b</code>, with the exception of the case <code>a == 0</code> and <code>b == 0</code>:</p> <pre data-language="julia">julia&gt; isequal(float(a//b), a/b)
true
</pre> <p>Constructing infinite rational values is acceptable:</p> <pre data-language="julia">julia&gt; 5//0
1//0

julia&gt; -3//0
-1//0

julia&gt; typeof(ans)
Rational{Int64}
</pre> <p>Trying to construct a <a class="reference internal" href="../../stdlib/numbers/#Base.NaN" title="Base.NaN"><code>NaN</code></a> rational value, however, is not:</p> <pre data-language="julia">julia&gt; 0//0
ERROR: ArgumentError: invalid rational: zero(Int64)//zero(Int64)
 in Rational{Int64}(::Int64, ::Int64) at ./rational.jl:8
 in //(::Int64, ::Int64) at ./rational.jl:22
 ...
</pre> <p>As usual, the promotion system makes interactions with other numeric types effortless:</p> <pre data-language="julia">julia&gt; 3//5 + 1
8//5

julia&gt; 3//5 - 0.5
0.09999999999999998

julia&gt; 2//7 * (1 + 2im)
2//7 + 4//7*im

julia&gt; 2//7 * (1.5 + 2im)
0.42857142857142855 + 0.5714285714285714im

julia&gt; 3//2 / (1 + 2im)
3//10 - 3//5*im

julia&gt; 1//2 + 2im
1//2 + 2//1*im

julia&gt; 1 + 2//3im
1//1 - 2//3*im

julia&gt; 0.5 == 1//2
true

julia&gt; 0.33 == 1//3
false

julia&gt; 0.33 &lt; 1//3
true

julia&gt; 1//3 - 0.33
0.0033333333333332993
</pre>
<div class="_attribution">
  <p class="_attribution-p">
    © 2009–2016 Jeff Bezanson, Stefan Karpinski, Viral B. Shah, and other contributors<br>Licensed under the MIT License.<br>
    <a href="http://docs.julialang.org/en/release-0.5/manual/complex-and-rational-numbers/" class="_attribution-link" target="_blank">http://docs.julialang.org/en/release-0.5/manual/complex-and-rational-numbers/</a>
  </p>
</div>

			</div>
		</div>
	</section>

	</div>
</body>
</html>
