
<!DOCTYPE HTML>

<html lang="en">

<head>
  <meta charset="utf-8">
  <title>Traditional Warnings - GCC 4 CPP - W3cubDocs</title>
  
  <meta name="description" content="You can request warnings about features that did not exist, or worked differently, in traditional C with the -Wtraditional option. GCC does not warn &hellip;">
  <meta name="keywords" content="traditional, warnings, -, gcc, cpp, gcc~4_cpp">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="http://docs.w3cub.com/gcc~4_cpp/traditional-warnings/">
  <link href="/favicon.png" rel="icon">
  <link type="text/css" rel="stylesheet" href="/assets/application-50364fff564ce3b6327021805f3f00e2957b441cf27f576a7dd4ff63bbc47047.css">
  <script type="text/javascript" src="/assets/application-db64bfd54ceb42be11af7995804cf4902548419ceb79d509b0b7d62c22d98e6f.js"></script>
  <script src="/json/gcc~4_cpp.js"></script>
  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-71174418-1']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>


</head>

<body>
	<div class="_app">
	<header class="_header">
  
  <form class="_search">
    <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
    <a class="_search-clear"></a>
    <div class="_search-tag"></div>
  </form>
  
  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/gcc~4_cpp/" class="_nav-link" title="" style="margin-left:0;">GCC 4 CPP</a></span>
  
  <nav class="_nav">
    <a href="/app/" class="_nav-link ">App</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		<div class="_list">
			
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<div class="_page _gnu">
				
<h1 class="section" id="Traditional-warnings">10.4 Traditional warnings</h1> <p>You can request warnings about features that did not exist, or worked differently, in traditional C with the <code>-Wtraditional</code> option. GCC does not warn about features of ISO C which you must use when you are using a conforming compiler, such as the ‘<code>#</code>’ and ‘<code>##</code>’ operators. </p>
<p>Presently <code>-Wtraditional</code> warns about: </p>
<ul> <li>Macro parameters that appear within string literals in the macro body. In traditional C macro replacement takes place within string literals, but does not in ISO C. </li>
<li>In traditional C, some preprocessor directives did not exist. Traditional preprocessors would only consider a line to be a directive if the ‘<code>#</code>’ appeared in column 1 on the line. Therefore <code>-Wtraditional</code> warns about directives that traditional C understands but would ignore because the ‘<code>#</code>’ does not appear as the first character on the line. It also suggests you hide directives like ‘<code>#pragma</code>’ not understood by traditional C by indenting them. Some traditional implementations would not recognize ‘<code>#elif</code>’, so it suggests avoiding it altogether. </li>
<li>A function-like macro that appears without an argument list. In some traditional preprocessors this was an error. In ISO C it merely means that the macro is not expanded. </li>
<li>The unary plus operator. This did not exist in traditional C. </li>
<li>The ‘<code>U</code>’ and ‘<code>LL</code>’ integer constant suffixes, which were not available in traditional C. (Traditional C does support the ‘<code>L</code>’ suffix for simple long integer constants.) You are not warned about uses of these suffixes in macros defined in system headers. For instance, <code>UINT_MAX</code> may well be defined as <code>4294967295U</code>, but you will not be warned if you use <code>UINT_MAX</code>. <p>You can usually avoid the warning, and the related warning about constants which are so large that they are unsigned, by writing the integer constant in question in hexadecimal, with no U suffix. Take care, though, because this gives the wrong result in exotic cases. </p>
</li>
</ul>
<div class="_attribution">
  <p class="_attribution-p">
    © Free Software Foundation<br>Licensed under the GNU Free Documentation License, Version 1.3.<br>
    <a href="https://gcc.gnu.org/onlinedocs/gcc-4.9.3/cpp/Traditional-warnings.html" class="_attribution-link" target="_blank">https://gcc.gnu.org/onlinedocs/gcc-4.9.3/cpp/Traditional-warnings.html</a>
  </p>
</div>

			</div>
		</div>
	</section>

	</div>
</body>
</html>
