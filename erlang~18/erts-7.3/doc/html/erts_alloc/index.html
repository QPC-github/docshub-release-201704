
<!DOCTYPE HTML>

<html lang="en">

<head>
  <meta charset="utf-8">
  <title>Erts_alloc - Erlang 18 - W3cubDocs</title>
  
  <meta name="description" content=" erts_alloc ">
  <meta name="keywords" content="erts, alloc, -, erlang, erlang~18">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="http://docs.w3cub.com/erlang~18/erts-7.3/doc/html/erts_alloc/">
  <link href="/favicon.png" rel="icon">
  <link type="text/css" rel="stylesheet" href="/assets/application-50364fff564ce3b6327021805f3f00e2957b441cf27f576a7dd4ff63bbc47047.css">
  <script type="text/javascript" src="/assets/application-db64bfd54ceb42be11af7995804cf4902548419ceb79d509b0b7d62c22d98e6f.js"></script>
  <script src="/json/erlang~18.js"></script>
  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-71174418-1']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>


</head>

<body>
	<div class="_app">
	<header class="_header">
  
  <form class="_search">
    <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
    <a class="_search-clear"></a>
    <div class="_search-tag"></div>
  </form>
  
  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/erlang~18/" class="_nav-link" title="" style="margin-left:0;">Erlang 18</a></span>
  
  <nav class="_nav">
    <a href="/app/" class="_nav-link ">App</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		<div class="_list">
			
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<div class="_page _erlang">
				
<h1>erts_alloc</h1> <h2>C library</h2> <p class="REFBODY">erts_alloc</p> <h2>Library summary</h2> <p class="REFBODY">An Erlang Run-Time System internal memory allocator library.</p> <h2>Description</h2> 
<p><code class="code">erts_alloc</code> is an Erlang Run-Time System internal memory allocator library. <code class="code">erts_alloc</code> provides the Erlang Run-Time System with a number of memory allocators.</p>  <h2 id="id195521">Allocators</h2>   <p>Currently the following allocators are present:</p> <dl> <dt><strong><code class="code">temp_alloc</code></strong></dt> <dd>Allocator used for temporary allocations.</dd> <dt><strong><code class="code">eheap_alloc</code></strong></dt> <dd>Allocator used for Erlang heap data, such as Erlang process heaps.</dd> <dt><strong><code class="code">binary_alloc</code></strong></dt> <dd>Allocator used for Erlang binary data.</dd> <dt><strong><code class="code">ets_alloc</code></strong></dt> <dd>Allocator used for ETS data.</dd> <dt><strong><code class="code">driver_alloc</code></strong></dt> <dd>Allocator used for driver data.</dd> <dt><strong><code class="code">sl_alloc</code></strong></dt> <dd>Allocator used for memory blocks that are expected to be short-lived.</dd> <dt><strong><code class="code">ll_alloc</code></strong></dt> <dd>Allocator used for memory blocks that are expected to be long-lived, for example Erlang code.</dd> <dt><strong><code class="code">fix_alloc</code></strong></dt> <dd>A fast allocator used for some frequently used fixed size data types.</dd> <dt><strong><code class="code">std_alloc</code></strong></dt> <dd>Allocator used for most memory blocks not allocated via any of the other allocators described above.</dd> <dt><strong><code class="code">sys_alloc</code></strong></dt> <dd>This is normally the default <code class="code">malloc</code> implementation used on the specific OS.</dd> <dt><strong><code class="code">mseg_alloc</code></strong></dt> <dd>A memory segment allocator. <code class="code">mseg_alloc</code> is used by other allocators for allocating memory segments and is currently only available on systems that have the <code class="code">mmap</code> system call. Memory segments that are deallocated are kept for a while in a segment cache before they are destroyed. When segments are allocated, cached segments are used if possible instead of creating new segments. This in order to reduce the number of system calls made.</dd> </dl> <p><code class="code">sys_alloc</code> is always enabled and cannot be disabled. <code class="code">mseg_alloc</code> is always enabled if it is available and an allocator that uses it is enabled. All other allocators can be <code class="bold_code"><a href="#M_e">enabled or disabled</a></code>. By default all allocators are enabled. When an allocator is disabled, <code class="code">sys_alloc</code> is used instead of the disabled allocator.</p> <p>The main idea with the <code class="code">erts_alloc</code> library is to separate memory blocks that are used differently into different memory areas, and by this achieving less memory fragmentation. By putting less effort in finding a good fit for memory blocks that are frequently allocated than for those less frequently allocated, a performance gain can be achieved.</p>  <h2 id="id195690">The alloc_util framework</h2>   <p>Internally a framework called <code class="code">alloc_util</code> is used for implementing allocators. <code class="code">sys_alloc</code>, and <code class="code">mseg_alloc</code> do not use this framework; hence, the following does <strong>not</strong> apply to them.</p> <p>An allocator manages multiple areas, called carriers, in which memory blocks are placed. A carrier is either placed in a separate memory segment (allocated via <code class="code">mseg_alloc</code>), or in the heap segment (allocated via <code class="code">sys_alloc</code>). Multiblock carriers are used for storage of several blocks. Singleblock carriers are used for storage of one block. Blocks that are larger than the value of the singleblock carrier threshold (<code class="bold_code"><a href="#M_sbct">sbct</a></code>) parameter are placed in singleblock carriers. Blocks that are smaller than the value of the <code class="code">sbct</code> parameter are placed in multiblock carriers. Normally an allocator creates a "main multiblock carrier". Main multiblock carriers are never deallocated. The size of the main multiblock carrier is determined by the value of the <code class="bold_code"><a href="#M_mmbcs">mmbcs</a></code> parameter.</p> <p id="mseg_mbc_sizes">Sizes of multiblock carriers allocated via <code class="code">mseg_alloc</code> are decided based on the values of the largest multiblock carrier size (<code class="bold_code"><a href="#M_lmbcs">lmbcs</a></code>), the smallest multiblock carrier size (<code class="bold_code"><a href="#M_smbcs">smbcs</a></code>), and the multiblock carrier growth stages (<code class="bold_code"><a href="#M_mbcgs">mbcgs</a></code>) parameters. If <code class="code">nc</code> is the current number of multiblock carriers (the main multiblock carrier excluded) managed by an allocator, the size of the next <code class="code">mseg_alloc</code> multiblock carrier allocated by this allocator will roughly be <code class="code">smbcs+nc*(lmbcs-smbcs)/mbcgs</code> when <code class="code">nc &lt;= mbcgs</code>, and <code class="code">lmbcs</code> when <code class="code">nc &gt; mbcgs</code>. If the value of the <code class="code">sbct</code> parameter should be larger than the value of the <code class="code">lmbcs</code> parameter, the allocator may have to create multiblock carriers that are larger than the value of the <code class="code">lmbcs</code> parameter, though. Singleblock carriers allocated via <code class="code">mseg_alloc</code> are sized to whole pages.</p> <p>Sizes of carriers allocated via <code class="code">sys_alloc</code> are decided based on the value of the <code class="code">sys_alloc</code> carrier size (<code class="bold_code"><a href="#Muycs">ycs</a></code>) parameter. The size of a carrier is the least number of multiples of the value of the <code class="code">ycs</code> parameter that satisfies the request.</p> <p>Coalescing of free blocks are always performed immediately. Boundary tags (headers and footers) in free blocks are used which makes the time complexity for coalescing constant.</p> <p id="strategy">The memory allocation strategy used for multiblock carriers by an allocator is configurable via the <code class="bold_code"><a href="#M_as">as</a></code> parameter. Currently the following strategies are available:</p> <dl> <dt><strong>Best fit</strong></dt> <dd> <p>Strategy: Find the smallest block that satisfies the requested block size.</p> <p>Implementation: A balanced binary search tree is used. The time complexity is proportional to log N, where N is the number of sizes of free blocks.</p> </dd> <dt><strong>Address order best fit</strong></dt> <dd> <p>Strategy: Find the smallest block that satisfies the requested block size. If multiple blocks are found, choose the one with the lowest address.</p> <p>Implementation: A balanced binary search tree is used. The time complexity is proportional to log N, where N is the number of free blocks.</p> </dd> <dt><strong>Address order first fit</strong></dt> <dd> <p>Strategy: Find the block with the lowest address that satisfies the requested block size.</p> <p>Implementation: A balanced binary search tree is used. The time complexity is proportional to log N, where N is the number of free blocks.</p> </dd> <dt><strong>Address order first fit carrier best fit</strong></dt> <dd> <p>Strategy: Find the <strong>carrier</strong> with the lowest address that can satisfy the requested block size, then find a block within that carrier using the "best fit" strategy.</p> <p>Implementation: Balanced binary search trees are used. The time complexity is proportional to log N, where N is the number of free blocks.</p> </dd> <dt><strong>Address order first fit carrier address order best fit</strong></dt> <dd> <p>Strategy: Find the <strong>carrier</strong> with the lowest address that can satisfy the requested block size, then find a block within that carrier using the "adress order best fit" strategy.</p> <p>Implementation: Balanced binary search trees are used. The time complexity is proportional to log N, where N is the number of free blocks.</p> </dd> <dt><strong>Good fit</strong></dt> <dd> <p>Strategy: Try to find the best fit, but settle for the best fit found during a limited search.</p> <p>Implementation: The implementation uses segregated free lists with a maximum block search depth (in each list) in order to find a good fit fast. When the maximum block search depth is small (by default 3) this implementation has a time complexity that is constant. The maximum block search depth is configurable via the <code class="bold_code"><a href="#M_mbsd">mbsd</a></code> parameter.</p> </dd> <dt><strong>A fit</strong></dt> <dd> <p>Strategy: Do not search for a fit, inspect only one free block to see if it satisfies the request. This strategy is only intended to be used for temporary allocations.</p> <p>Implementation: Inspect the first block in a free-list. If it satisfies the request, it is used; otherwise, a new carrier is created. The implementation has a time complexity that is constant.</p> <p>As of erts version 5.6.1 the emulator will refuse to use this strategy on other allocators than <code class="code">temp_alloc</code>. This since it will only cause problems for other allocators.</p> </dd> </dl> <p>Apart from the ordinary allocators described above a number of pre-allocators are used for some specific data types. These pre-allocators pre-allocate a fixed amount of memory for certain data types when the run-time system starts. As long as pre-allocated memory is available, it will be used. When no pre-allocated memory is available, memory will be allocated in ordinary allocators. These pre-allocators are typically much faster than the ordinary allocators, but can only satisfy a limited amount of requests.</p>  <h2 id="id196024">System Flags Effecting erts_alloc</h2>   <div class="warning"> <div class="label">Warning</div> <div class="content">

<p>Only use these flags if you are absolutely sure what you are doing. Unsuitable settings may cause serious performance degradation and even a system crash at any time during operation.</p> </div> </div> <p>Memory allocator system flags have the following syntax: <code class="code">+M&lt;S&gt;&lt;P&gt; &lt;V&gt;</code> where <code class="code">&lt;S&gt;</code> is a letter identifying a subsystem, <code class="code">&lt;P&gt;</code> is a parameter, and <code class="code">&lt;V&gt;</code> is the value to use. The flags can be passed to the Erlang emulator (<code class="bold_code"><a href="../erl/">erl</a></code>) as command line arguments.</p> <p>System flags effecting specific allocators have an upper-case letter as <code class="code">&lt;S&gt;</code>. The following letters are used for the currently present allocators:</p> <ul> <li><code class="code">B: binary_alloc</code></li> <li><code class="code">D: std_alloc</code></li> <li><code class="code">E: ets_alloc</code></li> <li><code class="code">F: fix_alloc</code></li> <li><code class="code">H: eheap_alloc</code></li> <li><code class="code">L: ll_alloc</code></li> <li><code class="code">M: mseg_alloc</code></li> <li><code class="code">R: driver_alloc</code></li> <li><code class="code">S: sl_alloc</code></li> <li><code class="code">T: temp_alloc</code></li> <li><code class="code">Y: sys_alloc</code></li> </ul> <p>The following flags are available for configuration of <code class="code">mseg_alloc</code>:</p> <dl> <dt><strong id="MMamcbf"><code class="code">+MMamcbf &lt;size&gt;</code></strong></dt> <dd> Absolute max cache bad fit (in kilobytes). A segment in the memory segment cache is not reused if its size exceeds the requested size with more than the value of this parameter. Default value is 4096. </dd> <dt><strong id="MMrmcbf"><code class="code">+MMrmcbf &lt;ratio&gt;</code></strong></dt> <dd> Relative max cache bad fit (in percent). A segment in the memory segment cache is not reused if its size exceeds the requested size with more than relative max cache bad fit percent of the requested size. Default value is 20.</dd> <dt><strong id="MMsco"><code class="code">+MMsco true|false</code></strong></dt> <dd> Set <code class="bold_code"><a href="#MMscs">super carrier</a></code> only flag. This flag defaults to <code class="code">true</code>. When a super carrier is used and this flag is <code class="code">true</code>, <code class="code">mseg_alloc</code> will only create carriers in the super carrier. Note that the <code class="code">alloc_util</code> framework may create <code class="code">sys_alloc</code> carriers, so if you want all carriers to be created in the super carrier, you therefore want to disable use of <code class="code">sys_alloc</code> carriers by also passing <code class="bold_code"><a href="#Musac"><span class="code">+Musac false</span></a></code>. When the flag is <code class="code">false</code>, <code class="code">mseg_alloc</code> will try to create carriers outside of the super carrier when the super carrier is full. <br><br> <strong>NOTE</strong>: Setting this flag to <code class="code">false</code> may not be supported on all systems. This flag will in that case be ignored. <br><br> <strong>NOTE</strong>: The super carrier cannot be enabled nor disabled on halfword heap systems. This flag will be ignored on halfword heap systems. </dd> <dt><strong id="MMscrfsd"><code class="code">+MMscrfsd &lt;amount&gt;</code></strong></dt> <dd> Set <code class="bold_code"><a href="#MMscs">super carrier</a></code> reserved free segment descriptors. This parameter defaults to <code class="code">65536</code>. This parameter determines the amount of memory to reserve for free segment descriptors used by the super carrier. If the system runs out of reserved memory for free segment descriptors, other memory will be used. This may however cause fragmentation issues, so you want to ensure that this never happens. The maximum amount of free segment descriptors used can be retrieved from the <code class="code">erts_mmap</code> tuple part of the result from calling <code class="bold_code">erlang:system_info({allocator, mseg_alloc})</code>. </dd> <dt><strong id="MMscrpm"><code class="code">+MMscrpm true|false</code></strong></dt> <dd> Set <code class="bold_code"><a href="#MMscs">super carrier</a></code> reserve physical memory flag. This flag defaults to <code class="code">true</code>. When this flag is <code class="code">true</code>, physical memory will be reserved for the whole super carrier at once when it is created. The reservation will after that be left unchanged. When this flag is set to <code class="code">false</code> only virtual address space will be reserved for the super carrier upon creation. The system will attempt to reserve physical memory upon carrier creations in the super carrier, and attempt to unreserve physical memory upon carrier destructions in the super carrier. <br><br> <strong>NOTE</strong>: What reservation of physical memory actually means highly depends on the operating system, and how it is configured. For example, different memory overcommit settings on Linux drastically change the behaviour. Also note, setting this flag to <code class="code">false</code> may not be supported on all systems. This flag will in that case be ignored. <br><br> <strong>NOTE</strong>: The super carrier cannot be enabled nor disabled on halfword heap systems. This flag will be ignored on halfword heap systems. </dd> <dt><strong id="MMscs"><code class="code">+MMscs &lt;size in MB&gt;</code></strong></dt> <dd> Set super carrier size (in MB). The super carrier size defaults to zero; i.e, the super carrier is by default disabled. The super carrier is a large continuous area in the virtual address space. <code class="code">mseg_alloc</code> will always try to create new carriers in the super carrier if it exists. Note that the <code class="code">alloc_util</code> framework may create <code class="code">sys_alloc</code> carriers. For more information on this, see the documentation of the <code class="bold_code"><a href="#MMsco"><span class="code">+MMsco</span></a></code> flag. <br><br> <strong>NOTE</strong>: The super carrier cannot be enabled nor disabled on halfword heap systems. This flag will be ignored on halfword heap systems. </dd> <dt><strong id="MMmcs"><code class="code">+MMmcs &lt;amount&gt;</code></strong></dt> <dd> Max cached segments. The maximum number of memory segments stored in the memory segment cache. Valid range is 0-30. Default value is 10.</dd> </dl> <p>The following flags are available for configuration of <code class="code">sys_alloc</code>:</p> <dl> <dt><strong id="MYe"><code class="code">+MYe true</code></strong></dt> <dd> Enable <code class="code">sys_alloc</code>. Note: <code class="code">sys_alloc</code> cannot be disabled.</dd> <dt><strong id="MYm"><code class="code">+MYm libc</code></strong></dt> <dd> <code class="code">malloc</code> library to use. Currently only <code class="code">libc</code> is available. <code class="code">libc</code> enables the standard <code class="code">libc</code> malloc implementation. By default <code class="code">libc</code> is used.</dd> <dt><strong id="MYtt"><code class="code">+MYtt &lt;size&gt;</code></strong></dt> <dd> Trim threshold size (in kilobytes). This is the maximum amount of free memory at the top of the heap (allocated by <code class="code">sbrk</code>) that will be kept by <code class="code">malloc</code> (not released to the operating system). When the amount of free memory at the top of the heap exceeds the trim threshold, <code class="code">malloc</code> will release it (by calling <code class="code">sbrk</code>). Trim threshold is given in kilobytes. Default trim threshold is 128. <strong>Note:</strong> This flag will only have any effect when the emulator has been linked with the GNU C library, and uses its <code class="code">malloc</code> implementation.</dd> <dt><strong id="MYtp"><code class="code">+MYtp &lt;size&gt;</code></strong></dt> <dd> Top pad size (in kilobytes). This is the amount of extra memory that will be allocated by <code class="code">malloc</code> when <code class="code">sbrk</code> is called to get more memory from the operating system. Default top pad size is 0. <strong>Note:</strong> This flag will only have any effect when the emulator has been linked with the GNU C library, and uses its <code class="code">malloc</code> implementation.</dd> </dl> <p>The following flags are available for configuration of allocators based on <code class="code">alloc_util</code>. If <code class="code">u</code> is used as subsystem identifier (i.e., <code class="code">&lt;S&gt; = u</code>) all allocators based on <code class="code">alloc_util</code> will be effected. If <code class="code">B</code>, <code class="code">D</code>, <code class="code">E</code>, <code class="code">F</code>, <code class="code">H</code>, <code class="code">L</code>, <code class="code">R</code>, <code class="code">S</code>, or <code class="code">T</code> is used as subsystem identifier, only the specific allocator identified will be effected:</p> <dl> <dt><strong id="M_acul"><code class="code">+M&lt;S&gt;acul &lt;utilization&gt;|de</code></strong></dt> <dd> Abandon carrier utilization limit. A valid <code class="code">&lt;utilization&gt;</code> is an integer in the range <code class="code">[0, 100]</code> representing utilization in percent. When a utilization value larger than zero is used, allocator instances are allowed to abandon multiblock carriers. If <code class="code">de</code> (default enabled) is passed instead of a <code class="code">&lt;utilization&gt;</code>, a recomended non zero utilization value will be used. The actual value chosen depend on allocator type and may be changed between ERTS versions. Currently the default equals <code class="code">de</code>, but this may be changed in the future. Carriers will be abandoned when memory utilization in the allocator instance falls below the utilization value used. Once a carrier has been abandoned, no new allocations will be made in it. When an allocator instance gets an increased multiblock carrier need, it will first try to fetch an abandoned carrier from an allocator instances of the same allocator type. If no abandoned carrier could be fetched, it will create a new empty carrier. When an abandoned carrier has been fetched it will function as an ordinary carrier. This feature has special requirements on the <code class="bold_code"><a href="#M_as">allocation strategy</a></code> used. Currently only the strategies <code class="code">aoff</code>, <code class="code">aoffcbf</code> and <code class="code">aoffcaobf</code> support abandoned carriers. This feature also requires <code class="bold_code"><a href="#M_t">multiple thread specific instances</a></code> to be enabled. When enabling this feature, multiple thread specific instances will be enabled if not already enabled, and the <code class="code">aoffcbf</code> strategy will be enabled if current strategy does not support abandoned carriers. This feature can be enabled on all allocators based on the <code class="code">alloc_util</code> framework with the exception of <code class="code">temp_alloc</code> (which would be pointless). </dd> <dt><strong id="M_as"><code class="code">+M&lt;S&gt;as bf|aobf|aoff|aoffcbf|aoffcaobf|gf|af</code></strong></dt> <dd> Allocation strategy. Valid strategies are <code class="code">bf</code> (best fit), <code class="code">aobf</code> (address order best fit), <code class="code">aoff</code> (address order first fit), <code class="code">aoffcbf</code> (address order first fit carrier best fit), <code class="code">aoffcaobf</code> (address order first fit carrier address order best fit), <code class="code">gf</code> (good fit), and <code class="code">af</code> (a fit). See <code class="bold_code"><a href="#strategy">the description of allocation strategies</a></code> in "the <code class="code">alloc_util</code> framework" section.</dd> <dt><strong id="M_asbcst"><code class="code">+M&lt;S&gt;asbcst &lt;size&gt;</code></strong></dt> <dd> Absolute singleblock carrier shrink threshold (in kilobytes). When a block located in an <code class="code">mseg_alloc</code> singleblock carrier is shrunk, the carrier will be left unchanged if the amount of unused memory is less than this threshold; otherwise, the carrier will be shrunk. See also <code class="bold_code"><a href="#M_rsbcst">rsbcst</a></code>.</dd> <dt><strong id="M_e"><code class="code">+M&lt;S&gt;e true|false</code></strong></dt> <dd> Enable allocator <code class="code">&lt;S&gt;</code>.</dd> <dt><strong id="M_lmbcs"><code class="code">+M&lt;S&gt;lmbcs &lt;size&gt;</code></strong></dt> <dd> Largest (<code class="code">mseg_alloc</code>) multiblock carrier size (in kilobytes). See <code class="bold_code"><a href="#mseg_mbc_sizes">the description on how sizes for mseg_alloc multiblock carriers are decided</a></code> in "the <code class="code">alloc_util</code> framework" section. On 32-bit Unix style OS this limit can not be set higher than 128 megabyte.</dd> <dt><strong id="M_mbcgs"><code class="code">+M&lt;S&gt;mbcgs &lt;ratio&gt;</code></strong></dt> <dd> (<code class="code">mseg_alloc</code>) multiblock carrier growth stages. See <code class="bold_code"><a href="#mseg_mbc_sizes">the description on how sizes for mseg_alloc multiblock carriers are decided</a></code> in "the <code class="code">alloc_util</code> framework" section.</dd> <dt><strong id="M_mbsd"><code class="code">+M&lt;S&gt;mbsd &lt;depth&gt;</code></strong></dt> <dd> Max block search depth. This flag has effect only if the good fit strategy has been selected for allocator <code class="code">&lt;S&gt;</code>. When the good fit strategy is used, free blocks are placed in segregated free-lists. Each free list contains blocks of sizes in a specific range. The max block search depth sets a limit on the maximum number of blocks to inspect in a free list during a search for suitable block satisfying the request.</dd> <dt><strong id="M_mmbcs"><code class="code">+M&lt;S&gt;mmbcs &lt;size&gt;</code></strong></dt> <dd> Main multiblock carrier size. Sets the size of the main multiblock carrier for allocator <code class="code">&lt;S&gt;</code>. The main multiblock carrier is allocated via <code class="code">sys_alloc</code> and is never deallocated.</dd> <dt><strong id="M_mmmbc"><code class="code">+M&lt;S&gt;mmmbc &lt;amount&gt;</code></strong></dt> <dd> Max <code class="code">mseg_alloc</code> multiblock carriers. Maximum number of multiblock carriers allocated via <code class="code">mseg_alloc</code> by allocator <code class="code">&lt;S&gt;</code>. When this limit has been reached, new multiblock carriers will be allocated via <code class="code">sys_alloc</code>.</dd> <dt><strong id="M_mmsbc"><code class="code">+M&lt;S&gt;mmsbc &lt;amount&gt;</code></strong></dt> <dd> Max <code class="code">mseg_alloc</code> singleblock carriers. Maximum number of singleblock carriers allocated via <code class="code">mseg_alloc</code> by allocator <code class="code">&lt;S&gt;</code>. When this limit has been reached, new singleblock carriers will be allocated via <code class="code">sys_alloc</code>.</dd> <dt><strong id="M_ramv"><code class="code">+M&lt;S&gt;ramv &lt;bool&gt;</code></strong></dt> <dd> Realloc always moves. When enabled, reallocate operations will more or less be translated into an allocate, copy, free sequence. This often reduce memory fragmentation, but costs performance. </dd> <dt><strong id="M_rmbcmt"><code class="code">+M&lt;S&gt;rmbcmt &lt;ratio&gt;</code></strong></dt> <dd> Relative multiblock carrier move threshold (in percent). When a block located in a multiblock carrier is shrunk, the block will be moved if the ratio of the size of the returned memory compared to the previous size is more than this threshold; otherwise, the block will be shrunk at current location.</dd> <dt><strong id="M_rsbcmt"><code class="code">+M&lt;S&gt;rsbcmt &lt;ratio&gt;</code></strong></dt> <dd> Relative singleblock carrier move threshold (in percent). When a block located in a singleblock carrier is shrunk to a size smaller than the value of the <code class="bold_code"><a href="#M_sbct">sbct</a></code> parameter, the block will be left unchanged in the singleblock carrier if the ratio of unused memory is less than this threshold; otherwise, it will be moved into a multiblock carrier. </dd> <dt><strong id="M_rsbcst"><code class="code">+M&lt;S&gt;rsbcst &lt;ratio&gt;</code></strong></dt> <dd> Relative singleblock carrier shrink threshold (in percent). When a block located in an <code class="code">mseg_alloc</code> singleblock carrier is shrunk, the carrier will be left unchanged if the ratio of unused memory is less than this threshold; otherwise, the carrier will be shrunk. See also <code class="bold_code"><a href="#M_asbcst">asbcst</a></code>.</dd> <dt><strong id="M_sbct"><code class="code">+M&lt;S&gt;sbct &lt;size&gt;</code></strong></dt> <dd> Singleblock carrier threshold. Blocks larger than this threshold will be placed in singleblock carriers. Blocks smaller than this threshold will be placed in multiblock carriers. On 32-bit Unix style OS this threshold can not be set higher than 8 megabytes.</dd> <dt><strong id="M_smbcs"><code class="code">+M&lt;S&gt;smbcs &lt;size&gt;</code></strong></dt> <dd> Smallest (<code class="code">mseg_alloc</code>) multiblock carrier size (in kilobytes). See <code class="bold_code"><a href="#mseg_mbc_sizes">the description on how sizes for mseg_alloc multiblock carriers are decided</a></code> in "the <code class="code">alloc_util</code> framework" section.</dd> <dt><strong id="M_t"><code class="code">+M&lt;S&gt;t true|false</code></strong></dt> <dd> <p>Multiple, thread specific instances of the allocator. This option will only have any effect on the runtime system with SMP support. Default behaviour on the runtime system with SMP support is <code class="code">NoSchedulers+1</code> instances. Each scheduler will use a lock-free instance of its own and other threads will use a common instance.</p> <p>It was previously (before ERTS version 5.9) possible to configure a smaller amount of thread specific instances than schedulers. This is, however, not possible any more.</p> </dd> </dl> <p>Currently the following flags are available for configuration of <code class="code">alloc_util</code>, i.e. all allocators based on <code class="code">alloc_util</code> will be effected:</p> <dl> <dt><strong id="Muycs"><code class="code">+Muycs &lt;size&gt;</code></strong></dt> <dd> <code class="code">sys_alloc</code> carrier size. Carriers allocated via <code class="code">sys_alloc</code> will be allocated in sizes which are multiples of the <code class="code">sys_alloc</code> carrier size. This is not true for main multiblock carriers and carriers allocated during a memory shortage, though.</dd> <dt><strong id="Mummc"><code class="code">+Mummc &lt;amount&gt;</code></strong></dt> <dd> Max <code class="code">mseg_alloc</code> carriers. Maximum number of carriers placed in separate memory segments. When this limit has been reached, new carriers will be placed in memory retrieved from <code class="code">sys_alloc</code>.</dd> <dt><strong id="Musac"><code class="code">+Musac &lt;bool&gt;</code></strong></dt> <dd> Allow <code class="code">sys_alloc</code> carriers. By default <code class="code">true</code>. If set to <code class="code">false</code>, <code class="code">sys_alloc</code> carriers will never be created by allocators using the <code class="code">alloc_util</code> framework.</dd> </dl> <p>Instrumentation flags:</p> <dl> <dt><strong id="Mim"><code class="code">+Mim true|false</code></strong></dt> <dd> A map over current allocations is kept by the emulator. The allocation map can be retrieved via the <code class="code">instrument</code> module. <code class="code">+Mim true</code> implies <code class="code">+Mis true</code>. <code class="code">+Mim true</code> is the same as <code class="bold_code"><a href="../erl/#instr">-instr</a></code>.</dd> <dt><strong id="Mis"><code class="code">+Mis true|false</code></strong></dt> <dd> Status over allocated memory is kept by the emulator. The allocation status can be retrieved via the <code class="code">instrument</code> module.</dd> <dt><strong id="Mit"><code class="code">+Mit X</code></strong></dt> <dd> Reserved for future use. Do <strong>not</strong> use this flag.</dd> </dl> <div class="note"> <div class="label">Note</div> <div class="content">

<p>When instrumentation of the emulator is enabled, the emulator uses more memory and runs slower.</p> </div> </div> <p>Other flags:</p> <dl> <dt><strong id="Mea"><code class="code">+Mea min|max|r9c|r10b|r11b|config</code></strong></dt> <dd> <dl> <dt><strong><code class="code">min</code></strong></dt> <dd> Disables all allocators that can be disabled. </dd> <dt><strong><code class="code">max</code></strong></dt> <dd> Enables all allocators (currently default). </dd> <dt><strong><code class="code">r9c|r10b|r11b</code></strong></dt> <dd> Configures all allocators as they were configured in respective OTP release. These will eventually be removed. </dd> <dt><strong><code class="code">config</code></strong></dt> <dd> Disables features that cannot be enabled while creating an allocator configuration with <code class="bold_code">erts_alloc_config(3)</code>. Note, this option should only be used while running <code class="code">erts_alloc_config</code>, <strong>not</strong> when using the created configuration. </dd> </dl> </dd> <dt><strong id="Mlpm"><code class="code">+Mlpm all|no</code></strong></dt> <dd>Lock physical memory. The default value is <code class="code">no</code>, i.e., no physical memory will be locked. If set to <code class="code">all</code>, all memory mappings made by the runtime system, will be locked into physical memory. If set to <code class="code">all</code>, the runtime system will fail to start if this feature is not supported, the user has not got enough privileges, or the user is not allowed to lock enough physical memory. The runtime system will also fail with an out of memory condition if the user limit on the amount of locked memory is reached. </dd> </dl> <p>Only some default values have been presented here. <code class="bold_code">erlang:system_info(allocator)</code>, and <code class="bold_code">erlang:system_info({allocator, Alloc})</code> can be used in order to obtain currently used settings and current status of the allocators.</p> <div class="note"> <div class="label">Note</div> <div class="content">

<p>Most of these flags are highly implementation dependent, and they may be changed or removed without prior notice.</p> <p><code class="code">erts_alloc</code> is not obliged to strictly use the settings that have been passed to it (it may even ignore them).</p> </div> </div> <p><code class="bold_code">erts_alloc_config(3)</code> is a tool that can be used to aid creation of an <code class="code">erts_alloc</code> configuration that is suitable for a limited number of runtime scenarios.</p>  <h2 id="id197355">See also</h2>  <p><code class="bold_code">erts_alloc_config(3)</code>, <code class="bold_code"><a href="../erl/">erl(1)</a></code>, <code class="bold_code">instrument(3)</code>, <code class="bold_code">erlang(3)</code></p>
<div class="_attribution">
  <p class="_attribution-p">
    © 1999–2016 Ericsson AB<br>Licensed under the Apache License, Version 2.0.<br>
    
  </p>
</div>

			</div>
		</div>
	</section>

	</div>
</body>
</html>
