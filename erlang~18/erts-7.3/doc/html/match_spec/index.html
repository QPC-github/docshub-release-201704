
<!DOCTYPE HTML>

<html lang="en">

<head>
  <meta charset="utf-8">
  <title>3 Match Specifications in Erlang - Erlang 18 - W3cubDocs</title>
  
  <meta name="description" content="A &#34;match specification&#34; (match_spec) is an Erlang term describing a small &#34;program&#34; that will try to match something (either the &hellip;">
  <meta name="keywords" content="match, specifications, erlang, -, erlang~18">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="http://docs.w3cub.com/erlang~18/erts-7.3/doc/html/match_spec/">
  <link href="/favicon.png" rel="icon">
  <link type="text/css" rel="stylesheet" href="/assets/application-50364fff564ce3b6327021805f3f00e2957b441cf27f576a7dd4ff63bbc47047.css">
  <script type="text/javascript" src="/assets/application-db64bfd54ceb42be11af7995804cf4902548419ceb79d509b0b7d62c22d98e6f.js"></script>
  <script src="/json/erlang~18.js"></script>
  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-71174418-1']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>


</head>

<body>
	<div class="_app">
	<header class="_header">
  
  <form class="_search">
    <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
    <a class="_search-clear"></a>
    <div class="_search-tag"></div>
  </form>
  
  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/erlang~18/" class="_nav-link" title="" style="margin-left:0;">Erlang 18</a></span>
  
  <nav class="_nav">
    <a href="/app/" class="_nav-link ">App</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		<div class="_list">
			
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<div class="_page _erlang">
				
<h1>3 Match specifications in Erlang</h1> <p>A "match specification" (match_spec) is an Erlang term describing a small "program" that will try to match something (either the parameters to a function as used in the <code class="code">erlang:trace_pattern/2</code> BIF, or the objects in an ETS table.). The match_spec in many ways works like a small function in Erlang, but is interpreted/compiled by the Erlang runtime system to something much more efficient than calling an Erlang function. The match_spec is also very limited compared to the expressiveness of real Erlang functions.</p> <p>Match specifications are given to the BIF <code class="code">erlang:trace_pattern/2</code> to execute matching of function arguments as well as to define some actions to be taken when the match succeeds (the <code class="code">MatchBody</code> part). Match specifications can also be used in ETS, to specify objects to be returned from an <code class="code">ets:select/2</code> call (or other select calls). The semantics and restrictions differ slightly when using match specifications for tracing and in ETS, the differences are defined in a separate paragraph below.</p> <p>The most notable difference between a match_spec and an Erlang fun is of course the syntax. Match specifications are Erlang terms, not Erlang code. A match_spec also has a somewhat strange concept of exceptions. An exception (e.g., <code class="code">badarg</code>) in the <code class="code">MatchCondition</code> part, which resembles an Erlang guard, will generate immediate failure, while an exception in the <code class="code">MatchBody</code> part, which resembles the body of an Erlang function, is implicitly caught and results in the single atom <code class="code">'EXIT'</code>. </p> <h2 id="id73964">3.1 Grammar</h2> <p>A match_spec used in tracing can be described in this <strong>informal</strong> grammar:</p> <ul> <li>MatchExpression ::= [ MatchFunction, ... ] </li> <li>MatchFunction ::= { MatchHead, MatchConditions, MatchBody } </li> <li>MatchHead ::= MatchVariable | <code class="code">'_'</code> | [ MatchHeadPart, ... ] </li> <li>MatchHeadPart ::= term() | MatchVariable | <code class="code">'_'</code> </li> <li>MatchVariable ::= '$&lt;number&gt;' </li> <li>MatchConditions ::= [ MatchCondition, ...] | <code class="code">[]</code> </li> <li>MatchCondition ::= { GuardFunction } | { GuardFunction, ConditionExpression, ... } </li> <li>BoolFunction ::= <code class="code">is_atom</code> | <code class="code">is_float</code> | <code class="code">is_integer</code> | <code class="code">is_list</code> | <code class="code">is_number</code> | <code class="code">is_pid</code> | <code class="code">is_port</code> | <code class="code">is_reference</code> | <code class="code">is_tuple</code> | <code class="code">is_map</code> | <code class="code">is_binary</code> | <code class="code">is_function</code> | <code class="code">is_record</code> | <code class="code">is_seq_trace</code> | <code class="code">'and'</code> | <code class="code">'or'</code> | <code class="code">'not'</code> | <code class="code">'xor'</code> | <code class="code">andalso</code> | <code class="code">orelse</code> </li> <li>ConditionExpression ::= ExprMatchVariable | { GuardFunction } | { GuardFunction, ConditionExpression, ... } | TermConstruct </li> <li>ExprMatchVariable ::= MatchVariable (bound in the MatchHead) | <code class="code">'$_'</code> | <code class="code">'$$'</code> </li> <li>TermConstruct = {{}} | {{ ConditionExpression, ... }} | <code class="code">[]</code> | [ConditionExpression, ...] | <code class="code">#{}</code> | #{term() =&gt; ConditionExpression, ...} | NonCompositeTerm | Constant</li> <li>NonCompositeTerm ::= term() (not list or tuple or map)</li> <li>Constant ::= {<code class="code">const</code>, term()} </li> <li>GuardFunction ::= BoolFunction | <code class="code">abs</code> | <code class="code">element</code> | <code class="code">hd</code> | <code class="code">length</code> | <code class="code">node</code> | <code class="code">round</code> | <code class="code">size</code> | <code class="code">tl</code> | <code class="code">trunc</code> | <code class="code">'+'</code> | <code class="code">'-'</code> | <code class="code">'*'</code> | <code class="code">'div'</code> | <code class="code">'rem'</code> | <code class="code">'band'</code> | <code class="code">'bor'</code> | <code class="code">'bxor'</code> | <code class="code">'bnot'</code> | <code class="code">'bsl'</code> | <code class="code">'bsr'</code> | <code class="code">'&gt;'</code> | <code class="code">'&gt;='</code> | <code class="code">'&lt;'</code> | <code class="code">'=&lt;'</code> | <code class="code">'=:='</code> | <code class="code">'=='</code> | <code class="code">'=/='</code> | <code class="code">'/='</code> | <code class="code">self</code> | <code class="code">get_tcw</code> </li> <li>MatchBody ::= [ ActionTerm ] </li> <li>ActionTerm ::= ConditionExpression | ActionCall </li> <li>ActionCall ::= {ActionFunction} | {ActionFunction, ActionTerm, ...} </li> <li>ActionFunction ::= <code class="code">set_seq_token</code> | <code class="code">get_seq_token</code> | <code class="code">message</code> | <code class="code">return_trace</code> | <code class="code">exception_trace</code> | <code class="code">process_dump</code> | <code class="code">enable_trace</code> | <code class="code">disable_trace</code> | <code class="code">trace</code> | <code class="code">display</code> | <code class="code">caller</code> | <code class="code">set_tcw</code> | <code class="code">silent</code> </li> </ul> <p>A match_spec used in ets can be described in this <strong>informal</strong> grammar:</p> <ul> <li>MatchExpression ::= [ MatchFunction, ... ] </li> <li>MatchFunction ::= { MatchHead, MatchConditions, MatchBody } </li> <li>MatchHead ::= MatchVariable | <code class="code">'_'</code> | { MatchHeadPart, ... } </li> <li>MatchHeadPart ::= term() | MatchVariable | <code class="code">'_'</code> </li> <li>MatchVariable ::= '$&lt;number&gt;' </li> <li>MatchConditions ::= [ MatchCondition, ...] | <code class="code">[]</code> </li> <li>MatchCondition ::= { GuardFunction } | { GuardFunction, ConditionExpression, ... } </li> <li>BoolFunction ::= <code class="code">is_atom</code> | <code class="code">is_float</code> | <code class="code">is_integer</code> | <code class="code">is_list</code> | <code class="code">is_number</code> | <code class="code">is_pid</code> | <code class="code">is_port</code> | <code class="code">is_reference</code> | <code class="code">is_tuple</code> | <code class="code">is_map</code> | <code class="code">is_binary</code> | <code class="code">is_function</code> | <code class="code">is_record</code> | <code class="code">is_seq_trace</code> | <code class="code">'and'</code> | <code class="code">'or'</code> | <code class="code">'not'</code> | <code class="code">'xor'</code> | <code class="code">andalso</code> | <code class="code">orelse</code> </li> <li>ConditionExpression ::= ExprMatchVariable | { GuardFunction } | { GuardFunction, ConditionExpression, ... } | TermConstruct </li> <li>ExprMatchVariable ::= MatchVariable (bound in the MatchHead) | <code class="code">'$_'</code> | <code class="code">'$$'</code> </li> <li>TermConstruct = {{}} | {{ ConditionExpression, ... }} | <code class="code">[]</code> | [ConditionExpression, ...] | #{} | #{term() =&gt; ConditionExpression, ...} | NonCompositeTerm | Constant</li> <li>NonCompositeTerm ::= term() (not list or tuple or map)</li> <li>Constant ::= {<code class="code">const</code>, term()} </li> <li>GuardFunction ::= BoolFunction | <code class="code">abs</code> | <code class="code">element</code> | <code class="code">hd</code> | <code class="code">length</code> | <code class="code">node</code> | <code class="code">round</code> | <code class="code">size</code> | <code class="code">tl</code> | <code class="code">trunc</code> | <code class="code">'+'</code> | <code class="code">'-'</code> | <code class="code">'*'</code> | <code class="code">'div'</code> | <code class="code">'rem'</code> | <code class="code">'band'</code> | <code class="code">'bor'</code> | <code class="code">'bxor'</code> | <code class="code">'bnot'</code> | <code class="code">'bsl'</code> | <code class="code">'bsr'</code> | <code class="code">'&gt;'</code> | <code class="code">'&gt;='</code> | <code class="code">'&lt;'</code> | <code class="code">'=&lt;'</code> | <code class="code">'=:='</code> | <code class="code">'=='</code> | <code class="code">'=/='</code> | <code class="code">'/='</code> | <code class="code">self</code> | <code class="code">get_tcw</code> </li> <li>MatchBody ::= [ ConditionExpression, ... ]</li> </ul> <h2 id="id77521">3.2 Function descriptions</h2> <h4>Functions allowed in all types of match specifications</h4> <p>The different functions allowed in <code class="code">match_spec</code> work like this: </p> <p><strong>is_atom, is_float, is_integer, is_list, is_number, is_pid, is_port, is_reference, is_tuple, is_map, is_binary, is_function:</strong> Like the corresponding guard tests in Erlang, return <code class="code">true</code> or <code class="code">false</code>.</p> <p><strong>is_record: </strong>Takes an additional parameter, which SHALL be the result of <code class="code">record_info(size, &lt;record_type&gt;)</code>, like in <code class="code">{is_record, '$1', rectype, record_info(size, rectype)}</code>. </p> <p><strong>'not': </strong>Negates its single argument (anything other than <code class="code">false</code> gives <code class="code">false</code>). </p> <p><strong>'and': </strong>Returns <code class="code">true</code> if all its arguments (variable length argument list) evaluate to <code class="code">true</code>, else <code class="code">false</code>. Evaluation order is undefined. </p> <p><strong>'or': </strong>Returns <code class="code">true</code> if any of its arguments evaluates to <code class="code">true</code>. Variable length argument list. Evaluation order is undefined. </p> <p><strong>andalso: </strong>Like <code class="code">'and'</code>, but quits evaluating its arguments as soon as one argument evaluates to something else than true. Arguments are evaluated left to right. </p> <p><strong>orelse: </strong>Like <code class="code">'or'</code>, but quits evaluating as soon as one of its arguments evaluates to <code class="code">true</code>. Arguments are evaluated left to right. </p> <p><strong>'xor': </strong>Only two arguments, of which one has to be true and the other false to return <code class="code">true</code>; otherwise <code class="code">'xor'</code> returns false. </p> <p><strong>abs, element, hd, length, node, round, size, tl, trunc, '+', '-', '*', 'div', 'rem', 'band', 'bor', 'bxor', 'bnot', 'bsl', 'bsr', '&gt;', '&gt;=', '&lt;', '=&lt;', '=:=', '==', '=/=', '/=', self: </strong>Work as the corresponding Erlang bif's (or operators). In case of bad arguments, the result depends on the context. In the <code class="code">MatchConditions</code> part of the expression, the test fails immediately (like in an Erlang guard), but in the <code class="code">MatchBody</code>, exceptions are implicitly caught and the call results in the atom <code class="code">'EXIT'</code>.</p> <h4>Functions allowed only for tracing</h4> <p><strong>is_seq_trace: </strong>Returns <code class="code">true</code> if a sequential trace token is set for the current process, otherwise <code class="code">false</code>. </p> <p><strong>set_seq_token:</strong> Works like <code class="code">seq_trace:set_token/2</code>, but returns <code class="code">true</code> on success and <code class="code">'EXIT'</code> on error or bad argument. Only allowed in the <code class="code">MatchBody</code> part and only allowed when tracing. </p> <p><strong>get_seq_token:</strong> Works just like <code class="code">seq_trace:get_token/0</code>, and is only allowed in the <code class="code">MatchBody</code> part when tracing. </p> <p><strong>message:</strong> Sets an additional message appended to the trace message sent. One can only set one additional message in the body; subsequent calls will replace the appended message. As a special case, <code class="code">{message, false}</code> disables sending of trace messages ('call' and 'return_to') for this function call, just like if the match_spec had not matched, which can be useful if only the side effects of the <code class="code">MatchBody</code> are desired. Another special case is <code class="code">{message, true}</code> which sets the default behavior, as if the function had no match_spec, trace message is sent with no extra information (if no other calls to <code class="code">message</code> are placed before <code class="code">{message, true}</code>, it is in fact a "noop"). </p> <p>Takes one argument, the message. Returns <code class="code">true</code> and can only be used in the <code class="code">MatchBody</code> part and when tracing. </p> <p><strong>return_trace:</strong> Causes a <code class="code">return_from</code> trace message to be sent upon return from the current function. Takes no arguments, returns <code class="code">true</code> and can only be used in the <code class="code">MatchBody</code> part when tracing. If the process trace flag <code class="code">silent</code> is active the <code class="code">return_from</code> trace message is inhibited. </p> <p>NOTE! If the traced function is tail recursive, this match spec function destroys that property. Hence, if a match spec executing this function is used on a perpetual server process, it may only be active for a limited time, or the emulator will eventually use all memory in the host machine and crash. If this match_spec function is inhibited using the <code class="code">silent</code> process trace flag tail recursiveness still remains. </p> <p><strong>exception_trace:</strong> Same as <strong>return_trace</strong>, plus; if the traced function exits due to an exception, an <code class="code">exception_from</code> trace message is generated, whether the exception is caught or not. </p> <p><strong>process_dump:</strong> Returns some textual information about the current process as a binary. Takes no arguments and is only allowed in the <code class="code">MatchBody</code> part when tracing. </p> <p><strong>enable_trace:</strong> With one parameter this function turns on tracing like the Erlang call <code class="code">erlang:trace(self(), true, [P2])</code>, where <code class="code">P2</code> is the parameter to <code class="code">enable_trace</code>. With two parameters, the first parameter should be either a process identifier or the registered name of a process. In this case tracing is turned on for the designated process in the same way as in the Erlang call <code class="code">erlang:trace(P1, true, [P2])</code>, where P1 is the first and P2 is the second argument. The process <code class="code">P1</code> gets its trace messages sent to the same tracer as the process executing the statement uses. <code class="code">P1</code> can <strong>not</strong> be one of the atoms <code class="code">all</code>, <code class="code">new</code> or <code class="code">existing</code> (unless, of course, they are registered names). <code class="code">P2</code> can <strong>not</strong> be <code class="code">cpu_timestamp</code> nor <code class="code">{tracer,_}</code>. Returns <code class="code">true</code> and may only be used in the <code class="code">MatchBody</code> part when tracing. </p> <p><strong>disable_trace:</strong> With one parameter this function disables tracing like the Erlang call <code class="code">erlang:trace(self(), false, [P2])</code>, where <code class="code">P2</code> is the parameter to <code class="code">disable_trace</code>. With two parameters it works like the Erlang call <code class="code">erlang:trace(P1, false, [P2])</code>, where P1 can be either a process identifier or a registered name and is given as the first argument to the match_spec function. <code class="code">P2</code> can <strong>not</strong> be <code class="code">cpu_timestamp</code> nor <code class="code">{tracer,_}</code>. Returns <code class="code">true</code> and may only be used in the <code class="code">MatchBody</code> part when tracing. </p> <p><strong>trace:</strong> With two parameters this function takes a list of trace flags to disable as first parameter and a list of trace flags to enable as second parameter. Logically, the disable list is applied first, but effectively all changes are applied atomically. The trace flags are the same as for <code class="code">erlang:trace/3</code> not including <code class="code">cpu_timestamp</code> but including <code class="code">{tracer,_}</code>. If a tracer is specified in both lists, the tracer in the enable list takes precedence. If no tracer is specified the same tracer as the process executing the match spec is used. With three parameters to this function the first is either a process identifier or the registered name of a process to set trace flags on, the second is the disable list, and the third is the enable list. Returns <code class="code">true</code> if any trace property was changed for the trace target process or <code class="code">false</code> if not. It may only be used in the <code class="code">MatchBody</code> part when tracing. </p> <p><strong>caller:</strong> Returns the calling function as a tuple {Module, Function, Arity} or the atom <code class="code">undefined</code> if the calling function cannot be determined. May only be used in the <code class="code">MatchBody</code> part when tracing. </p> <p>Note that if a "technically built in function" (i.e. a function not written in Erlang) is traced, the <code class="code">caller</code> function will sometimes return the atom <code class="code">undefined</code>. The calling Erlang function is not available during such calls. </p> <p><strong>display:</strong> For debugging purposes only; displays the single argument as an Erlang term on stdout, which is seldom what is wanted. Returns <code class="code">true</code> and may only be used in the <code class="code">MatchBody</code> part when tracing. </p> <p id="get_tcw">  <strong>get_tcw:</strong> Takes no argument and returns the value of the node's trace control word. The same is done by <code class="code">erlang:system_info(trace_control_word)</code>. </p> <p>The trace control word is a 32-bit unsigned integer intended for generic trace control. The trace control word can be tested and set both from within trace match specifications and with BIFs. This call is only allowed when tracing. </p> <p id="set_tcw">  <strong>set_tcw:</strong> Takes one unsigned integer argument, sets the value of the node's trace control word to the value of the argument and returns the previous value. The same is done by <code class="code">erlang:system_flag(trace_control_word, Value)</code>. It is only allowed to use <code class="code">set_tcw</code> in the <code class="code">MatchBody</code> part when tracing. </p> <p><strong>silent:</strong> Takes one argument. If the argument is <code class="code">true</code>, the call trace message mode for the current process is set to silent for this call and all subsequent, i.e call trace messages are inhibited even if <code class="code">{message, true}</code> is called in the <code class="code">MatchBody</code> part for a traced function. </p> <p>This mode can also be activated with the <code class="code">silent</code> flag to <code class="code">erlang:trace/3</code>. </p> <p>If the argument is <code class="code">false</code>, the call trace message mode for the current process is set to normal (non-silent) for this call and all subsequent. </p> <p>If the argument is neither <code class="code">true</code> nor <code class="code">false</code>, the call trace message mode is unaffected.</p> <p><strong>Note</strong> that all "function calls" have to be tuples, even if they take no arguments. The value of <code class="code">self</code> is the atom() <code class="code">self</code>, but the value of <code class="code">{self}</code> is the pid() of the current process.</p> <h2 id="id82621">3.3 Variables and literals</h2> <p>Variables take the form <code class="code">'$&lt;number&gt;'</code> where <code class="code">&lt;number&gt;</code> is an integer between 0 (zero) and 100000000 (1e+8), the behavior if the number is outside these limits is <strong>undefined</strong>. In the <code class="code">MatchHead</code> part, the special variable <code class="code">'_'</code> matches anything, and never gets bound (like <code class="code">_</code> in Erlang). In the <code class="code">MatchCondition/MatchBody</code> parts, no unbound variables are allowed, why <code class="code">'_'</code> is interpreted as itself (an atom). Variables can only be bound in the <code class="code">MatchHead</code> part. In the <code class="code">MatchBody</code> and <code class="code">MatchCondition</code> parts, only variables bound previously may be used. As a special case, in the <code class="code">MatchCondition/MatchBody</code> parts, the variable <code class="code">'$_'</code> expands to the whole expression which matched the <code class="code">MatchHead</code> (i.e., the whole parameter list to the possibly traced function or the whole matching object in the ets table) and the variable <code class="code">'$$'</code> expands to a list of the values of all bound variables in order (i.e. <code class="code">['$1','$2', ...]</code>). </p> <p>In the <code class="code">MatchHead</code> part, all literals (except the variables noted above) are interpreted as is. In the <code class="code">MatchCondition/MatchBody</code> parts, however, the interpretation is in some ways different. Literals in the <code class="code">MatchCondition/MatchBody</code> can either be written as is, which works for all literals except tuples, or by using the special form <code class="code">{const, T}</code>, where <code class="code">T</code> is any Erlang term. For tuple literals in the match_spec, one can also use double tuple parentheses, i.e., construct them as a tuple of arity one containing a single tuple, which is the one to be constructed. The "double tuple parenthesis" syntax is useful to construct tuples from already bound variables, like in <code class="code">{{'$1', [a,b,'$2']}}</code>. Some examples may be needed: </p> <table> <tr> <td>Expression </td> <td>Variable bindings </td> <td>Result </td> </tr> <tr> <td>{{'$1','$2'}} </td> <td>'$1' = a, '$2' = b</td> <td>{a,b}</td> </tr> <tr> <td>{const, {'$1', '$2'}} </td> <td>doesn't matter</td> <td>{'$1', '$2'}</td> </tr> <tr> <td>a </td> <td>doesn't matter </td> <td>a</td> </tr> <tr> <td>'$1' </td> <td>'$1' = [] </td> <td>[]</td> </tr> <tr> <td>['$1'] </td> <td>'$1' = [] </td> <td>[[]]</td> </tr> <tr> <td>[{{a}}] </td> <td>doesn't matter</td> <td>[{a}]</td> </tr> <tr> <td>42 </td> <td>doesn't matter</td> <td>42</td> </tr> <tr> <td>"hello" </td> <td>doesn't matter</td> <td>"hello"</td> </tr> <tr> <td>$1 </td> <td>doesn't matter</td> <td>49 (the ASCII value for the character '1')</td> </tr> </table> <em>Table 3.1: Literals in the MatchCondition/MatchBody parts of a match_spec</em> <h2 id="id83024">3.4 Execution of the match</h2> <p>The execution of the match expression, when the runtime system decides whether a trace message should be sent, goes as follows: </p> <p>For each tuple in the <code class="code">MatchExpression</code> list and while no match has succeeded:</p> <ul> <li>Match the <code class="code">MatchHead</code> part against the arguments to the function, binding the <code class="code">'$&lt;number&gt;'</code> variables (much like in <code class="code">ets:match/2</code>). If the <code class="code">MatchHead</code> cannot match the arguments, the match fails. </li> <li>Evaluate each <code class="code">MatchCondition</code> (where only <code class="code">'$&lt;number&gt;'</code> variables previously bound in the <code class="code">MatchHead</code> can occur) and expect it to return the atom <code class="code">true</code>. As soon as a condition does not evaluate to <code class="code">true</code>, the match fails. If any BIF call generates an exception, also fail. </li> <li> <ul> <li> <strong>If the match_spec is executing when tracing:</strong><br> Evaluate each <code class="code">ActionTerm</code> in the same way as the <code class="code">MatchConditions</code>, but completely ignore the return values. Regardless of what happens in this part, the match has succeeded.</li> <li> <strong>If the match_spec is executed when selecting objects from an ETS table:</strong><br> Evaluate the expressions in order and return the value of the last expression (typically there is only one expression in this context)</li> </ul> </li> </ul> <h2 id="id83128">3.5 Differences between match specifications in ETS and tracing</h2> <p>ETS match specifications are there to produce a return value. Usually the <code class="code">MatchBody</code> contains one single <code class="code">ConditionExpression</code> which defines the return value without having any side effects. Calls with side effects are not allowed in the ETS context.</p> <p>When tracing there is no return value to produce, the match specification either matches or doesn't. The effect when the expression matches is a trace message rather then a returned term. The <code class="code">ActionTerm</code>'s are executed as in an imperative language, i.e. for their side effects. Functions with side effects are also allowed when tracing.</p> <p>In ETS the match head is a <code class="code">tuple()</code> (or a single match variable) while it is a list (or a single match variable) when tracing.</p> <h2 id="id83168">3.6 Examples</h2> <p>Match an argument list of three where the first and third arguments are equal:</p> <div class="example"><pre>
[{['$1', '_', '$1'],
  [],
  []}]
    </pre></div> <p>Match an argument list of three where the second argument is a number greater than three:</p> <div class="example"><pre>
[{['_', '$1', '_'],
  [{ '&gt;', '$1', 3}],
  []}]
    </pre></div> <p>Match an argument list of three, where the third argument is a tuple containing argument one and two <strong>or</strong> a list beginning with argument one and two (i. e. <code class="code">[a,b,[a,b,c]]</code> or <code class="code">[a,b,{a,b}]</code>): </p> <div class="example"><pre>
[{['$1', '$2', '$3'],
  [{orelse, 
      {'=:=', '$3', {{'$1','$2'}}},
      {'and', 
        {'=:=', '$1', {hd, '$3'}},
        {'=:=', '$2', {hd, {tl, '$3'}}}}}],
  []}]
    </pre></div> <p>The above problem may also be solved like this:</p> <div class="example"><pre>
[{['$1', '$2', {'$1', '$2}], [], []},
 {['$1', '$2', ['$1', '$2' | '_']], [], []}]
    </pre></div> <p>Match two arguments where the first is a tuple beginning with a list which in turn begins with the second argument times two (i. e. [{[4,x],y},2] or [{[8], y, z},4])</p> <div class="example"><pre>
[{['$1', '$2'],[{'=:=', {'*', 2, '$2'}, {hd, {element, 1, '$1'}}}],
  []}]
    </pre></div> <p>Match three arguments. When all three are equal and are numbers, append the process dump to the trace message, else let the trace message be as is, but set the sequential trace token label to 4711.</p> <div class="example"><pre>
[{['$1', '$1', '$1'],
  [{is_number, '$1'}],
  [{message, {process_dump}}]},
 {'_', [], [{set_seq_token, label, 4711}]}]
    </pre></div> <p>As can be noted above, the parameter list can be matched against a single <code class="code">MatchVariable</code> or an <code class="code">'_'</code>. To replace the whole parameter list with a single variable is a special case. In all other cases the <code class="code">MatchHead</code> has to be a <strong>proper</strong> list. </p> <p>Match all objects in an ets table where the first element is the atom 'strider' and the tuple arity is 3 and return the whole object.</p> <div class="example"><pre>
[{{strider,'_','_'},
  [],
  ['$_']}]
    </pre></div> <p>Match all objects in an ets table with arity &gt; 1 and the first element is 'gandalf', return element 2.</p> <div class="example"><pre>
[{'$1',
  [{'==', gandalf, {element, 1, '$1'}},{'&gt;=',{size, '$1'},2}],
  [{element,2,'$1'}]}]
    </pre></div> <p>In the above example, if the first element had been the key, it's much more efficient to match that key in the <code class="code">MatchHead</code> part than in the <code class="code">MatchConditions</code> part. The search space of the tables is restricted with regards to the <code class="code">MatchHead</code> so that only objects with the matching key are searched. </p> <p>Match tuples of 3 elements where the second element is either 'merry' or 'pippin', return the whole objects.</p> <div class="example"><pre>
[{{'_',merry,'_'},
  [],
  ['$_']},
 {{'_',pippin,'_'},
  [],
  ['$_']}]
    </pre></div> <p>The function <code class="code">ets:test_ms/2</code> can be useful for testing complicated ets matches.</p>
<div class="_attribution">
  <p class="_attribution-p">
    © 1999–2016 Ericsson AB<br>Licensed under the Apache License, Version 2.0.<br>
    
  </p>
</div>

			</div>
		</div>
	</section>

	</div>
</body>
</html>
