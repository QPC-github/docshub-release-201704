
<!DOCTYPE HTML>

<html lang="en">

<head>
  <meta charset="utf-8">
  <title>10 External Term Format - Erlang 18 - W3cubDocs</title>
  
  <meta name="description" content=" The external term format is mainly used in the distribution mechanism of Erlang. ">
  <meta name="keywords" content="external, term, format, -, erlang, erlang~18">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="http://docs.w3cub.com/erlang~18/erts-7.3/doc/html/erl_ext_dist/">
  <link href="/favicon.png" rel="icon">
  <link type="text/css" rel="stylesheet" href="/assets/application-50364fff564ce3b6327021805f3f00e2957b441cf27f576a7dd4ff63bbc47047.css">
  <script type="text/javascript" src="/assets/application-db64bfd54ceb42be11af7995804cf4902548419ceb79d509b0b7d62c22d98e6f.js"></script>
  <script src="/json/erlang~18.js"></script>
  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-71174418-1']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>


</head>

<body>
	<div class="_app">
	<header class="_header">
  
  <form class="_search">
    <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
    <a class="_search-clear"></a>
    <div class="_search-tag"></div>
  </form>
  
  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/erlang~18/" class="_nav-link" title="" style="margin-left:0;">Erlang 18</a></span>
  
  <nav class="_nav">
    <a href="/app/" class="_nav-link ">App</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		<div class="_list">
			
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<div class="_page _erlang">
				
<h1>10 External Term Format</h1> <h2 id="id92118">10.1 Introduction</h2> <p> The external term format is mainly used in the distribution mechanism of Erlang. </p> <p> Since Erlang has a fixed number of types, there is no need for a programmer to define a specification for the external format used within some application. All Erlang terms has an external representation and the interpretation of the different terms are application specific. </p> <p> In Erlang the BIF <code class="bold_code">term_to_binary/1,2</code> is used to convert a term into the external format. To convert binary data encoding a term the BIF <code class="bold_code"> binary_to_term/1 </code> is used. </p> <p> The distribution does this implicitly when sending messages across node boundaries. </p>  <p> The overall format of the term format is: </p> <table> <tr> <td>1</td> <td>1</td> <td>N</td> </tr> <tr> <td><code class="code">131</code></td> <td><code class="code">Tag</code></td> <td><code class="code">Data</code></td> </tr> </table> <em>Table 10.1: </em> <div class="note"> <div class="label">Note</div> <div class="content">

<p> When messages are <code class="bold_code"><a href="../erl_dist_protocol/#connected_nodes">passed between connected nodes</a></code> and a <code class="bold_code"><a href="#distribution_header">distribution header</a></code> is used, the first byte containing the version number (131) is omitted from the terms that follow the distribution header. This since the version number is implied by the version number in the distribution header. </p> </div> </div> <p> A compressed term looks like this: </p> <table> <tr> <td>1</td> <td>1</td> <td>4</td> <td>N</td> </tr> <tr> <td>131</td> <td>80</td> <td>UncompressedSize</td> <td>Zlib-compressedData</td> </tr> </table> <em>Table 10.2: </em> <p> Uncompressed Size (unsigned 32 bit integer in big-endian byte order) is the size of the data before it was compressed. The compressed data has the following format when it has been expanded: </p> <table> <tr> <td>1</td> <td>Uncompressed Size</td> </tr> <tr> <td>Tag</td> <td>Data</td> </tr> </table> <em>Table 10.3: </em>  <div class="note"> <div class="label">Note</div> <div class="content">

<p>As of ERTS version 5.10 (OTP-R16) support for UTF-8 encoded atoms has been introduced in the external format. However, only characters that can be encoded using Latin1 (ISO-8859-1) are currently supported in atoms. The support for UTF-8 encoded atoms in the external format has been implemented in order to be able to support all Unicode characters in atoms in <strong>some future release</strong>. Until full Unicode support for atoms has been introduced, it is an <strong>error</strong> to pass atoms containing characters that cannot be encoded in Latin1, and <strong>the behavior is undefined</strong>.</p> <p>When the <code class="bold_code"><a href="../erl_dist_protocol/#dflags"><span class="code">DFLAG_UTF8_ATOMS</span></a></code> distribution flag has been exchanged between both nodes in the <code class="bold_code"><a href="../erl_dist_protocol/#distribution_handshake">distribution handshake</a></code>, all atoms in the distribution header will be encoded in UTF-8; otherwise, all atoms in the distribution header will be encoded in Latin1. The two new tags <code class="bold_code"><a href="#ATOM_UTF8_EXT">ATOM_UTF8_EXT</a></code>, and <code class="bold_code"><a href="#SMALL_ATOM_UTF8_EXT">SMALL_ATOM_UTF8_EXT</a></code> will only be used if the <code class="code">DFLAG_UTF8_ATOMS</code> distribution flag has been exchanged between nodes, or if an atom containing characters that cannot be encoded in Latin1 is encountered. </p> <p>The maximum number of allowed characters in an atom is 255. In the UTF-8 case each character may need 4 bytes to be encoded. </p> </div> </div> <h2 id="id92462">10.2 Distribution header</h2> <p id="distribution_header">  As of erts version 5.7.2 the old atom cache protocol was dropped and a new one was introduced. This atom cache protocol introduced the distribution header. Nodes with erts versions earlier than 5.7.2 can still communicate with new nodes, but no distribution header and no atom cache will be used.</p> <p> The distribution header currently only contains an atom cache reference section, but could in the future contain more information. The distribution header precedes one or more Erlang terms on the external format. For more information see the documentation of the <code class="bold_code"><a href="../erl_dist_protocol/#connected_nodes">protocol between connected nodes</a></code> in the <code class="bold_code"><a href="../erl_dist_protocol/">distribution protocol</a></code> documentation. </p> <p> <code class="bold_code"><a href="#ATOM_CACHE_REF">ATOM_CACHE_REF</a></code> entries with corresponding <code class="code">AtomCacheReferenceIndex</code> in terms encoded on the external format following a distribution header refers to the atom cache references made in the distribution header. The range is 0 &lt;= <code class="code">AtomCacheReferenceIndex</code> &lt; 255, i.e., at most 255 different atom cache references from the following terms can be made. </p> <p> The distribution header format is: </p> <table> <tr> <td>1</td> <td>1</td> <td>1</td> <td>NumberOfAtomCacheRefs/2+1 | 0</td> <td>N | 0</td> </tr> <tr> <td><code class="code">131</code></td> <td><code class="code">68</code></td> <td><code class="code">NumberOfAtomCacheRefs</code></td> <td><code class="code">Flags</code></td> <td><code class="code">AtomCacheRefs</code></td> </tr> </table> <em>Table 10.4: </em> <p> <code class="code">Flags</code> consists of <code class="code">NumberOfAtomCacheRefs/2+1</code> bytes, unless <code class="code">NumberOfAtomCacheRefs</code> is <code class="code">0</code>. If <code class="code">NumberOfAtomCacheRefs</code> is <code class="code">0</code>, <code class="code">Flags</code> and <code class="code">AtomCacheRefs</code> are omitted. Each atom cache reference have a half byte flag field. Flags corresponding to a specific <code class="code">AtomCacheReferenceIndex</code>, are located in flag byte number <code class="code">AtomCacheReferenceIndex/2</code>. Flag byte 0 is the first byte after the <code class="code">NumberOfAtomCacheRefs</code> byte. Flags for an even <code class="code">AtomCacheReferenceIndex</code> are located in the least significant half byte and flags for an odd <code class="code">AtomCacheReferenceIndex</code> are located in the most significant half byte. </p> <p> The flag field of an atom cache reference has the following format: </p> <table> <tr> <td>1 bit</td> <td>3 bits</td> </tr> <tr> <td><code class="code">NewCacheEntryFlag</code></td> <td><code class="code">SegmentIndex</code></td> </tr> </table> <em>Table 10.5: </em> <p> The most significant bit is the <code class="code">NewCacheEntryFlag</code>. If set, the corresponding cache reference is new. The three least significant bits are the <code class="code">SegmentIndex</code> of the corresponding atom cache entry. An atom cache consists of 8 segments each of size 256, i.e., an atom cache can contain 2048 entries. </p> <p> After flag fields for atom cache references, another half byte flag field is located which has the following format: </p> <table> <tr> <td>3 bits</td> <td>1 bit</td> </tr> <tr> <td><code class="code">CurrentlyUnused</code></td> <td><code class="code">LongAtoms</code></td> </tr> </table> <em>Table 10.6: </em> <p> The least significant bit in that half byte is the <code class="code">LongAtoms</code> flag. If it is set, 2 bytes are used for atom lengths instead of 1 byte in the distribution header. </p> <p> After the <code class="code">Flags</code> field follow the <code class="code">AtomCacheRefs</code>. The first <code class="code">AtomCacheRef</code> is the one corresponding to <code class="code">AtomCacheReferenceIndex</code> 0. Higher indices follows in sequence up to index <code class="code">NumberOfAtomCacheRefs - 1</code>. </p> <p> If the <code class="code">NewCacheEntryFlag</code> for the next <code class="code">AtomCacheRef</code> has been set, a <code class="code">NewAtomCacheRef</code> on the following format will follow: </p> <table> <tr> <td>1</td> <td>1 | 2</td> <td>Length</td> </tr> <tr> <td><code class="code">InternalSegmentIndex</code></td> <td><code class="code">Length</code></td> <td><code class="code">AtomText</code></td> </tr> </table> <em>Table 10.7: </em> <p> <code class="code">InternalSegmentIndex</code> together with the <code class="code">SegmentIndex</code> completely identify the location of an atom cache entry in the atom cache. <code class="code">Length</code> is number of bytes that <code class="code">AtomText</code> consists of. Length is a two byte big endian integer if the <code class="code">LongAtoms</code> flag has been set, otherwise a one byte integer. When the <code class="bold_code"><a href="../erl_dist_protocol/#dflags"><span class="code">DFLAG_UTF8_ATOMS</span></a></code> distribution flag has been exchanged between both nodes in the <code class="bold_code"><a href="../erl_dist_protocol/#distribution_handshake">distribution handshake</a></code>, characters in <code class="code">AtomText</code> is encoded in UTF-8; otherwise, encoded in Latin1. Subsequent <code class="code">CachedAtomRef</code>s with the same <code class="code">SegmentIndex</code> and <code class="code">InternalSegmentIndex</code> as this <code class="code">NewAtomCacheRef</code> will refer to this atom until a new <code class="code">NewAtomCacheRef</code> with the same <code class="code">SegmentIndex</code> and <code class="code">InternalSegmentIndex</code> appear. </p> <p> For more information on encoding of atoms, see <code class="bold_code"><a href="#utf8_atoms">note on UTF-8 encoded atoms</a></code> in the beginning of this document. </p> <p> If the <code class="code">NewCacheEntryFlag</code> for the next <code class="code">AtomCacheRef</code> has not been set, a <code class="code">CachedAtomRef</code> on the following format will follow: </p> <table> <tr> <td>1</td> </tr> <tr> <td><code class="code">InternalSegmentIndex</code></td> </tr> </table> <em>Table 10.8: </em> <p> <code class="code">InternalSegmentIndex</code> together with the <code class="code">SegmentIndex</code> identify the location of the atom cache entry in the atom cache. The atom corresponding to this <code class="code">CachedAtomRef</code> is the latest <code class="code">NewAtomCacheRef</code> preceding this <code class="code">CachedAtomRef</code> in another previously passed distribution header. </p> <h2 id="id93071">10.3 atom_cache_ref</h2>  <table> <tr> <td>1</td> <td>1</td> </tr> <tr> <td><code class="code">82</code></td> <td><code class="code">AtomCacheReferenceIndex</code></td> </tr> </table> <em>Table 10.9: </em> <p> Refers to the atom with <code class="code">AtomCacheReferenceIndex</code> in the <code class="bold_code"><a href="#distribution_header">distribution header</a></code>. </p> <h2 id="id93146">10.4 small_integer_ext</h2>  <table> <tr> <td>1</td> <td>1</td> </tr> <tr> <td>97</td> <td>Int</td> </tr> </table> <em>Table 10.10: </em> <p> Unsigned 8 bit integer. </p> <h2 id="id93210">10.5 integer_ext</h2>  <table> <tr> <td>1</td> <td>4</td> </tr> <tr> <td>98</td> <td>Int</td> </tr> </table> <em>Table 10.11: </em> <p> Signed 32 bit integer in big-endian format (i.e. MSB first) </p> <h2 id="id93274">10.6 float_ext</h2>  <table> <tr> <td>1</td> <td>31</td> </tr> <tr> <td>99</td> <td>Float String</td> </tr> </table> <em>Table 10.12: </em> <p> A float is stored in string format. the format used in sprintf to format the float is "%.20e" (there are more bytes allocated than necessary). To unpack the float use sscanf with format "%lf". </p> <p> This term is used in minor version 0 of the external format; it has been superseded by <code class="bold_code"><a href="#NEW_FLOAT_EXT"> NEW_FLOAT_EXT </a></code>. </p> <h2 id="id93349">10.7 atom_ext</h2>  <table> <tr> <td>1</td> <td>2</td> <td>Len</td> </tr> <tr> <td><code class="code">100</code></td> <td><code class="code">Len</code></td> <td><code class="code">AtomName</code></td> </tr> </table> <em>Table 10.13: </em> <p> An atom is stored with a 2 byte unsigned length in big-endian order, followed by <code class="code">Len</code> numbers of 8 bit Latin1 characters that forms the <code class="code">AtomName</code>. <strong>Note</strong>: The maximum allowed value for <code class="code">Len</code> is 255. </p> <h2 id="id93448">10.8 reference_ext</h2>  <table> <tr> <td>1</td> <td>N</td> <td>4</td> <td>1</td> </tr> <tr> <td><code class="code">101</code></td> <td><code class="code">Node</code></td> <td><code class="code">ID</code></td> <td><code class="code">Creation</code></td> </tr> </table> <em>Table 10.14: </em> <p> Encode a reference object (an object generated with <code class="code">make_ref/0</code>). The <code class="code">Node</code> term is an encoded atom, i.e. <code class="bold_code"><a href="#ATOM_EXT">ATOM_EXT</a></code>, <code class="bold_code"><a href="#SMALL_ATOM_EXT">SMALL_ATOM_EXT</a></code> or <code class="bold_code"><a href="#ATOM_CACHE_REF">ATOM_CACHE_REF</a></code>. The <code class="code">ID</code> field contains a big-endian unsigned integer, but <strong>should be regarded as uninterpreted data</strong> since this field is node specific. <code class="code">Creation</code> is a byte containing a node serial number that makes it possible to separate old (crashed) nodes from a new one. </p> <p> In <code class="code">ID</code>, only 18 bits are significant; the rest should be 0. In <code class="code">Creation</code>, only 2 bits are significant; the rest should be 0. See <code class="bold_code"><a href="#NEW_REFERENCE_EXT">NEW_REFERENCE_EXT</a></code>. </p> <h2 id="id93606">10.9 port_ext</h2>  <table> <tr> <td>1</td> <td>N</td> <td>4</td> <td>1</td> </tr> <tr> <td><code class="code">102</code></td> <td><code class="code">Node</code></td> <td><code class="code">ID</code></td> <td><code class="code">Creation</code></td> </tr> </table> <em>Table 10.15: </em> <p> Encode a port object (obtained form <code class="code">open_port/2</code>). The <code class="code">ID</code> is a node specific identifier for a local port. Port operations are not allowed across node boundaries. The <code class="code">Creation</code> works just like in <code class="bold_code"><a href="#REFERENCE_EXT">REFERENCE_EXT</a></code>. </p> <h2 id="id93725">10.10 pid_ext</h2>  <table> <tr> <td>1</td> <td>N</td> <td>4</td> <td>4</td> <td>1</td> </tr> <tr> <td><code class="code">103</code></td> <td><code class="code">Node</code></td> <td><code class="code">ID</code></td> <td><code class="code">Serial</code></td> <td><code class="code">Creation</code></td> </tr> </table> <em>Table 10.16: </em> <p> Encode a process identifier object (obtained from <code class="code">spawn/3</code> or friends). The <code class="code">ID</code> and <code class="code">Creation</code> fields works just like in <code class="bold_code"><a href="#REFERENCE_EXT">REFERENCE_EXT</a></code>, while the <code class="code">Serial</code> field is used to improve safety. In <code class="code">ID</code>, only 15 bits are significant; the rest should be 0. </p> <h2 id="id93869">10.11 small_tuple_ext</h2>  <table> <tr> <td>1</td> <td>1</td> <td>N</td> </tr> <tr> <td>104</td> <td>Arity</td> <td>Elements</td> </tr> </table> <em>Table 10.17: </em> <p> <code class="code">SMALL_TUPLE_EXT</code> encodes a tuple. The <code class="code">Arity</code> field is an unsigned byte that determines how many element that follows in the <code class="code">Elements</code> section. </p> <h2 id="id93961">10.12 large_tuple_ext</h2>  <table> <tr> <td>1</td> <td>4</td> <td>N</td> </tr> <tr> <td>105</td> <td>Arity</td> <td>Elements</td> </tr> </table> <em>Table 10.18: </em> <p> Same as <code class="bold_code"><a href="#SMALL_TUPLE_EXT">SMALL_TUPLE_EXT</a></code> with the exception that <code class="code">Arity</code> is an unsigned 4 byte integer in big endian format. </p> <h2 id="id94051">10.13 map_ext</h2>  <table> <tr> <td>1</td> <td>4</td> <td>N</td> </tr> <tr> <td>116</td> <td>Arity</td> <td>Pairs</td> </tr> </table> <em>Table 10.19: </em> <p> <code class="code">MAP_EXT</code> encodes a map. The <code class="code">Arity</code> field is an unsigned 4 byte integer in big endian format that determines the number of key-value pairs in the map. Key and value pairs (<code class="code">Ki =&gt; Vi</code>) are encoded in the <code class="code">Pairs</code> section in the following order: <code class="code">K1, V1, K2, V2,..., Kn, Vn</code>. Duplicate keys are <strong>not allowed</strong> within the same map. </p> <p><strong>Since: </strong>OTP 17.0</p> <h2 id="id94161">10.14 nil_ext</h2>  <table> <tr> <td>1</td> </tr> <tr> <td>106</td> </tr> </table> <em>Table 10.20: </em> <p> The representation for an empty list, i.e. the Erlang syntax <code class="code">[]</code>. </p> <h2 id="id94212">10.15 string_ext</h2>  <table> <tr> <td>1</td> <td>2</td> <td>Len</td> </tr> <tr> <td>107</td> <td>Length</td> <td>Characters</td> </tr> </table> <em>Table 10.21: </em> <p> String does NOT have a corresponding Erlang representation, but is an optimization for sending lists of bytes (integer in the range 0-255) more efficiently over the distribution. Since the <code class="code">Length</code> field is an unsigned 2 byte integer (big endian), implementations must make sure that lists longer than 65535 elements are encoded as <code class="bold_code"><a href="#LIST_EXT">LIST_EXT</a></code>. </p> <h2 id="id94305">10.16 list_ext</h2>  <table> <tr> <td>1</td> <td>4</td> <td> </td> <td> </td> </tr> <tr> <td>108</td> <td>Length</td> <td>Elements</td> <td>Tail</td> </tr> </table> <em>Table 10.22: </em> <p> <code class="code">Length</code> is the number of elements that follows in the <code class="code">Elements</code> section. <code class="code">Tail</code> is the final tail of the list; it is <code class="bold_code"><a href="#NIL_EXT">NIL_EXT</a></code> for a proper list, but may be anything type if the list is improper (for instance <code class="code">[a|b]</code>). </p> <h2 id="id94423">10.17 binary_ext</h2>  <table> <tr> <td>1</td> <td>4</td> <td>Len</td> </tr> <tr> <td>109</td> <td>Len</td> <td>Data</td> </tr> </table> <em>Table 10.23: </em> <p> Binaries are generated with bit syntax expression or with <code class="bold_code">list_to_binary/1</code>, <code class="bold_code">term_to_binary/1</code>, or as input from binary ports. The <code class="code">Len</code> length field is an unsigned 4 byte integer (big endian). </p> <h2 id="id94520">10.18 small_big_ext</h2>  <table> <tr> <td>1</td> <td>1</td> <td>1</td> <td>n</td> </tr> <tr> <td>110</td> <td>n</td> <td>Sign</td> <td>d(0) ... d(n-1)</td> </tr> </table> <em>Table 10.24: </em> <p> Bignums are stored in unary form with a <code class="code">Sign</code> byte that is 0 if the binum is positive and 1 if is negative. The digits are stored with the LSB byte stored first. To calculate the integer the following formula can be used:<br> B = 256<br> (d0*B^0 + d1*B^1 + d2*B^2 + ... d(N-1)*B^(n-1)) </p> <h2 id="id94628">10.19 large_big_ext</h2>  <table> <tr> <td>1</td> <td>4</td> <td>1</td> <td>n</td> </tr> <tr> <td>111</td> <td>n</td> <td>Sign</td> <td>d(0) ... d(n-1)</td> </tr> </table> <em>Table 10.25: </em> <p> Same as <code class="bold_code"><a href="#SMALL_BIG_EXT">SMALL_BIG_EXT</a></code> with the difference that the length field is an unsigned 4 byte integer. </p> <h2 id="id94731">10.20 new_reference_ext</h2>  <table> <tr> <td>1</td> <td>2</td> <td>N</td> <td>1</td> <td>N'</td> </tr> <tr> <td>114</td> <td>Len</td> <td>Node</td> <td>Creation</td> <td>ID ...</td> </tr> </table> <em>Table 10.26: </em> <p> Node and Creation are as in <code class="bold_code"><a href="#REFERENCE_EXT">REFERENCE_EXT</a></code>. </p> <p> <code class="code">ID</code> contains a sequence of big-endian unsigned integers (4 bytes each, so <code class="code">N'</code> is a multiple of 4), but should be regarded as uninterpreted data. </p> <p> <code class="code">N'</code> = 4 * <code class="code">Len</code>. </p> <p> In the first word (four bytes) of <code class="code">ID</code>, only 18 bits are significant, the rest should be 0. In <code class="code">Creation</code>, only 2 bits are significant, the rest should be 0. </p> <p> NEW_REFERENCE_EXT was introduced with distribution version 4. In version 4, <code class="code">N'</code> should be at most 12. </p> <p> See <code class="bold_code"><a href="#REFERENCE_EXT">REFERENCE_EXT</a></code>). </p> <h2 id="id94903">10.21 small_atom_ext</h2>  <table> <tr> <td>1</td> <td>1</td> <td>Len</td> </tr> <tr> <td><code class="code">115</code></td> <td><code class="code">Len</code></td> <td><code class="code">AtomName</code></td> </tr> </table> <em>Table 10.27: </em> <p> An atom is stored with a 1 byte unsigned length, followed by <code class="code">Len</code> numbers of 8 bit Latin1 characters that forms the <code class="code">AtomName</code>. Longer atoms can be represented by <code class="bold_code"><a href="#ATOM_EXT">ATOM_EXT</a></code>. <strong>Note</strong> the <code class="code">SMALL_ATOM_EXT</code> was introduced in erts version 5.7.2 and require an exchange of the <code class="bold_code"><a href="../erl_dist_protocol/#dflags"><span class="code">DFLAG_SMALL_ATOM_TAGS</span></a></code> distribution flag in the <code class="bold_code"><a href="../erl_dist_protocol/#distribution_handshake">distribution handshake</a></code>. </p> <h2 id="id95022">10.22 fun_ext</h2>  <table> <tr> <td>1</td> <td>4</td> <td>N1</td> <td>N2</td> <td>N3</td> <td>N4</td> <td>N5</td> </tr> <tr> <td>117</td> <td>NumFree</td> <td>Pid</td> <td>Module</td> <td>Index</td> <td>Uniq</td> <td>Free vars ...</td> </tr> </table> <em>Table 10.28: </em> <dl> <dt><strong><code class="code">Pid</code></strong></dt> <dd> is a process identifier as in <code class="bold_code"><a href="#PID_EXT">PID_EXT</a></code>. It represents the process in which the fun was created. </dd> <dt><strong><code class="code">Module</code></strong></dt> <dd> is an encoded as an atom, using <code class="bold_code"><a href="#ATOM_EXT">ATOM_EXT</a></code>, <code class="bold_code"><a href="#SMALL_ATOM_EXT">SMALL_ATOM_EXT</a></code> or <code class="bold_code"><a href="#ATOM_CACHE_REF">ATOM_CACHE_REF</a></code>. This is the module that the fun is implemented in. </dd> <dt><strong><code class="code">Index</code></strong></dt> <dd> is an integer encoded using <code class="bold_code"><a href="#SMALL_INTEGER_EXT">SMALL_INTEGER_EXT</a></code> or <code class="bold_code"><a href="#INTEGER_EXT">INTEGER_EXT</a></code>. It is typically a small index into the module's fun table. </dd> <dt><strong><code class="code">Uniq</code></strong></dt> <dd> is an integer encoded using <code class="bold_code"><a href="#SMALL_INTEGER_EXT">SMALL_INTEGER_EXT</a></code> or <code class="bold_code"><a href="#INTEGER_EXT">INTEGER_EXT</a></code>. <code class="code">Uniq</code> is the hash value of the parse for the fun. </dd> <dt><strong><code class="code">Free vars</code></strong></dt> <dd> is <code class="code">NumFree</code> number of terms, each one encoded according to its type. </dd> </dl> <h2 id="id95269">10.23 new_fun_ext</h2>  <table> <tr> <td>1</td> <td>4</td> <td>1</td> <td>16</td> <td>4</td> <td>4</td> <td>N1</td> <td>N2</td> <td>N3</td> <td>N4</td> <td>N5</td> </tr> <tr> <td>112</td> <td>Size</td> <td>Arity</td> <td>Uniq</td> <td>Index</td> <td>NumFree</td> <td>Module</td> <td>OldIndex</td> <td>OldUniq</td> <td>Pid</td> <td>Free Vars</td> </tr> </table> <em>Table 10.29: </em> <p> This is the new encoding of internal funs: <code class="code">fun F/A</code> and <code class="code">fun(Arg1,..) -&gt; ... end</code>. </p> <dl> <dt><strong><code class="code">Size</code></strong></dt> <dd> is the total number of bytes, including the <code class="code">Size</code> field. </dd> <dt><strong><code class="code">Arity</code></strong></dt> <dd> is the arity of the function implementing the fun. </dd> <dt><strong><code class="code">Uniq</code></strong></dt> <dd> is the 16 bytes MD5 of the significant parts of the Beam file. </dd> <dt><strong><code class="code">Index</code></strong></dt> <dd> is an index number. Each fun within a module has an unique index. <code class="code">Index</code> is stored in big-endian byte order. </dd> <dt><strong><code class="code">NumFree</code></strong></dt> <dd> is the number of free variables. </dd> <dt><strong><code class="code">Module</code></strong></dt> <dd> is an encoded as an atom, using <code class="bold_code"><a href="#ATOM_EXT">ATOM_EXT</a></code>, <code class="bold_code"><a href="#SMALL_ATOM_EXT">SMALL_ATOM_EXT</a></code> or <code class="bold_code"><a href="#ATOM_CACHE_REF">ATOM_CACHE_REF</a></code>. This is the module that the fun is implemented in. </dd> <dt><strong><code class="code">OldIndex</code></strong></dt> <dd> is an integer encoded using <code class="bold_code"><a href="#SMALL_INTEGER_EXT">SMALL_INTEGER_EXT</a></code> or <code class="bold_code"><a href="#INTEGER_EXT">INTEGER_EXT</a></code>. It is typically a small index into the module's fun table. </dd> <dt><strong><code class="code">OldUniq</code></strong></dt> <dd> is an integer encoded using <code class="bold_code"><a href="#SMALL_INTEGER_EXT">SMALL_INTEGER_EXT</a></code> or <code class="bold_code"><a href="#INTEGER_EXT">INTEGER_EXT</a></code>. <code class="code">Uniq</code> is the hash value of the parse tree for the fun. </dd> <dt><strong><code class="code">Pid</code></strong></dt> <dd> is a process identifier as in <code class="bold_code"><a href="#PID_EXT">PID_EXT</a></code>. It represents the process in which the fun was created. </dd> <dt><strong><code class="code">Free vars</code></strong></dt> <dd> is <code class="code">NumFree</code> number of terms, each one encoded according to its type. </dd> </dl> <h2 id="id95646">10.24 export_ext</h2>  <table> <tr> <td>1</td> <td>N1</td> <td>N2</td> <td>N3</td> </tr> <tr> <td>113</td> <td>Module</td> <td>Function</td> <td>Arity</td> </tr> </table> <em>Table 10.30: </em> <p> This term is the encoding for external funs: <code class="code">fun M:F/A</code>. </p> <p> <code class="code">Module</code> and <code class="code">Function</code> are atoms (encoded using <code class="bold_code"><a href="#ATOM_EXT">ATOM_EXT</a></code>, <code class="bold_code"><a href="#SMALL_ATOM_EXT">SMALL_ATOM_EXT</a></code> or <code class="bold_code"><a href="#ATOM_CACHE_REF">ATOM_CACHE_REF</a></code>). </p> <p> <code class="code">Arity</code> is an integer encoded using <code class="bold_code"><a href="#SMALL_INTEGER_EXT">SMALL_INTEGER_EXT</a></code>. </p> <h2 id="id95790">10.25 bit_binary_ext</h2>  <table> <tr> <td>1</td> <td>4</td> <td>1</td> <td>Len</td> </tr> <tr> <td>77</td> <td>Len</td> <td>Bits</td> <td>Data</td> </tr> </table> <em>Table 10.31: </em> <p> This term represents a bitstring whose length in bits does not have to be a multiple of 8. The <code class="code">Len</code> field is an unsigned 4 byte integer (big endian). The <code class="code">Bits</code> field is the number of bits (1-8) that are used in the last byte in the data field, counting from the most significant bit towards the least significant. </p> <h2 id="id95896">10.26 new_float_ext</h2>  <table> <tr> <td>1</td> <td>8</td> </tr> <tr> <td>70</td> <td>IEEE float</td> </tr> </table> <em>Table 10.32: </em> <p> A float is stored as 8 bytes in big-endian IEEE format. </p> <p> This term is used in minor version 1 of the external format. </p> <h2 id="id95964">10.27 atom_utf8_ext</h2>  <table> <tr> <td>1</td> <td>2</td> <td>Len</td> </tr> <tr> <td><code class="code">118</code></td> <td><code class="code">Len</code></td> <td><code class="code">AtomName</code></td> </tr> </table> <em>Table 10.33: </em> <p> An atom is stored with a 2 byte unsigned length in big-endian order, followed by <code class="code">Len</code> bytes containing the <code class="code">AtomName</code> encoded in UTF-8. </p> <p> For more information on encoding of atoms, see <code class="bold_code"><a href="#utf8_atoms">note on UTF-8 encoded atoms</a></code> in the beginning of this document. </p> <h2 id="id96066">10.28 small_atom_utf8_ext</h2>  <table> <tr> <td>1</td> <td>1</td> <td>Len</td> </tr> <tr> <td><code class="code">119</code></td> <td><code class="code">Len</code></td> <td><code class="code">AtomName</code></td> </tr> </table> <em>Table 10.34: </em> <p> An atom is stored with a 1 byte unsigned length, followed by <code class="code">Len</code> bytes containing the <code class="code">AtomName</code> encoded in UTF-8. Longer atoms encoded in UTF-8 can be represented using <code class="bold_code"><a href="#ATOM_UTF8_EXT">ATOM_UTF8_EXT</a></code>. </p> <p> For more information on encoding of atoms, see <code class="bold_code"><a href="#utf8_atoms">note on UTF-8 encoded atoms</a></code> in the beginning of this document. </p>
<div class="_attribution">
  <p class="_attribution-p">
    © 1999–2016 Ericsson AB<br>Licensed under the Apache License, Version 2.0.<br>
    
  </p>
</div>

			</div>
		</div>
	</section>

	</div>
</body>
</html>
