
<!DOCTYPE HTML>

<html lang="en">

<head>
  <meta charset="utf-8">
  <title>4 How to Interpret the Erlang Crash Dumps - Erlang 18 - W3cubDocs</title>
  
  <meta name="description" content=" This document describes the erl_crash.dump file generated upon abnormal exit of the Erlang runtime system. ">
  <meta name="keywords" content="how, interpret, erlang, crash, dumps, -, erlang~18">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="http://docs.w3cub.com/erlang~18/erts-7.3/doc/html/crash_dump/">
  <link href="/favicon.png" rel="icon">
  <link type="text/css" rel="stylesheet" href="/assets/application-50364fff564ce3b6327021805f3f00e2957b441cf27f576a7dd4ff63bbc47047.css">
  <script type="text/javascript" src="/assets/application-db64bfd54ceb42be11af7995804cf4902548419ceb79d509b0b7d62c22d98e6f.js"></script>
  <script src="/json/erlang~18.js"></script>
  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-71174418-1']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>


</head>

<body>
	<div class="_app">
	<header class="_header">
  
  <form class="_search">
    <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
    <a class="_search-clear"></a>
    <div class="_search-tag"></div>
  </form>
  
  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/erlang~18/" class="_nav-link" title="" style="margin-left:0;">Erlang 18</a></span>
  
  <nav class="_nav">
    <a href="/app/" class="_nav-link ">App</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		<div class="_list">
			
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<div class="_page _erlang">
				
<h1>4 How to interpret the Erlang crash dumps</h1> <p>This document describes the <code class="code">erl_crash.dump</code> file generated upon abnormal exit of the Erlang runtime system.</p> <p><strong>Important:</strong> For OTP release R9C the Erlang crash dump has had a major facelift. This means that the information in this document will not be directly applicable for older dumps. However, if you use the Crashdump Viewer tool on older dumps, the crash dumps are translated into a format similar to this.</p> <p>The system will write the crash dump in the current directory of the emulator or in the file pointed out by the environment variable (whatever that means on the current operating system) ERL_CRASH_DUMP. For a crash dump to be written, there has to be a writable file system mounted.</p> <p>Crash dumps are written mainly for one of two reasons: either the builtin function <code class="code">erlang:halt/1</code> is called explicitly with a string argument from running Erlang code, or else the runtime system has detected an error that cannot be handled. The most usual reason that the system can't handle the error is that the cause is external limitations, such as running out of memory. A crash dump due to an internal error may be caused by the system reaching limits in the emulator itself (like the number of atoms in the system, or too many simultaneous ets tables). Usually the emulator or the operating system can be reconfigured to avoid the crash, which is why interpreting the crash dump correctly is important.</p> <p>On systems that support OS signals, it is also possible to stop the runtime system and generate a crash dump by sending the SIGUSR1.</p> <p>The erlang crash dump is a readable text file, but it might not be very easy to read. Using the Crashdump Viewer tool in the <code class="code">observer</code> application will simplify the task. This is an wx-widget based tool for browsing Erlang crash dumps.</p> <h2 id="id83449">4.1 General information</h2>  <p>The first part of the dump shows the creation time for the dump, a slogan indicating the reason for the dump, the system version, of the node from which the dump originates, the compile time of the emulator running the originating node, the number of atoms in the atom table and the runtime system thread that caused the crash dump to happen. </p> <h4>Reasons for crash dumps (slogan)</h4> <p>The reason for the dump is noted in the beginning of the file as <strong>Slogan: &lt;reason&gt;</strong> (the word "slogan" has historical roots). If the system is halted by the BIF <code class="code">erlang:halt/1</code>, the slogan is the string parameter passed to the BIF, otherwise it is a description generated by the emulator or the (Erlang) kernel. Normally the message should be enough to understand the problem, but nevertheless some messages are described here. Note however that the suggested reasons for the crash are <strong>only suggestions</strong>. The exact reasons for the errors may vary depending on the local applications and the underlying operating system.</p> <ul> <li>"<strong>&lt;A&gt;</strong>: Cannot allocate <strong>&lt;N&gt;</strong> bytes of memory (of type "<strong>&lt;T&gt;</strong>")." - The system has run out of memory. &lt;A&gt; is the allocator that failed to allocate memory, &lt;N&gt; is the number of bytes that &lt;A&gt; tried to allocate, and &lt;T&gt; is the memory block type that the memory was needed for. The most common case is that a process stores huge amounts of data. In this case &lt;T&gt; is most often <code class="code">heap</code>, <code class="code">old_heap</code>, <code class="code">heap_frag</code>, or <code class="code">binary</code>. For more information on allocators see <code class="bold_code"><a href="../erts_alloc/">erts_alloc(3)</a></code>.</li> <li>"<strong>&lt;A&gt;</strong>: Cannot reallocate <strong>&lt;N&gt;</strong> bytes of memory (of type "<strong>&lt;T&gt;</strong>")." - Same as above with the exception that memory was being reallocated instead of being allocated when the system ran out of memory.</li> <li>"Unexpected op code <strong>N</strong>" - Error in compiled code, <code class="code">beam</code> file damaged or error in the compiler.</li> <li>"Module <strong>Name</strong> undefined" <code class="code">|</code> "Function <strong>Name</strong> undefined" <code class="code">|</code> "No function <strong>Name</strong>:<strong>Name</strong>/1" <code class="code">|</code> "No function <strong>Name</strong>:start/2" - The kernel/stdlib applications are damaged or the start script is damaged.</li> <li>"Driver_select called with too large file descriptor <code class="code">N</code>" - The number of file descriptors for sockets exceed 1024 (Unix only). The limit on file-descriptors in some Unix flavors can be set to over 1024, but only 1024 sockets/pipes can be used simultaneously by Erlang (due to limitations in the Unix <code class="code">select</code> call). The number of open regular files is not affected by this.</li> <li>"Received SIGUSR1" - Sending the SIGUSR1 signal to a Erlang machine (Unix only) forces a crash dump. This slogan reflects that the Erlang machine crash-dumped due to receiving that signal.</li> <li>"Kernel pid terminated (<strong>Who</strong>) (<strong>Exit-reason</strong>)" - The kernel supervisor has detected a failure, usually that the <code class="code">application_controller</code> has shut down (<code class="code">Who</code> = <code class="code">application_controller</code>, <code class="code">Why</code> = <code class="code">shutdown</code>). The application controller may have shut down for a number of reasons, the most usual being that the node name of the distributed Erlang node is already in use. A complete supervisor tree "crash" (i.e., the top supervisors have exited) will give about the same result. This message comes from the Erlang code and not from the virtual machine itself. It is always due to some kind of failure in an application, either within OTP or a "user-written" one. Looking at the error log for your application is probably the first step to take.</li> <li>"Init terminating in do_boot ()" - The primitive Erlang boot sequence was terminated, most probably because the boot script has errors or cannot be read. This is usually a configuration error - the system may have been started with a faulty <code class="code">-boot</code> parameter or with a boot script from the wrong version of OTP.</li> <li>"Could not start kernel pid (<strong>Who</strong>) ()" - One of the kernel processes could not start. This is probably due to faulty arguments (like errors in a <code class="code">-config</code> argument) or faulty configuration files. Check that all files are in their correct location and that the configuration files (if any) are not damaged. Usually there are also messages written to the controlling terminal and/or the error log explaining what's wrong.</li> </ul> <p>Other errors than the ones mentioned above may occur, as the <code class="code">erlang:halt/1</code> BIF may generate any message. If the message is not generated by the BIF and does not occur in the list above, it may be due to an error in the emulator. There may however be unusual messages that I haven't mentioned, that still are connected to an application failure. There is a lot more information available, so more thorough reading of the crash dump may reveal the crash reason. The size of processes, the number of ets tables and the Erlang data on each process stack can be useful for tracking down the problem.</p> <h4>Number of atoms</h4> <p>The number of atoms in the system at the time of the crash is shown as <strong>Atoms: &lt;number&gt;</strong>. Some ten thousands atoms is perfectly normal, but more could indicate that the BIF <code class="code">erlang:list_to_atom/1</code> is used to dynamically generate a lot of <strong>different</strong> atoms, which is never a good idea.</p> <h2 id="id83720">4.2 Scheduler information</h2>  <p>Under the tag <strong>=scheduler</strong> information about the current state and statistics of the schedulers in the runtime system is displayed. On OSs that do allow instant suspension of other threads, the data within this section will reflect what the runtime system looks like at the moment when the crash happens.</p> <p>The following fields can exist for a process:</p> <dl> <dt><strong><strong>=scheduler:id</strong></strong></dt> <dd>Header, states the scheduler identifier.</dd> <dt><strong><strong>Scheduler Sleep Info Flags</strong></strong></dt> <dd>If empty the scheduler was doing some work. If not empty the scheduler is either in some state of sleep, or suspended. This entry is only present in a SMP enabled emulator</dd> <dt><strong><strong>Scheduler Sleep Info Aux Work</strong></strong></dt> <dd>If not empty, a scheduler internal auxiliary work is scheduled to be done.</dd> <dt><strong><strong>Current Port</strong></strong></dt> <dd>The port identifier of the port that is currently being executed by the scheduler.</dd> <dt><strong><strong>Current Process</strong></strong></dt> <dd>The process identifier of the process that is currently being executed by the scheduler. If there is such a process this entry is followed by the <strong>State</strong>,<strong>Internal State</strong>, <strong>Program Counter</strong>, <strong>CP</strong> of that same process. See <code class="bold_code"><a href="#processes">Process Information</a></code> for a description what the different entries mean. Keep in mind that this is a snapshot of what the entries are exactly when the crash dump is starting to be generated. Therefore they will most likely be different (and more telling) then the entries for the same processes found in the <strong>=proc</strong> section. If there is no currently running process, only the <strong>Current Process</strong> entry will be printed. </dd> <dt><strong><strong>Current Process Limited Stack Trace</strong></strong></dt> <dd>This entry only shows up if there is a current process. It is very similar to <code class="bold_code"><a href="#proc_data"><strong>=proc_stack</strong></a></code>, except that only the function frames are printed (i.e. the stack variables are omited). It is also limited to only print the top and bottom part of the stack. If the stack is small (less that 512 slots) then the entire stack will be printed. If not, an entry stating <div class="example"><pre>skipping ## slots</pre></div> will be printed where ## is replaced by the number of slots that has been skipped.</dd> <dt><strong><strong>Run Queue</strong></strong></dt> <dd>Displays statistics about how many processes and ports of different priorities are scheduled on this scheduler.</dd> <dt><strong><strong>** crashed **</strong></strong></dt> <dd>This entry is normally not printed. It signifies that getting the rest of the information about this scheduler failed for some reason. </dd> </dl> <h2 id="id83872">4.3 Memory information</h2>  <p>Under the tag <strong>=memory</strong> you will find information similar to what you can obtain on a living node with <code class="bold_code">erlang:memory()</code>.</p> <h2 id="id83899">4.4 Internal table information</h2>  <p>The tags <strong>=hash_table:&lt;table_name&gt;</strong> and <strong>=index_table:&lt;table_name&gt;</strong> presents internal tables. These are mostly of interest for runtime system developers.</p> <h2 id="id83923">4.5 Allocated areas</h2>  <p>Under the tag <strong>=allocated_areas</strong> you will find information similar to what you can obtain on a living node with <code class="bold_code">erlang:system_info(allocated_areas)</code>.</p> <h2 id="id83950">4.6 Allocator</h2>  <p>Under the tag <strong>=allocator:&lt;A&gt;</strong> you will find various information about allocator &lt;A&gt;. The information is similar to what you can obtain on a living node with <code class="bold_code">erlang:system_info({allocator, &lt;A&gt;})</code>. For more information see the documentation of <code class="bold_code">erlang:system_info({allocator, &lt;A&gt;})</code>, and the <code class="bold_code"><a href="../erts_alloc/">erts_alloc(3)</a></code> documentation.</p> <h2 id="id83989">4.7 Process information</h2>  <p>The Erlang crashdump contains a listing of each living Erlang process in the system. The process information for one process may look like this (line numbers have been added): </p> <p>The following fields can exist for a process:</p> <dl> <dt><strong><strong>=proc:&lt;pid&gt;</strong></strong></dt> <dd>Heading, states the process identifier</dd> <dt><strong><strong>State</strong></strong></dt> <dd> <p>The state of the process. This can be one of the following:</p> <ul> <li> <strong>Scheduled</strong> - The process was scheduled to run but not currently running ("in the run queue").</li> <li> <strong>Waiting</strong> - The process was waiting for something (in <code class="code">receive</code>).</li> <li> <strong>Running</strong> - The process was currently running. If the BIF <code class="code">erlang:halt/1</code> was called, this was the process calling it.</li> <li> <strong>Exiting</strong> - The process was on its way to exit.</li> <li> <strong>Garbing</strong> - This is bad luck, the process was garbage collecting when the crash dump was written, the rest of the information for this process is limited.</li> <li> <strong>Suspended</strong> - The process is suspended, either by the BIF <code class="code">erlang:suspend_process/1</code> or because it is trying to write to a busy port.</li> </ul> </dd> <dt><strong><strong>Registered name</strong></strong></dt> <dd>The registered name of the process, if any.</dd> <dt><strong><strong>Spawned as</strong></strong></dt> <dd>The entry point of the process, i.e., what function was referenced in the <code class="code">spawn</code> or <code class="code">spawn_link</code> call that started the process.</dd> <dt><strong><strong>Last scheduled in for | Current call</strong></strong></dt> <dd>The current function of the process. These fields will not always exist.</dd> <dt><strong><strong>Spawned by</strong></strong></dt> <dd>The parent of the process, i.e. the process which executed <code class="code">spawn</code> or <code class="code">spawn_link</code>.</dd> <dt><strong><strong>Started</strong></strong></dt> <dd>The date and time when the process was started.</dd> <dt><strong><strong>Message queue length</strong></strong></dt> <dd>The number of messages in the process' message queue.</dd> <dt><strong><strong>Number of heap fragments</strong></strong></dt> <dd>The number of allocated heap fragments.</dd> <dt><strong><strong>Heap fragment data</strong></strong></dt> <dd>Size of fragmented heap data. This is data either created by messages being sent to the process or by the Erlang BIFs. This amount depends on so many things that this field is utterly uninteresting.</dd> <dt><strong><strong>Link list</strong></strong></dt> <dd>Process id's of processes linked to this one. May also contain ports. If process monitoring is used, this field also tells in which direction the monitoring is in effect, i.e., a link being "to" a process tells you that the "current" process was monitoring the other and a link "from" a process tells you that the other process was monitoring the current one.</dd> <dt><strong><strong>Reductions</strong></strong></dt> <dd>The number of reductions consumed by the process.</dd> <dt><strong><strong>Stack+heap</strong></strong></dt> <dd>The size of the stack and heap (they share memory segment)</dd> <dt><strong><strong>OldHeap</strong></strong></dt> <dd>The size of the "old heap". The Erlang virtual machine uses generational garbage collection with two generations. There is one heap for new data items and one for the data that have survived two garbage collections. The assumption (which is almost always correct) is that data that survive two garbage collections can be "tenured" to a heap more seldom garbage collected, as they will live for a long period. This is a quite usual technique in virtual machines. The sum of the heaps and stack together constitute most of the process's allocated memory.</dd> <dt><strong><strong>Heap unused, OldHeap unused</strong></strong></dt> <dd>The amount of unused memory on each heap. This information is usually useless.</dd> <dt><strong><strong>Stack</strong></strong></dt> <dd>If the system uses shared heap, the fields <strong>Stack+heap</strong>, <strong>OldHeap</strong>, <strong>Heap unused</strong> and <strong>OldHeap unused</strong> do not exist. Instead this field presents the size of the process' stack.</dd> <dt><strong><strong>Memory</strong></strong></dt> <dd>The total memory used by this process. This includes call stack, heap and internal structures. Same as <code class="bold_code"><a href="../erlang/#process_info-2">erlang:process_info(Pid,memory)</a></code>. </dd> <dt><strong><strong>Program counter</strong></strong></dt> <dd>The current instruction pointer. This is only interesting for runtime system developers. The function into which the program counter points is the current function of the process.</dd> <dt><strong><strong>CP</strong></strong></dt> <dd>The continuation pointer, i.e. the return address for the current call. Usually useless for other than runtime system developers. This may be followed by the function into which the CP points, which is the function calling the current function.</dd> <dt><strong><strong>Arity</strong></strong></dt> <dd>The number of live argument registers. The argument registers, if any are live, will follow. These may contain the arguments of the function if they are not yet moved to the stack.</dd> <dd><strong>Internal State</strong></dd> <dd>A more detailed internal represantation of the state of this process.</dd> </dl> <p>See also the section about <code class="bold_code"><a href="#proc_data">process data</a></code>.</p> <h2 id="id84323">4.8 Port information</h2>  <p>This section lists the open ports, their owners, any linked processed, and the name of their driver or external process.</p> <h2 id="id84340">4.9 ETS tables</h2>  <p>This section contains information about all the ETS tables in the system. The following fields are interesting for each table:</p> <dl> <dt><strong><strong>=ets:&lt;owner&gt;</strong></strong></dt> <dd>Heading, states the owner of the table (a process identifier)</dd> <dt><strong><strong>Table</strong></strong></dt> <dd>The identifier for the table. If the table is a <code class="code">named_table</code>, this is the name.</dd> <dt><strong><strong>Name</strong></strong></dt> <dd>The name of the table, regardless of whether it is a <code class="code">named_table</code> or not.</dd> <dt><strong><strong>Hash table, Buckets</strong></strong></dt> <dd>This occurs if the table is a hash table, i.e. if it is not an <code class="code">ordered_set</code>.</dd> <dt><strong><strong>Hash table, Chain Length</strong></strong></dt> <dd>Only applicable for hash tables. Contains statistics about the hash table, such as the max, min and avg chain length. Having a max much larger than the avg, and a std dev much larger that the expected std dev is a sign that the hashing of the terms is behaving badly for some reason.</dd> <dt><strong><strong>Ordered set (AVL tree), Elements</strong></strong></dt> <dd>This occurs only if the table is an <code class="code">ordered_set</code>. (The number of elements is the same as the number of objects in the table.)</dd> <dt><strong><strong>Fixed</strong></strong></dt> <dd>If the table is fixed using ets:safe_fixtable or some internal mechanism.</dd> <dt><strong><strong>Objects</strong></strong></dt> <dd>The number of objects in the table</dd> <dt><strong><strong>Words</strong></strong></dt> <dd>The number of words (usually 4 bytes/word) allocated to data in the table.</dd> <dt><strong><strong>Type</strong></strong></dt> <dd>The type of the table, i.e. <code class="code">set</code>, <code class="code">bag</code>, <code class="code">dublicate_bag</code> or <code class="code">ordered_set</code>.</dd> <dt><strong><strong>Compressed</strong></strong></dt> <dd>If this table was compressed.</dd> <dt><strong><strong>Protection</strong></strong></dt> <dd>The protection of this table.</dd> <dt><strong><strong>Write Concurrency</strong></strong></dt> <dd>If write_concurrency was enabled for this table.</dd> <dt><strong><strong>Read Concurrency</strong></strong></dt> <dd>If read_concurrency was enabled for this table.</dd> </dl> <h2 id="id84517">4.10 Timers</h2>  <p>This section contains information about all the timers started with the BIFs <code class="code">erlang:start_timer/3</code> and <code class="code">erlang:send_after/3</code>. The following fields exists for each timer:</p> <dl> <dt><strong><strong>=timer:&lt;owner&gt;</strong></strong></dt> <dd>Heading, states the owner of the timer (a process identifier) i.e. the process to receive the message when the timer expires.</dd> <dt><strong><strong>Message</strong></strong></dt> <dd>The message to be sent.</dd> <dt><strong><strong>Time left</strong></strong></dt> <dd>Number of milliseconds left until the message would have been sent.</dd> </dl> <h2 id="id84572">4.11 Distribution information</h2>  <p>If the Erlang node was alive, i.e., set up for communicating with other nodes, this section lists the connections that were active. The following fields can exist:</p> <dl> <dt><strong><strong>=node:&lt;node_name&gt;</strong></strong></dt> <dd>The name of the node</dd> <dt><strong><strong>no_distribution</strong></strong></dt> <dd>This will only occur if the node was not distributed.</dd> <dt><strong><strong>=visible_node:&lt;channel&gt;</strong></strong></dt> <dd>Heading for a visible nodes, i.e. an alive node with a connection to the node that crashed. States the channel number for the node.</dd> <dt><strong><strong>=hidden_node:&lt;channel&gt;</strong></strong></dt> <dd>Heading for a hidden node. A hidden node is the same as a visible node, except that it is started with the "-hidden" flag. States the channel number for the node.</dd> <dt><strong><strong>=not_connected:&lt;channel&gt;</strong></strong></dt> <dd>Heading for a node which is has been connected to the crashed node earlier. References (i.e. process or port identifiers) to the not connected node existed at the time of the crash. exist. States the channel number for the node.</dd> <dt><strong><strong>Name</strong></strong></dt> <dd>The name of the remote node.</dd> <dt><strong><strong>Controller</strong></strong></dt> <dd>The port which controls the communication with the remote node.</dd> <dt><strong><strong>Creation</strong></strong></dt> <dd>An integer (1-3) which together with the node name identifies a specific instance of the node.</dd> <dt><strong><strong>Remote monitoring: &lt;local_proc&gt; &lt;remote_proc&gt;</strong></strong></dt> <dd>The local process was monitoring the remote process at the time of the crash.</dd> <dt><strong><strong>Remotely monitored by: &lt;local_proc&gt; &lt;remote_proc&gt;</strong></strong></dt> <dd>The remote process was monitoring the local process at the time of the crash.</dd> <dt><strong><strong>Remote link: &lt;local_proc&gt; &lt;remote_proc&gt;</strong></strong></dt> <dd>A link existed between the local process and the remote process at the time of the crash.</dd> </dl> <h2 id="id84696">4.12 Loaded module information</h2>  <p>This section contains information about all loaded modules. First, the memory usage by loaded code is summarized. There is one field for "Current code" which is code that is the current latest version of the modules. There is also a field for "Old code" which is code where there exists a newer version in the system, but the old version is not yet purged. The memory usage is in bytes.</p> <p>All loaded modules are then listed. The following fields exist:</p> <dl> <dt><strong><strong>=mod:&lt;module_name&gt;</strong></strong></dt> <dd>Heading, and the name of the module.</dd> <dt><strong><strong>Current size</strong></strong></dt> <dd>Memory usage for the loaded code in bytes</dd> <dt><strong><strong>Old size</strong></strong></dt> <dd>Memory usage for the old code, if any.</dd> <dt><strong><strong>Current attributes</strong></strong></dt> <dd>Module attributes for the current code. This field is decoded when looked at by the Crashdump Viewer tool.</dd> <dt><strong><strong>Old attributes</strong></strong></dt> <dd>Module attributes for the old code, if any. This field is decoded when looked at by the Crashdump Viewer tool.</dd> <dt><strong><strong>Current compilation info</strong></strong></dt> <dd>Compilation information (options) for the current code. This field is decoded when looked at by the Crashdump Viewer tool.</dd> <dt><strong><strong>Old compilation info</strong></strong></dt> <dd>Compilation information (options) for the old code, if any. This field is decoded when looked at by the Crashdump Viewer tool.</dd> </dl> <h2 id="id84787">4.13 Fun information</h2>  <p>In this section, all funs are listed. The following fields exist for each fun:</p> <dl> <dt><strong><strong>=fun</strong></strong></dt> <dd>Heading</dd> <dt><strong><strong>Module</strong></strong></dt> <dd>The name of the module where the fun was defined.</dd> <dt><strong><strong>Uniq, Index</strong></strong></dt> <dd>Identifiers</dd> <dt><strong><strong>Address</strong></strong></dt> <dd>The address of the fun's code.</dd> <dt><strong><strong>Native_address</strong></strong></dt> <dd>The address of the fun's code when HiPE is enabled.</dd> <dt><strong><strong>Refc</strong></strong></dt> <dd>The number of references to the fun.</dd> </dl> <h2 id="id84859">4.14 Process Data</h2>  <p>For each process there will be at least one <strong>=proc_stack</strong> and one <strong>=proc_heap</strong> tag followed by the raw memory information for the stack and heap of the process.</p> <p>For each process there will also be a <strong>=proc_messages</strong> tag if the process' message queue is non-empty and a <strong>=proc_dictionary</strong> tag if the process' dictionary (the <code class="code">put/2</code> and <code class="code">get/1</code> thing) is non-empty.</p> <p>The raw memory information can be decoded by the Crashdump Viewer tool. You will then be able to see the stack dump, the message queue (if any) and the dictionary (if any).</p> <p>The stack dump is a dump of the Erlang process stack. Most of the live data (i.e., variables currently in use) are placed on the stack; thus this can be quite interesting. One has to "guess" what's what, but as the information is symbolic, thorough reading of this information can be very useful. As an example we can find the state variable of the Erlang primitive loader on line <code class="code">(5)</code> in the example below:</p> <div class="example"><pre>
(1)  3cac44   Return addr 0x13BF58 (&lt;terminate process normally&gt;)
(2)  y(0)     ["/view/siri_r10_dev/clearcase/otp/erts/lib/kernel/ebin","/view/siri_r10_dev/
(3)  clearcase/otp/erts/lib/stdlib/ebin"]
(4)  y(1)     &lt;0.1.0&gt;
(5)  y(2)     {state,[],none,#Fun&lt;erl_prim_loader.6.7085890&gt;,undefined,#Fun&lt;erl_prim_loader.7.9000327&gt;,#Fun&lt;erl_prim_loader.8.116480692&gt;,#Port&lt;0.2&gt;,infinity,#Fun&lt;erl_prim_loader.9.10708760&gt;}
(6)  y(3)     infinity    </pre></div> <p>When interpreting the data for a process, it is helpful to know that anonymous function objects (funs) are given a name constructed from the name of the function in which they are created, and a number (starting with 0) indicating the number of that fun within that function.</p> <h2 id="id84934">4.15 Atoms</h2>  <p>Now all the atoms in the system are written. This is only interesting if one suspects that dynamic generation of atoms could be a problem, otherwise this section can be ignored.</p> <p>Note that the last created atom is printed first.</p> <h2 id="id84951">4.16 Disclaimer</h2> <p>The format of the crash dump evolves between releases of OTP. Some information here may not apply to your version. A description as this will never be complete; it is meant as an explanation of the crash dump in general and as a help when trying to find application errors, not as a complete specification.</p>
<div class="_attribution">
  <p class="_attribution-p">
    © 1999–2016 Ericsson AB<br>Licensed under the Apache License, Version 2.0.<br>
    
  </p>
</div>

			</div>
		</div>
	</section>

	</div>
</body>
</html>
