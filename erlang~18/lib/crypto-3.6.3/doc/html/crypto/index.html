
<!DOCTYPE HTML>

<html lang="en">

<head>
  <meta charset="utf-8">
  <title>Crypto - Erlang 18 - W3cubDocs</title>
  
  <meta name="description" content=" crypto ">
  <meta name="keywords" content="crypto, -, erlang, erlang~18">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="http://docs.w3cub.com/erlang~18/lib/crypto-3.6.3/doc/html/crypto/">
  <link href="/favicon.png" rel="icon">
  <link type="text/css" rel="stylesheet" href="/assets/application-50364fff564ce3b6327021805f3f00e2957b441cf27f576a7dd4ff63bbc47047.css">
  <script type="text/javascript" src="/assets/application-db64bfd54ceb42be11af7995804cf4902548419ceb79d509b0b7d62c22d98e6f.js"></script>
  <script src="/json/erlang~18.js"></script>
  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-71174418-1']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>


</head>

<body>
	<div class="_app">
	<header class="_header">
  
  <form class="_search">
    <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
    <a class="_search-clear"></a>
    <div class="_search-tag"></div>
  </form>
  
  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/erlang~18/" class="_nav-link" title="" style="margin-left:0;">Erlang 18</a></span>
  
  <nav class="_nav">
    <a href="/app/" class="_nav-link ">App</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		<div class="_list">
			
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<div class="_page _erlang">
				
<h1>crypto</h1> <h2>Module</h2> <p class="REFBODY">crypto</p> <h2>Module summary</h2> <p class="REFBODY">Crypto Functions</p> <h2>Description</h2> 
<p>This module provides a set of cryptographic functions. </p> <ul> <li> <p>Hash functions - <code class="bold_code"><a href="http://csrc.nist.gov/publications/fips/fips180-4/fips-180-4.pdf" target="_blank"> Secure Hash Standard</a></code>, <code class="bold_code"><a href="http://www.ietf.org/rfc/rfc1321.txt" target="_blank"> The MD5 Message Digest Algorithm (RFC 1321)</a></code> and <code class="bold_code"><a href="http://www.ietf.org/rfc/rfc1320.txt" target="_blank">The MD4 Message Digest Algorithm (RFC 1320)</a></code> </p> </li> <li> <p>Hmac functions - <code class="bold_code"><a href="http://www.ietf.org/rfc/rfc2104.txt" target="_blank"> Keyed-Hashing for Message Authentication (RFC 2104) </a></code></p> </li> <li> <p>Block ciphers -  DES and AES in Block Cipher Modes - <code class="bold_code"><a href="http://csrc.nist.gov/groups/ST/toolkit/BCM/index.html" target="_blank"> ECB, CBC, CFB, OFB, CTR and GCM </a></code></p> </li> <li> <p><code class="bold_code"><a href="http://www.ietf.org/rfc/rfc1321.txt" target="_blank"> RSA encryption RFC 1321 </a></code> </p> </li> <li> <p>Digital signatures <code class="bold_code"><a href="http://csrc.nist.gov/publications/drafts/fips186-3/fips_186-3.pdf" target="_blank">Digital Signature Standard (DSS)</a></code> and<code class="bold_code"><a href="http://csrc.nist.gov/groups/STM/cavp/documents/dss2/ecdsa2vs.pdf" target="_blank"> Elliptic Curve Digital Signature Algorithm (ECDSA) </a></code> </p> </li> <li> <p><code class="bold_code"><a href="http://www.ietf.org/rfc/rfc2945.txt" target="_blank"> Secure Remote Password Protocol (SRP - RFC 2945) </a></code></p> </li> <li> <p>gcm: Dworkin, M., "Recommendation for Block Cipher Modes of Operation: Galois/Counter Mode (GCM) and GMAC", National Institute of Standards and Technology SP 800- 38D, November 2007.</p> </li> </ul>  <h2 id="id61539">Data types </h2>  <div class="example"><pre>key_value()  = integer() | binary() </pre></div> <p>Always <code class="code">binary()</code> when used as return value</p> <div class="example"><pre>rsa_public()  = [key_value()] = [E, N]  </pre></div> <p> Where E is the public exponent and N is public modulus. </p> <div class="example"><pre>rsa_private() = [key_value()] = [E, N, D] | [E, N, D, P1, P2, E1, E2, C] </pre></div> <p>Where E is the public exponent, N is public modulus and D is the private exponent.The longer key format contains redundant information that will make the calculation faster. P1,P2 are first and second prime factors. E1,E2 are first and second exponents. C is the CRT coefficient. Terminology is taken from <code class="bold_code"><a href="http://www.ietf.org/rfc/rfc3477.txt" target="_blank"> RFC 3447</a></code>.</p> <div class="example"><pre>dss_public() = [key_value()] = [P, Q, G, Y] </pre></div> <p>Where P, Q and G are the dss parameters and Y is the public key.</p> <div class="example"><pre>dss_private() =  [key_value()] = [P, Q, G, X] </pre></div> <p>Where P, Q and G are the dss parameters and X is the private key.</p> <div class="example"><pre>srp_public() = key_value() </pre></div> <p>Where is <code class="code">A</code> or <code class="code">B</code> from <code class="bold_code"><a href="http://srp.stanford.edu/design.html" target="_blank">SRP design</a></code></p> <div class="example"><pre>srp_private() = key_value() </pre></div> <p>Where is <code class="code">a</code> or <code class="code">b</code> from <code class="bold_code"><a href="http://srp.stanford.edu/design.html" target="_blank">SRP design</a></code></p> <p>Where Verifier is <code class="code">v</code>, Generator is <code class="code">g</code> and Prime is<code class="code">N</code>, DerivedKey is <code class="code">X</code>, and Scrambler is <code class="code">u</code> (optional will be generated if not provided) from <code class="bold_code"><a href="http://srp.stanford.edu/design.html" target="_blank">SRP design</a></code> Version = '3' | '6' | '6a' </p> <div class="example"><pre>dh_public() = key_value() </pre></div> <div class="example"><pre>dh_private() = key_value() </pre></div> <div class="example"><pre>dh_params() = [key_value()] = [P, G] </pre></div> <div class="example"><pre>ecdh_public() = key_value() </pre></div> <div class="example"><pre>ecdh_private() = key_value() </pre></div> <div class="example"><pre>ecdh_params() =  ec_named_curve() | ec_explicit_curve()</pre></div> <div class="example"><pre>ec_explicit_curve() =
    {ec_field(), Prime :: key_value(), Point :: key_value(), Order :: integer(), CoFactor :: none | integer()} </pre></div> <div class="example"><pre>ec_field() = {prime_field, Prime :: integer()} |
    {characteristic_two_field, M :: integer(), Basis :: ec_basis()}</pre></div> <div class="example"><pre>ec_basis() =  {tpbasis, K :: non_neg_integer()} |
    {ppbasis, K1 :: non_neg_integer(), K2 :: non_neg_integer(), K3 :: non_neg_integer()} |
    onbasis</pre></div> <div class="example"><pre>ec_named_curve() -&gt;
      sect571r1| sect571k1| sect409r1| sect409k1| secp521r1| secp384r1| secp224r1| secp224k1|
      secp192k1| secp160r2| secp128r2| secp128r1| sect233r1| sect233k1| sect193r2| sect193r1|
      sect131r2| sect131r1| sect283r1| sect283k1| sect163r2| secp256k1| secp160k1| secp160r1|
      secp112r2| secp112r1| sect113r2| sect113r1| sect239k1| sect163r1| sect163k1| secp256r1|
      secp192r1|
      brainpoolP160r1| brainpoolP160t1| brainpoolP192r1| brainpoolP192t1| brainpoolP224r1|
      brainpoolP224t1| brainpoolP256r1| brainpoolP256t1| brainpoolP320r1| brainpoolP320t1|
      brainpoolP384r1| brainpoolP384t1| brainpoolP512r1| brainpoolP512t1
    </pre></div> <p>Note that the <strong>sect</strong> curves are GF2m (characteristic two) curves and are only supported if the underlying OpenSSL has support for them. See also <code class="bold_code"><a href="#supports-0">crypto:supports/0</a></code> </p> <div class="example"><pre>stream_cipher() = rc4 | aes_ctr </pre></div> <div class="example"><pre>block_cipher() =  aes_cbc128 | aes_cfb8 | aes_cfb128 | aes_ige256 | blowfish_cbc |
     blowfish_cfb64 | des_cbc | des_cfb | des3_cbc | des3_cbf
     | des_ede3 | rc2_cbc </pre></div> <div class="example"><pre>aead_cipher() =  aes_gcm | chacha20_poly1305 </pre></div> <div class="example"><pre>stream_key() =  aes_key() | rc4_key() </pre></div> <div class="example"><pre>block_key() =  aes_key() |  blowfish_key() | des_key()| des3_key() </pre></div> <div class="example"><pre>aes_key() = iodata() </pre></div> <p>Key length is 128, 192 or 256 bits</p> <div class="example"><pre>rc4_key() = iodata() </pre></div> <p>Variable key length from 8 bits up to 2048 bits (usually between 40 and 256)</p> <div class="example"><pre>blowfish_key() = iodata() </pre></div> <p>Variable key length from 32 bits up to 448 bits</p> <div class="example"><pre>des_key() = iodata() </pre></div> <p>Key length is 64 bits (in CBC mode only 8 bits are used)</p> <div class="example"><pre>des3_key() = [binary(), binary(), binary()] </pre></div> <p>Each key part is 64 bits (in CBC mode only 8 bits are used)</p> <div class="example"><pre>digest_type() =  md5 | sha | sha224 | sha256 | sha384 | sha512</pre></div> <div class="example"><pre>hash_algorithms() =  md5 | ripemd160 | sha | sha224 | sha256 | sha384 | sha512 </pre></div> <p>md4 is also supported for hash_init/1 and hash/2. Note that both md4 and md5 are recommended only for compatibility with existing applications. </p> <div class="example"><pre>cipher_algorithms() = des_cbc | des_cfb |  des3_cbc | des3_cbf | des_ede3 |
    blowfish_cbc | blowfish_cfb64 | aes_cbc128 | aes_cfb8 | aes_cfb128| aes_cbc256 | aes_ige256 | aes_gcm | chacha20_poly1305 | rc2_cbc | aes_ctr| rc4  </pre></div> <div class="example"><pre>public_key_algorithms() =   rsa |dss | ecdsa | dh | ecdh | ec_gf2m</pre></div> <p>Note that ec_gf2m is not strictly a public key algorithm, but a restriction on what curves are supported with ecdsa and ecdh. </p>  <h2>Exports</h2> <h3 id="block_encrypt-3" class="code">block_encrypt(Type, Key, PlainText) -&gt; CipherText</h3>  <p>Types:</p>     <pre>Type = des_ecb | blowfish_ecb | aes_ecb
Key = block_key()
PlainText = iodata()</pre>

<p>Encrypt <code class="code">PlainText</code> according to <code class="code">Type</code> block cipher.</p> <p>May throw exception <code class="code">notsup</code> in case the chosen <code class="code">Type</code> is not supported by the underlying OpenSSL implementation.</p>  <h3 id="block_decrypt-3" class="code">block_decrypt(Type, Key, CipherText) -&gt; PlainText</h3>  <p>Types:</p>     <pre>Type = des_ecb | blowfish_ecb | aes_ecb
Key = block_key()
PlainText = iodata()</pre>

<p>Decrypt <code class="code">CipherText</code> according to <code class="code">Type</code> block cipher.</p> <p>May throw exception <code class="code">notsup</code> in case the chosen <code class="code">Type</code> is not supported by the underlying OpenSSL implementation.</p>  <h3 id="block_encrypt-4" class="code">block_encrypt(Type, Key, Ivec, PlainText) -&gt; CipherText<br>block_encrypt(AeadType, Key, Ivec, {AAD, PlainText}) -&gt; {CipherText, CipherTag}</h3>  <p>Types:</p>       <pre>Type = block_cipher()
AeadType = aead_cipher()
Key = block_key()
PlainText = iodata()
AAD = IVec = CipherText = CipherTag = binary()</pre>

<p>Encrypt <code class="code">PlainText</code> according to <code class="code">Type</code> block cipher. <code class="code">IVec</code> is an arbitrary initializing vector.</p> <p>In AEAD (Authenticated Encryption with Associated Data) mode, encrypt <code class="code">PlainText</code>according to <code class="code">Type</code> block cipher and calculate <code class="code">CipherTag</code> that also authenticates the <code class="code">AAD</code> (Associated Authenticated Data).</p> <p>May throw exception <code class="code">notsup</code> in case the chosen <code class="code">Type</code> is not supported by the underlying OpenSSL implementation.</p>  <h3 id="block_decrypt-4" class="code">block_decrypt(Type, Key, Ivec, CipherText) -&gt; PlainText<br>block_decrypt(AeadType, Key, Ivec, {AAD, CipherText, CipherTag}) -&gt; PlainText | error</h3>  <p>Types:</p>       <pre>Type = block_cipher()
AeadType = aead_cipher()
Key = block_key()
PlainText = iodata()
AAD = IVec = CipherText = CipherTag = binary()</pre>

<p>Decrypt <code class="code">CipherText</code> according to <code class="code">Type</code> block cipher. <code class="code">IVec</code> is an arbitrary initializing vector.</p> <p>In AEAD (Authenticated Encryption with Associated Data) mode, decrypt <code class="code">CipherText</code>according to <code class="code">Type</code> block cipher and check the authenticity the <code class="code">PlainText</code> and <code class="code">AAD</code> (Associated Authenticated Data) using the <code class="code">CipherTag</code>. May return <code class="code">error</code> if the decryption or validation fail's</p> <p>May throw exception <code class="code">notsup</code> in case the chosen <code class="code">Type</code> is not supported by the underlying OpenSSL implementation.</p>  <h3 id="bytes_to_integer-1" class="code">bytes_to_integer(Bin) -&gt; Integer</h3>  <p>Types:</p>    <pre>Bin = binary() - as returned by crypto functions
Integer = integer()</pre>

<p>Convert binary representation, of an integer, to an Erlang integer. </p>  <h3 id="compute_key-4" class="code">compute_key(Type, OthersPublicKey, MyKey, Params) -&gt; SharedSecret</h3>  <p>Types:</p>         <pre>Type = dh | ecdh | srp
OthersPublicKey = dh_public() | ecdh_public() | srp_public()
MyKey = dh_private() | ecdh_private() | {srp_public(),srp_private()}
Params = dh_params() | ecdh_params() | SrpUserParams | SrpHostParams
SrpUserParams = {user, [DerivedKey::binary(), Prime::binary(), Generator::binary(), Version::atom() | [Scrambler:binary()]]}
SrpHostParams = {host, [Verifier::binary(), Prime::binary(), Version::atom() | [Scrambler::binary]]}
SharedSecret = binary()</pre>

<p>Computes the shared secret from the private key and the other party's public key. See also <code class="bold_code">public_key:compute_key/2</code> </p>  <h3 id="exor-2" class="code">exor(Data1, Data2) -&gt; Result</h3>  <p>Types:</p>    <pre>Data1, Data2 = iodata()
Result = binary()</pre>

<p>Performs bit-wise XOR (exclusive or) on the data supplied.</p>  <h3 id="generate_key-3" class="code">generate_key(Type, Params) -&gt; {PublicKey, PrivKeyOut}<br>generate_key(Type, Params, PrivKeyIn) -&gt; {PublicKey, PrivKeyOut}</h3>  <p>Types:</p>         <pre>Type = dh | ecdh | srp
Params = dh_params() | ecdh_params() | SrpUserParams | SrpHostParams
SrpUserParams = {user, [Generator::binary(), Prime::binary(), Version::atom()]}
SrpHostParams = {host, [Verifier::binary(), Generator::binary(), Prime::binary(), Version::atom()]}
PublicKey = dh_public() | ecdh_public() | srp_public()
PrivKeyIn = undefined | dh_private() | ecdh_private() | srp_private()
PrivKeyOut = dh_private() | ecdh_private() | srp_private()</pre>

<p>Generates public keys of type <code class="code">Type</code>. See also <code class="bold_code">public_key:generate_key/1</code> </p>  <h3 id="hash-2" class="code">hash(Type, Data) -&gt; Digest</h3>  <p>Types:</p>     <pre>Type = md4 | hash_algorithms()
Data = iodata()
Digest = binary()</pre>

<p>Computes a message digest of type <code class="code">Type</code> from <code class="code">Data</code>.</p> <p>May throw exception <code class="code">notsup</code> in case the chosen <code class="code">Type</code> is not supported by the underlying OpenSSL implementation.</p>  <h3 id="hash_init-1" class="code">hash_init(Type) -&gt; Context</h3>  <p>Types:</p>   <pre>Type = md4 | hash_algorithms()</pre>

<p>Initializes the context for streaming hash operations. <code class="code">Type</code> determines which digest to use. The returned context should be used as argument to <code class="bold_code"><a href="#hash_update-2">hash_update</a></code>.</p> <p>May throw exception <code class="code">notsup</code> in case the chosen <code class="code">Type</code> is not supported by the underlying OpenSSL implementation.</p>  <h3 id="hash_update-2" class="code">hash_update(Context, Data) -&gt; NewContext</h3>  <p>Types:</p>   <pre>Data = iodata()</pre>

<p>Updates the digest represented by <code class="code">Context</code> using the given <code class="code">Data</code>. <code class="code">Context</code> must have been generated using <code class="bold_code"><a href="#hash_init-1">hash_init</a></code> or a previous call to this function. <code class="code">Data</code> can be any length. <code class="code">NewContext</code> must be passed into the next call to <code class="code">hash_update</code> or <code class="bold_code"><a href="#hash_final-1">hash_final</a></code>.</p>  <h3 id="hash_final-1" class="code">hash_final(Context) -&gt; Digest</h3>  <p>Types:</p>   <pre>Digest = binary()</pre>

<p>Finalizes the hash operation referenced by <code class="code">Context</code> returned from a previous call to <code class="bold_code"><a href="#hash_update-2">hash_update</a></code>. The size of <code class="code">Digest</code> is determined by the type of hash function used to generate it.</p>  <h3 id="hmac-4" class="code">hmac(Type, Key, Data) -&gt; Mac<br>hmac(Type, Key, Data, MacLength) -&gt; Mac</h3>  <p>Types:</p>       <pre>Type = hash_algorithms() - except ripemd160
Key = iodata()
Data = iodata()
MacLength = integer()
Mac = binary()</pre>

<p>Computes a HMAC of type <code class="code">Type</code> from <code class="code">Data</code> using <code class="code">Key</code> as the authentication key.</p> <p><code class="code">MacLength</code> will limit the size of the resultant <code class="code">Mac</code>.</p>  <h3 id="hmac_init-2" class="code">hmac_init(Type, Key) -&gt; Context</h3>  <p>Types:</p>     <pre>Type = hash_algorithms() - except ripemd160
Key = iodata()
Context = binary()</pre>

<p>Initializes the context for streaming HMAC operations. <code class="code">Type</code> determines which hash function to use in the HMAC operation. <code class="code">Key</code> is the authentication key. The key can be any length.</p>  <h3 id="hmac_update-2" class="code">hmac_update(Context, Data) -&gt; NewContext</h3>  <p>Types:</p>    <pre>Context = NewContext = binary()
Data = iodata()</pre>

<p>Updates the HMAC represented by <code class="code">Context</code> using the given <code class="code">Data</code>. <code class="code">Context</code> must have been generated using an HMAC init function (such as <code class="bold_code"><a href="#hmac_init-2">hmac_init</a></code>). <code class="code">Data</code> can be any length. <code class="code">NewContext</code> must be passed into the next call to <code class="code">hmac_update</code> or to one of the functions <code class="bold_code"><a href="#hmac_final-1">hmac_final</a></code> and <code class="bold_code"><a href="#hmac_final_n-2">hmac_final_n</a></code> </p> <div class="warning"> <div class="label">Warning</div> <div class="content">

<p>Do not use a <code class="code">Context</code> as argument in more than one call to hmac_update or hmac_final. The semantics of reusing old contexts in any way is undefined and could even crash the VM in earlier releases. The reason for this limitation is a lack of support in the underlying OpenSSL API.</p>
</div> </div>  <h3 id="hmac_final-1" class="code">hmac_final(Context) -&gt; Mac</h3>  <p>Types:</p>   <pre>Context = Mac = binary()</pre>

<p>Finalizes the HMAC operation referenced by <code class="code">Context</code>. The size of the resultant MAC is determined by the type of hash function used to generate it.</p>  <h3 id="hmac_final_n-2" class="code">hmac_final_n(Context, HashLen) -&gt; Mac</h3>  <p>Types:</p>    <pre>Context = Mac = binary()
HashLen = non_neg_integer()</pre>

<p>Finalizes the HMAC operation referenced by <code class="code">Context</code>. <code class="code">HashLen</code> must be greater than zero. <code class="code">Mac</code> will be a binary with at most <code class="code">HashLen</code> bytes. Note that if HashLen is greater than the actual number of bytes returned from the underlying hash, the returned hash will have fewer than <code class="code">HashLen</code> bytes.</p>  <h3 id="info_lib-0" class="code">info_lib() -&gt; [{Name,VerNum,VerStr}]</h3>  <p>Types:</p>     <pre>Name = binary()
VerNum = integer()
VerStr = binary()</pre>

<p>Provides the name and version of the libraries used by crypto.</p> <p><code class="code">Name</code> is the name of the library. <code class="code">VerNum</code> is the numeric version according to the library's own versioning scheme. <code class="code">VerStr</code> contains a text variant of the version.</p> <div class="example"><pre>
&gt; info_lib().
[{&lt;&lt;"OpenSSL"&gt;&gt;,9469983,&lt;&lt;"OpenSSL 0.9.8a 11 Oct 2005"&gt;&gt;}]
        </pre></div> <div class="note"> <div class="label">Note</div> <div class="content">

<p> From OTP R16 the <strong>numeric version</strong> represents the version of the OpenSSL <strong>header files</strong> (<code class="code">openssl/opensslv.h</code>) used when crypto was compiled. The text variant represents the OpenSSL library used at runtime. In earlier OTP versions both numeric and text was taken from the library. </p>
</div> </div>  <h3 id="mod_pow-3" class="code">mod_pow(N, P, M) -&gt; Result</h3>  <p>Types:</p>    <pre>N, P, M = binary() | integer()
Result = binary() | error</pre>

<p>Computes the function <code class="code">N^P mod M</code>.</p>  <h3 id="next_iv-3" class="code">next_iv(Type, Data) -&gt; NextIVec<br>next_iv(Type, Data, IVec) -&gt; NextIVec</h3>  <p>Types:</p>     <pre>Type = des_cbc | des3_cbc | aes_cbc | des_cfb
Data = iodata()
IVec = NextIVec = binary()</pre>

<p>Returns the initialization vector to be used in the next iteration of encrypt/decrypt of type <code class="code">Type</code>. <code class="code">Data</code> is the encrypted data from the previous iteration step. The <code class="code">IVec</code> argument is only needed for <code class="code">des_cfb</code> as the vector used in the previous iteration step.</p>  <h3 id="private_decrypt-4" class="code">private_decrypt(Type, CipherText, PrivateKey, Padding) -&gt; PlainText</h3>  <p>Types:</p>       <pre>Type = rsa
CipherText = binary()
PrivateKey = rsa_private()
Padding = rsa_pkcs1_padding | rsa_pkcs1_oaep_padding | rsa_no_padding
PlainText = binary()</pre>

<p>Decrypts the <code class="code">CipherText</code>, encrypted with <code class="bold_code"><a href="#public_encrypt-4">public_encrypt/4</a></code> (or equivalent function) using the <code class="code">PrivateKey</code>, and returns the plaintext (message digest). This is a low level signature verification operation used for instance by older versions of the SSL protocol. See also <code class="bold_code">public_key:decrypt_private/[2,3]</code> </p>  <h3 id="private_encrypt-4" class="code">private_encrypt(Type, PlainText, PrivateKey, Padding) -&gt; CipherText</h3>  <p>Types:</p>    The size of the <pre>Type = rsa
PlainText = binary()</pre>
<code class="code">PlainText</code> must be less than <code class="code">byte_size(N)-11</code> if <code class="code">rsa_pkcs1_padding</code> is used, and <code class="code">byte_size(N)</code> if <code class="code">rsa_no_padding</code> is used, where N is public modulus of the RSA key.     <pre>PrivateKey = rsa_private()
Padding = rsa_pkcs1_padding | rsa_no_padding
CipherText = binary()</pre>

<p>Encrypts the <code class="code">PlainText</code> using the <code class="code">PrivateKey</code> and returns the ciphertext. This is a low level signature operation used for instance by older versions of the SSL protocol. See also <code class="bold_code">public_key:encrypt_private/[2,3]</code> </p>  <h3 id="public_decrypt-4" class="code">public_decrypt(Type, CipherText, PublicKey, Padding) -&gt; PlainText</h3>  <p>Types:</p>       <pre>Type = rsa
CipherText = binary()
PublicKey = rsa_public()
Padding = rsa_pkcs1_padding | rsa_no_padding
PlainText = binary()</pre>

<p>Decrypts the <code class="code">CipherText</code>, encrypted with <code class="bold_code"><a href="#private_encrypt-4">private_encrypt/4</a></code>(or equivalent function) using the <code class="code">PrivateKey</code>, and returns the plaintext (message digest). This is a low level signature verification operation used for instance by older versions of the SSL protocol. See also <code class="bold_code">public_key:decrypt_public/[2,3]</code> </p>  <h3 id="public_encrypt-4" class="code">public_encrypt(Type, PlainText, PublicKey, Padding) -&gt; CipherText</h3>  <p>Types:</p>    The size of the <pre>Type = rsa
PlainText = binary()</pre>
<code class="code">PlainText</code> must be less than <code class="code">byte_size(N)-11</code> if <code class="code">rsa_pkcs1_padding</code> is used, and <code class="code">byte_size(N)</code> if <code class="code">rsa_no_padding</code> is used, where N is public modulus of the RSA key.     <pre>PublicKey = rsa_public()
Padding = rsa_pkcs1_padding | rsa_pkcs1_oaep_padding | rsa_no_padding
CipherText = binary()</pre>

<p>Encrypts the <code class="code">PlainText</code> (message digest) using the <code class="code">PublicKey</code> and returns the <code class="code">CipherText</code>. This is a low level signature operation used for instance by older versions of the SSL protocol. See also <code class="bold_code">public_key:encrypt_public/[2,3]</code> </p>  <h3 id="rand_bytes-1" class="code">rand_bytes(N) -&gt; binary()</h3>  <p>Types:</p>   <pre>N = integer()</pre>

<p>Generates N bytes randomly uniform 0..255, and returns the result in a binary. Uses the <code class="code">crypto</code> library pseudo-random number generator.</p> <p>This function is not recommended for cryptographic purposes. Please use <code class="bold_code"><a href="#strong_rand_bytes-1"> strong_rand_bytes/1</a></code> instead.</p>  <h3 id="rand_seed-1" class="code">rand_seed(Seed) -&gt; ok</h3>  <p>Types:</p>   <pre>Seed = binary()</pre>

<p>Set the seed for PRNG to the given binary. This calls the RAND_seed function from openssl. Only use this if the system you are running on does not have enough "randomness" built in. Normally this is when <code class="bold_code"><a href="#strong_rand_bytes-1"> strong_rand_bytes/1</a></code> returns <code class="code">low_entropy</code></p>  <h3 id="rand_uniform-2" class="code">rand_uniform(Lo, Hi) -&gt; N</h3>  <p>Types:</p>   <pre>Lo, Hi, N = integer()</pre>

<p>Generate a random number <code class="code">N, Lo =&lt; N &lt; Hi.</code> Uses the <code class="code">crypto</code> library pseudo-random number generator. <code class="code">Hi</code> must be larger than <code class="code">Lo</code>.</p>  <h3 id="sign-4" class="code">sign(Algorithm, DigestType, Msg, Key) -&gt; binary()</h3>  <p>Types:</p>   <pre>Algorithm = rsa | dss | ecdsa
Msg = binary() | {digest,binary()}</pre>
<p class="REFBODY">The msg is either the binary "cleartext" data to be signed or it is the hashed value of "cleartext" i.e. the digest (plaintext).</p>    <pre>DigestType = digest_type()
Key = rsa_private() | dss_private() | [ecdh_private(),ecdh_params()]</pre>

<p>Creates a digital signature.</p> <p>Algorithm <code class="code">dss</code> can only be used together with digest type <code class="code">sha</code>.</p> <p>See also <code class="bold_code">public_key:sign/3</code>.</p>  <h3 id="start-0" class="code">start() -&gt; ok</h3> 
<p> Equivalent to application:start(crypto).</p>  <h3 id="stop-0" class="code">stop() -&gt; ok</h3> 
<p> Equivalent to application:stop(crypto).</p>  <h3 id="strong_rand_bytes-1" class="code">strong_rand_bytes(N) -&gt; binary()</h3>  <p>Types:</p>   <pre>N = integer()</pre>

<p>Generates N bytes randomly uniform 0..255, and returns the result in a binary. Uses a cryptographically secure prng seeded and periodically mixed with operating system provided entropy. By default this is the <code class="code">RAND_bytes</code> method from OpenSSL.</p> <p>May throw exception <code class="code">low_entropy</code> in case the random generator failed due to lack of secure "randomness".</p>  <h3 id="stream_init-2" class="code">stream_init(Type, Key) -&gt; State</h3>  <p>Types:</p>     <pre>Type = rc4
State = opaque()
Key = iodata()</pre>

<p>Initializes the state for use in RC4 stream encryption <code class="bold_code"><a href="#stream_encrypt-2">stream_encrypt</a></code> and <code class="bold_code"><a href="#stream_decrypt-2">stream_decrypt</a></code></p>  <h3 id="stream_init-3" class="code">stream_init(Type, Key, IVec) -&gt; State</h3>  <p>Types:</p>      <pre>Type = aes_ctr
State = opaque()
Key = iodata()
IVec = binary()</pre>

<p>Initializes the state for use in streaming AES encryption using Counter mode (CTR). <code class="code">Key</code> is the AES key and must be either 128, 192, or 256 bits long. <code class="code">IVec</code> is an arbitrary initializing vector of 128 bits (16 bytes). This state is for use with <code class="bold_code"><a href="#stream_encrypt-2">stream_encrypt</a></code> and <code class="bold_code"><a href="#stream_decrypt-2">stream_decrypt</a></code>.</p>  <h3 id="stream_encrypt-2" class="code">stream_encrypt(State, PlainText) -&gt; { NewState, CipherText}</h3>  <p>Types:</p>    <pre>Text = iodata()
CipherText = binary()</pre>

<p>Encrypts <code class="code">PlainText</code> according to the stream cipher <code class="code">Type</code> specified in stream_init/3. <code class="code">Text</code> can be any number of bytes. The initial <code class="code">State</code> is created using <code class="bold_code"><a href="#stream_init-2">stream_init</a></code>. <code class="code">NewState</code> must be passed into the next call to <code class="code">stream_encrypt</code>.</p>  <h3 id="stream_decrypt-2" class="code">stream_decrypt(State, CipherText) -&gt; { NewState, PlainText }</h3>  <p>Types:</p>    <pre>CipherText = iodata()
PlainText = binary()</pre>

<p>Decrypts <code class="code">CipherText</code> according to the stream cipher <code class="code">Type</code> specified in stream_init/3. <code class="code">PlainText</code> can be any number of bytes. The initial <code class="code">State</code> is created using <code class="bold_code"><a href="#stream_init-2">stream_init</a></code>. <code class="code">NewState</code> must be passed into the next call to <code class="code">stream_decrypt</code>.</p>  <h3 id="supports-0" class="code">supports() -&gt; AlgorithmList</h3>  <p>Types:</p>   <pre>AlgorithmList = [{hashs, [hash_algorithms()]}, {ciphers, [cipher_algorithms()]}, {public_keys, [public_key_algorithms()]}</pre>

<p> Can be used to determine which crypto algorithms that are supported by the underlying OpenSSL library</p>  <h3 id="ec_curves-0" class="code">ec_curves() -&gt; EllipticCurveList</h3>  <p>Types:</p>   <pre>EllipticCurveList = [ec_named_curve()]</pre>

<p>Can be used to determine which named elliptic curves are supported.</p>  <h3 id="ec_curve-1" class="code">ec_curve(NamedCurve) -&gt; EllipticCurve</h3>  <p>Types:</p>    <pre>NamedCurve = ec_named_curve()
EllipticCurve = ec_explicit_curve()</pre>

<p>Return the defining parameters of a elliptic curve.</p>  <h3 id="verify-5" class="code">verify(Algorithm, DigestType, Msg, Signature, Key) -&gt; boolean()</h3>  <p>Types:</p>   <pre>Algorithm = rsa | dss | ecdsa
Msg = binary() | {digest,binary()}</pre>
<p class="REFBODY">The msg is either the binary "cleartext" data or it is the hashed value of "cleartext" i.e. the digest (plaintext).</p>     <pre>DigestType = digest_type()
Signature = binary()
Key = rsa_public() | dss_public() | [ecdh_public(),ecdh_params()]</pre>

<p>Verifies a digital signature</p> <p>Algorithm <code class="code">dss</code> can only be used together with digest type <code class="code">sha</code>.</p> <p>See also <code class="bold_code">public_key:verify/4</code>.</p>
<div class="_attribution">
  <p class="_attribution-p">
    © 1999–2016 Ericsson AB<br>Licensed under the Apache License, Version 2.0.<br>
    
  </p>
</div>

			</div>
		</div>
	</section>

	</div>
</body>
</html>
