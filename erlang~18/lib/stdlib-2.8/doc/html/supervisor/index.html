
<!DOCTYPE HTML>

<html lang="en">

<head>
  <meta charset="utf-8">
  <title>Supervisor - Erlang 18 - W3cubDocs</title>
  
  <meta name="description" content=" supervisor ">
  <meta name="keywords" content="supervisor, -, erlang, erlang~18">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="http://docs.w3cub.com/erlang~18/lib/stdlib-2.8/doc/html/supervisor/">
  <link href="/favicon.png" rel="icon">
  <link type="text/css" rel="stylesheet" href="/assets/application-50364fff564ce3b6327021805f3f00e2957b441cf27f576a7dd4ff63bbc47047.css">
  <script type="text/javascript" src="/assets/application-db64bfd54ceb42be11af7995804cf4902548419ceb79d509b0b7d62c22d98e6f.js"></script>
  <script src="/json/erlang~18.js"></script>
  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-71174418-1']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>


</head>

<body>
	<div class="_app">
	<header class="_header">
  
  <form class="_search">
    <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
    <a class="_search-clear"></a>
    <div class="_search-tag"></div>
  </form>
  
  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/erlang~18/" class="_nav-link" title="" style="margin-left:0;">Erlang 18</a></span>
  
  <nav class="_nav">
    <a href="/app/" class="_nav-link ">App</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		<div class="_list">
			
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<div class="_page _erlang">
				
<h1>supervisor</h1> <h2>Module</h2> <p class="REFBODY">supervisor</p> <h2>Module summary</h2> <p class="REFBODY">Generic Supervisor Behaviour</p> <h2>Description</h2> 
<p>A behaviour module for implementing a supervisor, a process which supervises other processes called child processes. A child process can either be another supervisor or a worker process. Worker processes are normally implemented using one of the <code class="code">gen_event</code>, <code class="code">gen_fsm</code>, or <code class="code">gen_server</code> behaviours. A supervisor implemented using this module will have a standard set of interface functions and include functionality for tracing and error reporting. Supervisors are used to build a hierarchical process structure called a supervision tree, a nice way to structure a fault tolerant application. Refer to <strong>OTP Design Principles</strong> for more information.</p> <p>A supervisor expects the definition of which child processes to supervise to be specified in a callback module exporting a pre-defined set of functions.</p> <p>Unless otherwise stated, all functions in this module will fail if the specified supervisor does not exist or if bad arguments are given.</p>  <h2 id="id243029">Supervision Principles</h2>  <p>The supervisor is responsible for starting, stopping and monitoring its child processes. The basic idea of a supervisor is that it shall keep its child processes alive by restarting them when necessary.</p> <p>The children of a supervisor are defined as a list of <strong>child specifications</strong>. When the supervisor is started, the child processes are started in order from left to right according to this list. When the supervisor terminates, it first terminates its child processes in reversed start order, from right to left.</p>  <p>The properties of a supervisor are defined by the supervisor flags. This is the type definition for the supervisor flags: </p> <div class="example"><pre>sup_flags() = #{strategy =&gt; strategy(),         % optional
                intensity =&gt; non_neg_integer(), % optional
                period =&gt; pos_integer()}        % optional
      </pre></div> <p>A supervisor can have one of the following <strong>restart strategies</strong>, specified with the <code class="code">strategy</code> key in the above map: </p> <ul> <li> <p><code class="code">one_for_one</code> - if one child process terminates and should be restarted, only that child process is affected. This is the default restart strategy.</p> </li> <li> <p><code class="code">one_for_all</code> - if one child process terminates and should be restarted, all other child processes are terminated and then all child processes are restarted.</p> </li> <li> <p><code class="code">rest_for_one</code> - if one child process terminates and should be restarted, the 'rest' of the child processes -- i.e. the child processes after the terminated child process in the start order -- are terminated. Then the terminated child process and all child processes after it are restarted.</p> </li> <li> <p><code class="code">simple_one_for_one</code> - a simplified <code class="code">one_for_one</code> supervisor, where all child processes are dynamically added instances of the same process type, i.e. running the same code.</p> <p>The functions <code class="code">delete_child/2</code> and <code class="code">restart_child/2</code> are invalid for <code class="code">simple_one_for_one</code> supervisors and will return <code class="code">{error,simple_one_for_one}</code> if the specified supervisor uses this restart strategy.</p> <p>The function <code class="code">terminate_child/2</code> can be used for children under <code class="code">simple_one_for_one</code> supervisors by giving the child's <code class="code">pid()</code> as the second argument. If instead the child specification identifier is used, <code class="code">terminate_child/2</code> will return <code class="code">{error,simple_one_for_one}</code>.</p> <p>Because a <code class="code">simple_one_for_one</code> supervisor could have many children, it shuts them all down asynchronously. This means that the children will do their cleanup in parallel, and therefore the order in which they are stopped is not defined.</p> </li> </ul> <p>To prevent a supervisor from getting into an infinite loop of child process terminations and restarts, a <strong>maximum restart intensity</strong> is defined using two integer values specified with the <code class="code">intensity</code> and <code class="code">period</code> keys in the above map. Assuming the values <code class="code">MaxR</code> for <code class="code">intensity</code> and <code class="code">MaxT</code> for <code class="code">period</code>, then if more than <code class="code">MaxR</code> restarts occur within <code class="code">MaxT</code> seconds, the supervisor will terminate all child processes and then itself. The default value for <code class="code">intensity</code> is <code class="code">1</code>, and the default value for <code class="code">period</code> is <code class="code">5</code>. </p>  <p>This is the type definition of a child specification:</p> <div class="example"><pre>child_spec() = #{id =&gt; child_id(),       % mandatory
                 start =&gt; mfargs(),      % mandatory
                 restart =&gt; restart(),   % optional
                 shutdown =&gt; shutdown(), % optional
                 type =&gt; worker(),       % optional
                 modules =&gt; modules()}   % optional</pre></div> <p>The old tuple format is kept for backwards compatibility, see <code class="bold_code"><a href="#type-child_spec">child_spec()</a></code>, but the map is preferred. </p> <ul> <li> <p><code class="code">id</code> is used to identify the child specification internally by the supervisor.</p> <p>The <code class="code">id</code> key is mandatory.</p> <p>Note that this identifier on occations has been called "name". As far as possible, the terms "identifier" or "id" are now used but in order to keep backwards compatibility, some occurences of "name" can still be found, for example in error messages.</p> </li> <li> <p><code class="code">start</code> defines the function call used to start the child process. It must be a module-function-arguments tuple <code class="code">{M,F,A}</code> used as <code class="code">apply(M,F,A)</code>.</p> <p>The start function <strong>must create and link to</strong> the child process, and must return <code class="code">{ok,Child}</code> or <code class="code">{ok,Child,Info}</code> where <code class="code">Child</code> is the pid of the child process and <code class="code">Info</code> an arbitrary term which is ignored by the supervisor.</p> <p>The start function can also return <code class="code">ignore</code> if the child process for some reason cannot be started, in which case the child specification will be kept by the supervisor (unless it is a temporary child) but the non-existing child process will be ignored.</p> <p>If something goes wrong, the function may also return an error tuple <code class="code">{error,Error}</code>.</p> <p>Note that the <code class="code">start_link</code> functions of the different behaviour modules fulfill the above requirements.</p> <p>The <code class="code">start</code> key is mandatory.</p> </li> <li> <p><code class="code">restart</code> defines when a terminated child process shall be restarted. A <code class="code">permanent</code> child process will always be restarted, a <code class="code">temporary</code> child process will never be restarted (even when the supervisor's restart strategy is <code class="code">rest_for_one</code> or <code class="code">one_for_all</code> and a sibling's death causes the temporary process to be terminated) and a <code class="code">transient</code> child process will be restarted only if it terminates abnormally, i.e. with another exit reason than <code class="code">normal</code>, <code class="code">shutdown</code> or <code class="code">{shutdown,Term}</code>.</p> <p>The <code class="code">restart</code> key is optional. If it is not given, the default value <code class="code">permanent</code> will be used.</p> </li> <li> <p><code class="code">shutdown</code> defines how a child process shall be terminated. <code class="code">brutal_kill</code> means the child process will be unconditionally terminated using <code class="code">exit(Child,kill)</code>. An integer timeout value means that the supervisor will tell the child process to terminate by calling <code class="code">exit(Child,shutdown)</code> and then wait for an exit signal with reason <code class="code">shutdown</code> back from the child process. If no exit signal is received within the specified number of milliseconds, the child process is unconditionally terminated using <code class="code">exit(Child,kill)</code>.</p> <p>If the child process is another supervisor, the shutdown time should be set to <code class="code">infinity</code> to give the subtree ample time to shut down. It is also allowed to set it to <code class="code">infinity</code>, if the child process is a worker.</p> <div class="warning"> <div class="label">Warning</div> <div class="content">

<p>Be careful when setting the shutdown time to <code class="code">infinity</code> when the child process is a worker. Because, in this situation, the termination of the supervision tree depends on the child process, it must be implemented in a safe way and its cleanup procedure must always return.</p> </div> </div> <p>Note that all child processes implemented using the standard OTP behaviour modules automatically adhere to the shutdown protocol.</p> <p>The <code class="code">shutdown</code> key is optional. If it is not given, the default value <code class="code">5000</code> will be used if the child is of type <code class="code">worker</code>; and <code class="code">infinity</code> will be used if the child is of type <code class="code">supervisor</code>.</p> </li> <li> <p><code class="code">type</code> specifies if the child process is a supervisor or a worker.</p> <p>The <code class="code">type</code> key is optional. If it is not given, the default value <code class="code">worker</code> will be used.</p> </li> <li> <p><code class="code">modules</code> is used by the release handler during code replacement to determine which processes are using a certain module. As a rule of thumb, if the child process is a <code class="code">supervisor</code>, <code class="code">gen_server</code>, or <code class="code">gen_fsm</code>, this should be a list with one element <code class="code">[Module]</code>, where <code class="code">Module</code> is the callback module. If the child process is an event manager (<code class="code">gen_event</code>) with a dynamic set of callback modules, the value <code class="code">dynamic</code> shall be used. See <strong>OTP Design Principles</strong> for more information about release handling.</p> <p>The <code class="code">modules</code> key is optional. If it is not given, it defaults to <code class="code">[M]</code>, where <code class="code">M</code> comes from the child's start <code class="code">{M,F,A}</code></p> </li> <li> <p>Internally, the supervisor also keeps track of the pid <code class="code">Child</code> of the child process, or <code class="code">undefined</code> if no pid exists.</p> </li> </ul>  <h2>Data types</h2> <h3 class="code">child() = undefined | pid()</h3> <h3 class="code">child_id() = term()</h3> 
<p>Not a <code class="code">pid()</code>.</p> <h3 class="code">child_spec() = <br>    #{id =&gt; <a href="#type-child_id">child_id()</a>,<br>      start =&gt; <a href="#type-mfargs">mfargs()</a>,<br>      restart =&gt; <a href="#type-restart">restart()</a>,<br>      shutdown =&gt; <a href="#type-shutdown">shutdown()</a>,<br>      type =&gt; <a href="#type-worker">worker()</a>,<br>      modules =&gt; <a href="#type-modules">modules()</a>} |<br>    {Id :: <a href="#type-child_id">child_id()</a>,<br>     StartFunc :: <a href="#type-mfargs">mfargs()</a>,<br>     Restart :: <a href="#type-restart">restart()</a>,<br>     Shutdown :: <a href="#type-shutdown">shutdown()</a>,<br>     Type :: <a href="#type-worker">worker()</a>,<br>     Modules :: <a href="#type-modules">modules()</a>}</h3> 
<p>The tuple format is kept for backwards compatibility only. A map is preferred; see more details <code class="bold_code"><a href="#child_spec">above</a></code>.</p> <h3 class="code">mfargs() = <br>    {M :: module(), F :: atom(), A :: [term()] | undefined}</h3> 
<p>The value <code class="code">undefined</code> for <code class="code">A</code> (the argument list) is only to be used internally in <code class="code">supervisor</code>. If the restart type of the child is <code class="code">temporary</code>, then the process is never to be restarted and therefore there is no need to store the real argument list. The value <code class="code">undefined</code> will then be stored instead.</p>  <h3 class="code">modules() = [module()] | dynamic</h3> <h3 class="code">restart() = permanent | transient | temporary</h3> <h3 class="code">shutdown() = brutal_kill | timeout()</h3> <h3 class="code">strategy() = <br>    one_for_all | one_for_one | rest_for_one | simple_one_for_one</h3> <h3 class="code">sup_flags() = <br>    #{strategy =&gt; <a href="#type-strategy">strategy()</a>,<br>      intensity =&gt; integer() &gt;= 0,<br>      period =&gt; integer() &gt;= 1} |<br>    {RestartStrategy :: <a href="#type-strategy">strategy()</a>,<br>     Intensity :: integer() &gt;= 0,<br>     Period :: integer() &gt;= 1}</h3> 
<p>The tuple format is kept for backwards compatibility only. A map is preferred; see more details <code class="bold_code"><a href="#sup_flags">above</a></code>.</p> <h3 class="code">sup_ref() = <br>    (Name :: atom()) |<br>    {Name :: atom(), Node :: node()} |<br>    {global, Name :: atom()} |<br>    {via, Module :: module(), Name :: any()} |<br>    pid()</h3> <h3 class="code">worker() = worker | supervisor</h3> <h2>Exports</h2> <h3 id="start_link-3" class="code">start_link(Module, Args) -&gt; startlink_ret()<br>start_link(SupName, Module, Args) -&gt; startlink_ret()</h3> <p>Types:</p>        <pre>SupName = sup_name()
Module = module()
Args = term()
startlink_ret() = 
    {ok, pid()} | ignore | {error, startlink_err()}
startlink_err() = 
    {already_started, pid()} | {shutdown, term()} | term()
sup_name() = 
    {local, Name :: atom()} |
    {global, Name :: atom()} |
    {via, Module :: module(), Name :: any()}</pre>

<p>Creates a supervisor process as part of a supervision tree. The function will, among other things, ensure that the supervisor is linked to the calling process (its supervisor).</p> <p>The created supervisor process calls <code class="code">Module:init/1</code> to find out about restart strategy, maximum restart intensity and child processes. To ensure a synchronized start-up procedure, <code class="code">start_link/2,3</code> does not return until <code class="code">Module:init/1</code> has returned and all child processes have been started.</p> <p>If <code class="code">SupName={local,Name}</code>, the supervisor is registered locally as <code class="code">Name</code> using <code class="code">register/2</code>. If <code class="code">SupName={global,Name}</code> the supervisor is registered globally as <code class="code">Name</code> using <code class="code">global:register_name/2</code>. If <code class="code">SupName={via,Module,Name}</code> the supervisor is registered as <code class="code">Name</code> using the registry represented by <code class="code">Module</code>. The <code class="code">Module</code> callback must export the functions <code class="code">register_name/2</code>, <code class="code">unregister_name/1</code> and <code class="code">send/2</code>, which shall behave like the corresponding functions in <code class="code">global</code>. Thus, <code class="code">{via,global,Name}</code> is a valid reference.</p> <p>If no name is provided, the supervisor is not registered.</p> <p><code class="code">Module</code> is the name of the callback module.</p> <p><code class="code">Args</code> is an arbitrary term which is passed as the argument to <code class="code">Module:init/1</code>.</p> <p>If the supervisor and its child processes are successfully created (i.e. if all child process start functions return <code class="code">{ok,Child}</code>, <code class="code">{ok,Child,Info}</code>, or <code class="code">ignore</code>), the function returns <code class="code">{ok,Pid}</code>, where <code class="code">Pid</code> is the pid of the supervisor. If there already exists a process with the specified <code class="code">SupName</code>, the function returns <code class="code">{error,{already_started,Pid}}</code>, where <code class="code">Pid</code> is the pid of that process.</p> <p>If <code class="code">Module:init/1</code> returns <code class="code">ignore</code>, this function returns <code class="code">ignore</code> as well, and the supervisor terminates with reason <code class="code">normal</code>. If <code class="code">Module:init/1</code> fails or returns an incorrect value, this function returns <code class="code">{error,Term}</code> where <code class="code">Term</code> is a term with information about the error, and the supervisor terminates with reason <code class="code">Term</code>.</p> <p>If any child process start function fails or returns an error tuple or an erroneous value, the supervisor will first terminate all already started child processes with reason <code class="code">shutdown</code> and then terminate itself and return <code class="code">{error, {shutdown, Reason}}</code>.</p>  <h3 id="start_child-2" class="code">start_child(SupRef, ChildSpec) -&gt; startchild_ret()</h3> <p>Types:</p>      <pre>SupRef = <a href="#type-sup_ref">sup_ref()</a>
ChildSpec = <a href="#type-child_spec">child_spec()</a> | (List :: [term()])
startchild_ret() = 
    {ok, Child :: <a href="#type-child">child()</a>} |
    {ok, Child :: <a href="#type-child">child()</a>, Info :: term()} |
    {error, startchild_err()}
startchild_err() = 
    already_present | {already_started, Child :: <a href="#type-child">child()</a>} | term()</pre>

<p>Dynamically adds a child specification to the supervisor <code class="code">SupRef</code> which starts the corresponding child process.</p> <p id="SupRef"><code class="code">SupRef</code> can be:</p> <ul> <li>the pid,</li> <li> <code class="code">Name</code>, if the supervisor is locally registered,</li> <li> <code class="code">{Name,Node}</code>, if the supervisor is locally registered at another node, or</li> <li> <code class="code">{global,Name}</code>, if the supervisor is globally registered.</li> <li> <code class="code">{via,Module,Name}</code>, if the supervisor is registered through an alternative process registry.</li> </ul> <p><code class="code">ChildSpec</code> must be a valid child specification (unless the supervisor is a <code class="code">simple_one_for_one</code> supervisor; see below). The child process will be started by using the start function as defined in the child specification.</p> <p>In the case of a <code class="code">simple_one_for_one</code> supervisor, the child specification defined in <code class="code">Module:init/1</code> will be used, and <code class="code">ChildSpec</code> shall instead be an arbitrary list of terms <code class="code">List</code>. The child process will then be started by appending <code class="code">List</code> to the existing start function arguments, i.e. by calling <code class="code">apply(M, F, A++List)</code> where <code class="code">{M,F,A}</code> is the start function defined in the child specification.</p> <p>If there already exists a child specification with the specified identifier, <code class="code">ChildSpec</code> is discarded, and the function returns <code class="code">{error,already_present}</code> or <code class="code">{error,{already_started,Child}}</code>, depending on if the corresponding child process is running or not.</p> <p>If the child process start function returns <code class="code">{ok,Child}</code> or <code class="code">{ok,Child,Info}</code>, the child specification and pid are added to the supervisor and the function returns the same value.</p> <p>If the child process start function returns <code class="code">ignore</code>, the child specification is added to the supervisor (unless the supervisor is a <code class="code">simple_one_for_one</code> supervisor, see below), the pid is set to <code class="code">undefined</code> and the function returns <code class="code">{ok,undefined}</code>. </p> <p>In the case of a <code class="code">simple_one_for_one</code> supervisor, when a child process start function returns <code class="code">ignore</code> the functions returns <code class="code">{ok,undefined}</code> and no child is added to the supervisor. </p> <p>If the child process start function returns an error tuple or an erroneous value, or if it fails, the child specification is discarded, and the function returns <code class="code">{error,Error}</code> where <code class="code">Error</code> is a term containing information about the error and child specification.</p>  <h3 id="terminate_child-2" class="code">terminate_child(SupRef, Id) -&gt; Result</h3> <p>Types:</p>      <pre>SupRef = <a href="#type-sup_ref">sup_ref()</a>
Id = pid() | <a href="#type-child_id">child_id()</a>
Result = ok | {error, Error}
Error = not_found | simple_one_for_one</pre>

<p>Tells the supervisor <code class="code">SupRef</code> to terminate the given child.</p> <p>If the supervisor is not <code class="code">simple_one_for_one</code>, <code class="code">Id</code> must be the child specification identifier. The process, if there is one, is terminated and, unless it is a temporary child, the child specification is kept by the supervisor. The child process may later be restarted by the supervisor. The child process can also be restarted explicitly by calling <code class="code">restart_child/2</code>. Use <code class="code">delete_child/2</code> to remove the child specification.</p> <p>If the child is temporary, the child specification is deleted as soon as the process terminates. This means that <code class="code">delete_child/2</code> has no meaning, and <code class="code">restart_child/2</code> can not be used for these children.</p> <p>If the supervisor is <code class="code">simple_one_for_one</code>, <code class="code">Id</code> must be the child process' <code class="code">pid()</code>. If the specified process is alive, but is not a child of the given supervisor, the function will return <code class="code">{error,not_found}</code>. If the child specification identifier is given instead of a <code class="code">pid()</code>, the function will return <code class="code">{error,simple_one_for_one}</code>.</p> <p>If successful, the function returns <code class="code">ok</code>. If there is no child specification with the specified <code class="code">Id</code>, the function returns <code class="code">{error,not_found}</code>.</p> <p>See <code class="bold_code"><a href="#SupRef"><span class="code">start_child/2</span></a></code> for a description of <code class="code">SupRef</code>.</p>  <h3 id="delete_child-2" class="code">delete_child(SupRef, Id) -&gt; Result</h3> <p>Types:</p>      <pre>SupRef = <a href="#type-sup_ref">sup_ref()</a>
Id = <a href="#type-child_id">child_id()</a>
Result = ok | {error, Error}
Error = running | restarting | not_found | simple_one_for_one</pre>

<p>Tells the supervisor <code class="code">SupRef</code> to delete the child specification identified by <code class="code">Id</code>. The corresponding child process must not be running. Use <code class="code">terminate_child/2</code> to terminate it.</p> <p>See <code class="bold_code"><a href="#SupRef"><span class="code">start_child/2</span></a></code> for a description of <code class="code">SupRef</code>.</p> <p>If successful, the function returns <code class="code">ok</code>. If the child specification identified by <code class="code">Id</code> exists but the corresponding child process is running or about to be restarted, the function returns <code class="code">{error,running}</code> or <code class="code">{error,restarting}</code>, respectively. If the child specification identified by <code class="code">Id</code> does not exist, the function returns <code class="code">{error,not_found}</code>.</p>  <h3 id="restart_child-2" class="code">restart_child(SupRef, Id) -&gt; Result</h3> <p>Types:</p>      <pre>SupRef = <a href="#type-sup_ref">sup_ref()</a>
Id = <a href="#type-child_id">child_id()</a>
Result = 
    {ok, Child :: <a href="#type-child">child()</a>} |
    {ok, Child :: <a href="#type-child">child()</a>, Info :: term()} |
    {error, Error}
Error = 
    running | restarting | not_found | simple_one_for_one | term()</pre>

<p>Tells the supervisor <code class="code">SupRef</code> to restart a child process corresponding to the child specification identified by <code class="code">Id</code>. The child specification must exist, and the corresponding child process must not be running.</p> <p>Note that for temporary children, the child specification is automatically deleted when the child terminates; thus it is not possible to restart such children.</p> <p>See <code class="bold_code"><a href="#SupRef"><span class="code">start_child/2</span></a></code> for a description of <code class="code">SupRef</code>.</p> <p>If the child specification identified by <code class="code">Id</code> does not exist, the function returns <code class="code">{error,not_found}</code>. If the child specification exists but the corresponding process is already running, the function returns <code class="code">{error,running}</code>.</p> <p>If the child process start function returns <code class="code">{ok,Child}</code> or <code class="code">{ok,Child,Info}</code>, the pid is added to the supervisor and the function returns the same value.</p> <p>If the child process start function returns <code class="code">ignore</code>, the pid remains set to <code class="code">undefined</code>, and the function returns <code class="code">{ok,undefined}</code>.</p> <p>If the child process start function returns an error tuple or an erroneous value, or if it fails, the function returns <code class="code">{error,Error}</code> where <code class="code">Error</code> is a term containing information about the error.</p>  <h3 id="which_children-1" class="code">which_children(SupRef) -&gt; [{Id, Child, Type, Modules}]</h3> <p>Types:</p>       <pre>SupRef = <a href="#type-sup_ref">sup_ref()</a>
Id = <a href="#type-child_id">child_id()</a> | undefined
Child = <a href="#type-child">child()</a> | restarting
Type = <a href="#type-worker">worker()</a>
Modules = <a href="#type-modules">modules()</a></pre>

<p>Returns a newly created list with information about all child specifications and child processes belonging to the supervisor <code class="code">SupRef</code>.</p> <p>Note that calling this function when supervising a large number of children under low memory conditions can cause an out of memory exception.</p> <p>See <code class="bold_code"><a href="#SupRef"><span class="code">start_child/2</span></a></code> for a description of <code class="code">SupRef</code>.</p> <p>The information given for each child specification/process is:</p> <ul> <li> <p><code class="code">Id</code> - as defined in the child specification or <code class="code">undefined</code> in the case of a <code class="code">simple_one_for_one</code> supervisor.</p> </li> <li> <p><code class="code">Child</code> - the pid of the corresponding child process, the atom <code class="code">restarting</code> if the process is about to be restarted, or <code class="code">undefined</code> if there is no such process.</p> </li> <li> <p><code class="code">Type</code> - as defined in the child specification.</p> </li> <li> <p><code class="code">Modules</code> - as defined in the child specification.</p> </li> </ul>  <h3 id="count_children-1" class="code">count_children(SupRef) -&gt; PropListOfCounts</h3> <p>Types:</p>     <pre>SupRef = <a href="#type-sup_ref">sup_ref()</a>
PropListOfCounts = [Count]
Count = 
    {specs, ChildSpecCount :: integer() &gt;= 0} |
    {active, ActiveProcessCount :: integer() &gt;= 0} |
    {supervisors, ChildSupervisorCount :: integer() &gt;= 0} |
    {workers, ChildWorkerCount :: integer() &gt;= 0}</pre>

<p>Returns a property list (see <code class="code">proplists</code>) containing the counts for each of the following elements of the supervisor's child specifications and managed processes:</p> <ul> <li> <p><code class="code">specs</code> - the total count of children, dead or alive.</p> </li> <li> <p><code class="code">active</code> - the count of all actively running child processes managed by this supervisor. In the case of <code class="code">simple_one_for_one</code> supervisors, no check is carried out to ensure that each child process is still alive, though the result provided here is likely to be very accurate unless the supervisor is heavily overloaded.</p> </li> <li> <p><code class="code">supervisors</code> - the count of all children marked as child_type = supervisor in the spec list, whether or not the child process is still alive.</p> </li> <li> <p><code class="code">workers</code> - the count of all children marked as child_type = worker in the spec list, whether or not the child process is still alive.</p> </li> </ul> <p>See <code class="bold_code"><a href="#SupRef"><span class="code">start_child/2</span></a></code> for a description of <code class="code">SupRef</code>.</p>  <h3 id="check_childspecs-1" class="code">check_childspecs(ChildSpecs) -&gt; Result</h3> <p>Types:</p>    <pre>ChildSpecs = [<a href="#type-child_spec">child_spec()</a>]
Result = ok | {error, Error :: term()}</pre>

<p>This function takes a list of child specification as argument and returns <code class="code">ok</code> if all of them are syntactically correct, or <code class="code">{error,Error}</code> otherwise.</p>  <h3 id="get_childspec-2" class="code">get_childspec(SupRef, Id) -&gt; Result</h3> <p>Types:</p>      <pre>SupRef = <a href="#type-sup_ref">sup_ref()</a>
Id = pid() | <a href="#type-child_id">child_id()</a>
Result = {ok, <a href="#type-child_spec">child_spec()</a>} | {error, Error}
Error = not_found</pre>

<p>Returns the child specification map for the child identified by <code class="code">Id</code> under supervisor <code class="code">SupRef</code>. The returned map contains all keys, both mandatory and optional.</p> <p>See <code class="bold_code"><a href="#SupRef"><span class="code">start_child/2</span></a></code> for a description of <code class="code">SupRef</code>.</p>  <h2 id="id244890">Callback functions</h2>  <p>The following functions must be exported from a <code class="code">supervisor</code> callback module.</p>  <h2>Exports</h2> <h3 id="Module:init-1" class="code">Module:init(Args) -&gt; Result</h3>  <p>Types:</p>      <pre>Args = term()
Result = {ok,{SupFlags,[ChildSpec]}} | ignore
 SupFlags = <a href="#type-sup_flags">sup_flags()</a>
 ChildSpec = <a href="#type-child_spec">child_spec()</a></pre>

<p>Whenever a supervisor is started using <code class="code">supervisor:start_link/2,3</code>, this function is called by the new process to find out about restart strategy, maximum restart intensity, and child specifications.</p> <p><code class="code">Args</code> is the <code class="code">Args</code> argument provided to the start function.</p> <p><code class="code">SupFlags</code> is the supervisor flags defining the restart strategy and max restart intensity for the supervisor. <code class="code">[ChildSpec]</code> is a list of valid child specifications defining which child processes the supervisor shall start and monitor. See the discussion about Supervision Principles above.</p> <p>Note that when the restart strategy is <code class="code">simple_one_for_one</code>, the list of child specifications must be a list with one child specification only. (The child specification identifier is ignored.) No child process is then started during the initialization phase, but all children are assumed to be started dynamically using <code class="code">supervisor:start_child/2</code>.</p> <p>The function may also return <code class="code">ignore</code>.</p> <p>Note that this function might also be called as a part of a code upgrade procedure. For this reason, the function should not have any side effects. See <code class="bold_code">Design Principles</code> for more information about code upgrade of supervisors.</p>  <h2 id="id245017">See also</h2>  <p><code class="bold_code"><a href="../gen_event/">gen_event(3)</a></code>, <code class="bold_code"><a href="../gen_fsm/">gen_fsm(3)</a></code>, <code class="bold_code"><a href="../gen_server/">gen_server(3)</a></code>, <code class="bold_code"><a href="../sys/">sys(3)</a></code></p>
<div class="_attribution">
  <p class="_attribution-p">
    © 1999–2016 Ericsson AB<br>Licensed under the Apache License, Version 2.0.<br>
    
  </p>
</div>

			</div>
		</div>
	</section>

	</div>
</body>
</html>
