
<!DOCTYPE HTML>

<html lang="en">

<head>
  <meta charset="utf-8">
  <title>Sofs - Erlang 18 - W3cubDocs</title>
  
  <meta name="description" content=" sofs ">
  <meta name="keywords" content="sofs, -, erlang, erlang~18">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="http://docs.w3cub.com/erlang~18/lib/stdlib-2.8/doc/html/sofs/">
  <link href="/favicon.png" rel="icon">
  <link type="text/css" rel="stylesheet" href="/assets/application-50364fff564ce3b6327021805f3f00e2957b441cf27f576a7dd4ff63bbc47047.css">
  <script type="text/javascript" src="/assets/application-db64bfd54ceb42be11af7995804cf4902548419ceb79d509b0b7d62c22d98e6f.js"></script>
  <script src="/json/erlang~18.js"></script>
  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-71174418-1']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>


</head>

<body>
	<div class="_app">
	<header class="_header">
  
  <form class="_search">
    <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
    <a class="_search-clear"></a>
    <div class="_search-tag"></div>
  </form>
  
  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/erlang~18/" class="_nav-link" title="" style="margin-left:0;">Erlang 18</a></span>
  
  <nav class="_nav">
    <a href="/app/" class="_nav-link ">App</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		<div class="_list">
			
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<div class="_page _erlang">
				
<h1>sofs</h1> <h2>Module</h2> <p class="REFBODY">sofs</p> <h2>Module summary</h2> <p class="REFBODY">Functions for Manipulating Sets of Sets</p> <h2>Description</h2> 
<p>The <code class="code">sofs</code> module implements operations on finite sets and relations represented as sets. Intuitively, a set is a collection of elements; every element belongs to the set, and the set contains every element.</p> <p>Given a set A and a sentence S(x), where x is a free variable, a new set B whose elements are exactly those elements of A for which S(x) holds can be formed, this is denoted B = {x in A : S(x)}. Sentences are expressed using the logical operators "for some" (or "there exists"), "for all", "and", "or", "not". If the existence of a set containing all the specified elements is known (as will always be the case in this module), we write B = {x : S(x)}. </p> <p>The <strong>unordered set</strong> containing the elements a, b and c is denoted {a, b, c}. This notation is not to be confused with tuples. The <strong>ordered pair</strong> of a and b, with first <strong>coordinate</strong> a and second coordinate b, is denoted (a, b). An ordered pair is an <strong>ordered set</strong> of two elements. In this module ordered sets can contain one, two or more elements, and parentheses are used to enclose the elements. Unordered sets and ordered sets are orthogonal, again in this module; there is no unordered set equal to any ordered set.</p> <p id="intersection_n">The set that contains no elements is called the <strong>empty set</strong>. If two sets A and B contain the same elements, then A is <strong>equal</strong> to B, denoted A = B. Two ordered sets are equal if they contain the same number of elements and have equal elements at each coordinate. If a set A contains all elements that B contains, then B is a <strong>subset</strong> of A. The <strong>union</strong> of two sets A and B is the smallest set that contains all elements of A and all elements of B. The <strong>intersection</strong> of two sets A and B is the set that contains all elements of A that belong to B. Two sets are <strong>disjoint</strong> if their intersection is the empty set. The <strong>difference</strong> of two sets A and B is the set that contains all elements of A that do not belong to B. The <strong>symmetric difference</strong> of two sets is the set that contains those element that belong to either of the two sets, but not both. The <strong>union</strong> of a collection of sets is the smallest set that contains all the elements that belong to at least one set of the collection. The <strong>intersection</strong> of a non-empty collection of sets is the set that contains all elements that belong to every set of the collection.</p> <p id="weak_relation">The <strong>Cartesian product</strong> of two sets X and Y, denoted X × Y, is the set {a : a = (x, y) for some x in X and for some y in Y}. A <strong>relation</strong> is a subset of X × Y. Let R be a relation. The fact that (x, y) belongs to R is written as x R y. Since relations are sets, the definitions of the last paragraph (subset, union, and so on) apply to relations as well. The <strong>domain</strong> of R is the set {x : x R y for some y in Y}. The <strong>range</strong> of R is the set {y : x R y for some x in X}. The <strong>converse</strong> of R is the set {a : a = (y, x) for some (x, y) in R}. If A is a subset of X, then the <strong>image</strong> of A under R is the set {y : x R y for some x in A}, and if B is a subset of Y, then the <strong>inverse image</strong> of B is the set {x : x R y for some y in B}. If R is a relation from X to Y and S is a relation from Y to Z, then the <strong>relative product</strong> of R and S is the relation T from X to Z defined so that x T z if and only if there exists an element y in Y such that x R y and y S z. The <strong>restriction</strong> of R to A is the set S defined so that x S y if and only if there exists an element x in A such that x R y. If S is a restriction of R to A, then R is an <strong>extension</strong> of S to X. If X = Y then we call R a relation <strong>in</strong> X. The <strong>field</strong> of a relation R in X is the union of the domain of R and the range of R. If R is a relation in X, and if S is defined so that x S y if x R y and not x = y, then S is the <strong>strict</strong> relation corresponding to R, and vice versa, if S is a relation in X, and if R is defined so that x R y if x S y or x = y, then R is the <strong>weak</strong> relation corresponding to S. A relation R in X is <strong>reflexive</strong> if x R x for every element x of X; it is <strong>symmetric</strong> if x R y implies that y R x; and it is <strong>transitive</strong> if x R y and y R z imply that x R z.</p> <p id="composite">A <strong>function</strong> F is a relation, a subset of X × Y, such that the domain of F is equal to X and such that for every x in X there is a unique element y in Y with (x, y) in F. The latter condition can be formulated as follows: if x F y and x F z then y = z. In this module, it will not be required that the domain of F be equal to X for a relation to be considered a function. Instead of writing (x, y) in F or x F y, we write F(x) = y when F is a function, and say that F maps x onto y, or that the value of F at x is y. Since functions are relations, the definitions of the last paragraph (domain, range, and so on) apply to functions as well. If the converse of a function F is a function F', then F' is called the <strong>inverse</strong> of F. The relative product of two functions F1 and F2 is called the <strong>composite</strong> of F1 and F2 if the range of F1 is a subset of the domain of F2. </p> <p id="family">Sometimes, when the range of a function is more important than the function itself, the function is called a <strong>family</strong>. The domain of a family is called the <strong>index set</strong>, and the range is called the <strong>indexed set</strong>. If x is a family from I to X, then x[i] denotes the value of the function at index i. The notation "a family in X" is used for such a family. When the indexed set is a set of subsets of a set X, then we call x a <strong>family of subsets</strong> of X. If x is a family of subsets of X, then the union of the range of x is called the <strong>union of the family</strong> x. If x is non-empty (the index set is non-empty), the <strong>intersection of the family</strong> x is the intersection of the range of x. In this module, the only families that will be considered are families of subsets of some set X; in the following the word "family" will be used for such families of subsets.</p> <p id="canonical_map">A <strong>partition</strong> of a set X is a collection S of non-empty subsets of X whose union is X and whose elements are pairwise disjoint. A relation in a set is an <strong>equivalence relation</strong> if it is reflexive, symmetric and transitive. If R is an equivalence relation in X, and x is an element of X, the <strong>equivalence class</strong> of x with respect to R is the set of all those elements y of X for which x R y holds. The equivalence classes constitute a partitioning of X. Conversely, if C is a partition of X, then the relation that holds for any two elements of X if they belong to the same equivalence class, is an equivalence relation induced by the partition C. If R is an equivalence relation in X, then the <strong>canonical map</strong> is the function that maps every element of X onto its equivalence class. </p> <p id="natural_join">Relations as defined above (as sets of ordered pairs) will from now on be referred to as <strong>binary relations</strong>. We call a set of ordered sets (x[1], ..., x[n]) an  <strong>(n-ary) relation</strong>, and say that the relation is a subset of the Cartesian product X[1] × ... × X[n] where x[i] is an element of X[i], 1 &lt;= i &lt;= n. The <strong>projection</strong> of an n-ary relation R onto coordinate i is the set {x[i] : (x[1], ..., x[i], ..., x[n]) in R for some x[j] in X[j], 1 &lt;= j &lt;= n and not i = j}. The projections of a binary relation R onto the first and second coordinates are the domain and the range of R respectively. The relative product of binary relations can be generalized to n-ary relations as follows. Let TR be an ordered set (R[1], ..., R[n]) of binary relations from X to Y[i] and S a binary relation from (Y[1] × ... × Y[n]) to Z. The <strong>relative product</strong> of TR and S is the binary relation T from X to Z defined so that x T z if and only if there exists an element y[i] in Y[i] for each 1 &lt;= i &lt;= n such that x R[i] y[i] and (y[1], ..., y[n]) S z. Now let TR be a an ordered set (R[1], ..., R[n]) of binary relations from X[i] to Y[i] and S a subset of X[1] × ... × X[n]. The <strong>multiple relative product</strong> of TR and S is defined to be the set {z : z = ((x[1], ..., x[n]), (y[1],...,y[n])) for some (x[1], ..., x[n]) in S and for some (x[i], y[i]) in R[i], 1 &lt;= i &lt;= n}. The <strong>natural join</strong> of an n-ary relation R and an m-ary relation S on coordinate i and j is defined to be the set {z : z = (x[1], ..., x[n], y[1], ..., y[j-1], y[j+1], ..., y[m]) for some (x[1], ..., x[n]) in R and for some (y[1], ..., y[m]) in S such that x[i] = y[j]}.</p> <p id="sets_definition">The sets recognized by this module will be represented by elements of the relation Sets, defined as the smallest set such that:</p> <ul> <li>for every atom T except '_' and for every term X, (T, X) belongs to Sets (<strong>atomic sets</strong>); </li> <li>(['_'], []) belongs to Sets (the <strong>untyped empty set</strong>); </li> <li>for every tuple T = {T[1], ..., T[n]} and for every tuple X = {X[1], ..., X[n]}, if (T[i], X[i]) belongs to Sets for every 1 &lt;= i &lt;= n then (T, X) belongs to Sets (<strong>ordered sets</strong>); </li> <li>for every term T, if X is the empty list or a non-empty sorted list [X[1], ..., X[n]] without duplicates such that (T, X[i]) belongs to Sets for every 1 &lt;= i &lt;= n, then ([T], X) belongs to Sets (<strong>typed unordered sets</strong>).</li> </ul> <p id="valid_type">An <strong>external set</strong> is an element of the range of Sets. A <strong>type</strong> is an element of the domain of Sets. If S is an element (T, X) of Sets, then T is a <strong>valid type</strong> of X, T is the type of S, and X is the external set of S. <code class="bold_code"><a href="#from_term">from_term/2</a></code> creates a set from a type and an Erlang term turned into an external set.</p> <p>The actual sets represented by Sets are the elements of the range of the function Set from Sets to Erlang terms and sets of Erlang terms:</p> <ul> <li>Set(T,Term) = Term, where T is an atom;</li> <li>Set({T[1], ..., T[n]}, {X[1], ..., X[n]}) = (Set(T[1], X[1]), ..., Set(T[n], X[n]));</li> <li>Set([T], [X[1], ..., X[n]]) = {Set(T, X[1]), ..., Set(T, X[n])};</li> <li>Set([T], []) = {}.</li> </ul> <p>When there is no risk of confusion, elements of Sets will be identified with the sets they represent. For instance, if U is the result of calling <code class="code">union/2</code> with S1 and S2 as arguments, then U is said to be the union of S1 and S2. A more precise formulation would be that Set(U) is the union of Set(S1) and Set(S2).</p> <p>The types are used to implement the various conditions that sets need to fulfill. As an example, consider the relative product of two sets R and S, and recall that the relative product of R and S is defined if R is a binary relation to Y and S is a binary relation from Y. The function that implements the relative product, <code class="bold_code"><a href="#relprod_impl">relative_product/2</a></code>, checks that the arguments represent binary relations by matching [{A,B}] against the type of the first argument (Arg1 say), and [{C,D}] against the type of the second argument (Arg2 say). The fact that [{A,B}] matches the type of Arg1 is to be interpreted as Arg1 representing a binary relation from X to Y, where X is defined as all sets Set(x) for some element x in Sets the type of which is A, and similarly for Y. In the same way Arg2 is interpreted as representing a binary relation from W to Z. Finally it is checked that B matches C, which is sufficient to ensure that W is equal to Y. The untyped empty set is handled separately: its type, ['_'], matches the type of any unordered set.</p> <p id="set_fun">A few functions of this module (<code class="code">drestriction/3</code>, <code class="code">family_projection/2</code>, <code class="code">partition/2</code>, <code class="code">partition_family/2</code>, <code class="code">projection/2</code>, <code class="code">restriction/3</code>, <code class="code">substitution/2</code>) accept an Erlang function as a means to modify each element of a given unordered set. Such a function, called SetFun in the following, can be specified as a functional object (fun), a tuple <code class="code">{external, Fun}</code>, or an integer. If SetFun is specified as a fun, the fun is applied to each element of the given set and the return value is assumed to be a set. If SetFun is specified as a tuple <code class="code">{external, Fun}</code>, Fun is applied to the external set of each element of the given set and the return value is assumed to be an external set. Selecting the elements of an unordered set as external sets and assembling a new unordered set from a list of external sets is in the present implementation more efficient than modifying each element as a set. However, this optimization can only be utilized when the elements of the unordered set are atomic or ordered sets. It must also be the case that the type of the elements matches some clause of Fun (the type of the created set is the result of applying Fun to the type of the given set), and that Fun does nothing but selecting, duplicating or rearranging parts of the elements. Specifying a SetFun as an integer I is equivalent to specifying <code class="code">{external, fun(X) -&gt; element(I, X) end}</code>, but is to be preferred since it makes it possible to handle this case even more efficiently. Examples of SetFuns:</p> <div class="example"><pre>
fun sofs:union/1
fun(S) -&gt; sofs:partition(1, S) end
{external, fun(A) -&gt; A end}
{external, fun({A,_,C}) -&gt; {C,A} end}
{external, fun({_,{_,C}}) -&gt; C end}
{external, fun({_,{_,{_,E}=C}}) -&gt; {E,{E,C}} end}
2</pre></div> <p>The order in which a SetFun is applied to the elements of an unordered set is not specified, and may change in future versions of sofs.</p> <p>The execution time of the functions of this module is dominated by the time it takes to sort lists. When no sorting is needed, the execution time is in the worst case proportional to the sum of the sizes of the input arguments and the returned value. A few functions execute in constant time: <code class="code">from_external</code>, <code class="code">is_empty_set</code>, <code class="code">is_set</code>, <code class="code">is_sofs_set</code>, <code class="code">to_external</code>, <code class="code">type</code>.</p> <p>The functions of this module exit the process with a <code class="code">badarg</code>, <code class="code">bad_function</code>, or <code class="code">type_mismatch</code> message when given badly formed arguments or sets the types of which are not compatible.</p> <p>When comparing external sets the operator <code class="code">==/2</code> is used.</p>  <h2>Data types</h2> <h3 class="code">anyset() = <a href="#type-ordset">ordset()</a> | <a href="#type-a_set">a_set()</a>
</h3> 
<p>Any kind of set (also included are the atomic sets).</p> <h3 class="code">binary_relation() = <a href="#type-relation">relation()</a>
</h3> 
<p>A <code class="bold_code"><a href="#binary_relation">binary relation</a></code>.</p> <h3 class="code">external_set() = term()</h3> 
<p>An <code class="bold_code"><a href="#external_set">external set</a></code>.</p> <h3 class="code">family() = <a href="#type-a_function">a_function()</a>
</h3> 
<p>A <code class="bold_code"><a href="#family">family</a></code> (of subsets).</p>  <h3 class="code">a_function() = <a href="#type-relation">relation()</a>
</h3> 
<p>A <code class="bold_code"><a href="#function">function</a></code>.</p> <h3 class="code">ordset()</h3> 
<p>An <code class="bold_code"><a href="#sets_definition">ordered set</a></code>.</p> <h3 class="code">relation() = <a href="#type-a_set">a_set()</a>
</h3> 
<p>An <code class="bold_code"><a href="#n_ary_relation">n-ary relation</a></code>. </p> <h3 class="code">a_set()</h3> 
<p>An <code class="bold_code"><a href="#sets_definition">unordered set</a></code>.</p> <h3 class="code">set_of_sets() = <a href="#type-a_set">a_set()</a>
</h3> 
<p>An <code class="bold_code"><a href="#sets_definition">unordered set</a></code> of unordered sets.</p> <h3 class="code">set_fun() = <br>    integer() &gt;= 1 |<br>    {external, fun((<a href="#type-external_set">external_set()</a>) -&gt; <a href="#type-external_set">external_set()</a>)} |<br>    fun((<a href="#type-anyset">anyset()</a>) -&gt; <a href="#type-anyset">anyset()</a>)</h3> 
<p>A <code class="bold_code"><a href="#set_fun">SetFun</a></code>.</p> <h3 class="code">spec_fun() = <br>    {external, fun((<a href="#type-external_set">external_set()</a>) -&gt; boolean())} |<br>    fun((<a href="#type-anyset">anyset()</a>) -&gt; boolean())</h3> <h3 class="code">type() = term()</h3> 
<p>A <code class="bold_code"><a href="#type">type</a></code>.</p> <p><code class="bold_code">tuple_of(T)</code></p> 
<p id="type-tuple_of"> A tuple where the elements are of type <code class="code">T</code>.</p> <h2>Exports</h2> <h3 id="a_function-2" class="code">a_function(Tuples) -&gt; Function<br>a_function(Tuples, Type) -&gt; Function</h3> <p>Types:</p>     <pre>Function = <a href="#type-a_function">a_function()</a>
Tuples = [tuple()]
Type = <a href="#type-type">type()</a></pre>

<p>Creates a <code class="bold_code"><a href="#function">function</a></code>. <code class="code">a_function(F, T)</code> is equivalent to <code class="code">from_term(F, T)</code>, if the result is a function. If no <code class="bold_code"><a href="#type">type</a></code> is explicitly given, <code class="code">[{atom, atom}]</code> is used as type of the function.</p>  <h3 id="canonical_relation-1" class="code">canonical_relation(SetOfSets) -&gt; BinRel</h3> <p>Types:</p>    <pre>BinRel = <a href="#type-binary_relation">binary_relation()</a>
SetOfSets = <a href="#type-set_of_sets">set_of_sets()</a></pre>

<p>Returns the binary relation containing the elements (E, Set) such that Set belongs to SetOfSets and E belongs to Set. If SetOfSets is a <code class="bold_code"><a href="#partition">partition</a></code> of a set X and R is the equivalence relation in X induced by SetOfSets, then the returned relation is the <code class="bold_code"><a href="#canonical_map">canonical map</a></code> from X onto the equivalence classes with respect to R.</p> <div class="example"><pre>
1&gt; Ss = sofs:from_term([[a,b],[b,c]]),
CR = sofs:canonical_relation(Ss),
sofs:to_external(CR).
[{a,[a,b]},{b,[a,b]},{b,[b,c]},{c,[b,c]}]</pre></div>  <h3 id="composite-2" class="code">composite(Function1, Function2) -&gt; Function3</h3> <p>Types:</p>     <pre>Function1 = Function2 = Function3 = <a href="#type-a_function">a_function()</a></pre>

<p>Returns the <code class="bold_code"><a href="#composite">composite</a></code> of the functions Function1 and Function2.</p> <div class="example"><pre>
1&gt; F1 = sofs:a_function([{a,1},{b,2},{c,2}]),
F2 = sofs:a_function([{1,x},{2,y},{3,z}]),
F = sofs:composite(F1, F2),
sofs:to_external(F).
[{a,x},{b,y},{c,y}]</pre></div>  <h3 id="constant_function-2" class="code">constant_function(Set, AnySet) -&gt; Function</h3> <p>Types:</p>     <pre>AnySet = <a href="#type-anyset">anyset()</a>
Function = <a href="#type-a_function">a_function()</a>
Set = <a href="#type-a_set">a_set()</a></pre>

<p>Creates the <code class="bold_code"><a href="#function">function</a></code> that maps each element of the set Set onto AnySet.</p> <div class="example"><pre>
1&gt; S = sofs:set([a,b]),
E = sofs:from_term(1),
R = sofs:constant_function(S, E),
sofs:to_external(R).
[{a,1},{b,1}]</pre></div>  <h3 id="converse-1" class="code">converse(BinRel1) -&gt; BinRel2</h3> <p>Types:</p>    <pre>BinRel1 = BinRel2 = <a href="#type-binary_relation">binary_relation()</a></pre>

<p>Returns the <code class="bold_code"><a href="#converse">converse</a></code> of the binary relation BinRel1.</p> <div class="example"><pre>
1&gt; R1 = sofs:relation([{1,a},{2,b},{3,a}]),
R2 = sofs:converse(R1),
sofs:to_external(R2).
[{a,1},{a,3},{b,2}]</pre></div>  <h3 id="difference-2" class="code">difference(Set1, Set2) -&gt; Set3</h3> <p>Types:</p>     <pre>Set1 = Set2 = Set3 = <a href="#type-a_set">a_set()</a></pre>

<p>Returns the <code class="bold_code"><a href="#difference">difference</a></code> of the sets Set1 and Set2.</p>  <h3 id="digraph_to_family-2" class="code">digraph_to_family(Graph) -&gt; Family<br>digraph_to_family(Graph, Type) -&gt; Family</h3> <p>Types:</p>     <pre>Graph = <a href="../digraph/#type-graph">digraph:graph()</a>
Family = <a href="#type-family">family()</a>
Type = <a href="#type-type">type()</a></pre>

<p>Creates a <code class="bold_code"><a href="#family">family</a></code> from the directed graph Graph. Each vertex a of Graph is represented by a pair (a, {b[1], ..., b[n]}) where the b[i]'s are the out-neighbours of a. If no type is explicitly given, [{atom, [atom]}] is used as type of the family. It is assumed that Type is a <code class="bold_code"><a href="#valid_type">valid type</a></code> of the external set of the family.</p> <p>If G is a directed graph, it holds that the vertices and edges of G are the same as the vertices and edges of <code class="code">family_to_digraph(digraph_to_family(G))</code>.</p>  <h3 id="domain-1" class="code">domain(BinRel) -&gt; Set</h3> <p>Types:</p>    <pre>BinRel = <a href="#type-binary_relation">binary_relation()</a>
Set = <a href="#type-a_set">a_set()</a></pre>

<p>Returns the <code class="bold_code"><a href="#domain">domain</a></code> of the binary relation BinRel.</p> <div class="example"><pre>
1&gt; R = sofs:relation([{1,a},{1,b},{2,b},{2,c}]),
S = sofs:domain(R),
sofs:to_external(S).
[1,2]</pre></div>  <h3 id="drestriction-2" class="code">drestriction(BinRel1, Set) -&gt; BinRel2</h3> <p>Types:</p>     <pre>BinRel1 = BinRel2 = <a href="#type-binary_relation">binary_relation()</a>

Set = <a href="#type-a_set">a_set()</a></pre>

<p>Returns the difference between the binary relation BinRel1 and the <code class="bold_code"><a href="#restriction">restriction</a></code> of BinRel1 to Set.</p> <div class="example"><pre>
1&gt; R1 = sofs:relation([{1,a},{2,b},{3,c}]),
S = sofs:set([2,4,6]),
R2 = sofs:drestriction(R1, S),
sofs:to_external(R2).
[{1,a},{3,c}]</pre></div> <p><code class="code">drestriction(R, S)</code> is equivalent to <code class="code">difference(R, restriction(R, S))</code>.</p>  <h3 id="drestriction-3" class="code">drestriction(SetFun, Set1, Set2) -&gt; Set3</h3> <p>Types:</p>      <pre>SetFun = <a href="#type-set_fun">set_fun()</a>
Set1 = Set2 = Set3 = <a href="#type-a_set">a_set()</a></pre>

<p>Returns a subset of Set1 containing those elements that do not yield an element in Set2 as the result of applying SetFun.</p> <div class="example"><pre>
1&gt; SetFun = {external, fun({_A,B,C}) -&gt; {B,C} end},
R1 = sofs:relation([{a,aa,1},{b,bb,2},{c,cc,3}]),
R2 = sofs:relation([{bb,2},{cc,3},{dd,4}]),
R3 = sofs:drestriction(SetFun, R1, R2),
sofs:to_external(R3).
[{a,aa,1}]</pre></div> <p><code class="code">drestriction(F, S1, S2)</code> is equivalent to <code class="code">difference(S1, restriction(F, S1, S2))</code>.</p>  <h3 id="empty_set-0" class="code">empty_set() -&gt; Set</h3> <p>Types:</p>   <pre>Set = <a href="#type-a_set">a_set()</a></pre>

<p>Returns the <code class="bold_code"><a href="#sets_definition">untyped empty set</a></code>. <code class="code">empty_set()</code> is equivalent to <code class="code">from_term([], ['_'])</code>.</p>  <h3 id="extension-3" class="code">extension(BinRel1, Set, AnySet) -&gt; BinRel2</h3> <p>Types:</p>      <pre>AnySet = <a href="#type-anyset">anyset()</a>
BinRel1 = BinRel2 = <a href="#type-binary_relation">binary_relation()</a>

Set = <a href="#type-a_set">a_set()</a></pre>

<p>Returns the <code class="bold_code"><a href="#extension">extension</a></code> of BinRel1 such that for each element E in Set that does not belong to the <code class="bold_code"><a href="#domain">domain</a></code> of BinRel1, BinRel2 contains the pair (E, AnySet).</p> <div class="example"><pre>
1&gt; S = sofs:set([b,c]),
A = sofs:empty_set(),
R = sofs:family([{a,[1,2]},{b,[3]}]),
X = sofs:extension(R, S, A),
sofs:to_external(X).
[{a,[1,2]},{b,[3]},{c,[]}]</pre></div>  <h3 id="family-2" class="code">family(Tuples) -&gt; Family<br>family(Tuples, Type) -&gt; Family</h3> <p>Types:</p>     <pre>Family = <a href="#type-family">family()</a>
Tuples = [tuple()]
Type = <a href="#type-type">type()</a></pre>

<p>Creates a <code class="bold_code"><a href="#family">family of subsets</a></code>. <code class="code">family(F, T)</code> is equivalent to <code class="code">from_term(F, T)</code>, if the result is a family. If no <code class="bold_code"><a href="#type">type</a></code> is explicitly given, <code class="code">[{atom, [atom]}]</code> is used as type of the family.</p>  <h3 id="family_difference-2" class="code">family_difference(Family1, Family2) -&gt; Family3</h3> <p>Types:</p>     <pre>Family1 = Family2 = Family3 = <a href="#type-family">family()</a></pre>

<p>If Family1 and Family2 are <code class="bold_code"><a href="#family">families</a></code>, then Family3 is the family such that the index set is equal to the index set of Family1, and Family3[i] is the difference between Family1[i] and Family2[i] if Family2 maps i, Family1[i] otherwise.</p> <div class="example"><pre>
1&gt; F1 = sofs:family([{a,[1,2]},{b,[3,4]}]),
F2 = sofs:family([{b,[4,5]},{c,[6,7]}]),
F3 = sofs:family_difference(F1, F2),
sofs:to_external(F3).
[{a,[1,2]},{b,[3]}]</pre></div>  <h3 id="family_domain-1" class="code">family_domain(Family1) -&gt; Family2</h3> <p>Types:</p>    <pre>Family1 = Family2 = <a href="#type-family">family()</a></pre>

<p>If Family1 is a <code class="bold_code"><a href="#family">family</a></code> and Family1[i] is a binary relation for every i in the index set of Family1, then Family2 is the family with the same index set as Family1 such that Family2[i] is the <code class="bold_code"><a href="#domain">domain</a></code> of Family1[i].</p> <div class="example"><pre>
1&gt; FR = sofs:from_term([{a,[{1,a},{2,b},{3,c}]},{b,[]},{c,[{4,d},{5,e}]}]),
F = sofs:family_domain(FR),
sofs:to_external(F).
[{a,[1,2,3]},{b,[]},{c,[4,5]}]</pre></div>  <h3 id="family_field-1" class="code">family_field(Family1) -&gt; Family2</h3> <p>Types:</p>    <pre>Family1 = Family2 = <a href="#type-family">family()</a></pre>

<p>If Family1 is a <code class="bold_code"><a href="#family">family</a></code> and Family1[i] is a binary relation for every i in the index set of Family1, then Family2 is the family with the same index set as Family1 such that Family2[i] is the <code class="bold_code"><a href="#field">field</a></code> of Family1[i].</p> <div class="example"><pre>
1&gt; FR = sofs:from_term([{a,[{1,a},{2,b},{3,c}]},{b,[]},{c,[{4,d},{5,e}]}]),
F = sofs:family_field(FR),
sofs:to_external(F).
[{a,[1,2,3,a,b,c]},{b,[]},{c,[4,5,d,e]}]</pre></div> <p><code class="code">family_field(Family1)</code> is equivalent to <code class="code">family_union(family_domain(Family1), family_range(Family1))</code>.</p>  <h3 id="family_intersection-1" class="code">family_intersection(Family1) -&gt; Family2</h3> <p>Types:</p>    <pre>Family1 = Family2 = <a href="#type-family">family()</a></pre>

<p>If Family1 is a <code class="bold_code"><a href="#family">family</a></code> and Family1[i] is a set of sets for every i in the index set of Family1, then Family2 is the family with the same index set as Family1 such that Family2[i] is the <code class="bold_code"><a href="#intersection_n">intersection</a></code> of Family1[i].</p> <p>If Family1[i] is an empty set for some i, then the process exits with a <code class="code">badarg</code> message.</p> <div class="example"><pre>
1&gt; F1 = sofs:from_term([{a,[[1,2,3],[2,3,4]]},{b,[[x,y,z],[x,y]]}]),
F2 = sofs:family_intersection(F1),
sofs:to_external(F2).
[{a,[2,3]},{b,[x,y]}]</pre></div>  <h3 id="family_intersection-2" class="code">family_intersection(Family1, Family2) -&gt; Family3</h3> <p>Types:</p>     <pre>Family1 = Family2 = Family3 = <a href="#type-family">family()</a></pre>

<p>If Family1 and Family2 are <code class="bold_code"><a href="#family">families</a></code>, then Family3 is the family such that the index set is the intersection of Family1's and Family2's index sets, and Family3[i] is the intersection of Family1[i] and Family2[i].</p> <div class="example"><pre>
1&gt; F1 = sofs:family([{a,[1,2]},{b,[3,4]},{c,[5,6]}]),
F2 = sofs:family([{b,[4,5]},{c,[7,8]},{d,[9,10]}]),
F3 = sofs:family_intersection(F1, F2),
sofs:to_external(F3).
[{b,[4]},{c,[]}]</pre></div>  <h3 id="family_projection-2" class="code">family_projection(SetFun, Family1) -&gt; Family2</h3> <p>Types:</p>     <pre>SetFun = <a href="#type-set_fun">set_fun()</a>
Family1 = Family2 = <a href="#type-family">family()</a></pre>

<p>If Family1 is a <code class="bold_code"><a href="#family">family</a></code> then Family2 is the family with the same index set as Family1 such that Family2[i] is the result of calling SetFun with Family1[i] as argument.</p> <div class="example"><pre>
1&gt; F1 = sofs:from_term([{a,[[1,2],[2,3]]},{b,[[]]}]),
F2 = sofs:family_projection(fun sofs:union/1, F1),
sofs:to_external(F2).
[{a,[1,2,3]},{b,[]}]</pre></div>  <h3 id="family_range-1" class="code">family_range(Family1) -&gt; Family2</h3> <p>Types:</p>    <pre>Family1 = Family2 = <a href="#type-family">family()</a></pre>

<p>If Family1 is a <code class="bold_code"><a href="#family">family</a></code> and Family1[i] is a binary relation for every i in the index set of Family1, then Family2 is the family with the same index set as Family1 such that Family2[i] is the <code class="bold_code"><a href="#range">range</a></code> of Family1[i].</p> <div class="example"><pre>
1&gt; FR = sofs:from_term([{a,[{1,a},{2,b},{3,c}]},{b,[]},{c,[{4,d},{5,e}]}]),
F = sofs:family_range(FR),
sofs:to_external(F).
[{a,[a,b,c]},{b,[]},{c,[d,e]}]</pre></div>  <h3 id="family_specification-2" class="code">family_specification(Fun, Family1) -&gt; Family2</h3> <p>Types:</p>     <pre>Fun = <a href="#type-spec_fun">spec_fun()</a>
Family1 = Family2 = <a href="#type-family">family()</a></pre>

<p>If Family1 is a <code class="bold_code"><a href="#family">family</a></code>, then Family2 is the <code class="bold_code"><a href="#restriction">restriction</a></code> of Family1 to those elements i of the index set for which Fun applied to Family1[i] returns <code class="code">true</code>. If Fun is a tuple <code class="code">{external, Fun2}</code>, Fun2 is applied to the <code class="bold_code"><a href="#external_set">external set</a></code> of Family1[i], otherwise Fun is applied to Family1[i].</p> <div class="example"><pre>
1&gt; F1 = sofs:family([{a,[1,2,3]},{b,[1,2]},{c,[1]}]),
SpecFun = fun(S) -&gt; sofs:no_elements(S) =:= 2 end,
F2 = sofs:family_specification(SpecFun, F1),
sofs:to_external(F2).
[{b,[1,2]}]</pre></div>  <h3 id="family_to_digraph-2" class="code">family_to_digraph(Family) -&gt; Graph<br>family_to_digraph(Family, GraphType) -&gt; Graph</h3> <p>Types:</p>     <pre>Graph = <a href="../digraph/#type-graph">digraph:graph()</a>
Family = <a href="#type-family">family()</a>
GraphType = [<a href="../digraph/#type-d_type">digraph:d_type()</a>]</pre>

<p>Creates a directed graph from the <code class="bold_code"><a href="#family">family</a></code> Family. For each pair (a, {b[1], ..., b[n]}) of Family, the vertex a as well the edges (a, b[i]) for 1 &lt;= i &lt;= n are added to a newly created directed graph.</p> <p>If no graph type is given <code class="bold_code"><a href="../digraph/#new-0"> digraph:new/0</a></code> is used for creating the directed graph, otherwise the GraphType argument is passed on as second argument to <code class="bold_code"><a href="../digraph/#new-1">digraph:new/1</a></code>.</p> <p>It F is a family, it holds that F is a subset of <code class="code">digraph_to_family(family_to_digraph(F), type(F))</code>. Equality holds if <code class="code">union_of_family(F)</code> is a subset of <code class="code">domain(F)</code>.</p> <p>Creating a cycle in an acyclic graph exits the process with a <code class="code">cyclic</code> message.</p>  <h3 id="family_to_relation-1" class="code">family_to_relation(Family) -&gt; BinRel</h3> <p>Types:</p>    <pre>Family = <a href="#type-family">family()</a>
BinRel = <a href="#type-binary_relation">binary_relation()</a></pre>

<p>If Family is a <code class="bold_code"><a href="#family">family</a></code>, then BinRel is the binary relation containing all pairs (i, x) such that i belongs to the index set of Family and x belongs to Family[i].</p> <div class="example"><pre>
1&gt; F = sofs:family([{a,[]}, {b,[1]}, {c,[2,3]}]),
R = sofs:family_to_relation(F),
sofs:to_external(R).
[{b,1},{c,2},{c,3}]</pre></div>  <h3 id="family_union-1" class="code">family_union(Family1) -&gt; Family2</h3> <p>Types:</p>    <pre>Family1 = Family2 = <a href="#type-family">family()</a></pre>

<p>If Family1 is a <code class="bold_code"><a href="#family">family</a></code> and Family1[i] is a set of sets for each i in the index set of Family1, then Family2 is the family with the same index set as Family1 such that Family2[i] is the <code class="bold_code"><a href="#union_n">union</a></code> of Family1[i].</p> <div class="example"><pre>
1&gt; F1 = sofs:from_term([{a,[[1,2],[2,3]]},{b,[[]]}]),
F2 = sofs:family_union(F1),
sofs:to_external(F2).
[{a,[1,2,3]},{b,[]}]</pre></div> <p><code class="code">family_union(F)</code> is equivalent to <code class="code">family_projection(fun sofs:union/1, F)</code>.</p>  <h3 id="family_union-2" class="code">family_union(Family1, Family2) -&gt; Family3</h3> <p>Types:</p>     <pre>Family1 = Family2 = Family3 = <a href="#type-family">family()</a></pre>

<p>If Family1 and Family2 are <code class="bold_code"><a href="#family">families</a></code>, then Family3 is the family such that the index set is the union of Family1's and Family2's index sets, and Family3[i] is the union of Family1[i] and Family2[i] if both maps i, Family1[i] or Family2[i] otherwise.</p> <div class="example"><pre>
1&gt; F1 = sofs:family([{a,[1,2]},{b,[3,4]},{c,[5,6]}]),
F2 = sofs:family([{b,[4,5]},{c,[7,8]},{d,[9,10]}]),
F3 = sofs:family_union(F1, F2),
sofs:to_external(F3).
[{a,[1,2]},{b,[3,4,5]},{c,[5,6,7,8]},{d,[9,10]}]</pre></div>  <h3 id="field-1" class="code">field(BinRel) -&gt; Set</h3> <p>Types:</p>    <pre>BinRel = <a href="#type-binary_relation">binary_relation()</a>
Set = <a href="#type-a_set">a_set()</a></pre>

<p>Returns the <code class="bold_code"><a href="#field">field</a></code> of the binary relation BinRel.</p> <div class="example"><pre>
1&gt; R = sofs:relation([{1,a},{1,b},{2,b},{2,c}]),
S = sofs:field(R),
sofs:to_external(S).
[1,2,a,b,c]</pre></div> <p><code class="code">field(R)</code> is equivalent to <code class="code">union(domain(R), range(R))</code>.</p>  <h3 id="from_external-2" class="code">from_external(ExternalSet, Type) -&gt; AnySet</h3> <p>Types:</p>     <pre>ExternalSet = <a href="#type-external_set">external_set()</a>
AnySet = <a href="#type-anyset">anyset()</a>
Type = <a href="#type-type">type()</a></pre>

<p>Creates a set from the <code class="bold_code"><a href="#external_set">external set</a></code> ExternalSet and the <code class="bold_code"><a href="#type">type</a></code> Type. It is assumed that Type is a <code class="bold_code"><a href="#valid_type">valid type</a></code> of ExternalSet.</p>  <h3 id="from_sets-1" class="code">from_sets(ListOfSets) -&gt; Set</h3> <p>Types:</p>    <pre>Set = <a href="#type-a_set">a_set()</a>
ListOfSets = [<a href="#type-anyset">anyset()</a>]</pre>

<p>Returns the <code class="bold_code"><a href="#sets_definition">unordered set</a></code> containing the sets of the list ListOfSets.</p> <div class="example"><pre>
1&gt; S1 = sofs:relation([{a,1},{b,2}]),
S2 = sofs:relation([{x,3},{y,4}]),
S = sofs:from_sets([S1,S2]),
sofs:to_external(S).
[[{a,1},{b,2}],[{x,3},{y,4}]]</pre></div>  <h3 class="code">from_sets(TupleOfSets) -&gt; Ordset</h3> <p>Types:</p>    <pre>Ordset = <a href="#type-ordset">ordset()</a>
TupleOfSets = <a href="#type-tuple_of">tuple_of</a>(<a href="#type-anyset">anyset()</a>)</pre>

<p>Returns the <code class="bold_code"><a href="#sets_definition">ordered set</a></code> containing the sets of the non-empty tuple TupleOfSets.</p>  <h3 id="from_term-2" class="code">from_term(Term) -&gt; AnySet<br>from_term(Term, Type) -&gt; AnySet</h3> <p>Types:</p>     <pre>AnySet = <a href="#type-anyset">anyset()</a>
Term = term()
Type = <a href="#type-type">type()</a></pre>

<p id="from_term">Creates an element of <code class="bold_code"><a href="#sets_definition">Sets</a></code> by traversing the term Term, sorting lists, removing duplicates and deriving or verifying a <code class="bold_code"><a href="#valid_type">valid type</a></code> for the so obtained external set. An explicitly given <code class="bold_code"><a href="#type">type</a></code> Type can be used to limit the depth of the traversal; an atomic type stops the traversal, as demonstrated by this example where "foo" and {"foo"} are left unmodified:</p> <div class="example"><pre>
1&gt; S = sofs:from_term([{{"foo"},[1,1]},{"foo",[2,2]}], [{atom,[atom]}]),
sofs:to_external(S).
[{{"foo"},[1]},{"foo",[2]}]</pre></div> <p><code class="code">from_term</code> can be used for creating atomic or ordered sets. The only purpose of such a set is that of later building unordered sets since all functions in this module that <strong>do</strong> anything operate on unordered sets. Creating unordered sets from a collection of ordered sets may be the way to go if the ordered sets are big and one does not want to waste heap by rebuilding the elements of the unordered set. An example showing that a set can be built "layer by layer":</p> <div class="example"><pre>
1&gt; A = sofs:from_term(a),
S = sofs:set([1,2,3]),
P1 = sofs:from_sets({A,S}),
P2 = sofs:from_term({b,[6,5,4]}),
Ss = sofs:from_sets([P1,P2]),
sofs:to_external(Ss).
[{a,[1,2,3]},{b,[4,5,6]}]</pre></div> <p>Other functions that create sets are <code class="code">from_external/2</code> and <code class="code">from_sets/1</code>. Special cases of <code class="code">from_term/2</code> are <code class="code">a_function/1,2</code>, <code class="code">empty_set/0</code>, <code class="code">family/1,2</code>, <code class="code">relation/1,2</code>, and <code class="code">set/1,2</code>.</p>  <h3 id="image-2" class="code">image(BinRel, Set1) -&gt; Set2</h3> <p>Types:</p>     <pre>BinRel = <a href="#type-binary_relation">binary_relation()</a>
Set1 = Set2 = <a href="#type-a_set">a_set()</a></pre>

<p>Returns the <code class="bold_code"><a href="#image">image</a></code> of the set Set1 under the binary relation BinRel.</p> <div class="example"><pre>
1&gt; R = sofs:relation([{1,a},{2,b},{2,c},{3,d}]),
S1 = sofs:set([1,2]),
S2 = sofs:image(R, S1),
sofs:to_external(S2).
[a,b,c]</pre></div>  <h3 id="intersection-1" class="code">intersection(SetOfSets) -&gt; Set</h3> <p>Types:</p>    <pre>Set = <a href="#type-a_set">a_set()</a>
SetOfSets = <a href="#type-set_of_sets">set_of_sets()</a></pre>

<p>Returns the <code class="bold_code"><a href="#intersection_n">intersection</a></code> of the set of sets SetOfSets.</p> <p>Intersecting an empty set of sets exits the process with a <code class="code">badarg</code> message.</p>  <h3 id="intersection-2" class="code">intersection(Set1, Set2) -&gt; Set3</h3> <p>Types:</p>     <pre>Set1 = Set2 = Set3 = <a href="#type-a_set">a_set()</a></pre>

<p>Returns the <code class="bold_code"><a href="#intersection">intersection</a></code> of Set1 and Set2.</p>  <h3 id="intersection_of_family-1" class="code">intersection_of_family(Family) -&gt; Set</h3> <p>Types:</p>    <pre>Family = <a href="#type-family">family()</a>
Set = <a href="#type-a_set">a_set()</a></pre>

<p>Returns the intersection of the <code class="bold_code"><a href="#family">family</a></code> Family. </p> <p>Intersecting an empty family exits the process with a <code class="code">badarg</code> message.</p> <div class="example"><pre>
1&gt; F = sofs:family([{a,[0,2,4]},{b,[0,1,2]},{c,[2,3]}]),
S = sofs:intersection_of_family(F),
sofs:to_external(S).
[2]</pre></div>  <h3 id="inverse-1" class="code">inverse(Function1) -&gt; Function2</h3> <p>Types:</p>    <pre>Function1 = Function2 = <a href="#type-a_function">a_function()</a></pre>

<p>Returns the <code class="bold_code"><a href="#inverse">inverse</a></code> of the function Function1.</p> <div class="example"><pre>
1&gt; R1 = sofs:relation([{1,a},{2,b},{3,c}]),
R2 = sofs:inverse(R1),
sofs:to_external(R2).
[{a,1},{b,2},{c,3}]</pre></div>  <h3 id="inverse_image-2" class="code">inverse_image(BinRel, Set1) -&gt; Set2</h3> <p>Types:</p>     <pre>BinRel = <a href="#type-binary_relation">binary_relation()</a>
Set1 = Set2 = <a href="#type-a_set">a_set()</a></pre>

<p>Returns the <code class="bold_code"><a href="#inverse_image">inverse image</a></code> of Set1 under the binary relation BinRel.</p> <div class="example"><pre>
1&gt; R = sofs:relation([{1,a},{2,b},{2,c},{3,d}]),
S1 = sofs:set([c,d,e]),
S2 = sofs:inverse_image(R, S1),
sofs:to_external(S2).
[2,3]</pre></div>  <h3 id="is_a_function-1" class="code">is_a_function(BinRel) -&gt; Bool</h3> <p>Types:</p>    <pre>Bool = boolean()
BinRel = <a href="#type-binary_relation">binary_relation()</a></pre>

<p>Returns <code class="code">true</code> if the binary relation BinRel is a <code class="bold_code"><a href="#function">function</a></code> or the untyped empty set, <code class="code">false</code> otherwise.</p>  <h3 id="is_disjoint-2" class="code">is_disjoint(Set1, Set2) -&gt; Bool</h3> <p>Types:</p>     <pre>Bool = boolean()
Set1 = Set2 = <a href="#type-a_set">a_set()</a></pre>

<p>Returns <code class="code">true</code> if Set1 and Set2 are <code class="bold_code"><a href="#disjoint">disjoint</a></code>, <code class="code">false</code> otherwise.</p>  <h3 id="is_empty_set-1" class="code">is_empty_set(AnySet) -&gt; Bool</h3> <p>Types:</p>    <pre>AnySet = <a href="#type-anyset">anyset()</a>
Bool = boolean()</pre>

<p>Returns <code class="code">true</code> if AnySet is an empty unordered set, <code class="code">false</code> otherwise.</p>  <h3 id="is_equal-2" class="code">is_equal(AnySet1, AnySet2) -&gt; Bool</h3> <p>Types:</p>     <pre>AnySet1 = AnySet2 = <a href="#type-anyset">anyset()</a>

Bool = boolean()</pre>

<p>Returns <code class="code">true</code> if the AnySet1 and AnySet2 are <code class="bold_code"><a href="#equal">equal</a></code>, <code class="code">false</code> otherwise. This example shows that <code class="code">==/2</code> is used when comparing sets for equality:</p> <div class="example"><pre>
1&gt; S1 = sofs:set([1.0]),
S2 = sofs:set([1]),
sofs:is_equal(S1, S2).
true</pre></div>  <h3 id="is_set-1" class="code">is_set(AnySet) -&gt; Bool</h3> <p>Types:</p>    <pre>AnySet = <a href="#type-anyset">anyset()</a>
Bool = boolean()</pre>

<p>Returns <code class="code">true</code> if AnySet is an <code class="bold_code"><a href="#sets_definition">unordered set</a></code>, and <code class="code">false</code> if AnySet is an ordered set or an atomic set.</p>  <h3 id="is_sofs_set-1" class="code">is_sofs_set(Term) -&gt; Bool</h3> <p>Types:</p>    <pre>Bool = boolean()
Term = term()</pre>

<p>Returns <code class="code">true</code> if Term is an <code class="bold_code"><a href="#sets_definition">unordered set</a></code>, an ordered set or an atomic set, <code class="code">false</code> otherwise.</p>  <h3 id="is_subset-2" class="code">is_subset(Set1, Set2) -&gt; Bool</h3> <p>Types:</p>     <pre>Bool = boolean()
Set1 = Set2 = <a href="#type-a_set">a_set()</a></pre>

<p>Returns <code class="code">true</code> if Set1 is a <code class="bold_code"><a href="#subset">subset</a></code> of Set2, <code class="code">false</code> otherwise.</p>  <h3 id="is_type-1" class="code">is_type(Term) -&gt; Bool</h3> <p>Types:</p>    <pre>Bool = boolean()
Term = term()</pre>

<p>Returns <code class="code">true</code> if the term Term is a <code class="bold_code"><a href="#type">type</a></code>.</p>  <h3 id="join-4" class="code">join(Relation1, I, Relation2, J) -&gt; Relation3</h3> <p>Types:</p>       <pre>Relation1 = Relation2 = Relation3 = <a href="#type-relation">relation()</a>


I = J = integer() &gt;= 1</pre>

<p>Returns the <code class="bold_code"><a href="#natural_join">natural join</a></code> of the relations Relation1 and Relation2 on coordinates I and J.</p> <div class="example"><pre>
1&gt; R1 = sofs:relation([{a,x,1},{b,y,2}]),
R2 = sofs:relation([{1,f,g},{1,h,i},{2,3,4}]),
J = sofs:join(R1, 3, R2, 1),
sofs:to_external(J).
[{a,x,1,f,g},{a,x,1,h,i},{b,y,2,3,4}]</pre></div>  <h3 id="multiple_relative_product-2" class="code">multiple_relative_product(TupleOfBinRels, BinRel1) -&gt; BinRel2</h3> <p>Types:</p>      <pre>TupleOfBinRels = <a href="#type-tuple_of">tuple_of</a>(BinRel)
BinRel = BinRel1 = BinRel2 = <a href="#type-binary_relation">binary_relation()</a></pre>

<p>If TupleOfBinRels is a non-empty tuple {R[1], ..., R[n]} of binary relations and BinRel1 is a binary relation, then BinRel2 is the <code class="bold_code"><a href="#multiple_relative_product">multiple relative product</a></code> of the ordered set (R[i], ..., R[n]) and BinRel1.</p> <div class="example"><pre>
1&gt; Ri = sofs:relation([{a,1},{b,2},{c,3}]),
R = sofs:relation([{a,b},{b,c},{c,a}]),
MP = sofs:multiple_relative_product({Ri, Ri}, R),
sofs:to_external(sofs:range(MP)).
[{1,2},{2,3},{3,1}]</pre></div>  <h3 id="no_elements-1" class="code">no_elements(ASet) -&gt; NoElements</h3> <p>Types:</p>    <pre>ASet = <a href="#type-a_set">a_set()</a> | <a href="#type-ordset">ordset()</a>
NoElements = integer() &gt;= 0</pre>

<p>Returns the number of elements of the ordered or unordered set ASet.</p>  <h3 id="partition-1" class="code">partition(SetOfSets) -&gt; Partition</h3> <p>Types:</p>    <pre>SetOfSets = <a href="#type-set_of_sets">set_of_sets()</a>
Partition = <a href="#type-a_set">a_set()</a></pre>

<p>Returns the <code class="bold_code"><a href="#partition">partition</a></code> of the union of the set of sets SetOfSets such that two elements are considered equal if they belong to the same elements of SetOfSets.</p> <div class="example"><pre>
1&gt; Sets1 = sofs:from_term([[a,b,c],[d,e,f],[g,h,i]]),
Sets2 = sofs:from_term([[b,c,d],[e,f,g],[h,i,j]]),
P = sofs:partition(sofs:union(Sets1, Sets2)),
sofs:to_external(P).
[[a],[b,c],[d],[e,f],[g],[h,i],[j]]</pre></div>  <h3 id="partition-2" class="code">partition(SetFun, Set) -&gt; Partition</h3> <p>Types:</p>     <pre>SetFun = <a href="#type-set_fun">set_fun()</a>
Partition = Set = <a href="#type-a_set">a_set()</a></pre>

<p>Returns the <code class="bold_code"><a href="#partition">partition</a></code> of Set such that two elements are considered equal if the results of applying SetFun are equal.</p> <div class="example"><pre>
1&gt; Ss = sofs:from_term([[a],[b],[c,d],[e,f]]),
SetFun = fun(S) -&gt; sofs:from_term(sofs:no_elements(S)) end,
P = sofs:partition(SetFun, Ss),
sofs:to_external(P).
[[[a],[b]],[[c,d],[e,f]]]</pre></div>  <h3 id="partition-3" class="code">partition(SetFun, Set1, Set2) -&gt; {Set3, Set4}</h3> <p>Types:</p>       <pre>SetFun = <a href="#type-set_fun">set_fun()</a>
Set1 = Set2 = Set3 = Set4 = <a href="#type-a_set">a_set()</a></pre>

<p>Returns a pair of sets that, regarded as constituting a set, forms a <code class="bold_code"><a href="#partition">partition</a></code> of Set1. If the result of applying SetFun to an element of Set1 yields an element in Set2, the element belongs to Set3, otherwise the element belongs to Set4.</p> <div class="example"><pre>
1&gt; R1 = sofs:relation([{1,a},{2,b},{3,c}]),
S = sofs:set([2,4,6]),
{R2,R3} = sofs:partition(1, R1, S),
{sofs:to_external(R2),sofs:to_external(R3)}.
{[{2,b}],[{1,a},{3,c}]}</pre></div> <p><code class="code">partition(F, S1, S2)</code> is equivalent to <code class="code">{restriction(F, S1, S2), drestriction(F, S1, S2)}</code>.</p>  <h3 id="partition_family-2" class="code">partition_family(SetFun, Set) -&gt; Family</h3> <p>Types:</p>     <pre>Family = <a href="#type-family">family()</a>
SetFun = <a href="#type-set_fun">set_fun()</a>
Set = <a href="#type-a_set">a_set()</a></pre>

<p>Returns the <code class="bold_code"><a href="#family">family</a></code> Family where the indexed set is a <code class="bold_code"><a href="#partition">partition</a></code> of Set such that two elements are considered equal if the results of applying SetFun are the same value i. This i is the index that Family maps onto the <code class="bold_code"><a href="#equivalence_class">equivalence class</a></code>.</p> <div class="example"><pre>
1&gt; S = sofs:relation([{a,a,a,a},{a,a,b,b},{a,b,b,b}]),
SetFun = {external, fun({A,_,C,_}) -&gt; {A,C} end},
F = sofs:partition_family(SetFun, S),
sofs:to_external(F).
[{{a,a},[{a,a,a,a}]},{{a,b},[{a,a,b,b},{a,b,b,b}]}]</pre></div>  <h3 id="product-1" class="code">product(TupleOfSets) -&gt; Relation</h3> <p>Types:</p>    <pre>Relation = <a href="#type-relation">relation()</a>
TupleOfSets = <a href="#type-tuple_of">tuple_of</a>(<a href="#type-a_set">a_set()</a>)</pre>

<p>Returns the <code class="bold_code"><a href="#Cartesian_product_tuple">Cartesian product</a></code> of the non-empty tuple of sets TupleOfSets. If (x[1], ..., x[n]) is an element of the n-ary relation Relation, then x[i] is drawn from element i of TupleOfSets.</p> <div class="example"><pre>
1&gt; S1 = sofs:set([a,b]),
S2 = sofs:set([1,2]),
S3 = sofs:set([x,y]),
P3 = sofs:product({S1,S2,S3}),
sofs:to_external(P3).
[{a,1,x},{a,1,y},{a,2,x},{a,2,y},{b,1,x},{b,1,y},{b,2,x},{b,2,y}]</pre></div>  <h3 id="product-2" class="code">product(Set1, Set2) -&gt; BinRel</h3> <p>Types:</p>     <pre>BinRel = <a href="#type-binary_relation">binary_relation()</a>
Set1 = Set2 = <a href="#type-a_set">a_set()</a></pre>

<p>Returns the <code class="bold_code"><a href="#Cartesian_product">Cartesian product</a></code> of Set1 and Set2.</p> <div class="example"><pre>
1&gt; S1 = sofs:set([1,2]),
S2 = sofs:set([a,b]),
R = sofs:product(S1, S2),
sofs:to_external(R).
[{1,a},{1,b},{2,a},{2,b}]</pre></div> <p><code class="code">product(S1, S2)</code> is equivalent to <code class="code">product({S1, S2})</code>.</p>  <h3 id="projection-2" class="code">projection(SetFun, Set1) -&gt; Set2</h3> <p>Types:</p>     <pre>SetFun = <a href="#type-set_fun">set_fun()</a>
Set1 = Set2 = <a href="#type-a_set">a_set()</a></pre>

<p>Returns the set created by substituting each element of Set1 by the result of applying SetFun to the element.</p> <p>If SetFun is a number i &gt;= 1 and Set1 is a relation, then the returned set is the <code class="bold_code"><a href="#projection">projection</a></code> of Set1 onto coordinate i.</p> <div class="example"><pre>
1&gt; S1 = sofs:from_term([{1,a},{2,b},{3,a}]),
S2 = sofs:projection(2, S1),
sofs:to_external(S2).
[a,b]</pre></div>  <h3 id="range-1" class="code">range(BinRel) -&gt; Set</h3> <p>Types:</p>    <pre>BinRel = <a href="#type-binary_relation">binary_relation()</a>
Set = <a href="#type-a_set">a_set()</a></pre>

<p>Returns the <code class="bold_code"><a href="#range">range</a></code> of the binary relation BinRel.</p> <div class="example"><pre>
1&gt; R = sofs:relation([{1,a},{1,b},{2,b},{2,c}]),
S = sofs:range(R),
sofs:to_external(S).
[a,b,c]</pre></div>  <h3 id="relation-2" class="code">relation(Tuples) -&gt; Relation<br>relation(Tuples, Type) -&gt; Relation</h3> <p>Types:</p>      <pre>N = integer()
Type = N | <a href="#type-type">type()</a>
Relation = <a href="#type-relation">relation()</a>
Tuples = [tuple()]</pre>

<p>Creates a <code class="bold_code"><a href="#relation">relation</a></code>. <code class="code">relation(R, T)</code> is equivalent to <code class="code">from_term(R, T)</code>, if T is a <code class="bold_code"><a href="#type">type</a></code> and the result is a relation. If Type is an integer N, then <code class="code">[{atom, ..., atom}])</code>, where the size of the tuple is N, is used as type of the relation. If no type is explicitly given, the size of the first tuple of Tuples is used if there is such a tuple. <code class="code">relation([])</code> is equivalent to <code class="code">relation([], 2)</code>.</p>  <h3 id="relation_to_family-1" class="code">relation_to_family(BinRel) -&gt; Family</h3> <p>Types:</p>    <pre>Family = <a href="#type-family">family()</a>
BinRel = <a href="#type-binary_relation">binary_relation()</a></pre>

<p>Returns the <code class="bold_code"><a href="#family">family</a></code> Family such that the index set is equal to the <code class="bold_code"><a href="#domain">domain</a></code> of the binary relation BinRel, and Family[i] is the <code class="bold_code"><a href="#image">image</a></code> of the set of i under BinRel.</p> <div class="example"><pre>
1&gt; R = sofs:relation([{b,1},{c,2},{c,3}]),
F = sofs:relation_to_family(R),
sofs:to_external(F).
[{b,[1]},{c,[2,3]}]</pre></div>  <h3 id="relative_product-2" class="code">relative_product(ListOfBinRels) -&gt; BinRel2<br>relative_product(ListOfBinRels, BinRel1) -&gt; BinRel2</h3> <p>Types:</p>      <pre>ListOfBinRels = [BinRel, ...]
BinRel = BinRel1 = BinRel2 = <a href="#type-binary_relation">binary_relation()</a></pre>

<p>If ListOfBinRels is a non-empty list [R[1], ..., R[n]] of binary relations and BinRel1 is a binary relation, then BinRel2 is the <code class="bold_code"><a href="#tuple_relative_product">relative product</a></code> of the ordered set (R[i], ..., R[n]) and BinRel1.</p> <p>If BinRel1 is omitted, the relation of equality between the elements of the <code class="bold_code"><a href="#Cartesian_product_tuple">Cartesian product</a></code> of the ranges of R[i], range R[1] × ... × range R[n], is used instead (intuitively, nothing is "lost").</p> <div class="example"><pre>
1&gt; TR = sofs:relation([{1,a},{1,aa},{2,b}]),
R1 = sofs:relation([{1,u},{2,v},{3,c}]),
R2 = sofs:relative_product([TR, R1]),
sofs:to_external(R2).
[{1,{a,u}},{1,{aa,u}},{2,{b,v}}]</pre></div> <p>Note that <code class="code">relative_product([R1], R2)</code> is different from <code class="code">relative_product(R1, R2)</code>; the list of one element is not identified with the element itself.</p>  <h3 class="code">relative_product(BinRel1, BinRel2) -&gt; BinRel3</h3> <p>Types:</p>     <pre>BinRel1 = BinRel2 = BinRel3 = <a href="#type-binary_relation">binary_relation()</a></pre>

<p id="relprod_impl">Returns the <code class="bold_code"><a href="#relative_product">relative product</a></code> of the binary relations BinRel1 and BinRel2.</p>  <h3 id="relative_product1-2" class="code">relative_product1(BinRel1, BinRel2) -&gt; BinRel3</h3> <p>Types:</p>     <pre>BinRel1 = BinRel2 = BinRel3 = <a href="#type-binary_relation">binary_relation()</a></pre>

<p>Returns the <code class="bold_code"><a href="#relative_product">relative product</a></code> of the <code class="bold_code"><a href="#converse">converse</a></code> of the binary relation BinRel1 and the binary relation BinRel2.</p> <div class="example"><pre>
1&gt; R1 = sofs:relation([{1,a},{1,aa},{2,b}]),
R2 = sofs:relation([{1,u},{2,v},{3,c}]),
R3 = sofs:relative_product1(R1, R2),
sofs:to_external(R3).
[{a,u},{aa,u},{b,v}]</pre></div> <p><code class="code">relative_product1(R1, R2)</code> is equivalent to <code class="code">relative_product(converse(R1), R2)</code>.</p>  <h3 id="restriction-2" class="code">restriction(BinRel1, Set) -&gt; BinRel2</h3> <p>Types:</p>     <pre>BinRel1 = BinRel2 = <a href="#type-binary_relation">binary_relation()</a>

Set = <a href="#type-a_set">a_set()</a></pre>

<p>Returns the <code class="bold_code"><a href="#restriction">restriction</a></code> of the binary relation BinRel1 to Set.</p> <div class="example"><pre>
1&gt; R1 = sofs:relation([{1,a},{2,b},{3,c}]),
S = sofs:set([1,2,4]),
R2 = sofs:restriction(R1, S),
sofs:to_external(R2).
[{1,a},{2,b}]</pre></div>  <h3 id="restriction-3" class="code">restriction(SetFun, Set1, Set2) -&gt; Set3</h3> <p>Types:</p>      <pre>SetFun = <a href="#type-set_fun">set_fun()</a>
Set1 = Set2 = Set3 = <a href="#type-a_set">a_set()</a></pre>

<p>Returns a subset of Set1 containing those elements that yield an element in Set2 as the result of applying SetFun.</p> <div class="example"><pre>
1&gt; S1 = sofs:relation([{1,a},{2,b},{3,c}]),
S2 = sofs:set([b,c,d]),
S3 = sofs:restriction(2, S1, S2),
sofs:to_external(S3).
[{2,b},{3,c}]</pre></div>  <h3 id="set-2" class="code">set(Terms) -&gt; Set<br>set(Terms, Type) -&gt; Set</h3> <p>Types:</p>     <pre>Set = <a href="#type-a_set">a_set()</a>
Terms = [term()]
Type = <a href="#type-type">type()</a></pre>

<p>Creates an <code class="bold_code"><a href="#sets_definition">unordered set</a></code>. <code class="code">set(L, T)</code> is equivalent to <code class="code">from_term(L, T)</code>, if the result is an unordered set. If no <code class="bold_code"><a href="#type">type</a></code> is explicitly given, <code class="code">[atom]</code> is used as type of the set.</p>  <h3 id="specification-2" class="code">specification(Fun, Set1) -&gt; Set2</h3> <p>Types:</p>     <pre>Fun = <a href="#type-spec_fun">spec_fun()</a>
Set1 = Set2 = <a href="#type-a_set">a_set()</a></pre>

<p>Returns the set containing every element of Set1 for which Fun returns <code class="code">true</code>. If Fun is a tuple <code class="code">{external, Fun2}</code>, Fun2 is applied to the <code class="bold_code"><a href="#external_set">external set</a></code> of each element, otherwise Fun is applied to each element.</p> <div class="example"><pre>
1&gt; R1 = sofs:relation([{a,1},{b,2}]),
R2 = sofs:relation([{x,1},{x,2},{y,3}]),
S1 = sofs:from_sets([R1,R2]),
S2 = sofs:specification(fun sofs:is_a_function/1, S1),
sofs:to_external(S2).
[[{a,1},{b,2}]]</pre></div>  <h3 id="strict_relation-1" class="code">strict_relation(BinRel1) -&gt; BinRel2</h3> <p>Types:</p>    <pre>BinRel1 = BinRel2 = <a href="#type-binary_relation">binary_relation()</a></pre>

<p>Returns the <code class="bold_code"><a href="#strict_relation">strict relation</a></code> corresponding to the binary relation BinRel1.</p> <div class="example"><pre>
1&gt; R1 = sofs:relation([{1,1},{1,2},{2,1},{2,2}]),
R2 = sofs:strict_relation(R1),
sofs:to_external(R2).
[{1,2},{2,1}]</pre></div>  <h3 id="substitution-2" class="code">substitution(SetFun, Set1) -&gt; Set2</h3> <p>Types:</p>     <pre>SetFun = <a href="#type-set_fun">set_fun()</a>
Set1 = Set2 = <a href="#type-a_set">a_set()</a></pre>

<p>Returns a function, the domain of which is Set1. The value of an element of the domain is the result of applying SetFun to the element.</p> <div class="example"><pre>
1&gt; L = [{a,1},{b,2}].
[{a,1},{b,2}]
2&gt; sofs:to_external(sofs:projection(1,sofs:relation(L))).
[a,b]
3&gt; sofs:to_external(sofs:substitution(1,sofs:relation(L))).
[{{a,1},a},{{b,2},b}]
4&gt; SetFun = {external, fun({A,_}=E) -&gt; {E,A} end},
sofs:to_external(sofs:projection(SetFun,sofs:relation(L))).
[{{a,1},a},{{b,2},b}]</pre></div> <p>The relation of equality between the elements of {a,b,c}:</p> <div class="example"><pre>
1&gt; I = sofs:substitution(fun(A) -&gt; A end, sofs:set([a,b,c])),
sofs:to_external(I).
[{a,a},{b,b},{c,c}]</pre></div> <p>Let SetOfSets be a set of sets and BinRel a binary relation. The function that maps each element Set of SetOfSets onto the <code class="bold_code"><a href="#image">image</a></code> of Set under BinRel is returned by this function:</p> <div class="example"><pre>
images(SetOfSets, BinRel) -&gt;
   Fun = fun(Set) -&gt; sofs:image(BinRel, Set) end,
   sofs:substitution(Fun, SetOfSets).</pre></div> <p>Here might be the place to reveal something that was more or less stated before, namely that external unordered sets are represented as sorted lists. As a consequence, creating the image of a set under a relation R may traverse all elements of R (to that comes the sorting of results, the image). In <code class="code">images/2</code>, BinRel will be traversed once for each element of SetOfSets, which may take too long. The following efficient function could be used instead under the assumption that the image of each element of SetOfSets under BinRel is non-empty:</p> <div class="example"><pre>
images2(SetOfSets, BinRel) -&gt;
   CR = sofs:canonical_relation(SetOfSets),
   R = sofs:relative_product1(CR, BinRel),
   sofs:relation_to_family(R).</pre></div>  <h3 id="symdiff-2" class="code">symdiff(Set1, Set2) -&gt; Set3</h3> <p>Types:</p>     <pre>Set1 = Set2 = Set3 = <a href="#type-a_set">a_set()</a></pre>

<p>Returns the <code class="bold_code"><a href="#symmetric_difference">symmetric difference</a></code> (or the Boolean sum) of Set1 and Set2.</p> <div class="example"><pre>
1&gt; S1 = sofs:set([1,2,3]),
S2 = sofs:set([2,3,4]),
P = sofs:symdiff(S1, S2),
sofs:to_external(P).
[1,4]</pre></div>  <h3 id="symmetric_partition-2" class="code">symmetric_partition(Set1, Set2) -&gt; {Set3, Set4, Set5}</h3> <p>Types:</p>       <pre>Set1 = Set2 = Set3 = Set4 = Set5 = <a href="#type-a_set">a_set()</a></pre>

<p>Returns a triple of sets: Set3 contains the elements of Set1 that do not belong to Set2; Set4 contains the elements of Set1 that belong to Set2; Set5 contains the elements of Set2 that do not belong to Set1.</p>  <h3 id="to_external-1" class="code">to_external(AnySet) -&gt; ExternalSet</h3> <p>Types:</p>    <pre>ExternalSet = <a href="#type-external_set">external_set()</a>
AnySet = <a href="#type-anyset">anyset()</a></pre>

<p>Returns the <code class="bold_code"><a href="#external_set">external set</a></code> of an atomic, ordered or unordered set.</p>  <h3 id="to_sets-1" class="code">to_sets(ASet) -&gt; Sets</h3> <p>Types:</p>     <pre>ASet = <a href="#type-a_set">a_set()</a> | <a href="#type-ordset">ordset()</a>
Sets = <a href="#type-tuple_of">tuple_of</a>(AnySet) | [AnySet]
AnySet = <a href="#type-anyset">anyset()</a></pre>

<p>Returns the elements of the ordered set ASet as a tuple of sets, and the elements of the unordered set ASet as a sorted list of sets without duplicates.</p>  <h3 id="type-1" class="code">type(AnySet) -&gt; Type</h3> <p>Types:</p>    <pre>AnySet = <a href="#type-anyset">anyset()</a>
Type = <a href="#type-type">type()</a></pre>

<p>Returns the <code class="bold_code"><a href="#type">type</a></code> of an atomic, ordered or unordered set.</p>  <h3 id="union-1" class="code">union(SetOfSets) -&gt; Set</h3> <p>Types:</p>    <pre>Set = <a href="#type-a_set">a_set()</a>
SetOfSets = <a href="#type-set_of_sets">set_of_sets()</a></pre>

<p>Returns the <code class="bold_code"><a href="#union_n">union</a></code> of the set of sets SetOfSets.</p>  <h3 id="union-2" class="code">union(Set1, Set2) -&gt; Set3</h3> <p>Types:</p>     <pre>Set1 = Set2 = Set3 = <a href="#type-a_set">a_set()</a></pre>

<p>Returns the <code class="bold_code"><a href="#union">union</a></code> of Set1 and Set2.</p>  <h3 id="union_of_family-1" class="code">union_of_family(Family) -&gt; Set</h3> <p>Types:</p>    <pre>Family = <a href="#type-family">family()</a>
Set = <a href="#type-a_set">a_set()</a></pre>

<p>Returns the union of the <code class="bold_code"><a href="#family">family</a></code> Family. </p> <div class="example"><pre>
1&gt; F = sofs:family([{a,[0,2,4]},{b,[0,1,2]},{c,[2,3]}]),
S = sofs:union_of_family(F),
sofs:to_external(S).
[0,1,2,3,4]</pre></div>  <h3 id="weak_relation-1" class="code">weak_relation(BinRel1) -&gt; BinRel2</h3> <p>Types:</p>    <pre>BinRel1 = BinRel2 = <a href="#type-binary_relation">binary_relation()</a></pre>

<p>Returns a subset S of the <code class="bold_code"><a href="#weak_relation">weak relation</a></code> W corresponding to the binary relation BinRel1. Let F be the <code class="bold_code"><a href="#field">field</a></code> of BinRel1. The subset S is defined so that x S y if x W y for some x in F and for some y in F.</p> <div class="example"><pre>
1&gt; R1 = sofs:relation([{1,1},{1,2},{3,1}]),
R2 = sofs:weak_relation(R1),
sofs:to_external(R2).
[{1,1},{1,2},{2,2},{3,1},{3,3}]</pre></div>  <h2 id="id241746">See Also</h2>  <p><code class="bold_code"><a href="../dict/">dict(3)</a></code>, <code class="bold_code"><a href="../digraph/">digraph(3)</a></code>, <code class="bold_code"><a href="../orddict/">orddict(3)</a></code>, <code class="bold_code"><a href="../ordsets/">ordsets(3)</a></code>, <code class="bold_code"><a href="../sets/">sets(3)</a></code></p>
<div class="_attribution">
  <p class="_attribution-p">
    © 1999–2016 Ericsson AB<br>Licensed under the Apache License, Version 2.0.<br>
    
  </p>
</div>

			</div>
		</div>
	</section>

	</div>
</body>
</html>
