
<!DOCTYPE HTML>

<html lang="en">

<head>
  <meta charset="utf-8">
  <title>Qlc - Erlang 18 - W3cubDocs</title>
  
  <meta name="description" content=" qlc ">
  <meta name="keywords" content="qlc, -, erlang, erlang~18">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="http://docs.w3cub.com/erlang~18/lib/stdlib-2.8/doc/html/qlc/">
  <link href="/favicon.png" rel="icon">
  <link type="text/css" rel="stylesheet" href="/assets/application-50364fff564ce3b6327021805f3f00e2957b441cf27f576a7dd4ff63bbc47047.css">
  <script type="text/javascript" src="/assets/application-db64bfd54ceb42be11af7995804cf4902548419ceb79d509b0b7d62c22d98e6f.js"></script>
  <script src="/json/erlang~18.js"></script>
  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-71174418-1']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>


</head>

<body>
	<div class="_app">
	<header class="_header">
  
  <form class="_search">
    <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
    <a class="_search-clear"></a>
    <div class="_search-tag"></div>
  </form>
  
  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/erlang~18/" class="_nav-link" title="" style="margin-left:0;">Erlang 18</a></span>
  
  <nav class="_nav">
    <a href="/app/" class="_nav-link ">App</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		<div class="_list">
			
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<div class="_page _erlang">
				
<h1>qlc</h1> <h2>Module</h2> <p class="REFBODY">qlc</p> <h2>Module summary</h2> <p class="REFBODY">Query Interface to Mnesia, ETS, Dets, etc</p> <h2>Description</h2> 
<p>The <code class="code">qlc</code> module provides a query interface to Mnesia, ETS, Dets and other data structures that implement an iterator style traversal of objects. </p>  <h2 id="id218287">Overview</h2>  <p id="query_list_comprehension">The <code class="code">qlc</code> module implements a query interface to <strong>QLC tables</strong>. Typical QLC tables are ETS, Dets, and Mnesia tables. There is also support for user defined tables, see the <code class="bold_code"><a href="#implementing_a_qlc_table">Implementing a QLC table</a></code> section.  A <strong>query</strong> is stated using <strong>Query List Comprehensions</strong> (QLCs). The answers to a query are determined by data in QLC tables that fulfill the constraints expressed by the QLCs of the query. QLCs are similar to ordinary list comprehensions as described in the Erlang Reference Manual and Programming Examples except that variables introduced in patterns cannot be used in list expressions. In fact, in the absence of optimizations and options such as <code class="code">cache</code> and <code class="code">unique</code> (see below), every QLC free of QLC tables evaluates to the same list of answers as the identical ordinary list comprehension.</p> <p id="query_cursor">While ordinary list comprehensions evaluate to lists, calling <code class="bold_code"><a href="#q">qlc:q/1,2</a></code> returns a <strong> Query Handle</strong>. To obtain all the answers to a query, <code class="bold_code"><a href="#eval">qlc:eval/1,2</a></code> should be called with the query handle as first argument. Query handles are essentially functional objects ("funs") created in the module calling <code class="code">q/1,2</code>. As the funs refer to the module's code, one should be careful not to keep query handles too long if the module's code is to be replaced. Code replacement is described in the <code class="bold_code">Erlang Reference Manual</code>. The list of answers can also be traversed in chunks by use of a <strong>Query Cursor</strong>. Query cursors are created by calling <code class="bold_code"><a href="#cursor">qlc:cursor/1,2</a></code> with a query handle as first argument. Query cursors are essentially Erlang processes. One answer at a time is sent from the query cursor process to the process that created the cursor.</p>  <h2 id="id218388">Syntax</h2>  <p>Syntactically QLCs have the same parts as ordinary list comprehensions:</p> <div class="example"><pre>[Expression || Qualifier1, Qualifier2, ...]</pre></div> <p><code class="code">Expression</code> (the <strong>template</strong>) is an arbitrary Erlang expression. Qualifiers are either <strong>filters</strong> or <strong>generators</strong>. Filters are Erlang expressions returning <code class="code">bool()</code>. Generators have the form <code class="code">Pattern &lt;- ListExpression</code>, where <code class="code">ListExpression</code> is an expression evaluating to a query handle or a list. Query handles are returned from <code class="code">qlc:table/2</code>, <code class="code">qlc:append/1,2</code>, <code class="code">qlc:sort/1,2</code>, <code class="code">qlc:keysort/2,3</code>, <code class="code">qlc:q/1,2</code>, and <code class="code">qlc:string_to_handle/1,2,3</code>.</p>  <h2 id="id218457">Evaluation</h2>  <p>The evaluation of a query handle begins by the inspection of options and the collection of information about tables. As a result qualifiers are modified during the optimization phase. Next all list expressions are evaluated. If a cursor has been created evaluation takes place in the cursor process. For those list expressions that are QLCs, the list expressions of the QLCs' generators are evaluated as well. One has to be careful if list expressions have side effects since the order in which list expressions are evaluated is unspecified. Finally the answers are found by evaluating the qualifiers from left to right, backtracking when some filter returns <code class="code">false</code>, or collecting the template when all filters return <code class="code">true</code>.</p> <p>Filters that do not return <code class="code">bool()</code> but fail are handled differently depending on their syntax: if the filter is a guard it returns <code class="code">false</code>, otherwise the query evaluation fails. This behavior makes it possible for the <code class="code">qlc</code> module to do some optimizations without affecting the meaning of a query. For example, when testing some position of a table and one or more constants for equality, only the objects with equal values are candidates for further evaluation. The other objects are guaranteed to make the filter return <code class="code">false</code>, but never fail. The (small) set of candidate objects can often be found by looking up some key values of the table or by traversing the table using a match specification. It is necessary to place the guard filters immediately after the table's generator, otherwise the candidate objects will not be restricted to a small set. The reason is that objects that could make the query evaluation fail must not be excluded by looking up a key or running a match specification.</p>  <h2 id="id218508">Join</h2>  <p>The <code class="code">qlc</code> module supports fast join of two query handles. Fast join is possible if some position <code class="code">P1</code> of one query handler and some position <code class="code">P2</code> of another query handler are tested for equality. Two fast join methods have been implemented:</p> <ul> <li>Lookup join traverses all objects of one query handle and finds objects of the other handle (a QLC table) such that the values at <code class="code">P1</code> and <code class="code">P2</code> match or compare equal. The <code class="code">qlc</code> module does not create any indices but looks up values using the key position and the indexed positions of the QLC table. </li> <li>Merge join sorts the objects of each query handle if necessary and filters out objects where the values at <code class="code">P1</code> and <code class="code">P2</code> do not compare equal. If there are many objects with the same value of <code class="code">P2</code> a temporary file will be used for the equivalence classes. </li> </ul> <p>The <code class="code">qlc</code> module warns at compile time if a QLC combines query handles in such a way that more than one join is possible. In other words, there is no query planner that can choose a good order between possible join operations. It is up to the user to order the joins by introducing query handles.</p> <p>The join is to be expressed as a guard filter. The filter must be placed immediately after the two joined generators, possibly after guard filters that use variables from no other generators but the two joined generators. The <code class="code">qlc</code> module inspects the operands of <code class="code">=:=/2</code>, <code class="code">==/2</code>, <code class="code">is_record/2</code>, <code class="code">element/2</code>, and logical operators (<code class="code">and/2</code>, <code class="code">or/2</code>, <code class="code">andalso/2</code>, <code class="code">orelse/2</code>, <code class="code">xor/2</code>) when determining which joins to consider.</p>  <h2 id="id218624">Common options</h2>  <p>The following options are accepted by <code class="code">cursor/2</code>, <code class="code">eval/2</code>, <code class="code">fold/4</code>, and <code class="code">info/2</code>:</p> <ul> <li> <code class="code">{cache_all, Cache}</code> where <code class="code">Cache</code> is equal to <code class="code">ets</code> or <code class="code">list</code> adds a <code class="code">{cache, Cache}</code> option to every list expression of the query except tables and lists. Default is <code class="code">{cache_all, no}</code>. The option <code class="code">cache_all</code> is equivalent to <code class="code">{cache_all, ets}</code>. </li> <li id="max_list_size"> <code class="code">{max_list_size, MaxListSize}</code>  where <code class="code">MaxListSize</code> is the size in bytes of terms on the external format. If the accumulated size of collected objects exceeds <code class="code">MaxListSize</code> the objects are written onto a temporary file. This option is used by the <code class="code">{cache, list}</code> option as well as by the merge join method. Default is 512*1024 bytes. </li> <li> <code class="code">{tmpdir_usage, TmpFileUsage}</code> determines the action taken when <code class="code">qlc</code> is about to create temporary files on the directory set by the <code class="code">tmpdir</code> option. If the value is <code class="code">not_allowed</code> an error tuple is returned, otherwise temporary files are created as needed. Default is <code class="code">allowed</code> which means that no further action is taken. The values <code class="code">info_msg</code>, <code class="code">warning_msg</code>, and <code class="code">error_msg</code> mean that the function with the corresponding name in the module <code class="code">error_logger</code> is called for printing some information (currently the stacktrace). </li> <li> <code class="code">{tmpdir, TempDirectory}</code> sets the directory used by merge join for temporary files and by the <code class="code">{cache, list}</code> option. The option also overrides the <code class="code">tmpdir</code> option of <code class="code">keysort/3</code> and <code class="code">sort/2</code>. The default value is <code class="code">""</code> which means that the directory returned by <code class="code">file:get_cwd()</code> is used. </li> <li> <code class="code">{unique_all, true}</code> adds a <code class="code">{unique, true}</code> option to every list expression of the query. Default is <code class="code">{unique_all, false}</code>. The option <code class="code">unique_all</code> is equivalent to <code class="code">{unique_all, true}</code>. </li> </ul>  <h2 id="id218803">Getting started</h2>  <p id="getting_started"> As already mentioned queries are stated in the list comprehension syntax as described in the <code class="bold_code">Erlang Reference Manual</code>. In the following some familiarity with list comprehensions is assumed. There are examples in <code class="bold_code">Programming Examples</code> that can get you started. It should be stressed that list comprehensions do not add any computational power to the language; anything that can be done with list comprehensions can also be done without them. But they add a syntax for expressing simple search problems which is compact and clear once you get used to it.</p> <p>Many list comprehension expressions can be evaluated by the <code class="code">qlc</code> module. Exceptions are expressions such that variables introduced in patterns (or filters) are used in some generator later in the list comprehension. As an example consider an implementation of lists:append(L): <code class="code">[X ||Y &lt;- L, X &lt;- Y]</code>. Y is introduced in the first generator and used in the second. The ordinary list comprehension is normally to be preferred when there is a choice as to which to use. One difference is that <code class="code">qlc:eval/1,2</code> collects answers in a list which is finally reversed, while list comprehensions collect answers on the stack which is finally unwound.</p> <p>What the <code class="code">qlc</code> module primarily adds to list comprehensions is that data can be read from QLC tables in small chunks. A QLC table is created by calling <code class="code">qlc:table/2</code>. Usually <code class="code">qlc:table/2</code> is not called directly from the query but via an interface function of some data structure. There are a few examples of such functions in Erlang/OTP: <code class="code">mnesia:table/1,2</code>, <code class="code">ets:table/1,2</code>, and <code class="code">dets:table/1,2</code>. For a given data structure there can be several functions that create QLC tables, but common for all these functions is that they return a query handle created by <code class="code">qlc:table/2</code>. Using the QLC tables provided by OTP is probably sufficient in most cases, but for the more advanced user the section <code class="bold_code"><a href="#implementing_a_qlc_table">Implementing a QLC table</a></code> describes the implementation of a function calling <code class="code">qlc:table/2</code>.</p> <p>Besides <code class="code">qlc:table/2</code> there are other functions that return query handles. They might not be used as often as tables, but are useful from time to time. <code class="code">qlc:append</code> traverses objects from several tables or lists after each other. If, for instance, you want to traverse all answers to a query QH and then finish off by a term <code class="code">{finished}</code>, you can do that by calling <code class="code">qlc:append(QH, [{finished}])</code>. <code class="code">append</code> first returns all objects of QH, then <code class="code">{finished}</code>. If there is one tuple <code class="code">{finished}</code> among the answers to QH it will be returned twice from <code class="code">append</code>.</p> <p>As another example, consider concatenating the answers to two queries QH1 and QH2 while removing all duplicates. The means to accomplish this is to use the <code class="code">unique</code> option:</p> <div class="example"><pre>
qlc:q([X || X &lt;- qlc:append(QH1, QH2)], {unique, true})</pre></div> <p>The cost is substantial: every returned answer will be stored in an ETS table. Before returning an answer it is looked up in the ETS table to check if it has already been returned. Without the <code class="code">unique</code> options all answers to QH1 would be returned followed by all answers to QH2. The <code class="code">unique</code> options keeps the order between the remaining answers.</p> <p>If the order of the answers is not important there is the alternative to sort the answers uniquely:</p> <div class="example"><pre>
qlc:sort(qlc:q([X || X &lt;- qlc:append(QH1, QH2)], {unique, true})).</pre></div> <p>This query also removes duplicates but the answers will be sorted. If there are many answers temporary files will be used. Note that in order to get the first unique answer all answers have to be found and sorted. Both alternatives find duplicates by comparing answers, that is, if A1 and A2 are answers found in that order, then A2 is a removed if A1 == A2.</p> <p>To return just a few answers cursors can be used. The following code returns no more than five answers using an ETS table for storing the unique answers:</p> <div class="example"><pre>
C = qlc:cursor(qlc:q([X || X &lt;- qlc:append(QH1, QH2)],{unique,true})),
R = qlc:next_answers(C, 5),
ok = qlc:delete_cursor(C),
R.</pre></div> <p>Query list comprehensions are convenient for stating constraints on data from two or more tables. An example that does a natural join on two query handles on position 2:</p> <div class="example"><pre>
qlc:q([{X1,X2,X3,Y1} || 
          {X1,X2,X3} &lt;- QH1, 
          {Y1,Y2} &lt;- QH2, 
          X2 =:= Y2])</pre></div> <p>The <code class="code">qlc</code> module will evaluate this differently depending on the query handles <code class="code">QH1</code> and <code class="code">QH2</code>. If, for example, <code class="code">X2</code> is matched against the key of a QLC table the lookup join method will traverse the objects of <code class="code">QH2</code> while looking up key values in the table. On the other hand, if neither <code class="code">X2</code> nor <code class="code">Y2</code> is matched against the key or an indexed position of a QLC table, the merge join method will make sure that <code class="code">QH1</code> and <code class="code">QH2</code> are both sorted on position 2 and next do the join by traversing the objects one by one.</p> <p>The <code class="code">join</code> option can be used to force the <code class="code">qlc</code> module to use a certain join method. For the rest of this section it is assumed that the excessively slow join method called "nested loop" has been chosen:</p> <div class="example"><pre>
qlc:q([{X1,X2,X3,Y1} || 
          {X1,X2,X3} &lt;- QH1, 
          {Y1,Y2} &lt;- QH2, 
          X2 =:= Y2],
      {join, nested_loop})</pre></div> <p>In this case the filter will be applied to every possible pair of answers to QH1 and QH2, one at a time. If there are M answers to QH1 and N answers to QH2 the filter will be run M*N times.</p> <p>If QH2 is a call to the function for <code class="code">gb_trees</code> as defined in the <code class="bold_code"><a href="#implementing_a_qlc_table">Implementing a QLC table</a></code> section, <code class="code">gb_table:table/1</code>, the iterator for the gb-tree will be initiated for each answer to QH1 after which the objects of the gb-tree will be returned one by one. This is probably the most efficient way of traversing the table in that case since it takes minimal computational power to get the following object. But if QH2 is not a table but a more complicated QLC, it can be more efficient use some RAM memory for collecting the answers in a cache, particularly if there are only a few answers. It must then be assumed that evaluating QH2 has no side effects so that the meaning of the query does not change if QH2 is evaluated only once. One way of caching the answers is to evaluate QH2 first of all and substitute the list of answers for QH2 in the query. Another way is to use the <code class="code">cache</code> option. It is stated like this:</p> <div class="example"><pre>
QH2' = qlc:q([X || X &lt;- QH2], {cache, ets})</pre></div> <p>or just</p> <div class="example"><pre>
QH2' = qlc:q([X || X &lt;- QH2], cache)</pre></div> <p>The effect of the <code class="code">cache</code> option is that when the generator QH2' is run the first time every answer is stored in an ETS table. When next answer of QH1 is tried, answers to QH2' are copied from the ETS table which is very fast. As for the <code class="code">unique</code> option the cost is a possibly substantial amount of RAM memory. The <code class="code">{cache, list}</code> option offers the possibility to store the answers in a list on the process heap. While this has the potential of being faster than ETS tables since there is no need to copy answers from the table it can often result in slower evaluation due to more garbage collections of the process' heap as well as increased RAM memory consumption due to larger heaps. Another drawback with cache lists is that if the size of the list exceeds a limit a temporary file will be used. Reading the answers from a file is very much slower than copying them from an ETS table. But if the available RAM memory is scarce setting the <code class="bold_code"><a href="#max_list_size">limit</a></code> to some low value is an alternative.</p> <p>There is an option <code class="code">cache_all</code> that can be set to <code class="code">ets</code> or <code class="code">list</code> when evaluating a query. It adds a <code class="code">cache</code> or <code class="code">{cache, list}</code> option to every list expression except QLC tables and lists on all levels of the query. This can be used for testing if caching would improve efficiency at all. If the answer is yes further testing is needed to pinpoint the generators that should be cached.</p>  <h2 id="id219170">Implementing a QLC table</h2>  <p id="implementing_a_qlc_table">As an example of how to use the <code class="bold_code"><a href="#q">qlc:table/2</a></code> function the implementation of a QLC table for the <code class="bold_code"><a href="../gb_trees/">gb_trees</a></code> module is given:</p> <div class="example"><pre>
-module(gb_table).

-export([table/1]).

table(T) -&gt;
    TF = fun() -&gt; qlc_next(gb_trees:next(gb_trees:iterator(T))) end,
    InfoFun = fun(num_of_objects) -&gt; gb_trees:size(T);
                 (keypos) -&gt; 1;
                 (is_sorted_key) -&gt; true;
                 (is_unique_objects) -&gt; true;
                 (_) -&gt; undefined
              end,
    LookupFun =
        fun(1, Ks) -&gt;
                lists:flatmap(fun(K) -&gt;
                                      case gb_trees:lookup(K, T) of
                                          {value, V} -&gt; [{K,V}];
                                          none -&gt; []
                                      end
                              end, Ks)
        end,
    FormatFun =
        fun({all, NElements, ElementFun}) -&gt;
                ValsS = io_lib:format("gb_trees:from_orddict(~w)",
                                      [gb_nodes(T, NElements, ElementFun)]),
                io_lib:format("gb_table:table(~s)", [ValsS]);
           ({lookup, 1, KeyValues, _NElements, ElementFun}) -&gt;
                ValsS = io_lib:format("gb_trees:from_orddict(~w)",
                                      [gb_nodes(T, infinity, ElementFun)]),
                io_lib:format("lists:flatmap(fun(K) -&gt; "
                              "case gb_trees:lookup(K, ~s) of "
                              "{value, V} -&gt; [{K,V}];none -&gt; [] end "
                              "end, ~w)",
                              [ValsS, [ElementFun(KV) || KV &lt;- KeyValues]])
        end,
    qlc:table(TF, [{info_fun, InfoFun}, {format_fun, FormatFun},
                   {lookup_fun, LookupFun},{key_equality,'=='}]).

qlc_next({X, V, S}) -&gt;
    [{X,V} | fun() -&gt; qlc_next(gb_trees:next(S)) end];
qlc_next(none) -&gt;
    [].

gb_nodes(T, infinity, ElementFun) -&gt;
    gb_nodes(T, -1, ElementFun);
gb_nodes(T, NElements, ElementFun) -&gt;
    gb_iter(gb_trees:iterator(T), NElements, ElementFun).

gb_iter(_I, 0, _EFun) -&gt;
    '...';
gb_iter(I0, N, EFun) -&gt;
    case gb_trees:next(I0) of
        {X, V, I} -&gt;
            [EFun({X,V}) | gb_iter(I, N-1, EFun)];
        none -&gt;
            []
    end.</pre></div> <p><code class="code">TF</code> is the traversal function. The <code class="code">qlc</code> module requires that there is a way of traversing all objects of the data structure; in <code class="code">gb_trees</code> there is an iterator function suitable for that purpose. Note that for each object returned a new fun is created. As long as the list is not terminated by <code class="code">[]</code> it is assumed that the tail of the list is a nullary function and that calling the function returns further objects (and functions).</p> <p>The lookup function is optional. It is assumed that the lookup function always finds values much faster than it would take to traverse the table. The first argument is the position of the key. Since <code class="code">qlc_next</code> returns the objects as {Key, Value} pairs the position is 1. Note that the lookup function should return {Key, Value} pairs, just as the traversal function does.</p> <p>The format function is also optional. It is called by <code class="code">qlc:info</code> to give feedback at runtime of how the query will be evaluated. One should try to give as good feedback as possible without showing too much details. In the example at most 7 objects of the table are shown. The format function handles two cases: <code class="code">all</code> means that all objects of the table will be traversed; <code class="code">{lookup, 1, KeyValues}</code> means that the lookup function will be used for looking up key values.</p> <p>Whether the whole table will be traversed or just some keys looked up depends on how the query is stated. If the query has the form</p> <div class="example"><pre>
qlc:q([T || P &lt;- LE, F])</pre></div> <p>and P is a tuple, the <code class="code">qlc</code> module analyzes P and F in compile time to find positions of the tuple P that are tested for equality to constants. If such a position at runtime turns out to be the key position, the lookup function can be used, otherwise all objects of the table have to be traversed. It is the info function <code class="code">InfoFun</code> that returns the key position. There can be indexed positions as well, also returned by the info function. An index is an extra table that makes lookup on some position fast. Mnesia maintains indices upon request, thereby introducing so called secondary keys. The <code class="code">qlc</code> module prefers to look up objects using the key before secondary keys regardless of the number of constants to look up.</p>  <h2 id="id219301">Key equality</h2>  <p>In Erlang there are two operators for testing term equality, namely <code class="code">==/2</code> and <code class="code">=:=/2</code>. The difference between them is all about the integers that can be represented by floats. For instance, <code class="code">2 == 2.0</code> evaluates to <code class="code">true</code> while <code class="code">2 =:= 2.0</code> evaluates to <code class="code">false</code>. Normally this is a minor issue, but the <code class="code">qlc</code> module cannot ignore the difference, which affects the user's choice of operators in QLCs.</p> <p>If the <code class="code">qlc</code> module can find out at compile time that some constant is free of integers, it does not matter which one of <code class="code">==/2</code> or <code class="code">=:=/2</code> is used:</p> <div class="example"><pre>
1&gt; E1 = ets:new(t, [set]), % uses =:=/2 for key equality
Q1 = qlc:q([K ||
{K} &lt;- ets:table(E1),
K == 2.71 orelse K == a]),
io:format("~s~n", [qlc:info(Q1)]).
ets:match_spec_run(lists:flatmap(fun(V) -&gt;
                                        ets:lookup(20493, V)
                                 end,
                                 [a,2.71]),
                   ets:match_spec_compile([{{'$1'},[],['$1']}]))</pre></div> <p>In the example the <code class="code">==/2</code> operator has been handled exactly as <code class="code">=:=/2</code> would have been handled. On the other hand, if it cannot be determined at compile time that some constant is free of integers and the table uses <code class="code">=:=/2</code> when comparing keys for equality (see the option <code class="bold_code"><a href="#key_equality">key_equality</a></code>), the <code class="code">qlc</code> module will not try to look up the constant. The reason is that there is in the general case no upper limit on the number of key values that can compare equal to such a constant; every combination of integers and floats has to be looked up:</p> <div class="example"><pre>
2&gt; E2 = ets:new(t, [set]),
true = ets:insert(E2, [{{2,2},a},{{2,2.0},b},{{2.0,2},c}]),
F2 = fun(I) -&gt;
qlc:q([V || {K,V} &lt;- ets:table(E2), K == I])
end,
Q2 = F2({2,2}),
io:format("~s~n", [qlc:info(Q2)]).
ets:table(53264,
          [{traverse,
            {select,[{{'$1','$2'},[{'==','$1',{const,{2,2}}}],['$2']}]}}])
3&gt; lists:sort(qlc:e(Q2)).
[a,b,c]</pre></div> <p>Looking up just <code class="code">{2,2}</code> would not return <code class="code">b</code> and <code class="code">c</code>.</p> <p>If the table uses <code class="code">==/2</code> when comparing keys for equality, the <code class="code">qlc</code> module will look up the constant regardless of which operator is used in the QLC. However, <code class="code">==/2</code> is to be preferred:</p> <div class="example"><pre>
4&gt; E3 = ets:new(t, [ordered_set]), % uses ==/2 for key equality
true = ets:insert(E3, [{{2,2.0},b}]),
F3 = fun(I) -&gt;
qlc:q([V || {K,V} &lt;- ets:table(E3), K == I])
end,
Q3 = F3({2,2}),
io:format("~s~n", [qlc:info(Q3)]).
ets:match_spec_run(ets:lookup(86033, {2,2}),
                   ets:match_spec_compile([{{'$1','$2'},[],['$2']}]))
5&gt; qlc:e(Q3).
[b]</pre></div> <p>Lookup join is handled analogously to lookup of constants in a table: if the join operator is <code class="code">==/2</code> and the table where constants are to be looked up uses <code class="code">=:=/2</code> when testing keys for equality, the <code class="code">qlc</code> module will not consider lookup join for that table.</p>  <h2>Data types</h2> <h3 class="code">abstract_expr() = <a href="../erl_parse/#type-abstract_expr">erl_parse:abstract_expr()</a>
</h3> 
<p>Parse trees for Erlang expression, see the <code class="bold_code">abstract format</code> documentation in the ERTS User's Guide.</p> <h3 class="code">answer() = term()</h3> <h3 class="code">answers() = [<a href="#type-answer">answer()</a>]</h3> <h3 class="code">cache() = ets | list | no</h3> <h3 class="code">match_expression() = <a href="../ets/#type-match_spec">ets:match_spec()</a>
</h3> 
<p>Match specification, see the <code class="bold_code">match specification</code> documentation in the ERTS User's Guide and <code class="bold_code"><a href="../ms_transform/">ms_transform(3).</a></code></p> <h3 class="code">no_files() = integer() &gt;= 1</h3> 
<p>Actually an integer &gt; 1.</p> <h3 class="code">key_pos() = integer() &gt;= 1 | [integer() &gt;= 1]</h3> <h3 class="code">max_list_size() = integer() &gt;= 0</h3> <h3 class="code">order() = ascending | descending | <a href="#type-order_fun">order_fun()</a>
</h3> <h3 class="code">order_fun() = fun((term(), term()) -&gt; boolean())</h3> <h3 class="code">query_cursor()</h3> 
<p>A <code class="bold_code"><a href="#query_cursor">query cursor</a></code>.</p>  <h3 class="code">query_handle()</h3> 
<p>A <code class="bold_code"><a href="#query_handle">query handle</a></code>.</p>  <h3 class="code">query_handle_or_list() = <a href="#type-query_handle">query_handle()</a> | list()</h3> <h3 class="code">query_list_comprehension() = term()</h3> 
<p>A literal <code class="bold_code"><a href="#query_list_comprehension">query list comprehension</a></code>.</p> <h3 class="code">spawn_options() = default | [<a href="../proc_lib/#type-spawn_option">proc_lib:spawn_option()</a>]</h3> <h3 class="code">sort_options() = [<a href="#type-sort_option">sort_option()</a>] | <a href="#type-sort_option">sort_option()</a>
</h3> <h3 class="code">sort_option() = <br>    {compressed, boolean()} |<br>    {no_files, <a href="#type-no_files">no_files()</a>} |<br>    {order, <a href="#type-order">order()</a>} |<br>    {size, integer() &gt;= 1} |<br>    {tmpdir, <a href="#type-tmp_directory">tmp_directory()</a>} |<br>    {unique, boolean()}</h3> 
<p>See <code class="bold_code"><a href="../file_sorter/">file_sorter(3)</a></code>.</p> <h3 class="code">tmp_directory() = [] | file:name()</h3> <h3 class="code">tmp_file_usage() = <br>    allowed | not_allowed | info_msg | warning_msg | error_msg</h3> <h2>Exports</h2> <h3 id="append-1" class="code">append(QHL) -&gt; QH</h3> <p>Types:</p>    <pre>QHL = [<a href="#type-query_handle_or_list">query_handle_or_list()</a>]
QH = <a href="#type-query_handle">query_handle()</a></pre>

<p>Returns a query handle. When evaluating the query handle <code class="code">QH</code> all answers to the first query handle in <code class="code">QHL</code> are returned followed by all answers to the rest of the query handles in <code class="code">QHL</code>.</p>  <h3 id="append-2" class="code">append(QH1, QH2) -&gt; QH3</h3> <p>Types:</p>     <pre>QH1 = QH2 = <a href="#type-query_handle_or_list">query_handle_or_list()</a>

QH3 = <a href="#type-query_handle">query_handle()</a></pre>

<p>Returns a query handle. When evaluating the query handle <code class="code">QH3</code> all answers to <code class="code">QH1</code> are returned followed by all answers to <code class="code">QH2</code>.</p> <p><code class="code">append(QH1, QH2)</code> is equivalent to <code class="code">append([QH1, QH2])</code>.</p>  <h3 id="cursor-2" class="code">cursor(QH) -&gt; Cursor<br>cursor(QH, Options) -&gt; Cursor</h3> <p>Types:</p>      <pre>QH = <a href="#type-query_handle_or_list">query_handle_or_list()</a>
Options = [Option] | Option
Option = 
    {cache_all, <a href="#type-cache">cache()</a>} |
    cache_all |
    {max_list_size, <a href="#type-max_list_size">max_list_size()</a>} |
    {spawn_options, <a href="#type-spawn_options">spawn_options()</a>} |
    {tmpdir_usage, <a href="#type-tmp_file_usage">tmp_file_usage()</a>} |
    {tmpdir, <a href="#type-tmp_directory">tmp_directory()</a>} |
    {unique_all, boolean()} |
    unique_all
Cursor = <a href="#type-query_cursor">query_cursor()</a></pre>

<p id="cursor">Creates a query cursor and makes the calling process the owner of the cursor. The cursor is to be used as argument to <code class="code">next_answers/1,2</code> and (eventually) <code class="code">delete_cursor/1</code>. Calls <code class="code">erlang:spawn_opt</code> to spawn and link a process which will evaluate the query handle. The value of the option <code class="code">spawn_options</code> is used as last argument when calling <code class="code">spawn_opt</code>. The default value is <code class="code">[link]</code>.</p> <div class="example"><pre>
1&gt; QH = qlc:q([{X,Y} || X &lt;- [a,b], Y &lt;- [1,2]]),
QC = qlc:cursor(QH),
qlc:next_answers(QC, 1).
[{a,1}]
2&gt; qlc:next_answers(QC, 1).
[{a,2}]
3&gt; qlc:next_answers(QC, all_remaining).
[{b,1},{b,2}]
4&gt; qlc:delete_cursor(QC).
ok</pre></div> <p><code class="code">cursor(QH)</code> is equivalent to <code class="code">cursor(QH, [])</code>.</p>  <h3 id="delete_cursor-1" class="code">delete_cursor(QueryCursor) -&gt; ok</h3> <p>Types:</p>   <pre>QueryCursor = <a href="#type-query_cursor">query_cursor()</a></pre>

<p>Deletes a query cursor. Only the owner of the cursor can delete the cursor.</p>  <h3 id="e-2" class="code">eval(QH) -&gt; Answers | Error<br>eval(QH, Options) -&gt; Answers | Error<br>e(QH) -&gt; Answers | Error<br>e(QH, Options) -&gt; Answers | Error</h3> <p>Types:</p>        <pre>QH = <a href="#type-query_handle_or_list">query_handle_or_list()</a>
Options = [Option] | Option
Option = 
    {cache_all, <a href="#type-cache">cache()</a>} |
    cache_all |
    {max_list_size, <a href="#type-max_list_size">max_list_size()</a>} |
    {tmpdir_usage, <a href="#type-tmp_file_usage">tmp_file_usage()</a>} |
    {tmpdir, <a href="#type-tmp_directory">tmp_directory()</a>} |
    {unique_all, boolean()} |
    unique_all
Answers = <a href="#type-answers">answers()</a>
Error = {error, module(), Reason}
Reason = <a href="../file_sorter/#type-reason">file_sorter:reason()</a></pre>

<p id="eval">Evaluates a query handle in the calling process and collects all answers in a list.</p> <div class="example"><pre>
1&gt; QH = qlc:q([{X,Y} || X &lt;- [a,b], Y &lt;- [1,2]]),
qlc:eval(QH).
[{a,1},{a,2},{b,1},{b,2}]</pre></div> <p><code class="code">eval(QH)</code> is equivalent to <code class="code">eval(QH, [])</code>.</p>  <h3 id="fold-4" class="code">fold(Function, Acc0, QH) -&gt; Acc1 | Error<br>fold(Function, Acc0, QH, Options) -&gt; Acc1 | Error</h3> <p>Types:</p>            <pre>QH = <a href="#type-query_handle_or_list">query_handle_or_list()</a>
Function = fun((<a href="#type-answer">answer()</a>, AccIn) -&gt; AccOut)
Acc0 = Acc1 = AccIn = AccOut = term()



Options = [Option] | Option
Option = 
    {cache_all, <a href="#type-cache">cache()</a>} |
    cache_all |
    {max_list_size, <a href="#type-max_list_size">max_list_size()</a>} |
    {tmpdir_usage, <a href="#type-tmp_file_usage">tmp_file_usage()</a>} |
    {tmpdir, <a href="#type-tmp_directory">tmp_directory()</a>} |
    {unique_all, boolean()} |
    unique_all
Error = {error, module(), Reason}
Reason = <a href="../file_sorter/#type-reason">file_sorter:reason()</a></pre>

<p>Calls <code class="code">Function</code> on successive answers to the query handle together with an extra argument <code class="code">AccIn</code>. The query handle and the function are evaluated in the calling process. <code class="code">Function</code> must return a new accumulator which is passed to the next call. <code class="code">Acc0</code> is returned if there are no answers to the query handle.</p> <div class="example"><pre>
1&gt; QH = [1,2,3,4,5,6],
qlc:fold(fun(X, Sum) -&gt; X + Sum end, 0, QH).
21</pre></div> <p><code class="code">fold(Function, Acc0, QH)</code> is equivalent to <code class="code">fold(Function, Acc0, QH, [])</code>.</p>  <h3 id="format_error-1" class="code">format_error(Error) -&gt; Chars</h3> <p>Types:</p>    <pre>Error = {error, module(), term()}
Chars = <a href="../io_lib/#type-chars">io_lib:chars()</a></pre>

<p>Returns a descriptive string in English of an error tuple returned by some of the functions of the <code class="code">qlc</code> module or the parse transform. This function is mainly used by the compiler invoking the parse transform.</p>  <h3 id="info-2" class="code">info(QH) -&gt; Info<br>info(QH, Options) -&gt; Info</h3> <p>Types:</p>           <pre>QH = <a href="#type-query_handle_or_list">query_handle_or_list()</a>
Options = [Option] | Option
Option = EvalOption | ReturnOption
EvalOption = 
    {cache_all, <a href="#type-cache">cache()</a>} |
    cache_all |
    {max_list_size, <a href="#type-max_list_size">max_list_size()</a>} |
    {tmpdir_usage, <a href="#type-tmp_file_usage">tmp_file_usage()</a>} |
    {tmpdir, <a href="#type-tmp_directory">tmp_directory()</a>} |
    {unique_all, boolean()} |
    unique_all
ReturnOption = 
    {depth, Depth} |
    {flat, boolean()} |
    {format, Format} |
    {n_elements, NElements}
Depth = infinity | integer() &gt;= 0
Format = abstract_code | string
NElements = infinity | integer() &gt;= 1
Info = <a href="#type-abstract_expr">abstract_expr()</a> | string()</pre>

<p id="info">Returns information about a query handle. The information describes the simplifications and optimizations that are the results of preparing the query for evaluation. This function is probably useful mostly during debugging.</p> <p>The information has the form of an Erlang expression where QLCs most likely occur. Depending on the format functions of mentioned QLC tables it may not be absolutely accurate.</p> <p>The default is to return a sequence of QLCs in a block, but if the option <code class="code">{flat, false}</code> is given, one single QLC is returned. The default is to return a string, but if the option <code class="code">{format, abstract_code}</code> is given, abstract code is returned instead. In the abstract code port identifiers, references, and pids are represented by strings. The default is to return all elements in lists, but if the <code class="code">{n_elements, NElements}</code> option is given, only a limited number of elements are returned. The default is to show all of objects and match specifications, but if the <code class="code">{depth, Depth}</code> option is given, parts of terms below a certain depth are replaced by <code class="code">'...'</code>.</p> <div class="example"><pre>
1&gt; QH = qlc:q([{X,Y} || X &lt;- [x,y], Y &lt;- [a,b]]),
io:format("~s~n", [qlc:info(QH, unique_all)]).
begin
    V1 =
        qlc:q([
               SQV ||
                   SQV &lt;- [x,y]
              ],
              [{unique,true}]),
    V2 =
        qlc:q([
               SQV ||
                   SQV &lt;- [a,b]
              ],
              [{unique,true}]),
    qlc:q([
           {X,Y} ||
               X &lt;- V1,
               Y &lt;- V2
          ],
          [{unique,true}])
end</pre></div> <p>In this example two simple QLCs have been inserted just to hold the <code class="code">{unique, true}</code> option.</p> <div class="example"><pre>
1&gt; E1 = ets:new(e1, []),
E2 = ets:new(e2, []),
true = ets:insert(E1, [{1,a},{2,b}]),
true = ets:insert(E2, [{a,1},{b,2}]),
Q = qlc:q([{X,Z,W} ||
{X, Z} &lt;- ets:table(E1),
{W, Y} &lt;- ets:table(E2),
X =:= Y]),
io:format("~s~n", [qlc:info(Q)]).
begin
    V1 =
        qlc:q([
               P0 ||
                   P0 = {W,Y} &lt;- ets:table(17)
              ]),
    V2 =
        qlc:q([
               [G1|G2] ||
                   G2 &lt;- V1,
                   G1 &lt;- ets:table(16),
                   element(2, G1) =:= element(1, G2)
              ],
              [{join,lookup}]),
    qlc:q([
           {X,Z,W} ||
               [{X,Z}|{W,Y}] &lt;- V2
          ])
end</pre></div> <p>In this example the query list comprehension <code class="code">V2</code> has been inserted to show the joined generators and the join method chosen. A convention is used for lookup join: the first generator (<code class="code">G2</code>) is the one traversed, the second one (<code class="code">G1</code>) is the table where constants are looked up.</p> <p><code class="code">info(QH)</code> is equivalent to <code class="code">info(QH, [])</code>.</p>  <h3 id="keysort-3" class="code">keysort(KeyPos, QH1) -&gt; QH2<br>keysort(KeyPos, QH1, SortOptions) -&gt; QH2</h3> <p>Types:</p>      <pre>KeyPos = <a href="#type-key_pos">key_pos()</a>
SortOptions = <a href="#type-sort_options">sort_options()</a>
QH1 = <a href="#type-query_handle_or_list">query_handle_or_list()</a>
QH2 = <a href="#type-query_handle">query_handle()</a></pre>

<p>Returns a query handle. When evaluating the query handle <code class="code">QH2</code> the answers to the query handle <code class="code">QH1</code> are sorted by <code class="bold_code"><a href="../file_sorter/">file_sorter:keysort/4</a></code> according to the options.</p> <p>The sorter will use temporary files only if <code class="code">QH1</code> does not evaluate to a list and the size of the binary representation of the answers exceeds <code class="code">Size</code> bytes, where <code class="code">Size</code> is the value of the <code class="code">size</code> option.</p> <p><code class="code">keysort(KeyPos, QH1)</code> is equivalent to <code class="code">keysort(KeyPos, QH1, [])</code>.</p>  <h3 id="next_answers-2" class="code">next_answers(QueryCursor) -&gt; Answers | Error<br>next_answers(QueryCursor, NumberOfAnswers) -&gt; Answers | Error</h3> <p>Types:</p>       <pre>QueryCursor = <a href="#type-query_cursor">query_cursor()</a>
Answers = <a href="#type-answers">answers()</a>
NumberOfAnswers = all_remaining | integer() &gt;= 1
Error = {error, module(), Reason}
Reason = <a href="../file_sorter/#type-reason">file_sorter:reason()</a></pre>

<p>Returns some or all of the remaining answers to a query cursor. Only the owner of <code class="code">QueryCursor</code> can retrieve answers.</p> <p>The optional argument <code class="code">NumberOfAnswers</code>determines the maximum number of answers returned. The default value is <code class="code">10</code>. If less than the requested number of answers is returned, subsequent calls to <code class="code">next_answers</code> will return <code class="code">[]</code>.</p>  <h3 id="q-2" class="code">q(QLC) -&gt; QH<br>q(QLC, Options) -&gt; QH</h3> <p>Types:</p>         <pre>QH = <a href="#type-query_handle">query_handle()</a>
Options = [Option] | Option
Option = 
    {max_lookup, MaxLookup} |
    {cache, <a href="#type-cache">cache()</a>} |
    cache |
    {join, Join} |
    {lookup, Lookup} |
    {unique, boolean()} |
    unique
MaxLookup = integer() &gt;= 0 | infinity
Join = any | lookup | merge | nested_loop
Lookup = boolean() | any
QLC = <a href="#type-query_list_comprehension">query_list_comprehension()</a></pre>

<p id="q">Returns a query handle for a query list comprehension. The query list comprehension must be the first argument to <code class="code">qlc:q/1,2</code> or it will be evaluated as an ordinary list comprehension. It is also necessary to add the line</p> <div class="example"><pre>
-include_lib("stdlib/include/qlc.hrl").</pre></div> <p>to the source file. This causes a parse transform to substitute a fun for the query list comprehension. The (compiled) fun will be called when the query handle is evaluated.</p> <p>When calling <code class="code">qlc:q/1,2</code> from the Erlang shell the parse transform is automatically called. When this happens the fun substituted for the query list comprehension is not compiled but will be evaluated by <code class="code">erl_eval(3)</code>. This is also true when expressions are evaluated by means of <code class="code">file:eval/1,2</code> or in the debugger.</p> <p>To be very explicit, this will not work:</p> <div class="example"><pre>
...
A = [X || {X} &lt;- [{1},{2}]],
QH = qlc:q(A),
...</pre></div> <p>The variable <code class="code">A</code> will be bound to the evaluated value of the list comprehension (<code class="code">[1,2]</code>). The compiler complains with an error message ("argument is not a query list comprehension"); the shell process stops with a <code class="code">badarg</code> reason.</p> <p><code class="code">q(QLC)</code> is equivalent to <code class="code">q(QLC, [])</code>.</p> <p>The <code class="code">{cache, ets}</code> option can be used to cache the answers to a query list comprehension. The answers are stored in one ETS table for each cached query list comprehension. When a cached query list comprehension is evaluated again, answers are fetched from the table without any further computations. As a consequence, when all answers to a cached query list comprehension have been found, the ETS tables used for caching answers to the query list comprehension's qualifiers can be emptied. The option <code class="code">cache</code> is equivalent to <code class="code">{cache, ets}</code>.</p> <p>The <code class="code">{cache, list}</code> option can be used to cache the answers to a query list comprehension just like <code class="code">{cache, ets}</code>. The difference is that the answers are kept in a list (on the process heap). If the answers would occupy more than a certain amount of RAM memory a temporary file is used for storing the answers. The option <code class="code">max_list_size</code> sets the limit in bytes and the temporary file is put on the directory set by the <code class="code">tmpdir</code> option.</p> <p>The <code class="code">cache</code> option has no effect if it is known that the query list comprehension will be evaluated at most once. This is always true for the top-most query list comprehension and also for the list expression of the first generator in a list of qualifiers. Note that in the presence of side effects in filters or callback functions the answers to query list comprehensions can be affected by the <code class="code">cache</code> option.</p> <p>The <code class="code">{unique, true}</code> option can be used to remove duplicate answers to a query list comprehension. The unique answers are stored in one ETS table for each query list comprehension. The table is emptied every time it is known that there are no more answers to the query list comprehension. The option <code class="code">unique</code> is equivalent to <code class="code">{unique, true}</code>. If the <code class="code">unique</code> option is combined with the <code class="code">{cache, ets}</code> option, two ETS tables are used, but the full answers are stored in one table only. If the <code class="code">unique</code> option is combined with the <code class="code">{cache, list}</code> option the answers are sorted twice using <code class="code">keysort/3</code>; once to remove duplicates, and once to restore the order.</p> <p>The <code class="code">cache</code> and <code class="code">unique</code> options apply not only to the query list comprehension itself but also to the results of looking up constants, running match specifications, and joining handles. </p> <div class="example"><pre>
1&gt; Q = qlc:q([{A,X,Z,W} ||
A &lt;- [a,b,c],
{X,Z} &lt;- [{a,1},{b,4},{c,6}],
{W,Y} &lt;- [{2,a},{3,b},{4,c}],
X =:= Y],
{cache, list}),
io:format("~s~n", [qlc:info(Q)]).
begin
    V1 =
        qlc:q([
               P0 ||
                   P0 = {X,Z} &lt;-
                       qlc:keysort(1, [{a,1},{b,4},{c,6}], [])
              ]),
    V2 =
        qlc:q([
               P0 ||
                   P0 = {W,Y} &lt;-
                       qlc:keysort(2, [{2,a},{3,b},{4,c}], [])
              ]),
    V3 =
        qlc:q([
               [G1|G2] ||
                   G1 &lt;- V1,
                   G2 &lt;- V2,
                   element(1, G1) == element(2, G2)
              ],
              [{join,merge},{cache,list}]),
    qlc:q([
           {A,X,Z,W} ||
               A &lt;- [a,b,c],
               [{X,Z}|{W,Y}] &lt;- V3,
               X =:= Y
          ])
end</pre></div> <p>In this example the cached results of the merge join are traversed for each value of <code class="code">A</code>. Note that without the <code class="code">cache</code> option the join would have been carried out three times, once for each value of <code class="code">A</code></p> <p><code class="code">sort/1,2</code> and <code class="code">keysort/2,3</code> can also be used for caching answers and for removing duplicates. When sorting answers are cached in a list, possibly stored on a temporary file, and no ETS tables are used.</p> <p id="max_lookup">Sometimes (see <code class="bold_code"><a href="#lookup_fun">qlc:table/2</a></code> below) traversal of tables can be done by looking up key values, which is assumed to be fast. Under certain (rare) circumstances it could happen that there are too many key values to look up.  The <code class="code">{max_lookup, MaxLookup}</code> option can then be used to limit the number of lookups: if more than <code class="code">MaxLookup</code> lookups would be required no lookups are done but the table traversed instead. The default value is <code class="code">infinity</code> which means that there is no limit on the number of keys to look up.</p> <div class="example"><pre>
1&gt; T = gb_trees:empty(),
QH = qlc:q([X || {{X,Y},_} &lt;- gb_table:table(T),
((X == 1) or (X == 2)) andalso
((Y == a) or (Y == b) or (Y == c))]),
io:format("~s~n", [qlc:info(QH)]).
ets:match_spec_run(
       lists:flatmap(fun(K) -&gt;
                            case
                                gb_trees:lookup(K,
                                                gb_trees:from_orddict([]))
                            of
                                {value,V} -&gt;
                                    [{K,V}];
                                none -&gt;
                                    []
                            end
                     end,
                     [{1,a},{1,b},{1,c},{2,a},{2,b},{2,c}]),
       ets:match_spec_compile([{{{'$1','$2'},'_'},[],['$1']}]))</pre></div> <p>In this example using the <code class="code">gb_table</code> module from the <code class="bold_code"><a href="#implementing_a_qlc_table">Implementing a QLC table</a></code> section there are six keys to look up: <code class="code">{1,a}</code>, <code class="code">{1,b}</code>, <code class="code">{1,c}</code>, <code class="code">{2,a}</code>, <code class="code">{2,b}</code>, and <code class="code">{2,c}</code>. The reason is that the two elements of the key {X, Y} are compared separately.</p> <p>The <code class="code">{lookup, true}</code> option can be used to ensure that the <code class="code">qlc</code> module will look up constants in some QLC table. If there are more than one QLC table among the generators' list expressions, constants have to be looked up in at least one of the tables. The evaluation of the query fails if there are no constants to look up. This option is useful in situations when it would be unacceptable to traverse all objects in some table. Setting the <code class="code">lookup</code> option to <code class="code">false</code> ensures that no constants will be looked up (<code class="code">{max_lookup, 0}</code> has the same effect). The default value is <code class="code">any</code> which means that constants will be looked up whenever possible.</p> <p>The <code class="code">{join, Join}</code> option can be used to ensure that a certain join method will be used: <code class="code">{join, lookup}</code> invokes the lookup join method; <code class="code">{join, merge}</code> invokes the merge join method; and <code class="code">{join, nested_loop}</code> invokes the method of matching every pair of objects from two handles. The last method is mostly very slow. The evaluation of the query fails if the <code class="code">qlc</code> module cannot carry out the chosen join method. The default value is <code class="code">any</code> which means that some fast join method will be used if possible.</p>  <h3 id="sort-2" class="code">sort(QH1) -&gt; QH2<br>sort(QH1, SortOptions) -&gt; QH2</h3> <p>Types:</p>     <pre>SortOptions = <a href="#type-sort_options">sort_options()</a>
QH1 = <a href="#type-query_handle_or_list">query_handle_or_list()</a>
QH2 = <a href="#type-query_handle">query_handle()</a></pre>

<p>Returns a query handle. When evaluating the query handle <code class="code">QH2</code> the answers to the query handle <code class="code">QH1</code> are sorted by <code class="bold_code"><a href="../file_sorter/">file_sorter:sort/3</a></code> according to the options.</p> <p>The sorter will use temporary files only if <code class="code">QH1</code> does not evaluate to a list and the size of the binary representation of the answers exceeds <code class="code">Size</code> bytes, where <code class="code">Size</code> is the value of the <code class="code">size</code> option.</p> <p><code class="code">sort(QH1)</code> is equivalent to <code class="code">sort(QH1, [])</code>.</p>  <h3 id="string_to_handle-3" class="code">string_to_handle(QueryString) -&gt; QH | Error<br>string_to_handle(QueryString, Options) -&gt; QH | Error<br>string_to_handle(QueryString, Options, Bindings) -&gt; QH | Error</h3> <p>Types:</p>            <pre>QueryString = string()
Options = [Option] | Option
Option = 
    {max_lookup, MaxLookup} |
    {cache, <a href="#type-cache">cache()</a>} |
    cache |
    {join, Join} |
    {lookup, Lookup} |
    {unique, boolean()} |
    unique
MaxLookup = integer() &gt;= 0 | infinity
Join = any | lookup | merge | nested_loop
Lookup = boolean() | any
Bindings = <a href="../erl_eval/#type-binding_struct">erl_eval:binding_struct()</a>
QH = <a href="#type-query_handle">query_handle()</a>
Error = {error, module(), Reason}
Reason = <a href="../erl_parse/#type-error_info">erl_parse:error_info()</a> | <a href="../erl_scan/#type-error_info">erl_scan:error_info()</a></pre>

<p>A string version of <code class="code">qlc:q/1,2</code>. When the query handle is evaluated the fun created by the parse transform is interpreted by <code class="code">erl_eval(3)</code>. The query string is to be one single query list comprehension terminated by a period.</p> <div class="example"><pre>
1&gt; L = [1,2,3],
Bs = erl_eval:add_binding('L', L, erl_eval:new_bindings()),
QH = qlc:string_to_handle("[X+1 || X &lt;- L].", [], Bs),
qlc:eval(QH).
[2,3,4]</pre></div> <p><code class="code">string_to_handle(QueryString)</code> is equivalent to <code class="code">string_to_handle(QueryString, [])</code>.</p> <p><code class="code">string_to_handle(QueryString, Options)</code> is equivalent to <code class="code">string_to_handle(QueryString, Options, erl_eval:new_bindings())</code>.</p> <p>This function is probably useful mostly when called from outside of Erlang, for instance from a driver written in C.</p>  <h3 id="table-2" class="code">table(TraverseFun, Options) -&gt; QH</h3> <p>Types:</p>                                  <pre>TraverseFun = TraverseFun0 | TraverseFun1
TraverseFun0 = fun(() -&gt; TraverseResult)
TraverseFun1 = fun((<a href="#type-match_expression">match_expression()</a>) -&gt; TraverseResult)
TraverseResult = Objects | term()
Objects = [] | [term() | ObjectList]
ObjectList = TraverseFun0 | Objects
Options = [Option] | Option
Option = 
    {format_fun, FormatFun} |
    {info_fun, InfoFun} |
    {lookup_fun, LookupFun} |
    {parent_fun, ParentFun} |
    {post_fun, PostFun} |
    {pre_fun, PreFun} |
    {key_equality, KeyComparison}
FormatFun = undefined | fun((SelectedObjects) -&gt; FormatedTable)
SelectedObjects = 
    all |
    {all, NElements, DepthFun} |
    {match_spec, <a href="#type-match_expression">match_expression()</a>} |
    {lookup, Position, Keys} |
    {lookup, Position, Keys, NElements, DepthFun}
NElements = infinity | integer() &gt;= 1
DepthFun = fun((term()) -&gt; term())
FormatedTable = {Mod, Fun, Args} | <a href="#type-abstract_expr">abstract_expr()</a> | string()
InfoFun = undefined | fun((InfoTag) -&gt; InfoValue)
InfoTag = indices | is_unique_objects | keypos | num_of_objects
InfoValue = undefined | term()
LookupFun = undefined | fun((Position, Keys) -&gt; LookupResult)
LookupResult = [term()] | term()
ParentFun = undefined | fun(() -&gt; ParentFunValue)
PostFun = undefined | fun(() -&gt; term())
PreFun = undefined | fun((PreArgs) -&gt; term())
PreArgs = [PreArg]
PreArg = {parent_value, ParentFunValue} | {stop_fun, StopFun}
ParentFunValue = undefined | term()
StopFun = undefined | fun(() -&gt; term())
KeyComparison = '=:=' | '=='
Position = integer() &gt;= 1
Keys = [term()]
Mod = Fun = atom()

Args = [term()]
QH = <a href="#type-query_handle">query_handle()</a></pre>

<p id="table">Returns a query handle for a QLC table. In Erlang/OTP there is support for ETS, Dets and Mnesia tables, but it is also possible to turn many other data structures into QLC tables. The way to accomplish this is to let function(s) in the module implementing the data structure create a query handle by calling <code class="code">qlc:table/2</code>. The different ways to traverse the table as well as properties of the table are handled by callback functions provided as options to <code class="code">qlc:table/2</code>.</p> <p>The callback function <code class="code">TraverseFun</code> is used for traversing the table. It is to return a list of objects terminated by either <code class="code">[]</code> or a nullary fun to be used for traversing the not yet traversed objects of the table. Any other return value is immediately returned as value of the query evaluation. Unary <code class="code">TraverseFun</code>s are to accept a match specification as argument. The match specification is created by the parse transform by analyzing the pattern of the generator calling <code class="code">qlc:table/2</code> and filters using variables introduced in the pattern. If the parse transform cannot find a match specification equivalent to the pattern and filters, <code class="code">TraverseFun</code> will be called with a match specification returning every object. Modules that can utilize match specifications for optimized traversal of tables should call <code class="code">qlc:table/2</code> with a unary <code class="code">TraverseFun</code> while other modules can provide a nullary <code class="code">TraverseFun</code>. <code class="code">ets:table/2</code> is an example of the former; <code class="code">gb_table:table/1</code> in the <code class="bold_code"><a href="#implementing_a_qlc_table">Implementing a QLC table</a></code> section is an example of the latter.</p> <p><code class="code">PreFun</code> is a unary callback function that is called once before the table is read for the first time. If the call fails, the query evaluation fails. Similarly, the nullary callback function <code class="code">PostFun</code> is called once after the table was last read. The return value, which is caught, is ignored. If <code class="code">PreFun</code> has been called for a table, <code class="code">PostFun</code> is guaranteed to be called for that table, even if the evaluation of the query fails for some reason. The order in which pre (post) functions for different tables are evaluated is not specified. Other table access than reading, such as calling <code class="code">InfoFun</code>, is assumed to be OK at any time. The argument <code class="code">PreArgs</code> is a list of tagged values. Currently there are two tags, <code class="code">parent_value</code> and <code class="code">stop_fun</code>, used by Mnesia for managing transactions. The value of <code class="code">parent_value</code> is the value returned by <code class="code">ParentFun</code>, or <code class="code">undefined</code> if there is no <code class="code">ParentFun</code>. <code class="code">ParentFun</code> is called once just before the call of <code class="code">PreFun</code> in the context of the process calling <code class="code">eval</code>, <code class="code">fold</code>, or <code class="code">cursor</code>. The value of <code class="code">stop_fun</code> is a nullary fun that deletes the cursor if called from the parent, or <code class="code">undefined</code> if there is no cursor.</p> <p id="lookup_fun">The binary callback function <code class="code">LookupFun</code> is used for looking up objects in the table. The first argument <code class="code">Position</code> is the key position or an indexed position and the second argument <code class="code">Keys</code> is a sorted list of unique values. The return value is to be a list of all objects (tuples) such that the element at <code class="code">Position</code> is a member of <code class="code">Keys</code>. Any other return value is immediately returned as value of the query evaluation. <code class="code">LookupFun</code> is called instead of traversing the table if the parse transform at compile time can find out that the filters match and compare the element at <code class="code">Position</code> in such a way that only <code class="code">Keys</code> need to be looked up in order to find all potential answers. The key position is obtained by calling <code class="code">InfoFun(keypos)</code> and the indexed positions by calling <code class="code">InfoFun(indices)</code>. If the key position can be used for lookup it is always chosen, otherwise the indexed position requiring the least number of lookups is chosen. If there is a tie between two indexed positions the one occurring first in the list returned by <code class="code">InfoFun</code> is chosen. Positions requiring more than <code class="bold_code"><a href="#max_lookup">max_lookup</a></code> lookups are ignored.</p> <p>The unary callback function <code class="code">InfoFun</code> is to return information about the table. <code class="code">undefined</code> should be returned if the value of some tag is unknown:</p> <ul> <li> <code class="code">indices</code>. Returns a list of indexed positions, a list of positive integers. </li> <li> <code class="code">is_unique_objects</code>. Returns <code class="code">true</code> if the objects returned by <code class="code">TraverseFun</code> are unique. </li> <li> <code class="code">keypos</code>. Returns the position of the table's key, a positive integer. </li> <li> <code class="code">is_sorted_key</code>. Returns <code class="code">true</code> if the objects returned by <code class="code">TraverseFun</code> are sorted on the key. </li> <li> <code class="code">num_of_objects</code>. Returns the number of objects in the table, a non-negative integer. </li> </ul> <p>The unary callback function <code class="code">FormatFun</code> is used by <code class="bold_code"><a href="#info">qlc:info/1,2</a></code> for displaying the call that created the table's query handle. The default value, <code class="code">undefined</code>, means that <code class="code">info/1,2</code> displays a call to <code class="code">'$MOD':'$FUN'/0</code>. It is up to <code class="code">FormatFun</code> to present the selected objects of the table in a suitable way. However, if a character list is chosen for presentation it must be an Erlang expression that can be scanned and parsed (a trailing dot will be added by <code class="code">qlc:info</code> though). <code class="code">FormatFun</code> is called with an argument that describes the selected objects based on optimizations done as a result of analyzing the filters of the QLC where the call to <code class="code">qlc:table/2</code> occurs. The possible values of the argument are:</p> <ul> <li> <code class="code">{lookup, Position, Keys, NElements, DepthFun}</code>. <code class="code">LookupFun</code> is used for looking up objects in the table. </li> <li> <code class="code">{match_spec, MatchExpression}</code>. No way of finding all possible answers by looking up keys was found, but the filters could be transformed into a match specification. All answers are found by calling <code class="code">TraverseFun(MatchExpression)</code>. </li> <li> <code class="code">{all, NElements, DepthFun}</code>. No optimization was found. A match specification matching all objects will be used if <code class="code">TraverseFun</code> is unary. </li> </ul> <p><code class="code">NElements</code> is the value of the <code class="code">info/1,2</code> option <code class="code">n_elements</code>, and <code class="code">DepthFun</code> is a function that can be used for limiting the size of terms; calling <code class="code">DepthFun(Term)</code> substitutes <code class="code">'...'</code> for parts of <code class="code">Term</code> below the depth specified by the <code class="code">info/1,2</code> option <code class="code">depth</code>. If calling <code class="code">FormatFun</code> with an argument including <code class="code">NElements</code> and <code class="code">DepthFun</code> fails, <code class="code">FormatFun</code> is called once again with an argument excluding <code class="code">NElements</code> and <code class="code">DepthFun</code> (<code class="code">{lookup, Position, Keys}</code> or <code class="code">all</code>).</p> <p id="key_equality">The value of <code class="code">key_equality</code> is to be <code class="code">'=:='</code> if the table considers two keys equal if they match, and to be <code class="code">'=='</code> if two keys are equal if they compare equal. The default is <code class="code">'=:='</code>.</p> <p>See <code class="bold_code"><a href="../ets/#qlc_table">ets(3)</a></code>, <code class="bold_code"><a href="../dets/#qlc_table">dets(3)</a></code> and <code class="bold_code">mnesia(3)</code> for the various options recognized by <code class="code">table/1,2</code> in respective module.</p>  <h2 id="id221657">See Also</h2>  <p><code class="bold_code"><a href="../dets/">dets(3)</a></code>, <code class="bold_code"> Erlang Reference Manual</code>, <code class="bold_code"><a href="../erl_eval/">erl_eval(3)</a></code>, <code class="bold_code">erlang(3)</code>, <code class="bold_code"><a href="../ets/">ets(3)</a></code>, <code class="bold_code">file(3)</code>, <code class="bold_code">error_logger(3)</code>, <code class="bold_code"><a href="../file_sorter/">file_sorter(3)</a></code>, <code class="bold_code">mnesia(3)</code>, <code class="bold_code"> Programming Examples</code>, <code class="bold_code"><a href="../shell/">shell(3)</a></code></p>
<div class="_attribution">
  <p class="_attribution-p">
    © 1999–2016 Ericsson AB<br>Licensed under the Apache License, Version 2.0.<br>
    
  </p>
</div>

			</div>
		</div>
	</section>

	</div>
</body>
</html>
