
<!DOCTYPE HTML>

<html lang="en">

<head>
  <meta charset="utf-8">
  <title>Erl_parse - Erlang 18 - W3cubDocs</title>
  
  <meta name="description" content=" erl_parse ">
  <meta name="keywords" content="erl, parse, -, erlang, erlang~18">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="http://docs.w3cub.com/erlang~18/lib/stdlib-2.8/doc/html/erl_parse/">
  <link href="/favicon.png" rel="icon">
  <link type="text/css" rel="stylesheet" href="/assets/application-50364fff564ce3b6327021805f3f00e2957b441cf27f576a7dd4ff63bbc47047.css">
  <script type="text/javascript" src="/assets/application-db64bfd54ceb42be11af7995804cf4902548419ceb79d509b0b7d62c22d98e6f.js"></script>
  <script src="/json/erlang~18.js"></script>
  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-71174418-1']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>


</head>

<body>
	<div class="_app">
	<header class="_header">
  
  <form class="_search">
    <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
    <a class="_search-clear"></a>
    <div class="_search-tag"></div>
  </form>
  
  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/erlang~18/" class="_nav-link" title="" style="margin-left:0;">Erlang 18</a></span>
  
  <nav class="_nav">
    <a href="/app/" class="_nav-link ">App</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		<div class="_list">
			
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<div class="_page _erlang">
				
<h1>erl_parse</h1> <h2>Module</h2> <p class="REFBODY">erl_parse</p> <h2>Module summary</h2> <p class="REFBODY">The Erlang Parser</p> <h2>Description</h2> 
<p>This module is the basic Erlang parser which converts tokens into the abstract form of either forms (i.e., top-level constructs), expressions, or terms. The Abstract Format is described in the <code class="bold_code">ERTS User's Guide</code>. Note that a token list must end with the <strong>dot</strong> token in order to be acceptable to the parse functions (see <code class="bold_code"><a href="../erl_scan/">erl_scan(3)</a></code>).</p>  <h2>Data types</h2> <h3 class="code">abstract_clause() = term()</h3> 
<p>Parse tree for Erlang clause.</p>  <h3 class="code">abstract_expr() = term()</h3> 
<p>Parse tree for Erlang expression.</p>  <h3 class="code">abstract_form() = term()</h3> 
<p>Parse tree for Erlang form.</p>  <h3 class="code">error_description() = term()</h3> <h3 class="code">error_info() = {<a href="../erl_anno/#type-line">erl_anno:line()</a>, module(), <a href="#type-error_description">error_description()</a>}</h3> <h3 class="code">token() = <a href="../erl_scan/#type-token">erl_scan:token()</a>
</h3> <h2>Exports</h2> <h3 id="parse_form-1" class="code">parse_form(Tokens) -&gt; {ok, AbsForm} | {error, ErrorInfo}</h3> <p>Types:</p>     <pre>Tokens = [<a href="#type-token">token()</a>]
AbsForm = <a href="#type-abstract_form">abstract_form()</a>
ErrorInfo = <a href="#type-error_info">error_info()</a></pre>

<p>This function parses <code class="code">Tokens</code> as if it were a form. It returns:</p> <dl> <dt><strong><code class="code">{ok, AbsForm}</code></strong></dt> <dd> <p>The parsing was successful. <code class="code">AbsForm</code> is the abstract form of the parsed form.</p> </dd> <dt><strong><code class="code">{error, ErrorInfo}</code></strong></dt> <dd> <p>An error occurred.</p> </dd> </dl>  <h3 id="parse_exprs-1" class="code">parse_exprs(Tokens) -&gt; {ok, ExprList} | {error, ErrorInfo}</h3> <p>Types:</p>     <pre>Tokens = [<a href="#type-token">token()</a>]
ExprList = [<a href="#type-abstract_expr">abstract_expr()</a>]
ErrorInfo = <a href="#type-error_info">error_info()</a></pre>

<p>This function parses <code class="code">Tokens</code> as if it were a list of expressions. It returns:</p> <dl> <dt><strong><code class="code">{ok, ExprList}</code></strong></dt> <dd> <p>The parsing was successful. <code class="code">ExprList</code> is a list of the abstract forms of the parsed expressions.</p> </dd> <dt><strong><code class="code">{error, ErrorInfo}</code></strong></dt> <dd> <p>An error occurred.</p> </dd> </dl>  <h3 id="parse_term-1" class="code">parse_term(Tokens) -&gt; {ok, Term} | {error, ErrorInfo}</h3> <p>Types:</p>     <pre>Tokens = [<a href="#type-token">token()</a>]
Term = term()
ErrorInfo = <a href="#type-error_info">error_info()</a></pre>

<p>This function parses <code class="code">Tokens</code> as if it were a term. It returns:</p> <dl> <dt><strong><code class="code">{ok, Term}</code></strong></dt> <dd> <p>The parsing was successful. <code class="code">Term</code> is the Erlang term corresponding to the token list.</p> </dd> <dt><strong><code class="code">{error, ErrorInfo}</code></strong></dt> <dd> <p>An error occurred.</p> </dd> </dl>  <h3 id="format_error-1" class="code">format_error(ErrorDescriptor) -&gt; Chars</h3>  <p>Types:</p>    <pre>ErrorDescriptor = <a href="#type-error_info">error_description()</a>
Chars = [char() | Chars]</pre>

<p>Uses an <code class="code">ErrorDescriptor</code> and returns a string which describes the error. This function is usually called implicitly when an <code class="code">ErrorInfo</code> structure is processed (see below).</p>  <h3 id="tokens-2" class="code">tokens(AbsTerm) -&gt; Tokens<br>tokens(AbsTerm, MoreTokens) -&gt; Tokens</h3> <p>Types:</p>     <pre>AbsTerm = <a href="#type-abstract_expr">abstract_expr()</a>
MoreTokens = Tokens = [<a href="#type-token">token()</a>]</pre>

<p>This function generates a list of tokens representing the abstract form <code class="code">AbsTerm</code> of an expression. Optionally, it appends <code class="code">MoreTokens</code>.</p>  <h3 id="normalise-1" class="code">normalise(AbsTerm) -&gt; Data</h3> <p>Types:</p>    <pre>AbsTerm = <a href="#type-abstract_expr">abstract_expr()</a>
Data = term()</pre>

<p>Converts the abstract form <code class="code">AbsTerm</code> of a term into a conventional Erlang data structure (i.e., the term itself). This is the inverse of <code class="code">abstract/1</code>.</p>  <h3 id="abstract-1" class="code">abstract(Data) -&gt; AbsTerm</h3> <p>Types:</p>    <pre>Data = term()
AbsTerm = <a href="#type-abstract_expr">abstract_expr()</a></pre>

<p>Converts the Erlang data structure <code class="code">Data</code> into an abstract form of type <code class="code">AbsTerm</code>. This is the inverse of <code class="code">normalise/1</code>.</p> <p><code class="code">erl_parse:abstract(T)</code> is equivalent to <code class="code">erl_parse:abstract(T, 0)</code>.</p>  <h3 id="abstract-2" class="code">abstract(Data, Options) -&gt; AbsTerm</h3> <p>Types:</p>         <pre>Data = term()
Options = Line | [Option]
Option = {line, Line} | {encoding, Encoding}
Encoding = latin1 | unicode | utf8 | none | encoding_func()
Line = <a href="../erl_anno/#type-line">erl_anno:line()</a>
AbsTerm = <a href="#type-abstract_expr">abstract_expr()</a>
encoding_func() = fun((integer() &gt;= 0) -&gt; boolean())</pre>

<p>Converts the Erlang data structure <code class="code">Data</code> into an abstract form of type <code class="code">AbsTerm</code>.</p> <p>The <code class="code">Line</code> option is the line that will be assigned to each node of the abstract form.</p> <p>The <code class="code">Encoding</code> option is used for selecting which integer lists will be considered as strings. The default is to use the encoding returned by <code class="bold_code"><a href="../epp/#default_encoding-0"> <span class="code">epp:default_encoding/0</span></a></code>. The value <code class="code">none</code> means that no integer lists will be considered as strings. The <code class="code">encoding_func()</code> will be called with one integer of a list at a time, and if it returns <code class="code">true</code> for every integer the list will be considered a string.</p>  <h3 id="map_anno-2" class="code">map_anno(Fun, Abstr) -&gt; NewAbstr</h3> <p>Types:</p>      <pre>Fun = fun((Anno) -&gt; Anno)
Anno = <a href="../erl_anno/#type-anno">erl_anno:anno()</a>
Abstr = NewAbstr = <a href="#type-abstract_form">abstract_form()</a> | <a href="#type-abstract_expr">abstract_expr()</a></pre>

<p>Modifies the abstract form Abstr by applying Fun on every collection of annotations of the abstract form. The abstract form is traversed in a depth-first, left-to-right, fashion. </p>  <h3 id="fold_anno-3" class="code">fold_anno(Fun, Acc0, Abstr) -&gt; NewAbstr</h3> <p>Types:</p>         <pre>Fun = fun((Anno, AccIn) -&gt; AccOut)
Anno = <a href="../erl_anno/#type-anno">erl_anno:anno()</a>
Acc0 = AccIn = AccOut = term()


Abstr = NewAbstr = <a href="#type-abstract_form">abstract_form()</a> | <a href="#type-abstract_expr">abstract_expr()</a></pre>

<p>Updates an accumulator by applying Fun on every collection of annotations of the abstract form Abstr. The first call to Fun has AccIn as argument, and the returned accumulator AccOut is passed to the next call, and so on. The final value of the accumulator is returned. The abstract form is traversed in a depth-first, left-to-right, fashion. </p>  <h3 id="mapfold_anno-3" class="code">mapfold_anno(Fun, Acc0, Abstr) -&gt; {NewAbstr, Acc1}</h3> <p>Types:</p>          <pre>Fun = fun((Anno, AccIn) -&gt; {Anno, AccOut})
Anno = <a href="../erl_anno/#type-anno">erl_anno:anno()</a>
Acc0 = Acc1 = AccIn = AccOut = term()



Abstr = NewAbstr = <a href="#type-abstract_form">abstract_form()</a> | <a href="#type-abstract_expr">abstract_expr()</a></pre>

<p>Modifies the abstract form Abstr by applying Fun on every collection of annotations of the abstract form, while at the same time updating an accumulator. The first call to Fun has AccIn as second argument, and the returned accumulator AccOut is passed to the next call, and so on. The modified abstract form as well as the the final value of the accumulator is returned. The abstract form is traversed in a depth-first, left-to-right, fashion. </p>  <h3 id="new_anno-1" class="code">new_anno(Term) -&gt; Abstr</h3> <p>Types:</p>    <pre>Term = term()
Abstr = <a href="#type-abstract_form">abstract_form()</a> | <a href="#type-abstract_expr">abstract_expr()</a></pre>

<p>Creates an abstract form from a term which has the same structure as an abstract form, but <code class="bold_code"><a href="../erl_anno/#type-location">locations</a></code> where the abstract form has annotations. For each location, <code class="bold_code"><a href="../erl_anno/#new-1"><span class="code">erl_anno:new/1</span></a></code> is called, and the annotations replace the location. </p>  <h3 id="anno_from_term-1" class="code">anno_from_term(Term) -&gt; <a href="#type-abstract_form">abstract_form()</a> | <a href="#type-abstract_expr">abstract_expr()</a>
</h3> <p>Types:</p>   <pre>Term = term()</pre>

<p>Assumes that Term is a term with the same structure as an abstract form, but with terms, T say, on those places where an abstract form has annotations. Returns an abstract form where every term T has been replaced by the value returned by calling <code class="code">erl_anno:from_term(T)</code>. The term Term is traversed in a depth-first, left-to-right, fashion. </p>  <h3 id="anno_to_term-1" class="code">anno_to_term(Abstr) -&gt; term()</h3> <p>Types:</p>   <pre>Abstr = <a href="#type-abstract_form">abstract_form()</a> | <a href="#type-abstract_expr">abstract_expr()</a></pre>

<p>Returns a term where every collection of annotations Anno of Abstr has been replaced by the term returned by calling <code class="code">erl_anno:to_term(Anno)</code>. The abstract form is traversed in a depth-first, left-to-right, fashion. </p>  <h2 id="id178678">Error Information</h2>  <p>The <code class="code">ErrorInfo</code> mentioned above is the standard <code class="code">ErrorInfo</code> structure which is returned from all IO modules. It has the format: </p> <div class="example"><pre>
{ErrorLine, Module, ErrorDescriptor}    </pre></div> <p>A string which describes the error is obtained with the following call: </p> <div class="example"><pre>
Module:format_error(ErrorDescriptor)    </pre></div>  <h2 id="id178714">See Also</h2>  <p><code class="bold_code"><a href="../io/">io(3)</a></code>, <code class="bold_code"><a href="../erl_anno/">erl_anno(3)</a></code>, <code class="bold_code"><a href="../erl_scan/">erl_scan(3)</a></code>, <code class="bold_code">ERTS User's Guide</code></p>
<div class="_attribution">
  <p class="_attribution-p">
    © 1999–2016 Ericsson AB<br>Licensed under the Apache License, Version 2.0.<br>
    
  </p>
</div>

			</div>
		</div>
	</section>

	</div>
</body>
</html>
