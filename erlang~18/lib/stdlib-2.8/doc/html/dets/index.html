
<!DOCTYPE HTML>

<html lang="en">

<head>
  <meta charset="utf-8">
  <title>Dets - Erlang 18 - W3cubDocs</title>
  
  <meta name="description" content=" dets ">
  <meta name="keywords" content="dets, -, erlang, erlang~18">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="http://docs.w3cub.com/erlang~18/lib/stdlib-2.8/doc/html/dets/">
  <link href="/favicon.png" rel="icon">
  <link type="text/css" rel="stylesheet" href="/assets/application-50364fff564ce3b6327021805f3f00e2957b441cf27f576a7dd4ff63bbc47047.css">
  <script type="text/javascript" src="/assets/application-db64bfd54ceb42be11af7995804cf4902548419ceb79d509b0b7d62c22d98e6f.js"></script>
  <script src="/json/erlang~18.js"></script>
  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-71174418-1']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>


</head>

<body>
	<div class="_app">
	<header class="_header">
  
  <form class="_search">
    <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
    <a class="_search-clear"></a>
    <div class="_search-tag"></div>
  </form>
  
  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/erlang~18/" class="_nav-link" title="" style="margin-left:0;">Erlang 18</a></span>
  
  <nav class="_nav">
    <a href="/app/" class="_nav-link ">App</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		<div class="_list">
			
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<div class="_page _erlang">
				
<h1>dets</h1> <h2>Module</h2> <p class="REFBODY">dets</p> <h2>Module summary</h2> <p class="REFBODY">A Disk Based Term Storage</p> <h2>Description</h2> 
<p>The module <code class="code">dets</code> provides a term storage on file. The stored terms, in this module called <strong>objects</strong>, are tuples such that one element is defined to be the key. A Dets <strong>table</strong> is a collection of objects with the key at the same position stored on a file.</p> <p>Dets is used by the Mnesia application, and is provided as is for users who are interested in an efficient storage of Erlang terms on disk only. Many applications just need to store some terms in a file. Mnesia adds transactions, queries, and distribution. The size of Dets files cannot exceed 2 GB. If larger tables are needed, Mnesia's table fragmentation can be used.</p> <p>There are three types of Dets tables: set, bag and duplicate_bag. A table of type <strong>set</strong> has at most one object with a given key. If an object with a key already present in the table is inserted, the existing object is overwritten by the new object. A table of type <strong>bag</strong> has zero or more different objects with a given key. A table of type <strong>duplicate_bag</strong> has zero or more possibly matching objects with a given key.</p> <p>Dets tables must be opened before they can be updated or read, and when finished they must be properly closed. If a table has not been properly closed, Dets will automatically repair the table. This can take a substantial time if the table is large. A Dets table is closed when the process which opened the table terminates. If several Erlang processes (users) open the same Dets table, they will share the table. The table is properly closed when all users have either terminated or closed the table. Dets tables are not properly closed if the Erlang runtime system is terminated abnormally.</p> <div class="note"> <div class="label">Note</div> <div class="content">

<p>A ^C command abnormally terminates an Erlang runtime system in a Unix environment with a break-handler.</p> </div> </div> <p>Since all operations performed by Dets are disk operations, it is important to realize that a single look-up operation involves a series of disk seek and read operations. For this reason, the Dets functions are much slower than the corresponding Ets functions, although Dets exports a similar interface.</p> <p>Dets organizes data as a linear hash list and the hash list grows gracefully as more data is inserted into the table. Space management on the file is performed by what is called a buddy system. The current implementation keeps the entire buddy system in RAM, which implies that if the table gets heavily fragmented, quite some memory can be used up. The only way to defragment a table is to close it and then open it again with the <code class="code">repair</code> option set to <code class="code">force</code>.</p> <p>It is worth noting that the ordered_set type present in Ets is not yet implemented by Dets, neither is the limited support for concurrent updates which makes a sequence of <code class="code">first</code> and <code class="code">next</code> calls safe to use on fixed Ets tables. Both these features will be implemented by Dets in a future release of Erlang/OTP. Until then, the Mnesia application (or some user implemented method for locking) has to be used to implement safe concurrency. Currently, no library of Erlang/OTP has support for ordered disk based term storage.</p> <p>Two versions of the format used for storing objects on file are supported by Dets. The first version, 8, is the format always used for tables created by OTP R7 and earlier. The second version, 9, is the default version of tables created by OTP R8 (and later OTP releases). OTP R8 can create version 8 tables, and convert version 8 tables to version 9, and vice versa, upon request. </p> <p>All Dets functions return <code class="code">{error, Reason}</code> if an error occurs (<code class="code">first/1</code> and <code class="code">next/2</code> are exceptions, they exit the process with the error tuple). If given badly formed arguments, all functions exit the process with a <code class="code">badarg</code> message.</p>  <h2>Data types</h2> <h3 class="code">access() = read | read_write</h3> <h3 class="code">auto_save() = infinity | integer() &gt;= 0</h3> <h3 class="code">bindings_cont()</h3> 
<p>Opaque continuation used by <code class="bold_code"><a href="#match-1"> <span class="code">match/1</span></a></code> and <code class="bold_code"><a href="#match-3"> <span class="code">match/3</span></a></code>.</p>  <h3 class="code">cont()</h3> 
<p>Opaque continuation used by <code class="bold_code"><a href="#bchunk-2"> <span class="code">bchunk/2</span></a></code>.</p>  <h3 class="code">keypos() = integer() &gt;= 1</h3> <h3 class="code">match_spec() = <a href="../ets/#type-match_spec">ets:match_spec()</a>
</h3> 
<p>Match specifications, see the <code class="bold_code">match specification</code> documentation in the ERTS User's Guide and <code class="bold_code"><a href="../ms_transform/">ms_transform(3).</a></code></p>  <h3 class="code">no_slots() = integer() &gt;= 0 | default</h3> <h3 class="code">object() = tuple()</h3> <h3 class="code">object_cont()</h3> 
<p>Opaque continuation used by <code class="bold_code"><a href="#match_object-1"> <span class="code">match_object/1</span></a></code> and <code class="bold_code"><a href="#match_object-3"> <span class="code">match_object/3</span></a></code>.</p>  <h3 class="code">pattern() = atom() | tuple()</h3> 
<p>See <code class="bold_code"><a href="../ets/#match-2">ets:match/2</a></code> for a description of patterns.</p>  <h3 class="code">select_cont()</h3> 
<p>Opaque continuation used by <code class="bold_code"><a href="#select-1"> <span class="code">select/1</span></a></code> and <code class="bold_code"><a href="#select-3"> <span class="code">select/3</span></a></code>.</p>  <h3 class="code">tab_name() = term()</h3> <h3 class="code">type() = bag | duplicate_bag | set</h3> <h3 class="code">version() = 8 | 9 | default</h3> <h2>Exports</h2> <h3 id="all-0" class="code">all() -&gt; [<a href="#type-tab_name">tab_name()</a>]</h3> 
<p>Returns a list of the names of all open tables on this node.</p>  <h3 id="bchunk-2" class="code">bchunk(Name, Continuation) -&gt;<br>          {Continuation2, Data} |<br>          '$end_of_table' |<br>          {error, Reason}</h3> <p>Types:</p>       <pre>Name = <a href="#type-tab_name">tab_name()</a>
Continuation = start | <a href="#type-cont">cont()</a>
Continuation2 = <a href="#type-cont">cont()</a>
Data = binary() | tuple()
Reason = term()</pre>

<p>Returns a list of objects stored in a table. The exact representation of the returned objects is not public. The lists of data can be used for initializing a table by giving the value <code class="code">bchunk</code> to the <code class="code">format</code> option of the <code class="bold_code"><a href="#init_table-3"><span class="code">init_table/3</span></a></code> function. The Mnesia application uses this function for copying open tables.</p> <p>Unless the table is protected using <code class="code">safe_fixtable/2</code>, calls to <code class="code">bchunk/2</code> may not work as expected if concurrent updates are made to the table.</p> <p>The first time <code class="code">bchunk/2</code> is called, an initial continuation, the atom <code class="code">start</code>, must be provided.</p> <p>The <code class="code">bchunk/2</code> function returns a tuple <code class="code">{Continuation2, Data}</code>, where <code class="code">Data</code> is a list of objects. <code class="code">Continuation2</code> is another continuation which is to be passed on to a subsequent call to <code class="code">bchunk/2</code>. With a series of calls to <code class="code">bchunk/2</code> it is possible to extract all objects of the table. </p> <p><code class="code">bchunk/2</code> returns <code class="code">'$end_of_table'</code> when all objects have been returned, or <code class="code">{error, Reason}</code> if an error occurs. </p>  <h3 id="close-1" class="code">close(Name) -&gt; ok | {error, Reason}</h3> <p>Types:</p>    <pre>Name = <a href="#type-tab_name">tab_name()</a>
Reason = term()</pre>

<p>Closes a table. Only processes that have opened a table are allowed to close it. </p> <p>All open tables must be closed before the system is stopped. If an attempt is made to open a table which has not been properly closed, Dets automatically tries to repair the table.</p>  <h3 id="delete-2" class="code">delete(Name, Key) -&gt; ok | {error, Reason}</h3> <p>Types:</p>     <pre>Name = <a href="#type-tab_name">tab_name()</a>
Key = Reason = term()</pre>

<p>Deletes all objects with the key <code class="code">Key</code> from the table <code class="code">Name</code>.</p>  <h3 id="delete_all_objects-1" class="code">delete_all_objects(Name) -&gt; ok | {error, Reason}</h3> <p>Types:</p>    <pre>Name = <a href="#type-tab_name">tab_name()</a>
Reason = term()</pre>

<p>Deletes all objects from a table in almost constant time. However, if the table if fixed, <code class="code">delete_all_objects(T)</code> is equivalent to <code class="code">match_delete(T, '_')</code>.</p>  <h3 id="delete_object-2" class="code">delete_object(Name, Object) -&gt; ok | {error, Reason}</h3> <p>Types:</p>     <pre>Name = <a href="#type-tab_name">tab_name()</a>
Object = <a href="#type-object">object()</a>
Reason = term()</pre>

<p>Deletes all instances of a given object from a table. If a table is of type <code class="code">bag</code> or <code class="code">duplicate_bag</code>, the <code class="code">delete/2</code> function cannot be used to delete only some of the objects with a given key. This function makes this possible.</p>  <h3 id="first-1" class="code">first(Name) -&gt; Key | '$end_of_table'</h3> <p>Types:</p>    <pre>Name = <a href="#type-tab_name">tab_name()</a>
Key = term()</pre>

<p>Returns the first key stored in the table <code class="code">Name</code> according to the table's internal order, or <code class="code">'$end_of_table'</code> if the table is empty.</p> <p>Unless the table is protected using <code class="code">safe_fixtable/2</code>, subsequent calls to <code class="bold_code"><a href="#next-2"><span class="code">next/2</span></a></code> may not work as expected if concurrent updates are made to the table.</p> <p>Should an error occur, the process is exited with an error tuple <code class="code">{error, Reason}</code>. The reason for not returning the error tuple is that it cannot be distinguished from a key.</p> <p>There are two reasons why <code class="code">first/1</code> and <code class="code">next/2</code> should not be used: they are not very efficient, and they prevent the use of the key <code class="code">'$end_of_table'</code> since this atom is used to indicate the end of the table. If possible, the <code class="code">match</code>, <code class="code">match_object</code>, and <code class="code">select</code> functions should be used for traversing tables.</p>  <h3 id="foldr-3" class="code">foldl(Function, Acc0, Name) -&gt; Acc | {error, Reason}<br>foldr(Function, Acc0, Name) -&gt; Acc | {error, Reason}</h3> <p>Types:</p>         <pre>Name = <a href="#type-tab_name">tab_name()</a>
Function = fun((Object :: <a href="#type-object">object()</a>, AccIn) -&gt; AccOut)
Acc0 = Acc = AccIn = AccOut = Reason = term()</pre>

<p>Calls <code class="code">Function</code> on successive elements of the table <code class="code">Name</code> together with an extra argument <code class="code">AccIn</code>. The order in which the elements of the table are traversed is unspecified. <code class="code">Function</code> must return a new accumulator which is passed to the next call. <code class="code">Acc0</code> is returned if the table is empty.</p>  <h3 id="from_ets-2" class="code">from_ets(Name, EtsTab) -&gt; ok | {error, Reason}</h3> <p>Types:</p>     <pre>Name = <a href="#type-tab_name">tab_name()</a>
EtsTab = <a href="../ets/#type-tab">ets:tab()</a>
Reason = term()</pre>

<p>Deletes all objects of the table <code class="code">Name</code> and then inserts all the objects of the Ets table <code class="code">EtsTab</code>. The order in which the objects are inserted is not specified. Since <code class="code">ets:safe_fixtable/2</code> is called the Ets table must be public or owned by the calling process.</p>  <h3 id="info-1" class="code">info(Name) -&gt; InfoList | undefined</h3> <p>Types:</p>     <pre>Name = <a href="#type-tab_name">tab_name()</a>
InfoList = [InfoTuple]
InfoTuple = 
    {file_size, integer() &gt;= 0} |
    {filename, file:name()} |
    {keypos, <a href="#type-keypos">keypos()</a>} |
    {size, integer() &gt;= 0} |
    {type, <a href="#type-type">type()</a>}</pre>

<p>Returns information about the table <code class="code">Name</code> as a list of tuples:</p> <ul> <li> <p><code class="code">{file_size, integer() &gt;= 0}</code>, the size of the file in bytes.</p> </li> <li> <p><code class="code">{filename,</code><code class="bold_code">file:name()</code><code class="code">}</code>, the name of the file where objects are stored.</p> </li> <li> <p><code class="code">{keypos,</code><code class="bold_code"><a href="#type-keypos">keypos()</a></code> <code class="code">}</code>, the position of the key.</p> </li> <li> <p><code class="code">{size, integer() &gt;= 0}</code>, the number of objects stored in the table.</p> </li> <li> <p><code class="code">{type,</code><code class="bold_code"><a href="#type-type">type()</a></code> <code class="code">}</code>, the type of the table.</p> </li> </ul>  <h3 id="info-2" class="code">info(Name, Item) -&gt; Value | undefined</h3> <p>Types:</p>     <pre>Name = <a href="#type-tab_name">tab_name()</a>
Item = 
    access |
    auto_save |
    bchunk_format |
    hash |
    file_size |
    filename |
    keypos |
    memory |
    no_keys |
    no_objects |
    no_slots |
    owner |
    ram_file |
    safe_fixed |
    safe_fixed_monotonic_time |
    size |
    type |
    version
Value = term()</pre>

<p>Returns the information associated with <code class="code">Item</code> for the table <code class="code">Name</code>. In addition to the <code class="code">{Item, Value}</code> pairs defined for <code class="code">info/1</code>, the following items are allowed:</p> <ul> <li> <p><code class="code">{access,</code><code class="bold_code"><a href="#type-access">access()</a></code> <code class="code">}</code>, the access mode.</p> </li> <li> <p><code class="code">{auto_save,</code><code class="bold_code"><a href="#type-auto_save"> auto_save()</a></code><code class="code">}</code>, the auto save interval.</p> </li> <li> <p><code class="code">{bchunk_format, binary()}</code>, an opaque binary describing the format of the objects returned by <code class="code">bchunk/2</code>. The binary can be used as argument to <code class="code">is_compatible_chunk_format/2</code>. Only available for version 9 tables.</p> </li> <li> <p><code class="code">{hash,</code> Hash<code class="code">}</code>. Describes which BIF is used to calculate the hash values of the objects stored in the Dets table. Possible values of Hash are <code class="code">hash</code>, which implies that the <code class="code">erlang:hash/2</code> BIF is used, <code class="code">phash</code>, which implies that the <code class="code">erlang:phash/2</code> BIF is used, and <code class="code">phash2</code>, which implies that the <code class="code">erlang:phash2/1</code> BIF is used.</p> </li> <li> <p><code class="code">{memory, integer() &gt;= 0}</code>, the size of the file in bytes. The same value is associated with the item <code class="code">file_size</code>.</p> </li> <li> <p><code class="code">{no_keys, integer &gt;= 0()}</code>, the number of different keys stored in the table. Only available for version 9 tables.</p> </li> <li> <p><code class="code">{no_objects, integer &gt;= 0()}</code>, the number of objects stored in the table.</p> </li> <li> <p><code class="code">{no_slots, {</code>Min<code class="code">,</code>Used<code class="code">,</code>Max<code class="code">}}</code>, the number of slots of the table. <code class="code">Min</code> is the minimum number of slots, <code class="code">Used</code> is the number of currently used slots, and <code class="code">Max</code> is the maximum number of slots. Only available for version 9 tables.</p> </li> <li> <p><code class="code">{owner, pid()}</code>, the pid of the process that handles requests to the Dets table.</p> </li> <li> <p><code class="code">{ram_file, boolean()}</code>, whether the table is kept in RAM.</p> </li> <li> <p><code class="code">{safe_fixed_monotonic_time, SafeFixed}</code>. If the table is fixed, <code class="code">SafeFixed</code> is a tuple <code class="code">{FixedAtTime, [{Pid,RefCount}]}</code>. <code class="code">FixedAtTime</code> is the time when the table was first fixed, and <code class="code">Pid</code> is the pid of the process that fixes the table <code class="code">RefCount</code> times. There may be any number of processes in the list. If the table is not fixed, SafeFixed is the atom <code class="code">false</code>.</p> <p><code class="code">FixedAtTime</code> will correspond to the result returned by <code class="bold_code">erlang:monotonic_time/0</code> at the time of fixation. The usage of <code class="code">safe_fixed_monotonic_time</code> is <code class="bold_code">time warp safe</code>.</p> </li> <li> <p> <code class="code">{safe_fixed, SafeFixed}</code>. The same as <code class="code">{safe_fixed_monotonic_time, SafeFixed}</code> with the exception of the format and value of <code class="code">FixedAtTime</code>. </p> <p> <code class="code">FixedAtTime</code> will correspond to the result returned by <code class="bold_code">erlang:timestamp/0</code> at the time of fixation. Note that when the system is using single or multi <code class="bold_code">time warp modes</code> this might produce strange results. This since the usage of <code class="code">safe_fixed</code> is not <code class="bold_code">time warp safe</code>. Time warp safe code need to use <code class="code">safe_fixed_monotonic_time</code> instead.</p> </li> <li> <p><code class="code">{version, integer()}</code>, the version of the format of the table.</p> </li> </ul>  <h3 id="init_table-3" class="code">init_table(Name, InitFun) -&gt; ok | {error, Reason}<br>init_table(Name, InitFun, Options) -&gt; ok | {error, Reason}</h3> <p>Types:</p>          <pre>Name = <a href="#type-tab_name">tab_name()</a>
InitFun = fun((Arg) -&gt; Res)
Arg = read | close
Res = 
    end_of_input |
    {[<a href="#type-object">object()</a>], InitFun} |
    {Data, InitFun} |
    term()
Options = Option | [Option]
Option = {min_no_slots, <a href="#type-no_slots">no_slots()</a>} | {format, term | bchunk}
Reason = term()
Data = binary() | tuple()</pre>

<p>Replaces the existing objects of the table <code class="code">Name</code> with objects created by calling the input function <code class="code">InitFun</code>, see below. The reason for using this function rather than calling <code class="code">insert/2</code> is that of efficiency. It should be noted that the input functions are called by the process that handles requests to the Dets table, not by the calling process.</p> <p>When called with the argument <code class="code">read</code> the function <code class="code">InitFun</code> is assumed to return <code class="code">end_of_input</code> when there is no more input, or <code class="code">{Objects, Fun}</code>, where <code class="code">Objects</code> is a list of objects and <code class="code">Fun</code> is a new input function. Any other value Value is returned as an error <code class="code">{error, {init_fun, Value}}</code>. Each input function will be called exactly once, and should an error occur, the last function is called with the argument <code class="code">close</code>, the reply of which is ignored.</p> <p>If the type of the table is <code class="code">set</code> and there is more than one object with a given key, one of the objects is chosen. This is not necessarily the last object with the given key in the sequence of objects returned by the input functions. Duplicate keys should be avoided, or the file will be unnecessarily fragmented. This holds also for duplicated objects stored in tables of type <code class="code">bag</code>.</p> <p>It is important that the table has a sufficient number of slots for the objects. If not, the hash list will start to grow when <code class="code">init_table/2</code> returns which will significantly slow down access to the table for a period of time. The minimum number of slots is set by the <code class="code">open_file/2</code> option <code class="code">min_no_slots</code> and returned by the <code class="code">info/2</code> item <code class="code">no_slots</code>. See also the <code class="code">min_no_slots</code> option below. </p> <p>The <code class="code">Options</code> argument is a list of <code class="code">{Key, Val}</code> tuples where the following values are allowed:</p> <ul> <li> <p><code class="code">{min_no_slots, no_slots()}</code>. Specifies the estimated number of different keys that will be stored in the table. The <code class="code">open_file</code> option with the same name is ignored unless the table is created, and in that case performance can be enhanced by supplying an estimate when initializing the table.</p> </li> <li> <p><code class="code">{format, Format}</code>. Specifies the format of the objects returned by the function <code class="code">InitFun</code>. If <code class="code">Format</code> is <code class="code">term</code> (the default), <code class="code">InitFun</code> is assumed to return a list of tuples. If <code class="code">Format</code> is <code class="code">bchunk</code>, <code class="code">InitFun</code> is assumed to return <code class="code">Data</code> as returned by <code class="bold_code"><a href="#bchunk-2"><span class="code">bchunk/2</span></a></code>. This option overrides the <code class="code">min_no_slots</code> option.</p> </li> </ul>  <h3 id="insert-2" class="code">insert(Name, Objects) -&gt; ok | {error, Reason}</h3> <p>Types:</p>     <pre>Name = <a href="#type-tab_name">tab_name()</a>
Objects = <a href="#type-object">object()</a> | [<a href="#type-object">object()</a>]
Reason = term()</pre>

<p>Inserts one or more objects into the table <code class="code">Name</code>. If there already exists an object with a key matching the key of some of the given objects and the table type is <code class="code">set</code>, the old object will be replaced.</p>  <h3 id="insert_new-2" class="code">insert_new(Name, Objects) -&gt; boolean() | {error, Reason}</h3> <p>Types:</p>     <pre>Name = <a href="#type-tab_name">tab_name()</a>
Objects = <a href="#type-object">object()</a> | [<a href="#type-object">object()</a>]
Reason = term()</pre>

<p>Inserts one or more objects into the table <code class="code">Name</code>. If there already exists some object with a key matching the key of any of the given objects the table is not updated and <code class="code">false</code> is returned, otherwise the objects are inserted and <code class="code">true</code> returned.</p>  <h3 id="is_compatible_bchunk_format-2" class="code">is_compatible_bchunk_format(Name, BchunkFormat) -&gt; boolean()</h3> <p>Types:</p>    <pre>Name = <a href="#type-tab_name">tab_name()</a>
BchunkFormat = binary()</pre>

<p>Returns <code class="code">true</code> if it would be possible to initialize the table <code class="code">Name</code>, using <code class="bold_code"><a href="#init_table-3"><span class="code">init_table/3</span></a></code> with the option <code class="code">{format, bchunk}</code>, with objects read with <code class="bold_code"><a href="#bchunk-2"><span class="code">bchunk/2</span></a></code> from some table <code class="code">T</code> such that calling <code class="code">info(T, bchunk_format)</code> returns <code class="code">BchunkFormat</code>.</p>  <h3 id="is_dets_file-1" class="code">is_dets_file(Filename) -&gt; boolean() | {error, Reason}</h3> <p>Types:</p>    <pre>Filename = file:name()
Reason = term()</pre>

<p>Returns <code class="code">true</code> if the file <code class="code">Filename</code> is a Dets table, <code class="code">false</code> otherwise.</p>  <h3 id="lookup-2" class="code">lookup(Name, Key) -&gt; Objects | {error, Reason}</h3> <p>Types:</p>      <pre>Name = <a href="#type-tab_name">tab_name()</a>
Key = term()
Objects = [<a href="#type-object">object()</a>]
Reason = term()</pre>

<p>Returns a list of all objects with the key <code class="code">Key</code> stored in the table <code class="code">Name</code>. For example:</p> <div class="example"><pre>
2&gt; dets:open_file(abc, [{type, bag}]).
{ok,abc}
3&gt; dets:insert(abc, {1,2,3}).
ok
4&gt; dets:insert(abc, {1,3,4}).
ok
5&gt; dets:lookup(abc, 1).
[{1,2,3},{1,3,4}]        </pre></div> <p>If the table is of type <code class="code">set</code>, the function returns either the empty list or a list with one object, as there cannot be more than one object with a given key. If the table is of type <code class="code">bag</code> or <code class="code">duplicate_bag</code>, the function returns a list of arbitrary length.</p> <p>Note that the order of objects returned is unspecified. In particular, the order in which objects were inserted is not reflected.</p>  <h3 id="match-1" class="code">match(Continuation) -&gt;<br>         {[Match], Continuation2} |<br>         '$end_of_table' |<br>         {error, Reason}</h3> <p>Types:</p>      <pre>Continuation = Continuation2 = <a href="#type-bindings_cont">bindings_cont()</a>

Match = [term()]
Reason = term()</pre>

<p>Matches some objects stored in a table and returns a non-empty list of the bindings that match a given pattern in some unspecified order. The table, the pattern, and the number of objects that are matched are all defined by <code class="code">Continuation</code>, which has been returned by a prior call to <code class="code">match/1</code> or <code class="code">match/3</code>.</p> <p>When all objects of the table have been matched, <code class="code">'$end_of_table'</code> is returned.</p>  <h3 id="match-2" class="code">match(Name, Pattern) -&gt; [Match] | {error, Reason}</h3> <p>Types:</p>      <pre>Name = <a href="#type-tab_name">tab_name()</a>
Pattern = <a href="#type-pattern">pattern()</a>
Match = [term()]
Reason = term()</pre>

<p>Returns for each object of the table <code class="code">Name</code> that matches <code class="code">Pattern</code> a list of bindings in some unspecified order. See <code class="bold_code"><a href="../ets/#match-2">ets:match/2</a></code> for a description of patterns. If the keypos'th element of <code class="code">Pattern</code> is unbound, all objects of the table are matched. If the keypos'th element is bound, only the objects with the right key are matched.</p>  <h3 id="match-3" class="code">match(Name, Pattern, N) -&gt;<br>         {[Match], Continuation} |<br>         '$end_of_table' |<br>         {error, Reason}</h3> <p>Types:</p>        <pre>Name = <a href="#type-tab_name">tab_name()</a>
Pattern = <a href="#type-pattern">pattern()</a>
N = default | integer() &gt;= 0
Continuation = <a href="#type-bindings_cont">bindings_cont()</a>
Match = [term()]
Reason = term()</pre>

<p>Matches some or all objects of the table <code class="code">Name</code> and returns a non-empty list of the bindings that match <code class="code">Pattern</code> in some unspecified order. See <code class="bold_code"><a href="../ets/#match-2">ets:match/2</a></code> for a description of patterns.</p> <p>A tuple of the bindings and a continuation is returned, unless the table is empty, in which case <code class="code">'$end_of_table'</code> is returned. The continuation is to be used when matching further objects by calling <code class="bold_code"><a href="#match-1"><span class="code">match/1</span></a></code>.</p> <p>If the keypos'th element of <code class="code">Pattern</code> is bound, all objects of the table are matched. If the keypos'th element is unbound, all objects of the table are matched, <code class="code">N</code> objects at a time, until at least one object matches or the end of the table has been reached. The default, indicated by giving <code class="code">N</code> the value <code class="code">default</code>, is to let the number of objects vary depending on the sizes of the objects. If <code class="code">Name</code> is a version 9 table, all objects with the same key are always matched at the same time which implies that more than N objects may sometimes be matched. </p> <p>The table should always be protected using <code class="code">safe_fixtable/2</code> before calling <code class="code">match/3</code>, or errors may occur when calling <code class="code">match/1</code>.</p>  <h3 id="match_delete-2" class="code">match_delete(Name, Pattern) -&gt; ok | {error, Reason}</h3> <p>Types:</p>     <pre>Name = <a href="#type-tab_name">tab_name()</a>
Pattern = <a href="#type-pattern">pattern()</a>
Reason = term()</pre>

<p>Deletes all objects that match <code class="code">Pattern</code> from the table <code class="code">Name</code>. See <code class="bold_code"><a href="../ets/#match-2">ets:match/2</a></code> for a description of patterns.</p> <p>If the keypos'th element of <code class="code">Pattern</code> is bound, only the objects with the right key are matched.</p>  <h3 id="match_object-1" class="code">match_object(Continuation) -&gt;<br>                {Objects, Continuation2} |<br>                '$end_of_table' |<br>                {error, Reason}</h3> <p>Types:</p>      <pre>Continuation = Continuation2 = <a href="#type-object_cont">object_cont()</a>

Objects = [<a href="#type-object">object()</a>]
Reason = term()</pre>

<p>Returns a non-empty list of some objects stored in a table that match a given pattern in some unspecified order. The table, the pattern, and the number of objects that are matched are all defined by <code class="code">Continuation</code>, which has been returned by a prior call to <code class="code">match_object/1</code> or <code class="code">match_object/3</code>.</p> <p>When all objects of the table have been matched, <code class="code">'$end_of_table'</code> is returned.</p>  <h3 id="match_object-2" class="code">match_object(Name, Pattern) -&gt; Objects | {error, Reason}</h3> <p>Types:</p>      <pre>Name = <a href="#type-tab_name">tab_name()</a>
Pattern = <a href="#type-pattern">pattern()</a>
Objects = [<a href="#type-object">object()</a>]
Reason = term()</pre>

<p>Returns a list of all objects of the table <code class="code">Name</code> that match <code class="code">Pattern</code> in some unspecified order. See <code class="bold_code"><a href="../ets/#match-2">ets:match/2</a></code> for a description of patterns. </p> <p>If the keypos'th element of <code class="code">Pattern</code> is unbound, all objects of the table are matched. If the keypos'th element of <code class="code">Pattern</code> is bound, only the objects with the right key are matched.</p> <p>Using the <code class="code">match_object</code> functions for traversing all objects of a table is more efficient than calling <code class="code">first/1</code> and <code class="code">next/2</code> or <code class="code">slot/2</code>.</p>  <h3 id="match_object-3" class="code">match_object(Name, Pattern, N) -&gt;<br>                {Objects, Continuation} |<br>                '$end_of_table' |<br>                {error, Reason}</h3> <p>Types:</p>        <pre>Name = <a href="#type-tab_name">tab_name()</a>
Pattern = <a href="#type-pattern">pattern()</a>
N = default | integer() &gt;= 0
Continuation = <a href="#type-object_cont">object_cont()</a>
Objects = [<a href="#type-object">object()</a>]
Reason = term()</pre>

<p>Matches some or all objects stored in the table <code class="code">Name</code> and returns a non-empty list of the objects that match <code class="code">Pattern</code> in some unspecified order. See <code class="bold_code"><a href="../ets/#match-2">ets:match/2</a></code> for a description of patterns.</p> <p>A list of objects and a continuation is returned, unless the table is empty, in which case <code class="code">'$end_of_table'</code> is returned. The continuation is to be used when matching further objects by calling <code class="code">match_object/1</code>.</p> <p>If the keypos'th element of <code class="code">Pattern</code> is bound, all objects of the table are matched. If the keypos'th element is unbound, all objects of the table are matched, <code class="code">N</code> objects at a time, until at least one object matches or the end of the table has been reached. The default, indicated by giving <code class="code">N</code> the value <code class="code">default</code>, is to let the number of objects vary depending on the sizes of the objects. If <code class="code">Name</code> is a version 9 table, all matching objects with the same key are always returned in the same reply which implies that more than N objects may sometimes be returned. </p> <p>The table should always be protected using <code class="code">safe_fixtable/2</code> before calling <code class="code">match_object/3</code>, or errors may occur when calling <code class="code">match_object/1</code>.</p>  <h3 id="member-2" class="code">member(Name, Key) -&gt; boolean() | {error, Reason}</h3> <p>Types:</p>     <pre>Name = <a href="#type-tab_name">tab_name()</a>
Key = Reason = term()</pre>

<p>Works like <code class="code">lookup/2</code>, but does not return the objects. The function returns <code class="code">true</code> if one or more elements of the table has the key <code class="code">Key</code>, <code class="code">false</code> otherwise.</p>  <h3 id="next-2" class="code">next(Name, Key1) -&gt; Key2 | '$end_of_table'</h3> <p>Types:</p>     <pre>Name = <a href="#type-tab_name">tab_name()</a>
Key1 = Key2 = term()</pre>

<p>Returns the key following <code class="code">Key1</code> in the table <code class="code">Name</code> according to the table's internal order, or <code class="code">'$end_of_table'</code> if there is no next key.</p> <p>Should an error occur, the process is exited with an error tuple <code class="code">{error, Reason}</code>.</p> <p>Use <code class="bold_code"><a href="#first-1"><span class="code">first/1</span></a></code> to find the first key in the table.</p>  <h3 id="open_file-1" class="code">open_file(Filename) -&gt; {ok, Reference} | {error, Reason}</h3> <p>Types:</p>     <pre>Filename = file:name()
Reference = reference()
Reason = term()</pre>

<p>Opens an existing table. If the table has not been properly closed, it will be repaired. The returned reference is to be used as the name of the table. This function is most useful for debugging purposes.</p>  <h3 id="open_file-2" class="code">open_file(Name, Args) -&gt; {ok, Name} | {error, Reason}</h3> <p>Types:</p>      <pre>Name = <a href="#type-tab_name">tab_name()</a>
Args = [OpenArg]
OpenArg = 
    {access, <a href="#type-access">access()</a>} |
    {auto_save, <a href="#type-auto_save">auto_save()</a>} |
    {estimated_no_objects, integer() &gt;= 0} |
    {file, file:name()} |
    {max_no_slots, <a href="#type-no_slots">no_slots()</a>} |
    {min_no_slots, <a href="#type-no_slots">no_slots()</a>} |
    {keypos, <a href="#type-keypos">keypos()</a>} |
    {ram_file, boolean()} |
    {repair, boolean() | force} |
    {type, <a href="#type-type">type()</a>} |
    {version, <a href="#type-version">version()</a>}
Reason = term()</pre>

<p>Opens a table. An empty Dets table is created if no file exists.</p> <p>The atom <code class="code">Name</code> is the name of the table. The table name must be provided in all subsequent operations on the table. The name can be used by other processes as well, and several process can share one table. </p> <p>If two processes open the same table by giving the same name and arguments, then the table will have two users. If one user closes the table, it still remains open until the second user closes the table.</p> <p>The <code class="code">Args</code> argument is a list of <code class="code">{Key, Val}</code> tuples where the following values are allowed:</p> <ul> <li> <p><code class="code">{access,</code><code class="bold_code"><a href="#type-access"> access()</a></code><code class="code">}</code>. It is possible to open existing tables in read-only mode. A table which is opened in read-only mode is not subjected to the automatic file reparation algorithm if it is later opened after a crash. The default value is <code class="code">read_write</code>.</p> </li> <li> <p><code class="code">{auto_save,</code><code class="bold_code"><a href="#type-auto_save"> auto_save()</a></code><code class="code">}</code>, the auto save interval. If the interval is an integer <code class="code">Time</code>, the table is flushed to disk whenever it is not accessed for <code class="code">Time</code> milliseconds. A table that has been flushed will require no reparation when reopened after an uncontrolled emulator halt. If the interval is the atom <code class="code">infinity</code>, auto save is disabled. The default value is 180000 (3 minutes).</p> </li> <li> <p><code class="code">{estimated_no_objects,</code><code class="bold_code"><a href="#type-no_slots"> no_slots()</a></code><code class="code">}</code>. Equivalent to the <code class="code">min_no_slots</code> option.</p> </li> <li> <p><code class="code">{file,</code><code class="bold_code"> file:name()</code><code class="code">}</code>, the name of the file to be opened. The default value is the name of the table.</p> </li> <li> <p><code class="code">{max_no_slots,</code><code class="bold_code"><a href="#type-no_slots"> no_slots()</a></code><code class="code">}</code>, the maximum number of slots that will be used. The default value as well as the maximal value is 32 M. Note that a higher value may increase the fragmentation of the table, and conversely, that a smaller value may decrease the fragmentation, at the expense of execution time. Only available for version 9 tables.</p> </li> <li> <p><code class="code">{min_no_slots,</code><code class="bold_code"><a href="#type-no_slots"> no_slots()</a></code><code class="code">}</code>. Application performance can be enhanced with this flag by specifying, when the table is created, the estimated number of different keys that will be stored in the table. The default value as well as the minimum value is 256.</p> </li> <li> <p><code class="code">{keypos,</code><code class="bold_code"><a href="#type-keypos"> keypos()</a></code><code class="code">}</code>, the position of the element of each object to be used as key. The default value is 1. The ability to explicitly state the key position is most convenient when we want to store Erlang records in which the first position of the record is the name of the record type.</p> </li> <li> <p><code class="code">{ram_file, boolean()}</code>, whether the table is to be kept in RAM. Keeping the table in RAM may sound like an anomaly, but can enhance the performance of applications which open a table, insert a set of objects, and then close the table. When the table is closed, its contents are written to the disk file. The default value is <code class="code">false</code>.</p> </li> <li> <p><code class="code">{repair, Value}</code>. <code class="code">Value</code> can be either a <code class="code">boolean()</code> or the atom <code class="code">force</code>. The flag specifies whether the Dets server should invoke the automatic file reparation algorithm. The default is <code class="code">true</code>. If <code class="code">false</code> is specified, there is no attempt to repair the file and <code class="code">{error, {needs_repair, FileName}}</code> is returned if the table needs to be repaired.</p> <p>The value <code class="code">force</code> means that a reparation will take place even if the table has been properly closed. This is how to convert tables created by older versions of STDLIB. An example is tables hashed with the deprecated <code class="code">erlang:hash/2</code> BIF. Tables created with Dets from a STDLIB version of 1.8.2 and later use the <code class="code">erlang:phash/2</code> function or the <code class="code">erlang:phash2/1</code> function, which is preferred.</p> <p>The <code class="code">repair</code> option is ignored if the table is already open.</p> </li> <li> <p><code class="code">{type,</code><code class="bold_code"><a href="#type-type">type()</a></code><code class="code">}</code>, the type of the table. The default value is <code class="code">set</code>.</p> </li> <li> <p><code class="code">{version,</code><code class="bold_code"><a href="#type-version"> version()</a></code><code class="code">}</code>, the version of the format used for the table. The default value is <code class="code">9</code>. Tables on the format used before OTP R8 can be created by giving the value <code class="code">8</code>. A version 8 table can be converted to a version 9 table by giving the options <code class="code">{version,9}</code> and <code class="code">{repair,force}</code>.</p> </li> </ul>  <h3 id="pid2name-1" class="code">pid2name(Pid) -&gt; {ok, Name} | undefined</h3> <p>Types:</p>    <pre>Pid = pid()
Name = <a href="#type-tab_name">tab_name()</a></pre>

<p>Returns the name of the table given the pid of a process that handles requests to a table, or <code class="code">undefined</code> if there is no such table.</p> <p>This function is meant to be used for debugging only.</p>  <h3 id="repair_continuation-2" class="code">repair_continuation(Continuation, MatchSpec) -&gt; Continuation2</h3> <p>Types:</p>     <pre>Continuation = Continuation2 = <a href="#type-select_cont">select_cont()</a>

MatchSpec = <a href="#type-match_spec">match_spec()</a></pre>

<p>This function can be used to restore an opaque continuation returned by <code class="code">select/3</code> or <code class="code">select/1</code> if the continuation has passed through external term format (been sent between nodes or stored on disk).</p> <p>The reason for this function is that continuation terms contain compiled match specifications and therefore will be invalidated if converted to external term format. Given that the original match specification is kept intact, the continuation can be restored, meaning it can once again be used in subsequent <code class="code">select/1</code> calls even though it has been stored on disk or on another node.</p> <p>See also <code class="code">ets(3)</code> for further explanations and examples. </p> <div class="note"> <div class="label">Note</div> <div class="content">

<p>This function is very rarely needed in application code. It is used by Mnesia to implement distributed <code class="code">select/3</code> and <code class="code">select/1</code> sequences. A normal application would either use Mnesia or keep the continuation from being converted to external format.</p> <p>The reason for not having an external representation of compiled match specifications is performance. It may be subject to change in future releases, while this interface will remain for backward compatibility.</p> </div> </div>  <h3 id="safe_fixtable-2" class="code">safe_fixtable(Name, Fix) -&gt; ok</h3> <p>Types:</p>    <pre>Name = <a href="#type-tab_name">tab_name()</a>
Fix = boolean()</pre>

<p>If <code class="code">Fix</code> is <code class="code">true</code>, the table <code class="code">Name</code> is fixed (once more) by the calling process, otherwise the table is released. The table is also released when a fixing process terminates. </p> <p>If several processes fix a table, the table will remain fixed until all processes have released it or terminated. A reference counter is kept on a per process basis, and N consecutive fixes require N releases to release the table.</p> <p>It is not guaranteed that calls to <code class="code">first/1</code>, <code class="code">next/2</code>, select and match functions work as expected even if the table has been fixed; the limited support for concurrency implemented in Ets has not yet been implemented in Dets. Fixing a table currently only disables resizing of the hash list of the table.</p> <p>If objects have been added while the table was fixed, the hash list will start to grow when the table is released which will significantly slow down access to the table for a period of time.</p>  <h3 id="select-1" class="code">select(Continuation) -&gt;<br>          {Selection, Continuation2} |<br>          '$end_of_table' |<br>          {error, Reason}</h3> <p>Types:</p>      <pre>Continuation = Continuation2 = <a href="#type-select_cont">select_cont()</a>

Selection = [term()]
Reason = term()</pre>

<p>Applies a match specification to some objects stored in a table and returns a non-empty list of the results. The table, the match specification, and the number of objects that are matched are all defined by <code class="code">Continuation</code>, which has been returned by a prior call to <code class="code">select/1</code> or <code class="code">select/3</code>.</p> <p>When all objects of the table have been matched, <code class="code">'$end_of_table'</code> is returned.</p>  <h3 id="select-2" class="code">select(Name, MatchSpec) -&gt; Selection | {error, Reason}</h3> <p>Types:</p>      <pre>Name = <a href="#type-tab_name">tab_name()</a>
MatchSpec = <a href="#type-match_spec">match_spec()</a>
Selection = [term()]
Reason = term()</pre>

<p>Returns the results of applying the match specification <code class="code">MatchSpec</code> to all or some objects stored in the table <code class="code">Name</code>. The order of the objects is not specified. See the ERTS User's Guide for a description of match specifications.</p> <p>If the keypos'th element of <code class="code">MatchSpec</code> is unbound, the match specification is applied to all objects of the table. If the keypos'th element is bound, the match specification is applied to the objects with the right key(s) only.</p> <p>Using the <code class="code">select</code> functions for traversing all objects of a table is more efficient than calling <code class="code">first/1</code> and <code class="code">next/2</code> or <code class="code">slot/2</code>. </p>  <h3 id="select-3" class="code">select(Name, MatchSpec, N) -&gt;<br>          {Selection, Continuation} |<br>          '$end_of_table' |<br>          {error, Reason}</h3> <p>Types:</p>        <pre>Name = <a href="#type-tab_name">tab_name()</a>
MatchSpec = <a href="#type-match_spec">match_spec()</a>
N = default | integer() &gt;= 0
Continuation = <a href="#type-select_cont">select_cont()</a>
Selection = [term()]
Reason = term()</pre>

<p>Returns the results of applying the match specification <code class="code">MatchSpec</code> to some or all objects stored in the table <code class="code">Name</code>. The order of the objects is not specified. See the ERTS User's Guide for a description of match specifications.</p> <p>A tuple of the results of applying the match specification and a continuation is returned, unless the table is empty, in which case <code class="code">'$end_of_table'</code> is returned. The continuation is to be used when matching further objects by calling <code class="code">select/1</code>.</p> <p>If the keypos'th element of <code class="code">MatchSpec</code> is bound, the match specification is applied to all objects of the table with the right key(s). If the keypos'th element of <code class="code">MatchSpec</code> is unbound, the match specification is applied to all objects of the table, <code class="code">N</code> objects at a time, until at least one object matches or the end of the table has been reached. The default, indicated by giving <code class="code">N</code> the value <code class="code">default</code>, is to let the number of objects vary depending on the sizes of the objects. If <code class="code">Name</code> is a version 9 table, all objects with the same key are always handled at the same time which implies that the match specification may be applied to more than N objects. </p> <p>The table should always be protected using <code class="code">safe_fixtable/2</code> before calling <code class="code">select/3</code>, or errors may occur when calling <code class="code">select/1</code>.</p>  <h3 id="select_delete-2" class="code">select_delete(Name, MatchSpec) -&gt; N | {error, Reason}</h3> <p>Types:</p>      <pre>Name = <a href="#type-tab_name">tab_name()</a>
MatchSpec = <a href="#type-match_spec">match_spec()</a>
N = integer() &gt;= 0
Reason = term()</pre>

<p>Deletes each object from the table <code class="code">Name</code> such that applying the match specification <code class="code">MatchSpec</code> to the object returns the value <code class="code">true</code>. See the ERTS User's Guide for a description of match specifications. Returns the number of deleted objects.</p> <p>If the keypos'th element of <code class="code">MatchSpec</code> is bound, the match specification is applied to the objects with the right key(s) only.</p>  <h3 id="slot-2" class="code">slot(Name, I) -&gt; '$end_of_table' | Objects | {error, Reason}</h3> <p>Types:</p>      <pre>Name = <a href="#type-tab_name">tab_name()</a>
I = integer() &gt;= 0
Objects = [<a href="#type-object">object()</a>]
Reason = term()</pre>

<p>The objects of a table are distributed among slots, starting with slot <code class="code">0</code> and ending with slot n. This function returns the list of objects associated with slot <code class="code">I</code>. If <code class="code">I</code> is greater than n <code class="code">'$end_of_table'</code> is returned.</p>  <h3 id="sync-1" class="code">sync(Name) -&gt; ok | {error, Reason}</h3> <p>Types:</p>    <pre>Name = <a href="#type-tab_name">tab_name()</a>
Reason = term()</pre>

<p>Ensures that all updates made to the table <code class="code">Name</code> are written to disk. This also applies to tables which have been opened with the <code class="code">ram_file</code> flag set to <code class="code">true</code>. In this case, the contents of the RAM file are flushed to disk.</p> <p>Note that the space management data structures kept in RAM, the buddy system, is also written to the disk. This may take some time if the table is fragmented.</p>  <h3 id="table-2" class="code">table(Name) -&gt; QueryHandle<br>table(Name, Options) -&gt; QueryHandle</h3> <p>Types:</p>        <pre>Name = <a href="#type-tab_name">tab_name()</a>
Options = Option | [Option]
Option = {n_objects, Limit} | {traverse, TraverseMethod}
Limit = default | integer() &gt;= 1
TraverseMethod = first_next | select | {select, <a href="#type-match_spec">match_spec()</a>}
QueryHandle = <a href="../qlc/#type-query_handle">qlc:query_handle()</a></pre>

<p id="qlc_table">Returns a QLC (Query List Comprehension) query handle. The module <code class="code">qlc</code> implements a query language aimed mainly at Mnesia but Ets tables, Dets tables, and lists are also recognized by <code class="code">qlc</code> as sources of data. Calling <code class="code">dets:table/1,2</code> is the means to make the Dets table <code class="code">Name</code> usable to <code class="code">qlc</code>.</p> <p>When there are only simple restrictions on the key position <code class="code">qlc</code> uses <code class="code">dets:lookup/2</code> to look up the keys, but when that is not possible the whole table is traversed. The option <code class="code">traverse</code> determines how this is done:</p> <ul> <li> <p><code class="code">first_next</code>. The table is traversed one key at a time by calling <code class="code">dets:first/1</code> and <code class="code">dets:next/2</code>.</p> </li> <li> <p><code class="code">select</code>. The table is traversed by calling <code class="code">dets:select/3</code> and <code class="code">dets:select/1</code>. The option <code class="code">n_objects</code> determines the number of objects returned (the third argument of <code class="code">select/3</code>). The match specification (the second argument of <code class="code">select/3</code>) is assembled by <code class="code">qlc</code>: simple filters are translated into equivalent match specifications while more complicated filters have to be applied to all objects returned by <code class="code">select/3</code> given a match specification that matches all objects.</p> </li> <li> <p><code class="code">{select,</code><code class="bold_code"><a href="#type-match_spec"> match_spec()</a></code><code class="code">}</code>. As for <code class="code">select</code> the table is traversed by calling <code class="code">dets:select/3</code> and <code class="code">dets:select/1</code>. The difference is that the match specification is explicitly given. This is how to state match specifications that cannot easily be expressed within the syntax provided by <code class="code">qlc</code>.</p> </li> </ul> <p>The following example uses an explicit match specification to traverse the table:</p> <div class="example"><pre>
1&gt; dets:open_file(t, []),
ok = dets:insert(t, [{1,a},{2,b},{3,c},{4,d}]),
MS = ets:fun2ms(fun({X,Y}) when (X &gt; 1) or (X &lt; 5) -&gt; {Y} end),
QH1 = dets:table(t, [{traverse, {select, MS}}]).        </pre></div> <p>An example with implicit match specification:</p> <div class="example"><pre>
2&gt; QH2 = qlc:q([{Y} || {X,Y} &lt;- dets:table(t), (X &gt; 1) or (X &lt; 5)]).        </pre></div> <p>The latter example is in fact equivalent to the former which can be verified using the function <code class="code">qlc:info/1</code>:</p> <div class="example"><pre>
3&gt; qlc:info(QH1) =:= qlc:info(QH2).
true        </pre></div> <p><code class="code">qlc:info/1</code> returns information about a query handle, and in this case identical information is returned for the two query handles.</p>  <h3 id="to_ets-2" class="code">to_ets(Name, EtsTab) -&gt; EtsTab | {error, Reason}</h3> <p>Types:</p>     <pre>Name = <a href="#type-tab_name">tab_name()</a>
EtsTab = <a href="../ets/#type-tab">ets:tab()</a>
Reason = term()</pre>

<p>Inserts the objects of the Dets table <code class="code">Name</code> into the Ets table <code class="code">EtsTab</code>. The order in which the objects are inserted is not specified. The existing objects of the Ets table are kept unless overwritten.</p>  <h3 id="traverse-2" class="code">traverse(Name, Fun) -&gt; Return | {error, Reason}</h3> <p>Types:</p>           <pre>Name = <a href="#type-tab_name">tab_name()</a>
Fun = fun((Object) -&gt; FunReturn)
Object = <a href="#type-object">object()</a>
FunReturn = 
    continue | {continue, Val} | {done, Value} | OtherValue
Return = [term()] | OtherValue
Val = Value = OtherValue = Reason = term()</pre>

<p>Applies <code class="code">Fun</code> to each object stored in the table <code class="code">Name</code> in some unspecified order. Different actions are taken depending on the return value of <code class="code">Fun</code>. The following <code class="code">Fun</code> return values are allowed:</p> <dl> <dt><strong><code class="code">continue</code></strong></dt> <dd> <p>Continue to perform the traversal. For example, the following function can be used to print out the contents of a table:</p> <div class="example"><pre>
fun(X) -&gt; io:format("~p~n", [X]), continue end.            </pre></div> </dd> <dt><strong><code class="code">{continue, Val}</code></strong></dt> <dd> <p>Continue the traversal and accumulate <code class="code">Val</code>. The following function is supplied in order to collect all objects of a table in a list: </p> <div class="example"><pre>
fun(X) -&gt; {continue, X} end.            </pre></div> </dd> <dt><strong><code class="code">{done, Value}</code></strong></dt> <dd> <p>Terminate the traversal and return <code class="code">[Value | Acc]</code>.</p> </dd> </dl> <p>Any other value <code class="code">OtherValue</code> returned by <code class="code">Fun</code> terminates the traversal and is immediately returned. </p>  <h3 id="update_counter-3" class="code">update_counter(Name, Key, Increment) -&gt; Result</h3> <p>Types:</p>        <pre>Name = <a href="#type-tab_name">tab_name()</a>
Key = term()
Increment = {Pos, Incr} | Incr
Pos = Incr = Result = integer()</pre>

<p>Updates the object with key <code class="code">Key</code> stored in the table <code class="code">Name</code> of type <code class="code">set</code> by adding <code class="code">Incr</code> to the element at the <code class="code">Pos</code>:th position. The new counter value is returned. If no position is specified, the element directly following the key is updated.</p> <p>This functions provides a way of updating a counter, without having to look up an object, update the object by incrementing an element and insert the resulting object into the table again.</p>  <h2 id="id169753">See Also</h2>  <p><code class="bold_code"><a href="../ets/">ets(3)</a></code>, mnesia(3), <code class="bold_code"><a href="../qlc/">qlc(3)</a></code></p>
<div class="_attribution">
  <p class="_attribution-p">
    © 1999–2016 Ericsson AB<br>Licensed under the Apache License, Version 2.0.<br>
    
  </p>
</div>

			</div>
		</div>
	</section>

	</div>
</body>
</html>
