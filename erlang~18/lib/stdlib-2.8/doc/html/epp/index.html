
<!DOCTYPE HTML>

<html lang="en">

<head>
  <meta charset="utf-8">
  <title>Epp - Erlang 18 - W3cubDocs</title>
  
  <meta name="description" content=" epp ">
  <meta name="keywords" content="epp, -, erlang, erlang~18">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="http://docs.w3cub.com/erlang~18/lib/stdlib-2.8/doc/html/epp/">
  <link href="/favicon.png" rel="icon">
  <link type="text/css" rel="stylesheet" href="/assets/application-50364fff564ce3b6327021805f3f00e2957b441cf27f576a7dd4ff63bbc47047.css">
  <script type="text/javascript" src="/assets/application-db64bfd54ceb42be11af7995804cf4902548419ceb79d509b0b7d62c22d98e6f.js"></script>
  <script src="/json/erlang~18.js"></script>
  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-71174418-1']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>


</head>

<body>
	<div class="_app">
	<header class="_header">
  
  <form class="_search">
    <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
    <a class="_search-clear"></a>
    <div class="_search-tag"></div>
  </form>
  
  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/erlang~18/" class="_nav-link" title="" style="margin-left:0;">Erlang 18</a></span>
  
  <nav class="_nav">
    <a href="/app/" class="_nav-link ">App</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		<div class="_list">
			
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<div class="_page _erlang">
				
<h1>epp</h1> <h2>Module</h2> <p class="REFBODY">epp</p> <h2>Module summary</h2> <p class="REFBODY">An Erlang Code Preprocessor</p> <h2>Description</h2> 
<p>The Erlang code preprocessor includes functions which are used by <code class="code">compile</code> to preprocess macros and include files before the actual parsing takes place.</p> <p id="encoding">The Erlang source file <strong>encoding</strong> is selected by a comment in one of the first two lines of the source file. The first string that matches the regular expression <code class="code">coding\s*[:=]\s*([-a-zA-Z0-9])+</code> selects the encoding. If the matching string is not a valid encoding it is ignored. The valid encodings are <code class="code">Latin-1</code> and <code class="code">UTF-8</code> where the case of the characters can be chosen freely. Examples:</p> <div class="example"><pre>
%% coding: utf-8</pre></div> <div class="example"><pre>
%% For this file we have chosen encoding = Latin-1</pre></div> <div class="example"><pre>
%% -*- coding: latin-1 -*-</pre></div>  <h2>Data types</h2> <h3 class="code">macros() = [atom() | {atom(), term()}]</h3> <h3 class="code">epp_handle() = pid()</h3> 
<p>Handle to the epp server.</p> <h3 class="code">source_encoding() = latin1 | utf8</h3> <h2>Exports</h2> <h3 id="open-1" class="code">open(Options) -&gt;<br>        {ok, Epp} | {ok, Epp, Extra} | {error, ErrorDescriptor}</h3> <p>Types:</p>      <pre>Options = 
    [{default_encoding, DefEncoding :: <a href="#type-source_encoding">source_encoding()</a>} |
     {includes, IncludePath :: [DirectoryName :: file:name()]} |
     {macros, PredefMacros :: <a href="#type-macros">macros()</a>} |
     {name, FileName :: file:name()} |
     extra]
Epp = <a href="#type-epp_handle">epp_handle()</a>
Extra = [{encoding, <a href="#type-source_encoding">source_encoding()</a> | none}]
ErrorDescriptor = term()</pre>

<p>Opens a file for preprocessing.</p> <p>If <code class="code">extra</code> is given in <code class="code">Options</code>, the return value will be <code class="code">{ok, Epp, Extra}</code> instead of <code class="code">{ok, Epp}</code>.</p>  <h3 id="open-2" class="code">open(FileName, IncludePath) -&gt;<br>        {ok, Epp} | {error, ErrorDescriptor}</h3> <p>Types:</p>      <pre>FileName = file:name()
IncludePath = [DirectoryName :: file:name()]
Epp = <a href="#type-epp_handle">epp_handle()</a>
ErrorDescriptor = term()</pre>

<p>Equivalent to <code class="code">epp:open([{name, FileName}, {includes, IncludePath}])</code>.</p>  <h3 id="open-3" class="code">open(FileName, IncludePath, PredefMacros) -&gt;<br>        {ok, Epp} | {error, ErrorDescriptor}</h3> <p>Types:</p>       <pre>FileName = file:name()
IncludePath = [DirectoryName :: file:name()]
PredefMacros = <a href="#type-macros">macros()</a>
Epp = <a href="#type-epp_handle">epp_handle()</a>
ErrorDescriptor = term()</pre>

<p>Equivalent to <code class="code">epp:open([{name, FileName}, {includes, IncludePath}, {macros, PredefMacros}])</code>.</p>  <h3 id="close-1" class="code">close(Epp) -&gt; ok</h3> <p>Types:</p>   <pre>Epp = <a href="#type-epp_handle">epp_handle()</a></pre>

<p>Closes the preprocessing of a file.</p>  <h3 id="parse_erl_form-1" class="code">parse_erl_form(Epp) -&gt;<br>                  {ok, AbsForm} | {eof, Line} | {error, ErrorInfo}</h3> <p>Types:</p>      <pre>Epp = <a href="#type-epp_handle">epp_handle()</a>
AbsForm = <a href="../erl_parse/#type-abstract_form">erl_parse:abstract_form()</a>
Line = <a href="../erl_anno/#type-line">erl_anno:line()</a>
ErrorInfo = <a href="../erl_scan/#type-error_info">erl_scan:error_info()</a> | <a href="../erl_parse/#type-error_info">erl_parse:error_info()</a></pre>

<p>Returns the next Erlang form from the opened Erlang source file. The tuple <code class="code">{eof, Line}</code> is returned at end-of-file. The first form corresponds to an implicit attribute <code class="code">-file(File,1).</code>, where <code class="code">File</code> is the name of the file.</p>  <h3 id="parse_file-2" class="code">parse_file(FileName, Options) -&gt;<br>              {ok, [Form]} |<br>              {ok, [Form], Extra} |<br>              {error, OpenError}</h3> <p>Types:</p>         <pre>FileName = file:name()
Options = 
    [{includes, IncludePath :: [DirectoryName :: file:name()]} |
     {macros, PredefMacros :: <a href="#type-macros">macros()</a>} |
     {default_encoding, DefEncoding :: <a href="#type-source_encoding">source_encoding()</a>} |
     extra]
Form = 
    <a href="../erl_parse/#type-abstract_form">erl_parse:abstract_form()</a> | {error, ErrorInfo} | {eof, Line}
Line = <a href="../erl_anno/#type-line">erl_anno:line()</a>
ErrorInfo = <a href="../erl_scan/#type-error_info">erl_scan:error_info()</a> | <a href="../erl_parse/#type-error_info">erl_parse:error_info()</a>
Extra = [{encoding, <a href="#type-source_encoding">source_encoding()</a> | none}]
OpenError = file:posix() | badarg | system_limit</pre>

<p>Preprocesses and parses an Erlang source file. Note that the tuple <code class="code">{eof, Line}</code> returned at end-of-file is included as a "form".</p> <p>If <code class="code">extra</code> is given in <code class="code">Options</code>, the return value will be <code class="code">{ok, [Form], Extra}</code> instead of <code class="code">{ok, [Form]}</code>.</p>  <h3 id="parse_file-3" class="code">parse_file(FileName, IncludePath, PredefMacros) -&gt;<br>              {ok, [Form]} | {error, OpenError}</h3> <p>Types:</p>         <pre>FileName = file:name()
IncludePath = [DirectoryName :: file:name()]
Form = 
    <a href="../erl_parse/#type-abstract_form">erl_parse:abstract_form()</a> | {error, ErrorInfo} | {eof, Line}
PredefMacros = <a href="#type-macros">macros()</a>
Line = <a href="../erl_anno/#type-line">erl_anno:line()</a>
ErrorInfo = <a href="../erl_scan/#type-error_info">erl_scan:error_info()</a> | <a href="../erl_parse/#type-error_info">erl_parse:error_info()</a>
OpenError = file:posix() | badarg | system_limit</pre>

<p>Equivalent to <code class="code">epp:parse_file(FileName, [{includes, IncludePath}, {macros, PredefMacros}])</code>.</p>  <h3 id="default_encoding-0" class="code">default_encoding() -&gt; <a href="#type-source_encoding">source_encoding()</a>
</h3> 
<p>Returns the default encoding of Erlang source files.</p>  <h3 id="encoding_to_string-1" class="code">encoding_to_string(Encoding) -&gt; string()</h3> <p>Types:</p>   <pre>Encoding = <a href="#type-source_encoding">source_encoding()</a></pre>

<p>Returns a string representation of an encoding. The string is recognized by <code class="code">read_encoding/1,2</code>, <code class="code">read_encoding_from_binary/1,2</code>, and <code class="code">set_encoding/1,2</code> as a valid encoding.</p>  <h3 id="read_encoding-2" class="code">read_encoding(FileName) -&gt; <a href="#type-source_encoding">source_encoding()</a> | none<br>read_encoding(FileName, Options) -&gt; <a href="#type-source_encoding">source_encoding()</a> | none</h3> <p>Types:</p>     <pre>FileName = file:name()
Options = [Option]
Option = {in_comment_only, boolean()}</pre>

<p>Read the <code class="bold_code"><a href="#encoding">encoding</a></code> from a file. Returns the read encoding, or <code class="code">none</code> if no valid encoding was found.</p> <p>The option <code class="code">in_comment_only</code> is <code class="code">true</code> by default, which is correct for Erlang source files. If set to <code class="code">false</code> the encoding string does not necessarily have to occur in a comment.</p>  <h3 id="read_encoding_from_binary-2" class="code">read_encoding_from_binary(Binary) -&gt; <a href="#type-source_encoding">source_encoding()</a> | none<br>read_encoding_from_binary(Binary, Options) -&gt;<br>                             <a href="#type-source_encoding">source_encoding()</a> | none</h3> <p>Types:</p>     <pre>Binary = binary()
Options = [Option]
Option = {in_comment_only, boolean()}</pre>

<p>Read the <code class="bold_code"><a href="#encoding">encoding</a></code> from a binary. Returns the read encoding, or <code class="code">none</code> if no valid encoding was found.</p> <p>The option <code class="code">in_comment_only</code> is <code class="code">true</code> by default, which is correct for Erlang source files. If set to <code class="code">false</code> the encoding string does not necessarily have to occur in a comment.</p>  <h3 id="set_encoding-1" class="code">set_encoding(File) -&gt; <a href="#type-source_encoding">source_encoding()</a> | none</h3> <p>Types:</p>   <pre>File = <a href="../io/#type-device">io:device()</a></pre>

<p>Reads the <code class="bold_code"><a href="#encoding">encoding</a></code> from an IO device and sets the encoding of the device accordingly. The position of the IO device referenced by <code class="code">File</code> is not affected. If no valid encoding can be read from the IO device the encoding of the IO device is set to the default encoding.</p> <p>Returns the read encoding, or <code class="code">none</code> if no valid encoding was found.</p>  <h3 id="set_encoding-2" class="code">set_encoding(File, Default) -&gt; <a href="#type-source_encoding">source_encoding()</a> | none</h3> <p>Types:</p>    <pre>Default = <a href="#type-source_encoding">source_encoding()</a>
File = <a href="../io/#type-device">io:device()</a></pre>

<p>Reads the <code class="bold_code"><a href="#encoding">encoding</a></code> from an IO device and sets the encoding of the device accordingly. The position of the IO device referenced by <code class="code">File</code> is not affected. If no valid encoding can be read from the IO device the encoding of the IO device is set to the <code class="bold_code"><a href="#encoding">encoding</a></code> given by <code class="code">Default</code>.</p> <p>Returns the read encoding, or <code class="code">none</code> if no valid encoding was found.</p>  <h3 id="format_error-1" class="code">format_error(ErrorDescriptor) -&gt; <a href="../io_lib/#type-chars">io_lib:chars()</a>
</h3> <p>Types:</p>   <pre>ErrorDescriptor = term()</pre>

<p>Takes an <code class="code">ErrorDescriptor</code> and returns a string which describes the error or warning. This function is usually called implicitly when processing an <code class="code">ErrorInfo</code> structure (see below).</p>  <h2 id="id174724">Error Information</h2>  <p>The <code class="code">ErrorInfo</code> mentioned above is the standard <code class="code">ErrorInfo</code> structure which is returned from all IO modules. It has the following format: </p> <div class="example"><pre>
{ErrorLine, Module, ErrorDescriptor}    </pre></div> <p>A string which describes the error is obtained with the following call: </p> <div class="example"><pre>
Module:format_error(ErrorDescriptor)    </pre></div>  <h2 id="id174761">See Also</h2>  <p><code class="bold_code"><a href="../erl_parse/">erl_parse(3)</a></code></p>
<div class="_attribution">
  <p class="_attribution-p">
    © 1999–2016 Ericsson AB<br>Licensed under the Apache License, Version 2.0.<br>
    
  </p>
</div>

			</div>
		</div>
	</section>

	</div>
</body>
</html>
