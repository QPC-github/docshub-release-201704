
<!DOCTYPE HTML>

<html lang="en">

<head>
  <meta charset="utf-8">
  <title>Io - Erlang 18 - W3cubDocs</title>
  
  <meta name="description" content=" io ">
  <meta name="keywords" content="io, -, erlang, erlang~18">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="http://docs.w3cub.com/erlang~18/lib/stdlib-2.8/doc/html/io/">
  <link href="/favicon.png" rel="icon">
  <link type="text/css" rel="stylesheet" href="/assets/application-50364fff564ce3b6327021805f3f00e2957b441cf27f576a7dd4ff63bbc47047.css">
  <script type="text/javascript" src="/assets/application-db64bfd54ceb42be11af7995804cf4902548419ceb79d509b0b7d62c22d98e6f.js"></script>
  <script src="/json/erlang~18.js"></script>
  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-71174418-1']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>


</head>

<body>
	<div class="_app">
	<header class="_header">
  
  <form class="_search">
    <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
    <a class="_search-clear"></a>
    <div class="_search-tag"></div>
  </form>
  
  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/erlang~18/" class="_nav-link" title="" style="margin-left:0;">Erlang 18</a></span>
  
  <nav class="_nav">
    <a href="/app/" class="_nav-link ">App</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		<div class="_list">
			
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<div class="_page _erlang">
				
<h1>io</h1> <h2>Module</h2> <p class="REFBODY">io</p> <h2>Module summary</h2> <p class="REFBODY">Standard I/O Server Interface Functions</p> <h2>Description</h2> 
<p>This module provides an interface to standard Erlang I/O servers. The output functions all return <code class="code">ok</code> if they are successful, or exit if they are not.</p> <p>In the following description, all functions have an optional parameter <code class="code">IoDevice</code>. If included, it must be the pid of a process which handles the IO protocols. Normally, it is the <code class="code">IoDevice</code> returned by <code class="bold_code">file:open/2</code>.</p> <p>For a description of the IO protocols refer to the <code class="bold_code"><a href="../io_protocol/">STDLIB User's Guide</a></code>.</p> <div class="warning"> <div class="label">Warning</div> <div class="content">

<p>As of R13A, data supplied to the <code class="bold_code"><a href="#put_chars-2">put_chars</a></code> function should be in the <code class="bold_code"><a href="../unicode/#type-chardata"><span class="code">unicode:chardata()</span></a></code> format. This means that programs supplying binaries to this function need to convert them to UTF-8 before trying to output the data on an IO device.</p> <p>If an IO device is set in binary mode, the functions <code class="bold_code"><a href="#get_chars-3">get_chars</a></code> and <code class="bold_code"><a href="#get_line-2">get_line</a></code> may return binaries instead of lists. The binaries will, as of R13A, be encoded in UTF-8.</p> <p>To work with binaries in ISO-latin-1 encoding, use the <code class="bold_code">file</code> module instead.</p> <p>For conversion functions between character encodings, see the <code class="bold_code">unicode</code> module.</p> </div> </div>  <h2>Data types</h2> <h3 class="code">device() = atom() | pid()</h3> 
<p>An IO device. Either <code class="code">standard_io</code>, <code class="code">standard_error</code>, a registered name, or a pid handling IO protocols (returned from <code class="bold_code">file:open/2</code>).</p>  <h3 class="code">opt_pair() = <br>    {binary, boolean()} |<br>    {echo, boolean()} |<br>    {expand_fun, <a href="#type-expand_fun">expand_fun()</a>} |<br>    {encoding, <a href="#type-encoding">encoding()</a>}</h3> <h3 class="code">expand_fun() = <br>    fun((term()) -&gt; {yes | no, string(), [string(), ...]})</h3> <h3 class="code">encoding() = <br>    latin1 |<br>    unicode |<br>    utf8 |<br>    utf16 |<br>    utf32 |<br>    {utf16, big | little} |<br>    {utf32, big | little}</h3> <h3 class="code">setopt() = binary | list | <a href="#type-opt_pair">opt_pair()</a>
</h3> <h3 class="code">format() = atom() | string() | binary()</h3> <h3 class="code">location() = <a href="../erl_anno/#type-location">erl_anno:location()</a>
</h3> <h3 class="code">prompt() = atom() | <a href="../unicode/#type-chardata">unicode:chardata()</a>
</h3> <h3 class="code">server_no_data() = {error, ErrorDescription :: term()} | eof</h3> 
<p>What the I/O-server sends when there is no data.</p> <h2>Exports</h2> <h3 id="columns-1" class="code">columns() -&gt; {ok, integer() &gt;= 1} | {error, enotsup}<br>columns(IoDevice) -&gt; {ok, integer() &gt;= 1} | {error, enotsup}</h3> <p>Types:</p>   <pre>IoDevice = <a href="#type-device">device()</a></pre>

<p>Retrieves the number of columns of the <code class="code">IoDevice</code> (i.e. the width of a terminal). The function only succeeds for terminal devices, for all other IO devices the function returns <code class="code">{error, enotsup}</code></p>  <h3 id="put_chars-2" class="code">put_chars(CharData) -&gt; ok<br>put_chars(IoDevice, CharData) -&gt; ok</h3> <p>Types:</p>    <pre>IoDevice = <a href="#type-device">device()</a>
CharData = <a href="../unicode/#type-chardata">unicode:chardata()</a></pre>

<p>Writes the characters of <code class="code">CharData</code> to the I/O server (<code class="code">IoDevice</code>).</p>  <h3 id="nl-1" class="code">nl() -&gt; ok<br>nl(IoDevice) -&gt; ok</h3> <p>Types:</p>   <pre>IoDevice = <a href="#type-device">device()</a></pre>

<p>Writes new line to the standard output (<code class="code">IoDevice</code>).</p>  <h3 id="get_chars-3" class="code">get_chars(Prompt, Count) -&gt; Data | <a href="#type-server_no_data">server_no_data()</a><br>get_chars(IoDevice, Prompt, Count) -&gt; Data | <a href="#type-server_no_data">server_no_data()</a>
</h3> <p>Types:</p>       <pre>IoDevice = <a href="#type-device">device()</a>
Prompt = <a href="#type-prompt">prompt()</a>
Count = integer() &gt;= 0
Data = string() | <a href="../unicode/#type-unicode_binary">unicode:unicode_binary()</a>
server_no_data() = {error, ErrorDescription :: term()} | eof</pre>

<p>Reads <code class="code">Count</code> characters from standard input (<code class="code">IoDevice</code>), prompting it with <code class="code">Prompt</code>. It returns:</p> <dl> <dt><strong><code class="code">Data</code></strong></dt> <dd> <p>The input characters. If the IO device supports Unicode, the data may represent codepoints larger than 255 (the latin1 range). If the I/O server is set to deliver binaries, they will be encoded in UTF-8 (regardless of if the IO device actually supports Unicode or not).</p> </dd> <dt><strong><code class="code">eof</code></strong></dt> <dd> <p>End of file was encountered.</p> </dd> <dt><strong><code class="code">{error, ErrorDescription}</code></strong></dt> <dd> <p>Other (rare) error condition, for instance <code class="code">{error, estale}</code> if reading from an NFS file system.</p> </dd> </dl>  <h3 id="get_line-2" class="code">get_line(Prompt) -&gt; Data | <a href="#type-server_no_data">server_no_data()</a><br>get_line(IoDevice, Prompt) -&gt; Data | <a href="#type-server_no_data">server_no_data()</a>
</h3> <p>Types:</p>      <pre>IoDevice = <a href="#type-device">device()</a>
Prompt = <a href="#type-prompt">prompt()</a>
Data = string() | <a href="../unicode/#type-unicode_binary">unicode:unicode_binary()</a>
server_no_data() = {error, ErrorDescription :: term()} | eof</pre>

<p>Reads a line from the standard input (<code class="code">IoDevice</code>), prompting it with <code class="code">Prompt</code>. It returns:</p> <dl> <dt><strong><code class="code">Data</code></strong></dt> <dd> <p>The characters in the line terminated by a LF (or end of file). If the IO device supports Unicode, the data may represent codepoints larger than 255 (the latin1 range). If the I/O server is set to deliver binaries, they will be encoded in UTF-8 (regardless of if the IO device actually supports Unicode or not).</p> </dd> <dt><strong><code class="code">eof</code></strong></dt> <dd> <p>End of file was encountered.</p> </dd> <dt><strong><code class="code">{error, ErrorDescription}</code></strong></dt> <dd> <p>Other (rare) error condition, for instance <code class="code">{error, estale}</code> if reading from an NFS file system.</p> </dd> </dl>  <h3 id="getopts-1" class="code">getopts() -&gt; [<a href="#type-opt_pair">opt_pair()</a>] | {error, Reason}<br>getopts(IoDevice) -&gt; [<a href="#type-opt_pair">opt_pair()</a>] | {error, Reason}</h3> <p>Types:</p>    <pre>IoDevice = <a href="#type-device">device()</a>
Reason = term()</pre>

<p>This function requests all available options and their current values for a specific IO device. Example:</p> <div class="example"><pre>
1&gt; {ok,F} = file:open("/dev/null",[read]).
{ok,&lt;0.42.0&gt;}
2&gt; io:getopts(F).
[{binary,false},{encoding,latin1}]</pre></div> <p>Here the file I/O-server returns all available options for a file, which are the expected ones, <code class="code">encoding</code> and <code class="code">binary</code>. The standard shell however has some more options:</p> <div class="example"><pre>
3&gt; io:getopts().
[{expand_fun,#Fun&lt;group.0.120017273&gt;},
 {echo,true},
 {binary,false},
 {encoding,unicode}]</pre></div> <p>This example is, as can be seen, run in an environment where the terminal supports Unicode input and output.</p>  <h3 id="printable_range-0" class="code">printable_range() -&gt; unicode | latin1</h3> 
<p>Return the user requested range of printable Unicode characters.</p> <p>The user can request a range of characters that are to be considered printable in heuristic detection of strings by the shell and by the formatting functions. This is done by supplying <code class="code">+pc &lt;range&gt;</code> when starting Erlang.</p> <p>Currently the only valid values for <code class="code">&lt;range&gt;</code> are <code class="code">latin1</code> and <code class="code">unicode</code>. <code class="code">latin1</code> means that only code points below 256 (with the exception of control characters etc) will be considered printable. <code class="code">unicode</code> means that all printable characters in all unicode character ranges are considered printable by the io functions.</p> <p>By default, Erlang is started so that only the <code class="code">latin1</code> range of characters will indicate that a list of integers is a string.</p> <p>The simplest way to utilize the setting is to call <code class="bold_code"><a href="../io_lib/#printable_list-1">io_lib:printable_list/1</a></code>, which will use the return value of this function to decide if a list is a string of printable characters or not.</p> <div class="note"> <div class="label">Note</div> <div class="content">

<p>In the future, this function may return more values and ranges. It is recommended to use the io_lib:printable_list/1 function to avoid compatibility problems.</p>
</div> </div>  <h3 id="setopts-2" class="code">setopts(Opts) -&gt; ok | {error, Reason}<br>setopts(IoDevice, Opts) -&gt; ok | {error, Reason}</h3> <p>Types:</p>     <pre>IoDevice = <a href="#type-device">device()</a>
Opts = [<a href="#type-setopt">setopt()</a>]
Reason = term()</pre>

<p>Set options for the standard IO device (<code class="code">IoDevice</code>).</p> <p>Possible options and values vary depending on the actual IO device. For a list of supported options and their current values on a specific IO device, use the <code class="bold_code"><a href="#getopts-1">getopts/1</a></code> function.</p> <p>The options and values supported by the current OTP IO devices are:</p> <dl> <dt><strong><code class="code">binary, list or {binary, boolean()}</code></strong></dt> <dd> <p>If set in binary mode (<code class="code">binary</code> or <code class="code">{binary, true}</code>), the I/O server sends binary data (encoded in UTF-8) as answers to the <code class="code">get_line</code>, <code class="code">get_chars</code> and, if possible, <code class="code">get_until</code> requests (see the I/O protocol description in <code class="bold_code"><a href="../io_protocol/">STDLIB User's Guide</a></code> for details). The immediate effect is that <code class="code">get_chars/2,3</code> and <code class="code">get_line/1,2</code> return UTF-8 binaries instead of lists of chars for the affected IO device.</p> <p>By default, all IO devices in OTP are set in list mode, but the I/O functions can handle any of these modes and so should other, user written, modules behaving as clients to I/O-servers.</p> <p>This option is supported by the standard shell (<code class="code">group.erl</code>), the 'oldshell' (<code class="code">user.erl</code>) and the file I/O servers.</p> </dd> <dt><strong><code class="code">{echo, boolean()}</code></strong></dt> <dd> <p>Denotes if the terminal should echo input. Only supported for the standard shell I/O-server (<code class="code">group.erl</code>)</p> </dd> <dt><strong><code class="code">{expand_fun, expand_fun()}</code></strong></dt> <dd> <p>Provide a function for tab-completion (expansion) like the Erlang shell. This function is called when the user presses the TAB key. The expansion is active when calling line-reading functions such as <code class="code">get_line/1,2</code>.</p> <p>The function is called with the current line, upto the cursor, as a reversed string. It should return a three-tuple: <code class="code">{yes|no, string(), [string(), ...]}</code>. The first element gives a beep if <code class="code">no</code>, otherwise the expansion is silent, the second is a string that will be entered at the cursor position, and the third is a list of possible expansions. If this list is non-empty, the list will be printed and the current input line will be written once again.</p> <p>Trivial example (beep on anything except empty line, which is expanded to <code class="code">"quit"</code>):</p> <div class="example"><pre>
fun("") -&gt; {yes, "quit", []};
   (_) -&gt; {no, "", ["quit"]} end</pre></div> <p>This option is supported by the standard shell only (<code class="code">group.erl</code>).</p> </dd> <dt><strong><code class="code">{encoding, latin1 | unicode}</code></strong></dt> <dd> <p>Specifies how characters are input or output from or to the actual IO device, implying that i.e. a terminal is set to handle Unicode input and output or a file is set to handle UTF-8 data encoding.</p> <p>The option <strong>does not</strong> affect how data is returned from the I/O functions or how it is sent in the I/O-protocol, it only affects how the IO device is to handle Unicode characters towards the "physical" device.</p> <p>The standard shell will be set for either Unicode or latin1 encoding when the system is started. The actual encoding is set with the help of the <code class="code">LANG</code> or <code class="code">LC_CTYPE</code> environment variables on Unix-like system or by other means on other systems. The bottom line is that the user can input Unicode characters and the IO device will be in <code class="code">{encoding, unicode}</code> mode if the IO device supports it. The mode can be changed, if the assumption of the runtime system is wrong, by setting this option.</p> <p>The IO device used when Erlang is started with the "-oldshell" or "-noshell" flags is by default set to latin1 encoding, meaning that any characters beyond codepoint 255 will be escaped and that input is expected to be plain 8-bit ISO-latin-1. If the encoding is changed to Unicode, input and output from the standard file descriptors will be in UTF-8 (regardless of operating system).</p> <p>Files can also be set in <code class="code">{encoding, unicode}</code>, meaning that data is written and read as UTF-8. More encodings are possible for files, see below.</p> <p><code class="code">{encoding, unicode | latin1}</code> is supported by both the standard shell (<code class="code">group.erl</code> including <code class="code">werl</code> on Windows®), the 'oldshell' (<code class="code">user.erl</code>) and the file I/O servers.</p> </dd> <dt><strong><code class="code">{encoding, utf8 | utf16 | utf32 | {utf16,big} | {utf16,little} | {utf32,big} | {utf32,little}}</code></strong></dt> <dd> <p>For disk files, the encoding can be set to various UTF variants. This will have the effect that data is expected to be read as the specified encoding from the file and the data will be written in the specified encoding to the disk file.</p> <p><code class="code">{encoding, utf8}</code> will have the same effect as <code class="code">{encoding, unicode}</code> on files.</p> <p>The extended encodings are only supported on disk files (opened by the <code class="bold_code">file:open/2</code> function)</p> </dd> </dl>  <h3 id="write-2" class="code">write(Term) -&gt; ok<br>write(IoDevice, Term) -&gt; ok</h3> <p>Types:</p>    <pre>IoDevice = <a href="#type-device">device()</a>
Term = term()</pre>

<p>Writes the term <code class="code">Term</code> to the standard output (<code class="code">IoDevice</code>).</p>  <h3 id="read-2" class="code">read(Prompt) -&gt; Result<br>read(IoDevice, Prompt) -&gt; Result</h3> <p>Types:</p>       <pre>IoDevice = <a href="#type-device">device()</a>
Prompt = <a href="#type-prompt">prompt()</a>
Result = 
    {ok, Term :: term()} | <a href="#type-server_no_data">server_no_data()</a> | {error, ErrorInfo}
ErrorInfo = <a href="../erl_scan/#type-error_info">erl_scan:error_info()</a> | <a href="../erl_parse/#type-error_info">erl_parse:error_info()</a>
server_no_data() = {error, ErrorDescription :: term()} | eof</pre>

<p>Reads a term <code class="code">Term</code> from the standard input (<code class="code">IoDevice</code>), prompting it with <code class="code">Prompt</code>. It returns:</p> <dl> <dt><strong><code class="code">{ok, Term}</code></strong></dt> <dd> <p>The parsing was successful.</p> </dd> <dt><strong><code class="code">eof</code></strong></dt> <dd> <p>End of file was encountered.</p> </dd> <dt><strong><code class="code">{error, ErrorInfo}</code></strong></dt> <dd> <p>The parsing failed.</p> </dd> <dt><strong><code class="code">{error, ErrorDescription}</code></strong></dt> <dd> <p>Other (rare) error condition, for instance <code class="code">{error, estale}</code> if reading from an NFS file system.</p> </dd> </dl>  <h3 id="read-4" class="code">read(IoDevice, Prompt, StartLocation) -&gt; Result<br>read(IoDevice, Prompt, StartLocation, Options) -&gt; Result</h3> <p>Types:</p>         <pre>IoDevice = <a href="#type-device">device()</a>
Prompt = <a href="#type-prompt">prompt()</a>
StartLocation = <a href="#type-location">location()</a>
Options = <a href="../erl_scan/#type-options">erl_scan:options()</a>
Result = 
    {ok, Term :: term(), EndLocation :: <a href="#type-location">location()</a>} |
    {eof, EndLocation :: <a href="#type-location">location()</a>} |
    <a href="#type-server_no_data">server_no_data()</a> |
    {error, ErrorInfo, ErrorLocation :: <a href="#type-location">location()</a>}
ErrorInfo = <a href="../erl_scan/#type-error_info">erl_scan:error_info()</a> | <a href="../erl_parse/#type-error_info">erl_parse:error_info()</a>
server_no_data() = {error, ErrorDescription :: term()} | eof</pre>

<p>Reads a term <code class="code">Term</code> from <code class="code">IoDevice</code>, prompting it with <code class="code">Prompt</code>. Reading starts at location <code class="code">StartLocation</code>. The argument <code class="code">Options</code> is passed on as the <code class="code">Options</code> argument of the <code class="code">erl_scan:tokens/4</code> function. It returns:</p> <dl> <dt><strong><code class="code">{ok, Term, EndLocation}</code></strong></dt> <dd> <p>The parsing was successful.</p> </dd> <dt><strong><code class="code">{eof, EndLocation}</code></strong></dt> <dd> <p>End of file was encountered.</p> </dd> <dt><strong><code class="code">{error, ErrorInfo, ErrorLocation}</code></strong></dt> <dd> <p>The parsing failed.</p> </dd> <dt><strong><code class="code">{error, ErrorDescription}</code></strong></dt> <dd> <p>Other (rare) error condition, for instance <code class="code">{error, estale}</code> if reading from an NFS file system.</p> </dd> </dl>  <h3 id="format-3" class="code">fwrite(Format) -&gt; ok<br>fwrite(Format, Data) -&gt; ok<br>fwrite(IoDevice, Format, Data) -&gt; ok<br>format(Format) -&gt; ok<br>format(Format, Data) -&gt; ok<br>format(IoDevice, Format, Data) -&gt; ok</h3> <p>Types:</p>     <pre>IoDevice = <a href="#type-device">device()</a>
Format = <a href="#type-format">format()</a>
Data = [term()]</pre>

<p>Writes the items in <code class="code">Data</code> (<code class="code">[]</code>) on the standard output (<code class="code">IoDevice</code>) in accordance with <code class="code">Format</code>. <code class="code">Format</code> contains plain characters which are copied to the output device, and control sequences for formatting, see below. If <code class="code">Format</code> is an atom or a binary, it is first converted to a list with the aid of <code class="code">atom_to_list/1</code> or <code class="code">binary_to_list/1</code>.</p> <div class="example"><pre>
1&gt; io:fwrite("Hello world!~n", []).
Hello world!
ok</pre></div> <p>The general format of a control sequence is <code class="code">~F.P.PadModC</code>. The character <code class="code">C</code> determines the type of control sequence to be used, <code class="code">F</code> and <code class="code">P</code> are optional numeric arguments. If <code class="code">F</code>, <code class="code">P</code>, or <code class="code">Pad</code> is <code class="code">*</code>, the next argument in <code class="code">Data</code> is used as the numeric value of <code class="code">F</code> or <code class="code">P</code>.</p> <p><code class="code">F</code> is the <code class="code">field width</code> of the printed argument. A negative value means that the argument will be left justified within the field, otherwise it will be right justified. If no field width is specified, the required print width will be used. If the field width specified is too small, then the whole field will be filled with <code class="code">*</code> characters.</p> <p><code class="code">P</code> is the <code class="code">precision</code> of the printed argument. A default value is used if no precision is specified. The interpretation of precision depends on the control sequences. Unless otherwise specified, the argument <code class="code">within</code> is used to determine print width.</p> <p><code class="code">Pad</code> is the padding character. This is the character used to pad the printed representation of the argument so that it conforms to the specified field width and precision. Only one padding character can be specified and, whenever applicable, it is used for both the field width and precision. The default padding character is <code class="code">' '</code> (space).</p> <p><code class="code">Mod</code> is the control sequence modifier. It is either a single character (currently only <code class="code">t</code>, for Unicode translation, and <code class="code">l</code>, for stopping <code class="code">p</code> and <code class="code">P</code> from detecting printable characters, are supported) that changes the interpretation of Data.</p> <p>The following control sequences are available:</p> <dl> <dt><strong><code class="code">~</code></strong></dt> <dd> <p>The character <code class="code">~</code> is written.</p> </dd> <dt><strong><code class="code">c</code></strong></dt> <dd> <p>The argument is a number that will be interpreted as an ASCII code. The precision is the number of times the character is printed and it defaults to the field width, which in turn defaults to 1. The following example illustrates:</p> <div class="example"><pre>
1&gt; io:fwrite("|~10.5c|~-10.5c|~5c|~n", [$a, $b, $c]).
|     aaaaa|bbbbb     |ccccc|
ok</pre></div> <p>If the Unicode translation modifier (<code class="code">t</code>) is in effect, the integer argument can be any number representing a valid Unicode codepoint, otherwise it should be an integer less than or equal to 255, otherwise it is masked with 16#FF:</p> <div class="example"><pre>
2&gt; io:fwrite("~tc~n",[1024]).
\x{400}
ok
3&gt; io:fwrite("~c~n",[1024]).
^@
ok</pre></div> </dd> <dt><strong><code class="code">f</code></strong></dt> <dd> <p>The argument is a float which is written as <code class="code">[-]ddd.ddd</code>, where the precision is the number of digits after the decimal point. The default precision is 6 and it cannot be less than 1.</p> </dd> <dt><strong><code class="code">e</code></strong></dt> <dd> <p>The argument is a float which is written as <code class="code">[-]d.ddde+-ddd</code>, where the precision is the number of digits written. The default precision is 6 and it cannot be less than 2.</p> </dd> <dt><strong><code class="code">g</code></strong></dt> <dd> <p>The argument is a float which is written as <code class="code">f</code>, if it is &gt;= 0.1 and &lt; 10000.0. Otherwise, it is written in the <code class="code">e</code> format. The precision is the number of significant digits. It defaults to 6 and should not be less than 2. If the absolute value of the float does not allow it to be written in the <code class="code">f</code> format with the desired number of significant digits, it is also written in the <code class="code">e</code> format.</p> </dd> <dt><strong><code class="code">s</code></strong></dt> <dd> <p>Prints the argument with the string syntax. The argument is, if no Unicode translation modifier is present, an <code class="code">iolist()</code>, a <code class="code">binary()</code>, or an <code class="code">atom()</code>. If the Unicode translation modifier (<code class="code">t</code>) is in effect, the argument is <code class="code">unicode:chardata()</code>, meaning that binaries are in UTF-8. The characters are printed without quotes. The string is first truncated by the given precision and then padded and justified to the given field width. The default precision is the field width.</p> <p>This format can be used for printing any object and truncating the output so it fits a specified field:</p> <div class="example"><pre>
1&gt; io:fwrite("|~10w|~n", [{hey, hey, hey}]).
|**********|
ok
2&gt; io:fwrite("|~10s|~n", [io_lib:write({hey, hey, hey})]).
|{hey,hey,h|
3&gt; io:fwrite("|~-10.8s|~n", [io_lib:write({hey, hey, hey})]).
|{hey,hey  |
ok</pre></div> <p>A list with integers larger than 255 is considered an error if the Unicode translation modifier is not given:</p> <div class="example"><pre>
4&gt; io:fwrite("~ts~n",[[1024]]).
\x{400}
ok
5&gt; io:fwrite("~s~n",[[1024]]).
** exception exit: {badarg,[{io,format,[&lt;0.26.0&gt;,"~s~n",[[1024]]]},
   ...</pre></div> </dd> <dt><strong><code class="code">w</code></strong></dt> <dd> <p>Writes data with the standard syntax. This is used to output Erlang terms. Atoms are printed within quotes if they contain embedded non-printable characters, and floats are printed accurately as the shortest, correctly rounded string.</p> </dd> <dt><strong><code class="code">p</code></strong></dt> <dd> <p>Writes the data with standard syntax in the same way as <code class="code">~w</code>, but breaks terms whose printed representation is longer than one line into many lines and indents each line sensibly. Left justification is not supported. It also tries to detect lists of printable characters and to output these as strings. The Unicode translation modifier is used for determining what characters are printable. For example:</p> <div class="example"><pre>
1&gt; T = [{attributes,[[{id,age,1.50000},{mode,explicit},
{typename,"INTEGER"}], [{id,cho},{mode,explicit},{typename,'Cho'}]]},
{typename,'Person'},{tag,{'PRIVATE',3}},{mode,implicit}].
...
2&gt; io:fwrite("~w~n", [T]).
[{attributes,[[{id,age,1.5},{mode,explicit},{typename,
[73,78,84,69,71,69,82]}],[{id,cho},{mode,explicit},{typena
me,'Cho'}]]},{typename,'Person'},{tag,{'PRIVATE',3}},{mode
,implicit}]
ok
3&gt; io:fwrite("~62p~n", [T]).
[{attributes,[[{id,age,1.5},
               {mode,explicit},
               {typename,"INTEGER"}],
              [{id,cho},{mode,explicit},{typename,'Cho'}]]},
 {typename,'Person'},
 {tag,{'PRIVATE',3}},
 {mode,implicit}]
ok</pre></div> <p>The field width specifies the maximum line length. It defaults to 80. The precision specifies the initial indentation of the term. It defaults to the number of characters printed on this line in the <code class="code">same</code> call to <code class="code">io:fwrite</code> or <code class="code">io:format</code>. For example, using <code class="code">T</code> above:</p> <div class="example"><pre>
4&gt; io:fwrite("Here T = ~62p~n", [T]).
Here T = [{attributes,[[{id,age,1.5},
                        {mode,explicit},
                        {typename,"INTEGER"}],
                       [{id,cho},
                        {mode,explicit},
                        {typename,'Cho'}]]},
          {typename,'Person'},
          {tag,{'PRIVATE',3}},
          {mode,implicit}]
ok</pre></div> <p>When the modifier <code class="code">l</code> is given no detection of printable character lists will take place. For example:</p> <div class="example"><pre>
5&gt; S = [{a,"a"}, {b, "b"}].
6&gt; io:fwrite("~15p~n", [S]).
[{a,"a"},
 {b,"b"}]
ok
7&gt; io:fwrite("~15lp~n", [S]).
[{a,[97]},
 {b,[98]}]
ok</pre></div> <p>Binaries that look like UTF-8 encoded strings will be output with the string syntax if the Unicode translation modifier is given:</p> <div class="example"><pre>
9&gt; io:fwrite("~p~n",[[1024]]).
[1024]
10&gt; io:fwrite("~tp~n",[[1024]]).
"\x{400}"
11&gt; io:fwrite("~tp~n", [&lt;&lt;128,128&gt;&gt;]).
&lt;&lt;128,128&gt;&gt;
12&gt; io:fwrite("~tp~n", [&lt;&lt;208,128&gt;&gt;]).
&lt;&lt;"\x{400}"/utf8&gt;&gt;
ok</pre></div> </dd> <dt><strong><code class="code">W</code></strong></dt> <dd> <p>Writes data in the same way as <code class="code">~w</code>, but takes an extra argument which is the maximum depth to which terms are printed. Anything below this depth is replaced with <code class="code">...</code>. For example, using <code class="code">T</code> above:</p> <div class="example"><pre>
8&gt; io:fwrite("~W~n", [T,9]).
[{attributes,[[{id,age,1.5},{mode,explicit},{typename,...}],
[{id,cho},{mode,...},{...}]]},{typename,'Person'},
{tag,{'PRIVATE',3}},{mode,implicit}]
ok</pre></div> <p>If the maximum depth has been reached, then it is impossible to read in the resultant output. Also, the <code class="code">,...</code> form in a tuple denotes that there are more elements in the tuple but these are below the print depth.</p> </dd> <dt><strong><code class="code">P</code></strong></dt> <dd> <p>Writes data in the same way as <code class="code">~p</code>, but takes an extra argument which is the maximum depth to which terms are printed. Anything below this depth is replaced with <code class="code">...</code>. For example:</p> <div class="example"><pre>
9&gt; io:fwrite("~62P~n", [T,9]).
[{attributes,[[{id,age,1.5},{mode,explicit},{typename,...}],
              [{id,cho},{mode,...},{...}]]},
 {typename,'Person'},
 {tag,{'PRIVATE',3}},
 {mode,implicit}]
ok</pre></div> </dd> <dt><strong><code class="code">B</code></strong></dt> <dd> <p>Writes an integer in base 2..36, the default base is 10. A leading dash is printed for negative integers.</p> <p>The precision field selects base. For example:</p> <div class="example"><pre>
1&gt; io:fwrite("~.16B~n", [31]).
1F
ok
2&gt; io:fwrite("~.2B~n", [-19]).
-10011
ok
3&gt; io:fwrite("~.36B~n", [5*36+35]).
5Z
ok</pre></div> </dd> <dt><strong><code class="code">X</code></strong></dt> <dd> <p>Like <code class="code">B</code>, but takes an extra argument that is a prefix to insert before the number, but after the leading dash, if any.</p> <p>The prefix can be a possibly deep list of characters or an atom.</p> <div class="example"><pre>
1&gt; io:fwrite("~X~n", [31,"10#"]).
10#31
ok
2&gt; io:fwrite("~.16X~n", [-31,"0x"]).
-0x1F
ok</pre></div> </dd> <dt><strong><code class="code">#</code></strong></dt> <dd> <p>Like <code class="code">B</code>, but prints the number with an Erlang style <code class="code">#</code>-separated base prefix.</p> <div class="example"><pre>
1&gt; io:fwrite("~.10#~n", [31]).
10#31
ok
2&gt; io:fwrite("~.16#~n", [-31]).
-16#1F
ok</pre></div> </dd> <dt><strong><code class="code">b</code></strong></dt> <dd> <p>Like <code class="code">B</code>, but prints lowercase letters.</p> </dd> <dt><strong><code class="code">x</code></strong></dt> <dd> <p>Like <code class="code">X</code>, but prints lowercase letters.</p> </dd> <dt><strong><code class="code">+</code></strong></dt> <dd> <p>Like <code class="code">#</code>, but prints lowercase letters.</p> </dd> <dt><strong><code class="code">n</code></strong></dt> <dd> <p>Writes a new line.</p> </dd> <dt><strong><code class="code">i</code></strong></dt> <dd> <p>Ignores the next term.</p> </dd> </dl> <p>Returns:</p> <dl> <dt><strong><code class="code">ok</code></strong></dt> <dd> <p>The formatting succeeded.</p> </dd> </dl> <p>If an error occurs, there is no output. For example:</p> <div class="example"><pre>
1&gt; io:fwrite("~s ~w ~i ~w ~c ~n",['abc def', 'abc def', {foo, 1},{foo, 1}, 65]).
abc def 'abc def'  {foo,1} A
ok
2&gt; io:fwrite("~s", [65]).
** exception exit: {badarg,[{io,format,[&lt;0.22.0&gt;,"~s","A"]},
                            {erl_eval,do_apply,5},
                            {shell,exprs,6},
                            {shell,eval_exprs,6},
                            {shell,eval_loop,3}]}
     in function  io:o_request/2</pre></div> <p>In this example, an attempt was made to output the single character 65 with the aid of the string formatting directive "~s".</p>  <h3 id="fread-3" class="code">fread(Prompt, Format) -&gt; Result<br>fread(IoDevice, Prompt, Format) -&gt; Result</h3> <p>Types:</p>       <pre>IoDevice = <a href="#type-device">device()</a>
Prompt = <a href="#type-prompt">prompt()</a>
Format = <a href="#type-format">format()</a>
Result = 
    {ok, Terms :: [term()]} |
    {error, {fread, FreadError :: <a href="../io_lib/#type-fread_error">io_lib:fread_error()</a>}} |
    <a href="#type-server_no_data">server_no_data()</a>
server_no_data() = {error, ErrorDescription :: term()} | eof</pre>

<p>Reads characters from the standard input (<code class="code">IoDevice</code>), prompting it with <code class="code">Prompt</code>. Interprets the characters in accordance with <code class="code">Format</code>. <code class="code">Format</code> contains control sequences which directs the interpretation of the input.</p> <p><code class="code">Format</code> may contain:</p> <ul> <li> <p>White space characters (SPACE, TAB and NEWLINE) which cause input to be read to the next non-white space character.</p> </li> <li> <p>Ordinary characters which must match the next input character.</p> </li> <li> <p>Control sequences, which have the general format <code class="code">~*FMC</code>. The character <code class="code">*</code> is an optional return suppression character. It provides a method to specify a field which is to be omitted. <code class="code">F</code> is the <code class="code">field width</code> of the input field, <code class="code">M</code> is an optional translation modifier (of which <code class="code">t</code> is the only currently supported, meaning Unicode translation) and <code class="code">C</code> determines the type of control sequence.</p> <p>Unless otherwise specified, leading white-space is ignored for all control sequences. An input field cannot be more than one line wide. The following control sequences are available:</p> <dl> <dt><strong><code class="code">~</code></strong></dt> <dd> <p>A single <code class="code">~</code> is expected in the input.</p> </dd> <dt><strong><code class="code">d</code></strong></dt> <dd> <p>A decimal integer is expected.</p> </dd> <dt><strong><code class="code">u</code></strong></dt> <dd> <p>An unsigned integer in base 2..36 is expected. The field width parameter is used to specify base. Leading white-space characters are not skipped.</p> </dd> <dt><strong><code class="code">-</code></strong></dt> <dd> <p>An optional sign character is expected. A sign character <code class="code">-</code> gives the return value <code class="code">-1</code>. Sign character <code class="code">+</code> or none gives <code class="code">1</code>. The field width parameter is ignored. Leading white-space characters are not skipped.</p> </dd> <dt><strong><code class="code">#</code></strong></dt> <dd> <p>An integer in base 2..36 with Erlang-style base prefix (for example <code class="code">"16#ffff"</code>) is expected.</p> </dd> <dt><strong><code class="code">f</code></strong></dt> <dd> <p>A floating point number is expected. It must follow the Erlang floating point number syntax.</p> </dd> <dt><strong><code class="code">s</code></strong></dt> <dd> <p>A string of non-white-space characters is read. If a field width has been specified, this number of characters are read and all trailing white-space characters are stripped. An Erlang string (list of characters) is returned.</p> <p>If Unicode translation is in effect (<code class="code">~ts</code>), characters larger than 255 are accepted, otherwise not. With the translation modifier, the list returned may as a consequence also contain integers larger than 255:</p> <div class="example"><pre>
1&gt; io:fread("Prompt&gt; ","~s").
Prompt&gt; &lt;Characters beyond latin1 range not printable in this medium&gt;
{error,{fread,string}}
2&gt; io:fread("Prompt&gt; ","~ts").
Prompt&gt; &lt;Characters beyond latin1 range not printable in this medium&gt;
{ok,[[1091,1085,1080,1094,1086,1076,1077]]}</pre></div> </dd> <dt><strong><code class="code">a</code></strong></dt> <dd> <p>Similar to <code class="code">s</code>, but the resulting string is converted into an atom.</p> <p>The Unicode translation modifier is not allowed (atoms can not contain characters beyond the latin1 range).</p> </dd> <dt><strong><code class="code">c</code></strong></dt> <dd> <p>The number of characters equal to the field width are read (default is 1) and returned as an Erlang string. However, leading and trailing white-space characters are not omitted as they are with <code class="code">s</code>. All characters are returned.</p> <p>The Unicode translation modifier works as with <code class="code">s</code>:</p> <div class="example"><pre>
1&gt; io:fread("Prompt&gt; ","~c").
Prompt&gt; &lt;Character beyond latin1 range not printable in this medium&gt;
{error,{fread,string}}
2&gt; io:fread("Prompt&gt; ","~tc").
Prompt&gt; &lt;Character beyond latin1 range not printable in this medium&gt;
{ok,[[1091]]}</pre></div> </dd> <dt><strong><code class="code">l</code></strong></dt> <dd> <p>Returns the number of characters which have been scanned up to that point, including white-space characters.</p> </dd> </dl> <p>It returns:</p> <dl> <dt><strong><code class="code">{ok, Terms}</code></strong></dt> <dd> <p>The read was successful and <code class="code">Terms</code> is the list of successfully matched and read items.</p> </dd> <dt><strong><code class="code">eof</code></strong></dt> <dd> <p>End of file was encountered.</p> </dd> <dt><strong><code class="code">{error, FreadError}</code></strong></dt> <dd> <p>The reading failed and <code class="code">FreadError</code> gives a hint about the error.</p> </dd> <dt><strong><code class="code">{error, ErrorDescription}</code></strong></dt> <dd> <p>The read operation failed and the parameter <code class="code">ErrorDescription</code> gives a hint about the error.</p> </dd> </dl> </li> </ul> <p>Examples:</p> <div class="example"><pre>
20&gt; io:fread('enter&gt;', "~f~f~f").
enter&gt;1.9 35.5e3 15.0
{ok,[1.9,3.55e4,15.0]}
21&gt; io:fread('enter&gt;', "~10f~d").
enter&gt;     5.67899
{ok,[5.678,99]}
22&gt; io:fread('enter&gt;', ":~10s:~10c:").
enter&gt;:   alan   :   joe    :
{ok, ["alan", "   joe    "]}</pre></div>  <h3 id="rows-1" class="code">rows() -&gt; {ok, integer() &gt;= 1} | {error, enotsup}<br>rows(IoDevice) -&gt; {ok, integer() &gt;= 1} | {error, enotsup}</h3> <p>Types:</p>   <pre>IoDevice = <a href="#type-device">device()</a></pre>

<p>Retrieves the number of rows of the <code class="code">IoDevice</code> (i.e. the height of a terminal). The function only succeeds for terminal devices, for all other IO devices the function returns <code class="code">{error, enotsup}</code></p>  <h3 id="scan_erl_exprs-4" class="code">scan_erl_exprs(Prompt) -&gt; Result<br>scan_erl_exprs(Device, Prompt) -&gt; Result<br>scan_erl_exprs(Device, Prompt, StartLocation) -&gt; Result<br>scan_erl_exprs(Device, Prompt, StartLocation, Options) -&gt; Result</h3> <p>Types:</p>        <pre>Device = <a href="#type-device">device()</a>
Prompt = <a href="#type-prompt">prompt()</a>
StartLocation = <a href="#type-location">location()</a>
Options = <a href="../erl_scan/#type-options">erl_scan:options()</a>
Result = <a href="../erl_scan/#type-tokens_result">erl_scan:tokens_result()</a> | <a href="#type-server_no_data">server_no_data()</a>
server_no_data() = {error, ErrorDescription :: term()} | eof</pre>

<p>Reads data from the standard input (<code class="code">IoDevice</code>), prompting it with <code class="code">Prompt</code>. Reading starts at location <code class="code">StartLocation</code> (<code class="code">1</code>). The argument <code class="code">Options</code> is passed on as the <code class="code">Options</code> argument of the <code class="code">erl_scan:tokens/4</code> function. The data is tokenized as if it were a sequence of Erlang expressions until a final dot (<code class="code">.</code>) is reached. This token is also returned. It returns:</p> <dl> <dt><strong><code class="code">{ok, Tokens, EndLocation}</code></strong></dt> <dd> <p>The tokenization succeeded.</p> </dd> <dt><strong><code class="code">{eof, EndLocation}</code></strong></dt> <dd> <p>End of file was encountered by the tokenizer.</p> </dd> <dt><strong><code class="code">eof</code></strong></dt> <dd> <p>End of file was encountered by the I/O-server.</p> </dd> <dt><strong><code class="code">{error, ErrorInfo, ErrorLocation}</code></strong></dt> <dd> <p>An error occurred while tokenizing.</p> </dd> <dt><strong><code class="code">{error, ErrorDescription}</code></strong></dt> <dd> <p>Other (rare) error condition, for instance <code class="code">{error, estale}</code> if reading from an NFS file system.</p> </dd> </dl> <p>Example:</p> <div class="example"><pre>
23&gt; io:scan_erl_exprs('enter&gt;').
enter&gt;abc(), "hey".
{ok,[{atom,1,abc},{'(',1},{')',1},{',',1},{string,1,"hey"},{dot,1}],2}
24&gt; io:scan_erl_exprs('enter&gt;').
enter&gt;1.0er.
{error,{1,erl_scan,{illegal,float}},2}</pre></div>  <h3 id="scan_erl_form-4" class="code">scan_erl_form(Prompt) -&gt; Result<br>scan_erl_form(IoDevice, Prompt) -&gt; Result<br>scan_erl_form(IoDevice, Prompt, StartLocation) -&gt; Result<br>scan_erl_form(IoDevice, Prompt, StartLocation, Options) -&gt; Result</h3> <p>Types:</p>        <pre>IoDevice = <a href="#type-device">device()</a>
Prompt = <a href="#type-prompt">prompt()</a>
StartLocation = <a href="#type-location">location()</a>
Options = <a href="../erl_scan/#type-options">erl_scan:options()</a>
Result = <a href="../erl_scan/#type-tokens_result">erl_scan:tokens_result()</a> | <a href="#type-server_no_data">server_no_data()</a>
server_no_data() = {error, ErrorDescription :: term()} | eof</pre>

<p>Reads data from the standard input (<code class="code">IoDevice</code>), prompting it with <code class="code">Prompt</code>. Starts reading at location <code class="code">StartLocation</code> (<code class="code">1</code>). The argument <code class="code">Options</code> is passed on as the <code class="code">Options</code> argument of the <code class="code">erl_scan:tokens/4</code> function. The data is tokenized as if it were an Erlang form - one of the valid Erlang expressions in an Erlang source file - until a final dot (<code class="code">.</code>) is reached. This last token is also returned. The return values are the same as for <code class="code">scan_erl_exprs/1,2,3</code> above.</p>  <h3 id="parse_erl_exprs-4" class="code">parse_erl_exprs(Prompt) -&gt; Result<br>parse_erl_exprs(IoDevice, Prompt) -&gt; Result<br>parse_erl_exprs(IoDevice, Prompt, StartLocation) -&gt; Result<br>parse_erl_exprs(IoDevice, Prompt, StartLocation, Options) -&gt;<br>                   Result</h3> <p>Types:</p>         <pre>IoDevice = <a href="#type-device">device()</a>
Prompt = <a href="#type-prompt">prompt()</a>
StartLocation = <a href="#type-location">location()</a>
Options = <a href="../erl_scan/#type-options">erl_scan:options()</a>
Result = parse_ret()
parse_ret() = 
    {ok,
     ExprList :: <a href="../erl_parse/#type-abstract_expr">erl_parse:abstract_expr()</a>,
     EndLocation :: <a href="#type-location">location()</a>} |
    {eof, EndLocation :: <a href="#type-location">location()</a>} |
    {error,
     ErrorInfo :: <a href="../erl_scan/#type-error_info">erl_scan:error_info()</a> | <a href="../erl_parse/#type-error_info">erl_parse:error_info()</a>,
     ErrorLocation :: <a href="#type-location">location()</a>} |
    <a href="#type-server_no_data">server_no_data()</a>
server_no_data() = {error, ErrorDescription :: term()} | eof</pre>

<p>Reads data from the standard input (<code class="code">IoDevice</code>), prompting it with <code class="code">Prompt</code>. Starts reading at location <code class="code">StartLocation</code> (<code class="code">1</code>). The argument <code class="code">Options</code> is passed on as the <code class="code">Options</code> argument of the <code class="code">erl_scan:tokens/4</code> function. The data is tokenized and parsed as if it were a sequence of Erlang expressions until a final dot (<code class="code">.</code>) is reached. It returns:</p> <dl> <dt><strong><code class="code">{ok, ExprList, EndLocation}</code></strong></dt> <dd> <p>The parsing was successful.</p> </dd> <dt><strong><code class="code">{eof, EndLocation}</code></strong></dt> <dd> <p>End of file was encountered by the tokenizer.</p> </dd> <dt><strong><code class="code">eof</code></strong></dt> <dd> <p>End of file was encountered by the I/O-server.</p> </dd> <dt><strong><code class="code">{error, ErrorInfo, ErrorLocation}</code></strong></dt> <dd> <p>An error occurred while tokenizing or parsing.</p> </dd> <dt><strong><code class="code">{error, ErrorDescription}</code></strong></dt> <dd> <p>Other (rare) error condition, for instance <code class="code">{error, estale}</code> if reading from an NFS file system.</p> </dd> </dl> <p>Example:</p> <div class="example"><pre>
25&gt; io:parse_erl_exprs('enter&gt;').
enter&gt;abc(), "hey".
{ok, [{call,1,{atom,1,abc},[]},{string,1,"hey"}],2}
26&gt; io:parse_erl_exprs ('enter&gt;').
enter&gt;abc("hey".
{error,{1,erl_parse,["syntax error before: ",["'.'"]]},2}</pre></div>  <h3 id="parse_erl_form-4" class="code">parse_erl_form(Prompt) -&gt; Result<br>parse_erl_form(IoDevice, Prompt) -&gt; Result<br>parse_erl_form(IoDevice, Prompt, StartLocation) -&gt; Result<br>parse_erl_form(IoDevice, Prompt, StartLocation, Options) -&gt; Result</h3> <p>Types:</p>         <pre>IoDevice = <a href="#type-device">device()</a>
Prompt = <a href="#type-prompt">prompt()</a>
StartLocation = <a href="#type-location">location()</a>
Options = <a href="../erl_scan/#type-options">erl_scan:options()</a>
Result = parse_form_ret()
parse_form_ret() = 
    {ok,
     AbsForm :: <a href="../erl_parse/#type-abstract_form">erl_parse:abstract_form()</a>,
     EndLocation :: <a href="#type-location">location()</a>} |
    {eof, EndLocation :: <a href="#type-location">location()</a>} |
    {error,
     ErrorInfo :: <a href="../erl_scan/#type-error_info">erl_scan:error_info()</a> | <a href="../erl_parse/#type-error_info">erl_parse:error_info()</a>,
     ErrorLocation :: <a href="#type-location">location()</a>} |
    <a href="#type-server_no_data">server_no_data()</a>
server_no_data() = {error, ErrorDescription :: term()} | eof</pre>

<p>Reads data from the standard input (<code class="code">IoDevice</code>), prompting it with <code class="code">Prompt</code>. Starts reading at location <code class="code">StartLocation</code> (<code class="code">1</code>). The argument <code class="code">Options</code> is passed on as the <code class="code">Options</code> argument of the <code class="code">erl_scan:tokens/4</code> function. The data is tokenized and parsed as if it were an Erlang form - one of the valid Erlang expressions in an Erlang source file - until a final dot (<code class="code">.</code>) is reached. It returns:</p> <dl> <dt><strong><code class="code">{ok, AbsForm, EndLocation}</code></strong></dt> <dd> <p>The parsing was successful.</p> </dd> <dt><strong><code class="code">{eof, EndLocation}</code></strong></dt> <dd> <p>End of file was encountered by the tokenizer.</p> </dd> <dt><strong><code class="code">eof</code></strong></dt> <dd> <p>End of file was encountered by the I/O-server.</p> </dd> <dt><strong><code class="code">{error, ErrorInfo, ErrorLocation}</code></strong></dt> <dd> <p>An error occurred while tokenizing or parsing.</p> </dd> <dt><strong><code class="code">{error, ErrorDescription}</code></strong></dt> <dd> <p>Other (rare) error condition, for instance <code class="code">{error, estale}</code> if reading from an NFS file system.</p> </dd> </dl>  <h2 id="id204878">Standard Input/Output</h2>  <p>All Erlang processes have a default standard IO device. This device is used when no <code class="code">IoDevice</code> argument is specified in the above function calls. However, it is sometimes desirable to use an explicit <code class="code">IoDevice</code> argument which refers to the default IO device. This is the case with functions that can access either a file or the default IO device. The atom <code class="code">standard_io</code> has this special meaning. The following example illustrates this:</p> <div class="example"><pre>
27&gt; io:read('enter&gt;').
enter&gt;foo.
{ok,foo}
28&gt; io:read(standard_io, 'enter&gt;').
enter&gt;bar.
{ok,bar}</pre></div> <p>There is always a process registered under the name of <code class="code">user</code>. This can be used for sending output to the user.</p>  <h2 id="id204931">Standard Error</h2>  <p>In certain situations, especially when the standard output is redirected, access to an I/O-server specific for error messages might be convenient. The IO device <code class="code">standard_error</code> can be used to direct output to whatever the current operating system considers a suitable IO device for error output. Example on a Unix-like operating system:</p> <div class="example"><pre>
$ erl -noshell -noinput -eval 'io:format(standard_error,"Error: ~s~n",["error 11"]),'\
'init:stop().' &gt; /dev/null
Error: error 11</pre></div>  <h2 id="id204960">Error Information</h2>  <p>The <code class="code">ErrorInfo</code> mentioned above is the standard <code class="code">ErrorInfo</code> structure which is returned from all IO modules. It has the format:</p> <div class="example"><pre>
{ErrorLocation, Module, ErrorDescriptor}</pre></div> <p>A string which describes the error is obtained with the following call:</p> <div class="example"><pre>
Module:format_error(ErrorDescriptor)</pre></div>
<div class="_attribution">
  <p class="_attribution-p">
    © 1999–2016 Ericsson AB<br>Licensed under the Apache License, Version 2.0.<br>
    
  </p>
</div>

			</div>
		</div>
	</section>

	</div>
</body>
</html>
