
<!DOCTYPE HTML>

<html lang="en">

<head>
  <meta charset="utf-8">
  <title>Lists - Erlang 18 - W3cubDocs</title>
  
  <meta name="description" content=" lists ">
  <meta name="keywords" content="lists, -, erlang, erlang~18">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="http://docs.w3cub.com/erlang~18/lib/stdlib-2.8/doc/html/lists/">
  <link href="/favicon.png" rel="icon">
  <link type="text/css" rel="stylesheet" href="/assets/application-50364fff564ce3b6327021805f3f00e2957b441cf27f576a7dd4ff63bbc47047.css">
  <script type="text/javascript" src="/assets/application-db64bfd54ceb42be11af7995804cf4902548419ceb79d509b0b7d62c22d98e6f.js"></script>
  <script src="/json/erlang~18.js"></script>
  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-71174418-1']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>


</head>

<body>
	<div class="_app">
	<header class="_header">
  
  <form class="_search">
    <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
    <a class="_search-clear"></a>
    <div class="_search-tag"></div>
  </form>
  
  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/erlang~18/" class="_nav-link" title="" style="margin-left:0;">Erlang 18</a></span>
  
  <nav class="_nav">
    <a href="/app/" class="_nav-link ">App</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		<div class="_list">
			
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<div class="_page _erlang">
				
<h1>lists</h1> <h2>Module</h2> <p class="REFBODY">lists</p> <h2>Module summary</h2> <p class="REFBODY">List Processing Functions</p> <h2>Description</h2> 
<p>This module contains functions for list processing.</p> <p>Unless otherwise stated, all functions assume that position numbering starts at 1. That is, the first element of a list is at position 1.</p> <p>Two terms <code class="code">T1</code> and <code class="code">T2</code> compare equal if <code class="code">T1 == T2</code> evaluates to <code class="code">true</code>. They match if <code class="code">T1 =:= T2</code> evaluates to <code class="code">true</code>.</p> <p id="ordering_function">Whenever an <strong>ordering function</strong> <code class="code">F</code> is expected as argument, it is assumed that the following properties hold of <code class="code">F</code> for all x, y and z:</p> <ul> <li> <p>if x <code class="code">F</code> y and y <code class="code">F</code> x then x = y (<code class="code">F</code> is antisymmetric);</p> </li> <li> <p>if x <code class="code">F</code> y and y <code class="code">F</code> z then x <code class="code">F</code> z (<code class="code">F</code> is transitive);</p> </li> <li> <p>x <code class="code">F</code> y or y <code class="code">F</code> x (<code class="code">F</code> is total).</p> </li> </ul> <p>An example of a typical ordering function is less than or equal to, <code class="code">=&lt;/2</code>.</p>  <h2>Exports</h2> <h3 id="all-2" class="code">all(Pred, List) -&gt; boolean()</h3> <p>Types:</p>     <pre>Pred = fun((Elem :: T) -&gt; boolean())
List = [T]
T = term()</pre>

<p>Returns <code class="code">true</code> if <code class="code">Pred(Elem)</code> returns <code class="code">true</code> for all elements <code class="code">Elem</code> in <code class="code">List</code>, otherwise <code class="code">false</code>.</p>  <h3 id="any-2" class="code">any(Pred, List) -&gt; boolean()</h3> <p>Types:</p>     <pre>Pred = fun((Elem :: T) -&gt; boolean())
List = [T]
T = term()</pre>

<p>Returns <code class="code">true</code> if <code class="code">Pred(Elem)</code> returns <code class="code">true</code> for at least one element <code class="code">Elem</code> in <code class="code">List</code>.</p>  <h3 id="append-1" class="code">append(ListOfLists) -&gt; List1</h3> <p>Types:</p>      <pre>ListOfLists = [List]
List = List1 = [T]

T = term()</pre>

<p>Returns a list in which all the sub-lists of <code class="code">ListOfLists</code> have been appended. For example:</p> <div class="example"><pre>
&gt; lists:append([[1, 2, 3], [a, b], [4, 5, 6]]).
[1,2,3,a,b,4,5,6]</pre></div>  <h3 id="append-2" class="code">append(List1, List2) -&gt; List3</h3> <p>Types:</p>      <pre>List1 = List2 = List3 = [T]


T = term()</pre>

<p>Returns a new list <code class="code">List3</code> which is made from the elements of <code class="code">List1</code> followed by the elements of <code class="code">List2</code>. For example:</p> <div class="example"><pre>
&gt; lists:append("abc", "def").
"abcdef"</pre></div> <p><code class="code">lists:append(A, B)</code> is equivalent to <code class="code">A ++ B</code>.</p>  <h3 id="concat-1" class="code">concat(Things) -&gt; string()</h3> <p>Types:</p>    <pre>Things = [Thing]
Thing = atom() | integer() | float() | string()</pre>

<p>Concatenates the text representation of the elements of <code class="code">Things</code>. The elements of <code class="code">Things</code> can be atoms, integers, floats or strings.</p> <div class="example"><pre>
&gt; lists:concat([doc, '/', file, '.', 3]).
"doc/file.3"</pre></div>  <h3 id="delete-2" class="code">delete(Elem, List1) -&gt; List2</h3> <p>Types:</p>      <pre>Elem = T
List1 = List2 = [T]

T = term()</pre>

<p>Returns a copy of <code class="code">List1</code> where the first element matching <code class="code">Elem</code> is deleted, if there is such an element.</p>  <h3 id="droplast-1" class="code">droplast(List) -&gt; InitList</h3> <p>Types:</p>     <pre>List = [T, ...]
InitList = [T]
T = term()</pre>

<p>Drops the last element of a <code class="code">List</code>. The list should be non-empty, otherwise the function will crash with a <code class="code">function_clause</code></p>  <h3 id="dropwhile-2" class="code">dropwhile(Pred, List1) -&gt; List2</h3> <p>Types:</p>      <pre>Pred = fun((Elem :: T) -&gt; boolean())
List1 = List2 = [T]

T = term()</pre>

<p>Drops elements <code class="code">Elem</code> from <code class="code">List1</code> while <code class="code">Pred(Elem)</code> returns <code class="code">true</code> and returns the remaining list.</p>  <h3 id="duplicate-2" class="code">duplicate(N, Elem) -&gt; List</h3> <p>Types:</p>      <pre>N = integer() &gt;= 0
Elem = T
List = [T]
T = term()</pre>

<p>Returns a list which contains <code class="code">N</code> copies of the term <code class="code">Elem</code>. For example:</p> <div class="example"><pre>
&gt; lists:duplicate(5, xx).
[xx,xx,xx,xx,xx]</pre></div>  <h3 id="filter-2" class="code">filter(Pred, List1) -&gt; List2</h3> <p>Types:</p>      <pre>Pred = fun((Elem :: T) -&gt; boolean())
List1 = List2 = [T]

T = term()</pre>

<p><code class="code">List2</code> is a list of all elements <code class="code">Elem</code> in <code class="code">List1</code> for which <code class="code">Pred(Elem)</code> returns <code class="code">true</code>.</p>  <h3 id="filtermap-2" class="code">filtermap(Fun, List1) -&gt; List2</h3> <p>Types:</p>       <pre>Fun = fun((Elem) -&gt; boolean() | {true, Value})
List1 = [Elem]
List2 = [Elem | Value]
Elem = Value = term()</pre>

<p>Calls <code class="code">Fun(Elem)</code> on successive elements <code class="code">Elem</code> of <code class="code">List1</code>. <code class="code">Fun/2</code> must return either a boolean or a tuple <code class="code">{true, Value}</code>. The function returns the list of elements for which <code class="code">Fun</code> returns a new value, where a value of <code class="code">true</code> is synonymous with <code class="code">{true, Elem}</code>.</p> <p>That is, <code class="code">filtermap</code> behaves as if it had been defined as follows:</p> <div class="example"><pre>
filtermap(Fun, List1) -&gt;
    lists:foldr(fun(Elem, Acc) -&gt;
                       case Fun(Elem) of
                           false -&gt; Acc;
                           true -&gt; [Elem|Acc];
                           {true,Value} -&gt; [Value|Acc]
                       end
                end, [], List1).</pre></div> <p>Example:</p> <div class="example"><pre>
&gt; lists:filtermap(fun(X) -&gt; case X rem 2 of 0 -&gt; {true, X div 2}; _ -&gt; false end end, [1,2,3,4,5]).
[1,2]</pre></div>  <h3 id="flatlength-1" class="code">flatlength(DeepList) -&gt; integer() &gt;= 0</h3> <p>Types:</p>   <pre>DeepList = [term() | DeepList]</pre>

<p>Equivalent to <code class="code">length(flatten(DeepList))</code>, but more efficient.</p>  <h3 id="flatmap-2" class="code">flatmap(Fun, List1) -&gt; List2</h3> <p>Types:</p>       <pre>Fun = fun((A) -&gt; [B])
List1 = [A]
List2 = [B]
A = B = term()</pre>

<p>Takes a function from <code class="code">A</code>s to lists of <code class="code">B</code>s, and a list of <code class="code">A</code>s (<code class="code">List1</code>) and produces a list of <code class="code">B</code>s by applying the function to every element in <code class="code">List1</code> and appending the resulting lists.</p> <p>That is, <code class="code">flatmap</code> behaves as if it had been defined as follows:</p> <div class="example"><pre>
flatmap(Fun, List1) -&gt;
    append(map(Fun, List1)).</pre></div> <p>Example:</p> <div class="example"><pre>
&gt; lists:flatmap(fun(X)-&gt;[X,X] end, [a,b,c]).
[a,a,b,b,c,c]</pre></div>  <h3 id="flatten-1" class="code">flatten(DeepList) -&gt; List</h3> <p>Types:</p>    <pre>DeepList = [term() | DeepList]
List = [term()]</pre>

<p>Returns a flattened version of <code class="code">DeepList</code>.</p>  <h3 id="flatten-2" class="code">flatten(DeepList, Tail) -&gt; List</h3> <p>Types:</p>     <pre>DeepList = [term() | DeepList]
Tail = List = [term()]</pre>

<p>Returns a flattened version of <code class="code">DeepList</code> with the tail <code class="code">Tail</code> appended.</p>  <h3 id="foldl-3" class="code">foldl(Fun, Acc0, List) -&gt; Acc1</h3> <p>Types:</p>         <pre>Fun = fun((Elem :: T, AccIn) -&gt; AccOut)
Acc0 = Acc1 = AccIn = AccOut = term()



List = [T]
T = term()</pre>

<p>Calls <code class="code">Fun(Elem, AccIn)</code> on successive elements <code class="code">A</code> of <code class="code">List</code>, starting with <code class="code">AccIn == Acc0</code>. <code class="code">Fun/2</code> must return a new accumulator which is passed to the next call. The function returns the final value of the accumulator. <code class="code">Acc0</code> is returned if the list is empty. For example:</p> <div class="example"><pre>
&gt; lists:foldl(fun(X, Sum) -&gt; X + Sum end, 0, [1,2,3,4,5]).
15
&gt; lists:foldl(fun(X, Prod) -&gt; X * Prod end, 1, [1,2,3,4,5]).
120</pre></div>  <h3 id="foldr-3" class="code">foldr(Fun, Acc0, List) -&gt; Acc1</h3> <p>Types:</p>         <pre>Fun = fun((Elem :: T, AccIn) -&gt; AccOut)
Acc0 = Acc1 = AccIn = AccOut = term()



List = [T]
T = term()</pre>

<p>Like <code class="code">foldl/3</code>, but the list is traversed from right to left. For example:</p> <div class="example"><pre>
&gt; P = fun(A, AccIn) -&gt; io:format("~p ", [A]), AccIn end.
#Fun&lt;erl_eval.12.2225172&gt;
&gt; lists:foldl(P, void, [1,2,3]).
1 2 3 void
&gt; lists:foldr(P, void, [1,2,3]).
3 2 1 void</pre></div> <p><code class="code">foldl/3</code> is tail recursive and would usually be preferred to <code class="code">foldr/3</code>.</p>  <h3 id="foreach-2" class="code">foreach(Fun, List) -&gt; ok</h3> <p>Types:</p>     <pre>Fun = fun((Elem :: T) -&gt; term())
List = [T]
T = term()</pre>

<p>Calls <code class="code">Fun(Elem)</code> for each element <code class="code">Elem</code> in <code class="code">List</code>. This function is used for its side effects and the evaluation order is defined to be the same as the order of the elements in the list.</p>  <h3 id="keydelete-3" class="code">keydelete(Key, N, TupleList1) -&gt; TupleList2</h3> <p>Types:</p>   <pre>Key = term()
N = integer() &gt;= 1</pre>
<p class="REFBODY">1..tuple_size(Tuple)</p>     <pre>TupleList1 = TupleList2 = [Tuple]

Tuple = tuple()</pre>

<p>Returns a copy of <code class="code">TupleList1</code> where the first occurrence of a tuple whose <code class="code">N</code>th element compares equal to <code class="code">Key</code> is deleted, if there is such a tuple.</p>  <h3 id="keyfind-3" class="code">keyfind(Key, N, TupleList) -&gt; Tuple | false</h3> <p>Types:</p>   <pre>Key = term()
N = integer() &gt;= 1</pre>
<p class="REFBODY">1..tuple_size(Tuple)</p>    <pre>TupleList = [Tuple]
Tuple = tuple()</pre>

<p>Searches the list of tuples <code class="code">TupleList</code> for a tuple whose <code class="code">N</code>th element compares equal to <code class="code">Key</code>. Returns <code class="code">Tuple</code> if such a tuple is found, otherwise <code class="code">false</code>.</p>  <h3 id="keymap-3" class="code">keymap(Fun, N, TupleList1) -&gt; TupleList2</h3> <p>Types:</p>   <pre>Fun = fun((Term1 :: term()) -&gt; Term2 :: term())
N = integer() &gt;= 1</pre>
<p class="REFBODY">1..tuple_size(Tuple)</p>     <pre>TupleList1 = TupleList2 = [Tuple]

Tuple = tuple()</pre>

<p>Returns a list of tuples where, for each tuple in <code class="code">TupleList1</code>, the <code class="code">N</code>th element <code class="code">Term1</code> of the tuple has been replaced with the result of calling <code class="code">Fun(Term1)</code>.</p> <p>Examples:</p> <div class="example"><pre>
&gt; Fun = fun(Atom) -&gt; atom_to_list(Atom) end.
#Fun&lt;erl_eval.6.10732646&gt;
2&gt; lists:keymap(Fun, 2, [{name,jane,22},{name,lizzie,20},{name,lydia,15}]).
[{name,"jane",22},{name,"lizzie",20},{name,"lydia",15}]</pre></div>  <h3 id="keymember-3" class="code">keymember(Key, N, TupleList) -&gt; boolean()</h3> <p>Types:</p>   <pre>Key = term()
N = integer() &gt;= 1</pre>
<p class="REFBODY">1..tuple_size(Tuple)</p>    <pre>TupleList = [Tuple]
Tuple = tuple()</pre>

<p>Returns <code class="code">true</code> if there is a tuple in <code class="code">TupleList</code> whose <code class="code">N</code>th element compares equal to <code class="code">Key</code>, otherwise <code class="code">false</code>.</p>  <h3 id="keymerge-3" class="code">keymerge(N, TupleList1, TupleList2) -&gt; TupleList3</h3> <p>Types:</p>  <pre>N = integer() &gt;= 1</pre>
<p class="REFBODY">1..tuple_size(Tuple)</p>        <pre>TupleList1 = [T1]
TupleList2 = [T2]
TupleList3 = [T1 | T2]
T1 = T2 = Tuple

Tuple = tuple()</pre>

<p>Returns the sorted list formed by merging <code class="code">TupleList1</code> and <code class="code">TupleList2</code>. The merge is performed on the <code class="code">N</code>th element of each tuple. Both <code class="code">TupleList1</code> and <code class="code">TupleList2</code> must be key-sorted prior to evaluating this function. When two tuples compare equal, the tuple from <code class="code">TupleList1</code> is picked before the tuple from <code class="code">TupleList2</code>.</p>  <h3 id="keyreplace-4" class="code">keyreplace(Key, N, TupleList1, NewTuple) -&gt; TupleList2</h3> <p>Types:</p>   <pre>Key = term()
N = integer() &gt;= 1</pre>
<p class="REFBODY">1..tuple_size(Tuple)</p>      <pre>TupleList1 = TupleList2 = [Tuple]

NewTuple = Tuple
Tuple = tuple()</pre>

<p>Returns a copy of <code class="code">TupleList1</code> where the first occurrence of a <code class="code">T</code> tuple whose <code class="code">N</code>th element compares equal to <code class="code">Key</code> is replaced with <code class="code">NewTuple</code>, if there is such a tuple <code class="code">T</code>.</p>  <h3 id="keysearch-3" class="code">keysearch(Key, N, TupleList) -&gt; {value, Tuple} | false</h3> <p>Types:</p>   <pre>Key = term()
N = integer() &gt;= 1</pre>
<p class="REFBODY">1..tuple_size(Tuple)</p>    <pre>TupleList = [Tuple]
Tuple = tuple()</pre>

<p>Searches the list of tuples <code class="code">TupleList</code> for a tuple whose <code class="code">N</code>th element compares equal to <code class="code">Key</code>. Returns <code class="code">{value, Tuple}</code> if such a tuple is found, otherwise <code class="code">false</code>.</p> <div class="note"> <div class="label">Note</div> <div class="content">

<p>This function is retained for backward compatibility. The function <code class="code">lists:keyfind/3</code> (introduced in R13A) is in most cases more convenient.</p>
</div> </div>  <h3 id="keysort-2" class="code">keysort(N, TupleList1) -&gt; TupleList2</h3> <p>Types:</p>  <pre>N = integer() &gt;= 1</pre>
<p class="REFBODY">1..tuple_size(Tuple)</p>     <pre>TupleList1 = TupleList2 = [Tuple]

Tuple = tuple()</pre>

<p>Returns a list containing the sorted elements of the list <code class="code">TupleList1</code>. Sorting is performed on the <code class="code">N</code>th element of the tuples. The sort is stable.</p>  <h3 id="keystore-4" class="code">keystore(Key, N, TupleList1, NewTuple) -&gt; TupleList2</h3> <p>Types:</p>   <pre>Key = term()
N = integer() &gt;= 1</pre>
<p class="REFBODY">1..tuple_size(Tuple)</p>      <pre>TupleList1 = [Tuple]
TupleList2 = [Tuple, ...]
NewTuple = Tuple
Tuple = tuple()</pre>

<p>Returns a copy of <code class="code">TupleList1</code> where the first occurrence of a tuple <code class="code">T</code> whose <code class="code">N</code>th element compares equal to <code class="code">Key</code> is replaced with <code class="code">NewTuple</code>, if there is such a tuple <code class="code">T</code>. If there is no such tuple <code class="code">T</code> a copy of <code class="code">TupleList1</code> where [<code class="code">NewTuple</code>] has been appended to the end is returned.</p>  <h3 id="keytake-3" class="code">keytake(Key, N, TupleList1) -&gt; {value, Tuple, TupleList2} | false</h3> <p>Types:</p>   <pre>Key = term()
N = integer() &gt;= 1</pre>
<p class="REFBODY">1..tuple_size(Tuple)</p>     <pre>TupleList1 = TupleList2 = [tuple()]

Tuple = tuple()</pre>

<p>Searches the list of tuples <code class="code">TupleList1</code> for a tuple whose <code class="code">N</code>th element compares equal to <code class="code">Key</code>. Returns <code class="code">{value, Tuple, TupleList2}</code> if such a tuple is found, otherwise <code class="code">false</code>. <code class="code">TupleList2</code> is a copy of <code class="code">TupleList1</code> where the first occurrence of <code class="code">Tuple</code> has been removed.</p>  <h3 id="last-1" class="code">last(List) -&gt; Last</h3> <p>Types:</p>     <pre>List = [T, ...]
Last = T
T = term()</pre>

<p>Returns the last element in <code class="code">List</code>.</p>  <h3 id="map-2" class="code">map(Fun, List1) -&gt; List2</h3> <p>Types:</p>       <pre>Fun = fun((A) -&gt; B)
List1 = [A]
List2 = [B]
A = B = term()</pre>

<p>Takes a function from <code class="code">A</code>s to <code class="code">B</code>s, and a list of <code class="code">A</code>s and produces a list of <code class="code">B</code>s by applying the function to every element in the list. This function is used to obtain the return values. The evaluation order is implementation dependent.</p>  <h3 id="mapfoldl-3" class="code">mapfoldl(Fun, Acc0, List1) -&gt; {List2, Acc1}</h3> <p>Types:</p>           <pre>Fun = fun((A, AccIn) -&gt; {B, AccOut})
Acc0 = Acc1 = AccIn = AccOut = term()



List1 = [A]
List2 = [B]
A = B = term()</pre>

<p><code class="code">mapfoldl</code> combines the operations of <code class="code">map/2</code> and <code class="code">foldl/3</code> into one pass. An example, summing the elements in a list and double them at the same time:</p> <div class="example"><pre>
&gt; lists:mapfoldl(fun(X, Sum) -&gt; {2*X, X+Sum} end,
0, [1,2,3,4,5]).
{[2,4,6,8,10],15}</pre></div>  <h3 id="mapfoldr-3" class="code">mapfoldr(Fun, Acc0, List1) -&gt; {List2, Acc1}</h3> <p>Types:</p>           <pre>Fun = fun((A, AccIn) -&gt; {B, AccOut})
Acc0 = Acc1 = AccIn = AccOut = term()



List1 = [A]
List2 = [B]
A = B = term()</pre>

<p><code class="code">mapfoldr</code> combines the operations of <code class="code">map/2</code> and <code class="code">foldr/3</code> into one pass.</p>  <h3 id="max-1" class="code">max(List) -&gt; Max</h3> <p>Types:</p>     <pre>List = [T, ...]
Max = T
T = term()</pre>

<p>Returns the first element of <code class="code">List</code> that compares greater than or equal to all other elements of <code class="code">List</code>.</p>  <h3 id="member-2" class="code">member(Elem, List) -&gt; boolean()</h3> <p>Types:</p>     <pre>Elem = T
List = [T]
T = term()</pre>

<p>Returns <code class="code">true</code> if <code class="code">Elem</code> matches some element of <code class="code">List</code>, otherwise <code class="code">false</code>.</p>  <h3 id="merge-1" class="code">merge(ListOfLists) -&gt; List1</h3> <p>Types:</p>      <pre>ListOfLists = [List]
List = List1 = [T]

T = term()</pre>

<p>Returns the sorted list formed by merging all the sub-lists of <code class="code">ListOfLists</code>. All sub-lists must be sorted prior to evaluating this function. When two elements compare equal, the element from the sub-list with the lowest position in <code class="code">ListOfLists</code> is picked before the other element.</p>  <h3 id="merge-2" class="code">merge(List1, List2) -&gt; List3</h3> <p>Types:</p>       <pre>List1 = [X]
List2 = [Y]
List3 = [X | Y]
X = Y = term()</pre>

<p>Returns the sorted list formed by merging <code class="code">List1</code> and <code class="code">List2</code>. Both <code class="code">List1</code> and <code class="code">List2</code> must be sorted prior to evaluating this function. When two elements compare equal, the element from <code class="code">List1</code> is picked before the element from <code class="code">List2</code>.</p>  <h3 id="merge-3" class="code">merge(Fun, List1, List2) -&gt; List3</h3> <p>Types:</p>        <pre>Fun = fun((A, B) -&gt; boolean())
List1 = [A]
List2 = [B]
List3 = [A | B]
A = B = term()</pre>

<p>Returns the sorted list formed by merging <code class="code">List1</code> and <code class="code">List2</code>. Both <code class="code">List1</code> and <code class="code">List2</code> must be sorted according to the <code class="bold_code"><a href="#ordering_function">ordering function</a></code> <code class="code">Fun</code> prior to evaluating this function. <code class="code">Fun(A, B)</code> should return <code class="code">true</code> if <code class="code">A</code> compares less than or equal to <code class="code">B</code> in the ordering, <code class="code">false</code> otherwise. When two elements compare equal, the element from <code class="code">List1</code> is picked before the element from <code class="code">List2</code>.</p>  <h3 id="merge3-3" class="code">merge3(List1, List2, List3) -&gt; List4</h3> <p>Types:</p>         <pre>List1 = [X]
List2 = [Y]
List3 = [Z]
List4 = [X | Y | Z]
X = Y = Z = term()</pre>

<p>Returns the sorted list formed by merging <code class="code">List1</code>, <code class="code">List2</code> and <code class="code">List3</code>. All of <code class="code">List1</code>, <code class="code">List2</code> and <code class="code">List3</code> must be sorted prior to evaluating this function. When two elements compare equal, the element from <code class="code">List1</code>, if there is such an element, is picked before the other element, otherwise the element from <code class="code">List2</code> is picked before the element from <code class="code">List3</code>.</p>  <h3 id="min-1" class="code">min(List) -&gt; Min</h3> <p>Types:</p>     <pre>List = [T, ...]
Min = T
T = term()</pre>

<p>Returns the first element of <code class="code">List</code> that compares less than or equal to all other elements of <code class="code">List</code>.</p>  <h3 id="nth-2" class="code">nth(N, List) -&gt; Elem</h3> <p>Types:</p>  <pre>N = integer() &gt;= 1</pre>
<p class="REFBODY">1..length(List)</p>     <pre>List = [T, ...]
Elem = T
T = term()</pre>

<p>Returns the <code class="code">N</code>th element of <code class="code">List</code>. For example:</p> <div class="example"><pre>
&gt; lists:nth(3, [a, b, c, d, e]).
c</pre></div>  <h3 id="nthtail-2" class="code">nthtail(N, List) -&gt; Tail</h3> <p>Types:</p>  <pre>N = integer() &gt;= 0</pre>
<p class="REFBODY">0..length(List)</p>     <pre>List = [T, ...]
Tail = [T]
T = term()</pre>

<p>Returns the <code class="code">N</code>th tail of <code class="code">List</code>, that is, the sublist of <code class="code">List</code> starting at <code class="code">N+1</code> and continuing up to the end of the list. For example:</p> <div class="example"><pre>
&gt; lists:nthtail(3, [a, b, c, d, e]).
[d,e]
&gt; tl(tl(tl([a, b, c, d, e]))).
[d,e]
&gt; lists:nthtail(0, [a, b, c, d, e]).
[a,b,c,d,e]
&gt; lists:nthtail(5, [a, b, c, d, e]).
[]</pre></div>  <h3 id="partition-2" class="code">partition(Pred, List) -&gt; {Satisfying, NotSatisfying}</h3> <p>Types:</p>       <pre>Pred = fun((Elem :: T) -&gt; boolean())
List = Satisfying = NotSatisfying = [T]


T = term()</pre>

<p>Partitions <code class="code">List</code> into two lists, where the first list contains all elements for which <code class="code">Pred(Elem)</code> returns <code class="code">true</code>, and the second list contains all elements for which <code class="code">Pred(Elem)</code> returns <code class="code">false</code>.</p> <p>Examples:</p> <div class="example"><pre>
&gt; lists:partition(fun(A) -&gt; A rem 2 == 1 end, [1,2,3,4,5,6,7]).
{[1,3,5,7],[2,4,6]}
&gt; lists:partition(fun(A) -&gt; is_atom(A) end, [a,b,1,c,d,2,3,4,e]).
{[a,b,c,d,e],[1,2,3,4]}</pre></div> <p>See also <code class="code">splitwith/2</code> for a different way to partition a list.</p>  <h3 id="prefix-2" class="code">prefix(List1, List2) -&gt; boolean()</h3> <p>Types:</p>     <pre>List1 = List2 = [T]

T = term()</pre>

<p>Returns <code class="code">true</code> if <code class="code">List1</code> is a prefix of <code class="code">List2</code>, otherwise <code class="code">false</code>.</p>  <h3 id="reverse-1" class="code">reverse(List1) -&gt; List2</h3> <p>Types:</p>     <pre>List1 = List2 = [T]

T = term()</pre>

<p>Returns a list with the elements in <code class="code">List1</code> in reverse order.</p>  <h3 id="reverse-2" class="code">reverse(List1, Tail) -&gt; List2</h3> <p>Types:</p>      <pre>List1 = [T]
Tail = term()
List2 = [T]
T = term()</pre>

<p>Returns a list with the elements in <code class="code">List1</code> in reverse order, with the tail <code class="code">Tail</code> appended. For example:</p> <div class="example"><pre>
&gt; lists:reverse([1, 2, 3, 4], [a, b, c]).
[4,3,2,1,a,b,c]</pre></div>  <h3 id="seq-3" class="code">seq(From, To) -&gt; Seq<br>seq(From, To, Incr) -&gt; Seq</h3> <p>Types:</p>      <pre>From = To = Incr = integer()


Seq = [integer()]</pre>

<p>Returns a sequence of integers which starts with <code class="code">From</code> and contains the successive results of adding <code class="code">Incr</code> to the previous element, until <code class="code">To</code> has been reached or passed (in the latter case, <code class="code">To</code> is not an element of the sequence). <code class="code">Incr</code> defaults to 1.</p> <p>Failure: If <code class="code">To&lt;From-Incr</code> and <code class="code">Incr</code> is positive, or if <code class="code">To&gt;From-Incr</code> and <code class="code">Incr</code> is negative, or if <code class="code">Incr==0</code> and <code class="code">From/=To</code>.</p> <p>The following equalities hold for all sequences:</p> <div class="example"><pre>
length(lists:seq(From, To)) == To-From+1
length(lists:seq(From, To, Incr)) == (To-From+Incr) div Incr</pre></div> <p>Examples:</p> <div class="example"><pre>
&gt; lists:seq(1, 10).
[1,2,3,4,5,6,7,8,9,10]
&gt; lists:seq(1, 20, 3).
[1,4,7,10,13,16,19]
&gt; lists:seq(1, 0, 1).
[]
&gt; lists:seq(10, 6, 4).
[]
&gt; lists:seq(1, 1, 0).
[1]</pre></div>  <h3 id="sort-1" class="code">sort(List1) -&gt; List2</h3> <p>Types:</p>     <pre>List1 = List2 = [T]

T = term()</pre>

<p>Returns a list containing the sorted elements of <code class="code">List1</code>.</p>  <h3 id="sort-2" class="code">sort(Fun, List1) -&gt; List2</h3> <p>Types:</p>      <pre>Fun = fun((A :: T, B :: T) -&gt; boolean())
List1 = List2 = [T]

T = term()</pre>

<p>Returns a list containing the sorted elements of <code class="code">List1</code>, according to the <code class="bold_code"><a href="#ordering_function">ordering function</a></code> <code class="code">Fun</code>. <code class="code">Fun(A, B)</code> should return <code class="code">true</code> if <code class="code">A</code> compares less than or equal to <code class="code">B</code> in the ordering, <code class="code">false</code> otherwise.</p>  <h3 id="split-2" class="code">split(N, List1) -&gt; {List2, List3}</h3> <p>Types:</p>  <pre>N = integer() &gt;= 0</pre>
<p class="REFBODY">0..length(List1)</p>      <pre>List1 = List2 = List3 = [T]


T = term()</pre>

<p>Splits <code class="code">List1</code> into <code class="code">List2</code> and <code class="code">List3</code>. <code class="code">List2</code> contains the first <code class="code">N</code> elements and <code class="code">List3</code> the rest of the elements (the <code class="code">N</code>th tail).</p>  <h3 id="splitwith-2" class="code">splitwith(Pred, List) -&gt; {List1, List2}</h3> <p>Types:</p>       <pre>Pred = fun((T) -&gt; boolean())
List = List1 = List2 = [T]


T = term()</pre>

<p>Partitions <code class="code">List</code> into two lists according to <code class="code">Pred</code>. <code class="code">splitwith/2</code> behaves as if it is defined as follows:</p> <div class="example"><pre>
splitwith(Pred, List) -&gt;
    {takewhile(Pred, List), dropwhile(Pred, List)}.</pre></div> <p>Examples:</p> <div class="example"><pre>
&gt; lists:splitwith(fun(A) -&gt; A rem 2 == 1 end, [1,2,3,4,5,6,7]).
{[1],[2,3,4,5,6,7]}
&gt; lists:splitwith(fun(A) -&gt; is_atom(A) end, [a,b,1,c,d,2,3,4,e]).
{[a,b],[1,c,d,2,3,4,e]}</pre></div> <p>See also <code class="code">partition/2</code> for a different way to partition a list.</p>  <h3 id="sublist-2" class="code">sublist(List1, Len) -&gt; List2</h3> <p>Types:</p>      <pre>List1 = List2 = [T]

Len = integer() &gt;= 0
T = term()</pre>

<p>Returns the sub-list of <code class="code">List1</code> starting at position 1 and with (max) <code class="code">Len</code> elements. It is not an error for <code class="code">Len</code> to exceed the length of the list, in that case the whole list is returned.</p>  <h3 id="sublist-3" class="code">sublist(List1, Start, Len) -&gt; List2</h3> <p>Types:</p>    <pre>List1 = List2 = [T]

Start = integer() &gt;= 1</pre>
<p class="REFBODY">1..(length(List1)+1)</p>    <pre>Len = integer() &gt;= 0
T = term()</pre>

<p>Returns the sub-list of <code class="code">List1</code> starting at <code class="code">Start</code> and with (max) <code class="code">Len</code> elements. It is not an error for <code class="code">Start+Len</code> to exceed the length of the list.</p> <div class="example"><pre>
&gt; lists:sublist([1,2,3,4], 2, 2).
[2,3]
&gt; lists:sublist([1,2,3,4], 2, 5).
[2,3,4]
&gt; lists:sublist([1,2,3,4], 5, 2).
[]</pre></div>  <h3 id="subtract-2" class="code">subtract(List1, List2) -&gt; List3</h3> <p>Types:</p>      <pre>List1 = List2 = List3 = [T]


T = term()</pre>

<p>Returns a new list <code class="code">List3</code> which is a copy of <code class="code">List1</code>, subjected to the following procedure: for each element in <code class="code">List2</code>, its first occurrence in <code class="code">List1</code> is deleted. For example:</p> <div class="example"><pre>
&gt; lists:subtract("123212", "212").
"312".</pre></div> <p><code class="code">lists:subtract(A, B)</code> is equivalent to <code class="code">A -- B</code>.</p> <div class="warning"> <div class="label">Warning</div> <div class="content">

<p>The complexity of <code class="code">lists:subtract(A, B)</code> is proportional to <code class="code">length(A)*length(B)</code>, meaning that it will be very slow if both <code class="code">A</code> and <code class="code">B</code> are long lists. (Using ordered lists and <code class="bold_code"><a href="../ordsets/#subtract-2">ordsets:subtract/2</a></code> is a much better choice if both lists are long.)</p>
</div> </div>  <h3 id="suffix-2" class="code">suffix(List1, List2) -&gt; boolean()</h3> <p>Types:</p>     <pre>List1 = List2 = [T]

T = term()</pre>

<p>Returns <code class="code">true</code> if <code class="code">List1</code> is a suffix of <code class="code">List2</code>, otherwise <code class="code">false</code>.</p>  <h3 id="sum-1" class="code">sum(List) -&gt; number()</h3> <p>Types:</p>   <pre>List = [number()]</pre>

<p>Returns the sum of the elements in <code class="code">List</code>.</p>  <h3 id="takewhile-2" class="code">takewhile(Pred, List1) -&gt; List2</h3> <p>Types:</p>      <pre>Pred = fun((Elem :: T) -&gt; boolean())
List1 = List2 = [T]

T = term()</pre>

<p>Takes elements <code class="code">Elem</code> from <code class="code">List1</code> while <code class="code">Pred(Elem)</code> returns <code class="code">true</code>, that is, the function returns the longest prefix of the list for which all elements satisfy the predicate.</p>  <h3 id="ukeymerge-3" class="code">ukeymerge(N, TupleList1, TupleList2) -&gt; TupleList3</h3> <p>Types:</p>  <pre>N = integer() &gt;= 1</pre>
<p class="REFBODY">1..tuple_size(Tuple)</p>        <pre>TupleList1 = [T1]
TupleList2 = [T2]
TupleList3 = [T1 | T2]
T1 = T2 = Tuple

Tuple = tuple()</pre>

<p>Returns the sorted list formed by merging <code class="code">TupleList1</code> and <code class="code">TupleList2</code>. The merge is performed on the <code class="code">N</code>th element of each tuple. Both <code class="code">TupleList1</code> and <code class="code">TupleList2</code> must be key-sorted without duplicates prior to evaluating this function. When two tuples compare equal, the tuple from <code class="code">TupleList1</code> is picked and the one from <code class="code">TupleList2</code> deleted.</p>  <h3 id="ukeysort-2" class="code">ukeysort(N, TupleList1) -&gt; TupleList2</h3> <p>Types:</p>  <pre>N = integer() &gt;= 1</pre>
<p class="REFBODY">1..tuple_size(Tuple)</p>     <pre>TupleList1 = TupleList2 = [Tuple]

Tuple = tuple()</pre>

<p>Returns a list containing the sorted elements of the list <code class="code">TupleList1</code> where all but the first tuple of the tuples comparing equal have been deleted. Sorting is performed on the <code class="code">N</code>th element of the tuples.</p>  <h3 id="umerge-1" class="code">umerge(ListOfLists) -&gt; List1</h3> <p>Types:</p>      <pre>ListOfLists = [List]
List = List1 = [T]

T = term()</pre>

<p>Returns the sorted list formed by merging all the sub-lists of <code class="code">ListOfLists</code>. All sub-lists must be sorted and contain no duplicates prior to evaluating this function. When two elements compare equal, the element from the sub-list with the lowest position in <code class="code">ListOfLists</code> is picked and the other one deleted.</p>  <h3 id="umerge-2" class="code">umerge(List1, List2) -&gt; List3</h3> <p>Types:</p>       <pre>List1 = [X]
List2 = [Y]
List3 = [X | Y]
X = Y = term()</pre>

<p>Returns the sorted list formed by merging <code class="code">List1</code> and <code class="code">List2</code>. Both <code class="code">List1</code> and <code class="code">List2</code> must be sorted and contain no duplicates prior to evaluating this function. When two elements compare equal, the element from <code class="code">List1</code> is picked and the one from <code class="code">List2</code> deleted.</p>  <h3 id="umerge-3" class="code">umerge(Fun, List1, List2) -&gt; List3</h3> <p>Types:</p>        <pre>Fun = fun((A, B) -&gt; boolean())
List1 = [A]
List2 = [B]
List3 = [A | B]
A = B = term()</pre>

<p>Returns the sorted list formed by merging <code class="code">List1</code> and <code class="code">List2</code>. Both <code class="code">List1</code> and <code class="code">List2</code> must be sorted according to the <code class="bold_code"><a href="#ordering_function">ordering function</a></code> <code class="code">Fun</code> and contain no duplicates prior to evaluating this function. <code class="code">Fun(A, B)</code> should return <code class="code">true</code> if <code class="code">A</code> compares less than or equal to <code class="code">B</code> in the ordering, <code class="code">false</code> otherwise. When two elements compare equal, the element from <code class="code">List1</code> is picked and the one from <code class="code">List2</code> deleted.</p>  <h3 id="umerge3-3" class="code">umerge3(List1, List2, List3) -&gt; List4</h3> <p>Types:</p>         <pre>List1 = [X]
List2 = [Y]
List3 = [Z]
List4 = [X | Y | Z]
X = Y = Z = term()</pre>

<p>Returns the sorted list formed by merging <code class="code">List1</code>, <code class="code">List2</code> and <code class="code">List3</code>. All of <code class="code">List1</code>, <code class="code">List2</code> and <code class="code">List3</code> must be sorted and contain no duplicates prior to evaluating this function. When two elements compare equal, the element from <code class="code">List1</code> is picked if there is such an element, otherwise the element from <code class="code">List2</code> is picked, and the other one deleted.</p>  <h3 id="unzip-1" class="code">unzip(List1) -&gt; {List2, List3}</h3> <p>Types:</p>       <pre>List1 = [{A, B}]
List2 = [A]
List3 = [B]
A = B = term()</pre>

<p>"Unzips" a list of two-tuples into two lists, where the first list contains the first element of each tuple, and the second list contains the second element of each tuple.</p>  <h3 id="unzip3-1" class="code">unzip3(List1) -&gt; {List2, List3, List4}</h3> <p>Types:</p>         <pre>List1 = [{A, B, C}]
List2 = [A]
List3 = [B]
List4 = [C]
A = B = C = term()</pre>

<p>"Unzips" a list of three-tuples into three lists, where the first list contains the first element of each tuple, the second list contains the second element of each tuple, and the third list contains the third element of each tuple.</p>  <h3 id="usort-1" class="code">usort(List1) -&gt; List2</h3> <p>Types:</p>     <pre>List1 = List2 = [T]

T = term()</pre>

<p>Returns a list containing the sorted elements of <code class="code">List1</code> where all but the first element of the elements comparing equal have been deleted.</p>  <h3 id="usort-2" class="code">usort(Fun, List1) -&gt; List2</h3> <p>Types:</p>      <pre>Fun = fun((T, T) -&gt; boolean())
List1 = List2 = [T]

T = term()</pre>

<p>Returns a list which contains the sorted elements of <code class="code">List1</code> where all but the first element of the elements comparing equal according to the <code class="bold_code"><a href="#ordering_function">ordering function</a></code> <code class="code">Fun</code> have been deleted. <code class="code">Fun(A, B)</code> should return <code class="code">true</code> if <code class="code">A</code> compares less than or equal to <code class="code">B</code> in the ordering, <code class="code">false</code> otherwise.</p>  <h3 id="zip-2" class="code">zip(List1, List2) -&gt; List3</h3> <p>Types:</p>       <pre>List1 = [A]
List2 = [B]
List3 = [{A, B}]
A = B = term()</pre>

<p>"Zips" two lists of equal length into one list of two-tuples, where the first element of each tuple is taken from the first list and the second element is taken from corresponding element in the second list.</p>  <h3 id="zip3-3" class="code">zip3(List1, List2, List3) -&gt; List4</h3> <p>Types:</p>         <pre>List1 = [A]
List2 = [B]
List3 = [C]
List4 = [{A, B, C}]
A = B = C = term()</pre>

<p>"Zips" three lists of equal length into one list of three-tuples, where the first element of each tuple is taken from the first list, the second element is taken from corresponding element in the second list, and the third element is taken from the corresponding element in the third list.</p>  <h3 id="zipwith-3" class="code">zipwith(Combine, List1, List2) -&gt; List3</h3> <p>Types:</p>         <pre>Combine = fun((X, Y) -&gt; T)
List1 = [X]
List2 = [Y]
List3 = [T]
X = Y = T = term()</pre>

<p>Combine the elements of two lists of equal length into one list. For each pair <code class="code">X, Y</code> of list elements from the two lists, the element in the result list will be <code class="code">Combine(X, Y)</code>.</p> <p><code class="code">zipwith(fun(X, Y) -&gt; {X,Y} end, List1, List2)</code> is equivalent to <code class="code">zip(List1, List2)</code>.</p> <p>Example:</p> <div class="example"><pre>
&gt; lists:zipwith(fun(X, Y) -&gt; X+Y end, [1,2,3], [4,5,6]).
[5,7,9]</pre></div>  <h3 id="zipwith3-4" class="code">zipwith3(Combine, List1, List2, List3) -&gt; List4</h3> <p>Types:</p>           <pre>Combine = fun((X, Y, Z) -&gt; T)
List1 = [X]
List2 = [Y]
List3 = [Z]
List4 = [T]
X = Y = Z = T = term()</pre>

<p>Combine the elements of three lists of equal length into one list. For each triple <code class="code">X, Y, Z</code> of list elements from the three lists, the element in the result list will be <code class="code">Combine(X, Y, Z)</code>.</p> <p><code class="code">zipwith3(fun(X, Y, Z) -&gt; {X,Y,Z} end, List1, List2, List3)</code> is equivalent to <code class="code">zip3(List1, List2, List3)</code>.</p> <p>Examples:</p> <div class="example"><pre>
&gt; lists:zipwith3(fun(X, Y, Z) -&gt; X+Y+Z end, [1,2,3], [4,5,6], [7,8,9]).
[12,15,18]
&gt; lists:zipwith3(fun(X, Y, Z) -&gt; [X,Y,Z] end, [a,b,c], [x,y,z], [1,2,3]).
[[a,x,1],[b,y,2],[c,z,3]]</pre></div>
<div class="_attribution">
  <p class="_attribution-p">
    © 1999–2016 Ericsson AB<br>Licensed under the Apache License, Version 2.0.<br>
    
  </p>
</div>

			</div>
		</div>
	</section>

	</div>
</body>
</html>
