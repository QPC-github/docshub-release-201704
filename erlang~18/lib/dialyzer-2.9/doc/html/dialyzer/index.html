
<!DOCTYPE HTML>

<html lang="en">

<head>
  <meta charset="utf-8">
  <title>Dialyzer - Erlang 18 - W3cubDocs</title>
  
  <meta name="description" content=" dialyzer ">
  <meta name="keywords" content="dialyzer, -, erlang, erlang~18">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="http://docs.w3cub.com/erlang~18/lib/dialyzer-2.9/doc/html/dialyzer/">
  <link href="/favicon.png" rel="icon">
  <link type="text/css" rel="stylesheet" href="/assets/application-50364fff564ce3b6327021805f3f00e2957b441cf27f576a7dd4ff63bbc47047.css">
  <script type="text/javascript" src="/assets/application-db64bfd54ceb42be11af7995804cf4902548419ceb79d509b0b7d62c22d98e6f.js"></script>
  <script src="/json/erlang~18.js"></script>
  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-71174418-1']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>


</head>

<body>
	<div class="_app">
	<header class="_header">
  
  <form class="_search">
    <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
    <a class="_search-clear"></a>
    <div class="_search-tag"></div>
  </form>
  
  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/erlang~18/" class="_nav-link" title="" style="margin-left:0;">Erlang 18</a></span>
  
  <nav class="_nav">
    <a href="/app/" class="_nav-link ">App</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		<div class="_list">
			
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<div class="_page _erlang">
				
<h1>dialyzer</h1> <h2>Module</h2> <p class="REFBODY">dialyzer</p> <h2>Module summary</h2> <p class="REFBODY">The Dialyzer, a DIscrepancy AnalYZer for ERlang programs</p> <h2>Description</h2> 
<p>The Dialyzer is a static analysis tool that identifies software discrepancies such as definite type errors, code which has become dead or unreachable due to some programming error, unnecessary tests, etc. in single Erlang modules or entire (sets of) applications. Dialyzer starts its analysis from either debug-compiled BEAM bytecode or from Erlang source code. The file and line number of a discrepancy is reported along with an indication of what the discrepancy is about. Dialyzer bases its analysis on the concept of success typings which allows for sound warnings (no false positives).</p> <p>Read more about Dialyzer and about how to use it from the GUI in <code class="bold_code"><a href="../dialyzer_chapter/">Dialyzer User's Guide</a></code>.</p>  <h2 id="id61558">Using the Dialyzer from the command line</h2>  <p>Dialyzer also has a command line version for automated use. Below is a brief description of the list of its options. The same information can be obtained by writing</p> <div class="example"><pre>
dialyzer --help</pre></div> <p>in a shell. Please refer to the GUI description for more details on the operation of Dialyzer.</p> <p>The exit status of the command line version is:</p> <div class="example"><pre>
0 - No problems were encountered during the analysis and no
    warnings were emitted.
1 - Problems were encountered during the analysis.
2 - No problems were encountered, but warnings were emitted.</pre></div> <p>Usage:</p> <div class="example"><pre>
     dialyzer [--help] [--version] [--shell] [--quiet] [--verbose]
[-pa dir]* [--plt plt] [--plts plt*] [-Ddefine]*
              [-I include_dir]* [--output_plt file] [-Wwarn]* [--raw]
              [--src] [--gui] [files_or_dirs] [-r dirs]
              [--apps applications] [-o outfile]
[--build_plt] [--add_to_plt] [--remove_from_plt]
[--check_plt] [--no_check_plt] [--plt_info] [--get_warnings]
              [--dump_callgraph file] [--no_native] [--fullpath]
              [--statistics] [--no_native_cache]</pre></div> <p>Options:</p> <dl> <dt><strong><code class="code">files_or_dirs</code> (for backwards compatibility also as: <code class="code">-c files_or_dirs</code>)</strong></dt> <dd>Use Dialyzer from the command line to detect defects in the specified files or directories containing <code class="code">.erl</code> or <code class="code">.beam</code> files, depending on the type of the analysis.</dd> <dt><strong><code class="code">-r dirs</code></strong></dt> <dd>Same as the previous but the specified directories are searched recursively for subdirectories containing <code class="code">.erl</code> or <code class="code">.beam</code> files in them, depending on the type of analysis.</dd> <dt><strong><code class="code">--apps applications</code></strong></dt> <dd>Option typically used when building or modifying a plt as in: <div class="example"><pre>
dialyzer --build_plt --apps erts kernel stdlib mnesia ...</pre></div> to conveniently refer to library applications corresponding to the Erlang/OTP installation. However, the option is general and can also be used during analysis in order to refer to Erlang/OTP applications. In addition, file or directory names can also be included, as in: <div class="example"><pre>
dialyzer --apps inets ssl ./ebin ../other_lib/ebin/my_module.beam</pre></div> </dd> <dt><strong><code class="code">-o outfile</code> (or <code class="code">--output outfile</code>)</strong></dt> <dd>When using Dialyzer from the command line, send the analysis results to the specified outfile rather than to stdout.</dd> <dt><strong><code class="code">--raw</code></strong></dt> <dd>When using Dialyzer from the command line, output the raw analysis results (Erlang terms) instead of the formatted result. The raw format is easier to post-process (for instance, to filter warnings or to output HTML pages).</dd> <dt><strong><code class="code">--src</code></strong></dt> <dd>Override the default, which is to analyze BEAM files, and analyze starting from Erlang source code instead.</dd> <dt><strong><code class="code">-Dname</code> (or <code class="code">-Dname=value</code>)</strong></dt> <dd>When analyzing from source, pass the define to Dialyzer. (**)</dd> <dt><strong><code class="code">-I include_dir</code></strong></dt> <dd>When analyzing from source, pass the <code class="code">include_dir</code> to Dialyzer. (**)</dd> <dt><strong><code class="code">-pa dir</code></strong></dt> <dd>Include <code class="code">dir</code> in the path for Erlang (useful when analyzing files that have <code class="code">'-include_lib()'</code> directives).</dd> <dt><strong><code class="code">--output_plt file</code></strong></dt> <dd>Store the plt at the specified file after building it.</dd> <dt><strong><code class="code">--plt plt</code></strong></dt> <dd>Use the specified plt as the initial plt (if the plt was built during setup the files will be checked for consistency).</dd> <dt><strong><code class="code">--plts plt*</code></strong></dt> <dd>Merge the specified plts to create the initial plt -- requires that the plts are disjoint (i.e., do not have any module appearing in more than one plt). The plts are created in the usual way: <div class="example"><pre>
dialyzer --build_plt --output_plt plt_1 files_to_include
...
dialyzer --build_plt --output_plt plt_n files_to_include</pre></div> and then can be used in either of the following ways: <div class="example"><pre>
dialyzer files_to_analyze --plts plt_1 ... plt_n</pre></div> or: <div class="example"><pre>
dialyzer --plts plt_1 ... plt_n -- files_to_analyze</pre></div> (Note the -- delimiter in the second case)</dd> <dt><strong><code class="code">-Wwarn</code></strong></dt> <dd>A family of options which selectively turn on/off warnings (for help on the names of warnings use <code class="code">dialyzer -Whelp</code>). Note that the options can also be given in the file with a <code class="code">-dialyzer()</code> attribute. See <code class="bold_code"><a href="#suppression">Requesting or Suppressing Warnings in Source Files</a></code> below for details.</dd> <dt><strong><code class="code">--shell</code></strong></dt> <dd>Do not disable the Erlang shell while running the GUI.</dd> <dt><strong><code class="code">--version</code> (or <code class="code">-v</code>)</strong></dt> <dd>Print the Dialyzer version and some more information and exit.</dd> <dt><strong><code class="code">--help</code> (or <code class="code">-h</code>)</strong></dt> <dd>Print this message and exit.</dd> <dt><strong><code class="code">--quiet</code> (or <code class="code">-q</code>)</strong></dt> <dd>Make Dialyzer a bit more quiet.</dd> <dt><strong><code class="code">--verbose</code></strong></dt> <dd>Make Dialyzer a bit more verbose.</dd> <dt><strong><code class="code">--statistics</code></strong></dt> <dd>Prints information about the progress of execution (analysis phases, time spent in each and size of the relative input).</dd> <dt><strong><code class="code">--build_plt</code></strong></dt> <dd>The analysis starts from an empty plt and creates a new one from the files specified with <code class="code">-c</code> and <code class="code">-r</code>. Only works for beam files. Use <code class="code">--plt</code> or <code class="code">--output_plt</code> to override the default plt location.</dd> <dt><strong><code class="code">--add_to_plt</code></strong></dt> <dd>The plt is extended to also include the files specified with <code class="code">-c</code> and <code class="code">-r</code>. Use <code class="code">--plt</code> to specify which plt to start from, and <code class="code">--output_plt</code> to specify where to put the plt. Note that the analysis might include files from the plt if they depend on the new files. This option only works with beam files.</dd> <dt><strong><code class="code">--remove_from_plt</code></strong></dt> <dd>The information from the files specified with <code class="code">-c</code> and <code class="code">-r</code> is removed from the plt. Note that this may cause a re-analysis of the remaining dependent files.</dd> <dt><strong><code class="code">--check_plt</code></strong></dt> <dd>Check the plt for consistency and rebuild it if it is not up-to-date.</dd> <dt><strong><code class="code">--no_check_plt</code></strong></dt> <dd>Skip the plt check when running Dialyzer. Useful when working with installed plts that never change.</dd> <dt><strong><code class="code">--plt_info</code></strong></dt> <dd>Make Dialyzer print information about the plt and then quit. The plt can be specified with <code class="code">--plt(s)</code>.</dd> <dt><strong><code class="code">--get_warnings</code></strong></dt> <dd>Make Dialyzer emit warnings even when manipulating the plt. Warnings are only emitted for files that are actually analyzed.</dd> <dt><strong><code class="code">--dump_callgraph file</code></strong></dt> <dd>Dump the call graph into the specified file whose format is determined by the file name extension. Supported extensions are: raw, dot, and ps. If something else is used as file name extension, default format '.raw' will be used.</dd> <dt><strong><code class="code">--no_native</code> (or <code class="code">-nn</code>)</strong></dt> <dd>Bypass the native code compilation of some key files that Dialyzer heuristically performs when dialyzing many files; this avoids the compilation time but it may result in (much) longer analysis time.</dd> <dt><strong><code class="code">--no_native_cache</code></strong></dt> <dd>By default, Dialyzer caches the results of native compilation in the <code class="code">$XDG_CACHE_HOME/erlang/dialyzer_hipe_cache</code> directory. <code class="code">XDG_CACHE_HOME</code> defaults to <code class="code">$HOME/.cache</code>. Use this option to disable caching.</dd> <dt><strong><code class="code">--fullpath</code></strong></dt> <dd>Display the full path names of files for which warnings are emitted.</dd> <dt><strong><code class="code">--gui</code></strong></dt> <dd>Use the GUI.</dd> </dl> <div class="note"> <div class="label">Note</div> <div class="content">

<p>* denotes that multiple occurrences of these options are possible.</p> <p>** options <code class="code">-D</code> and <code class="code">-I</code> work both from command-line and in the Dialyzer GUI; the syntax of defines and includes is the same as that used by <code class="code">erlc</code>.</p> </div> </div> <p>Warning options:</p> <dl> <dt><strong><code class="code">-Wno_return</code></strong></dt> <dd>Suppress warnings for functions that will never return a value.</dd> <dt><strong><code class="code">-Wno_unused</code></strong></dt> <dd>Suppress warnings for unused functions.</dd> <dt><strong><code class="code">-Wno_improper_lists</code></strong></dt> <dd>Suppress warnings for construction of improper lists.</dd> <dt><strong><code class="code">-Wno_fun_app</code></strong></dt> <dd>Suppress warnings for fun applications that will fail.</dd> <dt><strong><code class="code">-Wno_match</code></strong></dt> <dd>Suppress warnings for patterns that are unused or cannot match.</dd> <dt><strong><code class="code">-Wno_opaque</code></strong></dt> <dd>Suppress warnings for violations of opaqueness of data types.</dd> <dt><strong><code class="code">-Wno_fail_call</code></strong></dt> <dd>Suppress warnings for failing calls.</dd> <dt><strong><code class="code">-Wno_contracts</code></strong></dt> <dd>Suppress warnings about invalid contracts.</dd> <dt><strong><code class="code">-Wno_behaviours</code></strong></dt> <dd>Suppress warnings about behaviour callbacks which drift from the published recommended interfaces.</dd> <dt><strong><code class="code">-Wno_missing_calls</code></strong></dt> <dd>Suppress warnings about calls to missing functions.</dd> <dt><strong><code class="code">-Wno_undefined_callbacks</code></strong></dt> <dd>Suppress warnings about behaviours that have no <code class="code">-callback</code> attributes for their callbacks.</dd> <dt><strong><code class="code">-Wunmatched_returns</code>***</strong></dt> <dd>Include warnings for function calls which ignore a structured return value or do not match against one of many possible return value(s).</dd> <dt><strong><code class="code">-Werror_handling</code>***</strong></dt> <dd>Include warnings for functions that only return by means of an exception.</dd> <dt><strong><code class="code">-Wrace_conditions</code>***</strong></dt> <dd>Include warnings for possible race conditions. Note that the analysis that finds data races performs intra-procedural data flow analysis and can sometimes explode in time. Enable it at your own risk. </dd> i <dt><strong><code class="code">-Wunderspecs</code>***</strong></dt> <dd>Warn about underspecified functions (the -spec is strictly more allowing than the success typing).</dd> <dt><strong><code class="code">-Wunknown</code>***</strong></dt> <dd>Let warnings about unknown functions and types affect the exit status of the command line version. The default is to ignore warnings about unknown functions and types when setting the exit status. When using the Dialyzer from Erlang, warnings about unknown functions and types are returned; the default is not to return these warnings.</dd> </dl> <p>The following options are also available but their use is not recommended: (they are mostly for Dialyzer developers and internal debugging)</p> <dl> <dt><strong><code class="code">-Woverspecs</code>***</strong></dt> <dd>Warn about overspecified functions (the -spec is strictly less allowing than the success typing).</dd> <dt><strong><code class="code">-Wspecdiffs</code>***</strong></dt> <dd>Warn when the -spec is different than the success typing.</dd> </dl> <div class="note"> <div class="label">Note</div> <div class="content">

<p>*** Identifies options that turn on warnings rather than turning them off.</p> </div> </div>  <h2 id="id62246">Using the Dialyzer from Erlang</h2>  <p>You can also use Dialyzer directly from Erlang. Both the GUI and the command line versions are available. The options are similar to the ones given from the command line, so please refer to the sections above for a description of these.</p>  <h2 id="id62264">Requesting or Suppressing Warnings in Source Files</h2>   <p> The <code class="code">-dialyzer()</code> attribute can be used for turning off warnings in a module by specifying functions or warning options. For example, to turn off all warnings for the function <code class="code">f/0</code>, include the following line: </p> <div class="example"><pre>
-dialyzer({nowarn_function, f/0}).
</pre></div> <p>To turn off warnings for improper lists, add the following line to the source file: </p> <div class="example"><pre>
-dialyzer(no_improper_lists).
</pre></div> <p>The <code class="code">-dialyzer()</code> attribute is allowed after function declarations. Lists of warning options or functions are allowed: </p> <div class="example"><pre>
-dialyzer([{nowarn_function, [f/0]}, no_improper_lists]).
</pre></div> <p> Warning options can be restricted to functions: </p> <div class="example"><pre>
-dialyzer({no_improper_lists, g/0}).
</pre></div> <div class="example"><pre>
-dialyzer({[no_return, no_match], [g/0, h/0]}).
</pre></div> <p> For help on the warning options use <code class="code">dialyzer -Whelp</code>. The options are also enumerated <code class="bold_code"><a href="#gui-1">below</a></code> (<code class="code">WarnOpts</code>). </p> <div class="note"> <div class="label">Note</div> <div class="content">

<p> The <code class="code">-dialyzer()</code> attribute is not checked by the Erlang Compiler, but by the Dialyzer itself. </p> </div> </div> <div class="note"> <div class="label">Note</div> <div class="content">

<p> The warning option <code class="code">-Wrace_conditions</code> has no effect when set in source files. </p> </div> </div> <p> The <code class="code">-dialyzer()</code> attribute can also be used for turning on warnings. For instance, if a module has been fixed regarding unmatched returns, adding the line </p> <div class="example"><pre>
-dialyzer(unmatched_returns).
</pre></div> <p> can help in assuring that no new unmatched return warnings are introduced. </p>  <h2>Exports</h2> <h3 id="gui-1" class="code">gui() -&gt; ok | {error, Msg}<br>gui(OptList) -&gt; ok | {error, Msg}</h3>  <p>Types:</p>   <pre>OptList -- see below</pre>

<p>Dialyzer GUI version.</p> <div class="example"><pre>
OptList  :: [Option]
Option   :: {files,          [Filename :: string()]}
          | {files_rec,      [DirName :: string()]}
          | {defines,        [{Macro :: atom(), Value :: term()}]}
          | {from,           src_code | byte_code}   %% Defaults to byte_code
          | {init_plt,       FileName :: string()}   %% If changed from default
          | {plts,           [FileName :: string()]} %% If changed from default
          | {include_dirs,   [DirName :: string()]}
          | {output_file,    FileName :: string()}
          | {output_plt,     FileName :: string()}
          | {check_plt,      boolean()},
          | {analysis_type,  'succ_typings' |
                             'plt_add' |
                             'plt_build' |
                             'plt_check' |
                             'plt_remove'}
          | {warnings,       [WarnOpts]}
          | {get_warnings,   bool()}

WarnOpts :: no_return
          | no_unused
          | no_improper_lists
          | no_fun_app
          | no_match
          | no_opaque
          | no_fail_call
          | no_contracts
          | no_behaviours
          | no_undefined_callbacks
          | unmatched_returns
          | error_handling
          | race_conditions
          | overspecs
          | underspecs
          | specdiffs
          | unknown</pre></div>  <h3 id="run-1" class="code">run(OptList) -&gt; Warnings</h3>  <p>Types:</p>    <pre>OptList -- see gui/0,1
Warnings -- see below</pre>

<p>Dialyzer command line version.</p> <div class="example"><pre>
Warnings :: [{Tag, Id, Msg}]
Tag :: 'warn_behaviour'
     | 'warn_bin_construction'
     | 'warn_callgraph'
     | 'warn_contract_not_equal'
     | 'warn_contract_range'
     | 'warn_contract_subtype'
     | 'warn_contract_supertype'
     | 'warn_contract_syntax'
     | 'warn_contract_types'
     | 'warn_failing_call'
     | 'warn_fun_app'
     | 'warn_matching'
     | 'warn_non_proper_list'
     | 'warn_not_called'
     | 'warn_opaque'
     | 'warn_race_condition'
     | 'warn_return_no_exit'
     | 'warn_return_only_exit'
     | 'warn_umatched_return'
     | 'warn_undefined_callbacks'
     | 'warn_unknown'
Id = {File :: string(), Line :: integer()}
Msg = msg() -- Undefined</pre></div>  <h3 id="format_warning-1" class="code">format_warning(Msg) -&gt; string()</h3>  <p>Types:</p>   <pre>Msg = {Tag, Id, msg()} -- See run/1</pre>

<p>Get a string from warnings as returned by dialyzer:run/1.</p>  <h3 id="plt_info-1" class="code">plt_info(string()) -&gt; {'ok', [{atom(), any()}]} | {'error', atom()}</h3> 
<p>Returns information about the specified plt.</p>
<div class="_attribution">
  <p class="_attribution-p">
    © 1999–2016 Ericsson AB<br>Licensed under the Apache License, Version 2.0.<br>
    
  </p>
</div>

			</div>
		</div>
	</section>

	</div>
</body>
</html>
