
<!DOCTYPE HTML>

<html lang="en">

<head>
  <meta charset="utf-8">
  <title>1 Dialyzer - Erlang 18 - W3cubDocs</title>
  
  <meta name="description" content="Dialyzer is a static analysis tool that identifies software discrepancies such as type errors, unreachable code, unnecessary tests, etc in single &hellip;">
  <meta name="keywords" content="dialyzer, -, erlang, erlang~18">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="http://docs.w3cub.com/erlang~18/lib/dialyzer-2.9/doc/html/dialyzer_chapter/">
  <link href="/favicon.png" rel="icon">
  <link type="text/css" rel="stylesheet" href="/assets/application-50364fff564ce3b6327021805f3f00e2957b441cf27f576a7dd4ff63bbc47047.css">
  <script type="text/javascript" src="/assets/application-db64bfd54ceb42be11af7995804cf4902548419ceb79d509b0b7d62c22d98e6f.js"></script>
  <script src="/json/erlang~18.js"></script>
  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-71174418-1']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>


</head>

<body>
	<div class="_app">
	<header class="_header">
  
  <form class="_search">
    <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
    <a class="_search-clear"></a>
    <div class="_search-tag"></div>
  </form>
  
  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/erlang~18/" class="_nav-link" title="" style="margin-left:0;">Erlang 18</a></span>
  
  <nav class="_nav">
    <a href="/app/" class="_nav-link ">App</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		<div class="_list">
			
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<div class="_page _erlang">
				
<h1>1 Dialyzer</h1> <h2 id="id56859">1.1 Introduction</h2> <p><strong>Dialyzer</strong> is a static analysis tool that identifies software discrepancies such as type errors, unreachable code, unnecessary tests, etc in single Erlang modules or entire (sets of) applications.</p> <h2 id="id60735">1.2 Using the Dialyzer from the GUI</h2> <h4>Choosing the applications or modules</h4> <p>In the "File" window you will find a listing of the current directory. Click your way to the directories/modules you want to add or type the correct path in the entry.</p> <p>Mark the directories/modules you want to analyze for discrepancies and click "Add". You can either add the <code class="code">.beam</code> and <code class="code">.erl</code>-files directly, or you can add directories that contain these kinds of files. Note that you are only allowed to add the type of files that can be analyzed in the current mode of operation (see below), and that you cannot mix <code class="code">.beam</code> and <code class="code">.erl</code>-files.</p> <h4>The analysis modes</h4> <p>Dialyzer has two modes of analysis, "Byte Code" or "Source Code". These are controlled by the buttons in the top-middle part of the main window, under "Analysis Options".</p> <h4>Controlling the discrepancies reported by the Dialyzer</h4> <p>Under the "Warnings" pull-down menu, there are buttons that control which discrepancies are reported to the user in the "Warnings" window. By clicking on these buttons, one can enable/disable a whole class of warnings. Information about the classes of warnings can be found on the "Warnings" item under the "Help" menu (at the rightmost top corner).</p> <p>If modules are compiled with inlining, spurious warnings may be emitted. In the "Options" menu you can choose to ignore inline-compiled modules when analyzing byte code. When starting from source code this is not a problem since the inlining is explicitly turned off by Dialyzer. The option causes Dialyzer to suppress all warnings from inline-compiled modules, since there is currently no way for Dialyzer to find what parts of the code have been produced by inlining. </p> <h4>Running the analysis</h4> <p>Once you have chosen the modules or directories you want to analyze, click the "Run" button to start the analysis. If for some reason you want to stop the analysis while it is running, push the "Stop" button.</p> <p>The information from the analysis will be displayed in the Log and the Warnings windows.</p> <h4>Include directories and macro definitions</h4> <p>When analyzing from source you might have to supply Dialyzer with a list of include directories and macro definitions (as you can do with the <code class="code">erlc</code> flags <code class="code">-I</code> and <code class="code">-D</code>). This can be done either by starting Dialyzer with these flags from the command line as in:</p> <div class="example"><pre>

dialyzer -I my_includes -DDEBUG -Dvsn=42 -I one_more_dir
</pre></div> <p>or by adding these explicitly using the "Manage Macro Definitions" or "Manage Include Directories" sub-menus in the "Options" menu.</p> <h4>Saving the information on the Log and Warnings windows</h4> <p>In the "File" menu there are options to save the contents of the Log and the Warnings window. Just choose the options and enter the file to save the contents in.</p> <p>There are also buttons to clear the contents of each window.</p> <h4>Inspecting the inferred types of the analyzed functions</h4> <p>Dialyzer stores the information of the analyzed functions in a Persistent Lookup Table (PLT). After an analysis you can inspect this information. In the PLT menu you can choose to either search the PLT or inspect the contents of the whole PLT. The information is presented in edoc format.</p> <h2 id="id59179">1.3 Using the Dialyzer from the command line</h2> <p>See <code class="bold_code"><a href="../dialyzer/">dialyzer(3)</a></code>.</p> <h2 id="id59195">1.4 Using the Dialyzer from Erlang</h2> <p>See <code class="bold_code"><a href="../dialyzer/">dialyzer(3)</a></code>.</p> <h2 id="id59082">1.5 More on the Persistent Lookup Table (PLT)</h2> <p> The persistent lookup table, or PLT, is used to store the result of an analysis. The PLT can then be used as a starting point for later analyses. It is recommended to build a PLT with the otp applications that you are using, but also to include your own applications that you are using frequently.</p> <p>The PLT is built using the --build_plt option to dialyzer. The following command builds the recommended minimal PLT for OTP.</p> <div class="example"><pre>

dialyzer --build_plt -r $ERL_TOP/lib/stdlib/ebin\
                        $ERL_TOP/lib/kernel/ebin \
                        $ERL_TOP/lib/mnesia/ebin
</pre></div> <p>Dialyzer will look if there is an environment variable called $DIALYZER_PLT and place the PLT at this location. If no such variable is set, Dialyzer will place the PLT at $HOME/.dialyzer_plt. The placement can also be specified using the --plt, or --output_plt options.</p> <p>You can also add information to an existing plt using the --add_to_plt option. Suppose you want to also include the compiler in the PLT and place it in a new PLT, then give the command</p> <div class="example"><pre>

dialyzer --add_to_plt -r $ERL_TOP/lib/compiler/ebin --output_plt my.plt
</pre></div> <p>Then you would like to add your favorite application my_app to the new plt.</p> <div class="example"><pre>

dialyzer --add_to_plt --plt my.plt -r my_app/ebin
</pre></div> <p>But you realize that it is unnecessary to have compiler in this one.</p> <div class="example"><pre>

dialyzer --remove_from_plt --plt my.plt -r $ERL_TOP/lib/compiler/ebin
</pre></div> <p> Later, when you have fixed a bug in your application my_app, you want to update the plt so that it will be fresh the next time you run Dialyzer, run the command</p> <div class="example"><pre>

dialyzer --check_plt --plt my.plt
</pre></div> <p> Dialyzer will then reanalyze the files that have been changed, and the files that depend on these files. Note that this consistency check will be performed automatically the next time you run Dialyzer with this plt. The --check_plt option is merely for doing so without doing any other analysis.</p> <p> To get some information about a plt use the option</p> <div class="example"><pre>

dialyzer --plt_info
</pre></div> <p>You can also specify which plt with the --plt option, and get the output printed to a file with --output_file</p> <p>Note that when manipulating the plt, no warnings are emitted. To turn on warnings during (re)analysis of the plt, use the option --get_warnings.</p> <h2 id="id61338">1.6 Feedback and bug reports</h2> <p>At this point, we very much welcome user feedback (even wish-lists!). If you notice something weird, especially if the Dialyzer reports any discrepancy that is a false positive, please send an error report describing the symptoms and how to reproduce them to:</p> <div class="example"><pre>
tobias.lindahl@it.uu.se, kostis@it.uu.se
</pre></div>
<div class="_attribution">
  <p class="_attribution-p">
    © 1999–2016 Ericsson AB<br>Licensed under the Apache License, Version 2.0.<br>
    
  </p>
</div>

			</div>
		</div>
	</section>

	</div>
</body>
</html>
