
<!DOCTYPE HTML>

<html lang="en">

<head>
  <meta charset="utf-8">
  <title>Erl_ddll - Erlang 18 - W3cubDocs</title>
  
  <meta name="description" content=" erl_ddll ">
  <meta name="keywords" content="erl, ddll, -, erlang, erlang~18">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="http://docs.w3cub.com/erlang~18/lib/kernel-4.2/doc/html/erl_ddll/">
  <link href="/favicon.png" rel="icon">
  <link type="text/css" rel="stylesheet" href="/assets/application-50364fff564ce3b6327021805f3f00e2957b441cf27f576a7dd4ff63bbc47047.css">
  <script type="text/javascript" src="/assets/application-db64bfd54ceb42be11af7995804cf4902548419ceb79d509b0b7d62c22d98e6f.js"></script>
  <script src="/json/erlang~18.js"></script>
  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-71174418-1']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>


</head>

<body>
	<div class="_app">
	<header class="_header">
  
  <form class="_search">
    <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
    <a class="_search-clear"></a>
    <div class="_search-tag"></div>
  </form>
  
  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/erlang~18/" class="_nav-link" title="" style="margin-left:0;">Erlang 18</a></span>
  
  <nav class="_nav">
    <a href="/app/" class="_nav-link ">App</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		<div class="_list">
			
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<div class="_page _erlang">
				
<h1>erl_ddll</h1> <h2>Module</h2> <p class="REFBODY">erl_ddll</p> <h2>Module summary</h2> <p class="REFBODY">Dynamic Driver Loader and Linker</p> <h2>Description</h2> 
<p>The <code class="code">erl_ddll</code> module provides an interface for loading and unloading <strong>erlang linked in drivers</strong> in runtime.</p> <div class="note"> <div class="label">Note</div> <div class="content">

<p>This is a large reference document. For casual use of the module, as well as for most real world applications, the descriptions of the functions <code class="bold_code"><a href="#load-2">load/2</a></code> and <code class="bold_code"><a href="#unload-1">unload/1</a></code> are enough to get going. </p> </div> </div> <p>The driver should be provided as a dynamically linked library in a object code format specific for the platform in use, i. e. <code class="code">.so</code> files on most Unix systems and <code class="code">.ddl</code> files on windows. An erlang linked in driver has to provide specific interfaces to the emulator, so this module is not designed for loading arbitrary dynamic libraries. For further information about erlang drivers, refer to the ERTS reference manual section <code class="bold_code">erl_driver</code>.</p>  <p>When describing a set of functions, (i.e. a module, a part of a module or an application) executing in a process and wanting to use a ddll-driver, we use the term <strong>user</strong>. There can be several users in one process (different modules needing the same driver) and several processes running the same code, making up several <strong>users</strong> of a driver. In the basic scenario, each user loads the driver before starting to use it and unloads the driver when done. The reference counting keeps track of processes as well as the number of loads by each process, so that the driver will only be unloaded when no one wants it (it has no user). The driver also keeps track of ports that are opened towards it, so that one can delay unloading until all ports are closed or kill all ports using the driver when it is unloaded. </p>  <p>The interface supports two basic scenarios of loading and unloading. Each scenario can also have the option of either killing ports when the driver is unloading, or waiting for the ports to close themselves. The scenarios are:</p> <dl> <dt><strong><strong>Load and unload on a "when needed basis"</strong></strong></dt> <dd> <p>This (most common) scenario simply supports that each <code class="bold_code"><a href="#users">user</a></code> of the driver loads it when it is needed and unloads it when the <code class="bold_code"><a href="#users">user</a></code> no longer have any use for it. The driver is always reference counted and as long as a process keeping the driver loaded is still alive, the driver is present in the system.</p> <p>Each <code class="bold_code"><a href="#users">user</a></code> of the driver use <strong>literally</strong> the same pathname for the driver when demanding load, but the <code class="bold_code"><a href="#users">users</a></code> are not really concerned with if the driver is already loaded from the filesystem or if the object code has to be loaded from filesystem.</p> <p>Two pairs of functions support this scenario:</p> <dl> <dt><strong><strong>load/2 and unload/1</strong></strong></dt> <dd> <p>When using the <code class="code">load/unload</code> interfaces, the driver will not <strong>actually</strong> get unloaded until the <strong>last port</strong> using the driver is closed. The function <code class="code">unload/1</code> can return immediately, as the <code class="bold_code"><a href="#users">users</a></code> are not really concerned with when the actual unloading occurs. The driver will actually get unloaded when no one needs it any longer.</p> <p>If a process having the driver loaded dies, it will have the same effect as if unloading was done. </p> <p>When loading, the function <code class="code">load/2</code> returns <code class="code">ok</code> as soon as there is any instance of the driver present, so that if a driver is waiting to get unloaded (due to open ports), it will simply change state to no longer need unloading.</p> </dd> <dt><strong><strong>load_driver/2 and unload_driver/1</strong></strong></dt> <dd> <p>These interfaces is intended to be used when it is considered an error that ports are open towards a driver that no <code class="bold_code"><a href="#users">user</a></code> has loaded. The ports still open when the last <code class="bold_code"><a href="#users">user</a></code> calls <code class="code">unload_driver/1</code> or when the last process having the driver loaded dies, will get killed with reason <code class="code">driver_unloaded</code>.</p> <p>The function names <code class="code">load_driver</code> and <code class="code">unload_driver</code> are kept for backward compatibility.</p> </dd> </dl> </dd> <dt><strong><strong>Loading and reloading for code replacement</strong></strong></dt> <dd> <p>This scenario occurs when the driver code might need replacement during operation of the Erlang emulator. Implementing driver code replacement is somewhat more tedious than beam code replacement, as one driver cannot be loaded as both "old" and "new" code. All <code class="bold_code"><a href="#users">users</a></code> of a driver must have it closed (no open ports) before the old code can be unloaded and the new code can be loaded.</p> <p>The actual unloading/loading is done as one atomic operation, blocking all processes in the system from using the driver concerned while in progress.</p> <p>The preferred way to do driver code replacement is to let <strong>one single process</strong> keep track of the driver. When the process start, the driver is loaded. When replacement is required, the driver is reloaded. Unload is probably never done, or done when the process exits. If more than one <code class="bold_code"><a href="#users">user</a></code> has a driver loaded when code replacement is demanded, the replacement cannot occur until the last "other" <code class="bold_code"><a href="#users">user</a></code> has unloaded the driver.</p> <p>Demanding reload when a reload is already in progress is always an error. Using the high level functions, it is also an error to demand reloading when more than one <code class="bold_code"><a href="#users">user</a></code> has the driver loaded. To simplify driver replacement, avoid designing your system so that more than than one <code class="bold_code"><a href="#users">user</a></code> has the driver loaded.</p> <p>The two functions for reloading drivers should be used together with corresponding load functions, to support the two different behaviors concerning open ports:</p> <dl> <dt><strong><strong>load/2 and reload/2</strong></strong></dt> <dd> <p>This pair of functions is used when reloading should be done after the last open port towards the driver is closed.</p> <p>As <code class="code">reload/2</code> actually waits for the reloading to occur, a misbehaving process keeping open ports towards the driver (or keeping the driver loaded) might cause infinite waiting for reload. Timeouts has to be provided outside of the process demanding the reload or by using the low-level interface <code class="bold_code"><a href="#try_load-3">try_load/3</a></code> in combination with driver monitors (see below).</p> </dd> <dt><strong><strong>load_driver/2 and reload_driver/2</strong></strong></dt> <dd> <p>This pair of functions are used when open ports towards the driver should be killed with reason <code class="code">driver_unloaded</code> to allow for new driver code to get loaded.</p> <p>If, however, another process has the driver loaded, calling <code class="code">reload_driver</code> returns the error code <code class="code">pending_process</code>. As stated earlier, the recommended design is to not allow other <code class="bold_code"><a href="#users">users</a></code> than the "driver reloader" to actually demand loading of the concerned driver.</p> </dd> </dl> </dd> </dl>  <h2>Data types</h2> <h3 class="code">driver() = iolist() | atom()</h3> <h3 class="code">path() = string() | atom()</h3> <h2>Exports</h2> <h3 id="demonitor-1" class="code">demonitor(MonitorRef) -&gt; ok</h3> <p>Types:</p>   <pre>MonitorRef = reference()</pre>

<p>Removes a driver monitor in much the same way as <code class="bold_code">erlang:demonitor/1</code> does with process monitors. See <code class="bold_code"><a href="#monitor-2">monitor/2</a></code>, <code class="bold_code"><a href="#try_load-3">try_load/3</a></code> and <code class="bold_code"><a href="#try_unload-2">try_unload/2</a></code> for details about how to create driver monitors.</p> <p>The function throws a <code class="code">badarg</code> exception if the parameter is not a reference(). </p>  <h3 id="info-0" class="code">info() -&gt; AllInfoList</h3> <p>Types:</p>       <pre>AllInfoList = [DriverInfo]
DriverInfo = {DriverName, InfoList}
DriverName = string()
InfoList = [InfoItem]
InfoItem = {Tag :: atom(), Value :: term()}</pre>

<p>Returns a list of tuples <code class="code">{DriverName, InfoList}</code>, where <code class="code">InfoList</code> is the result of calling <code class="bold_code"><a href="#info-1">info/1</a></code> for that <code class="code">DriverName</code>. Only dynamically linked in drivers are included in the list.</p>  <h3 id="info-1" class="code">info(Name) -&gt; InfoList</h3> <p>Types:</p>     <pre>Name = <a href="#type-driver">driver()</a>
InfoList = [InfoItem, ...]
InfoItem = {Tag :: atom(), Value :: term()}</pre>

<p>Returns a list of tuples <code class="code">{Tag, Value}</code>, where <code class="code">Tag</code> is the information item and <code class="code">Value</code> is the result of calling <code class="bold_code"><a href="#info-2">info/2</a></code> with this driver name and this tag. The result being a tuple list containing all information available about a driver. </p> <p>The different tags that will appear in the list are:</p> <ul> <li>processes</li> <li>driver_options</li> <li>port_count</li> <li>linked_in_driver</li> <li>permanent</li> <li>awaiting_load</li> <li>awaiting_unload</li> </ul> <p>For a detailed description of each value, please read the description of <code class="bold_code"><a href="#info-2">info/2</a></code> below.</p> <p>The function throws a <code class="code">badarg</code> exception if the driver is not present in the system.</p>  <h3 id="info-2" class="code">info(Name, Tag) -&gt; Value</h3> <p>Types:</p>     <pre>Name = <a href="#type-driver">driver()</a>
Tag = 
    processes |
    driver_options |
    port_count |
    linked_in_driver |
    permanent |
    awaiting_load |
    awaiting_unload
Value = term()</pre>

<p>This function returns specific information about one aspect of a driver. The <code class="code">Tag</code> parameter specifies which aspect to get information about. The <code class="code">Value</code> return differs between different tags:</p> <dl> <dt><strong><strong>processes</strong></strong></dt> <dd> <p>Return all processes containing <code class="bold_code"><a href="#users">users</a></code> of the specific drivers as a list of tuples <code class="code">{pid(),integer() &gt;= 0}</code>, where the <code class="code">integer()</code> denotes the number of users in the process <code class="code">pid()</code>.</p> </dd> <dt><strong><strong>driver_options</strong></strong></dt> <dd> <p>Return a list of the driver options provided when loading, as well as any options set by the driver itself during initialization. The currently only valid option being <code class="code">kill_ports</code>.</p> </dd> <dt><strong><strong>port_count</strong></strong></dt> <dd> <p>Return the number of ports (an <code class="code">integer &gt;= 0()</code>) using the driver.</p> </dd> <dt><strong><strong>linked_in_driver</strong></strong></dt> <dd> <p>Return a <code class="code">boolean()</code>, being <code class="code">true</code> if the driver is a statically linked in one and <code class="code">false</code> otherwise.</p> </dd> <dt><strong><strong>permanent</strong></strong></dt> <dd> <p>Return a <code class="code">boolean()</code>, being <code class="code">true</code> if the driver has made itself permanent (and is <strong>not</strong> a statically linked in driver). <code class="code">false</code> otherwise.</p> </dd> <dt><strong><strong>awaiting_load</strong></strong></dt> <dd> <p>Return a list of all processes having monitors for <code class="code">loading</code> active, each process returned as <code class="code">{pid(),integer() &gt;= 0}</code>, where the <code class="code">integer()</code> is the number of monitors held by the process <code class="code">pid()</code>.</p> </dd> <dt><strong><strong>awaiting_unload</strong></strong></dt> <dd> <p>Return a list of all processes having monitors for <code class="code">unloading</code> active, each process returned as <code class="code">{pid(),integer() &gt;= 0}</code>, where the <code class="code">integer()</code> is the number of monitors held by the process <code class="code">pid()</code>.</p> </dd> </dl> <p>If the options <code class="code">linked_in_driver</code> or <code class="code">permanent</code> return true, all other options will return the value <code class="code">linked_in_driver</code> or <code class="code">permanent</code> respectively.</p> <p>The function throws a <code class="code">badarg</code> exception if the driver is not present in the system or the tag is not supported.</p>  <h3 id="load-2" class="code">load(Path, Name) -&gt; ok | {error, ErrorDesc}</h3> <p>Types:</p>     <pre>Path = <a href="#type-path">path()</a>
Name = <a href="#type-driver">driver()</a>
ErrorDesc = term()</pre>

<p>Loads and links the dynamic driver <code class="code">Name</code>. <code class="code">Path</code> is a file path to the directory containing the driver. <code class="code">Name</code> must be a sharable object/dynamic library. Two drivers with different <code class="code">Path</code> parameters cannot be loaded under the same name. The <code class="code">Name</code> is a string or atom containing at least one character.</p> <p>The <code class="code">Name</code> given should correspond to the filename of the actual dynamically loadable object file residing in the directory given as <code class="code">Path</code>, but <strong>without</strong> the extension (i.e. <code class="code">.so</code>). The driver name provided in the driver initialization routine must correspond with the filename, in much the same way as erlang module names correspond to the names of the <code class="code">.beam</code> files.</p> <p>If the driver has been previously unloaded, but is still present due to open ports against it, a call to <code class="code">load/2</code> will stop the unloading and keep the driver (as long as the <code class="code">Path</code> is the same) and <code class="code">ok</code> is returned. If one actually wants the object code to be reloaded, one uses <code class="bold_code"><a href="#reload-2">reload/2</a></code> or the low-level interface <code class="bold_code"><a href="#try_load-3">try_load/3</a></code> instead. Please refer to the description of <code class="bold_code"><a href="#scenarios">different scenarios</a></code> for loading/unloading in the introduction.</p> <p>If more than one process tries to load an already loaded driver withe the same <code class="code">Path</code>, or if the same process tries to load it several times, the function will return <code class="code">ok</code>. The emulator will keep track of the <code class="code">load/2</code> calls, so that a corresponding number of <code class="code">unload/2</code> calls will have to be done from the same process before the driver will actually get unloaded. It is therefore safe for an application to load a driver that is shared between processes or applications when needed. It can safely be unloaded without causing trouble for other parts of the system. </p> <p>It is not allowed to load several drivers with the same name but with different <code class="code">Path</code> parameters.</p> <div class="note"> <div class="label">Note</div> <div class="content">

<p>Note especially that the <code class="code">Path</code> is interpreted literally, so that all loaders of the same driver needs to give the same <strong>literal</strong><code class="code">Path</code> string, even though different paths might point out the same directory in the filesystem (due to use of relative paths and links).</p> </div> </div> <p>On success, the function returns <code class="code">ok</code>. On failure, the return value is <code class="code">{error,ErrorDesc}</code>, where <code class="code">ErrorDesc</code> is an opaque term to be translated into human readable form by the <code class="bold_code"><a href="#format_error-1">format_error/1</a></code> function.</p> <p>For more control over the error handling, again use the <code class="bold_code"><a href="#try_load-3">try_load/3</a></code> interface instead.</p> <p>The function throws a <code class="code">badarg</code> exception if the parameters are not given as described above. </p>  <h3 id="load_driver-2" class="code">load_driver(Path, Name) -&gt; ok | {error, ErrorDesc}</h3> <p>Types:</p>     <pre>Path = <a href="#type-path">path()</a>
Name = <a href="#type-driver">driver()</a>
ErrorDesc = term()</pre>

<p>Works essentially as <code class="code">load/2</code>, but will load the driver with other options. All ports that are using the driver will get killed with the reason <code class="code">driver_unloaded</code> when the driver is to be unloaded.</p> <p>The number of loads and unloads by different <code class="bold_code"><a href="#users">users</a></code> influence the actual loading and unloading of a driver file. The port killing will therefore only happen when the <strong>last</strong> <code class="bold_code"><a href="#users">user</a></code> unloads the driver, or the last process having loaded the driver exits.</p> <p>This interface (or at least the name of the functions) is kept for backward compatibility. Using <code class="bold_code"><a href="#try_load-3">try_load/3</a></code> with <code class="code">{driver_options,[kill_ports]}</code> in the option list will give the same effect regarding the port killing.</p> <p>The function throws a <code class="code">badarg</code> exception if the parameters are not given as described above. </p>  <h3 id="monitor-2" class="code">monitor(Tag, Item) -&gt; MonitorRef</h3> <p>Types:</p>       <pre>Tag = driver
Item = {Name, When}
Name = <a href="#type-driver">driver()</a>
When = loaded | unloaded | unloaded_only
MonitorRef = reference()</pre>

<p>This function creates a driver monitor and works in many ways as the function <code class="bold_code">erlang:monitor/2</code>, does for processes. When a driver changes state, the monitor results in a monitor-message being sent to the calling process. The <code class="code">MonitorRef</code> returned by this function is included in the message sent.</p> <p>As with process monitors, each driver monitor set will only generate <strong>one single message</strong>. The monitor is "destroyed" after the message is sent and there is then no need to call <code class="bold_code"><a href="#demonitor-1">demonitor/1</a></code>.</p> <p>The <code class="code">MonitorRef</code> can also be used in subsequent calls to <code class="bold_code"><a href="#demonitor-1">demonitor/1</a></code> to remove a monitor.</p> <p>The function accepts the following parameters:</p> <dl> <dt><strong><strong><code class="code">Tag</code></strong></strong></dt> <dd> <p>The monitor tag is always <code class="code">driver</code> as this function can only be used to create driver monitors. In the future, driver monitors will be integrated with process monitors, why this parameter has to be given for consistence.</p> </dd> <dt><strong><strong><code class="code">Item</code></strong></strong></dt> <dd> <p>The <code class="code">Item</code> parameter specifies which driver one wants to monitor (the name of the driver) as well as which state change one wants to monitor. The parameter is a tuple of arity two whose first element is the driver name and second element is either of:</p> <dl> <dt><strong><strong>loaded</strong></strong></dt> <dd> <p>Notify me when the driver is reloaded (or loaded if loading is underway). It only makes sense to monitor drivers that are in the process of being loaded or reloaded. One cannot monitor a future-to-be driver name for loading, that will only result in a <code class="code">'DOWN'</code> message being immediately sent. Monitoring for loading is therefore most useful when triggered by the <code class="bold_code"><a href="#try_load-3">try_load/3</a></code> function, where the monitor is created <strong>because</strong> the driver is in such a pending state.</p> <p>Setting a driver monitor for <code class="code">loading</code> will eventually lead to one of the following messages being sent:</p> <dl> <dt><strong><strong>{'UP', reference(), driver, Name, loaded}</strong></strong></dt> <dd> <p>This message is sent, either immediately if the driver is already loaded and no reloading is pending, or when reloading is executed if reloading is pending. </p> <p>The <code class="bold_code"><a href="#users">user</a></code> is expected to know if reloading is demanded prior to creating a monitor for loading.</p> </dd> <dt><strong><strong>{'UP', reference(), driver, Name, permanent}</strong></strong></dt> <dd> <p>This message will be sent if reloading was expected, but the (old) driver made itself permanent prior to reloading. It will also be sent if the driver was permanent or statically linked in when trying to create the monitor.</p> </dd> <dt><strong><strong>{'DOWN', reference(), driver, Name, load_cancelled}</strong></strong></dt> <dd> <p>This message will arrive if reloading was underway, but the <code class="bold_code"><a href="#users">user</a></code> having requested reload cancelled it by either dying or calling <code class="bold_code"><a href="#try_unload-2">try_unload/2</a></code> (or <code class="code">unload/1</code>/<code class="code">unload_driver/1</code>) again before it was reloaded.</p> </dd> <dt><strong><strong>{'DOWN', reference(), driver, Name, {load_failure, Failure}}</strong></strong></dt> <dd> <p>This message will arrive if reloading was underway but the loading for some reason failed. The <code class="code">Failure</code> term is one of the errors that can be returned from <code class="bold_code"><a href="#try_load-3">try_load/3</a></code>. The error term can be passed to <code class="bold_code"><a href="#format_error-1">format_error/1</a></code> for translation into human readable form. Note that the translation has to be done in the same running erlang virtual machine as the error was detected in.</p> </dd> </dl> </dd> <dt><strong><strong>unloaded</strong></strong></dt> <dd> <p>Monitor when a driver gets unloaded. If one monitors a driver that is not present in the system, one will immediately get notified that the driver got unloaded. There is no guarantee that the driver was actually ever loaded.</p> <p>A driver monitor for unload will eventually result in one of the following messages being sent:</p> <dl> <dt><strong><strong>{'DOWN', reference(), driver, Name, unloaded}</strong></strong></dt> <dd> <p>The driver instance monitored is now unloaded. As the unload might have been due to a <code class="code">reload/2</code> request, the driver might once again have been loaded when this message arrives.</p> </dd> <dt><strong><strong>{'UP', reference(), driver, Name, unload_cancelled}</strong></strong></dt> <dd> <p>This message will be sent if unloading was expected, but while the driver was waiting for all ports to get closed, a new <code class="bold_code"><a href="#users">user</a></code> of the driver appeared and the unloading was cancelled.</p> <p>This message appears when an <code class="code">{ok, pending_driver}</code>) was returned from <code class="bold_code"><a href="#try_unload-2">try_unload/2</a></code>) for the last <code class="bold_code"><a href="#users">user</a></code> of the driver and then a <code class="code">{ok, already_loaded}</code> is returned from a call to <code class="bold_code"><a href="#try_load-3">try_load/3</a></code>.</p> <p>If one wants to <strong>really</strong> monitor when the driver gets unloaded, this message will distort the picture, no unloading was really done. The <code class="code">unloaded_only</code> option creates a monitor similar to an <code class="code">unloaded</code> monitor, but does never result in this message.</p> </dd> <dt><strong><strong>{'UP', reference(), driver, Name, permanent}</strong></strong></dt> <dd> <p>This message will be sent if unloading was expected, but the driver made itself permanent prior to unloading. It will also be sent if trying to monitor a permanent or statically linked in driver.</p> </dd> </dl> </dd> <dt><strong><strong>unloaded_only</strong></strong></dt> <dd> <p>A monitor created as <code class="code">unloaded_only</code> behaves exactly as one created as <code class="code">unloaded</code> with the exception that the <code class="code">{'UP', reference(), driver, Name, unload_cancelled}</code> message will never be sent, but the monitor instead persists until the driver <strong>really</strong> gets unloaded.</p> </dd> </dl> </dd> </dl> <p>The function throws a <code class="code">badarg</code> exception if the parameters are not given as described above. </p>  <h3 id="reload-2" class="code">reload(Path, Name) -&gt; ok | {error, ErrorDesc}</h3> <p>Types:</p>      <pre>Path = <a href="#type-path">path()</a>
Name = <a href="#type-driver">driver()</a>
ErrorDesc = pending_process | OpaqueError
OpaqueError = term()</pre>

<p>Reloads the driver named <code class="code">Name</code> from a possibly different <code class="code">Path</code> than was previously used. This function is used in the code change <code class="bold_code"><a href="#scenarios">scenario</a></code> described in the introduction.</p> <p>If there are other <code class="bold_code"><a href="#users">users</a></code> of this driver, the function will return <code class="code">{error, pending_process}</code>, but if there are no more users, the function call will hang until all open ports are closed.</p> <div class="note"> <div class="label">Note</div> <div class="content">

<p>Avoid mixing several <code class="bold_code"><a href="#users">users</a></code> with driver reload requests.</p> </div> </div> <p>If one wants to avoid hanging on open ports, one should use the <code class="bold_code"><a href="#try_load-3">try_load/3</a></code> function instead.</p> <p>The <code class="code">Name</code> and <code class="code">Path</code> parameters have exactly the same meaning as when calling the plain <code class="bold_code"><a href="#load-2">load/2</a></code> function.</p> <div class="note"> <div class="label">Note</div> <div class="content">

<p>Avoid mixing several <code class="bold_code"><a href="#users">users</a></code> with driver reload requests.</p> </div> </div> <p>On success, the function returns <code class="code">ok</code>. On failure, the function returns an opaque error, with the exception of the <code class="code">pending_process</code> error described above. The opaque errors are to be translated into human readable form by the <code class="bold_code"><a href="#format_error-1">format_error/1</a></code> function.</p> <p>For more control over the error handling, again use the <code class="bold_code"><a href="#try_load-3">try_load/3</a></code> interface instead.</p> <p>The function throws a <code class="code">badarg</code> exception if the parameters are not given as described above. </p>  <h3 id="reload_driver-2" class="code">reload_driver(Path, Name) -&gt; ok | {error, ErrorDesc}</h3> <p>Types:</p>      <pre>Path = <a href="#type-path">path()</a>
Name = <a href="#type-driver">driver()</a>
ErrorDesc = pending_process | OpaqueError
OpaqueError = term()</pre>

<p>Works exactly as <code class="bold_code"><a href="#reload-2">reload/2</a></code>, but for drivers loaded with the <code class="bold_code"><a href="#load_driver-2">load_driver/2</a></code> interface. </p> <p>As this interface implies that ports are being killed when the last user disappears, the function wont hang waiting for ports to get closed.</p> <p>For further details, see the <code class="bold_code"><a href="#scenarios">scenarios</a></code> in the module description and refer to the <code class="bold_code"><a href="#reload-2">reload/2</a></code> function description.</p> <p>The function throws a <code class="code">badarg</code> exception if the parameters are not given as described above. </p>  <h3 id="try_load-3" class="code">try_load(Path, Name, OptionList) -&gt;<br>            {ok, Status} |<br>            {ok, PendingStatus, Ref} |<br>            {error, ErrorDesc}</h3> <p>Types:</p>                <pre>Path = <a href="#type-path">path()</a>
Name = <a href="#type-driver">driver()</a>
OptionList = [Option]
Option = 
    {driver_options, DriverOptionList} |
    {monitor, MonitorOption} |
    {reload, ReloadOption}
DriverOptionList = [DriverOption]
DriverOption = kill_ports
MonitorOption = ReloadOption = pending_driver | pending

Status = loaded | already_loaded | PendingStatus
PendingStatus = pending_driver | pending_process
Ref = reference()
ErrorDesc = ErrorAtom | OpaqueError
ErrorAtom = 
    linked_in_driver |
    inconsistent |
    permanent |
    not_loaded_by_this_process |
    not_loaded |
    pending_reload |
    pending_process
OpaqueError = term()</pre>

<p>This function provides more control than the <code class="code">load/2</code>/<code class="code">reload/2</code> and <code class="code">load_driver/2</code>/<code class="code">reload_driver/2</code> interfaces. It will never wait for completion of other operations related to the driver, but immediately return the status of the driver as either:</p> <dl> <dt><strong><strong>{ok, loaded}</strong></strong></dt> <dd> <p>The driver was actually loaded and is immediately usable.</p> </dd> <dt><strong><strong>{ok, already_loaded}</strong></strong></dt> <dd> <p>The driver was already loaded by another process and/or is in use by a living port. The load by you is registered and a corresponding <code class="code">try_unload</code> is expected sometime in the future.</p> </dd> <dt><strong><strong>{ok, pending_driver}</strong>or <strong>{ok, pending_driver, reference()}</strong></strong></dt> <dd> <p>The load request is registered, but the loading is delayed due to the fact that an earlier instance of the driver is still waiting to get unloaded (there are open ports using it). Still, unload is expected when you are done with the driver. This return value will <strong>mostly</strong> happen when the <code class="code">{reload,pending_driver}</code> or <code class="code">{reload,pending}</code> options are used, but <strong>can</strong> happen when another <code class="bold_code"><a href="#users">user</a></code> is unloading a driver in parallel and the <code class="code">kill_ports</code> driver option is set. In other words, this return value will always need to be handled!</p> </dd> <dt><strong><strong>{ok, pending_process}</strong>or <strong>{ok, pending_process, reference()}</strong></strong></dt> <dd> <p>The load request is registered, but the loading is delayed due to the fact that an earlier instance of the driver is still waiting to get unloaded by another <code class="bold_code"><a href="#users">user</a></code> (not only by a port, in which case <code class="code">{ok,pending_driver}</code> would have been returned). Still, unload is expected when you are done with the driver. This return value will <strong>only</strong> happen when the <code class="code">{reload,pending}</code> option is used.</p> </dd> </dl> <p>When the function returns <code class="code">{ok, pending_driver}</code> or <code class="code">{ok, pending_process}</code>, one might want to get information about when the driver is <strong>actually</strong> loaded. This can be achieved by using the <code class="code">{monitor, MonitorOption}</code> option.</p> <p>When monitoring is requested, and a corresponding <code class="code">{ok, pending_driver}</code> or <code class="code">{ok, pending_process}</code> would be returned, the function will instead return a tuple <code class="code">{ok, PendingStatus, reference()}</code> and the process will, at a later time when the driver actually gets loaded, get a monitor message. The monitor message one can expect is described in the <code class="bold_code"><a href="#monitor-2">monitor/2</a></code> function description. </p> <div class="note"> <div class="label">Note</div> <div class="content">

<p>Note that in case of loading, monitoring can <strong>not</strong> only get triggered by using the <code class="code">{reload, ReloadOption}</code> option, but also in special cases where the load-error is transient, why <code class="code">{monitor, pending_driver}</code> should be used under basically <strong>all</strong> real world circumstances!</p> </div> </div> <p>The function accepts the following parameters:</p> <dl> <dt><strong><strong><code class="code">Path</code></strong></strong></dt> <dd> <p>The filesystem path to the directory where the driver object file is situated. The filename of the object file (minus extension) must correspond to the driver name (used in the name parameter) and the driver must identify itself with the very same name. The <code class="code">Path</code> might be provided as an <strong>iolist()</strong>, meaning it can be a list of other <code class="code">iolist()</code>s, characters (eight bit integers) or binaries, all to be flattened into a sequence of characters.</p> <p>The (possibly flattened) <code class="code">Path</code> parameter must be consistent throughout the system, a driver should, by all <code class="bold_code"><a href="#users">users</a></code>, be loaded using the same <strong>literal</strong><code class="code">Path</code>. The exception is when <strong>reloading</strong> is requested, in which case the <code class="code">Path</code> may be specified differently. Note that all <code class="bold_code"><a href="#users">users</a></code> trying to load the driver at a later time will need to use the <strong>new</strong><code class="code">Path</code> if the <code class="code">Path</code> is changed using a <code class="code">reload</code> option. This is yet another reason to have <strong>only one loader</strong> of a driver one wants to upgrade in a running system! </p> </dd> <dt><strong><strong><code class="code">Name</code></strong></strong></dt> <dd> <p>The name parameter is the name of the driver to be used in subsequent calls to <code class="bold_code">open_port</code>. The name can be specified either as an <code class="code">iolist()</code> or as an <code class="code">atom()</code>. The name given when loading is used to find the actual object file (with the help of the <code class="code">Path</code> and the system implied extension suffix, i.e. <code class="code">.so</code>). The name by which the driver identifies itself must also be consistent with this <code class="code">Name</code> parameter, much as a beam-file's module name much correspond to its filename.</p> </dd> <dt><strong><strong><code class="code">OptionList</code></strong></strong></dt> <dd> <p>A number of options can be specified to control the loading operation. The options are given as a list of two-tuples, the tuples having the following values and meanings:</p> <dl> <dt><strong><strong>{driver_options, <code class="code">DriverOptionList</code>}</strong></strong></dt> <dd> <p>This option is to provide options that will change its general behavior and will "stick" to the driver throughout its lifespan.</p> <p>The driver options for a given driver name need always to be consistent, <strong>even when the driver is reloaded</strong>, meaning that they are as much a part of the driver as the actual name.</p> <p>Currently the only allowed driver option is <code class="code">kill_ports</code>, which means that all ports opened towards the driver are killed with the exit-reason <code class="code">driver_unloaded</code> when no process any longer has the driver loaded. This situation arises either when the last <code class="bold_code"><a href="#users">user</a></code> calls <code class="bold_code"><a href="#try_unload-2">try_unload/2</a></code>, or the last process having loaded the driver exits.</p> </dd> <dt><strong><strong>{monitor, <code class="code">MonitorOption</code>}</strong></strong></dt> <dd> <p>A <code class="code">MonitorOption</code> tells <code class="code">try_load/3</code> to trigger a driver monitor under certain conditions. When the monitor is triggered, the function will return a three-tuple <code class="code">{ok, PendingStatus, reference()}</code>, where the <code class="code">reference()</code> is the monitor ref for the driver monitor.</p> <p>Only one <code class="code">MonitorOption</code> can be specified and it is either the atom <code class="code">pending</code>, which means that a monitor should be created whenever a load operation is delayed, and the atom <code class="code">pending_driver</code>, in which a monitor is created whenever the operation is delayed due to open ports towards an otherwise unused driver. The <code class="code">pending_driver</code> option is of little use, but is present for completeness, it is very well defined which reload-options might give rise to which delays. It might, however, be a good idea to use the same <code class="code">MonitorOption</code> as the <code class="code">ReloadOption</code> if present.</p> <p>If reloading is not requested, it might still be useful to specify the <code class="code">monitor</code> option, as forced unloads (<code class="code">kill_ports</code> driver option or the <code class="code">kill_ports</code> option to <code class="bold_code"><a href="#try_unload-2">try_unload/2</a></code>) will trigger a transient state where driver loading cannot be performed until all closing ports are actually closed. So, as <code class="code">try_unload</code> can, in almost all situations, return <code class="code">{ok, pending_driver}</code>, one should always specify at least <code class="code">{monitor, pending_driver}</code> in production code (see the monitor discussion above). </p> </dd> <dt><strong><strong>{reload, <code class="code">ReloadOption</code>}</strong></strong></dt> <dd> <p>This option is used when one wants to <strong>reload</strong> a driver from disk, most often in a code upgrade scenario. Having a <code class="code">reload</code> option also implies that the <code class="code">Path</code> parameter need <strong>not</strong> be consistent with earlier loads of the driver.</p> <p>To reload a driver, the process needs to have previously loaded the driver, i.e there has to be an active <code class="bold_code"><a href="#users">user</a></code> of the driver in the process. </p> <p>The <code class="code">reload</code> option can be either the atom <code class="code">pending</code>, in which reloading is requested for any driver and will be effectuated when <strong>all</strong> ports opened against the driver are closed. The replacement of the driver will in this case take place regardless of if there are still pending <code class="bold_code"><a href="#users">users</a></code> having the driver loaded! The option also triggers port-killing (if the <code class="code">kill_ports</code> driver option is used) even though there are pending users, making it usable for forced driver replacement, but laying a lot of responsibility on the driver <code class="bold_code"><a href="#users">users</a></code>. The pending option is seldom used as one does not want other <code class="bold_code"><a href="#users">users</a></code> to have loaded the driver when code change is underway. </p> <p>The more useful option is <code class="code">pending_driver</code>, which means that reloading will be queued if the driver is <strong>not</strong> loaded by any other <code class="bold_code"><a href="#users">users</a></code>, but the driver has opened ports, in which case <code class="code">{ok, pending_driver}</code> will be returned (a <code class="code">monitor</code> option is of course recommended).</p> <p>If the driver is unloaded (not present in the system), the error code <code class="code">not_loaded</code> will be returned. The <code class="code">reload</code> option is intended for when the user has already loaded the driver in advance.</p> </dd> </dl> </dd> </dl> <p>The function might return numerous errors, of which some only can be returned given a certain combination of options.</p> <p>A number of errors are opaque and can only be interpreted by passing them to the <code class="bold_code"><a href="#format_error-1">format_error/1</a></code> function, but some can be interpreted directly:</p> <dl> <dt><strong><strong>{error,linked_in_driver}</strong></strong></dt> <dd> <p>The driver with the specified name is an erlang statically linked in driver, which cannot be manipulated with this API.</p> </dd> <dt><strong><strong>{error,inconsistent}</strong></strong></dt> <dd> <p>The driver has already been loaded with either other <code class="code">DriverOptionList</code> or a different <strong>literal</strong><code class="code">Path</code> argument.</p> <p>This can happen even if a <code class="code">reload</code> option is given, if the <code class="code">DriverOptionList</code> differ from the current.</p> </dd> <dt><strong><strong>{error, permanent}</strong></strong></dt> <dd> <p>The driver has requested itself to be permanent, making it behave like an erlang linked in driver and it can no longer be manipulated with this API.</p> </dd> <dt><strong><strong>{error, pending_process}</strong></strong></dt> <dd> <p>The driver is loaded by other <code class="bold_code"><a href="#users">users</a></code> when the <code class="code">{reload, pending_driver}</code> option was given.</p> </dd> <dt><strong><strong>{error, pending_reload}</strong></strong></dt> <dd> <p>Driver reload is already requested by another <code class="bold_code"><a href="#users">user</a></code> when the <code class="code">{reload, ReloadOption}</code> option was given.</p> </dd> <dt><strong><strong>{error, not_loaded_by_this_process}</strong></strong></dt> <dd> <p>Appears when the <code class="code">reload</code> option is given. The driver <code class="code">Name</code> is present in the system, but there is no <code class="bold_code"><a href="#users">user</a></code> of it in this process.</p> </dd> <dt><strong><strong>{error, not_loaded}</strong></strong></dt> <dd> <p>Appears when the <code class="code">reload</code> option is given. The driver <code class="code">Name</code> is not in the system. Only drivers loaded by this process can be reloaded.</p> </dd> </dl> <p>All other error codes are to be translated by the <code class="bold_code"><a href="#format_error-1">format_error/1</a></code> function. Note that calls to <code class="code">format_error</code> should be performed from the same running instance of the erlang virtual machine as the error was detected in, due to system dependent behavior concerning error values.</p> <p>If the arguments or options are malformed, the function will throw a <code class="code">badarg</code> exception.</p>  <h3 id="try_unload-2" class="code">try_unload(Name, OptionList) -&gt;<br>              {ok, Status} |<br>              {ok, PendingStatus, Ref} |<br>              {error, ErrorAtom}</h3> <p>Types:</p>          <pre>Name = <a href="#type-driver">driver()</a>
OptionList = [Option]
Option = {monitor, MonitorOption} | kill_ports
MonitorOption = pending_driver | pending
Status = unloaded | PendingStatus
PendingStatus = pending_driver | pending_process
Ref = reference()
ErrorAtom = 
    linked_in_driver |
    not_loaded |
    not_loaded_by_this_process |
    permanent</pre>

<p>This is the low level function to unload (or decrement reference counts of) a driver. It can be used to force port killing, in much the same way as the driver option <code class="code">kill_ports</code> implicitly does, and it can trigger a monitor either due to other <code class="bold_code"><a href="#users">users</a></code> still having the driver loaded or that there are open ports using the driver.</p> <p>Unloading can be described as the process of telling the emulator that this particular part of the code in this particular process (i.e. this <code class="bold_code"><a href="#users">user</a></code>) no longer needs the driver. That can, if there are no other users, trigger actual unloading of the driver, in which case the driver name disappears from the system and (if possible) the memory occupied by the driver executable code is reclaimed. If the driver has the <code class="code">kill_ports</code> option set, or if <code class="code">kill_ports</code> was specified as an option to this function, all pending ports using this driver will get killed when unloading is done by the last <code class="bold_code"><a href="#users">user</a></code>. If no port-killing is involved and there are open ports, the actual unloading is delayed until there are no more open ports using the driver. If, in this case, another <code class="bold_code"><a href="#users">user</a></code> (or even this user) loads the driver again before the driver is actually unloaded, the unloading will never take place.</p> <p>To allow the <code class="bold_code"><a href="#users">user</a></code> that <strong>requests unloading</strong> to wait for <strong>actual unloading</strong> to take place, <code class="code">monitor</code> triggers can be specified in much the same way as when loading. As <code class="bold_code"><a href="#users">users</a></code> of this function however seldom are interested in more than decrementing the reference counts, monitoring is more seldom needed. If the <code class="code">kill_ports</code> option is used however, monitor trigging is crucial, as the ports are not guaranteed to have been killed until the driver is unloaded, why a monitor should be triggered for at least the <code class="code">pending_driver</code> case.</p> <p>The possible monitor messages that can be expected are the same as when using the <code class="code">unloaded</code> option to the <code class="bold_code"><a href="#monitor-2">monitor/2</a></code> function.</p> <p>The function will return one of the following statuses upon success:</p> <dl> <dt><strong><strong>{ok, unloaded}</strong></strong></dt> <dd> <p>The driver was immediately unloaded, meaning that the driver name is now free to use by other drivers and, if the underlying OS permits it, the memory occupied by the driver object code is now reclaimed.</p> <p>The driver can only be unloaded when there are no open ports using it and there are no more <code class="bold_code"><a href="#users">users</a></code> requiring it to be loaded.</p> </dd> <dt><strong><strong>{ok, pending_driver}</strong>or <strong>{ok, pending_driver, reference()}</strong></strong></dt> <dd> <p>This return value indicates that this call removed the last <code class="bold_code"><a href="#users">user</a></code> from the driver, but there are still open ports using it. When all ports are closed and no new <code class="bold_code"><a href="#users">users</a></code> have arrived, the driver will actually be reloaded and the name and memory reclaimed.</p> <p>This return value is valid even when the option <code class="code">kill_ports</code> was used, as killing ports may not be a process that completes immediately. The condition is, in that case, however transient. Monitors are as always useful to detect when the driver is really unloaded.</p> </dd> <dt><strong><strong>{ok, pending_process}</strong>or <strong>{ok, pending_process, reference()}</strong></strong></dt> <dd> <p>The unload request is registered, but there are still other <code class="bold_code"><a href="#users">users</a></code> holding the driver. Note that the term <code class="code">pending_process</code> might refer to the running process, there might be more than one <code class="bold_code"><a href="#users">user</a></code> in the same process.</p> <p>This is a normal, healthy return value if the call was just placed to inform the emulator that you have no further use of the driver. It is actually the most common return value in the most common <code class="bold_code"><a href="#scenarios">scenario</a></code> described in the introduction.</p> </dd> </dl> <p>The function accepts the following parameters:</p> <dl> <dt><strong><strong><code class="code">Name</code></strong></strong></dt> <dd> <p>The name parameter is the name of the driver to be unloaded. The name can be specified either as an <code class="code">iolist()</code> or as an <code class="code">atom()</code>. </p> </dd> <dt><strong><strong><code class="code">OptionList</code></strong></strong></dt> <dd> <p>The <code class="code">OptionList</code> argument can be used to specify certain behavior regarding ports as well as triggering monitors under certain conditions:</p> <dl> <dt><strong><strong>kill_ports</strong></strong></dt> <dd> <p>Force killing of all ports opened using this driver, with the exit reason <code class="code">driver_unloaded</code>, if you are the <strong>last</strong><code class="bold_code"><a href="#users">user</a></code> of the driver.</p> <p>If there are other <code class="bold_code"><a href="#users">users</a></code> having the driver loaded, this option will have no effect.</p> <p>If one wants the consistent behavior of killing ports when the last <code class="bold_code"><a href="#users">user</a></code> unloads, one should use the driver option <code class="code">kill_ports</code> when loading the driver instead.</p> </dd> <dt><strong><strong>{monitor, <code class="code">MonitorOption</code>}</strong></strong></dt> <dd> <p>This option creates a driver monitor if the condition given in <code class="code">MonitorOption</code> is true. The valid options are:</p> <dl> <dt><strong><strong>pending_driver</strong></strong></dt> <dd> <p>Create a driver monitor if the return value is to be <code class="code">{ok, pending_driver}</code>.</p> </dd> <dt><strong><strong>pending</strong></strong></dt> <dd> <p>Create a monitor if the return value will be either <code class="code">{ok, pending_driver}</code> or <code class="code">{ok, pending_process}</code>.</p> </dd> </dl> <p>The <code class="code">pending_driver</code> <code class="code">MonitorOption</code> is by far the most useful and it has to be used to ensure that the driver has really been unloaded and the ports closed whenever the <code class="code">kill_ports</code> option is used or the driver may have been loaded with the <code class="code">kill_ports</code> driver option.</p> <p>By using the monitor-triggers in the call to <code class="code">try_unload</code> one can be sure that the monitor is actually added before the unloading is executed, meaning that the monitor will always get properly triggered, which would not be the case if one called <code class="code">erl_ddll:monitor/2</code> separately.</p> </dd> </dl> </dd> </dl> <p>The function may return several error conditions, of which all are well specified (no opaque values):</p> <dl> <dt><strong><strong>{error, linked_in_driver}</strong></strong></dt> <dd> <p>You were trying to unload an erlang statically linked in driver, which cannot be manipulated with this interface (and cannot be unloaded at all).</p> </dd> <dt><strong><strong>{error, not_loaded}</strong></strong></dt> <dd> <p>The driver <code class="code">Name</code> is not present in the system.</p> </dd> <dt><strong><strong>{error, not_loaded_by_this_process}</strong></strong></dt> <dd> <p>The driver <code class="code">Name</code> is present in the system, but there is no <code class="bold_code"><a href="#users">user</a></code> of it in this process. </p> <p>As a special case, drivers can be unloaded from processes that has done no corresponding call to <code class="code">try_load/3</code> if, and only if, there are <strong>no users of the driver at all</strong>, which may happen if the process containing the last user dies.</p> </dd> <dt><strong><strong>{error, permanent}</strong></strong></dt> <dd> <p>The driver has made itself permanent, in which case it can no longer be manipulated by this interface (much like a statically linked in driver).</p> </dd> </dl> <p>The function throws a <code class="code">badarg</code> exception if the parameters are not given as described above. </p>  <h3 id="unload-1" class="code">unload(Name) -&gt; ok | {error, ErrorDesc}</h3> <p>Types:</p>    <pre>Name = <a href="#type-driver">driver()</a>
ErrorDesc = term()</pre>

<p>Unloads, or at least dereferences the driver named <code class="code">Name</code>. If the caller is the last <code class="bold_code"><a href="#users">user</a></code> of the driver, and there are no more open ports using the driver, the driver will actually get unloaded. In all other cases, actual unloading will be delayed until all ports are closed and there are no remaining <code class="bold_code"><a href="#users">users</a></code>.</p> <p>If there are other <code class="bold_code"><a href="#users">users</a></code> of the driver, the reference counts of the driver is merely decreased, so that the caller is no longer considered a user of the driver. For usage scenarios, see the <code class="bold_code"><a href="#scenarios">description</a></code> in the beginning of this document. </p> <p>The <code class="code">ErrorDesc</code> returned is an opaque value to be passed further on to the <code class="bold_code"><a href="#format_error-1">format_error/1</a></code> function. For more control over the operation, use the <code class="bold_code"><a href="#try_unload-2">try_unload/2</a></code> interface.</p> <p>The function throws a <code class="code">badarg</code> exception if the parameters are not given as described above. </p>  <h3 id="unload_driver-1" class="code">unload_driver(Name) -&gt; ok | {error, ErrorDesc}</h3> <p>Types:</p>    <pre>Name = <a href="#type-driver">driver()</a>
ErrorDesc = term()</pre>

<p>Unloads, or at least dereferences the driver named <code class="code">Name</code>. If the caller is the last <code class="bold_code"><a href="#users">user</a></code> of the driver, all remaining open ports using the driver will get killed with the reason <code class="code">driver_unloaded</code> and the driver will eventually get unloaded.</p> <p>If there are other <code class="bold_code"><a href="#users">users</a></code> of the driver, the reference counts of the driver is merely decreased, so that the caller is no longer considered a <code class="bold_code"><a href="#users">user</a></code>. For usage scenarios, see the <code class="bold_code"><a href="#scenarios">description</a></code> in the beginning of this document.</p> <p>The <code class="code">ErrorDesc</code> returned is an opaque value to be passed further on to the <code class="bold_code"><a href="#format_error-1">format_error/1</a></code> function. For more control over the operation, use the <code class="bold_code"><a href="#try_unload-2">try_unload/2</a></code> interface.</p> <p>The function throws a <code class="code">badarg</code> exception if the parameters are not given as described above. </p>  <h3 id="loaded_drivers-0" class="code">loaded_drivers() -&gt; {ok, Drivers}</h3> <p>Types:</p>    <pre>Drivers = [Driver]
Driver = string()</pre>

<p>Returns a list of all the available drivers, both (statically) linked-in and dynamically loaded ones.</p> <p>The driver names are returned as a list of strings rather than a list of atoms for historical reasons.</p> <p>More information about drivers can be obtained using one of the <code class="bold_code"><a href="#info-0">info</a></code> functions.</p>  <h3 id="format_error-1" class="code">format_error(ErrorDesc) -&gt; string()</h3> <p>Types:</p>   <pre>ErrorDesc = term()</pre>

<p>Takes an <code class="code">ErrorDesc</code> returned by load, unload or reload functions and returns a string which describes the error or warning.</p> <div class="note"> <div class="label">Note</div> <div class="content">

<p>Due to peculiarities in the dynamic loading interfaces on different platform, the returned string is only guaranteed to describe the correct error <strong>if format_error/1 is called in the same instance of the erlang virtual machine as the error appeared in</strong> (meaning the same operating system process)!</p> </div> </div>  <h2 id="id114340">See also</h2>  <p>erl_driver(4), driver_entry(4)</p>
<div class="_attribution">
  <p class="_attribution-p">
    © 1999–2016 Ericsson AB<br>Licensed under the Apache License, Version 2.0.<br>
    
  </p>
</div>

			</div>
		</div>
	</section>

	</div>
</body>
</html>
