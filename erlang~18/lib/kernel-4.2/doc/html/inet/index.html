
<!DOCTYPE HTML>

<html lang="en">

<head>
  <meta charset="utf-8">
  <title>Inet - Erlang 18 - W3cubDocs</title>
  
  <meta name="description" content=" inet ">
  <meta name="keywords" content="inet, -, erlang, erlang~18">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="http://docs.w3cub.com/erlang~18/lib/kernel-4.2/doc/html/inet/">
  <link href="/favicon.png" rel="icon">
  <link type="text/css" rel="stylesheet" href="/assets/application-50364fff564ce3b6327021805f3f00e2957b441cf27f576a7dd4ff63bbc47047.css">
  <script type="text/javascript" src="/assets/application-db64bfd54ceb42be11af7995804cf4902548419ceb79d509b0b7d62c22d98e6f.js"></script>
  <script src="/json/erlang~18.js"></script>
  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-71174418-1']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>


</head>

<body>
	<div class="_app">
	<header class="_header">
  
  <form class="_search">
    <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
    <a class="_search-clear"></a>
    <div class="_search-tag"></div>
  </form>
  
  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/erlang~18/" class="_nav-link" title="" style="margin-left:0;">Erlang 18</a></span>
  
  <nav class="_nav">
    <a href="/app/" class="_nav-link ">App</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		<div class="_list">
			
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<div class="_page _erlang">
				
<h1>inet</h1> <h2>Module</h2> <p class="REFBODY">inet</p> <h2>Module summary</h2> <p class="REFBODY">Access to TCP/IP Protocols</p> <h2>Description</h2> 
<p>Provides access to TCP/IP protocols.</p> <p>See also <strong>ERTS User's Guide, Inet configuration</strong> for more information on how to configure an Erlang runtime system for IP communication.</p> <p>Two Kernel configuration parameters affect the behaviour of all sockets opened on an Erlang node: <code class="code">inet_default_connect_options</code> can contain a list of default options used for all sockets returned when doing <code class="code">connect</code>, and <code class="code">inet_default_listen_options</code> can contain a list of default options used when issuing a <code class="code">listen</code> call. When <code class="code">accept</code> is issued, the values of the listensocket options are inherited, why no such application variable is needed for <code class="code">accept</code>.</p> <p>Using the Kernel configuration parameters mentioned above, one can set default options for all TCP sockets on a node. This should be used with care, but options like <code class="code">{delay_send,true}</code> might be specified in this way. An example of starting an Erlang node with all sockets using delayed send could look like this:</p> <div class="example"><pre>
$ erl -sname test -kernel \
inet_default_connect_options '[{delay_send,true}]' \
inet_default_listen_options '[{delay_send,true}]'</pre></div> <p>Note that the default option <code class="code">{active, true}</code> currently cannot be changed, for internal reasons.</p> <p>Addresses as inputs to functions can be either a string or a tuple. For instance, the IP address 150.236.20.73 can be passed to <code class="code">gethostbyaddr/1</code> either as the string "150.236.20.73" or as the tuple <code class="code">{150, 236, 20, 73}</code>.</p> <p>IPv4 address examples:</p> <div class="example"><pre>
Address          ip_address()
-------          ------------
127.0.0.1        {127,0,0,1}
192.168.42.2     {192,168,42,2}</pre></div> <p>IPv6 address examples:</p> <div class="example"><pre>
Address          ip_address()
-------          ------------
::1             {0,0,0,0,0,0,0,1}
::192.168.42.2  {0,0,0,0,0,0,(192 bsl 8) bor 168,(42 bsl 8) bor 2}
FFFF::192.168.42.2
                {16#FFFF,0,0,0,0,0,(192 bsl 8) bor 168,(42 bsl 8) bor 2}
3ffe:b80:1f8d:2:204:acff:fe17:bf38
                {16#3ffe,16#b80,16#1f8d,16#2,16#204,16#acff,16#fe17,16#bf38}
fe80::204:acff:fe17:bf38
                {16#fe80,0,0,0,0,16#204,16#acff,16#fe17,16#bf38}</pre></div> <p>A function that may be useful is <code class="bold_code"><a href="#parse_address-1">parse_address/1</a></code>:</p> <div class="example"><pre>
1&gt; inet:parse_address("192.168.42.2").
{ok,{192,168,42,2}}
2&gt; inet:parse_address("FFFF::192.168.42.2").
{ok,{65535,0,0,0,0,0,49320,10754}}</pre></div>  <h2>Data types</h2> <h3 class="code">hostent() = <br>    #hostent{h_name = undefined | <a href="../inet/#type-hostname">inet:hostname()</a>,<br>             h_aliases = [<a href="../inet/#type-hostname">inet:hostname()</a>],<br>             h_addrtype = undefined | inet | inet6,<br>             h_length = undefined | integer() &gt;= 0,<br>             h_addr_list = [<a href="../inet/#type-ip_address">inet:ip_address()</a>]}</h3> 
<p>The record is defined in the Kernel include file "inet.hrl". Add the following directive to the module:</p> <div class="example"><pre>-include_lib("kernel/include/inet.hrl").</pre></div> <h3 class="code">hostname() = atom() | string()</h3> <h3 class="code">ip_address() = <a href="#type-ip4_address">ip4_address()</a> | <a href="#type-ip6_address">ip6_address()</a>
</h3> <h3 class="code">ip4_address() = {0..255, 0..255, 0..255, 0..255}</h3> <h3 class="code">ip6_address() = <br>    {0..65535,<br>     0..65535,<br>     0..65535,<br>     0..65535,<br>     0..65535,<br>     0..65535,<br>     0..65535,<br>     0..65535}</h3> <h3 class="code">port_number() = 0..65535</h3> <h3 class="code">posix() = exbadport | exbadseq | <a href="../file/#type-posix">file:posix()</a>
</h3> 
<p>An atom which is named from the Posix error codes used in Unix, and in the runtime libraries of most C compilers. See <code class="bold_code"><a href="#error_codes">POSIX Error Codes</a></code>.</p>  <p><code class="bold_code">socket()</code></p> 
<p id="type-socket"> See <code class="bold_code"><a href="../gen_tcp/#type-socket">gen_tcp(3)</a></code> and <code class="bold_code"><a href="../gen_udp/#type-socket">gen_udp(3)</a></code>.</p>  <h3 class="code">address_family() = inet | inet6</h3> <h2>Exports</h2> <h3 id="close-1" class="code">close(Socket) -&gt; ok</h3> <p>Types:</p>   <pre>Socket = <a href="#type-socket">socket()</a></pre>

<p>Closes a socket of any type.</p>  <h3 id="get_rc-0" class="code">get_rc() -&gt; [{Par :: any(), Val :: any()}]</h3> 
<p>Returns the state of the Inet configuration database in form of a list of recorded configuration parameters. (See the ERTS User's Guide, Inet configuration, for more information). Only parameters with other than default values are returned.</p>  <h3 id="format_error-1" class="code">format_error(Reason) -&gt; string()</h3> <p>Types:</p>   <pre>Reason = <a href="#type-posix">posix()</a> | system_limit</pre>

<p>Returns a diagnostic error string. See the section below for possible Posix values and the corresponding strings.</p>  <h3 id="getaddr-2" class="code">getaddr(Host, Family) -&gt; {ok, Address} | {error, <a href="#type-posix">posix()</a>}</h3> <p>Types:</p>     <pre>Host = <a href="#type-ip_address">ip_address()</a> | <a href="#type-hostname">hostname()</a>
Family = <a href="#type-address_family">address_family()</a>
Address = <a href="#type-ip_address">ip_address()</a></pre>

<p>Returns the IP-address for <code class="code">Host</code> as a tuple of integers. <code class="code">Host</code> can be an IP-address, a single hostname or a fully qualified hostname.</p>  <h3 id="getaddrs-2" class="code">getaddrs(Host, Family) -&gt; {ok, Addresses} | {error, <a href="#type-posix">posix()</a>}</h3> <p>Types:</p>     <pre>Host = <a href="#type-ip_address">ip_address()</a> | <a href="#type-hostname">hostname()</a>
Family = <a href="#type-address_family">address_family()</a>
Addresses = [<a href="#type-ip_address">ip_address()</a>]</pre>

<p>Returns a list of all IP-addresses for <code class="code">Host</code>. <code class="code">Host</code> can be an IP-address, a single hostname or a fully qualified hostname.</p>  <h3 id="gethostbyaddr-1" class="code">gethostbyaddr(Address) -&gt; {ok, Hostent} | {error, <a href="#type-posix">posix()</a>}</h3> <p>Types:</p>    <pre>Address = string() | <a href="#type-ip_address">ip_address()</a>
Hostent = <a href="#type-hostent">hostent()</a></pre>

<p>Returns a <code class="code">hostent</code> record given an address.</p>  <h3 id="gethostbyname-1" class="code">gethostbyname(Hostname) -&gt; {ok, Hostent} | {error, <a href="#type-posix">posix()</a>}</h3> <p>Types:</p>    <pre>Hostname = <a href="#type-hostname">hostname()</a>
Hostent = <a href="#type-hostent">hostent()</a></pre>

<p>Returns a <code class="code">hostent</code> record given a hostname.</p>  <h3 id="gethostbyname-2" class="code">gethostbyname(Hostname, Family) -&gt;<br>                 {ok, Hostent} | {error, <a href="#type-posix">posix()</a>}</h3> <p>Types:</p>     <pre>Hostname = <a href="#type-hostname">hostname()</a>
Family = <a href="#type-address_family">address_family()</a>
Hostent = <a href="#type-hostent">hostent()</a></pre>

<p>Returns a <code class="code">hostent</code> record given a hostname, restricted to the given address family.</p>  <h3 id="gethostname-0" class="code">gethostname() -&gt; {ok, Hostname}</h3> <p>Types:</p>   <pre>Hostname = string()</pre>

<p>Returns the local hostname. Will never fail.</p>  <h3 id="getifaddrs-0" class="code">getifaddrs() -&gt; {ok, Iflist} | {error, <a href="#type-posix">posix()</a>}</h3> <p>Types:</p>           <pre>Iflist = [{Ifname, [Ifopt]}]
Ifname = string()
Ifopt = 
    {flags, [Flag]} |
    {addr, Addr} |
    {netmask, Netmask} |
    {broadaddr, Broadaddr} |
    {dstaddr, Dstaddr} |
    {hwaddr, Hwaddr}
Flag = 
    up | broadcast | loopback | pointtopoint | running | multicast
Addr = Netmask = Broadaddr = Dstaddr = <a href="#type-ip_address">ip_address()</a>



Hwaddr = [byte()]</pre>

<p> Returns a list of 2-tuples containing interface names and the interface's addresses. <code class="code">Ifname</code> is a Unicode string. <code class="code">Hwaddr</code> is hardware dependent, e.g on Ethernet interfaces it is the 6-byte Ethernet address (MAC address (EUI-48 address)). </p> <p> The <code class="code">{addr,Addr}</code>, <code class="code">{netmask,_}</code> and <code class="code">{broadaddr,_}</code> tuples are repeated in the result list iff the interface has multiple addresses. If you come across an interface that has multiple <code class="code">{flag,_}</code> or <code class="code">{hwaddr,_}</code> tuples you have a really strange interface or possibly a bug in this function. The <code class="code">{flag,_}</code> tuple is mandatory, all other optional. </p> <p> Do not rely too much on the order of <code class="code">Flag</code> atoms or <code class="code">Ifopt</code> tuples. There are some rules, though:</p> <ul> <li> Immediately after <code class="code">{addr,_}</code> follows <code class="code">{netmask,_}</code> </li> <li> Immediately thereafter follows <code class="code">{broadaddr,_}</code> if the <code class="code">broadcast</code> flag is <strong>not</strong> set and the <code class="code">pointtopoint</code> flag <strong>is</strong> set. </li> <li> Any <code class="code">{netmask,_}</code>, <code class="code">{broadaddr,_}</code> or <code class="code">{dstaddr,_}</code> tuples that follow an <code class="code">{addr,_}</code> tuple concerns that address. </li> </ul> <p> The <code class="code">{hwaddr,_}</code> tuple is not returned on Solaris since the hardware address historically belongs to the link layer and only the superuser can read such addresses. </p> <p> On Windows, the data is fetched from quite different OS API functions, so the <code class="code">Netmask</code> and <code class="code">Broadaddr</code> values may be calculated, just as some <code class="code">Flag</code> values. You have been warned. Report flagrant bugs. </p>  <h3 id="getopts-2" class="code">getopts(Socket, Options) -&gt; {ok, OptionValues} | {error, <a href="#type-posix">posix()</a>}</h3> <p>Types:</p>       <pre>Socket = <a href="#type-socket">socket()</a>
Options = [socket_getopt()]
OptionValues = [socket_setopt()]
socket_getopt() = 
    <a href="../gen_sctp/#type-option_name">gen_sctp:option_name()</a> |
    <a href="../gen_tcp/#type-option_name">gen_tcp:option_name()</a> |
    <a href="../gen_udp/#type-option_name">gen_udp:option_name()</a>
socket_setopt() = 
    <a href="../gen_sctp/#type-option">gen_sctp:option()</a> | <a href="../gen_tcp/#type-option">gen_tcp:option()</a> | <a href="../gen_udp/#type-option">gen_udp:option()</a></pre>

<p>Gets one or more options for a socket. See <code class="bold_code"><a href="#setopts-2">setopts/2</a></code> for a list of available options.</p> <p>The number of elements in the returned <code class="code">OptionValues</code> list does not necessarily correspond to the number of options asked for. If the operating system fails to support an option, it is simply left out in the returned list. An error tuple is only returned when getting options for the socket is impossible (i.e. the socket is closed or the buffer size in a raw request is too large). This behavior is kept for backward compatibility reasons.</p> <p>A raw option request <code class="code">RawOptReq = {raw, Protocol, OptionNum, ValueSpec}</code> can be used to get information about socket options not (explicitly) supported by the emulator. The use of raw socket options makes the code non portable, but allows the Erlang programmer to take advantage of unusual features present on the current platform.</p> <p>The <code class="code">RawOptReq</code> consists of the tag <code class="code">raw</code> followed by the protocol level, the option number and either a binary or the size, in bytes, of the buffer in which the option value is to be stored. A binary should be used when the underlying <code class="code">getsockopt</code> requires <strong>input</strong> in the argument field, in which case the size of the binary should correspond to the required buffer size of the return value. The supplied values in a <code class="code">RawOptReq</code> correspond to the second, third and fourth/fifth parameters to the <code class="code">getsockopt</code> call in the C socket API. The value stored in the buffer is returned as a binary <code class="code">ValueBin</code> where all values are coded in the native endianess.</p> <p>Asking for and inspecting raw socket options require low level information about the current operating system and TCP stack.</p> <p>As an example, consider a Linux machine where the <code class="code">TCP_INFO</code> option could be used to collect TCP statistics for a socket. Lets say we're interested in the <code class="code">tcpi_sacked</code> field of the <code class="code">struct tcp_info</code> filled in when asking for <code class="code">TCP_INFO</code>. To be able to access this information, we need to know both the numeric value of the protocol level <code class="code">IPPROTO_TCP</code>, the numeric value of the option <code class="code">TCP_INFO</code>, the size of the <code class="code">struct tcp_info</code> and the size and offset of the specific field. By inspecting the headers or writing a small C program, we found <code class="code">IPPROTO_TCP</code> to be 6, <code class="code">TCP_INFO</code> to be 11, the structure size to be 92 (bytes), the offset of <code class="code">tcpi_sacked</code> to be 28 bytes and the actual value to be a 32 bit integer. We could use the following code to retrieve the value:</p> <div class="example"><pre>
get_tcpi_sacked(Sock) -&gt;
    {ok,[{raw,_,_,Info}]} = inet:getopts(Sock,[{raw,6,11,92}]),
    &lt;&lt;_:28/binary,TcpiSacked:32/native,_/binary&gt;&gt; = Info,
    TcpiSacked.</pre></div> <p>Preferably, you would check the machine type, the OS and the kernel version prior to executing anything similar to the code above.</p>  <h3 id="getstat-2" class="code">getstat(Socket) -&gt; {ok, OptionValues} | {error, <a href="#type-posix">posix()</a>}<br>getstat(Socket, Options) -&gt; {ok, OptionValues} | {error, <a href="#type-posix">posix()</a>}</h3> <p>Types:</p>      <pre>Socket = <a href="#type-socket">socket()</a>
Options = [stat_option()]
OptionValues = [{stat_option(), integer()}]
stat_option() = 
    recv_cnt |
    recv_max |
    recv_avg |
    recv_oct |
    recv_dvi |
    send_cnt |
    send_max |
    send_avg |
    send_oct |
    send_pend</pre>

<p>Gets one or more statistic options for a socket.</p> <p><code class="code">getstat(Socket)</code> is equivalent to <code class="code">getstat(Socket, [recv_avg, recv_cnt, recv_dvi, recv_max, recv_oct, send_avg, send_cnt, send_dvi, send_max, send_oct])</code>.</p> <p>The following options are available:</p> <dl> <dt><strong><code class="code">recv_avg</code></strong></dt> <dd> <p>Average size of packets in bytes received by the socket.</p> </dd> <dt><strong><code class="code">recv_cnt</code></strong></dt> <dd> <p>Number of packets received by the socket.</p> </dd> <dt><strong><code class="code">recv_dvi</code></strong></dt> <dd> <p>Average packet size deviation in bytes received by the socket.</p> </dd> <dt><strong><code class="code">recv_max</code></strong></dt> <dd> <p>The size of the largest packet in bytes received by the socket.</p> </dd> <dt><strong><code class="code">recv_oct</code></strong></dt> <dd> <p>Number of bytes received by the socket.</p> </dd> <dt><strong><code class="code">send_avg</code></strong></dt> <dd> <p>Average size of packets in bytes sent from the socket.</p> </dd> <dt><strong><code class="code">send_cnt</code></strong></dt> <dd> <p>Number of packets sent from the socket.</p> </dd> <dt><strong><code class="code">send_dvi</code></strong></dt> <dd> <p>Average packet size deviation in bytes sent from the socket.</p> </dd> <dt><strong><code class="code">send_max</code></strong></dt> <dd> <p>The size of the largest packet in bytes sent from the socket.</p> </dd> <dt><strong><code class="code">send_oct</code></strong></dt> <dd> <p>Number of bytes sent from the socket.</p> </dd> </dl>  <h3 id="ntoa-1" class="code">ntoa(IpAddress) -&gt; Address | {error, einval}</h3> <p>Types:</p>    <pre>Address = string()
IpAddress = <a href="#type-ip_address">ip_address()</a></pre>

<p>Parses an <code class="bold_code"><a href="#type-ip_address">ip_address()</a></code> and returns an IPv4 or IPv6 address string.</p>  <h3 id="parse_ipv4_address-1" class="code">parse_ipv4_address(Address) -&gt; {ok, IPv4Address} | {error, einval}</h3> <p>Types:</p>    <pre>Address = string()
IPv4Address = <a href="#type-ip_address">ip_address()</a></pre>

<p>Parses an IPv4 address string and returns an <code class="bold_code"><a href="#type-ip4_address">ip4_address()</a></code>. Accepts a shortened IPv4 shortened address string.</p>  <h3 id="parse_ipv4strict_address-1" class="code">parse_ipv4strict_address(Address) -&gt;<br>                            {ok, IPv4Address} | {error, einval}</h3> <p>Types:</p>    <pre>Address = string()
IPv4Address = <a href="#type-ip_address">ip_address()</a></pre>

<p>Parses an IPv4 address string containing four fields, i.e <strong>not</strong> shortened, and returns an <code class="bold_code"><a href="#type-ip4_address">ip4_address()</a></code>.</p>  <h3 id="parse_ipv6_address-1" class="code">parse_ipv6_address(Address) -&gt; {ok, IPv6Address} | {error, einval}</h3> <p>Types:</p>    <pre>Address = string()
IPv6Address = <a href="#type-ip_address">ip_address()</a></pre>

<p>Parses an IPv6 address string and returns an <code class="bold_code"><a href="#type-ip6_address">ip6_address()</a></code>. If an IPv4 address string is passed, an IPv4-mapped IPv6 address is returned.</p>  <h3 id="parse_ipv6strict_address-1" class="code">parse_ipv6strict_address(Address) -&gt;<br>                            {ok, IPv6Address} | {error, einval}</h3> <p>Types:</p>    <pre>Address = string()
IPv6Address = <a href="#type-ip_address">ip_address()</a></pre>

<p>Parses an IPv6 address string and returns an <code class="bold_code"><a href="#type-ip6_address">ip6_address()</a></code>. Does <strong>not</strong> accept IPv4 adresses.</p>  <h3 id="parse_address-1" class="code">parse_address(Address) -&gt; {ok, IPAddress} | {error, einval}</h3> <p>Types:</p>    <pre>Address = string()
IPAddress = <a href="#type-ip_address">ip_address()</a></pre>

<p>Parses an IPv4 or IPv6 address string and returns an <code class="bold_code"><a href="#type-ip4_address">ip4_address()</a></code> or <code class="bold_code"><a href="#type-ip6_address">ip6_address()</a></code>. Accepts a shortened IPv4 address string.</p>  <h3 id="parse_strict_address-1" class="code">parse_strict_address(Address) -&gt; {ok, IPAddress} | {error, einval}</h3> <p>Types:</p>    <pre>Address = string()
IPAddress = <a href="#type-ip_address">ip_address()</a></pre>

<p>Parses an IPv4 or IPv6 address string and returns an <code class="bold_code"><a href="#type-ip4_address">ip4_address()</a></code> or <code class="bold_code"><a href="#type-ip6_address">ip6_address()</a></code>. Does <strong>not</strong> accept a shortened IPv4 address string.</p>  <h3 id="peername-1" class="code">peername(Socket) -&gt; {ok, {Address, Port}} | {error, <a href="#type-posix">posix()</a>}</h3> <p>Types:</p>     <pre>Socket = <a href="#type-socket">socket()</a>
Address = <a href="#type-ip_address">ip_address()</a>
Port = integer() &gt;= 0</pre>

<p> Returns the address and port for the other end of a connection. </p> <p> Note that for SCTP sockets this function only returns one of the socket's peer addresses. The function <code class="bold_code"><a href="#peernames-1">peernames/1,2</a></code> returns all. </p>  <h3 id="peernames-1" class="code">peernames(Socket) -&gt; {ok, [{Address, Port}]} | {error, <a href="#type-posix">posix()</a>}</h3> <p>Types:</p>     <pre>Socket = <a href="#type-socket">socket()</a>
Address = <a href="#type-ip_address">ip_address()</a>
Port = integer() &gt;= 0</pre>

<p> Equivalent to <code class="bold_code"><a href="#peernames-2"><span class="code">peernames(Socket, 0)</span></a></code>. Note that this function's behaviour for an SCTP one-to-many style socket is not defined by the <code class="bold_code"><a href="http://tools.ietf.org/html/draft-ietf-tsvwg-sctpsocket-13" target="_blank">SCTP Sockets API Extensions</a></code>. </p>  <h3 id="peernames-2" class="code">peernames(Socket, Assoc) -&gt;<br>             {ok, [{Address, Port}]} | {error, <a href="#type-posix">posix()</a>}</h3> <p>Types:</p>      <pre>Socket = <a href="#type-socket">socket()</a>
Assoc = #sctp_assoc_change{} | <a href="../gen_sctp/#type-assoc_id">gen_sctp:assoc_id()</a>
Address = <a href="#type-ip_address">ip_address()</a>
Port = integer() &gt;= 0</pre>

<p> Returns a list of all address/port number pairs for the other end of a socket's association <code class="code">Assoc</code>. </p> <p> This function can return multiple addresses for multihomed sockets such as SCTP sockets. For other sockets it returns a one element list. </p> <p> Note that the <code class="code">Assoc</code> parameter is by the <code class="bold_code"><a href="http://tools.ietf.org/html/draft-ietf-tsvwg-sctpsocket-13" target="_blank">SCTP Sockets API Extensions</a></code> defined to be ignored for one-to-one style sockets. What the special value <code class="code">0</code> means hence its behaviour for one-to-many style sockets is unfortunately not defined. </p>  <h3 id="port-1" class="code">port(Socket) -&gt; {ok, Port} | {error, any()}</h3> <p>Types:</p>    <pre>Socket = <a href="#type-socket">socket()</a>
Port = <a href="#type-port_number">port_number()</a></pre>

<p>Returns the local port number for a socket.</p>  <h3 id="sockname-1" class="code">sockname(Socket) -&gt; {ok, {Address, Port}} | {error, <a href="#type-posix">posix()</a>}</h3> <p>Types:</p>     <pre>Socket = <a href="#type-socket">socket()</a>
Address = <a href="#type-ip_address">ip_address()</a>
Port = integer() &gt;= 0</pre>

<p>Returns the local address and port number for a socket.</p> <p> Note that for SCTP sockets this function only returns one of the socket addresses. The function <code class="bold_code"><a href="#socknames-1">socknames/1,2</a></code> returns all. </p>  <h3 id="socknames-1" class="code">socknames(Socket) -&gt; {ok, [{Address, Port}]} | {error, <a href="#type-posix">posix()</a>}</h3> <p>Types:</p>     <pre>Socket = <a href="#type-socket">socket()</a>
Address = <a href="#type-ip_address">ip_address()</a>
Port = integer() &gt;= 0</pre>

<p> Equivalent to <code class="bold_code"><a href="#socknames-2"><span class="code">socknames(Socket, 0)</span></a></code>. </p>  <h3 id="socknames-2" class="code">socknames(Socket, Assoc) -&gt;<br>             {ok, [{Address, Port}]} | {error, <a href="#type-posix">posix()</a>}</h3> <p>Types:</p>      <pre>Socket = <a href="#type-socket">socket()</a>
Assoc = #sctp_assoc_change{} | <a href="../gen_sctp/#type-assoc_id">gen_sctp:assoc_id()</a>
Address = <a href="#type-ip_address">ip_address()</a>
Port = integer() &gt;= 0</pre>

<p> Returns a list of all local address/port number pairs for a socket for the given association <code class="code">Assoc</code>. </p> <p> This function can return multiple addresses for multihomed sockets such as SCTP sockets. For other sockets it returns a one element list. </p> <p> Note that the <code class="code">Assoc</code> parameter is by the <code class="bold_code"><a href="http://tools.ietf.org/html/draft-ietf-tsvwg-sctpsocket-13" target="_blank">SCTP Sockets API Extensions</a></code> defined to be ignored for one-to-one style sockets. For one-to-many style sockets the special value <code class="code">0</code> is defined to mean that the returned addresses shall be without regard to any particular association. How different SCTP implementations interprets this varies somewhat. </p>  <h3 id="setopts-2" class="code">setopts(Socket, Options) -&gt; ok | {error, <a href="#type-posix">posix()</a>}</h3> <p>Types:</p>     <pre>Socket = <a href="#type-socket">socket()</a>
Options = [socket_setopt()]
socket_setopt() = 
    <a href="../gen_sctp/#type-option">gen_sctp:option()</a> | <a href="../gen_tcp/#type-option">gen_tcp:option()</a> | <a href="../gen_udp/#type-option">gen_udp:option()</a></pre>

<p>Sets one or more options for a socket. The following options are available:</p> <dl> <dt><strong><code class="code">{active, true | false | once | N}</code></strong></dt> <dd> <p>If the value is <code class="code">true</code>, which is the default, everything received from the socket will be sent as messages to the receiving process. If the value is <code class="code">false</code> (passive mode), the process must explicitly receive incoming data by calling <code class="bold_code"><a href="../gen_tcp/#recv-2"><span class="code">gen_tcp:recv/2,3</span></a></code>, <code class="bold_code"><a href="../gen_udp/#recv-2"><span class="code">gen_udp:recv/2,3</span></a></code> or <code class="bold_code"><a href="../gen_sctp/#recv-1"><span class="code">gen_sctp:recv/1,2</span></a></code> (depending on the type of socket).</p> <p>If the value is <code class="code">once</code> (<code class="code">{active, once}</code>), <strong>one</strong> data message from the socket will be sent to the process. To receive one more message, <code class="code">setopts/2</code> must be called again with the <code class="code">{active, once}</code> option.</p> <p>If the value is an integer <code class="code">N</code> in the range -32768 to 32767 (inclusive), the value is added to the socket's count of data messages sent to the controlling process. A socket's default message count is 0. If a negative value is specified and its magnitude is equal to or greater than the socket's current message count, the socket's message count is set to 0. Once the socket's message count reaches 0, either due to sending received data messages to the process or by being explicitly set, the process is then notified by a special message, specific to the type of socket, that the socket has entered passive mode. Once the socket enters passive mode, to receive more messages <code class="code">setopts/2</code> must be called again to set the socket back into an active mode.</p> <p>When using <code class="code">{active, once}</code> or <code class="code">{active, N}</code>, the socket changes behaviour automatically when data is received. This can sometimes be confusing in combination with connection-oriented sockets (i.e. <code class="code">gen_tcp</code>) as a socket with <code class="code">{active, false}</code> behaviour reports closing differently than a socket with <code class="code">{active, true}</code> behaviour. To make programming easier, a socket where the peer closed and this was detected while in <code class="code">{active, false}</code> mode, will still generate the message <code class="code">{tcp_closed,Socket}</code> when set to <code class="code">{active, once}</code>, <code class="code">{active, true}</code> or <code class="code">{active, N}</code> mode. It is therefore safe to assume that the message <code class="code">{tcp_closed,Socket}</code>, possibly followed by socket port termination (depending on the <code class="code">exit_on_close</code> option) will eventually appear when a socket changes back and forth between <code class="code">{active, true}</code> and <code class="code">{active, false}</code> mode. However, <strong>when</strong> peer closing is detected is all up to the underlying TCP/IP stack and protocol.</p> <p>Note that <code class="code">{active, true}</code> mode provides no flow control; a fast sender could easily overflow the receiver with incoming messages. The same is true of <code class="code">{active, N}</code> mode while the message count is greater than zero. Use active mode only if your high-level protocol provides its own flow control (for instance, acknowledging received messages) or the amount of data exchanged is small. <code class="code">{active, false}</code> mode, use of the <code class="code">{active, once}</code> mode or <code class="code">{active, N}</code> mode with values of <code class="code">N</code> appropriate for the application provides flow control; the other side will not be able send faster than the receiver can read.</p> </dd> <dt><strong><code class="code">{broadcast, Boolean}</code>(UDP sockets)</strong></dt> <dd id="option-buffer"> <p>Enable/disable permission to send broadcasts.</p>  </dd> <dt><strong><code class="code">{buffer, Size}</code></strong></dt> <dd> <p>The size of the user-level software buffer used by the driver. Not to be confused with <code class="code">sndbuf</code> and <code class="code">recbuf</code> options which correspond to the kernel socket buffers. It is recommended to have <code class="code">val(buffer) &gt;= max(val(sndbuf),val(recbuf))</code> to avoid performance issues due to unnecessary copying. In fact, the <code class="code">val(buffer)</code> is automatically set to the above maximum when <code class="code">sndbuf</code> or <code class="code">recbuf</code> values are set. However, since the actual sizes set for <code class="code">sndbuf</code> and <code class="code">recbuf</code> usually becomes larger, you are encouraged to use <code class="bold_code"><a href="../inet/#getopts-2"><span class="code">inet:getopts/2</span></a></code> to analyze the behavior of your operating system.</p> </dd> <dt><strong><code class="code">{delay_send, Boolean}</code></strong></dt> <dd> <p>Normally, when an Erlang process sends to a socket, the driver will try to immediately send the data. If that fails, the driver will use any means available to queue up the message to be sent whenever the operating system says it can handle it. Setting <code class="code">{delay_send, true}</code> will make <strong>all</strong> messages queue up. This makes the messages actually sent onto the network be larger but fewer. The option actually affects the scheduling of send requests versus Erlang processes instead of changing any real property of the socket. Needless to say it is an implementation specific option. Default is <code class="code">false</code>.</p> </dd> <dt><strong><code class="code">{deliver, port | term}</code></strong></dt> <dd> <p> When <code class="code">{active, true}</code> delivers data on the forms <code class="code">port</code> : <code class="code">{S, {data, [H1,..Hsz | Data]}}</code> or <code class="code">term</code> : <code class="code">{tcp, S, [H1..Hsz | Data]}</code>. </p> </dd> <dt><strong><code class="code">{dontroute, Boolean}</code></strong></dt> <dd> <p>Enable/disable routing bypass for outgoing messages.</p> </dd> <dt><strong><code class="code">{exit_on_close, Boolean}</code></strong></dt> <dd> <p>By default this option is set to <code class="code">true</code>.</p> <p>The only reason to set it to <code class="code">false</code> is if you want to continue sending data to the socket after a close has been detected, for instance if the peer has used <code class="bold_code"><a href="../gen_tcp/#shutdown-2">gen_tcp:shutdown/2</a></code> to shutdown the write side.</p> </dd> <dt><strong><code class="code">{header, Size}</code></strong></dt> <dd> <p>This option is only meaningful if the <code class="code">binary</code> option was specified when the socket was created. If the <code class="code">header</code> option is specified, the first <code class="code">Size</code> number bytes of data received from the socket will be elements of a list, and the rest of the data will be a binary given as the tail of the same list. If for example <code class="code">Size == 2</code>, the data received will match <code class="code">[Byte1,Byte2|Binary]</code>.</p> </dd> <dt><strong><code class="code">{high_msgq_watermark, Size}</code></strong></dt> <dd> <p>The socket message queue will be set into a busy state when the amount of data queued on the message queue reaches this limit. Note that this limit only concerns data that have not yet reached the ERTS internal socket implementation. Default value used is 8 kB.</p> <p>Senders of data to the socket will be suspended if either the socket message queue is busy, or the socket itself is busy.</p> <p>For more information see the <code class="code">low_msgq_watermark</code>, <code class="code">high_watermark</code>, and <code class="code">low_watermark</code> options.</p> <p>Note that distribution sockets will disable the use of <code class="code">high_msgq_watermark</code> and <code class="code">low_msgq_watermark</code>, and will instead use the <code class="bold_code">distribution buffer busy limit</code> which is a similar feature.</p> </dd> <dt><strong><code class="code">{high_watermark, Size}</code> (TCP/IP sockets)</strong></dt> <dd> <p>The socket will be set into a busy state when the amount of data queued internally by the ERTS socket implementation reaches this limit. Default value used is 8 kB.</p> <p>Senders of data to the socket will be suspended if either the socket message queue is busy, or the socket itself is busy.</p> <p>For more information see the <code class="code">low_watermark</code>, <code class="code">high_msgq_watermark</code>, and <code class="code">low_msqg_watermark</code> options.</p> </dd> <dt><strong><code class="code">{ipv6_v6only, Boolean}</code></strong></dt> <dd> <p> Restricts the socket to only use IPv6, prohibiting any IPv4 connections. This is only applicable for IPv6 sockets (option <code class="code">inet6</code>). </p> <p> On most platforms this option has to be set on the socket before associating it to an address. Therefore it is only reasonable to give it when creating the socket and not to use it when calling the function (<code class="bold_code"><a href="#setopts-2">setopts/2</a></code>) containing this description. </p> <p> The behaviour of a socket with this socket option set to <code class="code">true</code> is becoming the only portable one. The original idea when IPv6 was new of using IPv6 for all traffic is now not recommended by FreeBSD (you can use <code class="code">{ipv6_v6only,false}</code> to override the recommended system default value), forbidden by OpenBSD (the supported GENERIC kernel) and impossible on Windows (that has separate IPv4 and IPv6 protocol stacks). Most Linux distros still have a system default value of <code class="code">false</code>. This policy shift among operating systems towards separating IPv6 from IPv4 traffic has evolved since it gradually proved hard and complicated to get a dual stack implementation correct and secure. </p> <p> On some platforms the only allowed value for this option is <code class="code">true</code>, e.g. OpenBSD and Windows. Trying to set this option to <code class="code">false</code> when creating the socket will in this case fail. </p> <p> Setting this option on platforms where it does not exist is ignored and getting this option with <code class="bold_code"><a href="#getopts-2">getopts/2</a></code> returns no value i.e the returned list will not contain an <code class="code">{ipv6_v6only,_}</code> tuple. On Windows the option acually does not exist, but it is emulated as being a read-only option with the value <code class="code">true</code>. </p> <p> So it boils down to that setting this option to <code class="code">true</code> when creating a socket will never fail except possibly (at the time of this writing) on a platform where you have customized the kernel to only allow <code class="code">false</code>, which might be doable (but weird) on e.g. OpenBSD. </p> <p> If you read back the option value using <code class="bold_code"><a href="#getopts-2">getopts/2</a></code> and get no value the option does not exist in the host OS and all bets are off regarding the behaviour of both an IPv6 and an IPv4 socket listening on the same port as well as for an IPv6 socket getting IPv4 traffic. </p> </dd> <dt><strong><code class="code">{keepalive, Boolean}</code>(TCP/IP sockets)</strong></dt> <dd id="option-linger"> <p>Enables/disables periodic transmission on a connected socket, when no other data is being exchanged. If the other end does not respond, the connection is considered broken and an error message will be sent to the controlling process. Default disabled.</p>  </dd> <dt><strong><code class="code">{linger, {true|false, Seconds}}</code></strong></dt> <dd> <p>Determines the timeout in seconds for flushing unsent data in the <code class="code">close/1</code> socket call. If the 1st component of the value tuple is <code class="code">false</code>, the 2nd one is ignored, which means that <code class="code">close/1</code> returns immediately not waiting for data to be flushed. Otherwise, the 2nd component is the flushing time-out in seconds.</p> </dd> <dt><strong><code class="code">{low_msgq_watermark, Size}</code></strong></dt> <dd> <p>If the socket message queue is in a busy state, the socket message queue will be set in a not busy state when the amount of data queued in the message queue falls below this limit. Note that this limit only concerns data that have not yet reached the ERTS internal socket implementation. Default value used is 4 kB.</p> <p>Senders that have been suspended due to either a busy message queue or a busy socket, will be resumed when neither the socket message queue, nor the socket are busy.</p> <p>For more information see the <code class="code">high_msgq_watermark</code>, <code class="code">high_watermark</code>, and <code class="code">low_watermark</code> options.</p> <p>Note that distribution sockets will disable the use of <code class="code">high_msgq_watermark</code> and <code class="code">low_msgq_watermark</code>, and will instead use the <code class="bold_code">distribution buffer busy limit</code> which is a similar feature.</p> </dd> <dt><strong><code class="code">{low_watermark, Size}</code> (TCP/IP sockets)</strong></dt> <dd> <p>If the socket is in a busy state, the socket will be set in a not busy state when the amount of data queued internally by the ERTS socket implementation falls below this limit. Default value used is 4 kB.</p> <p>Senders that have been suspended due to either a busy message queue or a busy socket, will be resumed when neither the socket message queue, nor the socket are busy.</p> <p>For more information see the <code class="code">high_watermark</code>, <code class="code">high_msgq_watermark</code>, and <code class="code">low_msgq_watermark</code> options.</p> </dd> <dt><strong><code class="code">{mode, Mode :: binary | list}</code></strong></dt> <dd> <p>Received <code class="code">Packet</code> is delivered as defined by Mode.</p> </dd> <dt><strong><code class="code">{netns, Namespace :: file:filename_all()}</code></strong></dt> <dd> <p>Set a network namespace for the socket. The <code class="code">Namespace</code> parameter is a filename defining the namespace for example <code class="code">"/var/run/netns/example"</code> typically created by the command <code class="code">ip netns add example</code>. This option must be used in a function call that creates a socket i.e <code class="bold_code"><a href="../gen_tcp/#connect-3"> gen_tcp:connect/3,4</a></code>, <code class="bold_code"><a href="../gen_tcp/#listen-2"> gen_tcp:listen/2</a></code>, <code class="bold_code"><a href="../gen_udp/#open-1"> gen_udp:open/1,2</a></code> or <code class="bold_code"><a href="../gen_sctp/#open-0"> gen_sctp:open/0-2</a></code>. </p> <p>This option uses the Linux specific syscall <code class="code">setns()</code> such as in Linux kernel 3.0 or later and therefore only exists when the runtime system has been compiled for such an operating system. </p> <p> The virtual machine also needs elevated privileges either running as superuser or (for Linux) having the capability <code class="code">CAP_SYS_ADMIN</code> according to the documentation for setns(2). However, during testing also <code class="code">CAP_SYS_PTRACE</code> and <code class="code">CAP_DAC_READ_SEARCH</code> has proven to be necessary. Example:</p> <div class="example"><pre>
setcap cap_sys_admin,cap_sys_ptrace,cap_dac_read_search+epi beam.smp
</pre></div> <p>Note also that the filesystem containing the virtual machine executable (<code class="code">beam.smp</code> in the example above) has to be local, mounted without the <code class="code">nosetuid</code> flag, support extended attributes and that the kernel has to support file capabilities. All this runs out of the box on at least Ubuntu 12.04 LTS, except that SCTP sockets appears to not support network namespaces. </p> <p>The <code class="code">Namespace</code> is a file name and is encoded and decoded as discussed in <code class="bold_code"><a href="../file/">file</a></code> except that the emulator flag <code class="code">+fnu</code> is ignored and <code class="bold_code"><a href="#getopts-2">getopts/2</a></code> for this option will return a binary for the filename if the stored filename can not be decoded, which should only happen if you set the option using a binary that can not be decoded with the emulator's filename encoding: <code class="bold_code"><a href="../file/#native_name_encoding-0"> file:native_name_encoding/0</a></code>. </p> </dd> <dt><strong><code class="code">list</code></strong></dt> <dd> <p>Received <code class="code">Packet</code> is delivered as a list.</p> </dd> <dt><strong><code class="code">binary</code></strong></dt> <dd> <p>Received <code class="code">Packet</code> is delivered as a binary.</p> </dd> <dt><strong><code class="code">{nodelay, Boolean}</code>(TCP/IP sockets)</strong></dt> <dd> <p>If <code class="code">Boolean == true</code>, the <code class="code">TCP_NODELAY</code> option is turned on for the socket, which means that even small amounts of data will be sent immediately.</p> </dd> <dt><strong><code class="code">{packet, PacketType}</code>(TCP/IP sockets)</strong></dt> <dd> <p>Defines the type of packets to use for a socket. The following values are valid:</p> <dl> <dt><strong><code class="code">raw | 0</code></strong></dt> <dd> <p>No packaging is done.</p> </dd> <dt><strong><code class="code">1 | 2 | 4</code></strong></dt> <dd> <p>Packets consist of a header specifying the number of bytes in the packet, followed by that number of bytes. The length of header can be one, two, or four bytes; containing an unsigned integer in big-endian byte order. Each send operation will generate the header, and the header will be stripped off on each receive operation.</p> <p>In current implementation the 4-byte header is limited to 2Gb.</p> </dd> <dt><strong><code class="code">asn1 | cdr | sunrm | fcgi | tpkt | line</code></strong></dt> <dd> <p>These packet types only have effect on receiving. When sending a packet, it is the responsibility of the application to supply a correct header. On receiving, however, there will be one message sent to the controlling process for each complete packet received, and, similarly, each call to <code class="code">gen_tcp:recv/2,3</code> returns one complete packet. The header is <strong>not</strong> stripped off.</p> <p>The meanings of the packet types are as follows: <br> <code class="code">asn1</code> - ASN.1 BER, <br> <code class="code">sunrm</code> - Sun's RPC encoding, <br> <code class="code">cdr</code> - CORBA (GIOP 1.1), <br> <code class="code">fcgi</code> - Fast CGI, <br> <code class="code">tpkt</code> - TPKT format [RFC1006], <br> <code class="code">line</code> - Line mode, a packet is a line terminated with newline, lines longer than the receive buffer are truncated.</p> </dd> <dt><strong><code class="code">http | http_bin</code></strong></dt> <dd> <p>The Hypertext Transfer Protocol. The packets are returned with the format according to <code class="code">HttpPacket</code> described in <code class="bold_code"> erlang:decode_packet/3</code>. A socket in passive mode will return <code class="code">{ok, HttpPacket}</code> from <code class="code">gen_tcp:recv</code> while an active socket will send messages like <code class="code">{http, Socket, HttpPacket}</code>.</p> </dd> <dt><strong><code class="code">httph | httph_bin</code></strong></dt> <dd> <p>These two types are often not needed as the socket will automatically switch from <code class="code">http</code>/<code class="code">http_bin</code> to <code class="code">httph</code>/<code class="code">httph_bin</code> internally after the first line has been read. There might be occasions however when they are useful, such as parsing trailers from chunked encoding.</p> </dd> </dl> </dd> <dt><strong><code class="code">{packet_size, Integer}</code>(TCP/IP sockets)</strong></dt> <dd> <p>Sets the max allowed length of the packet body. If the packet header indicates that the length of the packet is longer than the max allowed length, the packet is considered invalid. The same happens if the packet header is too big for the socket receive buffer.</p> <p>For line oriented protocols (<code class="code">line</code>,<code class="code">http*</code>), option <code class="code">packet_size</code> also guarantees that lines up to the indicated length are accepted and not considered invalid due to internal buffer limitations.</p> </dd> <dt><strong><code class="code">{line_delimiter, Char}</code>(TCP/IP sockets)</strong></dt> <dd> <p>Sets the line delimiting character for line oriented protocols (<code class="code">line</code>). Default value is <code class="code">$\n</code>.</p> </dd> <dt><strong><code class="code">{priority, Priority}</code></strong></dt> <dd> <p>Set the protocol-defined priority for all packets to be sent on this socket.</p> </dd> <dt><strong><code class="code">{raw, Protocol, OptionNum, ValueBin}</code></strong></dt> <dd> <p>See below.</p> </dd> <dt><strong><code class="code">{read_packets, Integer}</code>(UDP sockets)</strong></dt> <dd> <p>Sets the max number of UDP packets to read without intervention from the socket when data is available. When this many packets have been read and delivered to the destination process, new packets are not read until a new notification of available data has arrived. The default is 5, and if this parameter is set too high the system can become unresponsive due to UDP packet flooding.</p> </dd> <dt><strong><code class="code">{recbuf, Size}</code></strong></dt> <dd> <p>The minimum size of the receive buffer to use for the socket. You are encouraged to use <code class="bold_code"><a href="../inet/#getopts-2"><span class="code">inet:getopts/2</span></a></code>, to retrieve the actual size set by your operating system. </p> </dd> <dt><strong><code class="code">{reuseaddr, Boolean}</code></strong></dt> <dd> <p>Allows or disallows local reuse of port numbers. By default, reuse is disallowed.</p> </dd> <dt><strong><code class="code">{send_timeout, Integer}</code></strong></dt> <dd> <p>Only allowed for connection oriented sockets.</p> <p>Specifies a longest time to wait for a send operation to be accepted by the underlying TCP stack. When the limit is exceeded, the send operation will return <code class="code">{error,timeout}</code>. How much of a packet that actually got sent is unknown, why the socket should be closed whenever a timeout has occurred (see <code class="code">send_timeout_close</code>). Default is <code class="code">infinity</code>.</p> </dd> <dt><strong><code class="code">{send_timeout_close, Boolean}</code></strong></dt> <dd id="option-sndbuf"> <p>Only allowed for connection oriented sockets.</p> <p>Used together with <code class="code">send_timeout</code> to specify whether the socket will be automatically closed when the send operation returns <code class="code">{error,timeout}</code>. The recommended setting is <code class="code">true</code> which will automatically close the socket. Default is <code class="code">false</code> due to backward compatibility.</p>  </dd> <dt><strong><code class="code">{show_econnreset, Boolean}</code>(TCP/IP sockets)</strong></dt> <dd id="option-show_econnreset"> <p>When this option is set to <code class="code">false</code>, as it is by default, an RST that is received from the TCP peer is treated as a normal close (as though a FIN was sent). A caller to <code class="bold_code"><a href="../gen_tcp/#recv-2">gen_tcp:recv/2</a></code> will get <code class="code">{error, closed}</code>. In active mode the controlling process will receive a <code class="code">{tcp_close, Socket}</code> message, indicating that the peer has closed the connection.</p> <p>Setting this option to <code class="code">true</code> will allow you to distinguish between a connection that was closed normally, and one which was aborted (intentionally or unintentionally) by the TCP peer. A call to <code class="bold_code"><a href="../gen_tcp/#recv-2">gen_tcp:recv/2</a></code> will return <code class="code">{error, econnreset}</code>. In active mode, the controlling process will receive a <code class="code">{tcp_error, Socket, econnreset}</code> message before the usual <code class="code">{tcp_closed, Socket}</code>, as is the case for any other socket error. Calls to <code class="bold_code"><a href="../gen_tcp/#send-2">gen_tcp:send/2</a></code> will also return <code class="code">{error, econnreset}</code> when it is detected that a TCP peer has sent an RST.</p> <p>A connected socket returned from <code class="bold_code"><a href="../gen_tcp/#accept-1">gen_tcp:accept/1</a></code> will inherit the <code class="code">show_econnreset</code> setting from the listening socket.</p>  </dd> <dt><strong><code class="code">{sndbuf, Size}</code></strong></dt> <dd> <p>The minimum size of the send buffer to use for the socket. You are encouraged to use <code class="bold_code"><a href="../inet/#getopts-2"><span class="code">inet:getopts/2</span></a></code>, to retrieve the actual size set by your operating system. </p> </dd> <dt><strong><code class="code">{priority, Integer}</code></strong></dt> <dd> <p>Sets the SO_PRIORITY socket level option on platforms where this is implemented. The behaviour and allowed range varies on different systems. The option is ignored on platforms where the option is not implemented. Use with caution.</p> </dd> <dt><strong><code class="code">{tos, Integer}</code></strong></dt> <dd> <p>Sets IP_TOS IP level options on platforms where this is implemented. The behaviour and allowed range varies on different systems. The option is ignored on platforms where the option is not implemented. Use with caution.</p> </dd> </dl> <p>In addition to the options mentioned above, <strong>raw</strong> option specifications can be used. The raw options are specified as a tuple of arity four, beginning with the tag <code class="code">raw</code>, followed by the protocol level, the option number and the actual option value specified as a binary. This corresponds to the second, third and fourth argument to the <code class="code">setsockopt</code> call in the C socket API. The option value needs to be coded in the native endianess of the platform and, if a structure is required, needs to follow the struct alignment conventions on the specific platform.</p> <p>Using raw socket options require detailed knowledge about the current operating system and TCP stack.</p> <p>As an example of the usage of raw options, consider a Linux system where you want to set the <code class="code">TCP_LINGER2</code> option on the <code class="code">IPPROTO_TCP</code> protocol level in the stack. You know that on this particular system it defaults to 60 (seconds), but you would like to lower it to 30 for a particular socket. The <code class="code">TCP_LINGER2</code> option is not explicitly supported by inet, but you know that the protocol level translates to the number 6, the option number to the number 8 and the value is to be given as a 32 bit integer. You can use this line of code to set the option for the socket named <code class="code">Sock</code>:</p> <div class="example"><pre>
inet:setopts(Sock,[{raw,6,8,&lt;&lt;30:32/native&gt;&gt;}]),</pre></div> <p>As many options are silently discarded by the stack if they are given out of range, it could be a good idea to check that a raw option really got accepted. This code places the value in the variable TcpLinger2:</p> <div class="example"><pre>
{ok,[{raw,6,8,&lt;&lt;TcpLinger2:32/native&gt;&gt;}]}=inet:getopts(Sock,[{raw,6,8,4}]),</pre></div> <p>Code such as the examples above is inherently non portable, even different versions of the same OS on the same platform may respond differently to this kind of option manipulation. Use with care.</p> <p>Note that the default options for TCP/IP sockets can be changed with the Kernel configuration parameters mentioned in the beginning of this document.</p>  <h2 id="id133765">POSIX Error Codes</h2>   <ul> <li> <code class="code">e2big</code> - argument list too long</li> <li> <code class="code">eacces</code> - permission denied</li> <li> <code class="code">eaddrinuse</code> - address already in use</li> <li> <code class="code">eaddrnotavail</code> - cannot assign requested address</li> <li> <code class="code">eadv</code> - advertise error</li> <li> <code class="code">eafnosupport</code> - address family not supported by protocol family</li> <li> <code class="code">eagain</code> - resource temporarily unavailable</li> <li> <code class="code">ealign</code> - EALIGN</li> <li> <code class="code">ealready</code> - operation already in progress</li> <li> <code class="code">ebade</code> - bad exchange descriptor</li> <li> <code class="code">ebadf</code> - bad file number</li> <li> <code class="code">ebadfd</code> - file descriptor in bad state</li> <li> <code class="code">ebadmsg</code> - not a data message</li> <li> <code class="code">ebadr</code> - bad request descriptor</li> <li> <code class="code">ebadrpc</code> - RPC structure is bad</li> <li> <code class="code">ebadrqc</code> - bad request code</li> <li> <code class="code">ebadslt</code> - invalid slot</li> <li> <code class="code">ebfont</code> - bad font file format</li> <li> <code class="code">ebusy</code> - file busy</li> <li> <code class="code">echild</code> - no children</li> <li> <code class="code">echrng</code> - channel number out of range</li> <li> <code class="code">ecomm</code> - communication error on send</li> <li> <code class="code">econnaborted</code> - software caused connection abort</li> <li> <code class="code">econnrefused</code> - connection refused</li> <li> <code class="code">econnreset</code> - connection reset by peer</li> <li> <code class="code">edeadlk</code> - resource deadlock avoided</li> <li> <code class="code">edeadlock</code> - resource deadlock avoided</li> <li> <code class="code">edestaddrreq</code> - destination address required</li> <li> <code class="code">edirty</code> - mounting a dirty fs w/o force</li> <li> <code class="code">edom</code> - math argument out of range</li> <li> <code class="code">edotdot</code> - cross mount point</li> <li> <code class="code">edquot</code> - disk quota exceeded</li> <li> <code class="code">eduppkg</code> - duplicate package name</li> <li> <code class="code">eexist</code> - file already exists</li> <li> <code class="code">efault</code> - bad address in system call argument</li> <li> <code class="code">efbig</code> - file too large</li> <li> <code class="code">ehostdown</code> - host is down</li> <li> <code class="code">ehostunreach</code> - host is unreachable</li> <li> <code class="code">eidrm</code> - identifier removed</li> <li> <code class="code">einit</code> - initialization error</li> <li> <code class="code">einprogress</code> - operation now in progress</li> <li> <code class="code">eintr</code> - interrupted system call</li> <li> <code class="code">einval</code> - invalid argument</li> <li> <code class="code">eio</code> - I/O error</li> <li> <code class="code">eisconn</code> - socket is already connected</li> <li> <code class="code">eisdir</code> - illegal operation on a directory</li> <li> <code class="code">eisnam</code> - is a named file</li> <li> <code class="code">el2hlt</code> - level 2 halted</li> <li> <code class="code">el2nsync</code> - level 2 not synchronized</li> <li> <code class="code">el3hlt</code> - level 3 halted</li> <li> <code class="code">el3rst</code> - level 3 reset</li> <li> <code class="code">elbin</code> - ELBIN</li> <li> <code class="code">elibacc</code> - cannot access a needed shared library</li> <li> <code class="code">elibbad</code> - accessing a corrupted shared library</li> <li> <code class="code">elibexec</code> - cannot exec a shared library directly</li> <li> <code class="code">elibmax</code> - attempting to link in more shared libraries than system limit</li> <li> <code class="code">elibscn</code> - .lib section in a.out corrupted</li> <li> <code class="code">elnrng</code> - link number out of range</li> <li> <code class="code">eloop</code> - too many levels of symbolic links</li> <li> <code class="code">emfile</code> - too many open files</li> <li> <code class="code">emlink</code> - too many links</li> <li> <code class="code">emsgsize</code> - message too long</li> <li> <code class="code">emultihop</code> - multihop attempted</li> <li> <code class="code">enametoolong</code> - file name too long</li> <li> <code class="code">enavail</code> - not available</li> <li> <code class="code">enet</code> - ENET</li> <li> <code class="code">enetdown</code> - network is down</li> <li> <code class="code">enetreset</code> - network dropped connection on reset</li> <li> <code class="code">enetunreach</code> - network is unreachable</li> <li> <code class="code">enfile</code> - file table overflow</li> <li> <code class="code">enoano</code> - anode table overflow</li> <li> <code class="code">enobufs</code> - no buffer space available</li> <li> <code class="code">enocsi</code> - no CSI structure available</li> <li> <code class="code">enodata</code> - no data available</li> <li> <code class="code">enodev</code> - no such device</li> <li> <code class="code">enoent</code> - no such file or directory</li> <li> <code class="code">enoexec</code> - exec format error</li> <li> <code class="code">enolck</code> - no locks available</li> <li> <code class="code">enolink</code> - link has be severed</li> <li> <code class="code">enomem</code> - not enough memory</li> <li> <code class="code">enomsg</code> - no message of desired type</li> <li> <code class="code">enonet</code> - machine is not on the network</li> <li> <code class="code">enopkg</code> - package not installed</li> <li> <code class="code">enoprotoopt</code> - bad protocol option</li> <li> <code class="code">enospc</code> - no space left on device</li> <li> <code class="code">enosr</code> - out of stream resources or not a stream device</li> <li> <code class="code">enosym</code> - unresolved symbol name</li> <li> <code class="code">enosys</code> - function not implemented</li> <li> <code class="code">enotblk</code> - block device required</li> <li> <code class="code">enotconn</code> - socket is not connected</li> <li> <code class="code">enotdir</code> - not a directory</li> <li> <code class="code">enotempty</code> - directory not empty</li> <li> <code class="code">enotnam</code> - not a named file</li> <li> <code class="code">enotsock</code> - socket operation on non-socket</li> <li> <code class="code">enotsup</code> - operation not supported</li> <li> <code class="code">enotty</code> - inappropriate device for ioctl</li> <li> <code class="code">enotuniq</code> - name not unique on network</li> <li> <code class="code">enxio</code> - no such device or address</li> <li> <code class="code">eopnotsupp</code> - operation not supported on socket</li> <li> <code class="code">eperm</code> - not owner</li> <li> <code class="code">epfnosupport</code> - protocol family not supported</li> <li> <code class="code">epipe</code> - broken pipe</li> <li> <code class="code">eproclim</code> - too many processes</li> <li> <code class="code">eprocunavail</code> - bad procedure for program</li> <li> <code class="code">eprogmismatch</code> - program version wrong</li> <li> <code class="code">eprogunavail</code> - RPC program not available</li> <li> <code class="code">eproto</code> - protocol error</li> <li> <code class="code">eprotonosupport</code> - protocol not supported</li> <li> <code class="code">eprototype</code> - protocol wrong type for socket</li> <li> <code class="code">erange</code> - math result unrepresentable</li> <li> <code class="code">erefused</code> - EREFUSED</li> <li> <code class="code">eremchg</code> - remote address changed</li> <li> <code class="code">eremdev</code> - remote device</li> <li> <code class="code">eremote</code> - pathname hit remote file system</li> <li> <code class="code">eremoteio</code> - remote i/o error</li> <li> <code class="code">eremoterelease</code> - EREMOTERELEASE</li> <li> <code class="code">erofs</code> - read-only file system</li> <li> <code class="code">erpcmismatch</code> - RPC version is wrong</li> <li> <code class="code">erremote</code> - object is remote</li> <li> <code class="code">eshutdown</code> - cannot send after socket shutdown</li> <li> <code class="code">esocktnosupport</code> - socket type not supported</li> <li> <code class="code">espipe</code> - invalid seek</li> <li> <code class="code">esrch</code> - no such process</li> <li> <code class="code">esrmnt</code> - srmount error</li> <li> <code class="code">estale</code> - stale remote file handle</li> <li> <code class="code">esuccess</code> - Error 0</li> <li> <code class="code">etime</code> - timer expired</li> <li> <code class="code">etimedout</code> - connection timed out</li> <li> <code class="code">etoomanyrefs</code> - too many references</li> <li> <code class="code">etxtbsy</code> - text file or pseudo-device busy</li> <li> <code class="code">euclean</code> - structure needs cleaning</li> <li> <code class="code">eunatch</code> - protocol driver not attached</li> <li> <code class="code">eusers</code> - too many users</li> <li> <code class="code">eversion</code> - version mismatch</li> <li> <code class="code">ewouldblock</code> - operation would block</li> <li> <code class="code">exdev</code> - cross-domain link</li> <li> <code class="code">exfull</code> - message tables full</li> <li> <code class="code">nxdomain</code> - the hostname or domain name could not be found</li> </ul>
<div class="_attribution">
  <p class="_attribution-p">
    © 1999–2016 Ericsson AB<br>Licensed under the Apache License, Version 2.0.<br>
    
  </p>
</div>

			</div>
		</div>
	</section>

	</div>
</body>
</html>
