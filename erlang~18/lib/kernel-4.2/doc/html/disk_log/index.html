
<!DOCTYPE HTML>

<html lang="en">

<head>
  <meta charset="utf-8">
  <title>Disk_log - Erlang 18 - W3cubDocs</title>
  
  <meta name="description" content=" disk_log ">
  <meta name="keywords" content="disk, log, -, erlang, erlang~18">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="http://docs.w3cub.com/erlang~18/lib/kernel-4.2/doc/html/disk_log/">
  <link href="/favicon.png" rel="icon">
  <link type="text/css" rel="stylesheet" href="/assets/application-50364fff564ce3b6327021805f3f00e2957b441cf27f576a7dd4ff63bbc47047.css">
  <script type="text/javascript" src="/assets/application-db64bfd54ceb42be11af7995804cf4902548419ceb79d509b0b7d62c22d98e6f.js"></script>
  <script src="/json/erlang~18.js"></script>
  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-71174418-1']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>


</head>

<body>
	<div class="_app">
	<header class="_header">
  
  <form class="_search">
    <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
    <a class="_search-clear"></a>
    <div class="_search-tag"></div>
  </form>
  
  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/erlang~18/" class="_nav-link" title="" style="margin-left:0;">Erlang 18</a></span>
  
  <nav class="_nav">
    <a href="/app/" class="_nav-link ">App</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		<div class="_list">
			
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<div class="_page _erlang">
				
<h1>disk_log</h1> <h2>Module</h2> <p class="REFBODY">disk_log</p> <h2>Module summary</h2> <p class="REFBODY">A disk based term logging facility</p> <h2>Description</h2> 
<p><code class="code">disk_log</code> is a disk based term logger which makes it possible to efficiently log items on files. Two types of logs are supported, <strong>halt logs</strong> and <strong>wrap logs</strong>. A halt log appends items to a single file, the size of which may or may not be limited by the disk log module, whereas a wrap log utilizes a sequence of wrap log files of limited size. As a wrap log file has been filled up, further items are logged onto to the next file in the sequence, starting all over with the first file when the last file has been filled up. For the sake of efficiency, items are always written to files as binaries. </p> <p>Two formats of the log files are supported, the <strong>internal format</strong> and the <strong>external format</strong>. The internal format supports automatic repair of log files that have not been properly closed, and makes it possible to efficiently read logged items in <strong>chunks</strong> using a set of functions defined in this module. In fact, this is the only way to read internally formatted logs. The external format leaves it up to the user to read the logged deep byte lists. The disk log module cannot repair externally formatted logs. An item logged to an internally formatted log must not occupy more than 4 GB of disk space (the size must fit in 4 bytes). </p> <p>For each open disk log there is one process that handles requests made to the disk log; the disk log process is created when <code class="code">open/1</code> is called, provided there exists no process handling the disk log. A process that opens a disk log can either be an <strong>owner</strong> or an anonymous <strong>user</strong> of the disk log. Each owner is linked to the disk log process, and the disk log is closed by the owner should the owner terminate. Owners can subscribe to <strong>notifications</strong>, messages of the form <code class="code">{disk_log, Node, Log, Info}</code> that are sent from the disk log process when certain events occur, see the commands below and in particular the <code class="code">open/1</code> option <code class="bold_code"><a href="#notify">notify</a></code>. There can be several owners of a log, but a process cannot own a log more than once. One and the same process may, however, open the log as a user more than once. For a disk log process to properly close its file and terminate, it must be closed by its owners and once by some non-owner process for each time the log was used anonymously; the users are counted, and there must not be any users left when the disk log process terminates. </p> <p>Items can be logged <strong>synchronously</strong> by using the functions <code class="code">log/2</code>, <code class="code">blog/2</code>, <code class="code">log_terms/2</code> and <code class="code">blog_terms/2</code>. For each of these functions, the caller is put on hold until the items have been logged (but not necessarily written, use <code class="code">sync/1</code> to ensure that). By adding an <code class="code">a</code> to each of the mentioned function names we get functions that log items <strong>asynchronously</strong>. Asynchronous functions do not wait for the disk log process to actually write the items to the file, but return the control to the caller more or less immediately. </p> <p>When using the internal format for logs, the functions <code class="code">log/2</code>, <code class="code">log_terms/2</code>, <code class="code">alog/2</code>, and <code class="code">alog_terms/2</code> should be used. These functions log one or more Erlang terms. By prefixing each of the functions with a <code class="code">b</code> (for "binary") we get the corresponding <code class="code">blog</code> functions for the external format. These functions log one or more deep lists of bytes or, alternatively, binaries of deep lists of bytes. For example, to log the string <code class="code">"hello"</code> in ASCII format, we can use <code class="code">disk_log:blog(Log, "hello")</code>, or <code class="code">disk_log:blog(Log, list_to_binary("hello"))</code>. The two alternatives are equally efficient. The <code class="code">blog</code> functions can be used for internally formatted logs as well, but in this case they must be called with binaries constructed with calls to <code class="code">term_to_binary/1</code>. There is no check to ensure this, it is entirely the responsibility of the caller. If these functions are called with binaries that do not correspond to Erlang terms, the <code class="code">chunk/2,3</code> and automatic repair functions will fail. The corresponding terms (not the binaries) will be returned when <code class="code">chunk/2,3</code> is called. </p> <p>A collection of open disk logs with the same name running on different nodes is said to be a <strong>a distributed disk log</strong> if requests made to any one of the logs are automatically made to the other logs as well. The members of such a collection will be called individual distributed disk logs, or just distributed disk logs if there is no risk of confusion. There is no order between the members of such a collection. For instance, logged terms are not necessarily written onto the node where the request was made before written onto the other nodes. One could note here that there are a few functions that do not make requests to all members of distributed disk logs, namely <code class="code">info</code>, <code class="code">chunk</code>, <code class="code">bchunk</code>, <code class="code">chunk_step</code> and <code class="code">lclose</code>. An open disk log that is not a distributed disk log is said to be a <strong>local disk log</strong>. A local disk log is accessible only from the node where the disk log process runs, whereas a distributed disk log is accessible from all nodes in the Erlang system, with exception for those nodes where a local disk log with the same name as the distributed disk log exists. All processes on nodes that have access to a local or distributed disk log can log items or otherwise change, inspect or close the log. </p> <p>It is not guaranteed that all log files of a distributed disk log contain the same log items; there is no attempt made to synchronize the contents of the files. However, as long as at least one of the involved nodes is alive at each time, all items will be logged. When logging items to a distributed log, or otherwise trying to change the log, the replies from individual logs are ignored. If all nodes are down, the disk log functions reply with a <code class="code">nonode</code> error. </p> <div class="note"> <div class="label">Note</div> <div class="content">

<p>In some applications it may not be acceptable that replies from individual logs are ignored. An alternative in such situations is to use several local disk logs instead of one distributed disk log, and implement the distribution without use of the disk log module.</p> </div> </div> <p>Errors are reported differently for asynchronous log attempts and other uses of the disk log module. When used synchronously the disk log module replies with an error message, but when called asynchronously, the disk log module does not know where to send the error message. Instead owners subscribing to notifications will receive an <code class="code">error_status</code> message. </p> <p>The disk log module itself does not report errors to the <code class="code">error_logger</code> module; it is up to the caller to decide whether the error logger should be employed or not. The function <code class="code">format_error/1</code> can be used to produce readable messages from error replies. Information events are however sent to the error logger in two situations, namely when a log is repaired, or when a file is missing while reading chunks. </p> <p>The error message <code class="code">no_such_log</code> means that the given disk log is not currently open. Nothing is said about whether the disk log files exist or not. </p> <div class="note"> <div class="label">Note</div> <div class="content">

<p>If an attempt to reopen or truncate a log fails (see <code class="code">reopen</code> and <code class="code">truncate</code>) the disk log process immediately terminates. Before the process terminates links to to owners and blocking processes (see <code class="code">block</code>) are removed. The effect is that the links work in one direction only; any process using a disk log has to check for the error message <code class="code">no_such_log</code> if some other process might truncate or reopen the log simultaneously.</p> </div> </div>  <h2>Data types</h2> <h3 class="code">log() = term()</h3> <h3 class="code">dlog_size() = <br>    infinity |<br>    integer() &gt;= 1 |<br>    {MaxNoBytes :: integer() &gt;= 1, MaxNoFiles :: integer() &gt;= 1}</h3> <h3 class="code">dlog_format() = external | internal</h3> <h3 class="code">dlog_head_opt() = none | term() | binary() | [<a href="#type-dlog_byte">dlog_byte()</a>]</h3> <h3 class="code">dlog_byte() = [<a href="#type-dlog_byte">dlog_byte()</a>] | byte()</h3> <h3 class="code">dlog_mode() = read_only | read_write</h3> <h3 class="code">dlog_type() = halt | wrap</h3> <h3 class="code">continuation()</h3> 
<p>Chunk continuation returned by <code class="code">chunk/2,3</code>, <code class="code">bchunk/2,3</code>, or <code class="code">chunk_step/3</code>.</p>  <h3 class="code">bytes() = binary() | [byte()]</h3> <h3 class="code">invalid_header() = term()</h3> <h3 class="code">file_error() = term()</h3> <h2>Exports</h2> <h3 id="accessible_logs-0" class="code">accessible_logs() -&gt; {[LocalLog], [DistributedLog]}</h3> <p>Types:</p>    <pre>LocalLog = DistributedLog = <a href="#type-log">log()</a></pre>

<p>The <code class="code">accessible_logs/0</code> function returns the names of the disk logs accessible on the current node. The first list contains local disk logs, and the second list contains distributed disk logs. </p>  <h3 id="balog-2" class="code">alog(Log, Term) -&gt; notify_ret()<br>balog(Log, Bytes) -&gt; notify_ret()</h3> <p>Types:</p>      <pre>Log = <a href="#type-log">log()</a>
Term = term()
Bytes = <a href="#type-bytes">bytes()</a>
notify_ret() = ok | {error, no_such_log}</pre>

<p>The <code class="code">alog/2</code> and <code class="code">balog/2</code> functions asynchronously append an item to a disk log. The function <code class="code">alog/2</code> is used for internally formatted logs, and the function <code class="code">balog/2</code> for externally formatted logs. <code class="code">balog/2</code> can be used for internally formatted logs as well provided the binary was constructed with a call to <code class="code">term_to_binary/1</code>. </p> <p>The owners that subscribe to notifications will receive the message <code class="code">read_only</code>, <code class="code">blocked_log</code> or <code class="code">format_external</code> in case the item cannot be written on the log, and possibly one of the messages <code class="code">wrap</code>, <code class="code">full</code> and <code class="code">error_status</code> if an item was written on the log. The message <code class="code">error_status</code> is sent if there is something wrong with the header function or a file error occurred. </p>  <h3 id="balog_terms-2" class="code">alog_terms(Log, TermList) -&gt; notify_ret()<br>balog_terms(Log, ByteList) -&gt; notify_ret()</h3> <p>Types:</p>      <pre>Log = <a href="#type-log">log()</a>
TermList = [term()]
ByteList = [<a href="#type-bytes">bytes()</a>]
notify_ret() = ok | {error, no_such_log}</pre>

<p>The <code class="code">alog_terms/2</code> and <code class="code">balog_terms/2</code> functions asynchronously append a list of items to a disk log. The function <code class="code">alog_terms/2</code> is used for internally formatted logs, and the function <code class="code">balog_terms/2</code> for externally formatted logs. <code class="code">balog_terms/2</code> can be used for internally formatted logs as well provided the binaries were constructed with calls to <code class="code">term_to_binary/1</code>. </p> <p>The owners that subscribe to notifications will receive the message <code class="code">read_only</code>, <code class="code">blocked_log</code> or <code class="code">format_external</code> in case the items cannot be written on the log, and possibly one or more of the messages <code class="code">wrap</code>, <code class="code">full</code> and <code class="code">error_status</code> if items were written on the log. The message <code class="code">error_status</code> is sent if there is something wrong with the header function or a file error occurred. </p>  <h3 id="block-2" class="code">block(Log) -&gt; ok | {error, block_error_rsn()}<br>block(Log, QueueLogRecords) -&gt; ok | {error, block_error_rsn()}</h3> <p>Types:</p>     <pre>Log = <a href="#type-log">log()</a>
QueueLogRecords = boolean()
block_error_rsn() = no_such_log | nonode | {blocked_log, <a href="#type-log">log()</a>}</pre>

<p>With a call to <code class="code">block/1,2</code> a process can block a log. If the blocking process is not an owner of the log, a temporary link is created between the disk log process and the blocking process. The link is used to ensure that the disk log is unblocked should the blocking process terminate without first closing or unblocking the log. </p> <p>Any process can probe a blocked log with <code class="code">info/1</code> or close it with <code class="code">close/1</code>. The blocking process can also use the functions <code class="code">chunk/2,3</code>, <code class="code">bchunk/2,3</code>, <code class="code">chunk_step/3</code>, and <code class="code">unblock/1</code> without being affected by the block. Any other attempt than those hitherto mentioned to update or read a blocked log suspends the calling process until the log is unblocked or returns an error message <code class="code">{blocked_log, Log}</code>, depending on whether the value of <code class="code">QueueLogRecords</code> is <code class="code">true</code> or <code class="code">false</code>. The default value of <code class="code">QueueLogRecords</code> is <code class="code">true</code>, which is used by <code class="code">block/1</code>. </p>  <h3 id="change_header-2" class="code">change_header(Log, Header) -&gt; ok | {error, Reason}</h3> <p>Types:</p>     <pre>Log = <a href="#type-log">log()</a>
Header = 
    {head, <a href="#type-dlog_head_opt">dlog_head_opt()</a>} |
    {head_func, MFA :: {atom(), atom(), list()}}
Reason = 
    no_such_log |
    nonode |
    {read_only_mode, Log} |
    {blocked_log, Log} |
    {badarg, head}</pre>

<p>The <code class="code">change_header/2</code> function changes the value of the <code class="code">head</code> or <code class="code">head_func</code> option of a disk log.</p>  <h3 id="change_notify-3" class="code">change_notify(Log, Owner, Notify) -&gt; ok | {error, Reason}</h3> <p>Types:</p>      <pre>Log = <a href="#type-log">log()</a>
Owner = pid()
Notify = boolean()
Reason = 
    no_such_log |
    nonode |
    {blocked_log, Log} |
    {badarg, notify} |
    {not_owner, Owner}</pre>

<p>The <code class="code">change_notify/3</code> function changes the value of the <code class="code">notify</code> option for an owner of a disk log. </p>  <h3 id="change_size-2" class="code">change_size(Log, Size) -&gt; ok | {error, Reason}</h3> <p>Types:</p>     <pre>Log = <a href="#type-log">log()</a>
Size = <a href="#type-dlog_size">dlog_size()</a>
Reason = 
    no_such_log |
    nonode |
    {read_only_mode, Log} |
    {blocked_log, Log} |
    {new_size_too_small, CurrentSize :: integer() &gt;= 1} |
    {badarg, size} |
    {file_error, <a href="../file/#type-filename">file:filename()</a>, <a href="#type-file_error">file_error()</a>}</pre>

<p>The <code class="code">change_size/2</code> function changes the size of an open log. For a halt log it is always possible to increase the size, but it is not possible to decrease the size to something less than the current size of the file. </p> <p>For a wrap log it is always possible to increase both the size and number of files, as long as the number of files does not exceed 65000. If the maximum number of files is decreased, the change will not be valid until the current file is full and the log wraps to the next file. The redundant files will be removed next time the log wraps around, i.e. starts to log to file number 1. </p> <p>As an example, assume that the old maximum number of files is 10 and that the new maximum number of files is 6. If the current file number is not greater than the new maximum number of files, the files 7 to 10 will be removed when file number 6 is full and the log starts to write to file number 1 again. Otherwise the files greater than the current file will be removed when the current file is full (e.g. if the current file is 8, the files 9 and 10); the files between new maximum number of files and the current file (i.e. files 7 and 8) will be removed next time file number 6 is full. </p> <p>If the size of the files is decreased the change will immediately affect the current log. It will not of course change the size of log files already full until next time they are used. </p> <p>If the log size is decreased for instance to save space, the function <code class="code">inc_wrap_file/1</code> can be used to force the log to wrap. </p>  <h3 id="bchunk-3" class="code">chunk(Log, Continuation) -&gt; chunk_ret()<br>chunk(Log, Continuation, N) -&gt; chunk_ret()<br>bchunk(Log, Continuation) -&gt; bchunk_ret()<br>bchunk(Log, Continuation, N) -&gt; bchunk_ret()</h3> <p>Types:</p>        <pre>Log = <a href="#type-log">log()</a>
Continuation = start | <a href="#type-continuation">continuation()</a>
N = integer() &gt;= 1 | infinity
chunk_ret() = 
    {Continuation2 :: <a href="#type-continuation">continuation()</a>, Terms :: [term()]} |
    {Continuation2 :: <a href="#type-continuation">continuation()</a>,
     Terms :: [term()],
     Badbytes :: integer() &gt;= 0} |
    eof |
    {error, Reason :: chunk_error_rsn()}
bchunk_ret() = 
    {Continuation2 :: <a href="#type-continuation">continuation()</a>, Binaries :: [binary()]} |
    {Continuation2 :: <a href="#type-continuation">continuation()</a>,
     Binaries :: [binary()],
     Badbytes :: integer() &gt;= 0} |
    eof |
    {error, Reason :: chunk_error_rsn()}
chunk_error_rsn() = 
    no_such_log |
    {format_external, <a href="#type-log">log()</a>} |
    {blocked_log, <a href="#type-log">log()</a>} |
    {badarg, continuation} |
    {not_internal_wrap, <a href="#type-log">log()</a>} |
    {corrupt_log_file, FileName :: <a href="../file/#type-filename">file:filename()</a>} |
    {file_error, <a href="../file/#type-filename">file:filename()</a>, <a href="#type-file_error">file_error()</a>}</pre>

<p>The <code class="code">chunk/2,3</code> and <code class="code">bchunk/2,3</code> functions make it possible to efficiently read the terms which have been appended to an internally formatted log. It minimizes disk I/O by reading 64 kilobyte chunks from the file. The <code class="code">bchunk/2,3</code> functions return the binaries read from the file; they do not call <code class="code">binary_to_term</code>. Otherwise the work just like <code class="code">chunk/2,3</code>. </p> <p>The first time <code class="code">chunk</code> (or <code class="code">bchunk</code>) is called, an initial continuation, the atom <code class="code">start</code>, must be provided. If there is a disk log process running on the current node, terms are read from that log, otherwise an individual distributed log on some other node is chosen, if such a log exists. </p> <p>When <code class="code">chunk/3</code> is called, <code class="code">N</code> controls the maximum number of terms that are read from the log in each chunk. Default is <code class="code">infinity</code>, which means that all the terms contained in the 64 kilobyte chunk are read. If less than <code class="code">N</code> terms are returned, this does not necessarily mean that the end of the file has been reached. </p> <p>The <code class="code">chunk</code> function returns a tuple <code class="code">{Continuation2, Terms}</code>, where <code class="code">Terms</code> is a list of terms found in the log. <code class="code">Continuation2</code> is yet another continuation which must be passed on to any subsequent calls to <code class="code">chunk</code>. With a series of calls to <code class="code">chunk</code> it is possible to extract all terms from a log. </p> <p>The <code class="code">chunk</code> function returns a tuple <code class="code">{Continuation2, Terms, Badbytes}</code> if the log is opened in read-only mode and the read chunk is corrupt. <code class="code">Badbytes</code> is the number of bytes in the file which were found not to be Erlang terms in the chunk. Note also that the log is not repaired. When trying to read chunks from a log opened in read-write mode, the tuple <code class="code">{corrupt_log_file, FileName}</code> is returned if the read chunk is corrupt. </p> <p><code class="code">chunk</code> returns <code class="code">eof</code> when the end of the log is reached, or <code class="code">{error, Reason}</code> if an error occurs. Should a wrap log file be missing, a message is output on the error log. </p> <p>When <code class="code">chunk/2,3</code> is used with wrap logs, the returned continuation may or may not be valid in the next call to <code class="code">chunk</code>. This is because the log may wrap and delete the file into which the continuation points. To make sure this does not happen, the log can be blocked during the search. </p>  <h3 id="chunk_info-1" class="code">chunk_info(Continuation) -&gt; InfoList | {error, Reason}</h3> <p>Types:</p>     <pre>Continuation = <a href="#type-continuation">continuation()</a>
InfoList = [{node, Node :: node()}, ...]
Reason = {no_continuation, Continuation}</pre>

<p>The <code class="code">chunk_info/1</code> function returns the following pair describing the chunk continuation returned by <code class="code">chunk/2,3</code>, <code class="code">bchunk/2,3</code>, or <code class="code">chunk_step/3</code>: </p> <ul> <li> <p><code class="code">{node, Node}</code>. Terms are read from the disk log running on <code class="code">Node</code>.</p> </li> </ul>  <h3 id="chunk_step-3" class="code">chunk_step(Log, Continuation, Step) -&gt;<br>              {ok, any()} | {error, Reason}</h3> <p>Types:</p>      <pre>Log = <a href="#type-log">log()</a>
Continuation = start | <a href="#type-continuation">continuation()</a>
Step = integer()
Reason = 
    no_such_log |
    end_of_log |
    {format_external, Log} |
    {blocked_log, Log} |
    {badarg, continuation} |
    {file_error, <a href="../file/#type-filename">file:filename()</a>, <a href="#type-file_error">file_error()</a>}</pre>

<p>The function <code class="code">chunk_step</code> can be used in conjunction with <code class="code">chunk/2,3</code> and <code class="code">bchunk/2,3</code> to search through an internally formatted wrap log. It takes as argument a continuation as returned by <code class="code">chunk/2,3</code>, <code class="code">bchunk/2,3</code>, or <code class="code">chunk_step/3</code>, and steps forward (or backward) <code class="code">Step</code> files in the wrap log. The continuation returned points to the first log item in the new current file. </p> <p>If the atom <code class="code">start</code> is given as continuation, a disk log to read terms from is chosen. A local or distributed disk log on the current node is preferred to an individual distributed log on some other node. </p> <p>If the wrap log is not full because all files have not been used yet, <code class="code">{error, end_of_log}</code> is returned if trying to step outside the log. </p>  <h3 id="close-1" class="code">close(Log) -&gt; ok | {error, close_error_rsn()}</h3> <p>Types:</p>    <pre>Log = <a href="#type-log">log()</a>
close_error_rsn() = 
    no_such_log |
    nonode |
    {file_error, <a href="../file/#type-filename">file:filename()</a>, <a href="#type-file_error">file_error()</a>}</pre>

<p id="close_1">The function <code class="code">close/1</code> closes a local or distributed disk log properly. An internally formatted log must be closed before the Erlang system is stopped, otherwise the log is regarded as unclosed and the automatic repair procedure will be activated next time the log is opened. </p> <p>The disk log process in not terminated as long as there are owners or users of the log. It should be stressed that each and every owner must close the log, possibly by terminating, and that any other process - not only the processes that have opened the log anonymously - can decrement the <code class="code">users</code> counter by closing the log. Attempts to close a log by a process that is not an owner are simply ignored if there are no users. </p> <p>If the log is blocked by the closing process, the log is also unblocked. </p>  <h3 id="format_error-1" class="code">format_error(Error) -&gt; io_lib:chars()</h3> <p>Types:</p>   <pre>Error = term()</pre>

<p>Given the error returned by any function in this module, the function <code class="code">format_error</code> returns a descriptive string of the error in English. For file errors, the function <code class="code">format_error/1</code> in the <code class="code">file</code> module is called.</p>  <h3 id="inc_wrap_file-1" class="code">inc_wrap_file(Log) -&gt; ok | {error, inc_wrap_error_rsn()}</h3> <p>Types:</p>     <pre>Log = <a href="#type-log">log()</a>
inc_wrap_error_rsn() = 
    no_such_log |
    nonode |
    {read_only_mode, <a href="#type-log">log()</a>} |
    {blocked_log, <a href="#type-log">log()</a>} |
    {halt_log, <a href="#type-log">log()</a>} |
    {invalid_header, <a href="#type-invalid_header">invalid_header()</a>} |
    {file_error, <a href="../file/#type-filename">file:filename()</a>, <a href="#type-file_error">file_error()</a>}
invalid_header() = term()</pre>

<p>The <code class="code">inc_wrap_file/1</code> function forces the internally formatted disk log to start logging to the next log file. It can be used, for instance, in conjunction with <code class="code">change_size/2</code> to reduce the amount of disk space allocated by the disk log. </p> <p>The owners that subscribe to notifications will normally receive a <code class="code">wrap</code> message, but in case of an error with a reason tag of <code class="code">invalid_header</code> or <code class="code">file_error</code> an <code class="code">error_status</code> message will be sent.</p>  <h3 id="info-1" class="code">info(Log) -&gt; InfoList | {error, no_such_log}</h3> <p>Types:</p>     <pre>Log = <a href="#type-log">log()</a>
InfoList = [dlog_info()]
dlog_info() = 
    {name, Log :: <a href="#type-log">log()</a>} |
    {file, File :: <a href="../file/#type-filename">file:filename()</a>} |
    {type, Type :: <a href="#type-dlog_type">dlog_type()</a>} |
    {format, Format :: <a href="#type-dlog_format">dlog_format()</a>} |
    {size, Size :: <a href="#type-dlog_size">dlog_size()</a>} |
    {mode, Mode :: <a href="#type-dlog_mode">dlog_mode()</a>} |
    {owners, [{pid(), Notify :: boolean()}]} |
    {users, Users :: integer() &gt;= 0} |
    {status,
     Status :: ok | {blocked, QueueLogRecords :: boolean()}} |
    {node, Node :: node()} |
    {distributed, Dist :: local | [node()]} |
    {head,
     Head ::
         none | {head, term()} | (MFA :: {atom(), atom(), list()})} |
    {no_written_items, NoWrittenItems :: integer() &gt;= 0} |
    {full, Full :: boolean} |
    {no_current_bytes, integer() &gt;= 0} |
    {no_current_items, integer() &gt;= 0} |
    {no_items, integer() &gt;= 0} |
    {current_file, integer() &gt;= 1} |
    {no_overflows,
     {SinceLogWasOpened :: integer() &gt;= 0,
      SinceLastInfo :: integer() &gt;= 0}}</pre>

<p>The <code class="code">info/1</code> function returns a list of <code class="code">{Tag, Value}</code> pairs describing the log. If there is a disk log process running on the current node, that log is used as source of information, otherwise an individual distributed log on some other node is chosen, if such a log exists. </p> <p>The following pairs are returned for all logs: </p> <ul> <li> <p><code class="code">{name, Log}</code>, where <code class="code">Log</code> is the name of the log as given by the <code class="code">open/1</code> option <code class="code">name</code>.</p> </li> <li> <p><code class="code">{file, File}</code>. For halt logs <code class="code">File</code> is the filename, and for wrap logs <code class="code">File</code> is the base name.</p> </li> <li> <p><code class="code">{type, Type}</code>, where <code class="code">Type</code> is the type of the log as given by the <code class="code">open/1</code> option <code class="code">type</code>.</p> </li> <li> <p><code class="code">{format, Format}</code>, where <code class="code">Format</code> is the format of the log as given by the <code class="code">open/1</code> option <code class="code">format</code>.</p> </li> <li> <p><code class="code">{size, Size}</code>, where <code class="code">Size</code> is the size of the log as given by the <code class="code">open/1</code> option <code class="code">size</code>, or the size set by <code class="code">change_size/2</code>. The value set by <code class="code">change_size/2</code> is reflected immediately.</p> </li> <li> <p><code class="code">{mode, Mode}</code>, where <code class="code">Mode</code> is the mode of the log as given by the <code class="code">open/1</code> option <code class="code">mode</code>.</p> </li> <li> <p><code class="code">{owners, [{pid(), Notify}]}</code> where <code class="code">Notify</code> is the value set by the <code class="code">open/1</code> option <code class="code">notify</code> or the function <code class="code">change_notify/3</code> for the owners of the log.</p> </li> <li> <p><code class="code">{users, Users}</code> where <code class="code">Users</code> is the number of anonymous users of the log, see the <code class="code">open/1</code> option <code class="bold_code"><a href="#linkto">linkto</a></code>.</p> </li> <li> <p><code class="code">{status, Status}</code>, where <code class="code">Status</code> is <code class="code">ok</code> or <code class="code">{blocked, QueueLogRecords}</code> as set by the functions <code class="code">block/1,2</code> and <code class="code">unblock/1</code>.</p> </li> <li> <p><code class="code">{node, Node}</code>. The information returned by the current invocation of the <code class="code">info/1</code> function has been gathered from the disk log process running on <code class="code">Node</code>.</p> </li> <li> <p><code class="code">{distributed, Dist}</code>. If the log is local on the current node, then <code class="code">Dist</code> has the value <code class="code">local</code>, otherwise all nodes where the log is distributed are returned as a list.</p> </li> </ul> <p>The following pairs are returned for all logs opened in <code class="code">read_write</code> mode: </p> <ul> <li> <p><code class="code">{head, Head}</code>. Depending of the value of the <code class="code">open/1</code> options <code class="code">head</code> and <code class="code">head_func</code> or set by the function <code class="code">change_header/2</code>, the value of <code class="code">Head</code> is <code class="code">none</code> (default), <code class="code">{head, H}</code> (<code class="code">head</code> option) or <code class="code">{M,F,A}</code> (<code class="code">head_func</code> option).</p> </li> <li> <p><code class="code">{no_written_items, NoWrittenItems}</code>, where <code class="code">NoWrittenItems</code> is the number of items written to the log since the disk log process was created.</p> </li> </ul> <p>The following pair is returned for halt logs opened in <code class="code">read_write</code> mode: </p> <ul> <li> <p><code class="code">{full, Full}</code>, where <code class="code">Full</code> is <code class="code">true</code> or <code class="code">false</code> depending on whether the halt log is full or not.</p> </li> </ul> <p>The following pairs are returned for wrap logs opened in <code class="code">read_write</code> mode: </p> <ul> <li> <p><code class="code">{no_current_bytes, integer() &gt;= 0}</code> is the number of bytes written to the current wrap log file.</p> </li> <li> <p><code class="code">{no_current_items, integer() &gt;= 0}</code> is the number of items written to the current wrap log file, header inclusive.</p> </li> <li> <p><code class="code">{no_items, integer() &gt;= 0}</code> is the total number of items in all wrap log files.</p> </li> <li> <p><code class="code">{current_file, integer()}</code> is the ordinal for the current wrap log file in the range <code class="code">1..MaxNoFiles</code>, where <code class="code">MaxNoFiles</code> is given by the <code class="code">open/1</code> option <code class="code">size</code> or set by <code class="code">change_size/2</code>.</p> </li> <li> <p><code class="code">{no_overflows, {SinceLogWasOpened, SinceLastInfo}}</code>, where <code class="code">SinceLogWasOpened</code> (<code class="code">SinceLastInfo</code>) is the number of times a wrap log file has been filled up and a new one opened or <code class="code">inc_wrap_file/1</code> has been called since the disk log was last opened (<code class="code">info/1</code> was last called). The first time <code class="code">info/2</code> is called after a log was (re)opened or truncated, the two values are equal.</p> </li> </ul> <p>Note that the <code class="code">chunk/2,3</code>, <code class="code">bchunk/2,3</code>, and <code class="code">chunk_step/3</code> functions do not affect any value returned by <code class="code">info/1</code>. </p>  <h3 id="lclose-2" class="code">lclose(Log) -&gt; ok | {error, lclose_error_rsn()}<br>lclose(Log, Node) -&gt; ok | {error, lclose_error_rsn()}</h3> <p>Types:</p>     <pre>Log = <a href="#type-log">log()</a>
Node = node()
lclose_error_rsn() = 
    no_such_log | {file_error, <a href="../file/#type-filename">file:filename()</a>, <a href="#type-file_error">file_error()</a>}</pre>

<p>The function <code class="code">lclose/1</code> closes a local log or an individual distributed log on the current node. The function <code class="code">lclose/2</code> closes an individual distributed log on the specified node if the node is not the current one. <code class="code">lclose(Log)</code> is equivalent to <code class="code">lclose(Log, node())</code>. See also <code class="bold_code"><a href="#close_1">close/1</a></code>. </p> <p>If there is no log with the given name on the specified node, <code class="code">no_such_log</code> is returned. </p>  <h3 id="blog-2" class="code">log(Log, Term) -&gt; ok | {error, Reason :: log_error_rsn()}<br>blog(Log, Bytes) -&gt; ok | {error, Reason :: log_error_rsn()}</h3> <p>Types:</p>      <pre>Log = <a href="#type-log">log()</a>
Term = term()
Bytes = <a href="#type-bytes">bytes()</a>
log_error_rsn() = 
    no_such_log |
    nonode |
    {read_only_mode, <a href="#type-log">log()</a>} |
    {format_external, <a href="#type-log">log()</a>} |
    {blocked_log, <a href="#type-log">log()</a>} |
    {full, <a href="#type-log">log()</a>} |
    {invalid_header, <a href="#type-invalid_header">invalid_header()</a>} |
    {file_error, <a href="../file/#type-filename">file:filename()</a>, <a href="#type-file_error">file_error()</a>}</pre>

<p>The <code class="code">log/2</code> and <code class="code">blog/2</code> functions synchronously append a term to a disk log. They return <code class="code">ok</code> or <code class="code">{error, Reason}</code> when the term has been written to disk. If the log is distributed, <code class="code">ok</code> is always returned, unless all nodes are down. Terms are written by means of the ordinary <code class="code">write()</code> function of the operating system. Hence, there is no guarantee that the term has actually been written to the disk, it might linger in the operating system kernel for a while. To make sure the item is actually written to disk, the <code class="code">sync/1</code> function must be called. </p> <p>The <code class="code">log/2</code> function is used for internally formatted logs, and <code class="code">blog/2</code> for externally formatted logs. <code class="code">blog/2</code> can be used for internally formatted logs as well provided the binary was constructed with a call to <code class="code">term_to_binary/1</code>. </p> <p>The owners that subscribe to notifications will be notified of an error with an <code class="code">error_status</code> message if the error reason tag is <code class="code">invalid_header</code> or <code class="code">file_error</code>. </p>  <h3 id="blog_terms-2" class="code">log_terms(Log, TermList) -&gt;<br>             ok | {error, Resaon :: log_error_rsn()}<br>blog_terms(Log, BytesList) -&gt;<br>              ok | {error, Reason :: log_error_rsn()}</h3> <p>Types:</p>      <pre>Log = <a href="#type-log">log()</a>
TermList = [term()]
BytesList = [<a href="#type-bytes">bytes()</a>]
log_error_rsn() = 
    no_such_log |
    nonode |
    {read_only_mode, <a href="#type-log">log()</a>} |
    {format_external, <a href="#type-log">log()</a>} |
    {blocked_log, <a href="#type-log">log()</a>} |
    {full, <a href="#type-log">log()</a>} |
    {invalid_header, <a href="#type-invalid_header">invalid_header()</a>} |
    {file_error, <a href="../file/#type-filename">file:filename()</a>, <a href="#type-file_error">file_error()</a>}</pre>

<p>The <code class="code">log_terms/2</code> and <code class="code">blog_terms/2</code> functions synchronously append a list of items to the log. The benefit of using these functions rather than the <code class="code">log/2</code> and <code class="code">blog/2</code> functions is that of efficiency: the given list is split into as large sublists as possible (limited by the size of wrap log files), and each sublist is logged as one single item, which reduces the overhead. </p> <p>The <code class="code">log_terms/2</code> function is used for internally formatted logs, and <code class="code">blog_terms/2</code> for externally formatted logs. <code class="code">blog_terms/2</code> can be used for internally formatted logs as well provided the binaries were constructed with calls to <code class="code">term_to_binary/1</code>. </p> <p>The owners that subscribe to notifications will be notified of an error with an <code class="code">error_status</code> message if the error reason tag is <code class="code">invalid_header</code> or <code class="code">file_error</code>. </p>  <h3 id="open-1" class="code">open(ArgL) -&gt; open_ret() | dist_open_ret()</h3> <p>Types:</p>            <pre>ArgL = dlog_options()
dlog_options() = [dlog_option()]
dlog_option() = 
    {name, Log :: <a href="#type-log">log()</a>} |
    {file, FileName :: <a href="../file/#type-filename">file:filename()</a>} |
    {linkto, LinkTo :: none | pid()} |
    {repair, Repair :: true | false | truncate} |
    {type, Type :: dlog_type} |
    {format, Format :: <a href="#type-dlog_format">dlog_format()</a>} |
    {size, Size :: <a href="#type-dlog_size">dlog_size()</a>} |
    {distributed, Nodes :: [node()]} |
    {notify, boolean()} |
    {head, Head :: <a href="#type-dlog_head_opt">dlog_head_opt()</a>} |
    {head_func, MFA :: {atom(), atom(), list()}} |
    {mode, Mode :: <a href="#type-dlog_mode">dlog_mode()</a>}
open_ret() = ret() | {error, open_error_rsn()}
ret() = 
    {ok, Log :: <a href="#type-log">log()</a>} |
    {repaired,
     Log :: <a href="#type-log">log()</a>,
     {recovered, Rec :: integer() &gt;= 0},
     {badbytes, Bad :: integer() &gt;= 0}}
dist_open_ret() = 
    {[{node(), ret()}], [{node(), {error, dist_error_rsn()}}]}
dist_error_rsn() = nodedown | open_error_rsn()
open_error_rsn() = 
    no_such_log |
    {badarg, term()} |
    {size_mismatch,
     CurrentSize :: <a href="#type-dlog_size">dlog_size()</a>,
     NewSize :: <a href="#type-dlog_size">dlog_size()</a>} |
    {arg_mismatch,
     OptionName :: dlog_optattr(),
     CurrentValue :: term(),
     Value :: term()} |
    {name_already_open, Log :: <a href="#type-log">log()</a>} |
    {open_read_write, Log :: <a href="#type-log">log()</a>} |
    {open_read_only, Log :: <a href="#type-log">log()</a>} |
    {need_repair, Log :: <a href="#type-log">log()</a>} |
    {not_a_log_file, FileName :: <a href="../file/#type-filename">file:filename()</a>} |
    {invalid_index_file, FileName :: <a href="../file/#type-filename">file:filename()</a>} |
    {invalid_header, <a href="#type-invalid_header">invalid_header()</a>} |
    {file_error, <a href="../file/#type-filename">file:filename()</a>, <a href="#type-file_error">file_error()</a>} |
    {node_already_open, Log :: <a href="#type-log">log()</a>}
dlog_optattr() = 
    name |
    file |
    linkto |
    repair |
    type |
    format |
    size |
    distributed |
    notify |
    head |
    head_func |
    mode
dlog_size() = 
    infinity |
    integer() &gt;= 1 |
    {MaxNoBytes :: integer() &gt;= 1, MaxNoFiles :: integer() &gt;= 1}</pre>

<p>The <code class="code">ArgL</code> parameter is a list of options which have the following meanings:</p> <ul> <li> <p><code class="code">{name, Log}</code> specifies the name of the log. This is the name which must be passed on as a parameter in all subsequent logging operations. A name must always be supplied. </p> </li> <li> <p><code class="code">{file, FileName}</code> specifies the name of the file which will be used for logged terms. If this value is omitted and the name of the log is either an atom or a string, the file name will default to <code class="code">lists:concat([Log, ".LOG"])</code> for halt logs. For wrap logs, this will be the base name of the files. Each file in a wrap log will be called <code class="code">&lt;base_name&gt;.N</code>, where <code class="code">N</code> is an integer. Each wrap log will also have two files called <code class="code">&lt;base_name&gt;.idx</code> and <code class="code">&lt;base_name&gt;.siz</code>. </p> </li> <li> <p id="linkto"><code class="code">{linkto, LinkTo}</code>.  If <code class="code">LinkTo</code> is a pid, that pid becomes an owner of the log. If <code class="code">LinkTo</code> is <code class="code">none</code> the log records that it is used anonymously by some process by incrementing the <code class="code">users</code> counter. By default, the process which calls <code class="code">open/1</code> owns the log. </p> </li> <li> <p><code class="code">{repair, Repair}</code>. If <code class="code">Repair</code> is <code class="code">true</code>, the current log file will be repaired, if needed. As the restoration is initiated, a message is output on the error log. If <code class="code">false</code> is given, no automatic repair will be attempted. Instead, the tuple <code class="code">{error, {need_repair, Log}}</code> is returned if an attempt is made to open a corrupt log file. If <code class="code">truncate</code> is given, the log file will be truncated, creating an empty log. Default is <code class="code">true</code>, which has no effect on logs opened in read-only mode. </p> </li> <li> <p><code class="code">{type, Type}</code> is the type of the log. Default is <code class="code">halt</code>. </p> </li> <li> <p><code class="code">{format, Format}</code> specifies the format of the disk log. Default is <code class="code">internal</code>. </p> </li> <li> <p><code class="code">{size, Size}</code> specifies the size of the log. When a halt log has reached its maximum size, all attempts to log more items are rejected. The default size is <code class="code">infinity</code>, which for halt implies that there is no maximum size. For wrap logs, the <code class="code">Size</code> parameter may be either a pair <code class="code">{MaxNoBytes, MaxNoFiles}</code> or <code class="code">infinity</code>. In the latter case, if the files of an already existing wrap log with the same name can be found, the size is read from the existing wrap log, otherwise an error is returned. Wrap logs write at most <code class="code">MaxNoBytes</code> bytes on each file and use <code class="code">MaxNoFiles</code> files before starting all over with the first wrap log file. Regardless of <code class="code">MaxNoBytes</code>, at least the header (if there is one) and one item is written on each wrap log file before wrapping to the next file. When opening an existing wrap log, it is not necessary to supply a value for the option <code class="code">Size</code>, but any supplied value must equal the current size of the log, otherwise the tuple <code class="code">{error, {size_mismatch, CurrentSize, NewSize}}</code> is returned. </p> </li> <li> <p><code class="code">{distributed, Nodes}</code>. This option can be used for adding members to a distributed disk log. The default value is <code class="code">[]</code>, which means that the log is local on the current node. </p> </li> <li id="notify">  <p><code class="code">{notify, bool()}</code>. If <code class="code">true</code>, the owners of the log are notified when certain events occur in the log. Default is <code class="code">false</code>. The owners are sent one of the following messages when an event occurs: </p> <ul> <li> <p><code class="code">{disk_log, Node, Log, {wrap, NoLostItems}}</code> is sent when a wrap log has filled up one of its files and a new file is opened. <code class="code">NoLostItems</code> is the number of previously logged items that have been lost when truncating existing files. </p> </li> <li> <p><code class="code">{disk_log, Node, Log, {truncated, NoLostItems}}</code> is sent when a log has been truncated or reopened. For halt logs <code class="code">NoLostItems</code> is the number of items written on the log since the disk log process was created. For wrap logs <code class="code">NoLostItems</code> is the number of items on all wrap log files. </p> </li> <li> <p><code class="code">{disk_log, Node, Log, {read_only, Items}}</code> is sent when an asynchronous log attempt is made to a log file opened in read-only mode. <code class="code">Items</code> is the items from the log attempt. </p> </li> <li> <p><code class="code">{disk_log, Node, Log, {blocked_log, Items}}</code> is sent when an asynchronous log attempt is made to a blocked log that does not queue log attempts. <code class="code">Items</code> is the items from the log attempt. </p> </li> <li> <p><code class="code">{disk_log, Node, Log, {format_external, Items}}</code> is sent when <code class="code">alog/2</code> or <code class="code">alog_terms/2</code> is used for internally formatted logs. <code class="code">Items</code> is the items from the log attempt. </p> </li> <li> <p><code class="code">{disk_log, Node, Log, full}</code> is sent when an attempt to log items to a wrap log would write more bytes than the limit set by the <code class="code">size</code> option. </p> </li> <li> <p><code class="code">{disk_log, Node, Log, {error_status, Status}}</code> is sent when the error status changes. The error status is defined by the outcome of the last attempt to log items to a the log or to truncate the log or the last use of <code class="code">sync/1</code>, <code class="code">inc_wrap_file/1</code> or <code class="code">change_size/2</code>. <code class="code">Status</code> is one of <code class="code">ok</code> and <code class="code">{error, Error}</code>, the former being the initial value. </p> </li> </ul> </li> <li> <p><code class="code">{head, Head}</code> specifies a header to be written first on the log file. If the log is a wrap log, the item <code class="code">Head</code> is written first in each new file. <code class="code">Head</code> should be a term if the format is <code class="code">internal</code>, and a deep list of bytes (or a binary) otherwise. Default is <code class="code">none</code>, which means that no header is written first on the file. </p> </li> <li> <p><code class="code">{head_func, {M,F,A}}</code> specifies a function to be called each time a new log file is opened. The call <code class="code">M:F(A)</code> is assumed to return <code class="code">{ok, Head}</code>. The item <code class="code">Head</code> is written first in each file. <code class="code">Head</code> should be a term if the format is <code class="code">internal</code>, and a deep list of bytes (or a binary) otherwise. </p> </li> <li> <p><code class="code">{mode, Mode}</code> specifies if the log is to be opened in read-only or read-write mode. It defaults to <code class="code">read_write</code>. </p> </li> </ul> <p>The <code class="code">open/1</code> function returns <code class="code">{ok, Log}</code> if the log file was successfully opened. If the file was successfully repaired, the tuple <code class="code">{repaired, Log, {recovered, Rec}, {badbytes, Bad}}</code> is returned, where <code class="code">Rec</code> is the number of whole Erlang terms found in the file and <code class="code">Bad</code> is the number of bytes in the file which were non-Erlang terms. If the <code class="code">distributed</code> parameter was given, <code class="code">open/1</code> returns a list of successful replies and a list of erroneous replies. Each reply is tagged with the node name. </p> <p>When a disk log is opened in read-write mode, any existing log file is checked for. If there is none a new empty log is created, otherwise the existing file is opened at the position after the last logged item, and the logging of items will commence from there. If the format is <code class="code">internal</code> and the existing file is not recognized as an internally formatted log, a tuple <code class="code">{error, {not_a_log_file, FileName}}</code> is returned. </p> <p>The <code class="code">open/1</code> function cannot be used for changing the values of options of an already open log; when there are prior owners or users of a log, all option values except <code class="code">name</code>, <code class="code">linkto</code> and <code class="code">notify</code> are just checked against the values that have been supplied before as option values to <code class="code">open/1</code>, <code class="code">change_header/2</code>, <code class="code">change_notify/3</code> or <code class="code">change_size/2</code>. As a consequence, none of the options except <code class="code">name</code> is mandatory. If some given value differs from the current value, a tuple <code class="code">{error, {arg_mismatch, OptionName, CurrentValue, Value}}</code> is returned. Caution: an owner's attempt to open a log as owner once again is acknowledged with the return value <code class="code">{ok, Log}</code>, but the state of the disk log is not affected in any way. </p> <p>If a log with a given name is local on some node, and one tries to open the log distributed on the same node, then the tuple <code class="code">{error, {node_already_open, Log}}</code> is returned. The same tuple is returned if the log is distributed on some node, and one tries to open the log locally on the same node. Opening individual distributed disk logs for the first time adds those logs to a (possibly empty) distributed disk log. The option values supplied are used on all nodes mentioned by the <code class="code">distributed</code> option. Individual distributed logs know nothing about each other's option values, so each node can be given unique option values by creating a distributed log with several calls to <code class="code">open/1</code>. </p> <p>It is possible to open a log file more than once by giving different values to the option <code class="code">name</code> or by using the same file when distributing a log on different nodes. It is up to the user of the <code class="code">disk_log</code> module to ensure that no more than one disk log process has write access to any file, or the the file may be corrupted. </p> <p>If an attempt to open a log file for the first time fails, the disk log process terminates with the EXIT message <code class="code">{{failed,Reason},[{disk_log,open,1}]}</code>. The function returns <code class="code">{error, Reason}</code> for all other errors. </p>  <h3 id="pid2name-1" class="code">pid2name(Pid) -&gt; {ok, Log} | undefined</h3> <p>Types:</p>    <pre>Pid = pid()
Log = <a href="#type-log">log()</a></pre>

<p>The <code class="code">pid2name/1</code> function returns the name of the log given the pid of a disk log process on the current node, or <code class="code">undefined</code> if the given pid is not a disk log process. </p> <p>This function is meant to be used for debugging only. </p>  <h3 id="breopen-3" class="code">reopen(Log, File) -&gt; ok | {error, reopen_error_rsn()}<br>reopen(Log, File, Head) -&gt; ok | {error, reopen_error_rsn()}<br>breopen(Log, File, BHead) -&gt; ok | {error, reopen_error_rsn()}</h3> <p>Types:</p>       <pre>Log = <a href="#type-log">log()</a>
File = <a href="../file/#type-filename">file:filename()</a>
Head = term()
BHead = <a href="#type-bytes">bytes()</a>
reopen_error_rsn() = 
    no_such_log |
    nonode |
    {read_only_mode, <a href="#type-log">log()</a>} |
    {blocked_log, <a href="#type-log">log()</a>} |
    {same_file_name, <a href="#type-log">log()</a>} |
    {invalid_index_file, <a href="../file/#type-filename">file:filename()</a>} |
    {invalid_header, <a href="#type-invalid_header">invalid_header()</a>} |
    {file_error, <a href="../file/#type-filename">file:filename()</a>, <a href="#type-file_error">file_error()</a>}</pre>

<p>The <code class="code">reopen</code> functions first rename the log file to <code class="code">File</code> and then re-create a new log file. In case of a wrap log, <code class="code">File</code> is used as the base name of the renamed files. By default the header given to <code class="code">open/1</code> is written first in the newly opened log file, but if the <code class="code">Head</code> or the <code class="code">BHead</code> argument is given, this item is used instead. The header argument is used once only; next time a wrap log file is opened, the header given to <code class="code">open/1</code> is used. </p> <p>The <code class="code">reopen/2,3</code> functions are used for internally formatted logs, and <code class="code">breopen/3</code> for externally formatted logs. </p> <p>The owners that subscribe to notifications will receive a <code class="code">truncate</code> message. </p> <p>Upon failure to reopen the log, the disk log process terminates with the EXIT message <code class="code">{{failed,Error},[{disk_log,Fun,Arity}]}</code>, and other processes that have requests queued receive the message <code class="code">{disk_log, Node, {error, disk_log_stopped}}</code>. </p>  <h3 id="sync-1" class="code">sync(Log) -&gt; ok | {error, sync_error_rsn()}</h3> <p>Types:</p>    <pre>Log = <a href="#type-log">log()</a>
sync_error_rsn() = 
    no_such_log |
    nonode |
    {read_only_mode, <a href="#type-log">log()</a>} |
    {blocked_log, <a href="#type-log">log()</a>} |
    {file_error, <a href="../file/#type-filename">file:filename()</a>, <a href="#type-file_error">file_error()</a>}</pre>

<p>The <code class="code">sync/1</code> function ensures that the contents of the log are actually written to the disk. This is usually a rather expensive operation. </p>  <h3 id="btruncate-2" class="code">truncate(Log) -&gt; ok | {error, trunc_error_rsn()}<br>truncate(Log, Head) -&gt; ok | {error, trunc_error_rsn()}<br>btruncate(Log, BHead) -&gt; ok | {error, trunc_error_rsn()}</h3> <p>Types:</p>      <pre>Log = <a href="#type-log">log()</a>
Head = term()
BHead = <a href="#type-bytes">bytes()</a>
trunc_error_rsn() = 
    no_such_log |
    nonode |
    {read_only_mode, <a href="#type-log">log()</a>} |
    {blocked_log, <a href="#type-log">log()</a>} |
    {invalid_header, <a href="#type-invalid_header">invalid_header()</a>} |
    {file_error, <a href="../file/#type-filename">file:filename()</a>, <a href="#type-file_error">file_error()</a>}</pre>

<p>The <code class="code">truncate</code> functions remove all items from a disk log. If the <code class="code">Head</code> or the <code class="code">BHead</code> argument is given, this item is written first in the newly truncated log, otherwise the header given to <code class="code">open/1</code> is used. The header argument is only used once; next time a wrap log file is opened, the header given to <code class="code">open/1</code> is used. </p> <p>The <code class="code">truncate/1,2</code> functions are used for internally formatted logs, and <code class="code">btruncate/2</code> for externally formatted logs. </p> <p>The owners that subscribe to notifications will receive a <code class="code">truncate</code> message. </p> <p>If the attempt to truncate the log fails, the disk log process terminates with the EXIT message <code class="code">{{failed,Reason},[{disk_log,Fun,Arity}]}</code>, and other processes that have requests queued receive the message <code class="code">{disk_log, Node, {error, disk_log_stopped}}</code>. </p>  <h3 id="unblock-1" class="code">unblock(Log) -&gt; ok | {error, unblock_error_rsn()}</h3> <p>Types:</p>    <pre>Log = <a href="#type-log">log()</a>
unblock_error_rsn() = 
    no_such_log |
    nonode |
    {not_blocked, <a href="#type-log">log()</a>} |
    {not_blocked_by_pid, <a href="#type-log">log()</a>}</pre>

<p>The <code class="code">unblock/1</code> function unblocks a log. A log can only be unblocked by the blocking process. </p>  <h2 id="id110520">See Also</h2>  <p><code class="bold_code"><a href="../file/">file(3)</a></code>, <code class="bold_code"><a href="../pg2/">pg2(3)</a></code>, <code class="bold_code"><a href="../wrap_log_reader/">wrap_log_reader(3)</a></code></p>
<div class="_attribution">
  <p class="_attribution-p">
    © 1999–2016 Ericsson AB<br>Licensed under the Apache License, Version 2.0.<br>
    
  </p>
</div>

			</div>
		</div>
	</section>

	</div>
</body>
</html>
