
<!DOCTYPE HTML>

<html lang="en">

<head>
  <meta charset="utf-8">
  <title>File - Erlang 18 - W3cubDocs</title>
  
  <meta name="description" content=" file ">
  <meta name="keywords" content="file, -, erlang, erlang~18">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="http://docs.w3cub.com/erlang~18/lib/kernel-4.2/doc/html/file/">
  <link href="/favicon.png" rel="icon">
  <link type="text/css" rel="stylesheet" href="/assets/application-50364fff564ce3b6327021805f3f00e2957b441cf27f576a7dd4ff63bbc47047.css">
  <script type="text/javascript" src="/assets/application-db64bfd54ceb42be11af7995804cf4902548419ceb79d509b0b7d62c22d98e6f.js"></script>
  <script src="/json/erlang~18.js"></script>
  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-71174418-1']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>


</head>

<body>
	<div class="_app">
	<header class="_header">
  
  <form class="_search">
    <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
    <a class="_search-clear"></a>
    <div class="_search-tag"></div>
  </form>
  
  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/erlang~18/" class="_nav-link" title="" style="margin-left:0;">Erlang 18</a></span>
  
  <nav class="_nav">
    <a href="/app/" class="_nav-link ">App</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		<div class="_list">
			
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<div class="_page _erlang">
				
<h1>file</h1> <h2>Module</h2> <p class="REFBODY">file</p> <h2>Module summary</h2> <p class="REFBODY">File Interface Module</p> <h2>Description</h2> 
<p>The module <code class="code">file</code> provides an interface to the file system.</p> <p>On operating systems with thread support, it is possible to let file operations be performed in threads of their own, allowing other Erlang processes to continue executing in parallel with the file operations. See the command line flag <code class="code">+A</code> in <code class="bold_code">erl(1)</code>.</p> <p>With regard to file name encoding, the Erlang VM can operate in two modes. The current mode can be queried using the <code class="bold_code"><a href="#native_name_encoding">native_name_encoding/0</a></code> function. It returns either <code class="code">latin1</code> or <code class="code">utf8</code>.</p> <p>In the <code class="code">latin1</code> mode, the Erlang VM does not change the encoding of file names. In the <code class="code">utf8</code> mode, file names can contain Unicode characters greater than 255 and the VM will convert file names back and forth to the native file name encoding (usually UTF-8, but UTF-16 on Windows).</p> <p>The default mode depends on the operating system. Windows and MacOS X enforce consistent file name encoding and therefore the VM uses the <code class="code">utf8</code> mode.</p> <p>On operating systems with transparent naming (i.e. all Unix systems except MacOS X), the default will be <code class="code">utf8</code> if the terminal supports UTF-8, otherwise <code class="code">latin1</code>. The default may be overridden using the <code class="code">+fnl</code> (to force <code class="code">latin1</code> mode) or <code class="code">+fnu</code> (to force <code class="code">utf8</code> mode) when starting <code class="bold_code">erl</code>.</p> <p>On operating systems with transparent naming, files could be inconsistently named, i.e. some files are encoded in UTF-8 while others are encoded in (for example) iso-latin1. To be able to handle file systems with inconsistent naming when running in the <code class="code">utf8</code> mode, the concept of "raw file names" has been introduced.</p> <p>A raw file name is a file name given as a binary. The Erlang VM will perform no translation of a file name given as a binary on systems with transparent naming.</p> <p>When running in the <code class="code">utf8</code> mode, the <code class="code">file:list_dir/1</code> and <code class="code">file:read_link/1</code> functions will never return raw file names. Use the <code class="bold_code"><a href="#list_dir_all">list_dir_all/1</a></code> and <code class="bold_code"><a href="#read_link_all">read_link_all/1</a></code> functions to return all file names including raw file names.</p> <p>Also see <code class="bold_code">Notes about raw file names</code>.</p>  <h2>Data types</h2> <h3 class="code">deep_list() = [char() | atom() | <a href="#type-deep_list">deep_list()</a>]</h3> <p><code class="bold_code">fd()</code></p> 
<p id="type-fd"> A file descriptor representing a file opened in <code class="bold_code"><a href="#raw">raw</a></code> mode.</p>  <h3 class="code">filename() = string()</h3> <h3 class="code">filename_all() = string() | binary()</h3> <h3 class="code">io_device() = pid() | <a href="#type-fd">fd()</a>
</h3> 
<p>As returned by <code class="bold_code"><a href="#open-2">file:open/2</a></code>; <code class="code">pid()</code> is a process handling I/O-protocols.</p>  <h3 class="code">name() = string() | atom() | <a href="#type-deep_list">deep_list()</a>
</h3> 
<p>If VM is in Unicode filename mode, <code class="code">string()</code> and <code class="code">char()</code> are allowed to be &gt; 255. </p>  <h3 class="code">name_all() = <br>    string() | atom() | <a href="#type-deep_list">deep_list()</a> | (RawFilename :: binary())</h3> 
<p>If VM is in Unicode filename mode, <code class="code">string()</code> and <code class="code">char()</code> are allowed to be &gt; 255. <code class="code">RawFilename</code> is a filename not subject to Unicode translation, meaning that it can contain characters not conforming to the Unicode encoding expected from the filesystem (i.e. non-UTF-8 characters although the VM is started in Unicode filename mode). </p>  <h3 class="code">posix() = <br>    eacces |<br>    eagain |<br>    ebadf |<br>    ebusy |<br>    edquot |<br>    eexist |<br>    efault |<br>    efbig |<br>    eintr |<br>    einval |<br>    eio |<br>    eisdir |<br>    eloop |<br>    emfile |<br>    emlink |<br>    enametoolong |<br>    enfile |<br>    enodev |<br>    enoent |<br>    enomem |<br>    enospc |<br>    enotblk |<br>    enotdir |<br>    enotsup |<br>    enxio |<br>    eperm |<br>    epipe |<br>    erofs |<br>    espipe |<br>    esrch |<br>    estale |<br>    exdev</h3> 
<p>An atom which is named from the POSIX error codes used in Unix, and in the runtime libraries of most C compilers.</p>  <h3 class="code">date_time() = calendar:datetime()</h3> 
<p>Must denote a valid date and time.</p>  <h3 class="code">file_info() = <br>    #file_info{size = undefined | integer() &gt;= 0,<br>               type =<br>                   undefined |<br>                   device |<br>                   directory |<br>                   other |<br>                   regular |<br>                   symlink,<br>               access =<br>                   undefined | read | write | read_write | none,<br>               atime =<br>                   undefined |<br>                   <a href="../file/#type-date_time">file:date_time()</a> |<br>                   integer() &gt;= 0,<br>               mtime =<br>                   undefined |<br>                   <a href="../file/#type-date_time">file:date_time()</a> |<br>                   integer() &gt;= 0,<br>               ctime =<br>                   undefined |<br>                   <a href="../file/#type-date_time">file:date_time()</a> |<br>                   integer() &gt;= 0,<br>               mode = undefined | integer() &gt;= 0,<br>               links = undefined | integer() &gt;= 0,<br>               major_device = undefined | integer() &gt;= 0,<br>               minor_device = undefined | integer() &gt;= 0,<br>               inode = undefined | integer() &gt;= 0,<br>               uid = undefined | integer() &gt;= 0,<br>               gid = undefined | integer() &gt;= 0}</h3> <h3 class="code">location() = <br>    integer() |<br>    {bof, Offset :: integer()} |<br>    {cur, Offset :: integer()} |<br>    {eof, Offset :: integer()} |<br>    bof |<br>    cur |<br>    eof</h3> <h3 class="code">mode() = <br>    read |<br>    write |<br>    append |<br>    exclusive |<br>    raw |<br>    binary |<br>    {delayed_write,<br>     Size :: integer() &gt;= 0,<br>     Delay :: integer() &gt;= 0} |<br>    delayed_write |<br>    {read_ahead, Size :: integer() &gt;= 1} |<br>    read_ahead |<br>    compressed |<br>    {encoding, unicode:encoding()} |<br>    sync</h3> <h3 class="code">file_info_option() = <br>    {time, local} | {time, universal} | {time, posix} | raw</h3> <h2>Exports</h2> <h3 id="advise-4" class="code">advise(IoDevice, Offset, Length, Advise) -&gt; ok | {error, Reason}</h3> <p>Types:</p>        <pre>IoDevice = <a href="#type-io_device">io_device()</a>
Offset = Length = integer()

Advise = posix_file_advise()
Reason = <a href="#type-posix">posix()</a> | badarg
posix_file_advise() = 
    normal |
    sequential |
    random |
    no_reuse |
    will_need |
    dont_need</pre>

<p><code class="code">advise/4</code> can be used to announce an intention to access file data in a specific pattern in the future, thus allowing the operating system to perform appropriate optimizations.</p> <p>On some platforms, this function might have no effect.</p>  <h3 id="allocate-3" class="code">allocate(File, Offset, Length) -&gt; ok | {error, <a href="#type-posix">posix()</a>}</h3> <p>Types:</p>     <pre>File = <a href="#type-io_device">io_device()</a>
Offset = Length = integer() &gt;= 0</pre>

<p><code class="code">allocate/3</code> can be used to preallocate space for a file.</p> <p>This function only succeeds in platforms that implement this feature. When it succeeds, space is preallocated for the file but the file size might not be updated. This behaviour depends on the preallocation implementation. To guarantee the file size is updated one must truncate the file to the new size.</p>  <h3 id="change_group-2" class="code">change_group(Filename, Gid) -&gt; ok | {error, Reason}</h3> <p>Types:</p>     <pre>Filename = <a href="#type-name_all">name_all()</a>
Gid = integer()
Reason = <a href="#type-posix">posix()</a> | badarg</pre>

<p>Changes group of a file. See <code class="bold_code"><a href="#write_file_info-2">write_file_info/2</a></code>.</p>  <h3 id="change_mode-2" class="code">change_mode(Filename, Mode) -&gt; ok | {error, Reason}</h3> <p>Types:</p>     <pre>Filename = <a href="#type-name_all">name_all()</a>
Mode = integer()
Reason = <a href="#type-posix">posix()</a> | badarg</pre>

<p>Changes permissions of a file. See <code class="bold_code"><a href="#write_file_info-2">write_file_info/2</a></code>.</p>  <h3 id="change_owner-2" class="code">change_owner(Filename, Uid) -&gt; ok | {error, Reason}</h3> <p>Types:</p>     <pre>Filename = <a href="#type-name_all">name_all()</a>
Uid = integer()
Reason = <a href="#type-posix">posix()</a> | badarg</pre>

<p>Changes owner of a file. See <code class="bold_code"><a href="#write_file_info-2">write_file_info/2</a></code>.</p>  <h3 id="change_owner-3" class="code">change_owner(Filename, Uid, Gid) -&gt; ok | {error, Reason}</h3> <p>Types:</p>      <pre>Filename = <a href="#type-name_all">name_all()</a>
Uid = Gid = integer()

Reason = <a href="#type-posix">posix()</a> | badarg</pre>

<p>Changes owner and group of a file. See <code class="bold_code"><a href="#write_file_info-2">write_file_info/2</a></code>.</p>  <h3 id="change_time-2" class="code">change_time(Filename, Mtime) -&gt; ok | {error, Reason}</h3> <p>Types:</p>     <pre>Filename = <a href="#type-name_all">name_all()</a>
Mtime = <a href="#type-date_time">date_time()</a>
Reason = <a href="#type-posix">posix()</a> | badarg</pre>

<p>Changes the modification and access times of a file. See <code class="bold_code"><a href="#write_file_info-2">write_file_info/2</a></code>.</p>  <h3 id="change_time-3" class="code">change_time(Filename, Atime, Mtime) -&gt; ok | {error, Reason}</h3> <p>Types:</p>      <pre>Filename = <a href="#type-name_all">name_all()</a>
Atime = Mtime = <a href="#type-date_time">date_time()</a>

Reason = <a href="#type-posix">posix()</a> | badarg</pre>

<p>Changes the modification and last access times of a file. See <code class="bold_code"><a href="#write_file_info-2">write_file_info/2</a></code>.</p>  <h3 id="close-1" class="code">close(IoDevice) -&gt; ok | {error, Reason}</h3> <p>Types:</p>    <pre>IoDevice = <a href="#type-io_device">io_device()</a>
Reason = <a href="#type-posix">posix()</a> | badarg | terminated</pre>

<p>Closes the file referenced by <code class="code">IoDevice</code>. It mostly returns <code class="code">ok</code>, expect for some severe errors such as out of memory.</p> <p>Note that if the option <code class="code">delayed_write</code> was used when opening the file, <code class="code">close/1</code> might return an old write error and not even try to close the file. See <code class="bold_code"><a href="#open-2">open/2</a></code>.</p>  <h3 id="consult-1" class="code">consult(Filename) -&gt; {ok, Terms} | {error, Reason}</h3> <p>Types:</p>     <pre>Filename = <a href="#type-name_all">name_all()</a>
Terms = [term()]
Reason = 
    <a href="#type-posix">posix()</a> |
    badarg |
    terminated |
    system_limit |
    {Line :: integer(), Mod :: module(), Term :: term()}</pre>

<p>Reads Erlang terms, separated by '.', from <code class="code">Filename</code>. Returns one of the following:</p> <dl> <dt><strong><code class="code">{ok, Terms}</code></strong></dt> <dd> <p>The file was successfully read.</p> </dd> <dt><strong><code class="code">{error, atom()}</code></strong></dt> <dd> <p>An error occurred when opening the file or reading it. See <code class="bold_code"><a href="#open-2">open/2</a></code> for a list of typical error codes.</p> </dd> <dt><strong><code class="code">{error, {Line, Mod, Term}}</code></strong></dt> <dd> <p>An error occurred when interpreting the Erlang terms in the file. Use <code class="code">format_error/1</code> to convert the three-element tuple to an English description of the error.</p> </dd> </dl> <p>Example:</p> <div class="example"><pre>f.txt:  {person, "kalle", 25}.
        {person, "pelle", 30}.</pre></div> <div class="example"><pre>1&gt; file:consult("f.txt").
{ok,[{person,"kalle",25},{person,"pelle",30}]}</pre></div> <p>The encoding of of <code class="code">Filename</code> can be set by a comment as described in <code class="bold_code">epp(3)</code>.</p>  <h3 id="copy-3" class="code">copy(Source, Destination) -&gt; {ok, BytesCopied} | {error, Reason}<br>copy(Source, Destination, ByteCount) -&gt;<br>        {ok, BytesCopied} | {error, Reason}</h3> <p>Types:</p>         <pre>Source = Destination = <a href="#type-io_device">io_device()</a> | Filename | {Filename, Modes}

Filename = <a href="#type-name_all">name_all()</a>
Modes = [<a href="#type-mode">mode()</a>]
ByteCount = integer() &gt;= 0 | infinity
BytesCopied = integer() &gt;= 0
Reason = <a href="#type-posix">posix()</a> | badarg | terminated</pre>

<p>Copies <code class="code">ByteCount</code> bytes from <code class="code">Source</code> to <code class="code">Destination</code>. <code class="code">Source</code> and <code class="code">Destination</code> refer to either filenames or IO devices from e.g. <code class="code">open/2</code>. <code class="code">ByteCount</code> defaults to <code class="code">infinity</code>, denoting an infinite number of bytes.</p> <p>The argument <code class="code">Modes</code> is a list of possible modes, see <code class="bold_code"><a href="#open-2">open/2</a></code>, and defaults to [].</p> <p>If both <code class="code">Source</code> and <code class="code">Destination</code> refer to filenames, the files are opened with <code class="code">[read, binary]</code> and <code class="code">[write, binary]</code> prepended to their mode lists, respectively, to optimize the copy.</p> <p>If <code class="code">Source</code> refers to a filename, it is opened with <code class="code">read</code> mode prepended to the mode list before the copy, and closed when done.</p> <p>If <code class="code">Destination</code> refers to a filename, it is opened with <code class="code">write</code> mode prepended to the mode list before the copy, and closed when done.</p> <p>Returns <code class="code">{ok, BytesCopied}</code> where <code class="code">BytesCopied</code> is the number of bytes that actually was copied, which may be less than <code class="code">ByteCount</code> if end of file was encountered on the source. If the operation fails, <code class="code">{error, Reason}</code> is returned.</p> <p>Typical error reasons: As for <code class="code">open/2</code> if a file had to be opened, and as for <code class="code">read/2</code> and <code class="code">write/2</code>.</p>  <h3 id="del_dir-1" class="code">del_dir(Dir) -&gt; ok | {error, Reason}</h3> <p>Types:</p>    <pre>Dir = <a href="#type-name_all">name_all()</a>
Reason = <a href="#type-posix">posix()</a> | badarg</pre>

<p>Tries to delete the directory <code class="code">Dir</code>. The directory must be empty before it can be deleted. Returns <code class="code">ok</code> if successful.</p> <p>Typical error reasons are:</p> <dl> <dt><strong><code class="code">eacces</code></strong></dt> <dd> <p>Missing search or write permissions for the parent directories of <code class="code">Dir</code>.</p> </dd> <dt><strong><code class="code">eexist</code></strong></dt> <dd> <p>The directory is not empty.</p> </dd> <dt><strong><code class="code">enoent</code></strong></dt> <dd> <p>The directory does not exist.</p> </dd> <dt><strong><code class="code">enotdir</code></strong></dt> <dd> <p>A component of <code class="code">Dir</code> is not a directory. On some platforms, <code class="code">enoent</code> is returned instead.</p> </dd> <dt><strong><code class="code">einval</code></strong></dt> <dd> <p>Attempt to delete the current directory. On some platforms, <code class="code">eacces</code> is returned instead.</p> </dd> </dl>  <h3 id="delete-1" class="code">delete(Filename) -&gt; ok | {error, Reason}</h3> <p>Types:</p>    <pre>Filename = <a href="#type-name_all">name_all()</a>
Reason = <a href="#type-posix">posix()</a> | badarg</pre>

<p>Tries to delete the file <code class="code">Filename</code>. Returns <code class="code">ok</code> if successful.</p> <p>Typical error reasons are:</p> <dl> <dt><strong><code class="code">enoent</code></strong></dt> <dd> <p>The file does not exist.</p> </dd> <dt><strong><code class="code">eacces</code></strong></dt> <dd> <p>Missing permission for the file or one of its parents.</p> </dd> <dt><strong><code class="code">eperm</code></strong></dt> <dd> <p>The file is a directory and the user is not super-user.</p> </dd> <dt><strong><code class="code">enotdir</code></strong></dt> <dd> <p>A component of the file name is not a directory. On some platforms, <code class="code">enoent</code> is returned instead.</p> </dd> <dt><strong><code class="code">einval</code></strong></dt> <dd> <p><code class="code">Filename</code> had an improper type, such as tuple.</p> </dd> </dl> <div class="warning"> <div class="label">Warning</div> <div class="content">

<p>In a future release, a bad type for the <code class="code">Filename</code> argument will probably generate an exception.</p> </div> </div>  <h3 id="eval-1" class="code">eval(Filename) -&gt; ok | {error, Reason}</h3> <p>Types:</p>    <pre>Filename = <a href="#type-name_all">name_all()</a>
Reason = 
    <a href="#type-posix">posix()</a> |
    badarg |
    terminated |
    system_limit |
    {Line :: integer(), Mod :: module(), Term :: term()}</pre>

<p>Reads and evaluates Erlang expressions, separated by '.' (or ',', a sequence of expressions is also an expression), from <code class="code">Filename</code>. The actual result of the evaluation is not returned; any expression sequence in the file must be there for its side effect. Returns one of the following:</p> <dl> <dt><strong><code class="code">ok</code></strong></dt> <dd> <p>The file was read and evaluated.</p> </dd> <dt><strong><code class="code">{error, atom()}</code></strong></dt> <dd> <p>An error occurred when opening the file or reading it. See <code class="code">open/2</code> for a list of typical error codes.</p> </dd> <dt><strong><code class="code">{error, {Line, Mod, Term}}</code></strong></dt> <dd> <p>An error occurred when interpreting the Erlang expressions in the file. Use <code class="code">format_error/1</code> to convert the three-element tuple to an English description of the error.</p> </dd> </dl> <p>The encoding of of <code class="code">Filename</code> can be set by a comment as described in <code class="bold_code">epp(3)</code>.</p>  <h3 id="eval-2" class="code">eval(Filename, Bindings) -&gt; ok | {error, Reason}</h3> <p>Types:</p>     <pre>Filename = <a href="#type-name_all">name_all()</a>
Bindings = erl_eval:binding_struct()
Reason = 
    <a href="#type-posix">posix()</a> |
    badarg |
    terminated |
    system_limit |
    {Line :: integer(), Mod :: module(), Term :: term()}</pre>

<p>The same as <code class="code">eval/1</code> but the variable bindings <code class="code">Bindings</code> are used in the evaluation. See <code class="bold_code">erl_eval(3)</code> about variable bindings.</p>  <h3 id="format_error-1" class="code">format_error(Reason) -&gt; Chars</h3> <p>Types:</p>    <pre>Reason = 
    <a href="#type-posix">posix()</a> |
    badarg |
    terminated |
    system_limit |
    {Line :: integer(), Mod :: module(), Term :: term()}
Chars = string()</pre>

<p>Given the error reason returned by any function in this module, returns a descriptive string of the error in English.</p>  <h3 id="get_cwd-0" class="code">get_cwd() -&gt; {ok, Dir} | {error, Reason}</h3> <p>Types:</p>    <pre>Dir = <a href="#type-filename">filename()</a>
Reason = <a href="#type-posix">posix()</a></pre>

<p>Returns <code class="code">{ok, Dir}</code>, where <code class="code">Dir</code> is the current working directory of the file server.</p> <div class="note"> <div class="label">Note</div> <div class="content">

<p>In rare circumstances, this function can fail on Unix. It may happen if read permission does not exist for the parent directories of the current directory.</p> </div> </div> <p>Typical error reasons are:</p> <dl> <dt><strong><code class="code">eacces</code></strong></dt> <dd> <p>Missing read permission for one of the parents of the current directory.</p> </dd> </dl>  <h3 id="get_cwd-1" class="code">get_cwd(Drive) -&gt; {ok, Dir} | {error, Reason}</h3> <p>Types:</p>     <pre>Drive = string()
Dir = <a href="#type-filename">filename()</a>
Reason = <a href="#type-posix">posix()</a> | badarg</pre>

<p><code class="code">Drive</code> should be of the form "<code class="code">Letter</code><code class="code">:</code>", for example "c:". Returns <code class="code">{ok, Dir}</code> or <code class="code">{error, Reason}</code>, where <code class="code">Dir</code> is the current working directory of the drive specified.</p> <p>This function returns <code class="code">{error, enotsup}</code> on platforms which have no concept of current drive (Unix, for example).</p> <p>Typical error reasons are:</p> <dl> <dt><strong><code class="code">enotsup</code></strong></dt> <dd> <p>The operating system has no concept of drives.</p> </dd> <dt><strong><code class="code">eacces</code></strong></dt> <dd> <p>The drive does not exist.</p> </dd> <dt><strong><code class="code">einval</code></strong></dt> <dd> <p>The format of <code class="code">Drive</code> is invalid.</p> </dd> </dl>  <h3 id="list_dir-1" class="code">list_dir(Dir) -&gt; {ok, Filenames} | {error, Reason}</h3> <p>Types:</p>     <pre>Dir = <a href="#type-name_all">name_all()</a>
Filenames = [<a href="#type-filename">filename()</a>]
Reason = 
    <a href="#type-posix">posix()</a> |
    badarg |
    {no_translation, Filename :: unicode:latin1_binary()}</pre>

<p>Lists all files in a directory, <strong>except</strong> files with "raw" names. Returns <code class="code">{ok, Filenames}</code> if successful. Otherwise, it returns <code class="code">{error, Reason}</code>. <code class="code">Filenames</code> is a list of the names of all the files in the directory. The names are not sorted.</p> <p>Typical error reasons are:</p> <dl> <dt><strong><code class="code">eacces</code></strong></dt> <dd> <p>Missing search or write permissions for <code class="code">Dir</code> or one of its parent directories.</p> </dd> <dt><strong><code class="code">enoent</code></strong></dt> <dd> <p>The directory does not exist.</p> </dd> <dt><strong><code class="code">{no_translation, Filename}</code></strong></dt> <dd> <p><code class="code">Filename</code> is a <code class="code">binary()</code> with characters coded in ISO-latin-1 and the VM was started with the parameter <code class="code">+fnue</code>.</p> </dd> </dl>  <h3 id="list_dir_all-1" class="code">list_dir_all(Dir) -&gt; {ok, Filenames} | {error, Reason}</h3> <p>Types:</p>     <pre>Dir = <a href="#type-name_all">name_all()</a>
Filenames = [<a href="#type-filename_all">filename_all()</a>]
Reason = <a href="#type-posix">posix()</a> | badarg</pre>

<p id="list_dir_all">Lists all the files in a directory, including files with "raw" names. Returns <code class="code">{ok, Filenames}</code> if successful. Otherwise, it returns <code class="code">{error, Reason}</code>. <code class="code">Filenames</code> is a list of the names of all the files in the directory. The names are not sorted.</p> <p>Typical error reasons are:</p> <dl> <dt><strong><code class="code">eacces</code></strong></dt> <dd> <p>Missing search or write permissions for <code class="code">Dir</code> or one of its parent directories.</p> </dd> <dt><strong><code class="code">enoent</code></strong></dt> <dd> <p>The directory does not exist.</p> </dd> </dl>  <h3 id="make_dir-1" class="code">make_dir(Dir) -&gt; ok | {error, Reason}</h3> <p>Types:</p>    <pre>Dir = <a href="#type-name_all">name_all()</a>
Reason = <a href="#type-posix">posix()</a> | badarg</pre>

<p>Tries to create the directory <code class="code">Dir</code>. Missing parent directories are <strong>not</strong> created. Returns <code class="code">ok</code> if successful.</p> <p>Typical error reasons are:</p> <dl> <dt><strong><code class="code">eacces</code></strong></dt> <dd> <p>Missing search or write permissions for the parent directories of <code class="code">Dir</code>.</p> </dd> <dt><strong><code class="code">eexist</code></strong></dt> <dd> <p>There is already a file or directory named <code class="code">Dir</code>.</p> </dd> <dt><strong><code class="code">enoent</code></strong></dt> <dd> <p>A component of <code class="code">Dir</code> does not exist.</p> </dd> <dt><strong><code class="code">enospc</code></strong></dt> <dd> <p>There is a no space left on the device.</p> </dd> <dt><strong><code class="code">enotdir</code></strong></dt> <dd> <p>A component of <code class="code">Dir</code> is not a directory. On some platforms, <code class="code">enoent</code> is returned instead.</p> </dd> </dl>  <h3 id="make_link-2" class="code">make_link(Existing, New) -&gt; ok | {error, Reason}</h3> <p>Types:</p>     <pre>Existing = New = <a href="#type-name_all">name_all()</a>

Reason = <a href="#type-posix">posix()</a> | badarg</pre>

<p>Makes a hard link from <code class="code">Existing</code> to <code class="code">New</code>, on platforms that support links (Unix and Windows). This function returns <code class="code">ok</code> if the link was successfully created, or <code class="code">{error, Reason}</code>. On platforms that do not support links, <code class="code">{error,enotsup}</code> is returned.</p> <p>Typical error reasons:</p> <dl> <dt><strong><code class="code">eacces</code></strong></dt> <dd> <p>Missing read or write permissions for the parent directories of <code class="code">Existing</code> or <code class="code">New</code>.</p> </dd> <dt><strong><code class="code">eexist</code></strong></dt> <dd> <p><code class="code">New</code> already exists.</p> </dd> <dt><strong><code class="code">enotsup</code></strong></dt> <dd> <p>Hard links are not supported on this platform.</p> </dd> </dl>  <h3 id="make_symlink-2" class="code">make_symlink(Existing, New) -&gt; ok | {error, Reason}</h3> <p>Types:</p>     <pre>Existing = New = <a href="#type-name_all">name_all()</a>

Reason = <a href="#type-posix">posix()</a> | badarg</pre>

<p>This function creates a symbolic link <code class="code">New</code> to the file or directory <code class="code">Existing</code>, on platforms that support symbolic links (most Unix systems and Windows beginning with Vista). <code class="code">Existing</code> need not exist. This function returns <code class="code">ok</code> if the link was successfully created, or <code class="code">{error, Reason}</code>. On platforms that do not support symbolic links, <code class="code">{error, enotsup}</code> is returned.</p> <p>Typical error reasons:</p> <dl> <dt><strong><code class="code">eacces</code></strong></dt> <dd> <p>Missing read or write permissions for the parent directories of <code class="code">Existing</code> or <code class="code">New</code>.</p> </dd> <dt><strong><code class="code">eexist</code></strong></dt> <dd> <p><code class="code">New</code> already exists.</p> </dd> <dt><strong><code class="code">enotsup</code></strong></dt> <dd> <p>Symbolic links are not supported on this platform.</p> </dd> <dt><strong><code class="code">eperm</code></strong></dt> <dd> <p>User does not have privileges to create symbolic links (<code class="code">SeCreateSymbolicLinkPrivilege</code> on Windows).</p> </dd> </dl>  <h3 id="native_name_encoding-0" class="code">native_name_encoding() -&gt; latin1 | utf8</h3> 
<p id="native_name_encoding">This function returns the file name encoding mode. If it is <code class="code">latin1</code>, the system does no translation of file names. If it is <code class="code">utf8</code>, file names will be converted back and forth to the native file name encoding (usually UTF-8, but UTF-16 on Windows).</p>  <h3 id="open-2" class="code">open(File, Modes) -&gt; {ok, IoDevice} | {error, Reason}</h3> <p>Types:</p>       <pre>File = Filename | iodata()
Filename = <a href="#type-name_all">name_all()</a>
Modes = [<a href="#type-mode">mode()</a> | ram]
IoDevice = <a href="#type-io_device">io_device()</a>
Reason = <a href="#type-posix">posix()</a> | badarg | system_limit</pre>

<p>Opens the file <code class="code">File</code> in the mode determined by <code class="code">Modes</code>, which may contain one or more of the following items:</p> <dl> <dt><strong><code class="code">read</code></strong></dt> <dd> <p>The file, which must exist, is opened for reading.</p> </dd> <dt><strong><code class="code">write</code></strong></dt> <dd> <p>The file is opened for writing. It is created if it does not exist. If the file exists, and if <code class="code">write</code> is not combined with <code class="code">read</code>, the file will be truncated.</p> </dd> <dt><strong><code class="code">append</code></strong></dt> <dd> <p>The file will be opened for writing, and it will be created if it does not exist. Every write operation to a file opened with <code class="code">append</code> will take place at the end of the file.</p> </dd> <dt><strong><code class="code">exclusive</code></strong></dt> <dd> <p>The file, when opened for writing, is created if it does not exist. If the file exists, open will return <code class="code">{error, eexist}</code>.</p> <div class="warning"> <div class="label">Warning</div> <div class="content">

<p>This option does not guarantee exclusiveness on file systems that do not support O_EXCL properly, such as NFS. Do not depend on this option unless you know that the file system supports it (in general, local file systems should be safe).</p>
</div> </div> </dd> <dt><strong><code class="code">raw</code></strong></dt> <dd> <p id="raw"> The <code class="code">raw</code> option allows faster access to a file, because no Erlang process is needed to handle the file. However, a file opened in this way has the following limitations:</p> <ul> <li>The functions in the <code class="code">io</code> module cannot be used, because they can only talk to an Erlang process. Instead, use the <code class="code">read/2</code>, <code class="code">read_line/1</code> and <code class="code">write/2</code> functions.</li> <li>Especially if <code class="code">read_line/1</code> is to be used on a <code class="code">raw</code> file, it is recommended to combine this option with the <code class="code">{read_ahead, Size}</code> option as line oriented I/O is inefficient without buffering.</li> <li>Only the Erlang process which opened the file can use it.</li> <li>A remote Erlang file server cannot be used; the computer on which the Erlang node is running must have access to the file system (directly or through NFS).</li> </ul> </dd> <dt><strong><code class="code">binary</code></strong></dt> <dd> <p>When this option has been given, read operations on the file will return binaries rather than lists.</p> </dd> <dt><strong><code class="code">{delayed_write, Size, Delay}</code></strong></dt> <dd> <p>If this option is used, the data in subsequent <code class="code">write/2</code> calls is buffered until there are at least <code class="code">Size</code> bytes buffered, or until the oldest buffered data is <code class="code">Delay</code> milliseconds old. Then all buffered data is written in one operating system call. The buffered data is also flushed before some other file operation than <code class="code">write/2</code> is executed.</p> <p>The purpose of this option is to increase performance by reducing the number of operating system calls, so the <code class="code">write/2</code> calls should be for sizes significantly less than <code class="code">Size</code>, and not interspersed by to many other file operations, for this to happen.</p> <p>When this option is used, the result of <code class="code">write/2</code> calls may prematurely be reported as successful, and if a write error should actually occur the error is reported as the result of the next file operation, which is not executed.</p> <p>For example, when <code class="code">delayed_write</code> is used, after a number of <code class="code">write/2</code> calls, <code class="code">close/1</code> might return <code class="code">{error, enospc}</code> because there was not enough space on the disc for previously written data, and <code class="code">close/1</code> should probably be called again since the file is still open.</p> </dd> <dt><strong><code class="code">delayed_write</code></strong></dt> <dd> <p>The same as <code class="code">{delayed_write, Size, Delay}</code> with reasonable default values for <code class="code">Size</code> and <code class="code">Delay</code>. (Roughly some 64 KBytes, 2 seconds)</p> </dd> <dt><strong><code class="code">{read_ahead, Size}</code></strong></dt> <dd> <p>This option activates read data buffering. If <code class="code">read/2</code> calls are for significantly less than <code class="code">Size</code> bytes, read operations towards the operating system are still performed for blocks of <code class="code">Size</code> bytes. The extra data is buffered and returned in subsequent <code class="code">read/2</code> calls, giving a performance gain since the number of operating system calls is reduced.</p> <p>The <code class="code">read_ahead</code> buffer is also highly utilized by the <code class="code">read_line/1</code> function in <code class="code">raw</code> mode, why this option is recommended (for performance reasons) when accessing raw files using that function.</p> <p>If <code class="code">read/2</code> calls are for sizes not significantly less than, or even greater than <code class="code">Size</code> bytes, no performance gain can be expected.</p> </dd> <dt><strong><code class="code">read_ahead</code></strong></dt> <dd> <p>The same as <code class="code">{read_ahead, Size}</code> with a reasonable default value for <code class="code">Size</code>. (Roughly some 64 KBytes)</p> </dd> <dt><strong><code class="code">compressed</code></strong></dt> <dd> <p>Makes it possible to read or write gzip compressed files. The <code class="code">compressed</code> option must be combined with either <code class="code">read</code> or <code class="code">write</code>, but not both. Note that the file size obtained with <code class="code">read_file_info/1</code> will most probably not match the number of bytes that can be read from a compressed file.</p> </dd> <dt><strong><code class="code">{encoding, Encoding}</code></strong></dt> <dd> <p>Makes the file perform automatic translation of characters to and from a specific (Unicode) encoding. Note that the data supplied to file:write or returned by file:read still is byte oriented, this option only denotes how data is actually stored in the disk file.</p> <p>Depending on the encoding, different methods of reading and writing data is preferred. The default encoding of <code class="code">latin1</code> implies using this (the file) module for reading and writing data, as the interfaces provided here work with byte-oriented data, while using other (Unicode) encodings makes the <code class="bold_code">io(3)</code> module's <code class="code">get_chars</code>, <code class="code">get_line</code> and <code class="code">put_chars</code> functions more suitable, as they can work with the full Unicode range.</p> <p>If data is sent to an <code class="code">io_device()</code> in a format that cannot be converted to the specified encoding, or if data is read by a function that returns data in a format that cannot cope with the character range of the data, an error occurs and the file will be closed.</p> <p>The allowed values for <code class="code">Encoding</code> are:</p> <dl> <dt><strong><code class="code">latin1</code></strong></dt> <dd> <p>The default encoding. Bytes supplied to i.e. file:write are written as is on the file, likewise bytes read from the file are returned to i.e. file:read as is. If the <code class="bold_code">io(3)</code> module is used for writing, the file can only cope with Unicode characters up to codepoint 255 (the ISO-latin-1 range).</p> </dd> <dt><strong><code class="code">unicode</code> or <code class="code">utf8</code></strong></dt> <dd> <p>Characters are translated to and from the UTF-8 encoding before being written to or read from the file. A file opened in this way might be readable using the file:read function, as long as no data stored on the file lies beyond the ISO-latin-1 range (0..255), but failure will occur if the data contains Unicode codepoints beyond that range. The file is best read with the functions in the Unicode aware <code class="bold_code">io(3)</code> module.</p> <p>Bytes written to the file by any means are translated to UTF-8 encoding before actually being stored on the disk file.</p> </dd> <dt><strong><code class="code">utf16</code> or <code class="code">{utf16,big}</code></strong></dt> <dd> <p>Works like <code class="code">unicode</code>, but translation is done to and from big endian UTF-16 instead of UTF-8.</p> </dd> <dt><strong><code class="code">{utf16,little}</code></strong></dt> <dd> <p>Works like <code class="code">unicode</code>, but translation is done to and from little endian UTF-16 instead of UTF-8.</p> </dd> <dt><strong><code class="code">utf32</code> or <code class="code">{utf32,big}</code></strong></dt> <dd> <p>Works like <code class="code">unicode</code>, but translation is done to and from big endian UTF-32 instead of UTF-8.</p> </dd> <dt><strong><code class="code">{utf32,little}</code></strong></dt> <dd> <p>Works like <code class="code">unicode</code>, but translation is done to and from little endian UTF-32 instead of UTF-8.</p> </dd> </dl> <p>The Encoding can be changed for a file "on the fly" by using the <code class="bold_code">io:setopts/2</code> function, why a file can be analyzed in latin1 encoding for i.e. a BOM, positioned beyond the BOM and then be set for the right encoding before further reading.See the <code class="bold_code">unicode(3)</code> module for functions identifying BOM's.</p> <p>This option is not allowed on <code class="code">raw</code> files.</p> </dd> <dt><strong><code class="code">ram</code></strong></dt> <dd> <p><code class="code">File</code> must be <code class="code">iodata()</code>. Returns an <code class="code">fd()</code> which lets the <code class="code">file</code> module operate on the data in-memory as if it is a file.</p> </dd> <dt><strong><code class="code">sync</code></strong></dt> <dd> <p>On platforms that support it, enables the POSIX <code class="code">O_SYNC</code> synchronous I/O flag or its platform-dependent equivalent (e.g., <code class="code">FILE_FLAG_WRITE_THROUGH</code> on Windows) so that writes to the file block until the data has been physically written to disk. Be aware, though, that the exact semantics of this flag differ from platform to platform; for example, neither Linux nor Windows guarantees that all file metadata are also written before the call returns. For precise semantics, check the details of your platform's documentation. On platforms with no support for POSIX <code class="code">O_SYNC</code> or equivalent, use of the <code class="code">sync</code> flag causes <code class="code">open</code> to return <code class="code">{error, enotsup}</code>.</p> </dd> </dl> <p>Returns:</p> <dl> <dt><strong><code class="code">{ok, IoDevice}</code></strong></dt> <dd> <p>The file has been opened in the requested mode. <code class="code">IoDevice</code> is a reference to the file.</p> </dd> <dt><strong><code class="code">{error, Reason}</code></strong></dt> <dd> <p>The file could not be opened.</p> </dd> </dl> <p><code class="code">IoDevice</code> is really the pid of the process which handles the file. This process is linked to the process which originally opened the file. If any process to which the <code class="code">IoDevice</code> is linked terminates, the file will be closed and the process itself will be terminated. An <code class="code">IoDevice</code> returned from this call can be used as an argument to the IO functions (see <code class="bold_code">io(3)</code>).</p> <div class="note"> <div class="label">Note</div> <div class="content">

<p>In previous versions of <code class="code">file</code>, modes were given as one of the atoms <code class="code">read</code>, <code class="code">write</code>, or <code class="code">read_write</code> instead of a list. This is still allowed for reasons of backwards compatibility, but should not be used for new code. Also note that <code class="code">read_write</code> is not allowed in a mode list.</p> </div> </div> <p>Typical error reasons:</p> <dl> <dt><strong><code class="code">enoent</code></strong></dt> <dd> <p>The file does not exist.</p> </dd> <dt><strong><code class="code">eacces</code></strong></dt> <dd> <p>Missing permission for reading the file or searching one of the parent directories.</p> </dd> <dt><strong><code class="code">eisdir</code></strong></dt> <dd> <p>The named file is not a regular file. It may be a directory, a fifo, or a device.</p> </dd> <dt><strong><code class="code">enotdir</code></strong></dt> <dd> <p>A component of the file name is not a directory. On some platforms, <code class="code">enoent</code> is returned instead.</p> </dd> <dt><strong><code class="code">enospc</code></strong></dt> <dd> <p>There is a no space left on the device (if <code class="code">write</code> access was specified).</p> </dd> </dl>  <h3 id="path_consult-2" class="code">path_consult(Path, Filename) -&gt;<br>                {ok, Terms, FullName} | {error, Reason}</h3> <p>Types:</p>        <pre>Path = [Dir]
Dir = Filename = <a href="#type-name_all">name_all()</a>

Terms = [term()]
FullName = <a href="#type-filename_all">filename_all()</a>
Reason = 
    <a href="#type-posix">posix()</a> |
    badarg |
    terminated |
    system_limit |
    {Line :: integer(), Mod :: module(), Term :: term()}</pre>

<p>Searches the path <code class="code">Path</code> (a list of directory names) until the file <code class="code">Filename</code> is found. If <code class="code">Filename</code> is an absolute filename, <code class="code">Path</code> is ignored. Then reads Erlang terms, separated by '.', from the file. Returns one of the following:</p> <dl> <dt><strong><code class="code">{ok, Terms, FullName}</code></strong></dt> <dd> <p>The file was successfully read. <code class="code">FullName</code> is the full name of the file.</p> </dd> <dt><strong><code class="code">{error, enoent}</code></strong></dt> <dd> <p>The file could not be found in any of the directories in <code class="code">Path</code>.</p> </dd> <dt><strong><code class="code">{error, atom()}</code></strong></dt> <dd> <p>An error occurred when opening the file or reading it. See <code class="bold_code"><a href="#open-2">open/2</a></code> for a list of typical error codes.</p> </dd> <dt><strong><code class="code">{error, {Line, Mod, Term}}</code></strong></dt> <dd> <p>An error occurred when interpreting the Erlang terms in the file. Use <code class="code">format_error/1</code> to convert the three-element tuple to an English description of the error.</p> </dd> </dl> <p>The encoding of of <code class="code">Filename</code> can be set by a comment as described in <code class="bold_code">epp(3)</code>.</p>  <h3 id="path_eval-2" class="code">path_eval(Path, Filename) -&gt; {ok, FullName} | {error, Reason}</h3> <p>Types:</p>      <pre>Path = [Dir :: <a href="#type-name_all">name_all()</a>]
Filename = <a href="#type-name_all">name_all()</a>
FullName = <a href="#type-filename_all">filename_all()</a>
Reason = 
    <a href="#type-posix">posix()</a> |
    badarg |
    terminated |
    system_limit |
    {Line :: integer(), Mod :: module(), Term :: term()}</pre>

<p>Searches the path <code class="code">Path</code> (a list of directory names) until the file <code class="code">Filename</code> is found. If <code class="code">Filename</code> is an absolute file name, <code class="code">Path</code> is ignored. Then reads and evaluates Erlang expressions, separated by '.' (or ',', a sequence of expressions is also an expression), from the file. The actual result of evaluation is not returned; any expression sequence in the file must be there for its side effect. Returns one of the following:</p> <dl> <dt><strong><code class="code">{ok, FullName}</code></strong></dt> <dd> <p>The file was read and evaluated. <code class="code">FullName</code> is the full name of the file.</p> </dd> <dt><strong><code class="code">{error, enoent}</code></strong></dt> <dd> <p>The file could not be found in any of the directories in <code class="code">Path</code>.</p> </dd> <dt><strong><code class="code">{error, atom()}</code></strong></dt> <dd> <p>An error occurred when opening the file or reading it. See <code class="bold_code"><a href="#open-2">open/2</a></code> for a list of typical error codes.</p> </dd> <dt><strong><code class="code">{error, {Line, Mod, Term}}</code></strong></dt> <dd> <p>An error occurred when interpreting the Erlang expressions in the file. Use <code class="code">format_error/1</code> to convert the three-element tuple to an English description of the error.</p> </dd> </dl> <p>The encoding of of <code class="code">Filename</code> can be set by a comment as described in <code class="bold_code">epp(3)</code>.</p>  <h3 id="path_open-3" class="code">path_open(Path, Filename, Modes) -&gt;<br>             {ok, IoDevice, FullName} | {error, Reason}</h3> <p>Types:</p>        <pre>Path = [Dir :: <a href="#type-name_all">name_all()</a>]
Filename = <a href="#type-name_all">name_all()</a>
Modes = [<a href="#type-mode">mode()</a>]
IoDevice = <a href="#type-io_device">io_device()</a>
FullName = <a href="#type-filename_all">filename_all()</a>
Reason = <a href="#type-posix">posix()</a> | badarg | system_limit</pre>

<p>Searches the path <code class="code">Path</code> (a list of directory names) until the file <code class="code">Filename</code> is found. If <code class="code">Filename</code> is an absolute file name, <code class="code">Path</code> is ignored. Then opens the file in the mode determined by <code class="code">Modes</code>. Returns one of the following:</p> <dl> <dt><strong><code class="code">{ok, IoDevice, FullName}</code></strong></dt> <dd> <p>The file has been opened in the requested mode. <code class="code">IoDevice</code> is a reference to the file and <code class="code">FullName</code> is the full name of the file.</p> </dd> <dt><strong><code class="code">{error, enoent}</code></strong></dt> <dd> <p>The file could not be found in any of the directories in <code class="code">Path</code>.</p> </dd> <dt><strong><code class="code">{error, atom()}</code></strong></dt> <dd> <p>The file could not be opened.</p> </dd> </dl>  <h3 id="path_script-2" class="code">path_script(Path, Filename) -&gt;<br>               {ok, Value, FullName} | {error, Reason}</h3> <p>Types:</p>       <pre>Path = [Dir :: <a href="#type-name_all">name_all()</a>]
Filename = <a href="#type-name_all">name_all()</a>
Value = term()
FullName = <a href="#type-filename_all">filename_all()</a>
Reason = 
    <a href="#type-posix">posix()</a> |
    badarg |
    terminated |
    system_limit |
    {Line :: integer(), Mod :: module(), Term :: term()}</pre>

<p>Searches the path <code class="code">Path</code> (a list of directory names) until the file <code class="code">Filename</code> is found. If <code class="code">Filename</code> is an absolute file name, <code class="code">Path</code> is ignored. Then reads and evaluates Erlang expressions, separated by '.' (or ',', a sequence of expressions is also an expression), from the file. Returns one of the following:</p> <dl> <dt><strong><code class="code">{ok, Value, FullName}</code></strong></dt> <dd> <p>The file was read and evaluated. <code class="code">FullName</code> is the full name of the file and <code class="code">Value</code> the value of the last expression.</p> </dd> <dt><strong><code class="code">{error, enoent}</code></strong></dt> <dd> <p>The file could not be found in any of the directories in <code class="code">Path</code>.</p> </dd> <dt><strong><code class="code">{error, atom()}</code></strong></dt> <dd> <p>An error occurred when opening the file or reading it. See <code class="bold_code"><a href="#open-2">open/2</a></code> for a list of typical error codes.</p> </dd> <dt><strong><code class="code">{error, {Line, Mod, Term}}</code></strong></dt> <dd> <p>An error occurred when interpreting the Erlang expressions in the file. Use <code class="code">format_error/1</code> to convert the three-element tuple to an English description of the error.</p> </dd> </dl> <p>The encoding of of <code class="code">Filename</code> can be set by a comment as described in <code class="bold_code">epp(3)</code>.</p>  <h3 id="path_script-3" class="code">path_script(Path, Filename, Bindings) -&gt;<br>               {ok, Value, FullName} | {error, Reason}</h3> <p>Types:</p>        <pre>Path = [Dir :: <a href="#type-name_all">name_all()</a>]
Filename = <a href="#type-name_all">name_all()</a>
Bindings = erl_eval:binding_struct()
Value = term()
FullName = <a href="#type-filename_all">filename_all()</a>
Reason = 
    <a href="#type-posix">posix()</a> |
    badarg |
    terminated |
    system_limit |
    {Line :: integer(), Mod :: module(), Term :: term()}</pre>

<p>The same as <code class="code">path_script/2</code> but the variable bindings <code class="code">Bindings</code> are used in the evaluation. See <code class="bold_code">erl_eval(3)</code> about variable bindings.</p>  <h3 id="pid2name-1" class="code">pid2name(Pid) -&gt; {ok, Filename} | undefined</h3> <p>Types:</p>    <pre>Filename = <a href="#type-filename_all">filename_all()</a>
Pid = pid()</pre>

<p>If <code class="code">Pid</code> is an IO device, that is, a pid returned from <code class="code">open/2</code>, this function returns the filename, or rather:</p> <dl> <dt><strong><code class="code">{ok, Filename}</code></strong></dt> <dd> <p>If this node's file server is not a slave, the file was opened by this node's file server, (this implies that <code class="code">Pid</code> must be a local pid) and the file is not closed. <code class="code">Filename</code> is the filename in flat string format.</p> </dd> <dt><strong><code class="code">undefined</code></strong></dt> <dd> <p>In all other cases.</p> </dd> </dl> <div class="warning"> <div class="label">Warning</div> <div class="content">

<p>This function is intended for debugging only.</p> </div> </div>  <h3 id="position-2" class="code">position(IoDevice, Location) -&gt;<br>            {ok, NewPosition} | {error, Reason}</h3> <p>Types:</p>      <pre>IoDevice = <a href="#type-io_device">io_device()</a>
Location = <a href="#type-location">location()</a>
NewPosition = integer()
Reason = <a href="#type-posix">posix()</a> | badarg | terminated</pre>

<p>Sets the position of the file referenced by <code class="code">IoDevice</code> to <code class="code">Location</code>. Returns <code class="code">{ok, NewPosition}</code> (as absolute offset) if successful, otherwise <code class="code">{error, Reason}</code>. <code class="code">Location</code> is one of the following:</p> <dl> <dt><strong><code class="code">Offset</code></strong></dt> <dd> <p>The same as <code class="code">{bof, Offset}</code>.</p> </dd> <dt><strong><code class="code">{bof, Offset}</code></strong></dt> <dd> <p>Absolute offset.</p> </dd> <dt><strong><code class="code">{cur, Offset}</code></strong></dt> <dd> <p>Offset from the current position.</p> </dd> <dt><strong><code class="code">{eof, Offset}</code></strong></dt> <dd> <p>Offset from the end of file.</p> </dd> <dt><strong><code class="code">bof | cur | eof</code></strong></dt> <dd> <p>The same as above with <code class="code">Offset</code> 0.</p> </dd> </dl> <p>Note that offsets are counted in bytes, not in characters. If the file is opened using some other <code class="code">encoding</code> than <code class="code">latin1</code>, one byte does not correspond to one character. Positioning in such a file can only be done to known character boundaries, i.e. to a position earlier retrieved by getting a current position, to the beginning/end of the file or to some other position <strong>known</strong> to be on a correct character boundary by some other means (typically beyond a byte order mark in the file, which has a known byte-size).</p> <p>Typical error reasons are:</p> <dl> <dt><strong><code class="code">einval</code></strong></dt> <dd> <p>Either <code class="code">Location</code> was illegal, or it evaluated to a negative offset in the file. Note that if the resulting position is a negative value, the result is an error, and after the call the file position is undefined.</p> </dd> </dl>  <h3 id="pread-2" class="code">pread(IoDevice, LocNums) -&gt; {ok, DataL} | eof | {error, Reason}</h3> <p>Types:</p>       <pre>IoDevice = <a href="#type-io_device">io_device()</a>
LocNums = 
    [{Location :: <a href="#type-location">location()</a>, Number :: integer() &gt;= 0}]
DataL = [Data]
Data = string() | binary() | eof
Reason = <a href="#type-posix">posix()</a> | badarg | terminated</pre>

<p>Performs a sequence of <code class="code">pread/3</code> in one operation, which is more efficient than calling them one at a time. Returns <code class="code">{ok, [Data, ...]}</code> or <code class="code">{error, Reason}</code>, where each <code class="code">Data</code>, the result of the corresponding <code class="code">pread</code>, is either a list or a binary depending on the mode of the file, or <code class="code">eof</code> if the requested position was beyond end of file.</p> <p>As the position is given as a byte-offset, special caution has to be taken when working with files where <code class="code">encoding</code> is set to something else than <code class="code">latin1</code>, as not every byte position will be a valid character boundary on such a file.</p>  <h3 id="pread-3" class="code">pread(IoDevice, Location, Number) -&gt;<br>         {ok, Data} | eof | {error, Reason}</h3> <p>Types:</p>       <pre>IoDevice = <a href="#type-io_device">io_device()</a>
Location = <a href="#type-location">location()</a>
Number = integer() &gt;= 0
Data = string() | binary()
Reason = <a href="#type-posix">posix()</a> | badarg | terminated</pre>

<p>Combines <code class="code">position/2</code> and <code class="code">read/2</code> in one operation, which is more efficient than calling them one at a time. If <code class="code">IoDevice</code> has been opened in raw mode, some restrictions apply: <code class="code">Location</code> is only allowed to be an integer; and the current position of the file is undefined after the operation.</p> <p>As the position is given as a byte-offset, special caution has to be taken when working with files where <code class="code">encoding</code> is set to something else than <code class="code">latin1</code>, as not every byte position will be a valid character boundary on such a file.</p>  <h3 id="pwrite-2" class="code">pwrite(IoDevice, LocBytes) -&gt; ok | {error, {N, Reason}}</h3> <p>Types:</p>      <pre>IoDevice = <a href="#type-io_device">io_device()</a>
LocBytes = [{Location :: <a href="#type-location">location()</a>, Bytes :: iodata()}]
N = integer() &gt;= 0
Reason = <a href="#type-posix">posix()</a> | badarg | terminated</pre>

<p>Performs a sequence of <code class="code">pwrite/3</code> in one operation, which is more efficient than calling them one at a time. Returns <code class="code">ok</code> or <code class="code">{error, {N, Reason}}</code>, where <code class="code">N</code> is the number of successful writes that was done before the failure.</p> <p>When positioning in a file with other <code class="code">encoding</code> than <code class="code">latin1</code>, caution must be taken to set the position on a correct character boundary, see <code class="bold_code"><a href="#position-2">position/2</a></code> for details.</p>  <h3 id="pwrite-3" class="code">pwrite(IoDevice, Location, Bytes) -&gt; ok | {error, Reason}</h3> <p>Types:</p>      <pre>IoDevice = <a href="#type-io_device">io_device()</a>
Location = <a href="#type-location">location()</a>
Bytes = iodata()
Reason = <a href="#type-posix">posix()</a> | badarg | terminated</pre>

<p>Combines <code class="code">position/2</code> and <code class="code">write/2</code> in one operation, which is more efficient than calling them one at a time. If <code class="code">IoDevice</code> has been opened in raw mode, some restrictions apply: <code class="code">Location</code> is only allowed to be an integer; and the current position of the file is undefined after the operation.</p> <p>When positioning in a file with other <code class="code">encoding</code> than <code class="code">latin1</code>, caution must be taken to set the position on a correct character boundary, see <code class="bold_code"><a href="#position-2">position/2</a></code> for details.</p>  <h3 id="read-2" class="code">read(IoDevice, Number) -&gt; {ok, Data} | eof | {error, Reason}</h3> <p>Types:</p>      <pre>IoDevice = <a href="#type-io_device">io_device()</a> | atom()
Number = integer() &gt;= 0
Data = string() | binary()
Reason = 
    <a href="#type-posix">posix()</a> |
    badarg |
    terminated |
    {no_translation, unicode, latin1}</pre>

<p>Reads <code class="code">Number</code> bytes/characters from the file referenced by <code class="code">IoDevice</code>. The functions <code class="code">read/2</code>, <code class="code">pread/3</code> and <code class="code">read_line/1</code> are the only ways to read from a file opened in raw mode (although they work for normally opened files, too).</p> <p>For files where <code class="code">encoding</code> is set to something else than <code class="code">latin1</code>, one character might be represented by more than one byte on the file. The parameter <code class="code">Number</code> always denotes the number of <strong>characters</strong> read from the file, while the position in the file might be moved much more than this number when reading a Unicode file.</p> <p>Also, if <code class="code">encoding</code> is set to something else than <code class="code">latin1</code>, the <code class="code">read/3</code> call will fail if the data contains characters larger than 255, which is why the <code class="bold_code">io(3)</code> module is to be preferred when reading such a file.</p> <p>The function returns:</p> <dl> <dt><strong><code class="code">{ok, Data}</code></strong></dt> <dd> <p>If the file was opened in binary mode, the read bytes are returned in a binary, otherwise in a list. The list or binary will be shorter than the number of bytes requested if end of file was reached.</p> </dd> <dt><strong><code class="code">eof</code></strong></dt> <dd> <p>Returned if <code class="code">Number&gt;0</code> and end of file was reached before anything at all could be read.</p> </dd> <dt><strong><code class="code">{error, Reason}</code></strong></dt> <dd> <p>An error occurred.</p> </dd> </dl> <p>Typical error reasons:</p> <dl> <dt><strong><code class="code">ebadf</code></strong></dt> <dd> <p>The file is not opened for reading.</p> </dd> <dt><strong><code class="code">{no_translation, unicode, latin1}</code></strong></dt> <dd> <p>The file was opened with another <code class="code">encoding</code> than <code class="code">latin1</code> and the data in the file can not be translated to the byte-oriented data that this function returns.</p> </dd> </dl>  <h3 id="read_file-1" class="code">read_file(Filename) -&gt; {ok, Binary} | {error, Reason}</h3> <p>Types:</p>     <pre>Filename = <a href="#type-name_all">name_all()</a>
Binary = binary()
Reason = <a href="#type-posix">posix()</a> | badarg | terminated | system_limit</pre>

<p>Returns <code class="code">{ok, Binary}</code>, where <code class="code">Binary</code> is a binary data object that contains the contents of <code class="code">Filename</code>, or <code class="code">{error, Reason}</code> if an error occurs.</p> <p>Typical error reasons:</p> <dl> <dt><strong><code class="code">enoent</code></strong></dt> <dd> <p>The file does not exist.</p> </dd> <dt><strong><code class="code">eacces</code></strong></dt> <dd> <p>Missing permission for reading the file, or for searching one of the parent directories.</p> </dd> <dt><strong><code class="code">eisdir</code></strong></dt> <dd> <p>The named file is a directory.</p> </dd> <dt><strong><code class="code">enotdir</code></strong></dt> <dd> <p>A component of the file name is not a directory. On some platforms, <code class="code">enoent</code> is returned instead.</p> </dd> <dt><strong><code class="code">enomem</code></strong></dt> <dd> <p>There is not enough memory for the contents of the file.</p> </dd> </dl>  <h3 id="read_file_info-2" class="code">read_file_info(Filename) -&gt; {ok, FileInfo} | {error, Reason}<br>read_file_info(Filename, Opts) -&gt; {ok, FileInfo} | {error, Reason}</h3> <p>Types:</p>      <pre>Filename = <a href="#type-name_all">name_all()</a>
Opts = [<a href="#type-file_info_option">file_info_option()</a>]
FileInfo = <a href="#type-file_info">file_info()</a>
Reason = <a href="#type-posix">posix()</a> | badarg</pre>

<p>Retrieves information about a file. Returns <code class="code">{ok, FileInfo}</code> if successful, otherwise <code class="code">{error, Reason}</code>. <code class="code">FileInfo</code> is a record <code class="code">file_info</code>, defined in the Kernel include file <code class="code">file.hrl</code>. Include the following directive in the module from which the function is called:</p> <div class="example"><pre>
-include_lib("kernel/include/file.hrl").</pre></div> <p>The time type returned in <code class="code">atime</code>, <code class="code">mtime</code> and <code class="code">ctime</code> is dependent on the time type set in <code class="code">Opts :: {time, Type}</code>. Type <code class="code">local</code> will return local time, <code class="code">universal</code> will return universal time and <code class="code">posix</code> will return seconds since or before unix time epoch which is 1970-01-01 00:00 UTC. Default is <code class="code">{time, local}</code>. </p> <p>If the <code class="code">raw</code> option is set, the file server will not be called and only informations about local files will be returned.</p> <div class="note"> <div class="label">Note</div> <div class="content">

<p> Since file times is stored in posix time on most OS it is faster to query file information with the <code class="code">posix</code> option. </p> </div> </div> <p>The record <code class="code">file_info</code> contains the following fields.</p> <dl> <dt><strong><code class="code">size = integer() &gt;= 0</code></strong></dt> <dd> <p>Size of file in bytes.</p> </dd> <dt><strong><code class="code">type = device | directory | other | regular | symlink</code></strong></dt> <dd> <p>The type of the file.</p> </dd> <dt><strong><code class="code">access = read | write | read_write | none</code></strong></dt> <dd> <p>The current system access to the file.</p> </dd> <dt><strong><code class="code">atime =</code><code class="bold_code"><a href="#type-date_time">date_time()</a></code><code class="code">| integer() &gt;= 0</code></strong></dt> <dd> <p>The last time the file was read.</p> </dd> <dt><strong><code class="code">mtime =</code><code class="bold_code"><a href="#type-date_time">date_time()</a></code><code class="code">| integer() &gt;= 0</code></strong></dt> <dd> <p>The last time the file was written.</p> </dd> <dt><strong><code class="code">ctime =</code><code class="bold_code"><a href="#type-date_time">date_time()</a></code><code class="code">| integer() &gt;=0</code></strong></dt> <dd> <p>The interpretation of this time field depends on the operating system. On Unix, it is the last time the file or the inode was changed. In Windows, it is the create time.</p> </dd> <dt><strong><code class="code">mode = integer() &gt;= 0</code></strong></dt> <dd> <p>The file permissions as the sum of the following bit values:</p> <dl> <dt><strong>8#00400</strong></dt> <dd>read permission: owner</dd> <dt><strong>8#00200</strong></dt> <dd>write permission: owner</dd> <dt><strong>8#00100</strong></dt> <dd>execute permission: owner</dd> <dt><strong>8#00040</strong></dt> <dd>read permission: group</dd> <dt><strong>8#00020</strong></dt> <dd>write permission: group</dd> <dt><strong>8#00010</strong></dt> <dd>execute permission: group</dd> <dt><strong>8#00004</strong></dt> <dd>read permission: other</dd> <dt><strong>8#00002</strong></dt> <dd>write permission: other</dd> <dt><strong>8#00001</strong></dt> <dd>execute permission: other</dd> <dt><strong>16#800</strong></dt> <dd>set user id on execution</dd> <dt><strong>16#400</strong></dt> <dd>set group id on execution</dd> </dl> <p>On Unix platforms, other bits than those listed above may be set.</p> </dd> <dt><strong><code class="code">links = integer() &gt;= 0</code></strong></dt> <dd> <p>Number of links to the file (this will always be 1 for file systems which have no concept of links).</p> </dd> <dt><strong><code class="code">major_device = integer() &gt;= 0</code></strong></dt> <dd> <p>Identifies the file system where the file is located. In Windows, the number indicates a drive as follows: 0 means A:, 1 means B:, and so on.</p> </dd> <dt><strong><code class="code">minor_device = integer() &gt;= 0</code></strong></dt> <dd> <p>Only valid for character devices on Unix. In all other cases, this field is zero.</p> </dd> <dt><strong><code class="code">inode = integer() &gt;= 0</code></strong></dt> <dd> <p>Gives the <code class="code">inode</code> number. On non-Unix file systems, this field will be zero.</p> </dd> <dt><strong><code class="code">uid = integer() &gt;= 0</code></strong></dt> <dd> <p>Indicates the owner of the file. Will be zero for non-Unix file systems.</p> </dd> <dt><strong><code class="code">gid = integer() &gt;= 0</code></strong></dt> <dd> <p>Gives the group that the owner of the file belongs to. Will be zero for non-Unix file systems.</p> </dd> </dl> <p>Typical error reasons:</p> <dl> <dt><strong><code class="code">eacces</code></strong></dt> <dd> <p>Missing search permission for one of the parent directories of the file.</p> </dd> <dt><strong><code class="code">enoent</code></strong></dt> <dd> <p>The file does not exist.</p> </dd> <dt><strong><code class="code">enotdir</code></strong></dt> <dd> <p>A component of the file name is not a directory. On some platforms, <code class="code">enoent</code> is returned instead.</p> </dd> </dl>  <h3 id="read_line-1" class="code">read_line(IoDevice) -&gt; {ok, Data} | eof | {error, Reason}</h3> <p>Types:</p>     <pre>IoDevice = <a href="#type-io_device">io_device()</a> | atom()
Data = string() | binary()
Reason = 
    <a href="#type-posix">posix()</a> |
    badarg |
    terminated |
    {no_translation, unicode, latin1}</pre>

<p>Reads a line of bytes/characters from the file referenced by <code class="code">IoDevice</code>. Lines are defined to be delimited by the linefeed (LF, <code class="code">\n</code>) character, but any carriage return (CR, <code class="code">\r</code>) followed by a newline is also treated as a single LF character (the carriage return is silently ignored). The line is returned <strong>including</strong> the LF, but excluding any CR immediately followed by a LF. This behaviour is consistent with the behaviour of <code class="bold_code">io:get_line/2</code>. If end of file is reached without any LF ending the last line, a line with no trailing LF is returned.</p> <p>The function can be used on files opened in <code class="code">raw</code> mode. It is however inefficient to use it on <code class="code">raw</code> files if the file is not opened with the option <code class="code">{read_ahead, Size}</code> specified, why combining <code class="code">raw</code> and <code class="code">{read_ahead, Size}</code> is highly recommended when opening a text file for raw line oriented reading.</p> <p>If <code class="code">encoding</code> is set to something else than <code class="code">latin1</code>, the <code class="code">read_line/1</code> call will fail if the data contains characters larger than 255, why the <code class="bold_code">io(3)</code> module is to be preferred when reading such a file.</p> <p>The function returns:</p> <dl> <dt><strong><code class="code">{ok, Data}</code></strong></dt> <dd> <p>One line from the file is returned, including the trailing LF, but with CRLF sequences replaced by a single LF (see above).</p> <p>If the file was opened in binary mode, the read bytes are returned in a binary, otherwise in a list.</p> </dd> <dt><strong><code class="code">eof</code></strong></dt> <dd> <p>Returned if end of file was reached before anything at all could be read.</p> </dd> <dt><strong><code class="code">{error, Reason}</code></strong></dt> <dd> <p>An error occurred.</p> </dd> </dl> <p>Typical error reasons:</p> <dl> <dt><strong><code class="code">ebadf</code></strong></dt> <dd> <p>The file is not opened for reading.</p> </dd> <dt><strong><code class="code">{no_translation, unicode, latin1}</code></strong></dt> <dd> <p>The file is was opened with another <code class="code">encoding</code> than <code class="code">latin1</code> and the data on the file can not be translated to the byte-oriented data that this function returns.</p> </dd> </dl>  <h3 id="read_link-1" class="code">read_link(Name) -&gt; {ok, Filename} | {error, Reason}</h3> <p>Types:</p>     <pre>Name = <a href="#type-name_all">name_all()</a>
Filename = <a href="#type-filename">filename()</a>
Reason = <a href="#type-posix">posix()</a> | badarg</pre>

<p id="read_link_all">This function returns <code class="code">{ok, Filename}</code> if <code class="code">Name</code> refers to a symbolic link that is not a "raw" file name, or <code class="code">{error, Reason}</code> otherwise. On platforms that do not support symbolic links, the return value will be <code class="code">{error,enotsup}</code>.</p> <p>Typical error reasons:</p> <dl> <dt><strong><code class="code">einval</code></strong></dt> <dd> <p><code class="code">Name</code> does not refer to a symbolic link or the name of the file that it refers to does not conform to the expected encoding.</p> </dd> <dt><strong><code class="code">enoent</code></strong></dt> <dd> <p>The file does not exist.</p> </dd> <dt><strong><code class="code">enotsup</code></strong></dt> <dd> <p>Symbolic links are not supported on this platform.</p> </dd> </dl>  <h3 id="read_link_all-1" class="code">read_link_all(Name) -&gt; {ok, Filename} | {error, Reason}</h3> <p>Types:</p>     <pre>Name = <a href="#type-name_all">name_all()</a>
Filename = <a href="#type-filename_all">filename_all()</a>
Reason = <a href="#type-posix">posix()</a> | badarg</pre>

<p>This function returns <code class="code">{ok, Filename}</code> if <code class="code">Name</code> refers to a symbolic link or <code class="code">{error, Reason}</code> otherwise. On platforms that do not support symbolic links, the return value will be <code class="code">{error,enotsup}</code>.</p> <p>Note that <code class="code">Filename</code> can be either a list or a binary.</p> <p>Typical error reasons:</p> <dl> <dt><strong><code class="code">einval</code></strong></dt> <dd> <p><code class="code">Name</code> does not refer to a symbolic link.</p> </dd> <dt><strong><code class="code">enoent</code></strong></dt> <dd> <p>The file does not exist.</p> </dd> <dt><strong><code class="code">enotsup</code></strong></dt> <dd> <p>Symbolic links are not supported on this platform.</p> </dd> </dl>  <h3 id="read_link_info-2" class="code">read_link_info(Name) -&gt; {ok, FileInfo} | {error, Reason}<br>read_link_info(Name, Opts) -&gt; {ok, FileInfo} | {error, Reason}</h3> <p>Types:</p>      <pre>Name = <a href="#type-name_all">name_all()</a>
Opts = [<a href="#type-file_info_option">file_info_option()</a>]
FileInfo = <a href="#type-file_info">file_info()</a>
Reason = <a href="#type-posix">posix()</a> | badarg</pre>

<p>This function works like <code class="bold_code"><a href="#read_file_info-2">read_file_info/1,2</a></code> except that if <code class="code">Name</code> is a symbolic link, information about the link will be returned in the <code class="code">file_info</code> record and the <code class="code">type</code> field of the record will be set to <code class="code">symlink</code>.</p> <p>If the <code class="code">raw</code> option is set, the file server will not be called and only informations about local files will be returned.</p> <p>If <code class="code">Name</code> is not a symbolic link, this function returns exactly the same result as <code class="code">read_file_info/1</code>. On platforms that do not support symbolic links, this function is always equivalent to <code class="code">read_file_info/1</code>.</p>  <h3 id="rename-2" class="code">rename(Source, Destination) -&gt; ok | {error, Reason}</h3> <p>Types:</p>     <pre>Source = Destination = <a href="#type-name_all">name_all()</a>

Reason = <a href="#type-posix">posix()</a> | badarg</pre>

<p>Tries to rename the file <code class="code">Source</code> to <code class="code">Destination</code>. It can be used to move files (and directories) between directories, but it is not sufficient to specify the destination only. The destination file name must also be specified. For example, if <code class="code">bar</code> is a normal file and <code class="code">foo</code> and <code class="code">baz</code> are directories, <code class="code">rename("foo/bar", "baz")</code> returns an error, but <code class="code">rename("foo/bar", "baz/bar")</code> succeeds. Returns <code class="code">ok</code> if it is successful.</p> <div class="note"> <div class="label">Note</div> <div class="content">

<p>Renaming of open files is not allowed on most platforms (see <code class="code">eacces</code> below).</p> </div> </div> <p>Typical error reasons:</p> <dl> <dt><strong><code class="code">eacces</code></strong></dt> <dd> <p>Missing read or write permissions for the parent directories of <code class="code">Source</code> or <code class="code">Destination</code>. On some platforms, this error is given if either <code class="code">Source</code> or <code class="code">Destination</code> is open.</p> </dd> <dt><strong><code class="code">eexist</code></strong></dt> <dd> <p><code class="code">Destination</code> is not an empty directory. On some platforms, also given when <code class="code">Source</code> and <code class="code">Destination</code> are not of the same type.</p> </dd> <dt><strong><code class="code">einval</code></strong></dt> <dd> <p><code class="code">Source</code> is a root directory, or <code class="code">Destination</code> is a sub-directory of <code class="code">Source</code>.</p> </dd> <dt><strong><code class="code">eisdir</code></strong></dt> <dd> <p><code class="code">Destination</code> is a directory, but <code class="code">Source</code> is not.</p> </dd> <dt><strong><code class="code">enoent</code></strong></dt> <dd> <p><code class="code">Source</code> does not exist.</p> </dd> <dt><strong><code class="code">enotdir</code></strong></dt> <dd> <p><code class="code">Source</code> is a directory, but <code class="code">Destination</code> is not.</p> </dd> <dt><strong><code class="code">exdev</code></strong></dt> <dd> <p><code class="code">Source</code> and <code class="code">Destination</code> are on different file systems.</p> </dd> </dl>  <h3 id="script-1" class="code">script(Filename) -&gt; {ok, Value} | {error, Reason}</h3> <p>Types:</p>     <pre>Filename = <a href="#type-name_all">name_all()</a>
Value = term()
Reason = 
    <a href="#type-posix">posix()</a> |
    badarg |
    terminated |
    system_limit |
    {Line :: integer(), Mod :: module(), Term :: term()}</pre>

<p>Reads and evaluates Erlang expressions, separated by '.' (or ',', a sequence of expressions is also an expression), from the file. Returns one of the following:</p> <dl> <dt><strong><code class="code">{ok, Value}</code></strong></dt> <dd> <p>The file was read and evaluated. <code class="code">Value</code> is the value of the last expression.</p> </dd> <dt><strong><code class="code">{error, atom()}</code></strong></dt> <dd> <p>An error occurred when opening the file or reading it. See <code class="bold_code"><a href="#open-2">open/2</a></code> for a list of typical error codes.</p> </dd> <dt><strong><code class="code">{error, {Line, Mod, Term}}</code></strong></dt> <dd> <p>An error occurred when interpreting the Erlang expressions in the file. Use <code class="code">format_error/1</code> to convert the three-element tuple to an English description of the error.</p> </dd> </dl> <p>The encoding of of <code class="code">Filename</code> can be set by a comment as described in <code class="bold_code">epp(3)</code>.</p>  <h3 id="script-2" class="code">script(Filename, Bindings) -&gt; {ok, Value} | {error, Reason}</h3> <p>Types:</p>      <pre>Filename = <a href="#type-name_all">name_all()</a>
Bindings = erl_eval:binding_struct()
Value = term()
Reason = 
    <a href="#type-posix">posix()</a> |
    badarg |
    terminated |
    system_limit |
    {Line :: integer(), Mod :: module(), Term :: term()}</pre>

<p>The same as <code class="code">script/1</code> but the variable bindings <code class="code">Bindings</code> are used in the evaluation. See <code class="bold_code">erl_eval(3)</code> about variable bindings.</p>  <h3 id="set_cwd-1" class="code">set_cwd(Dir) -&gt; ok | {error, Reason}</h3> <p>Types:</p>     <pre>Dir = <a href="#type-name">name()</a> | EncodedBinary
EncodedBinary = binary()
Reason = <a href="#type-posix">posix()</a> | badarg | no_translation</pre>

<p>Sets the current working directory of the file server to <code class="code">Dir</code>. Returns <code class="code">ok</code> if successful.</p> <p>The functions in the <code class="code">file</code> module usually treat binaries as raw filenames, i.e. they are passed as is even when the encoding of the binary does not agree with <code class="code">file:native_name_encoding()</code>. This function however expects binaries to be encoded according to the value returned by <code class="code">file:native_name_encoding()</code>.</p> <p>Typical error reasons are:</p> <dl> <dt><strong><code class="code">enoent</code></strong></dt> <dd> <p>The directory does not exist.</p> </dd> <dt><strong><code class="code">enotdir</code></strong></dt> <dd> <p>A component of <code class="code">Dir</code> is not a directory. On some platforms, <code class="code">enoent</code> is returned.</p> </dd> <dt><strong><code class="code">eacces</code></strong></dt> <dd> <p>Missing permission for the directory or one of its parents.</p> </dd> <dt><strong><code class="code">badarg</code></strong></dt> <dd> <p><code class="code">Dir</code> had an improper type, such as tuple.</p> </dd> <dt><strong><code class="code">no_translation</code></strong></dt> <dd> <p><code class="code">Dir</code> is a <code class="code">binary()</code> with characters coded in ISO-latin-1 and the VM is operating with unicode file name encoding.</p> </dd> </dl> <div class="warning"> <div class="label">Warning</div> <div class="content">

<p>In a future release, a bad type for the <code class="code">Dir</code> argument will probably generate an exception.</p> </div> </div>  <h3 id="sync-1" class="code">sync(IoDevice) -&gt; ok | {error, Reason}</h3> <p>Types:</p>    <pre>IoDevice = <a href="#type-io_device">io_device()</a>
Reason = <a href="#type-posix">posix()</a> | badarg | terminated</pre>

<p>Makes sure that any buffers kept by the operating system (not by the Erlang runtime system) are written to disk. On some platforms, this function might have no effect.</p> <p>Typical error reasons are:</p> <dl> <dt><strong><code class="code">enospc</code></strong></dt> <dd> <p>Not enough space left to write the file.</p> </dd> </dl>  <h3 id="datasync-1" class="code">datasync(IoDevice) -&gt; ok | {error, Reason}</h3> <p>Types:</p>    <pre>IoDevice = <a href="#type-io_device">io_device()</a>
Reason = <a href="#type-posix">posix()</a> | badarg | terminated</pre>

<p>Makes sure that any buffers kept by the operating system (not by the Erlang runtime system) are written to disk. In many ways it resembles fsync but it does not update some of the file's metadata such as the access time. On some platforms this function has no effect.</p> <p>Applications that access databases or log files often write a tiny data fragment (e.g., one line in a log file) and then call fsync() immediately in order to ensure that the written data is physically stored on the harddisk. Unfortunately, fsync() will always initiate two write operations: one for the newly written data and another one in order to update the modification time stored in the inode. If the modification time is not a part of the transaction concept, fdatasync() can be used to avoid unnecessary inode disk write operations.</p> <p>Available only in some POSIX systems, this call results in a call to fsync(), or has no effect in systems not implementing the fdatasync() syscall.</p>  <h3 id="truncate-1" class="code">truncate(IoDevice) -&gt; ok | {error, Reason}</h3> <p>Types:</p>    <pre>IoDevice = <a href="#type-io_device">io_device()</a>
Reason = <a href="#type-posix">posix()</a> | badarg | terminated</pre>

<p>Truncates the file referenced by <code class="code">IoDevice</code> at the current position. Returns <code class="code">ok</code> if successful, otherwise <code class="code">{error, Reason}</code>.</p>  <h3 id="sendfile-2" class="code">sendfile(Filename, Socket) -&gt;<br>            {ok, integer() &gt;= 0} |<br>            {error, <a href="../inet/#type-posix">inet:posix()</a> | closed | badarg | not_owner}</h3> <p>Types:</p>    <pre>Filename = <a href="#type-name_all">name_all()</a>
Socket = <a href="../inet/#type-socket">inet:socket()</a></pre>

<p>Sends the file <code class="code">Filename</code> to <code class="code">Socket</code>. Returns <code class="code">{ok, BytesSent}</code> if successful, otherwise <code class="code">{error, Reason}</code>.</p>  <h3 id="sendfile-5" class="code">sendfile(RawFile, Socket, Offset, Bytes, Opts) -&gt;<br>            {ok, integer() &gt;= 0} |<br>            {error, <a href="../inet/#type-posix">inet:posix()</a> | closed | badarg | not_owner}</h3> <p>Types:</p>        <pre>RawFile = <a href="#type-fd">fd()</a>
Socket = <a href="../inet/#type-socket">inet:socket()</a>
Offset = Bytes = integer() &gt;= 0

Opts = [sendfile_option()]
sendfile_option() = 
    {chunk_size, integer() &gt;= 0} | {use_threads, boolean()}</pre>

<p>Sends <code class="code">Bytes</code> from the file referenced by <code class="code">RawFile</code> beginning at <code class="code">Offset</code> to <code class="code">Socket</code>. Returns <code class="code">{ok, BytesSent}</code> if successful, otherwise <code class="code">{error, Reason}</code>. If <code class="code">Bytes</code> is set to 0 all data after the given <code class="code">Offset</code> is sent.</p> <p>The file used must be opened using the raw flag, and the process calling sendfile must be the controlling process of the socket. See <code class="bold_code"><a href="../gen_tcp/#controlling_process-2">gen_tcp:controlling_process/2</a></code></p> <p>If the OS used does not support sendfile, an Erlang fallback using file:read and gen_tcp:send is used.</p> <p>The option list can contain the following options:</p> <dl> <dt><strong><code class="code">chunk_size</code></strong></dt> <dd>The chunk size used by the erlang fallback to send data. If using the fallback, this should be set to a value which comfortably fits in the systems memory. Default is 20 MB.</dd> <dt><strong><code class="code">use_threads</code></strong></dt> <dd>Instruct the emulator to use the async thread pool for the sendfile system call. This could be usefull if the OS you are running on does not properly support non-blocking sendfile calls. Do note that using async threads potentially makes your system volnerable to slow client attacks. If set to true and no async threads are available, the sendfile call will return <code class="code">{error,einval}</code>. Introduced in Erlang/OTP 17.0. Default is false.</dd> </dl>  <h3 id="write-2" class="code">write(IoDevice, Bytes) -&gt; ok | {error, Reason}</h3> <p>Types:</p>     <pre>IoDevice = <a href="#type-io_device">io_device()</a> | atom()
Bytes = iodata()
Reason = <a href="#type-posix">posix()</a> | badarg | terminated</pre>

<p>Writes <code class="code">Bytes</code> to the file referenced by <code class="code">IoDevice</code>. This function is the only way to write to a file opened in raw mode (although it works for normally opened files, too). Returns <code class="code">ok</code> if successful, and <code class="code">{error, Reason}</code> otherwise.</p> <p>If the file is opened with <code class="code">encoding</code> set to something else than <code class="code">latin1</code>, each byte written might result in several bytes actually being written to the file, as the byte range 0..255 might represent anything between one and four bytes depending on value and UTF encoding type.</p> <p>Typical error reasons are:</p> <dl> <dt><strong><code class="code">ebadf</code></strong></dt> <dd> <p>The file is not opened for writing.</p> </dd> <dt><strong><code class="code">enospc</code></strong></dt> <dd> <p>There is a no space left on the device.</p> </dd> </dl>  <h3 id="write_file-2" class="code">write_file(Filename, Bytes) -&gt; ok | {error, Reason}</h3> <p>Types:</p>     <pre>Filename = <a href="#type-name_all">name_all()</a>
Bytes = iodata()
Reason = <a href="#type-posix">posix()</a> | badarg | terminated | system_limit</pre>

<p>Writes the contents of the iodata term <code class="code">Bytes</code> to the file <code class="code">Filename</code>. The file is created if it does not exist. If it exists, the previous contents are overwritten. Returns <code class="code">ok</code>, or <code class="code">{error, Reason}</code>.</p> <p>Typical error reasons are:</p> <dl> <dt><strong><code class="code">enoent</code></strong></dt> <dd> <p>A component of the file name does not exist.</p> </dd> <dt><strong><code class="code">enotdir</code></strong></dt> <dd> <p>A component of the file name is not a directory. On some platforms, <code class="code">enoent</code> is returned instead.</p> </dd> <dt><strong><code class="code">enospc</code></strong></dt> <dd> <p>There is a no space left on the device.</p> </dd> <dt><strong><code class="code">eacces</code></strong></dt> <dd> <p>Missing permission for writing the file or searching one of the parent directories.</p> </dd> <dt><strong><code class="code">eisdir</code></strong></dt> <dd> <p>The named file is a directory.</p> </dd> </dl>  <h3 id="write_file-3" class="code">write_file(Filename, Bytes, Modes) -&gt; ok | {error, Reason}</h3> <p>Types:</p>      <pre>Filename = <a href="#type-name_all">name_all()</a>
Bytes = iodata()
Modes = [<a href="#type-mode">mode()</a>]
Reason = <a href="#type-posix">posix()</a> | badarg | terminated | system_limit</pre>

<p>Same as <code class="code">write_file/2</code>, but takes a third argument <code class="code">Modes</code>, a list of possible modes, see <code class="bold_code"><a href="#open-2">open/2</a></code>. The mode flags <code class="code">binary</code> and <code class="code">write</code> are implicit, so they should not be used.</p>  <h3 id="write_file_info-3" class="code">write_file_info(Filename, FileInfo) -&gt; ok | {error, Reason}<br>write_file_info(Filename, FileInfo, Opts) -&gt; ok | {error, Reason}</h3> <p>Types:</p>      <pre>Filename = <a href="#type-name_all">name_all()</a>
Opts = [<a href="#type-file_info_option">file_info_option()</a>]
FileInfo = <a href="#type-file_info">file_info()</a>
Reason = <a href="#type-posix">posix()</a> | badarg</pre>

<p>Change file information. Returns <code class="code">ok</code> if successful, otherwise <code class="code">{error, Reason}</code>. <code class="code">FileInfo</code> is a record <code class="code">file_info</code>, defined in the Kernel include file <code class="code">file.hrl</code>. Include the following directive in the module from which the function is called:</p> <div class="example"><pre>
-include_lib("kernel/include/file.hrl").</pre></div> <p>The time type set in <code class="code">atime</code>, <code class="code">mtime</code> and <code class="code">ctime</code> is dependent on the time type set in <code class="code">Opts :: {time, Type}</code>. Type <code class="code">local</code> will interpret the time set as local, <code class="code">universal</code> will interpret it as universal time and <code class="code">posix</code> must be seconds since or before unix time epoch which is 1970-01-01 00:00 UTC. Default is <code class="code">{time, local}</code>.</p> <p>If the <code class="code">raw</code> option is set, the file server will not be called and only informations about local files will be returned.</p> <p>The following fields are used from the record, if they are given.</p> <dl> <dt><strong><code class="code">atime =</code><code class="bold_code"><a href="#type-date_time">date_time()</a></code><code class="code">| integer() &gt;= 0</code></strong></dt> <dd> <p>The last time the file was read.</p> </dd> <dt><strong><code class="code">mtime =</code><code class="bold_code"><a href="#type-date_time">date_time()</a></code><code class="code">| integer() &gt;= 0</code></strong></dt> <dd> <p>The last time the file was written.</p> </dd> <dt><strong><code class="code">ctime =</code><code class="bold_code"><a href="#type-date_time">date_time()</a></code><code class="code">| integer() &gt;= 0</code></strong></dt> <dd> <p>On Unix, any value give for this field will be ignored (the "ctime" for the file will be set to the current time). On Windows, this field is the new creation time to set for the file.</p> </dd> <dt><strong><code class="code">mode = integer() &gt;= 0</code></strong></dt> <dd> <p>The file permissions as the sum of the following bit values:</p> <dl> <dt><strong>8#00400</strong></dt> <dd>read permission: owner</dd> <dt><strong>8#00200</strong></dt> <dd>write permission: owner</dd> <dt><strong>8#00100</strong></dt> <dd>execute permission: owner</dd> <dt><strong>8#00040</strong></dt> <dd>read permission: group</dd> <dt><strong>8#00020</strong></dt> <dd>write permission: group</dd> <dt><strong>8#00010</strong></dt> <dd>execute permission: group</dd> <dt><strong>8#00004</strong></dt> <dd>read permission: other</dd> <dt><strong>8#00002</strong></dt> <dd>write permission: other</dd> <dt><strong>8#00001</strong></dt> <dd>execute permission: other</dd> <dt><strong>16#800</strong></dt> <dd>set user id on execution</dd> <dt><strong>16#400</strong></dt> <dd>set group id on execution</dd> </dl> <p>On Unix platforms, other bits than those listed above may be set.</p> </dd> <dt><strong><code class="code">uid = integer() &gt;= 0</code></strong></dt> <dd> <p>Indicates the owner of the file. Ignored for non-Unix file systems.</p> </dd> <dt><strong><code class="code">gid = integer() &gt;= 0</code></strong></dt> <dd> <p>Gives the group that the owner of the file belongs to. Ignored for non-Unix file systems.</p> </dd> </dl> <p>Typical error reasons:</p> <dl> <dt><strong><code class="code">eacces</code></strong></dt> <dd> <p>Missing search permission for one of the parent directories of the file.</p> </dd> <dt><strong><code class="code">enoent</code></strong></dt> <dd> <p>The file does not exist.</p> </dd> <dt><strong><code class="code">enotdir</code></strong></dt> <dd> <p>A component of the file name is not a directory. On some platforms, <code class="code">enoent</code> is returned instead.</p> </dd> </dl>  <h2 id="id122788">POSIX Error Codes</h2>  <ul> <li> <code class="code">eacces</code> - permission denied</li> <li> <code class="code">eagain</code> - resource temporarily unavailable</li> <li> <code class="code">ebadf</code> - bad file number</li> <li> <code class="code">ebusy</code> - file busy</li> <li> <code class="code">edquot</code> - disk quota exceeded</li> <li> <code class="code">eexist</code> - file already exists</li> <li> <code class="code">efault</code> - bad address in system call argument</li> <li> <code class="code">efbig</code> - file too large</li> <li> <code class="code">eintr</code> - interrupted system call</li> <li> <code class="code">einval</code> - invalid argument</li> <li> <code class="code">eio</code> - IO error</li> <li> <code class="code">eisdir</code> - illegal operation on a directory</li> <li> <code class="code">eloop</code> - too many levels of symbolic links</li> <li> <code class="code">emfile</code> - too many open files</li> <li> <code class="code">emlink</code> - too many links</li> <li> <code class="code">enametoolong</code> - file name too long</li> <li> <code class="code">enfile</code> - file table overflow</li> <li> <code class="code">enodev</code> - no such device</li> <li> <code class="code">enoent</code> - no such file or directory</li> <li> <code class="code">enomem</code> - not enough memory</li> <li> <code class="code">enospc</code> - no space left on device</li> <li> <code class="code">enotblk</code> - block device required</li> <li> <code class="code">enotdir</code> - not a directory</li> <li> <code class="code">enotsup</code> - operation not supported</li> <li> <code class="code">enxio</code> - no such device or address</li> <li> <code class="code">eperm</code> - not owner</li> <li> <code class="code">epipe</code> - broken pipe</li> <li> <code class="code">erofs</code> - read-only file system</li> <li> <code class="code">espipe</code> - invalid seek</li> <li> <code class="code">esrch</code> - no such process</li> <li> <code class="code">estale</code> - stale remote file handle</li> <li> <code class="code">exdev</code> - cross-domain link</li> </ul>  <h2 id="id122999">Performance</h2>  <p>Some operating system file operations, for example a <code class="code">sync/1</code> or <code class="code">close/1</code> on a huge file, may block their calling thread for seconds. If this befalls the emulator main thread, the response time is no longer in the order of milliseconds, depending on the definition of "soft" in soft real-time system.</p> <p>If the device driver thread pool is active, file operations are done through those threads instead, so the emulator can go on executing Erlang processes. Unfortunately, the time for serving a file operation increases due to the extra scheduling required from the operating system.</p> <p>If the device driver thread pool is disabled or of size 0, large file reads and writes are segmented into several smaller, which enables the emulator so server other processes during the file operation. This gives the same effect as when using the thread pool, but with larger overhead. Other file operations, for example <code class="code">sync/1</code> or <code class="code">close/1</code> on a huge file, still are a problem.</p> <p>For increased performance, raw files are recommended. Raw files uses the file system of the node's host machine. For normal files (non-raw), the file server is used to find the files, and if the node is running its file server as slave to another node's, and the other node runs on some other host machine, they may have different file systems. This is seldom a problem, but you have now been warned.</p> <p>A normal file is really a process so it can be used as an IO device (see <code class="code">io</code>). Therefore when data is written to a normal file, the sending of the data to the file process, copies all data that are not binaries. Opening the file in binary mode and writing binaries is therefore recommended. If the file is opened on another node, or if the file server runs as slave to another node's, also binaries are copied.</p> <p>Caching data to reduce the number of file operations, or rather the number of calls to the file driver, will generally increase performance. The following function writes 4 MBytes in 23 seconds when tested:</p> <div class="example"><pre>
create_file_slow(Name, N) when integer(N), N &gt;= 0 -&gt;
    {ok, FD} = file:open(Name, [raw, write, delayed_write, binary]),
    ok = create_file_slow(FD, 0, N),
    ok = ?FILE_MODULE:close(FD),
    ok.
      
create_file_slow(FD, M, M) -&gt;
    ok;
create_file_slow(FD, M, N) -&gt;
    ok = file:write(FD, &lt;&lt;M:32/unsigned&gt;&gt;),
    create_file_slow(FD, M+1, N).</pre></div> <p>The following, functionally equivalent, function collects 1024 entries into a list of 128 32-byte binaries before each call to <code class="code">file:write/2</code> and so does the same work in 0.52 seconds, which is 44 times faster.</p> <div class="example"><pre>
create_file(Name, N) when integer(N), N &gt;= 0 -&gt;
    {ok, FD} = file:open(Name, [raw, write, delayed_write, binary]),
    ok = create_file(FD, 0, N),
    ok = ?FILE_MODULE:close(FD),
    ok.
      
create_file(FD, M, M) -&gt;
    ok;
create_file(FD, M, N) when M + 1024 =&amp;lt; N -&gt;
    create_file(FD, M, M + 1024, []),
    create_file(FD, M + 1024, N);
create_file(FD, M, N) -&gt;
    create_file(FD, M, N, []).
      
create_file(FD, M, M, R) -&gt;
    ok = file:write(FD, R);
create_file(FD, M, N0, R) when M + 8 =&amp;lt; N0 -&gt;
    N1  = N0-1,  N2  = N0-2,  N3  = N0-3,  N4  = N0-4, 
    N5  = N0-5,  N6  = N0-6,  N7  = N0-7,  N8  = N0-8, 
    create_file(FD, M, N8, 
                [&lt;&lt;N8:32/unsigned,  N7:32/unsigned, 
                   N6:32/unsigned,  N5:32/unsigned, 
                   N4:32/unsigned,  N3:32/unsigned, 
                   N2:32/unsigned,  N1:32/unsigned&gt;&gt; | R]);
create_file(FD, M, N0, R) -&gt;
    N1 = N0-1,
    create_file(FD, M, N1, [&lt;&lt;N1:32/unsigned&gt;&gt; | R]).</pre></div> <div class="note"> <div class="label">Note</div> <div class="content">

<p>Trust only your own benchmarks. If the list length in <code class="code">create_file/2</code> above is increased, it will run slightly faster, but consume more memory and cause more memory fragmentation. How much this affects your application is something that this simple benchmark can not predict.</p> <p>If the size of each binary is increased to 64 bytes, it will also run slightly faster, but the code will be twice as clumsy. In the current implementation are binaries larger than 64 bytes stored in memory common to all processes and not copied when sent between processes, while these smaller binaries are stored on the process heap and copied when sent like any other term.</p> <p>So, with a binary size of 68 bytes <code class="code">create_file/2</code> runs 30 percent slower then with 64 bytes, and will cause much more memory fragmentation. Note that if the binaries were to be sent between processes (for example a non-raw file) the results would probably be completely different.</p> </div> </div> <p>A raw file is really a port. When writing data to a port, it is efficient to write a list of binaries. There is no need to flatten a deep list before writing. On Unix hosts, scatter output, which writes a set of buffers in one operation, is used when possible. In this way <code class="code">file:write(FD, [Bin1, Bin2 | Bin3])</code> will write the contents of the binaries without copying the data at all except for perhaps deep down in the operating system kernel.</p> <p>For raw files, <code class="code">pwrite/2</code> and <code class="code">pread/2</code> are efficiently implemented. The file driver is called only once for the whole operation, and the list iteration is done in the file driver.</p> <p>The options <code class="code">delayed_write</code> and <code class="code">read_ahead</code> to <code class="code">file:open/2</code> makes the file driver cache data to reduce the number of operating system calls. The function <code class="code">create_file/2</code> in the example above takes 60 seconds seconds without the <code class="code">delayed_write</code> option, which is 2.6 times slower.</p> <p>And, as a really bad example, <code class="code">create_file_slow/2</code> above without the <code class="code">raw</code>, <code class="code">binary</code> and <code class="code">delayed_write</code> options, that is it calls <code class="code">file:open(Name, [write])</code>, needs 1 min 20 seconds for the job, which is 3.5 times slower than the first example, and 150 times slower than the optimized <code class="code">create_file/2</code>. </p>  <h2 id="id123201">Warnings</h2>  <p>If an error occurs when accessing an open file with the <code class="code">io</code> module, the process which handles the file will exit. The dead file process might hang if a process tries to access it later. This will be fixed in a future release.</p>  <h2 id="id123218">See also</h2>  <p><code class="bold_code">filename(3)</code></p>
<div class="_attribution">
  <p class="_attribution-p">
    © 1999–2016 Ericsson AB<br>Licensed under the Apache License, Version 2.0.<br>
    
  </p>
</div>

			</div>
		</div>
	</section>

	</div>
</body>
</html>
