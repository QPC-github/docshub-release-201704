
<!DOCTYPE HTML>

<html lang="en">

<head>
  <meta charset="utf-8">
  <title>Gen_sctp - Erlang 18 - W3cubDocs</title>
  
  <meta name="description" content=" gen_sctp ">
  <meta name="keywords" content="gen, sctp, -, erlang, erlang~18">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="http://docs.w3cub.com/erlang~18/lib/kernel-4.2/doc/html/gen_sctp/">
  <link href="/favicon.png" rel="icon">
  <link type="text/css" rel="stylesheet" href="/assets/application-50364fff564ce3b6327021805f3f00e2957b441cf27f576a7dd4ff63bbc47047.css">
  <script type="text/javascript" src="/assets/application-db64bfd54ceb42be11af7995804cf4902548419ceb79d509b0b7d62c22d98e6f.js"></script>
  <script src="/json/erlang~18.js"></script>
  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-71174418-1']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>


</head>

<body>
	<div class="_app">
	<header class="_header">
  
  <form class="_search">
    <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
    <a class="_search-clear"></a>
    <div class="_search-tag"></div>
  </form>
  
  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/erlang~18/" class="_nav-link" title="" style="margin-left:0;">Erlang 18</a></span>
  
  <nav class="_nav">
    <a href="/app/" class="_nav-link ">App</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		<div class="_list">
			
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<div class="_page _erlang">
				
<h1>gen_sctp</h1> <h2>Module</h2> <p class="REFBODY">gen_sctp</p> <h2>Module summary</h2> <p class="REFBODY">The gen_sctp module provides functions for communicating with sockets using the SCTP protocol.</p> <h2>Description</h2> 
<p>The <code class="code">gen_sctp</code> module provides functions for communicating with sockets using the SCTP protocol. The implementation assumes that the OS kernel supports SCTP <code class="bold_code"><a href="http://www.rfc-archive.org/getrfc.php?rfc=2960" target="_blank">(RFC2960)</a></code> through the user-level <code class="bold_code"><a href="http://tools.ietf.org/html/draft-ietf-tsvwg-sctpsocket-13" target="_blank">Sockets API Extensions.</a></code> During development this implementation was tested on Linux Fedora Core 5.0 (kernel 2.6.15-2054 or later is needed), and on Solaris 10, 11. During OTP adaptation it was tested on SUSE Linux Enterprise Server 10 (x86_64) kernel 2.6.16.27-0.6-smp, with lksctp-tools-1.0.6, briefly on Solaris 10, and later on SUSE Linux Enterprise Server 10 Service Pack 1 (x86_64) kernel 2.6.16.54-0.2.3-smp with lksctp-tools-1.0.7, and later also on FreeBSD 8.2. </p> <p> This module was written for one-to-many style sockets (type <code class="code">seqpacket</code>). With the addition of <code class="bold_code"><a href="#peeloff-2">peeloff/2</a></code>, one-to-one style sockets (type <code class="code">stream</code>) were introduced. </p> <p>Record definitions for the <code class="code">gen_sctp</code> module can be found using:</p> <div class="example"><pre>-include_lib("kernel/include/inet_sctp.hrl").    </pre></div> <p>These record definitions use the "new" spelling 'adaptation', not the deprecated 'adaption', regardless of which spelling the underlying C API uses.</p>  <h2 id="id125242">Contents</h2>   <ul> <li><code class="bold_code"><a href="#types">DATA TYPES</a></code></li> <li><code class="bold_code"><a href="#exports">EXPORTS</a></code></li> <li><code class="bold_code"><a href="#options">SCTP SOCKET OPTIONS</a></code></li> <li><code class="bold_code"><a href="#examples">SCTP EXAMPLES</a></code></li> <li><code class="bold_code"><a href="#seealso">SEE ALSO</a></code></li> </ul>   <h2>Data types</h2> <p><code class="bold_code">assoc_id()</code></p> 
<p id="type-assoc_id"> An opaque term returned in for example #sctp_paddr_change{} that identifies an association for an SCTP socket. The term is opaque except for the special value <code class="code">0</code> that has a meaning such as "the whole endpoint" or "all future associations". </p>  <h3 class="code">option() = <br>    {active, true | false | once | -32768..32767} |<br>    {buffer, integer() &gt;= 0} |<br>    {dontroute, boolean()} |<br>    {high_msgq_watermark, integer() &gt;= 1} |<br>    {linger, {boolean(), integer() &gt;= 0}} |<br>    {low_msgq_watermark, integer() &gt;= 1} |<br>    {mode, list | binary} |<br>    list |<br>    binary |<br>    {priority, integer() &gt;= 0} |<br>    {recbuf, integer() &gt;= 0} |<br>    {reuseaddr, boolean()} |<br>    {ipv6_v6only, boolean()} |<br>    {sctp_adaptation_layer, #sctp_setadaptation{}} |<br>    {sctp_associnfo, #sctp_assocparams{}} |<br>    {sctp_autoclose, integer() &gt;= 0} |<br>    {sctp_default_send_param, #sctp_sndrcvinfo{}} |<br>    {sctp_delayed_ack_time, #sctp_assoc_value{}} |<br>    {sctp_disable_fragments, boolean()} |<br>    {sctp_events, #sctp_event_subscribe{}} |<br>    {sctp_get_peer_addr_info, #sctp_paddrinfo{}} |<br>    {sctp_i_want_mapped_v4_addr, boolean()} |<br>    {sctp_initmsg, #sctp_initmsg{}} |<br>    {sctp_maxseg, integer() &gt;= 0} |<br>    {sctp_nodelay, boolean()} |<br>    {sctp_peer_addr_params, #sctp_paddrparams{}} |<br>    {sctp_primary_addr, #sctp_prim{}} |<br>    {sctp_rtoinfo, #sctp_rtoinfo{}} |<br>    {sctp_set_peer_primary_addr, #sctp_setpeerprim{}} |<br>    {sctp_status, #sctp_status{}} |<br>    {sndbuf, integer() &gt;= 0} |<br>    {tos, integer() &gt;= 0}</h3> 
<p>One of the <code class="bold_code"><a href="#options">SCTP Socket Options.</a></code></p>  <h3 class="code">option_name() = <br>    active |<br>    buffer |<br>    dontroute |<br>    high_msgq_watermark |<br>    linger |<br>    low_msgq_watermark |<br>    mode |<br>    priority |<br>    recbuf |<br>    reuseaddr |<br>    ipv6_v6only |<br>    sctp_adaptation_layer |<br>    sctp_associnfo |<br>    sctp_autoclose |<br>    sctp_default_send_param |<br>    sctp_delayed_ack_time |<br>    sctp_disable_fragments |<br>    sctp_events |<br>    sctp_get_peer_addr_info |<br>    sctp_i_want_mapped_v4_addr |<br>    sctp_initmsg |<br>    sctp_maxseg |<br>    sctp_nodelay |<br>    sctp_peer_addr_params |<br>    sctp_primary_addr |<br>    sctp_rtoinfo |<br>    sctp_set_peer_primary_addr |<br>    sctp_status |<br>    sndbuf |<br>    tos</h3>  <p><code class="bold_code">sctp_socket()</code></p> 
<p id="type-sctp_socket"> Socket identifier returned from <code class="code">open/*</code>.</p>   <h2>Exports</h2> <h3 id="abort-2" class="code">abort(Socket, Assoc) -&gt; ok | {error, <a href="../inet/#type-posix">inet:posix()</a>}</h3> <p>Types:</p>    <pre>Socket = <a href="#type-sctp_socket">sctp_socket()</a>
Assoc = #sctp_assoc_change{}</pre>

<p>Abnormally terminates the association given by <code class="code">Assoc</code>, without flushing of unsent data. The socket itself remains open. Other associations opened on this socket are still valid, and it can be used in new associations.</p>  <h3 id="close-1" class="code">close(Socket) -&gt; ok | {error, <a href="../inet/#type-posix">inet:posix()</a>}</h3> <p>Types:</p>   <pre>Socket = <a href="#type-sctp_socket">sctp_socket()</a></pre>

<p>Completely closes the socket and all associations on it. The unsent data is flushed as in <code class="code">eof/2</code>. The <code class="code">close/1</code> call is blocking or otherwise depending of the value of the <code class="bold_code"><a href="../inet/#option-linger">linger</a></code> socket <code class="bold_code"><a href="#options">option</a></code>. If <code class="code">close</code> does not linger or linger timeout expires, the call returns and the data is flushed in the background.</p>  <h3 id="connect-4" class="code">connect(Socket, Addr, Port, Opts) -&gt;<br>           {ok, Assoc} | {error, <a href="../inet/#type-posix">inet:posix()</a>}</h3> <p>Types:</p>       <pre>Socket = <a href="#type-sctp_socket">sctp_socket()</a>
Addr = <a href="../inet/#type-ip_address">inet:ip_address()</a> | <a href="../inet/#type-hostname">inet:hostname()</a>
Port = <a href="../inet/#type-port_number">inet:port_number()</a>
Opts = [Opt :: <a href="#type-option">option()</a>]
Assoc = #sctp_assoc_change{}</pre>

<p>Same as <code class="code">connect(Socket, Addr, Port, Opts, infinity)</code>.</p>  <h3 id="connect-5" class="code">connect(Socket, Addr, Port, Opts, Timeout) -&gt;<br>           {ok, Assoc} | {error, <a href="../inet/#type-posix">inet:posix()</a>}</h3> <p>Types:</p>        <pre>Socket = <a href="#type-sctp_socket">sctp_socket()</a>
Addr = <a href="../inet/#type-ip_address">inet:ip_address()</a> | <a href="../inet/#type-hostname">inet:hostname()</a>
Port = <a href="../inet/#type-port_number">inet:port_number()</a>
Opts = [Opt :: <a href="#type-option">option()</a>]
Timeout = timeout()
Assoc = #sctp_assoc_change{}</pre>

<p>Establishes a new association for the socket <code class="code">Socket</code>, with the peer (SCTP server socket) given by <code class="code">Addr</code> and <code class="code">Port</code>. The <code class="code">Timeout</code>, is expressed in milliseconds. A socket can be associated with multiple peers.</p> <p><strong>WARNING:</strong>Using a value of <code class="code">Timeout</code> less than the maximum time taken by the OS to establish an association (around 4.5 minutes if the default values from RFC 4960 are used) can result in inconsistent or incorrect return values. This is especially relevant for associations sharing the same <code class="code">Socket</code> (i.e. source address and port) since the controlling process blocks until <code class="code">connect/*</code> returns. <code class="bold_code"><a href="#connect_init-4">connect_init/*</a></code> provides an alternative not subject to this limitation.</p> <p id="record-sctp_assoc_change"> The result of <code class="code">connect/*</code> is an <code class="code">#sctp_assoc_change{}</code> event which contains, in particular, the new <code class="bold_code"><a href="#type-assoc_id">Association ID</a></code>.</p> <div class="example"><pre> #sctp_assoc_change{
      state             = atom(),
      error             = atom(),
      outbound_streams  = integer(),
      inbound_streams   = integer(),
      assoc_id          = assoc_id()
}        </pre></div> <p>The number of outbound and inbound streams can be set by giving an <code class="code">sctp_initmsg</code> option to <code class="code">connect</code> as in:</p> <div class="example"><pre>connect(Socket, Ip, Port&gt;,
      [{sctp_initmsg,#sctp_initmsg{num_ostreams=OutStreams,
                                   max_instreams=MaxInStreams}}])        </pre></div> <p>All options <code class="code">Opt</code> are set on the socket before the association is attempted. If an option record has got undefined field values, the options record is first read from the socket for those values. In effect, <code class="code">Opt</code> option records only define field values to change before connecting.</p> <p>The returned <code class="code">outbound_streams</code> and <code class="code">inbound_streams</code> are the actual stream numbers on the socket, which may be different from the requested values (<code class="code">OutStreams</code> and <code class="code">MaxInStreams</code> respectively) if the peer requires lower values.</p> <p>The following values of <code class="code">state</code> are possible:</p> <ul> <li> <p><code class="code">comm_up</code>: association successfully established. This indicates a successful completion of <code class="code">connect</code>.</p> </li> <li> <p><code class="code">cant_assoc</code>: association cannot be established (<code class="code">connect/*</code> failure).</p> </li> </ul> <p>All other states do not normally occur in the output from <code class="code">connect/*</code>. Rather, they may occur in <code class="code">#sctp_assoc_change{}</code> events received instead of data in <code class="bold_code"><a href="#recv-1">recv/*</a></code> calls. All of them indicate losing the association due to various error conditions, and are listed here for the sake of completeness. The <code class="code">error</code> field may provide more detailed diagnostics.</p> <ul> <li> <p><code class="code">comm_lost</code>;</p> </li> <li> <p><code class="code">restart</code>;</p> </li> <li> <p><code class="code">shutdown_comp</code>.</p> </li> </ul>  <h3 id="connect_init-4" class="code">connect_init(Socket, Addr, Port, Opts) -&gt;<br>                ok | {error, <a href="../inet/#type-posix">inet:posix()</a>}</h3> <p>Types:</p>      <pre>Socket = <a href="#type-sctp_socket">sctp_socket()</a>
Addr = <a href="../inet/#type-ip_address">inet:ip_address()</a> | <a href="../inet/#type-hostname">inet:hostname()</a>
Port = <a href="../inet/#type-port_number">inet:port_number()</a>
Opts = [<a href="#type-option">option()</a>]</pre>

<p>Same as <code class="code">connect_init(Socket, Addr, Port, Opts, infinity)</code>.</p>  <h3 id="connect_init-5" class="code">connect_init(Socket, Addr, Port, Opts, Timeout) -&gt;<br>                ok | {error, <a href="../inet/#type-posix">inet:posix()</a>}</h3> <p>Types:</p>       <pre>Socket = <a href="#type-sctp_socket">sctp_socket()</a>
Addr = <a href="../inet/#type-ip_address">inet:ip_address()</a> | <a href="../inet/#type-hostname">inet:hostname()</a>
Port = <a href="../inet/#type-port_number">inet:port_number()</a>
Opts = [<a href="#type-option">option()</a>]
Timeout = timeout()</pre>

<p>Initiates a new association for the socket <code class="code">Socket</code>, with the peer (SCTP server socket) given by <code class="code">Addr</code> and <code class="code">Port</code>.</p> <p>The fundamental difference between this API and <code class="code">connect/*</code> is that the return value is that of the underlying OS connect(2) system call. If <code class="code">ok</code> is returned then the result of the association establishement is received by the calling process as an <code class="bold_code"><a href="#record-sctp_assoc_change"> #sctp_assoc_change{}</a></code> event. The calling process must be prepared to receive this, or poll for it using <code class="code">recv/*</code> depending on the value of the active option.</p> <p>The parameters are as described in <code class="bold_code"><a href="#connect-5">connect/*</a></code>, with the exception of the <code class="code">Timeout</code> value.</p> <p>The timer associated with <code class="code">Timeout</code> only supervises IP resolution of <code class="code">Addr</code></p>  <h3 id="controlling_process-2" class="code">controlling_process(Socket, Pid) -&gt; ok | {error, Reason}</h3> <p>Types:</p>     <pre>Socket = <a href="#type-sctp_socket">sctp_socket()</a>
Pid = pid()
Reason = closed | not_owner | <a href="../inet/#type-posix">inet:posix()</a></pre>

<p>Assigns a new controlling process <code class="code">Pid</code> to <code class="code">Socket</code>. Same implementation as <code class="code">gen_udp:controlling_process/2</code>.</p>  <h3 id="eof-2" class="code">eof(Socket, Assoc) -&gt; ok | {error, Reason}</h3> <p>Types:</p>     <pre>Socket = <a href="#type-sctp_socket">sctp_socket()</a>
Assoc = #sctp_assoc_change{}
Reason = term()</pre>

<p>Gracefully terminates the association given by <code class="code">Assoc</code>, with flushing of all unsent data. The socket itself remains open. Other associations opened on this socket are still valid, and it can be used in new associations.</p>  <h3 id="listen-2" class="code">listen(Socket, IsServer) -&gt; ok | {error, Reason}<br>listen(Socket, Backlog) -&gt; ok | {error, Reason}</h3> <p>Types:</p>     <pre>Socket = <a href="#type-sctp_socket">sctp_socket()</a>
Backlog = integer()
Reason = term()</pre>

<p>Sets up a socket to listen on the IP address and port number it is bound to.</p> <p>For type <code class="code">seqpacket</code> sockets (the default) <code class="code">IsServer</code> must be <code class="code">true</code> or <code class="code">false</code>. In contrast to TCP, in SCTP there is no listening queue length. If <code class="code">IsServer</code> is <code class="code">true</code> the socket accepts new associations, i.e. it will become an SCTP server socket.</p> <p>For type <code class="code">stream</code> sockets Backlog defines the backlog queue length just like in TCP.</p>  <h3 id="open-2" class="code">open() -&gt; {ok, Socket} | {error, <a href="../inet/#type-posix">inet:posix()</a>}<br>open(Port) -&gt; {ok, Socket} | {error, <a href="../inet/#type-posix">inet:posix()</a>}<br>open(Opts) -&gt; {ok, Socket} | {error, <a href="../inet/#type-posix">inet:posix()</a>}<br>open(Port, Opts) -&gt; {ok, Socket} | {error, <a href="../inet/#type-posix">inet:posix()</a>}</h3> <p>Types:</p>        <pre>Opts = [Opt]
Opt = 
    {ip, IP} |
    {ifaddr, IP} |
    <a href="../inet/#type-address_family">inet:address_family()</a> |
    {port, Port} |
    {type, SockType} |
    <a href="#type-option">option()</a>
IP = <a href="../inet/#type-ip_address">inet:ip_address()</a> | any | loopback
Port = <a href="../inet/#type-port_number">inet:port_number()</a>
SockType = seqpacket | stream
Socket = <a href="#type-sctp_socket">sctp_socket()</a></pre>

<p>Creates an SCTP socket and binds it to the local addresses specified by all <code class="code">{ip,IP}</code> (or synonymously <code class="code">{ifaddr,IP}</code>) options (this feature is called SCTP multi-homing). The default <code class="code">IP</code> and <code class="code">Port</code> are <code class="code">any</code> and <code class="code">0</code>, meaning bind to all local addresses on any one free port.</p> <p>Other options are:</p> <dl> <dt><strong><code class="code">inet6</code></strong></dt> <dd> <p>Set up the socket for IPv6.</p> </dd> <dt><strong><code class="code">inet</code></strong></dt> <dd> <p>Set up the socket for IPv4. This is the default.</p> </dd> </dl> <p>A default set of socket <code class="bold_code"><a href="#options">options</a></code> is used. In particular, the socket is opened in <code class="bold_code"><a href="#option-binary">binary</a></code> and <code class="bold_code"><a href="#option-active">passive</a></code> mode, with SockType <code class="code">seqpacket</code>, and with reasonably large <code class="bold_code"><a href="../inet/#option-sndbuf">kernel</a></code> and driver <code class="bold_code"><a href="../inet/#option-buffer">buffers.</a></code></p>  <h3 id="peeloff-2" class="code">peeloff(Socket, Assoc) -&gt; {ok, NewSocket} | {error, Reason}</h3> <p>Types:</p>      <pre>Socket = <a href="#type-sctp_socket">sctp_socket()</a>
Assoc = #sctp_assoc_change{} | <a href="#type-assoc_id">assoc_id()</a>
NewSocket = <a href="#type-sctp_socket">sctp_socket()</a>
Reason = term()</pre>

<p> Branch off an existing association Assoc in a socket Socket of type <code class="code">seqpacket</code> (one-to-many style) into a new socket NewSocket of type <code class="code">stream</code> (one-to-one style). </p> <p> The existing association argument Assoc can be either a <code class="bold_code"><a href="#record-sctp_assoc_change"> #sctp_assoc_change{} </a></code> record as returned from e.g <code class="bold_code"><a href="#recv-2">recv/*</a></code>, <code class="bold_code"><a href="#connect-5">connect/*</a></code> or from a listening socket in active mode. Or it can be just the field <code class="code">assoc_id</code> integer from such a record. </p>  <h3 id="recv-2" class="code">recv(Socket) -&gt;<br>        {ok, {FromIP, FromPort, AncData, Data}} | {error, Reason}<br>recv(Socket, Timeout) -&gt;<br>        {ok, {FromIP, FromPort, AncData, Data}} | {error, Reason}</h3> <p>Types:</p>         <pre>Socket = <a href="#type-sctp_socket">sctp_socket()</a>
Timeout = timeout()
FromIP = <a href="../inet/#type-ip_address">inet:ip_address()</a>
FromPort = <a href="../inet/#type-port_number">inet:port_number()</a>
AncData = [#sctp_sndrcvinfo{}]
Data = 
    binary() |
    string() |
    #sctp_sndrcvinfo{} |
    #sctp_assoc_change{} |
    #sctp_paddr_change{} |
    #sctp_adaptation_event{}
Reason = 
    <a href="../inet/#type-posix">inet:posix()</a> |
    #sctp_send_failed{} |
    #sctp_paddr_change{} |
    #sctp_pdapi_event{} |
    #sctp_remote_error{} |
    #sctp_shutdown_event{}</pre>

<p>Receives the <code class="code">Data</code> message from any association of the socket. If the receive times out <code class="code">{error,timeout</code> is returned. The default timeout is <code class="code">infinity</code>. <code class="code">FromIP</code> and <code class="code">FromPort</code> indicate the sender's address.</p> <p><code class="code">AncData</code> is a list of Ancillary Data items which may be received along with the main <code class="code">Data</code>. This list can be empty, or contain a single <code class="bold_code"><a href="#record-sctp_sndrcvinfo">#sctp_sndrcvinfo{}</a></code> record, if receiving of such ancillary data is enabled (see option <code class="bold_code"><a href="#option-sctp_events">sctp_events</a></code>). It is enabled by default, since such ancillary data provide an easy way of determining the association and stream over which the message has been received. (An alternative way would be to get the Association ID from the <code class="code">FromIP</code> and <code class="code">FromPort</code> using the <code class="bold_code"><a href="#option-sctp_get_peer_addr_info">sctp_get_peer_addr_info</a></code> socket option, but this would still not produce the Stream number).</p> <p id="sctp_events">The actual <code class="code">Data</code> received may be a <code class="code">binary()</code>, or <code class="code">list()</code> of bytes (integers in the range 0 through 255) depending on the socket mode, or an SCTP Event.  The following SCTP Events are possible:</p> <ul> <li> <p><code class="bold_code"><a href="#record-sctp_sndrcvinfo">#sctp_sndrcvinfo{}</a></code></p> </li> <li> <p><code class="bold_code"><a href="#record-sctp_assoc_change">#sctp_assoc_change{}</a></code>;</p> </li> <li> <div class="example"><pre>#sctp_paddr_change{
      addr      = {ip_address(),port()},
      state     = atom(),
      error     = integer(),
      assoc_id  = assoc_id()
}            </pre></div> <p>Indicates change of the status of the peer's IP address given by <code class="code">addr</code> within the association <code class="code">assoc_id</code>. Possible values of <code class="code">state</code> (mostly self-explanatory) include:</p> <ul> <li> <p><code class="code">addr_unreachable</code>;</p> </li> <li> <p><code class="code">addr_available</code>;</p> </li> <li> <p><code class="code">addr_removed</code>;</p> </li> <li> <p><code class="code">addr_added</code>;</p> </li> <li> <p><code class="code">addr_made_prim</code>.</p> </li> <li> <p><code class="code">addr_confirmed</code>.</p> </li> </ul> <p>In case of an error (e.g. <code class="code">addr_unreachable</code>), the <code class="code">error</code> field provides additional diagnostics. In such cases, the <code class="code">#sctp_paddr_change{}</code> Event is automatically converted into an <code class="code">error</code> term returned by <code class="code">gen_sctp:recv</code>. The <code class="code">error</code> field value can be converted into a string using <code class="code">error_string/1</code>.</p> </li> <li> <div class="example"><pre>#sctp_send_failed{
      flags     = true | false,
      error     = integer(),
      info      = #sctp_sndrcvinfo{},
      assoc_id  = assoc_id()
      data      = binary()
}            </pre></div> <p>The sender may receive this event if a send operation fails. The <code class="code">flags</code> is a Boolean specifying whether the data have actually been transmitted over the wire; <code class="code">error</code> provides extended diagnostics, use <code class="code">error_string/1</code>; <code class="code">info</code> is the original <code class="bold_code"><a href="#record-sctp_sndrcvinfo">#sctp_sndrcvinfo{}</a></code> record used in the failed <code class="bold_code"><a href="#send-3">send/*,</a></code> and <code class="code">data</code> is the whole original data chunk attempted to be sent.</p> <p>In the current implementation of the Erlang/SCTP binding, this Event is internally converted into an <code class="code">error</code> term returned by <code class="code">recv/*</code>.</p> </li> <li> <div class="example"><pre>#sctp_adaptation_event{
      adaptation_ind = integer(),
      assoc_id       = assoc_id()
}            </pre></div> <p>Delivered when a peer sends an Adaptation Layer Indication parameter (configured through the option <code class="bold_code"><a href="#option-sctp_adaptation_layer">sctp_adaptation_layer</a></code>). Note that with the current implementation of the Erlang/SCTP binding, this event is disabled by default.</p> </li> <li> <div class="example"><pre>#sctp_pdapi_event{
      indication = sctp_partial_delivery_aborted,
      assoc_id   = assoc_id()
}            </pre></div> <p>A partial delivery failure. In the current implementation of the Erlang/SCTP binding, this Event is internally converted into an <code class="code">error</code> term returned by <code class="code">recv/*</code>.</p> </li> </ul>  <h3 id="send-3" class="code">send(Socket, SndRcvInfo, Data) -&gt; ok | {error, Reason}</h3> <p>Types:</p>      <pre>Socket = <a href="#type-sctp_socket">sctp_socket()</a>
SndRcvInfo = #sctp_sndrcvinfo{}
Data = binary() | iolist()
Reason = term()</pre>

<p>Sends the <code class="code">Data</code> message with all sending parameters from a <code class="bold_code"><a href="#record-sctp_sndrcvinfo">#sctp_sndrcvinfo{}</a></code> record. This way, the user can specify the PPID (passed to the remote end) and Context (passed to the local SCTP layer) which can be used for example for error identification. However, such a fine level of user control is rarely required. The send/4 function is sufficient for most applications.</p>  <h3 id="send-4" class="code">send(Socket, Assoc, Stream, Data) -&gt; ok | {error, Reason}</h3> <p>Types:</p>       <pre>Socket = <a href="#type-sctp_socket">sctp_socket()</a>
Assoc = #sctp_assoc_change{} | <a href="#type-assoc_id">assoc_id()</a>
Stream = integer()
Data = binary() | iolist()
Reason = term()</pre>

<p>Sends <code class="code">Data</code> message over an existing association and given stream.</p>  <h3 id="error_string-1" class="code">error_string(ErrorNumber) -&gt; ok | string() | unknown_error</h3> <p>Types:</p>   <pre>ErrorNumber = integer()</pre>

<p>Translates an SCTP error number from for example <code class="code">#sctp_remote_error{}</code> or <code class="code">#sctp_send_failed{}</code> into an explanatory string, or one of the atoms <code class="code">ok</code> for no error and <code class="code">undefined</code> for an unrecognized error.</p>  <h2 id="id126749">Sctp socket options</h2>   <p>The set of admissible SCTP socket options is by construction orthogonal to the sets of TCP, UDP and generic INET options: only those options which are explicitly listed below are allowed for SCTP sockets. Options can be set on the socket using <code class="bold_code"><a href="#open-1"><span class="code">gen_sctp:open/1,2</span></a></code> or <code class="bold_code"><a href="../inet/#setopts-2"><span class="code">inet:setopts/2</span></a></code>, retrieved using <code class="bold_code"><a href="../inet/#getopts-2"><span class="code">inet:getopts/2</span></a></code>, and when calling <code class="bold_code"><a href="#connect-4"><span class="code">gen_sctp:connect/4,5</span></a></code> options can be changed.</p>   <dl> <dt><strong><code class="code">{mode, list|binary}</code> or just <code class="code">list</code> or <code class="code">binary</code></strong></dt> <dd id="option-active"> <p>Determines the type of data returned from <code class="code">gen_sctp:recv/1,2</code>.</p>  </dd> <dt><strong><code class="code">{active, true|false|once|N}</code></strong></dt> <dd> <ul> <li> <p>If <code class="code">false</code> (passive mode, the default), the caller needs to do an explicit <code class="code">gen_sctp:recv</code> call in order to retrieve the available data from the socket.</p> </li> <li> <p>If <code class="code">true</code> (full active mode), the pending data or events are sent to the owning process.</p> <p><strong>NB:</strong> This can cause the message queue to overflow, as there is no way to throttle the sender in this case (no flow control!).</p> </li> <li> <p>If <code class="code">once</code>, only one message is automatically placed in the message queue, and after that the mode is automatically reset to passive. This provides flow control as well as the possibility for the receiver to listen for its incoming SCTP data interleaved with other inter-process messages.</p> </li> <li> <p>If <code class="code">active</code> is specified as an integer <code class="code">N</code> in the range -32768 to 32767 (inclusive), then that number is added to the socket's count of the number of data messages to be delivered to the controlling process. If the result of the addition would be negative, the count is set to 0. Once the count reaches 0, either through the delivery of messages or by being explicitly set with <code class="bold_code"><a href="../inet/#setopts-2">inet:setopts/2</a></code>, the socket's mode is automatically reset to passive (<code class="code">{active, false}</code>) mode. When a socket in this active mode transitions to passive mode, the message <code class="code">{sctp_passive, Socket}</code> is sent to the controlling process to notify it that if it wants to receive more data messages from the socket, it must call <code class="bold_code"><a href="../inet/#setopts-2">inet:setopts/2</a></code> to set the socket back into an active mode.</p> </li> </ul> </dd> <dt><strong><code class="code">{tos, integer()}</code></strong></dt> <dd> <p>Sets the Type-Of-Service field on the IP datagrams being sent, to the given value, which effectively determines a prioritization policy for the outbound packets. The acceptable values are system-dependent. TODO: we do not provide symbolic names for these values yet.</p> </dd> <dt><strong><code class="code">{priority, integer()}</code></strong></dt> <dd> <p>A protocol-independent equivalent of <code class="code">tos</code> above. Setting priority implies setting tos as well.</p> </dd> <dt><strong><code class="code">{dontroute, true|false}</code></strong></dt> <dd> <p>By default <code class="code">false</code>. If <code class="code">true</code>, the kernel does not send packets via any gateway, only sends them to directly connected hosts.</p> </dd> <dt><strong><code class="code">{reuseaddr, true|false}</code></strong></dt> <dd> <p>By default <code class="code">false</code>. If true, the local binding address <code class="code">{IP,Port}</code> of the socket can be re-used immediately: no waiting in the CLOSE_WAIT state is performed (may be required for high-throughput servers).</p> </dd> <dt><strong><code class="code">{sndbuf, integer()}</code></strong></dt> <dd> <p>The size, in bytes, of the *kernel* send buffer for this socket. Sending errors would occur for datagrams larger than <code class="code">val(sndbuf)</code>. Setting this option also adjusts the size of the driver buffer (see <code class="code">buffer</code> above).</p> </dd> <dt><strong><code class="code">{recbuf, integer()}</code></strong></dt> <dd> <p>The size, in bytes, of the *kernel* recv buffer for this socket. Sending errors would occur for datagrams larger than <code class="code">val(sndbuf)</code>. Setting this option also adjusts the size of the driver buffer (see <code class="code">buffer</code> above).</p> </dd> <dt><strong><code class="code">{sctp_module, module()}</code></strong></dt> <dd> <p> Override which callback module is used. Defaults to <code class="code">inet_sctp</code> for IPv4 and <code class="code">inet6_sctp</code> for IPv6. </p> </dd> <dt><strong><code class="code">{sctp_rtoinfo, #sctp_rtoinfo{}}</code></strong></dt> <dd> <div class="example"><pre>#sctp_rtoinfo{
      assoc_id = assoc_id(),
      initial  = integer(),
      max      = integer(),
      min      = integer()
}        </pre></div> <p>Determines re-transmission time-out parameters, in milliseconds, for the association(s) given by <code class="code">assoc_id</code>. If <code class="code">assoc_id = 0</code> (default) indicates the whole endpoint. See <code class="bold_code"><a href="http://www.rfc-archive.org/getrfc.php?rfc=2960" target="_blank">RFC2960</a></code> and <code class="bold_code"><a href="http://tools.ietf.org/html/draft-ietf-tsvwg-sctpsocket-13" target="_blank">Sockets API Extensions for SCTP</a></code> for the exact semantics of the fields values.</p> </dd> <dt><strong><code class="code">{sctp_associnfo, #sctp_assocparams{}}</code></strong></dt> <dd> <div class="example"><pre>#sctp_assocparams{
      assoc_id                 = assoc_id(),
      asocmaxrxt               = integer(),
      number_peer_destinations = integer(),
      peer_rwnd                = integer(),
      local_rwnd               = integer(),
      cookie_life              = integer()
}        </pre></div> <p>Determines association parameters for the association(s) given by <code class="code">assoc_id</code>. <code class="code">assoc_id = 0</code> (default) indicates the whole endpoint. See <code class="bold_code"><a href="http://tools.ietf.org/html/draft-ietf-tsvwg-sctpsocket-13" target="_blank">Sockets API Extensions for SCTP</a></code> for the discussion of their semantics. Rarely used.</p> </dd> <dt><strong><code class="code">{sctp_initmsg, #sctp_initmsg{}}</code></strong></dt> <dd> <div class="example"><pre>#sctp_initmsg{
     num_ostreams   = integer(),
     max_instreams  = integer(),
     max_attempts   = integer(),
     max_init_timeo = integer()
}        </pre></div> <p>Determines the default parameters which this socket attempts to negotiate with its peer while establishing an association with it. Should be set after <code class="code">open/*</code> but before the first <code class="code">connect/*</code>. <code class="code">#sctp_initmsg{}</code> can also be used as ancillary data with the first call of <code class="code">send/*</code> to a new peer (when a new association is created).</p> <ul> <li> <p><code class="code">num_ostreams</code>: number of outbound streams;</p> </li> <li> <p><code class="code">max_instreams</code>: max number of in-bound streams;</p> </li> <li> <p><code class="code">max_attempts</code>: max re-transmissions while establishing an association;</p> </li> <li> <p><code class="code">max_init_timeo</code>: time-out in milliseconds for establishing an association.</p> </li> </ul> </dd> <dt><strong><code class="code">{sctp_autoclose, integer() &gt;= 0}</code></strong></dt> <dd> <p>Determines the time (in seconds) after which an idle association is automatically closed. <code class="code">0</code> means that the association is never automatically closed.</p> </dd> <dt><strong><code class="code">{sctp_nodelay, true|false}</code></strong></dt> <dd> <p>Turns on|off the Nagle algorithm for merging small packets into larger ones (which improves throughput at the expense of latency).</p> </dd> <dt><strong><code class="code">{sctp_disable_fragments, true|false}</code></strong></dt> <dd> <p>If <code class="code">true</code>, induces an error on an attempt to send a message which is larger than the current PMTU size (which would require fragmentation/re-assembling). Note that message fragmentation does not affect the logical atomicity of its delivery; this option is provided for performance reasons only.</p> </dd> <dt><strong><code class="code">{sctp_i_want_mapped_v4_addr, true|false}</code></strong></dt> <dd> <p>Turns on|off automatic mapping of IPv4 addresses into IPv6 ones (if the socket address family is AF_INET6).</p> </dd> <dt><strong><code class="code">{sctp_maxseg, integer()}</code></strong></dt> <dd> <p>Determines the maximum chunk size if message fragmentation is used. If <code class="code">0</code>, the chunk size is limited by the Path MTU only.</p> </dd> <dt><strong><code class="code">{sctp_primary_addr, #sctp_prim{}}</code></strong></dt> <dd> <div class="example"><pre>#sctp_prim{
      assoc_id = assoc_id(),
      addr     = {IP, Port}
}
IP = ip_address()
Port = port_number()        </pre></div> <p>For the association given by <code class="code">assoc_id</code>, <code class="code">{IP,Port}</code> must be one of the peer's addresses. This option determines that the given address is treated by the local SCTP stack as the peer's primary address.</p> </dd> <dt><strong><code class="code">{sctp_set_peer_primary_addr, #sctp_setpeerprim{}}</code></strong></dt> <dd id="option-sctp_adaptation_layer"> <div class="example"><pre>#sctp_setpeerprim{
      assoc_id = assoc_id(),
      addr     = {IP, Port}
}
IP = ip_address()
Port = port_number()        </pre></div> <p>When set, informs the peer that it should use <code class="code">{IP, Port}</code> as the primary address of the local endpoint for the association given by <code class="code">assoc_id</code>.</p>  </dd> <dt><strong><code class="code">{sctp_adaptation_layer, #sctp_setadaptation{}}</code></strong></dt> <dd id="record-sctp_setadaptation">  <div class="example"><pre>#sctp_setadaptation{
      adaptation_ind = integer()
}        </pre></div> <p>When set, requests that the local endpoint uses the value given by <code class="code">adaptation_ind</code> as the Adaptation Indication parameter for establishing new associations. See <code class="bold_code"><a href="http://www.rfc-archive.org/getrfc.php?rfc=2960" target="_blank">RFC2960</a></code> and <code class="bold_code"><a href="http://tools.ietf.org/html/draft-ietf-tsvwg-sctpsocket-13" target="_blank">Sockets API Extenstions for SCTP</a></code> for more details.</p> </dd> <dt><strong><code class="code">{sctp_peer_addr_params, #sctp_paddrparams{}}</code></strong></dt> <dd> <div class="example"><pre>#sctp_paddrparams{
      assoc_id   = assoc_id(),
      address    = {IP, Port},
      hbinterval = integer(),
      pathmaxrxt = integer(),
      pathmtu    = integer(),
      sackdelay  = integer(),
      flags      = list()
}
IP = ip_address()
Port = port_number()        </pre></div> <p>This option determines various per-address parameters for the association given by <code class="code">assoc_id</code> and the peer address <code class="code">address</code> (the SCTP protocol supports multi-homing, so more than 1 address can correspond to a given association).</p> <ul> <li> <p><code class="code">hbinterval</code>: heartbeat interval, in milliseconds;</p> </li> <li> <p><code class="code">pathmaxrxt</code>: max number of retransmissions before this address is considered unreachable (and an alternative address is selected);</p> </li> <li> <p><code class="code">pathmtu</code>: fixed Path MTU, if automatic discovery is disabled (see <code class="code">flags</code> below);</p> </li> <li> <p><code class="code">sackdelay</code>: delay in milliseconds for SAC messages (if the delay is enabled, see <code class="code">flags</code> below);</p> </li> <li> <p><code class="code">flags</code>: the following flags are available:</p> <ul> <li> <p><code class="code">hb_enable</code>: enable heartbeat; </p> </li> <li> <p><code class="code">hb_disable</code>: disable heartbeat;</p> </li> <li> <p><code class="code">hb_demand</code>: initiate heartbeat immediately;</p> </li> <li> <p><code class="code">pmtud_enable</code>: enable automatic Path MTU discovery;</p> </li> <li> <p><code class="code">pmtud_disable</code>: disable automatic Path MTU discovery;</p> </li> <li> <p><code class="code">sackdelay_enable</code>: enable SAC delay;</p> </li> <li> <p><code class="code">sackdelay_disable</code>: disable SAC delay.</p> </li> </ul> </li> </ul> </dd> <dt><strong><code class="code">{sctp_default_send_param, #sctp_sndrcvinfo{}}</code></strong></dt> <dd id="option-sctp_events">  <div class="example"><pre>#sctp_sndrcvinfo{
      stream     = integer(),
      ssn        = integer(),
      flags      = list(),
      ppid       = integer(),
      context    = integer(),
      timetolive = integer(),
      tsn        = integer(),
      cumtsn     = integer(),
      assoc_id   = assoc_id()
}        </pre></div> <p><code class="code">#sctp_sndrcvinfo{}</code> is used both in this socket option, and as ancillary data while sending or receiving SCTP messages. When set as an option, it provides a default values for subsequent <code class="code">gen_sctp:send</code>calls on the association given by <code class="code">assoc_id</code>. <code class="code">assoc_id = 0</code> (default) indicates the whole endpoint. The following fields typically need to be specified by the sender:</p> <ul> <li> <p><code class="code">sinfo_stream</code>: stream number (0-base) within the association to send the messages through;</p> </li> <li> <p><code class="code">sinfo_flags</code>: the following flags are recognised:</p> <ul> <li> <p><code class="code">unordered</code>: the message is to be sent unordered;</p> </li> <li> <p><code class="code">addr_over</code>: the address specified in <code class="code">gen_sctp:send</code> overwrites the primary peer address;</p> </li> <li> <p><code class="code">abort</code>: abort the current association without flushing any unsent data;</p> </li> <li> <p><code class="code">eof</code>: gracefully shut down the current association, with flushing of unsent data.</p> </li> </ul> <p>Other fields are rarely used. See <code class="bold_code"><a href="http://www.rfc-archive.org/getrfc.php?rfc=2960" target="_blank">RFC2960</a></code> and <code class="bold_code"><a href="http://tools.ietf.org/html/draft-ietf-tsvwg-sctpsocket-13" target="_blank">Sockets API Extensions for SCTP</a></code> for full information.</p> </li> </ul>  </dd> <dt><strong><code class="code">{sctp_events, #sctp_event_subscribe{}}</code></strong></dt> <dd id="record-sctp_event_subscribe">  <div class="example"><pre>#sctp_event_subscribe{
        data_io_event          = true | false,
        association_event      = true | false,
        address_event          = true | false,
        send_failure_event     = true | false,
        peer_error_event       = true | false,
        shutdown_event         = true | false,
        partial_delivery_event = true | false,
        adaptation_layer_event = true | false
  }        </pre></div> <p>This option determines which <code class="bold_code"><a href="#sctp_events">SCTP Events</a></code> are to be received (via <code class="bold_code"><a href="#recv-1">recv/*</a></code>) along with the data. The only exception is <code class="code">data_io_event</code> which enables or disables receiving of <code class="bold_code"><a href="#record-sctp_sndrcvinfo">#sctp_sndrcvinfo{}</a></code> ancillary data, not events. By default, all flags except <code class="code">adaptation_layer_event</code> are enabled, although <code class="code">sctp_data_io_event</code> and <code class="code">association_event</code> are used by the driver itself and not exported to the user level.</p> </dd> <dt><strong><code class="code">{sctp_delayed_ack_time, #sctp_assoc_value{}}</code></strong></dt> <dd> <div class="example"><pre>#sctp_assoc_value{
      assoc_id    = assoc_id(),
      assoc_value = integer()
}        </pre></div> <p>Rarely used. Determines the ACK time (given by <code class="code">assoc_value</code> in milliseconds) for the given association or the whole endpoint if <code class="code">assoc_value = 0</code> (default).</p> </dd> <dt><strong><code class="code">{sctp_status, #sctp_status{}}</code></strong></dt> <dd id="option-sctp_get_peer_addr_info"> <div class="example"><pre>#sctp_status{
      assoc_id            = assoc_id(),
      state               = atom(),
      rwnd                = integer(),
      unackdata           = integer(),
      penddata            = integer(),
      instrms             = integer(),
      outstrms            = integer(),
      fragmentation_point = integer(),
      primary             = #sctp_paddrinfo{}
}        </pre></div> <p>This option is read-only. It determines the status of the SCTP association given by <code class="code">assoc_id</code>. Possible values of <code class="code">state</code> follows. The state designations are mostly self-explanatory. <code class="code">state_empty</code> is the default which means that no other state is active:</p> <ul> <li> <p><code class="code">sctp_state_empty</code></p> </li> <li> <p><code class="code">sctp_state_closed</code></p> </li> <li> <p><code class="code">sctp_state_cookie_wait</code></p> </li> <li> <p><code class="code">sctp_state_cookie_echoed</code></p> </li> <li> <p><code class="code">sctp_state_established</code></p> </li> <li> <p><code class="code">sctp_state_shutdown_pending</code></p> </li> <li> <p><code class="code">sctp_state_shutdown_sent</code></p> </li> <li> <p><code class="code">sctp_state_shutdown_received</code></p> </li> <li> <p><code class="code">sctp_state_shutdown_ack_sent</code></p> </li> </ul> <p>The semantics of other fields is the following:</p> <ul> <li> <p><code class="code">sstat_rwnd</code>: the association peer's current receiver window size;</p> </li> <li> <p><code class="code">sstat_unackdata</code>: number of unacked data chunks;</p> </li> <li> <p><code class="code">sstat_penddata</code>: number of data chunks pending receipt;</p> </li> <li> <p><code class="code">sstat_instrms</code>: number of inbound streams;</p> </li> <li> <p><code class="code">sstat_outstrms</code>: number of outbound streams;</p> </li> <li> <p><code class="code">sstat_fragmentation_point</code>: message size at which SCTP fragmentation will occur;</p> </li> <li> <p><code class="code">sstat_primary</code>: information on the current primary peer address (see below for the format of <code class="code">#sctp_paddrinfo{}</code>).</p> </li> </ul>  </dd> <dt><strong><code class="code">{sctp_get_peer_addr_info, #sctp_paddrinfo{}}</code></strong></dt> <dd id="record-sctp_paddrinfo">  <div class="example"><pre>#sctp_paddrinfo{
      assoc_id  = assoc_id(),
      address   = {IP, Port},
      state     = inactive | active | unconfirmed,
      cwnd      = integer(),
      srtt      = integer(),
      rto       = integer(),
      mtu       = integer()
}
IP = ip_address()
Port = port_number()        </pre></div> <p>This option is read-only. It determines the parameters specific to the peer's address given by <code class="code">address</code> within the association given by <code class="code">assoc_id</code>. The <code class="code">address</code> field must be set by the caller; all other fields are filled in on return. If <code class="code">assoc_id = 0</code> (default), the <code class="code">address</code> is automatically translated into the corresponding association ID. This option is rarely used; see <code class="bold_code"><a href="http://www.rfc-archive.org/getrfc.php?rfc=2960" target="_blank">RFC2960</a></code> and <code class="bold_code"><a href="http://tools.ietf.org/html/draft-ietf-tsvwg-sctpsocket-13" target="_blank">Sockets API Extensions for SCTP</a></code> for the semantics of all fields.</p> </dd> </dl>  <h2 id="id128062">Sctp examples</h2>   <ul> <li> <p>Example of an Erlang SCTP Server which receives SCTP messages and prints them on the standard output:</p> <div class="example"><pre>-module(sctp_server).

-export([server/0,server/1,server/2]).
-include_lib("kernel/include/inet.hrl").
-include_lib("kernel/include/inet_sctp.hrl").

server() -&gt;
    server(any, 2006).

server([Host,Port]) when is_list(Host), is_list(Port) -&gt;
    {ok, #hostent{h_addr_list = [IP|_]}} = inet:gethostbyname(Host),
    io:format("~w -&gt; ~w~n", [Host, IP]),
    server([IP, list_to_integer(Port)]).

server(IP, Port) when is_tuple(IP) orelse IP == any orelse IP == loopback,
                      is_integer(Port) -&gt;
    {ok,S} = gen_sctp:open(Port, [{recbuf,65536}, {ip,IP}]),
    io:format("Listening on ~w:~w. ~w~n", [IP,Port,S]),
    ok     = gen_sctp:listen(S, true),
    server_loop(S).

server_loop(S) -&gt;
    case gen_sctp:recv(S) of
    {error, Error} -&gt;
        io:format("SCTP RECV ERROR: ~p~n", [Error]);
    Data -&gt;
        io:format("Received: ~p~n", [Data])
    end,
    server_loop(S).        </pre></div> </li> <li> <p>Example of an Erlang SCTP Client which interacts with the above Server. Note that in this example, the Client creates an association with the Server with 5 outbound streams. For this reason, sending of "Test 0" over Stream 0 succeeds, but sending of "Test 5" over Stream 5 fails. The client then <code class="code">abort</code>s the association, which results in the corresponding Event being received on the Server side.</p> <div class="example"><pre>-module(sctp_client).

-export([client/0, client/1, client/2]).
-include_lib("kernel/include/inet.hrl").
-include_lib("kernel/include/inet_sctp.hrl").
 
client() -&gt;
    client([localhost]).

client([Host]) -&gt;
    client(Host, 2006);

client([Host, Port]) when is_list(Host), is_list(Port) -&gt;
    client(Host,list_to_integer(Port)),
    init:stop().

client(Host, Port) when is_integer(Port) -&gt;
    {ok,S}     = gen_sctp:open(),
    {ok,Assoc} = gen_sctp:connect
        (S, Host, Port, [{sctp_initmsg,#sctp_initmsg{num_ostreams=5}}]),
    io:format("Connection Successful, Assoc=~p~n", [Assoc]),
    
    io:write(gen_sctp:send(S, Assoc, 0, &lt;&lt;"Test 0"&gt;&gt;)),
    io:nl(),
    timer:sleep(10000),
    io:write(gen_sctp:send(S, Assoc, 5, &lt;&lt;"Test 5"&gt;&gt;)),
    io:nl(),
    timer:sleep(10000),
    io:write(gen_sctp:abort(S, Assoc)),
    io:nl(),
    
    timer:sleep(1000),
    gen_sctp:close(S).        </pre></div> </li> <li> <p>A very simple Erlang SCTP Client which uses the connect_init API.</p> <div class="example"><pre>-module(ex3).

-export([client/4]).
-include_lib("kernel/include/inet.hrl").
-include_lib("kernel/include/inet_sctp.hrl").

client(Peer1, Port1, Peer2, Port2)
  when is_tuple(Peer1), is_integer(Port1), is_tuple(Peer2), is_integer(Port2) -&gt;
    {ok,S}     = gen_sctp:open(),
    SctpInitMsgOpt = {sctp_initmsg,#sctp_initmsg{num_ostreams=5}},
    ActiveOpt = {active, true},
    Opts = [SctpInitMsgOpt, ActiveOpt],
    ok = gen_sctp:connect(S, Peer1, Port1, Opts),
    ok = gen_sctp:connect(S, Peer2, Port2, Opts),
    io:format("Connections initiated~n", []),
    client_loop(S, Peer1, Port1, undefined, Peer2, Port2, undefined).

client_loop(S, Peer1, Port1, AssocId1, Peer2, Port2, AssocId2) -&gt;
    receive
        {sctp, S, Peer1, Port1, {_Anc, SAC}}
          when is_record(SAC, sctp_assoc_change), AssocId1 == undefined -&gt;
            io:format("Association 1 connect result: ~p. AssocId: ~p~n",
                      [SAC#sctp_assoc_change.state,
                       SAC#sctp_assoc_change.assoc_id]),
            client_loop(S, Peer1, Port1, SAC#sctp_assoc_change.assoc_id,
                        Peer2, Port2, AssocId2);

        {sctp, S, Peer2, Port2, {_Anc, SAC}}
          when is_record(SAC, sctp_assoc_change), AssocId2 == undefined -&gt;
            io:format("Association 2 connect result: ~p. AssocId: ~p~n",
                      [SAC#sctp_assoc_change.state, SAC#sctp_assoc_change.assoc_id]),
            client_loop(S, Peer1, Port1, AssocId1, Peer2, Port2,
                        SAC#sctp_assoc_change.assoc_id);

        {sctp, S, Peer1, Port1, Data} -&gt;
            io:format("Association 1: received ~p~n", [Data]),
            client_loop(S, Peer1, Port1, AssocId1,
                        Peer2, Port2, AssocId2);

        {sctp, S, Peer2, Port2, Data} -&gt;
            io:format("Association 2: received ~p~n", [Data]),
            client_loop(S, Peer1, Port1, AssocId1,
                        Peer2, Port2, AssocId2);

        Other -&gt;
            io:format("Other ~p~n", [Other]),
            client_loop(S, Peer1, Port1, AssocId1,
                        Peer2, Port2, AssocId2)

    after 5000 -&gt;
            ok
    end.
</pre></div> </li> </ul>  <h2 id="id128156">See also</h2>   <p><code class="bold_code"><a href="../inet/">inet(3)</a></code>, <code class="bold_code"><a href="../gen_tcp/">gen_tcp(3)</a></code>, <code class="bold_code"><a href="../gen_udp/">gen_udp(3)</a></code>, <code class="bold_code"><a href="http://www.rfc-archive.org/getrfc.php?rfc=2960" target="_blank">RFC2960</a></code> (Stream Control Transmission Protocol), <code class="bold_code"><a href="http://tools.ietf.org/html/draft-ietf-tsvwg-sctpsocket-13" target="_blank">Sockets API Extensions for SCTP.</a></code></p>
<div class="_attribution">
  <p class="_attribution-p">
    © 1999–2016 Ericsson AB<br>Licensed under the Apache License, Version 2.0.<br>
    
  </p>
</div>

			</div>
		</div>
	</section>

	</div>
</body>
</html>
