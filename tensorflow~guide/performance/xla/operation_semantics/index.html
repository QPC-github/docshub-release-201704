
<!DOCTYPE HTML>

<html lang="en">

<head>
  <meta charset="utf-8">
  <title>Operation Semantics - TensorFlow Guide - W3cubDocs</title>
  
  <meta name="description" content="The following describes the semantics of operations defined in the ComputationBuilder interface. Typically, these operations map one-to-one to &hellip;">
  <meta name="keywords" content="operation, semantics, -, tensorflow, guide, tensorflow~guide">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="http://docs.w3cub.com/tensorflow~guide/performance/xla/operation_semantics/">
  <link href="/favicon.png" rel="icon">
  <link type="text/css" rel="stylesheet" href="/assets/application-50364fff564ce3b6327021805f3f00e2957b441cf27f576a7dd4ff63bbc47047.css">
  <script type="text/javascript" src="/assets/application-db64bfd54ceb42be11af7995804cf4902548419ceb79d509b0b7d62c22d98e6f.js"></script>
  <script src="/json/tensorflow~guide.js"></script>
  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-71174418-1']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>


</head>

<body>
	<div class="_app">
	<header class="_header">
  
  <form class="_search">
    <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
    <a class="_search-clear"></a>
    <div class="_search-tag"></div>
  </form>
  
  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/tensorflow~guide/" class="_nav-link" title="" style="margin-left:0;">TensorFlow Guide</a></span>
  
  <nav class="_nav">
    <a href="/app/" class="_nav-link ">App</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		<div class="_list">
			
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<div class="_page _tensorflow">
				
<h1 itemprop="name" class="devsite-page-title"> Operation Semantics </h1>     <p>The following describes the semantics of operations defined in the <a href="https://www.tensorflow.org/code/tensorflow/compiler/xla/client/computation_builder.h" target="_blank"><code>ComputationBuilder</code></a> interface. Typically, these operations map one-to-one to operations defined in the RPC interface in <a href="https://www.tensorflow.org/code/tensorflow/compiler/xla/xla_data.proto" target="_blank"><code>xla_data.proto</code></a>.</p> <p>A note on nomenclature: the generalized data type XLA deals with is an N-dimensional array holding elements of some uniform type (such as 32-bit float). Throughout the documentation, <em>array</em> is used to denote an arbitrary-dimensional array. For convenience, special cases have more specific and familiar names; for example a <em>vector</em> is a 1-dimensional array and a <em>matrix</em> is a 2-dimensional array.</p> <h2 id="broadcast">Broadcast</h2> <p>See also <a href="https://www.tensorflow.org/code/tensorflow/compiler/xla/client/computation_builder.h" target="_blank"><code>ComputationBuilder::Broadcast</code></a>.</p> <p>Adds dimensions to an array by duplicating the data in the array.</p> <p><b> <code>Broadcast(operand, broadcast_sizes)</code> </b></p> <table> <thead> <tr> <th>Arguments</th> <th>Type</th> <th>Semantics</th> </tr> </thead> <tbody> <tr> <td><code>operand</code></td> <td><code>ComputationDataHandle</code></td> <td>The array to duplicate</td> </tr> <tr> <td><code>broadcast_sizes</code></td> <td><code>ArraySlice&lt;int64&gt;</code></td> <td>The sizes of the new dimensions</td> </tr> </tbody> </table> <p>The new dimensions are inserted on the left, i.e. if <code>broadcast_sizes</code> has values <code>{a0, ..., aN}</code> and the operand shape has dimensions <code>{b0, ..., bM}</code> then the shape of the output has dimensions <code>{a0, ..., aN, b0, ..., bM}</code>.</p> <p>The new dimensions index into copies of the operand, i.e.</p> <pre class="prettyprint" data-language="cpp">output[i0, ..., iN, j0, ..., jM] = operand[j0, ..., jM]
</pre> <p>For example, if <code>operand</code> is a scalar <code>f32</code> with value <code>2.0f</code>, and <code>broadcast_sizes</code> is <code>{2, 3}</code>, then the result will be an array with shape <code>f32[2, 3]</code> and all the values in the result will be <code>2.0f</code>.</p> <h2 id="call">Call</h2> <p>See also <a href="https://www.tensorflow.org/code/tensorflow/compiler/xla/client/computation_builder.h" target="_blank"><code>ComputationBuilder::Call</code></a>.</p> <p>Invokes a computation with the given arguments.</p> <p><b> <code>Call(computation, args...)</code> </b></p> <table> <thead> <tr> <th>Arguments</th> <th>Type</th> <th>Semantics</th> </tr> </thead> <tbody> <tr> <td><code>computation</code></td> <td><code>Computation</code></td> <td>computation of type <code>T_0, T_1, ..., T_N -&gt; S</code> with N parameters of arbitrary type</td> </tr> <tr> <td><code>args</code></td> <td>sequence of N <code>ComputationDataHandle</code>s</td> <td>N arguments of arbitrary type</td> </tr> </tbody> </table> <p>The arity and types of the <code>args</code> must match the parameters of the <code>computation</code>. It is allowed to have no <code>args</code>.</p> <h2 id="collapse">Collapse</h2> <p>See also <a href="https://www.tensorflow.org/code/tensorflow/compiler/xla/client/computation_builder.h" target="_blank"><code>ComputationBuilder::Collapse</code></a> and the <a href="https://www.tensorflow.org/api_docs/python/tf/reshape" target="_blank"><code>tf.reshape</code></a> operation.</p> <p>Collapses dimensions of an array into one dimension.</p> <p><b> <code>Collapse(operand, dimensions)</code> </b></p> <table> <thead> <tr> <th>Arguments</th> <th>Type</th> <th>Semantics</th> </tr> </thead> <tbody> <tr> <td><code>operand</code></td> <td><code>ComputationDataHandle</code></td> <td>array of type T</td> </tr> <tr> <td><code>dimensions</code></td> <td>
<code>int64</code> vector</td> <td>in-order, consecutive subset of T's dimensions.</td> </tr> </tbody> </table> <p>Collapse replaces the given subset of the operand's dimensions by a single dimension. The input arguments are an arbitrary array of type T and a compile-time-constant vector of dimension indices. The dimension indices must be an in-order (low to high dimension numbers), consecutive subset of T's dimensions. Thus, {0, 1, 2}, {0, 1}, or {1, 2} are all valid dimension sets, but {1, 0} or {0, 2} are not. They are replaced by a single new dimension, in the same position in the dimension sequence as those they replace, with the new dimension size equal to the product of original dimension sizes. The lowest dimension number in <code>dimensions</code> is the slowest varying dimension (most major) in the loop nest which collapses these dimension, and the highest dimension number is fastest varying (most minor). See the <a href="https://www.tensorflow.org/api_docs/python/tf/reshape" target="_blank"><code>tf.reshape</code></a> operator if more general collapse ordering is needed.</p> <p>For example, let v be an array of 24 elements:</p> <pre class="prettyprint" data-language="cpp">let v = f32[4x2x3] { { {10, 11, 12},  {15, 16, 17}},
                    { {20, 21, 22},  {25, 26, 27}},
                    { {30, 31, 32},  {35, 36, 37}},
                    { {40, 41, 42},  {45, 46, 47}}};

// Collapse to a single dimension, leaving one dimension.
let v012 = Collapse(v, {0,1,2});
then v012 == f32[24] {10, 11, 12, 15, 16, 17,
                      20, 21, 22, 25, 26, 27,
                      30, 31, 32, 35, 36, 37,
                      40, 41, 42, 45, 46, 47};

// Collapse the two lower dimensions, leaving two dimensions.
let v01 = Collapse(v, {0,1});
then v01 == f32[4x6] { {10, 11, 12, 15, 16, 17},
                      {20, 21, 22, 25, 26, 27},
                      {30, 31, 32, 35, 36, 37},
                      {40, 41, 42, 45, 46, 47}};

// Collapse the two higher dimensions, leaving two dimensions.
let v12 = Collapse(v, {1,2});
then v12 == f32[8x3] { {10, 11, 12},
                      {15, 16, 17},
                      {20, 21, 22},
                      {25, 26, 27},
                      {30, 31, 32},
                      {35, 36, 37},
                      {40, 41, 42},
                      {45, 46, 47}};

</pre> <h2 id="concatenate">Concatenate</h2> <p>See also <a href="https://www.tensorflow.org/code/tensorflow/compiler/xla/client/computation_builder.h" target="_blank"><code>ComputationBuilder::ConcatInDim</code></a>.</p> <p>Concatenate composes an array from multiple array operands. The array is of the same rank as each of the input array operands (which must be of the same rank as each other) and contains the arguments in the order that they were specified.</p> <p><b> <code>Concatenate(operands..., dimension)</code> </b></p> <table> <thead> <tr> <th>Arguments</th> <th>Type</th> <th>Semantics</th> </tr> </thead> <tbody> <tr> <td><code>operands</code></td> <td>sequence of N <code>ComputationDataHandle</code>
</td> <td>N arrays of type T with dimensions [L0, L1, ...]. Requires N &gt;= 1.</td> </tr> <tr> <td><code>dimension</code></td> <td><code>int64</code></td> <td>A value in the interval <code>[0, N)</code> that names the dimension to be concatenated between the <code>operands</code>.</td> </tr> </tbody> </table> <p>With the exception of <code>dimension</code> all dimensions must be the same. This is because XLA does not support "ragged" arrays Also note that rank-0 values cannot be concatenated (as it's impossible to name the dimension along which the concatenation occurs).</p> <p>1-dimensional example:</p> <pre class="prettyprint" data-language="cpp">Concat({ {2, 3}, {4, 5}, {6, 7}}, 0)
&gt;&gt;&gt; {2, 3, 4, 5, 6, 7}
</pre> <p>2-dimensional example:</p> <pre class="prettyprint" data-language="cpp">let a = {
  {1, 2},
  {3, 4},
  {5, 6},
};
let b = {
  {7, 8},
};
Concat({a, b}, 0)
&gt;&gt;&gt; {
  {1, 2},
  {3, 4},
  {5, 6},
  {7, 8},
}
</pre> <p>Diagram: </p>
<div style="width:95%; margin:auto; margin-bottom:10px; margin-top:20px;"> <img style="width:100%" src="https://www.tensorflow.org/images/ops_concatenate.png"> </div> <h2 id="convertelementtype">ConvertElementType</h2> <p>See also <a href="https://www.tensorflow.org/code/tensorflow/compiler/xla/client/computation_builder.h" target="_blank"><code>ComputationBuilder::ConvertElementType</code></a>.</p> <p>Similar to an element-wise <code>static_cast</code> in C++, performs an element-wise conversion operation from a data shape to a target shape. The dimensions must match, and the conversion is an element-wise one; e.g. <code>s32</code> elements become <code>f32</code> elements via an <code>s32</code>-to-<code>f32</code> conversion routine.</p> <p><b> <code>ConvertElementType(operand, new_element_type)</code> </b></p> <table> <thead> <tr> <th>Arguments</th> <th>Type</th> <th>Semantics</th> </tr> </thead> <tbody> <tr> <td><code>operand</code></td> <td><code>ComputationDataHandle</code></td> <td>array of type T with dims D</td> </tr> <tr> <td><code>new_element_type</code></td> <td><code>PrimitiveType</code></td> <td>type U</td> </tr> </tbody> </table> <p>If the dimensions of the operand and the target shape do not match, or an invalid conversion is requested (e.g. to/from a tuple) an error will be produced.</p> <p>A conversion such as <code>T=s32</code> to <code>U=f32</code> will perform a normalizing int-to-float conversion routine such as round-to-nearest-even.</p> <blockquote> <aside class="note"><strong>Note:</strong><span> The precise float-to-int and visa-versa conversions are currently unspecified, but may become additional arguments to the convert operation in the future. Not all possible conversions have been implemented for all targets.</span></aside> </blockquote> <pre class="prettyprint" data-language="cpp">let a: s32[3] = {0, 1, 2};
let b: f32[3] = convert(a, f32);
then b == f32[3]{0.0, 1.0, 2.0}
</pre> <h2 id="conv_convolution">Conv (convolution)</h2> <p>See also <a href="https://www.tensorflow.org/code/tensorflow/compiler/xla/client/computation_builder.h" target="_blank"><code>ComputationBuilder::Conv</code></a>.</p> <p>As ConvWithGeneralPadding, but the padding is specified in a short-hand way as either SAME or VALID. SAME padding pads the input (<code>lhs</code>) with zeroes so that the output has the same shape as the input when not taking striding into account. VALID padding simply means no padding.</p> <h2 id="convwithgeneralpadding_convolution">ConvWithGeneralPadding (convolution)</h2> <p>See also <a href="https://www.tensorflow.org/code/tensorflow/compiler/xla/client/computation_builder.h" target="_blank"><code>ComputationBuilder::ConvWithGeneralPadding</code></a>.</p> <p>Computes a convolution of the kind used in neural networks. Here, a convolution can be thought of as a n-dimensional window moving across a n-dimensional base area and a computation is performed for each possible position of the window.</p> <table> <thead> <tr> <th>Arguments</th> <th>Type</th> <th>Semantics</th> </tr> </thead> <tbody> <tr> <td><code>lhs</code></td> <td><code>ComputationDataHandle</code></td> <td>rank n+2 array of inputs</td> </tr> <tr> <td><code>rhs</code></td> <td><code>ComputationDataHandle</code></td> <td>rank n+2 array of kernel weights</td> </tr> <tr> <td><code>window_strides</code></td> <td><code>ArraySlice&lt;int64&gt;</code></td> <td>n-d array of kernel strides</td> </tr> <tr> <td><code>padding</code></td> <td><code>ArraySlice&lt;pair&lt;int64, int64&gt;&gt;</code></td> <td>n-d array of (low, high) padding</td> </tr> <tr> <td><code>lhs_dilation</code></td> <td><code>ArraySlice&lt;int64&gt;</code></td> <td>n-d lhs dilation factor array</td> </tr> <tr> <td><code>rhs_dilation</code></td> <td><code>ArraySlice&lt;int64&gt;</code></td> <td>n-d rhs dilation factor array</td> </tr> </tbody> </table> <p>Let n be the number of spatial dimensions. The <code>lhs</code> argument is a rank n+2 array describing the base area. This is called the input, even though of course the rhs is also an input. In a neural network, these are the input activations. The n+2 dimensions are, in this order:</p> <ul> <li>
<code>batch</code>: Each coordinate in this dimension represents an independent input for which convolution is carried out.</li> <li>
<code>z/depth/features</code>: Each (y,x) position in the base area has a vector associated to it, which goes into this dimension.</li> <li>
<code>spatial_dims</code>: Describes the <code>n</code> spatial dimensions that define the base area that the window moves across.</li> </ul> <p>The <code>rhs</code> argument is a rank n+2 array describing the convolutional filter/kernel/window. The dimensions are, in this order:</p> <ul> <li>
<code>output-z</code>: The <code>z</code> dimension of the output.</li> <li>
<code>input-z</code>: The size of this dimension should equal the size of the <code>z</code> dimension in lhs.</li> <li>
<code>spatial_dims</code>: Describes the <code>n</code> spatial dimensions that define the n-d window that moves across the base area.</li> </ul> <p>The <code>window_strides</code> argument specifies the stride of the convolutional window in the spatial dimensions. For example, if the stride in a the first spatial dimension is 3, then the window can only be placed at coordinates where the first spatial index is divisible by 3.</p> <p>The <code>padding</code> argument specifies the amount of zero padding to be applied to the base area. The amount of padding can be negative -- the absolute value of negative padding indicates the number of elements to remove from the specified dimension before doing the convolution. <code>padding[0]</code> specifies the padding for dimension <code>y</code> and <code>padding[1]</code> specifies the padding for dimension <code>x</code>. Each pair has the low padding as the first element and the high padding as the second element. The low padding is applied in the direction of lower indices while the high padding is applied in the direction of higher indices. For example, if <code>padding[1]</code> is <code>(2,3)</code> then there will be a padding by 2 zeroes on the left and by 3 zeroes on the right in the second spatial dimension. Using padding is equivalent to inserting those same zero values into the input (<code>lhs</code>) before doing the convolution.</p> <p>The <code>lhs_dilation</code> and <code>rhs_dilation</code> arguments specify the dilation factor to be applied to the lhs and rhs, respectively, in each spatial dimension. If the dilation factor in a spatial dimension is d, then d-1 holes are implicitly placed between each of the entries in that dimension, increasing the size of the array. The holes are filled with a no-op value, which for convolution means zeroes.</p> <p>Dilation of the rhs is also called atrous convolution. For more details, see the <a href="https://www.tensorflow.org/api_docs/python/tf/nn/atrous_conv2d" target="_blank"><code>tf.nn.atrous_conv2d</code></a>. Dilation of the lhs is also called deconvolution.</p> <p>The output shape has these dimensions, in this order:</p> <ul> <li>
<code>batch</code>: Same size as <code>batch</code> on the input (<code>lhs</code>).</li> <li>
<code>z</code>: Same size as <code>output-z</code> on the kernel (<code>rhs</code>).</li> <li>
<code>spatial_dims</code>: One value for each valid placement of the convolutional window.</li> </ul> <p>The valid placements of the convolutional window are determined by the strides and the size of the base area after padding.</p> <p>To describe what a convolution does, consider a 2d convolution, and pick some fixed <code>batch</code>, <code>z</code>, <code>y</code>, <code>x</code> coordinates in the output. Then <code>(y,x)</code> is a position of a corner of the window within the base area (e.g. the upper left corner, depending on how you interpret the spatial dimensions). We now have a 2d window, taken from the base area, where each 2d point is associated to a 1d vector, so we get a 3d box. From the convolutional kernel, since we fixed the output coordinate <code>z</code>, we also have a 3d box. The two boxes have the same dimensions, so we can take the sum of the element-wise products between the two boxes (similar to a dot product). That is the output value.</p> <p>Note that if <code>output-z</code> is e.g., 5, then each position of the window produces 5 values in the output into the <code>z</code> dimension of the output. These values differ in what part of the convolutional kernel is used - there is a separate 3d box of values used for each <code>output-z</code> coordinate. So you could think of it as 5 separate convolutions with a different filter for each of them.</p> <p>Here is pseudo-code for a 2d convolution with padding and striding:</p> <pre class="prettyprint" data-language="cpp">for (b, oz, oy, ox) {  // output coordinates
  value = 0;
  for (iz, ky, kx) {  // kernel coordinates and input z
    iy = oy*stride_y + ky - pad_low_y;
    ix = ox*stride_x + kx - pad_low_x;
    if ((iy, ix) inside the base area considered without padding) {
      value += input(b, iz, iy, ix) * kernel(oz, iz, ky, kx);
    }
  }
  output(b, oz, oy, ox) = value;
}
</pre> <h2 id="crossreplicasum">CrossReplicaSum</h2> <p>See also <a href="https://www.tensorflow.org/code/tensorflow/compiler/xla/client/computation_builder.h" target="_blank"><code>ComputationBuilder::CrossReplicaSum</code></a>.</p> <p>Computes a sum across replicas.</p> <p><b> <code>CrossReplicaSum(operand)</code> </b></p> <table> <thead> <tr> <th>Arguments</th> <th>Type</th> <th>Semantics</th> </tr> </thead> <tbody> <tr> <td><code>operand</code></td> <td><code>ComputationDataHandle</code></td> <td>Array to sum across replicas.</td> </tr> </tbody> </table> <p>The output shape is the same as the input shape. For example, if there are two replicas and the operand has the value <code>(1.0, 2.5)</code> and <code>(3.0, 5.1)</code> respectively on the two replicas, then the output value from this op will be <code>(4.0, 7.6)</code> on both replicas.</p> <p>Computing the result of CrossReplicaSum requires having one input from each replica, so if one replica executes a CrossReplicaSum node more times than another, then the former replica will wait forever. Since the replicas are all running the same program, there are not a lot of ways for that to happen, but it is possible when a while loop's condition depends on data from infeed and the data that is infed causes the while loop to iterate more times on one replica than another.</p> <h2 id="customcall">CustomCall</h2> <p>See also <a href="https://www.tensorflow.org/code/tensorflow/compiler/xla/client/computation_builder.h" target="_blank"><code>ComputationBuilder::CustomCall</code></a>.</p> <p>Call a user-provided function within a computation.</p> <p><b> <code>CustomCall(target_name, args..., shape)</code> </b></p> <table> <thead> <tr> <th>Arguments</th> <th>Type</th> <th>Semantics</th> </tr> </thead> <tbody> <tr> <td><code>target_name</code></td> <td><code>string</code></td> <td>Name of the function. A call instruction will be emitted which targets this symbol name.</td> </tr> <tr> <td><code>args</code></td> <td>sequence of N <code>ComputationDataHandle</code>s</td> <td>N arguments of arbitrary type, which will be passed to the function.</td> </tr> <tr> <td><code>shape</code></td> <td><code>Shape</code></td> <td>Output shape of the function</td> </tr> </tbody> </table> <p>The function signature is the same, regardless of the arity or type of args:</p> <pre class="prettyprint" data-language="cpp">extern "C" void target_name(void* out, void** in);
</pre> <p>For example, if CustomCall is used as follows:</p> <pre class="prettyprint" data-language="cpp">let x = f32[2] {1,2};
let y = f32[2x3] { {10, 20, 30}, {40, 50, 60}};

CustomCall("myfunc", {x, y}, f32[3x3])
</pre> <p>Here is an example of an implementation of <code>myfunc</code>:</p> <pre class="prettyprint" data-language="cpp">extern "C" void myfunc(void* out, void** in) {
  float (&amp;x)[2] = *static_cast&lt;float(*)[2]&gt;(in[0]);
  float (&amp;y)[2][3] = *static_cast&lt;float(*)[2][3]&gt;(in[1]);
  EXPECT_EQ(1, x[0]);
  EXPECT_EQ(2, x[1]);
  EXPECT_EQ(10, y[0][0]);
  EXPECT_EQ(20, y[0][1]);
  EXPECT_EQ(30, y[0][2]);
  EXPECT_EQ(40, y[1][0]);
  EXPECT_EQ(50, y[1][1]);
  EXPECT_EQ(60, y[1][2]);
  float (&amp;z)[3][3] = *static_cast&lt;float(*)[3][3]&gt;(out);
  z[0][0] = x[1] + y[1][0];
  // ...
}
</pre> <p>The user-provided function must not have side-effects and its execution must be idempotent.</p> <blockquote> <aside class="note"><strong>Note:</strong><span> The opaque nature of the user-provided function restricts optimization opportunities for the compiler. Try to express your computation in terms of native XLA ops whenever possible; only use CustomCall as a last resort.</span></aside> </blockquote> <h2 id="dot">Dot</h2> <p>See also <a href="https://www.tensorflow.org/code/tensorflow/compiler/xla/client/computation_builder.h" target="_blank"><code>ComputationBuilder::Dot</code></a>.</p> <p><b> <code>Dot(lhs, rhs)</code> </b></p> <table> <thead> <tr> <th>Arguments</th> <th>Type</th> <th>Semantics</th> </tr> </thead> <tbody> <tr> <td><code>lhs</code></td> <td><code>ComputationDataHandle</code></td> <td>array of type T</td> </tr> <tr> <td><code>rhs</code></td> <td><code>ComputationDataHandle</code></td> <td>array of type T</td> </tr> </tbody> </table> <p>The exact semantics of this operation depend on the ranks of the operands:</p> <table> <thead> <tr> <th>Input</th> <th>Output</th> <th>Semantics</th> </tr> </thead> <tbody> <tr> <td>vector [n] <code>dot</code> vector [n]</td> <td>scalar</td> <td>vector dot product</td> </tr> <tr> <td>matrix [m x k] <code>dot</code> vector [k]</td> <td>vector [m]</td> <td>matrix-vector multiplication</td> </tr> <tr> <td>matrix [m x k] <code>dot</code> matrix [k x n]</td> <td>matrix [m x n]</td> <td>matrix-matrix multiplication</td> </tr> </tbody> </table> <p>The operation performs sum of products over the last dimension of <code>lhs</code> and the one-before-last dimension of <code>rhs</code>. These are the "contracted" dimensions. The contracted dimensions of <code>lhs</code> and <code>rhs</code> must be of the same size. In practice, it can be used to perform dot products between vectors, vector/matrix multiplications or matrix/matrix multiplications.</p> <h2 id="element-wise_binary_arithmetic_operations">Element-wise binary arithmetic operations</h2> <p>See also <a href="https://www.tensorflow.org/code/tensorflow/compiler/xla/client/computation_builder.h" target="_blank"><code>ComputationBuilder::Add</code></a>.</p> <p>A set of element-wise binary arithmetic operations is supported.</p> <p><b> <code>Op(lhs, rhs)</code> </b></p> <p>Where <code>Op</code> is one of <code>Add</code> (addition), <code>Sub</code> (subtraction), <code>Mul</code> (multiplication), <code>Div</code> (division), <code>Rem</code> (remainder), <code>Max</code> (maximum), <code>Min</code> (minimum), <code>LogicalAnd</code> (logical AND), or <code>LogicalOr</code> (logical OR).</p> <table> <thead> <tr> <th>Arguments</th> <th>Type</th> <th>Semantics</th> </tr> </thead> <tbody> <tr> <td><code>lhs</code></td> <td><code>ComputationDataHandle</code></td> <td>left-hand-side operand: array of type T</td> </tr> <tr> <td><code>rhs</code></td> <td><code>ComputationDataHandle</code></td> <td>right-hand-side operand: array of type T</td> </tr> </tbody> </table> <p>The arguments' shapes have to be either similar or compatible. See the <a href="../broadcasting/">broadcasting</a> documentation about what it means for shapes to be compatible. The result of an operation has a shape which is the result of broadcasting the two input arrays. In this variant, operations between arrays of different ranks are <em>not</em> supported, unless one of the operands is a scalar.</p> <p>When <code>Op</code> is <code>Rem</code>, the sign of the result is taken from the dividend, and the absolute value of the result is always less than the divisor's absolute value.</p> <p>An alternative variant with different-rank broadcasting support exists for these operations:</p> <p><b> <code>Op(lhs, rhs, broadcast_dimensions)</code> </b></p> <p>Where <code>Op</code> is the same as above. This variant of the operation should be used for arithmetic operations between arrays of different ranks (such as adding a matrix to a vector).</p> <p>The additional <code>broadcast_dimensions</code> operand is a slice of integers used to expand the rank of the lower-rank operand up to the rank of the higher-rank operand. <code>broadcast_dimensions</code> maps the dimensions of the lower-rank shape to the dimensions of the higher-rank shape. The unmapped dimensions of the expanded shape are filled with dimensions of size one. Degenerate-dimension broadcasting then broadcasts the shapes along these degenerate dimension to equalize the shapes of both operands. The semantics are described in detail on the <a href="../broadcasting/">broadcasting page</a>.</p> <h2 id="element-wise_comparison_operations">Element-wise comparison operations</h2> <p>See also <a href="https://www.tensorflow.org/code/tensorflow/compiler/xla/client/computation_builder.h" target="_blank"><code>ComputationBuilder::Eq</code></a>.</p> <p>A set of standard element-wise binary comparison operations is supported. Note that standard IEEE 754 floating-point comparison semantics apply when comparing floating-point types.</p> <p><b> <code>Op(lhs, rhs)</code> </b></p> <p>Where <code>Op</code> is one of <code>Eq</code> (equal-to), <code>Ne</code> (not equal-to), <code>Ge</code> (greater-or-equal-than), <code>Gt</code> (greater-than), <code>Le</code> (less-or-equal-than), <code>Le</code> (less-than).</p> <table> <thead> <tr> <th>Arguments</th> <th>Type</th> <th>Semantics</th> </tr> </thead> <tbody> <tr> <td><code>lhs</code></td> <td><code>ComputationDataHandle</code></td> <td>left-hand-side operand: array of type T</td> </tr> <tr> <td><code>rhs</code></td> <td><code>ComputationDataHandle</code></td> <td>right-hand-side operand: array of type T</td> </tr> </tbody> </table> <p>The arguments' shapes have to be either similar or compatible. See the <a href="../broadcasting/">broadcasting</a> documentation about what it means for shapes to be compatible. The result of an operation has a shape which is the result of broadcasting the two input arrays with the element type <code>PRED</code>. In this variant, operations between arrays of different ranks are <em>not</em> supported, unless one of the operands is a scalar.</p> <p>An alternative variant with different-rank broadcasting support exists for these operations:</p> <p><b> <code>Op(lhs, rhs, broadcast_dimensions)</code> </b></p> <p>Where <code>Op</code> is the same as above. This variant of the operation should be used for comparison operations between arrays of different ranks (such as adding a matrix to a vector).</p> <p>The additional <code>broadcast_dimensions</code> operand is a slice of integers specifying the dimensions to use for broadcasting the operands. The semantics are described in detail on the <a href="../broadcasting/">broadcasting page</a>.</p> <h2 id="element-wise_unary_functions">Element-wise unary functions</h2> <p>ComputationBuilder supports these element-wise unary functions:</p> <p><b><code>Abs(operand)</code></b> Element-wise abs <code>x -&gt; |x|</code>.</p> <p><b><code>Ceil(operand)</code></b> Element-wise ceil <code>x -&gt; ⌈x⌉</code>.</p> <p><b><code>Exp(operand)</code></b> Element-wise natural exponential <code>x -&gt; e^x</code>.</p> <p><b><code>Floor(operand)</code></b> Element-wise floor <code>x -&gt; ⌊x⌋</code>.</p> <p><b><code>Log(operand)</code></b> Element-wise natural logarithm <code>x -&gt; ln(x)</code>.</p> <p><b><code>LogicalNot(operand)</code></b> Element-wise logical not <code>x -&gt; !(x)</code>.</p> <p><b><code>Neg(operand)</code></b> Element-wise negation <code>x -&gt; -x</code>.</p> <p><b><code>Sign(operand)</code></b> Element-wise sign operation <code>x -&gt; sgn(x)</code> where</p> <div> $$\text{sgn}(x) = \begin{cases} -1 &amp; x &lt; 0\\ 0 &amp; x = 0\\ 1 &amp; x &gt; 0 \end{cases}$$ </div> <p>using the comparison operator of the element type of <code>operand</code>.</p> <p><b><code>Tanh(operand)</code></b> Element-wise hyperbolic tangent <code>x -&gt; tanh(x)</code>.</p> <table> <thead> <tr> <th>Arguments</th> <th>Type</th> <th>Semantics</th> </tr> </thead> <tbody> <tr> <td><code>operand</code></td> <td><code>ComputationDataHandle</code></td> <td>The operand to the function</td> </tr> </tbody> </table> <p>The function is applied to each element in the <code>operand</code> array, resulting in an array with the same shape. It is allowed for <code>operand</code> to be a scalar (rank 0).</p> <h2 id="gettupleelement">GetTupleElement</h2> <p>See also <a href="https://www.tensorflow.org/code/tensorflow/compiler/xla/client/computation_builder.h" target="_blank"><code>ComputationBuilder::GetTupleElement</code></a>.</p> <p>Indexes into a tuple with a compile-time-constant value.</p> <p>The value must be a compile-time-constant so that shape inference can determine the type of the resulting value.</p> <p>This is analogous to <code>std::get&lt;int N&gt;(t)</code> in C++. Conceptually:</p> <pre class="prettyprint" data-language="cpp">let v: f32[10] = f32[10]{0, 1, 2, 3, 4, 5, 6, 7, 8, 9};
let s: s32 = 5;
let t: (f32[10], s32) = tuple(v, s);
let element_1: s32 = gettupleelement(t, 1);  // Inferred shape matches s32.
</pre> <p>See also <a href="https://www.tensorflow.org/api_docs/python/tf/tuple" target="_blank"><code>tf.tuple</code></a>.</p> <h2 id="infeed">Infeed</h2> <p>See also <a href="https://www.tensorflow.org/code/tensorflow/compiler/xla/client/computation_builder.h" target="_blank"><code>ComputationBuilder::Infeed</code></a>.</p> <p><b> <code>Infeed(shape)</code> </b></p> <table> <thead> <tr> <th>Argument</th> <th>Type</th> <th>Semantics</th> </tr> </thead> <tbody> <tr> <td><code>shape</code></td> <td><code>Shape</code></td> <td>Shape of the data read from the Infeed interface. The layout field of the shape must be set to match the layout of the data sent to the device; otherwise its behavior is undefined.</td> </tr> </tbody> </table> <p>Reads a single data item from the implicit Infeed streaming interface of the device, interpreting the data as the given shape and its layout, and returns a <code>ComputationDataHandle</code> of the data. Multiple Infeed operations are allowed in a computation, but there must be a total order among the Infeed operations. For example, two Infeeds in the code below have a total order since there is a dependency between the while loops. The compiler issues an error if there isn't a total order.</p> <pre class="prettyprint" data-language="cpp">result1 = while (condition, init = init_value) {
  Infeed(shape)
}

result2 = while (condition, init = result1) {
  Infeed(shape)
}
</pre> <p>Nested tuple shapes are not supported. For an empty tuple shape, the Infeed operation is effectively a nop and proceeds without reading any data from the Infeed of the device.</p> <blockquote> <aside class="note"><strong>Note:</strong><span> We plan to allow multiple Infeed operations without a total order, in which case the compiler will provide information about how the Infeed operations are serialized in the compiled program.</span></aside> </blockquote> <h2 id="map">Map</h2> <p>See also <a href="https://www.tensorflow.org/code/tensorflow/compiler/xla/client/computation_builder.h" target="_blank"><code>ComputationBuilder::Map</code></a>.</p> <p><b> <code>Map(operands..., computation)</code> </b></p> <table> <thead> <tr> <th>Arguments</th> <th>Type</th> <th>Semantics</th> </tr> </thead> <tbody> <tr> <td><code>operands</code></td> <td>sequence of N <code>ComputationDataHandle</code>s</td> <td>N arrays of types T_0..T_{N-1}</td> </tr> <tr> <td><code>computation</code></td> <td><code>Computation</code></td> <td>computation of type <code>T_0, T_1, ..., T_{N + M -1} -&gt; S</code> with N parameters of type T and M of arbitrary type</td> </tr> <tr> <td><code>static_operands</code></td> <td>sequence of M <code>ComputationDataHandle</code>s</td> <td>M arrays of arbitrary type</td> </tr> </tbody> </table> <p>Applies a scalar function over the given <code>operands</code> arrays, producing an array of the same dimensions where each element is the result of the mapped function applied to the corresponding elements in the input arrays with <code>static_operands</code> given as additional input to <code>computation</code>.</p> <p>The mapped function is an arbitrary computation with the restriction that it has N inputs of scalar type <code>T</code> and a single output with type <code>S</code>. The output has the same dimensions as the operands except that the element type T is replaced with S.</p> <p>For example: <code>Map(op1, op2, op3, computation, par1)</code> maps <code>elem_out &lt;- computation(elem1, elem2, elem3, par1)</code> at each (multi-dimensional) index in the input arrays to produce the output array.</p> <h2 id="pad">Pad</h2> <p>See also <a href="https://www.tensorflow.org/code/tensorflow/compiler/xla/client/computation_builder.h" target="_blank"><code>ComputationBuilder::Pad</code></a>.</p> <p><b> <code>Pad(operand, padding_value, padding_config)</code> </b></p> <table> <thead> <tr> <th>Arguments</th> <th>Type</th> <th>Semantics</th> </tr> </thead> <tbody> <tr> <td><code>operand</code></td> <td><code>ComputationDataHandle</code></td> <td>array of type <code>T</code>
</td> </tr> <tr> <td><code>padding_value</code></td> <td><code>ComputationDataHandle</code></td> <td>scalar of type <code>T</code> to fill in the added padding</td> </tr> <tr> <td><code>padding_config</code></td> <td><code>PaddingConfig</code></td> <td>padding amount on both edges (low, high) and between the elements of each dimension</td> </tr> </tbody> </table> <p>Expands the given <code>operand</code> array by padding around the array as well as between the elements of the array with the given <code>padding_value</code>. <code>padding_config</code> specifies the amount of edge padding and the interior padding for each dimension.</p> <p><code>PaddingConfig</code> is a repeated field of <code>PaddingConfigDimension</code>, which contains three fields for each dimension: <code>edge_padding_low</code>, <code>edge_padding_high</code>, and <code>interior_padding</code>. <code>edge_padding_low</code> and <code>edge_padding_high</code> specifies the amount of padding added at the low-end (next to index 0) and the high-end (next to the highest index) of each dimension respectively. The amount of edge padding can be negative -- the absolute value of negative padding indicates the number of elements to remove from the specified dimension. <code>interior_padding</code> specifies the amount of padding added between any two elements in each dimension. Interior padding occurs logically before edge padding, so in the case of negative edge padding elements are removed from the interior-padded operand. This operation is a no-op if the edge padding pairs are all (0, 0) and the interior padding values are all 0. Figure below shows examples of different <code>edge_padding</code> and <code>interior_padding</code> values for a two dimensional array.</p> <div style="width:95%; margin:auto; margin-bottom:10px; margin-top:20px;"> <img style="width:100%" src="https://www.tensorflow.org/images/ops_pad.png"> </div> <h2 id="reduce">Reduce</h2> <p>See also <a href="https://www.tensorflow.org/code/tensorflow/compiler/xla/client/computation_builder.h" target="_blank"><code>ComputationBuilder::Reduce</code></a>.</p> <p>Applies a reduction function to an array.</p> <p><b> <code>Reduce(operand, init_value, computation, dimensions)</code> </b></p> <table> <thead> <tr> <th>Arguments</th> <th>Type</th> <th>Semantics</th> </tr> </thead> <tbody> <tr> <td><code>operand</code></td> <td><code>ComputationDataHandle</code></td> <td>array of type <code>T</code>
</td> </tr> <tr> <td><code>init_value</code></td> <td><code>ComputationDataHandle</code></td> <td>scalar of type <code>T</code>
</td> </tr> <tr> <td><code>computation</code></td> <td><code>Computation</code></td> <td>computation of type <code>T, T -&gt; T</code>
</td> </tr> <tr> <td><code>dimensions</code></td> <td>
<code>int64</code> array</td> <td>unordered array of dimensions to reduce</td> </tr> </tbody> </table> <p>Conceptually, this operation reduces one or more dimensions in the input array into scalars. The rank of the result array is <code>rank(operand) - len(dimensions)</code>. <code>init_value</code> is the initial value used for every reduction and may also be inserted anywhere during computation if the back-end chooses to do so. So in most cases <code>init_value</code> should be an identity of the reduction function (for example, 0 for addition).</p> <p>The evaluation order of the reduction function across the reduction dimensions is arbitrary and may be non-deterministic. Therefore, the reduction function should not be overly sensitive to reassociation[^1].</p> <p>As an example, when reducing across the one dimension in a 1D array with values [10, 11, 12, 13], with reduction function <code>f</code> (this is <code>computation</code>) then that could be computed as</p> <p><code>f(10, f(11, f(12, f(init_value, 13)))</code></p> <p>but there are also many other possibilities, e.g.</p> <p><code>f(init_value, f(f(10, f(init_value, 11)), f(f(init_value, 12), f(13, init_value))))</code></p> <p>The following is a rough pseudo-code example of how reduction could be implemented, using summation as the reduction computation with an initial value of 0.</p> <pre class="prettyprint lang-python" data-language="python">result_shape &lt;- remove all dims in dimensions from operand_shape

# Iterate over all elements in result_shape. The number of r's here is equal
# to the rank of the result
for r0 in range(result_shape[0]), r1 in range(result_shape[1]), ...:
  # Initialize this result element
  result[r0, r1...] &lt;- 0

  # Iterate over all the reduction dimensions
  for d0 in range(dimensions[0]), d1 in range(dimensions[1]), ...:
    # Increment the result element with the value of the operand's element.
    # The index of the operand's element is constructed from all ri's and di's
    # in the right order (by construction ri's and di's together index over the
    # whole operand shape).
    result[r0, r1...] += operand[ri... di]
</pre> <p>Here's an example of reducing a 2D array (matrix). The shape has rank 2, dimension 0 of size 2 and dimension 1 of size 3:</p> <div style="width:95%; margin:auto; margin-bottom:10px; margin-top:20px;"> <img style="width:35%" src="https://www.tensorflow.org/images/ops_2d_matrix.png"> </div> <p>Results of reducing dimensions 0 or 1 with an "add" function:</p> <div style="width:95%; margin:auto; margin-bottom:10px; margin-top:20px;"> <img style="width:35%" src="https://www.tensorflow.org/images/ops_reduce_from_2d_matrix.png"> </div> <p>Note that both reduction results are 1D arrays. The diagram shows one as column and another as row just for visual convenience.</p> <p>For a more complex example, here is a 3D array. Its rank is 3, dimension 0 of size 4, dimension 1 of size 2 and dimension 2 of size 3. For simplicity, the values 1 to 6 are replicated across dimension 0.</p> <div style="width:95%; margin:auto; margin-bottom:10px; margin-top:20px;"> <img style="width:35%" src="https://www.tensorflow.org/images/ops_reduce_from_3d_matrix.png"> </div> <p>Similarly to the 2D example, we can reduce just one dimension. If we reduce dimension 0, for example, we get a rank-2 array where all values across dimension 0 were folded into a scalar:</p> <pre class="prettyprint lang-text" data-language="cpp">| 4  8  12 |
| 4  8  12 |
</pre> <p>If we reduce dimension 2, we also get a rank-2 array where all values across dimension 2 were folded into a scalar:</p> <pre class="prettyprint lang-text" data-language="cpp">| 6  15 |
| 6  15 |
| 6  15 |
| 6  15 |
</pre> <p>Note that the relative order between the remaining dimensions in the input is preserved in the output, but some dimensions may get assigned new numbers (since the rank changes).</p> <p>We can also reduce multiple dimensions. Add-reducing dimensions 0 and 1 produces the 1D array <code>| 20 28 36 |</code>.</p> <p>Reducing the 3D array over all its dimensions produces the scalar <code>84</code>.</p> <h2 id="reducewindow">ReduceWindow</h2> <p>See also <a href="https://www.tensorflow.org/code/tensorflow/compiler/xla/client/computation_builder.h" target="_blank"><code>ComputationBuilder::ReduceWindow</code></a>.</p> <p>Applies a reduction function to all elements in each window of the input multi-dimensional array, producing an output multi-dimensional array with the same number of elements as the number of valid positions of the window. A pooling layer can be expressed as a <code>ReduceWindow</code>.</p> <p><b> <code>ReduceWindow(operand, init_value, computation, window_dimensions, window_strides, padding)</code> </b></p> <table> <thead> <tr> <th>Arguments</th> <th>Type</th> <th>Semantics</th> </tr> </thead> <tbody> <tr> <td><code>operand</code></td> <td><code>ComputationDataHandle</code></td> <td>N dimensional array containing elements of type T. This is the base area on which the window is placed.</td> </tr> <tr> <td><code>init_value</code></td> <td><code>ComputationDataHandle</code></td> <td>Starting value for the reduction. See <a href="#reduce">Reduce</a> for details.</td> </tr> <tr> <td><code>computation</code></td> <td><code>Computation</code></td> <td>Reduction function of type <code>T, T -&gt; T</code>, to apply to all elements in each window</td> </tr> <tr> <td><code>window_dimensions</code></td> <td><code>ArraySlice&lt;int64&gt;</code></td> <td>array of integers for window dimension values</td> </tr> <tr> <td><code>window_strides</code></td> <td><code>ArraySlice&lt;int64&gt;</code></td> <td>array of integers for window stride values</td> </tr> <tr> <td><code>padding</code></td> <td><code>Padding</code></td> <td>padding type for window (Padding\:\:kSame or Padding\:\:kValid)</td> </tr> </tbody> </table> <p>Below code and figure shows an example of using <code>ReduceWindow</code>. Input is a matrix of size [4x6] and both window_dimensions and window_stride_dimensions are [2x3].</p> <pre class="prettyprint" data-language="cpp">// Create a computation for the reduction (maximum).
Computation max;
{
  ComputationBuilder builder(client_, "max");
  auto y = builder.Parameter(0, ShapeUtil::MakeShape(F32, {}), "y");
  auto x = builder.Parameter(1, ShapeUtil::MakeShape(F32, {}), "x");
  builder.Max(y, x);
  max = builder.Build().ConsumeValueOrDie();
}

// Create a ReduceWindow computation with the max reduction computation.
ComputationBuilder builder(client_, "reduce_window_2x3");
auto shape = ShapeUtil::MakeShape(F32, {4, 6});
auto input = builder.Parameter(0, shape, "input");
builder.ReduceWindow(
    input, *max,
    /*init_val=*/builder.ConstantLiteral(LiteralUtil::MinValue(F32)),
    /*window_dimensions=*/{2, 3},
    /*window_stride_dimensions=*/{2, 3},
    Padding::kValid);
</pre> <div style="width:95%; margin:auto; margin-bottom:10px; margin-top:20px;"> <img style="width:35%" src="https://www.tensorflow.org/images/ops_reduce_window.png"> </div> <p>Stride of 1 in a dimension specifies that the position of a window in the dimension is 1 element away from its adjacent window. In order to specify that no windows overlap with each other, window_stride_dimensions should be equal to window_dimensions. The figure below illustrates the use of two different stride values. Padding is applied to each dimension of the input and the calculations are the same as though the input came in with the dimensions it has after padding.</p> <div style="width:95%; margin:auto; margin-bottom:10px; margin-top:20px;"> <img style="width:75%" src="https://www.tensorflow.org/images/ops_reduce_window_stride.png"> </div> <h2 id="reshape">Reshape</h2> <p>See also <a href="https://www.tensorflow.org/code/tensorflow/compiler/xla/client/computation_builder.h" target="_blank"><code>ComputationBuilder::Reshape</code></a> and the <a href="#collapse"><code>Collapse</code></a> operation.</p> <p>Reshapes the dimensions of an array into a new configuration.</p> <p><b> <code>Reshape(operand, new_sizes)</code> </b> <b> <code>Reshape(operand, dimensions, new_sizes)</code> </b></p> <table> <thead> <tr> <th>Arguments</th> <th>Type</th> <th>Semantics</th> </tr> </thead> <tbody> <tr> <td><code>operand</code></td> <td><code>ComputationDataHandle</code></td> <td>array of type T</td> </tr> <tr> <td><code>dimensions</code></td> <td>
<code>int64</code> vector</td> <td>order in which dimensions are collapsed</td> </tr> <tr> <td><code>new_sizes</code></td> <td>
<code>int64</code> vector</td> <td>vector of sizes of new dimensions</td> </tr> </tbody> </table> <p>Conceptually, reshape first flattens an array into a one-dimensional vector of data values, and then refines this vector into a new shape. The input arguments are an arbitrary array of type T, a compile-time-constant vector of dimension indices, and a compile-time-constant vector of dimension sizes for the result. The values in the <code>dimension</code> vector, if given, must be a permutation of all of T's dimensions; the default if not given is <code>{0, ..., rank - 1}</code>. The order of the dimensions in <code>dimensions</code> is from slowest-varying dimension (most major) to fastest-varying dimension (most minor) in the loop nest which collapses the input array into a single dimension. The <code>new_sizes</code> vector determines the size of the output array. The value at index 0 in <code>new_sizes</code> is the size of dimension 0, the value at index 1 is the size of dimension 1, and so on. The product of the <code>new_size</code> dimensions must equal the product of the operand's dimension sizes. When refining the collapsed array into the multidimensional array defined by <code>new_sizes</code>, the dimensions in <code>new_sizes</code> are ordered from slowest varying (most major) and to fastest varying (most minor).</p> <p>For example, let v be an array of 24 elements:</p> <pre class="prettyprint" data-language="cpp">let v = f32[4x2x3] { { {10, 11, 12}, {15, 16, 17}},
                    { {20, 21, 22}, {25, 26, 27}},
                    { {30, 31, 32}, {35, 36, 37}},
                    { {40, 41, 42}, {45, 46, 47}}};

In-order collapse:
let v012_24 = Reshape(v, {0,1,2}, {24});
then v012_24 == f32[24] {10, 11, 12, 15, 16, 17, 20, 21, 22, 25, 26, 27,
                         30, 31, 32, 35, 36, 37, 40, 41, 42, 45, 46, 47};

let v012_83 = Reshape(v, {0,1,2}, {8,3});
then v012_83 == f32[8x3] { {10, 11, 12}, {15, 16, 17},
                          {20, 21, 22}, {25, 26, 27},
                          {30, 31, 32}, {35, 36, 37},
                          {40, 41, 42}, {45, 46, 47}};

Out-of-order collapse:
let v021_24 = Reshape(v, {1,2,0}, {24});
then v012_24 == f32[24]  {10, 20, 30, 40, 11, 21, 31, 41, 12, 22, 32, 42,
                          15, 25, 35, 45, 16, 26, 36, 46, 17, 27, 37, 47};

let v021_83 = Reshape(v, {1,2,0}, {8,3});
then v021_83 == f32[8x3] { {10, 20, 30}, {40, 11, 21},
                          {31, 41, 12}, {22, 32, 42},
                          {15, 25, 35}, {45, 16, 26},
                          {36, 46, 17}, {27, 37, 47}};

let v021_262 = Reshape(v, {1,2,0}, {2,6,2});
then v021_262 == f32[2x6x2] { { {10, 20}, {30, 40},
                              {11, 21}, {31, 41},
                              {12, 22}, {32, 42}},
                             { {15, 25}, {35, 45},
                              {16, 26}, {36, 46},
                              {17, 27}, {37, 47}}};
</pre> <p>As a special case, reshape can transform a single-element array to a scalar and vice versa. For example,</p> <pre class="prettyprint" data-language="cpp">Reshape(f32[1x1] { {5}}, {0,1}, {}) == 5;
Reshape(5, {}, {1,1}) == f32[1x1] { {5}};
</pre> <h2 id="rev_reverse">Rev (reverse)</h2> <p>See also <a href="https://www.tensorflow.org/code/tensorflow/compiler/xla/client/computation_builder.h" target="_blank"><code>ComputationBuilder::Rev</code></a>.</p> <p><b><code>Rev(operand, dimensions)</code></b></p> <table> <thead> <tr> <th>Arguments</th> <th>Type</th> <th>Semantics</th> </tr> </thead> <tbody> <tr> <td><code>operand</code></td> <td><code>ComputationDataHandle</code></td> <td>array of type T</td> </tr> <tr> <td><code>dimensions</code></td> <td><code>ArraySlice&lt;int64&gt;</code></td> <td>dimensions to reverse</td> </tr> </tbody> </table> <p>Reverses the order of elements in the <code>operand</code> array along the specified <code>dimensions</code>, generating an output array of the same shape. Each element of the operand array at a multidimensional index is stored into the output array at a transformed index. The multidimensional index is transformed by reversing the index in each dimension to be reversed (i.e., if a dimension of size N is one of the reversing dimensions, its index i is transformed into N - 1 - i).</p> <p>One use for the <code>Rev</code> operation is to reverse the convolution weight array along the two window dimensions during the gradient computation in neural networks.</p> <h2 id="rngbernoulli">RngBernoulli</h2> <p>See also <a href="https://www.tensorflow.org/code/tensorflow/compiler/xla/client/computation_builder.h" target="_blank"><code>ComputationBuilder::RngBernoulli</code></a>.</p> <p>Constructs an output of a given shape with random numbers generated following the Bernoulli distribution. The parameter needs to be a scalar valued F32 operand while the output shape needs to have elemental type U32.</p> <p><b><code>RngBernoulli(mean, shape)</code></b></p> <table> <thead> <tr> <th>Arguments</th> <th>Type</th> <th>Semantics</th> </tr> </thead> <tbody> <tr> <td><code>mean</code></td> <td><code>ComputationDataHandle</code></td> <td>Scalar of type F32 specifying mean of generated numbers</td> </tr> <tr> <td><code>shape</code></td> <td><code>Shape</code></td> <td>Output shape of type U32</td> </tr> </tbody> </table> <h2 id="rngnormal">RngNormal</h2> <p>See also <a href="https://www.tensorflow.org/code/tensorflow/compiler/xla/client/computation_builder.h" target="_blank"><code>ComputationBuilder::RngNormal</code></a>.</p> <p>Constructs an output of a given shape with random numbers generated following </p>
<div> the $$N(\mu, \sigma)$$ normal distribution. The parameters <code>mu</code> and <code>sigma</code>, and </div> output shape have to have elemental type F32. The parameters furthermore have to be scalar valued. <p><b><code>RngNormal(mean, sigma, shape)</code></b></p> <table> <thead> <tr> <th>Arguments</th> <th>Type</th> <th>Semantics</th> </tr> </thead> <tbody> <tr> <td><code>mu</code></td> <td><code>ComputationDataHandle</code></td> <td>Scalar of type F32 specifying mean of generated numbers</td> </tr> <tr> <td><code>sigma</code></td> <td><code>ComputationDataHandle</code></td> <td>Scalar of type F32 specifying standard deviation of generated numbers</td> </tr> <tr> <td><code>shape</code></td> <td><code>Shape</code></td> <td>Output shape of type F32</td> </tr> </tbody> </table> <h2 id="rnguniform">RngUniform</h2> <p>See also <a href="https://www.tensorflow.org/code/tensorflow/compiler/xla/client/computation_builder.h" target="_blank"><code>ComputationBuilder::RngUniform</code></a>.</p> <p>Constructs an output of a given shape with random numbers generated following </p>
<div> the uniform distribution over the interval $$[a,b)$$. The parameters and output </div> shape may be either F32, S32 or U32, but the types have to be consistent. <div> Furthermore, the parameters need to be scalar valued. If $$b &lt;= a$$ the result </div> is implementation-defined. <p><b><code>RngUniform(a, b, shape)</code></b></p> <table> <thead> <tr> <th>Arguments</th> <th>Type</th> <th>Semantics</th> </tr> </thead> <tbody> <tr> <td><code>a</code></td> <td><code>ComputationDataHandle</code></td> <td>Scalar of type T specifying lower limit of interval</td> </tr> <tr> <td><code>b</code></td> <td><code>ComputationDataHandle</code></td> <td>Scalar of type T specifying upper limit of interval</td> </tr> <tr> <td><code>shape</code></td> <td><code>Shape</code></td> <td>Output shape of type T</td> </tr> </tbody> </table> <h2 id="selectandscatter">SelectAndScatter</h2> <p>See also <a href="https://www.tensorflow.org/code/tensorflow/compiler/xla/client/computation_builder.h" target="_blank"><code>ComputationBuilder::SelectAndScatter</code></a>.</p> <p>This operation can be considered as a composite operation that first computes <code>ReduceWindow</code> on the <code>operand</code> array to select an element from each window, and then scatters the <code>source</code> array to the indices of the selected elements to construct an output array with the same shape as the operand array. The binary <code>select</code> function is used to select an element from each window by applying it across each window, and it is called with the property that the first parameter's index vector is lexicographically less than the second parameter's index vector. The <code>select</code> function returns <code>true</code> if the first parameter is selected and returns <code>false</code> if the second parameter is selected, and the function must hold transitivity (i.e., if <code>select(a, b)</code> and <code>select(b, c)</code> are <code>true</code>, then <code>select(a, c)</code> is also <code>true</code>) so that the selected element does not depend on the order of the elements traversed for a given window.</p> <p>The function <code>scatter</code> is applied at each selected index in the output array. It takes two scalar parameters:</p> <ol> <li>Current value at the selected index in the output array</li> <li>The scatter value from <code>source</code> that applies to the selected index</li> </ol> <p>It combines the two parameters and returns a scalar value that's used to update the value at the selected index in the output array. Initially, all indices of the output array are set to <code>init_value</code>.</p> <p>The output array has the same shape as the <code>operand</code> array and the <code>source</code> array must have the same shape as the result of applying a <code>ReduceWindow</code> operation on the <code>operand</code> array. <code>SelectAndScatter</code> can be used to backpropagate the gradient values for a pooling layer in a neural network.</p> <p><b><code>SelectAndScatter(operand, select, window_dimensions, window_strides, padding, source, init_value, scatter)</code></b></p> <table> <thead> <tr> <th>Arguments</th> <th>Type</th> <th>Semantics</th> </tr> </thead> <tbody> <tr> <td><code>operand</code></td> <td><code>ComputationDataHandle</code></td> <td>array of type T over which the windows slide</td> </tr> <tr> <td><code>select</code></td> <td><code>Computation</code></td> <td>binary computation of type <code>T, T -&gt; PRED</code>, to apply to all elements in each window; returns <code>true</code> if the first parameter is selected and returns <code>false</code> if the second parameter is selected</td> </tr> <tr> <td><code>window_dimensions</code></td> <td><code>ArraySlice&lt;int64&gt;</code></td> <td>array of integers for window dimension values</td> </tr> <tr> <td><code>window_strides</code></td> <td><code>ArraySlice&lt;int64&gt;</code></td> <td>array of integers for window stride values</td> </tr> <tr> <td><code>padding</code></td> <td><code>Padding</code></td> <td>padding type for window (Padding\:\:kSame or Padding\:\:kValid)</td> </tr> <tr> <td><code>source</code></td> <td><code>ComputationDataHandle</code></td> <td>array of type T with the values to scatter</td> </tr> <tr> <td><code>init_value</code></td> <td><code>ComputationDataHandle</code></td> <td>scalar value of type T for the inital value of the output array</td> </tr> <tr> <td><code>scatter</code></td> <td><code>Computation</code></td> <td>binary computation of type <code>T, T -&gt; T</code>, to apply each scatter source element with its destination element</td> </tr> </tbody> </table> <p>The figure below shows examples of using <code>SelectAndScatter</code>, with the <code>select</code> function computing the maximal value among its parameters. Note that when the windows overlap, as in the figure (2) below, an index of the <code>operand</code> array may be selected multiple times by different windows. In the figure, the element of value 9 is selected by both of the top windows (blue and red) and the binary addition <code>scatter</code> function produces the output element of value 8 (2 + 6).</p> <div style="width:95%; margin:auto; margin-bottom:10px; margin-top:20px;"> <img style="width:100%" src="https://www.tensorflow.org/images/ops_scatter_to_selected_window_element.png"> </div> <h2 id="select">Select</h2> <p>See also <a href="https://www.tensorflow.org/code/tensorflow/compiler/xla/client/computation_builder.h" target="_blank"><code>ComputationBuilder::Select</code></a>.</p> <p>Constructs an output array from elements of two input arrays, based on the values of a predicate array.</p> <p><b> <code>Select(pred, on_true, on_false)</code> </b></p> <table> <thead> <tr> <th>Arguments</th> <th>Type</th> <th>Semantics</th> </tr> </thead> <tbody> <tr> <td><code>pred</code></td> <td><code>ComputationDataHandle</code></td> <td>array of type PRED</td> </tr> <tr> <td><code>on_true</code></td> <td><code>ComputationDataHandle</code></td> <td>array of type T</td> </tr> <tr> <td><code>on_false</code></td> <td><code>ComputationDataHandle</code></td> <td>array of type T</td> </tr> </tbody> </table> <p>The arrays <code>on_true</code> and <code>on_false</code> must have the same shape. This is also the shape of the output array. The array <code>pred</code> must have the same dimensionality as <code>on_true</code> and <code>on_false</code>, with the <code>PRED</code> element type.</p> <p>For each element <code>P</code> of <code>pred</code>, the corresponding element of the output array is taken from <code>on_true</code> if the value of <code>P</code> is <code>true</code>, and from <code>on_false</code> if the value of <code>P</code> is <code>false</code>. As a restricted form of <a href="../broadcasting/">broadcasting</a> , <code>pred</code> can be a scalar of type <code>PRED</code>. In this case, the output array is taken wholly from <code>on_true</code> if <code>pred</code> is <code>true</code>, and from <code>on_false</code> if <code>pred</code> is <code>false</code>.</p> <p>Example with non-scalar <code>pred</code>:</p> <pre class="prettyprint" data-language="cpp">let pred: PRED[4] = {true, false, false, true};
let v1: s32[4] = {1, 2, 3, 4};
let v2: s32[4] = {100, 200, 300, 400};
==&gt;
Select(pred, v1, v2) = s32[4]{1, 200, 300, 4};
</pre> <p>Example with scalar <code>pred</code>:</p> <pre class="prettyprint" data-language="cpp">let pred: PRED = true;
let v1: s32[4] = {1, 2, 3, 4};
let v2: s32[4] = {100, 200, 300, 400};
==&gt;
Select(pred, v1, v2) = s32[4]{1, 2, 3, 4};
</pre> <p>Selections between tuples are supported. Tuples are considered to be scalar types for this purpose. If <code>on_true</code> and <code>on_false</code> are tuples (which must have the same shape!) then <code>pred</code> has to be a scalar of type <code>PRED</code>.</p> <h2 id="slice">Slice</h2> <p>See also <a href="https://www.tensorflow.org/code/tensorflow/compiler/xla/client/computation_builder.h" target="_blank"><code>ComputationBuilder::Slice</code></a>.</p> <p>Slicing extracts a sub-array from the input array. The sub-array is of the same rank as the input and contains the values inside a bounding box within the input array where the dimensions and indices of the bounding box are given as arguments to the slice operation.</p> <p><b> <code>Slice(operand, start_indices, limit_indices)</code> </b></p> <table> <thead> <tr> <th>Arguments</th> <th>Type</th> <th>Semantics</th> </tr> </thead> <tbody> <tr> <td><code>operand</code></td> <td><code>ComputationDataHandle</code></td> <td>N dimensional array of type T</td> </tr> <tr> <td><code>start_indices</code></td> <td><code>ArraySlice&lt;int64&gt;</code></td> <td>List of N integers containing the starting indices of the slice for each dimension. Values must be greater than or equal to zero.</td> </tr> <tr> <td><code>limit_indices</code></td> <td><code>ArraySlice&lt;int64&gt;</code></td> <td>List of N integers containing the ending indices (exclusive) for the slice for each dimension. Each value must be strictly greater than the respective <code>start_indices</code> value for the dimension and less than or equal to the size of the dimension.</td> </tr> </tbody> </table> <p>1-dimensional example:</p> <pre class="prettyprint" data-language="cpp">let a = {0.0, 1.0, 2.0, 3.0, 4.0}
Slice(a, {2}, {4}) produces:
  {2.0, 3.0}
</pre> <p>2-dimensional example:</p> <pre class="prettyprint" data-language="cpp">let b =
 { {0.0,  1.0,  2.0},
   {3.0,  4.0,  5.0},
   {6.0,  7.0,  8.0},
   {9.0, 10.0, 11.0} }

Slice(b, {2, 1}, {4, 3}) produces:
  { { 7.0,  8.0},
    {10.0, 11.0} }
</pre> <h2 id="dynamicslice">DynamicSlice</h2> <p>See also <a href="https://www.tensorflow.org/code/tensorflow/compiler/xla/client/computation_builder.h" target="_blank"><code>ComputationBuilder::DynamicSlice</code></a>.</p> <p>DynamicSlice extracts a sub-array from the input array at dynamic <code>start_indices</code>. The size of the slice in each dimension is passed in <code>size_indices</code>, which specify the end point of exclusive slice intervals in each dimension: [start, start + size). The shape of <code>start_indices</code> must be rank == 1, with dimension size equal to the rank of <code>operand</code>. Note: handling of out-of-bounds slice indices (generated by incorrect runtime calculation of 'start_indices') is currently implementation-defined. Currently, slice indices are computed modulo input dimension sizes to prevent out-of-bound array accesses, but this behavior may change in future implementations.</p> <p><b> <code>DynamicSlice(operand, start_indices, size_indices)</code> </b></p> <table> <thead> <tr> <th>Arguments</th> <th>Type</th> <th>Semantics</th> </tr> </thead> <tbody> <tr> <td><code>operand</code></td> <td><code>ComputationDataHandle</code></td> <td>N dimensional array of type T</td> </tr> <tr> <td><code>start_indices</code></td> <td><code>ComputationDataHandle</code></td> <td>Rank 1 array of N integers containing the starting indices of the slice for each dimension. Value must be greater than or equal to zero.</td> </tr> <tr> <td><code>size_indices</code></td> <td><code>ArraySlice&lt;int64&gt;</code></td> <td>List of N integers containing the slice size for each dimension. Each value must be strictly greater than zero, and start + size must be less than or equal to the size of the dimension to avoid wrapping modulo dimension size.</td> </tr> </tbody> </table> <p>1-dimensional example:</p> <pre class="prettyprint" data-language="cpp">let a = {0.0, 1.0, 2.0, 3.0, 4.0}
let s = {2}

DynamicSlice(a, s, {2}) produces:
  {2.0, 3.0}
</pre> <p>2-dimensional example:</p> <pre class="prettyprint" data-language="cpp">let b =
 { {0.0,  1.0,  2.0},
   {3.0,  4.0,  5.0},
   {6.0,  7.0,  8.0},
   {9.0, 10.0, 11.0} }
let s = {2, 1}

DynamicSlice(b, s, {2, 2}) produces:
  { { 7.0,  8.0},
    {10.0, 11.0} }
</pre> <h2 id="dynamicupdateslice">DynamicUpdateSlice</h2> <p>See also <a href="https://www.tensorflow.org/code/tensorflow/compiler/xla/client/computation_builder.h" target="_blank"><code>ComputationBuilder::DynamicUpdateSlice</code></a>.</p> <p>DynamicUpdateSlice generates a result which is the value of the input array <code>operand</code>, with a slice <code>update</code> overwritten at <code>start_indices</code>. The shape of <code>update</code> determines the shape of the sub-array of the result which is updated. The shape of <code>start_indices</code> must be rank == 1, with dimension size equal to the rank of <code>operand</code>. Note: handling of out-of-bounds slice indices (generated by incorrect runtime calculation of 'start_indices') is currently implementation-defined. Currently, slice indices are computed modulo update dimension sizes to prevent out-of-bound array accesses, but this behavior may change in future implementations.</p> <p><b> <code>DynamicUpdateSlice(operand, update, start_indices)</code> </b></p> <table> <thead> <tr> <th>Arguments</th> <th>Type</th> <th>Semantics</th> </tr> </thead> <tbody> <tr> <td><code>operand</code></td> <td><code>ComputationDataHandle</code></td> <td>N dimensional array of type T</td> </tr> <tr> <td><code>update</code></td> <td><code>ComputationDataHandle</code></td> <td>N dimensional array of type T containing the slice update. Each dimension of update shape must be strictly greater than zero, and start + update must be less than operand size for each dimension to avoid generating out-of-bounds update indices.</td> </tr> <tr> <td><code>start_indices</code></td> <td><code>ComputationDataHandle</code></td> <td>Rank 1 array of N integers containing the starting indices of the slice for each dimension. Value must be greater than or equal to zero.</td> </tr> </tbody> </table> <p>1-dimensional example:</p> <pre class="prettyprint" data-language="cpp">let a = {0.0, 1.0, 2.0, 3.0, 4.0}
let u = {5.0, 6.0}
let s = {2}

DynamicUpdateSlice(a, u, s) produces:
  {0.0, 1.0, 5.0, 6.0, 4.0}
</pre> <p>2-dimensional example:</p> <pre class="prettyprint" data-language="cpp">let b =
 { {0.0,  1.0,  2.0},
   {3.0,  4.0,  5.0},
   {6.0,  7.0,  8.0},
   {9.0, 10.0, 11.0} }
let u =
 { {12.0,  13.0},
   {14.0,  15.0},
   {16.0,  17.0} }

let s = {1, 1}

DynamicUpdateSlice(b, u, s) produces:
 { {0.0,  1.0,  2.0},
   {3.0, 12.0, 13.0},
   {6.0, 14.0, 15.0},
   {9.0, 16.0, 17.0} }
</pre> <h2 id="sort">Sort</h2> <p>See also <a href="https://www.tensorflow.org/code/tensorflow/compiler/xla/client/computation_builder.h" target="_blank"><code>ComputationBuilder::Sort</code></a>.</p> <p>Sorts the elements in the operand.</p> <p><b><code>Sort(operand)</code></b></p> <table> <thead> <tr> <th>Arguments</th> <th>Type</th> <th>Semantics</th> </tr> </thead> <tbody> <tr> <td><code>operand</code></td> <td><code>ComputationDataHandle</code></td> <td>The operand to sort</td> </tr> </tbody> </table> <h2 id="transpose">Transpose</h2> <p>See also the <a href="https://www.tensorflow.org/api_docs/python/tf/reshape" target="_blank"><code>tf.reshape</code></a> operation.</p> <p><b><code>Transpose(operand)</code></b></p> <table> <thead> <tr> <th>Arguments</th> <th>Type</th> <th>Semantics</th> </tr> </thead> <tbody> <tr> <td><code>operand</code></td> <td><code>ComputationDataHandle</code></td> <td>The operand to transpose.</td> </tr> <tr> <td><code>permutation</code></td> <td><code>ArraySlice&lt;int64&gt;</code></td> <td>How to permute the dimensions.</td> </tr> </tbody> </table> <p>Permutes the operand dimensions with the given permutation, so <code>∀ i . 0 ≤ i &lt; rank ⇒ input_dimensions[permutation[i]] = output_dimensions[i]</code>.</p> <p>This is the same as Reshape(operand, permutation, Permute(permutation, operand.shape.dimensions)).</p> <h2 id="tuple">Tuple</h2> <p>See also <a href="https://www.tensorflow.org/code/tensorflow/compiler/xla/client/computation_builder.h" target="_blank"><code>ComputationBuilder::Tuple</code></a>.</p> <p>A tuple containing a variable number of data handles, each of which has its own shape.</p> <p>This is analogous to <code>std::tuple</code> in C++. Conceptually:</p> <pre class="prettyprint" data-language="cpp">let v: f32[10] = f32[10]{0, 1, 2, 3, 4, 5, 6, 7, 8, 9};
let s: s32 = 5;
let t: (f32[10], s32) = tuple(v, s);
</pre> <p>Tuples can be deconstructed (accessed) via the <a href="#gettupleelement"><code>GetTupleElement</code></a> operation.</p> <h2 id="while">While</h2> <p>See also <a href="https://www.tensorflow.org/code/tensorflow/compiler/xla/client/computation_builder.h" target="_blank"><code>ComputationBuilder::While</code></a>.</p> <p><b> <code>While(condition, body, init)</code> </b></p> <table> <thead> <tr> <th>Arguments</th> <th>Type</th> <th>Semantics</th> </tr> </thead> <tbody> <tr> <td><code>condition</code></td> <td><code>Computation</code></td> <td>Computation of type <code>T -&gt; PRED</code> which defines the termination condition of the loop.</td> </tr> <tr> <td><code>body</code></td> <td><code>Computation</code></td> <td>Computation of type <code>T -&gt; T</code> which defines the body of the loop.</td> </tr> <tr> <td><code>init</code></td> <td><code>T</code></td> <td>Initial value for the parameter of <code>condition</code> and <code>body</code>.</td> </tr> </tbody> </table> <p>Sequentially executes the <code>body</code> until the <code>condition</code> fails. This is similar to a typical while loop in many other languages except for the differences and restrictions listed below.</p> <ul> <li>A <code>While</code> node returns a value of type <code>T</code>, which is the result from the last execution of the <code>body</code>.</li> <li>The shape of the type <code>T</code> is statically determined and must be the same across all iterations.</li> <li>
<code>While</code> nodes are not allowed to be nested. (This restriction may be lifted in the future on some targets.)</li> </ul> <p>The T parameters of the computations are initialized with the <code>init</code> value in the first iteration and are automatically updated to the new result from <code>body</code> in each subsequent iteration.</p> <p>One main use case of the <code>While</code> node is to implement the repeated execution of training in neural networks. Simplified pseudocode is shown below with a graph that represents the computation. The code can be found in <a href="https://www.tensorflow.org/code/tensorflow/compiler/xla/tests/while_test.cc" target="_blank"><code>while_test.cc</code></a>. The type <code>T</code> in this example is a <code>Tuple</code> consisting of an <code>int32</code> for the iteration count and a <code>vector[10]</code> for the accumulator. For 1000 iterations, the loop keeps adding a constant vector to the accumulator.</p> <pre class="prettyprint" data-language="cpp">// Pseudocode for the computation.
init = {0, zero_vector[10]} // Tuple of int32 and float[10].
result = init;
while (result(0) &lt; 1000) {
  iteration = result(0) + 1;
  new_vector = result(1) + constant_vector[10];
  result = {iteration, new_vector};
}
</pre> <div style="width:95%; margin:auto; margin-bottom:10px; margin-top:20px;"> <img style="width:100%" src="https://www.tensorflow.org/images/ops_while.png"> </div> <p>[^1]: Some obvious reductions like "add reduction" are not strictly associative for floats. However, if the range of the data is limited, floating-point addition is close enough to being associative for most practical uses. It is possible to conceive some complete un-associative reductions, however, and these will produce wrong results in TLA reductions.</p>
<div class="_attribution">
  <p class="_attribution-p">
    © 2017 The TensorFlow Authors. All rights reserved.<br>Licensed under the Creative Commons Attribution License 3.0.<br>Code samples licensed under the Apache 2.0 License.<br>
    <a href="https://www.tensorflow.org/performance/xla/operation_semantics" class="_attribution-link" target="_blank">https://www.tensorflow.org/performance/xla/operation_semantics</a>
  </p>
</div>

			</div>
		</div>
	</section>

	</div>
</body>
</html>
