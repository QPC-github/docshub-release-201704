
<!DOCTYPE HTML>

<html lang="en">

<head>
  <meta charset="utf-8">
  <title>Work With Network Commands (Engine) - Docker 1.13 - W3cubDocs</title>
  
  <meta name="description" content="This article provides examples of the network subcommands you can use to interact with Docker networks and the containers in them. The commands are &hellip;">
  <meta name="keywords" content="work, with, network, commands, engine, -, docker, docker~1.13">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="http://docs.w3cub.com/docker~1.13/engine/userguide/networking/work-with-networks/">
  <link href="/favicon.png" rel="icon">
  <link type="text/css" rel="stylesheet" href="/assets/application-50364fff564ce3b6327021805f3f00e2957b441cf27f576a7dd4ff63bbc47047.css">
  <script type="text/javascript" src="/assets/application-db64bfd54ceb42be11af7995804cf4902548419ceb79d509b0b7d62c22d98e6f.js"></script>
  <script src="/json/docker~1.13.js"></script>
  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-71174418-1']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>


</head>

<body>
	<div class="_app">
	<header class="_header">
  
  <form class="_search">
    <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
    <a class="_search-clear"></a>
    <div class="_search-tag"></div>
  </form>
  
  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/docker~1.13/" class="_nav-link" title="" style="margin-left:0;">Docker 1.13</a></span>
  
  <nav class="_nav">
    <a href="/app/" class="_nav-link ">App</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		<div class="_list">
			
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<div class="_page _docker">
				
<h1>Work with network commands</h1>  <p>This article provides examples of the network subcommands you can use to interact with Docker networks and the containers in them. The commands are available through the Docker Engine CLI. These commands are:</p> <ul> <li><code class="highlighter-rouge">docker network create</code></li> <li><code class="highlighter-rouge">docker network connect</code></li> <li><code class="highlighter-rouge">docker network ls</code></li> <li><code class="highlighter-rouge">docker network rm</code></li> <li><code class="highlighter-rouge">docker network disconnect</code></li> <li><code class="highlighter-rouge">docker network inspect</code></li> </ul> <p>While not required, it is a good idea to read <a href="../">Understanding Docker network</a> before trying the examples in this section. The examples for the rely on a <code class="highlighter-rouge">bridge</code> network so that you can try them immediately. If you would prefer to experiment with an <code class="highlighter-rouge">overlay</code> network see the <a href="../get-started-overlay/">Getting started with multi-host networks</a> instead.</p> <h2 id="create-networks">Create networks</h2> <p>Docker Engine creates a <code class="highlighter-rouge">bridge</code> network automatically when you install Engine. This network corresponds to the <code class="highlighter-rouge">docker0</code> bridge that Engine has traditionally relied on. In addition to this network, you can create your own <code class="highlighter-rouge">bridge</code> or <code class="highlighter-rouge">overlay</code> network.</p> <p>A <code class="highlighter-rouge">bridge</code> network resides on a single host running an instance of Docker Engine. An <code class="highlighter-rouge">overlay</code> network can span multiple hosts running their own engines. If you run <code class="highlighter-rouge">docker network create</code> and supply only a network name, it creates a bridge network for you.</p> <pre class="highlight" data-language="bash">$ docker network create simple-network

69568e6336d8c96bbf57869030919f7c69524f71183b44d80948bd3927c87f6a

$ docker network inspect simple-network
[
    {
        "Name": "simple-network",
        "Id": "69568e6336d8c96bbf57869030919f7c69524f71183b44d80948bd3927c87f6a",
        "Scope": "local",
        "Driver": "bridge",
        "IPAM": {
            "Driver": "default",
            "Config": [
                {
                    "Subnet": "172.22.0.0/16",
                    "Gateway": "172.22.0.1"
                }
            ]
        },
        "Containers": {},
        "Options": {},
        "Labels": {}
    }
]
</pre>  <p>Unlike <code class="highlighter-rouge">bridge</code> networks, <code class="highlighter-rouge">overlay</code> networks require some pre-existing conditions before you can create one. These conditions are:</p> <ul> <li>Access to a key-value store. Engine supports Consul, Etcd, and ZooKeeper (Distributed store) key-value stores.</li> <li>A cluster of hosts with connectivity to the key-value store.</li> <li>A properly configured Engine <code class="highlighter-rouge">daemon</code> on each host in the swarm.</li> </ul> <p>The <code class="highlighter-rouge">dockerd</code> options that support the <code class="highlighter-rouge">overlay</code> network are:</p> <ul> <li><code class="highlighter-rouge">--cluster-store</code></li> <li><code class="highlighter-rouge">--cluster-store-opt</code></li> <li><code class="highlighter-rouge">--cluster-advertise</code></li> </ul> <p>When you create a network, Engine creates a non-overlapping subnetwork for the network by default. You can override this default and specify a subnetwork directly using the <code class="highlighter-rouge">--subnet</code> option. On a <code class="highlighter-rouge">bridge</code> network you can only specify a single subnet. An <code class="highlighter-rouge">overlay</code> network supports multiple subnets.</p> <blockquote> <p><strong>Note</strong> : It is highly recommended to use the <code class="highlighter-rouge">--subnet</code> option while creating a network. If the <code class="highlighter-rouge">--subnet</code> is not specified, the docker daemon automatically chooses and assigns a subnet for the network and it could overlap with another subnet in your infrastructure that is not managed by docker. Such overlaps can cause connectivity issues or failures when containers are connected to that network.</p> </blockquote> <p>In addition to the <code class="highlighter-rouge">--subnet</code> option, you also specify the <code class="highlighter-rouge">--gateway</code>, <code class="highlighter-rouge">--ip-range</code>, and <code class="highlighter-rouge">--aux-address</code> options.</p> <pre class="highlight" data-language="bash">$ docker network create -d overlay \
  --subnet=192.168.0.0/16 \
  --subnet=192.170.0.0/16 \
  --gateway=192.168.0.100 \
  --gateway=192.170.0.100 \
  --ip-range=192.168.1.0/24 \
  --aux-address="my-router=192.168.1.5" --aux-address="my-switch=192.168.1.6" \
  --aux-address="my-printer=192.170.1.5" --aux-address="my-nas=192.170.1.6" \
  my-multihost-network
</pre>  <p>Be sure that your subnetworks do not overlap. If they do, network creation fails and Engine returns an error.</p> <p>When creating a custom network, you can pass additional options to the driver. The <code class="highlighter-rouge">bridge</code> driver accepts the following options:</p> <table> <thead> <tr> <th>Option</th> <th>Equivalent</th> <th>Description</th> </tr> </thead> <tbody> <tr> <td><code class="highlighter-rouge">com.docker.network.bridge.name</code></td> <td>-</td> <td>bridge name to be used when creating the Linux bridge</td> </tr> <tr> <td><code class="highlighter-rouge">com.docker.network.bridge.enable_ip_masquerade</code></td> <td><code class="highlighter-rouge">--ip-masq</code></td> <td>Enable IP masquerading</td> </tr> <tr> <td><code class="highlighter-rouge">com.docker.network.bridge.enable_icc</code></td> <td><code class="highlighter-rouge">--icc</code></td> <td>Enable or Disable Inter Container Connectivity</td> </tr> <tr> <td><code class="highlighter-rouge">com.docker.network.bridge.host_binding_ipv4</code></td> <td><code class="highlighter-rouge">--ip</code></td> <td>Default IP when binding container ports</td> </tr> <tr> <td><code class="highlighter-rouge">com.docker.network.driver.mtu</code></td> <td><code class="highlighter-rouge">--mtu</code></td> <td>Set the containers network MTU</td> </tr> </tbody> </table> <p>The <code class="highlighter-rouge">com.docker.network.driver.mtu</code> option is also supported by the <code class="highlighter-rouge">overlay</code> driver.</p> <p>The following arguments can be passed to <code class="highlighter-rouge">docker network create</code> for any network driver.</p> <table> <thead> <tr> <th>Argument</th> <th>Equivalent</th> <th>Description</th> </tr> </thead> <tbody> <tr> <td><code class="highlighter-rouge">--internal</code></td> <td>-</td> <td>Restricts external access to the network</td> </tr> <tr> <td><code class="highlighter-rouge">--ipv6</code></td> <td><code class="highlighter-rouge">--ipv6</code></td> <td>Enable IPv6 networking</td> </tr> </tbody> </table> <p>The following example uses <code class="highlighter-rouge">-o</code> to bind to a specific IP address when binding ports, then uses <code class="highlighter-rouge">docker network inspect</code> to inspect the network, and finally attaches a new container to the new network.</p> <pre class="highlight" data-language="bash">$ docker network create -o "com.docker.network.bridge.host_binding_ipv4"="172.23.0.1" my-network

b1a086897963e6a2e7fc6868962e55e746bee8ad0c97b54a5831054b5f62672a

$ docker network inspect my-network

[
    {
        "Name": "my-network",
        "Id": "b1a086897963e6a2e7fc6868962e55e746bee8ad0c97b54a5831054b5f62672a",
        "Scope": "local",
        "Driver": "bridge",
        "IPAM": {
            "Driver": "default",
            "Options": {},
            "Config": [
                {
                    "Subnet": "172.23.0.0/16",
                    "Gateway": "172.23.0.1"
                }
            ]
        },
        "Containers": {},
        "Options": {
            "com.docker.network.bridge.host_binding_ipv4": "172.23.0.1"
        },
        "Labels": {}
    }
]

$ docker run -d -P --name redis --network my-network redis

bafb0c808c53104b2c90346f284bda33a69beadcab4fc83ab8f2c5a4410cd129

$ docker ps

CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS                        NAMES
bafb0c808c53        redis               "/entrypoint.sh redis"   4 seconds ago       Up 3 seconds        172.23.0.1:32770-&gt;6379/tcp   redis
</pre>  <h2 id="connect-containers">Connect containers</h2> <p>You can connect an existing container to one or more networks. A container can connect to networks which use different network drivers. Once connected, the containers can communicate using another container’s IP address or name.</p> <p>For <code class="highlighter-rouge">overlay</code> networks or custom plugins that support multi-host connectivity, containers connected to the same multi-host network but launched from different hosts can also communicate in this way.</p> <p>This example uses six containers, and directs you to create them as they are needed.</p> <h3 id="basic-container-networking-example">Basic container networking example</h3> <ol> <li> <p>First, create and run two containers, <code class="highlighter-rouge">container1</code> and <code class="highlighter-rouge">container2</code>:</p> <pre class="highlight" data-language="bash">$ docker run -itd --name=container1 busybox

18c062ef45ac0c026ee48a83afa39d25635ee5f02b58de4abc8f467bcaa28731

$ docker run -itd --name=container2 busybox

498eaaaf328e1018042c04b2de04036fc04719a6e39a097a4f4866043a2c2152
</pre>  </li> <li> <p>Create an isolated, <code class="highlighter-rouge">bridge</code> network to test with.</p> <pre class="highlight" data-language="bash">$ docker network create -d bridge --subnet 172.25.0.0/16 isolated_nw

06a62f1c73c4e3107c0f555b7a5f163309827bfbbf999840166065a8f35455a8
</pre>  </li> <li> <p>Connect <code class="highlighter-rouge">container2</code> to the network and then <code class="highlighter-rouge">inspect</code> the network to verify the connection:</p> <pre class="highlight" data-language="bash">$ docker network connect isolated_nw container2

$ docker network inspect isolated_nw

[
    {
        "Name": "isolated_nw",
        "Id": "06a62f1c73c4e3107c0f555b7a5f163309827bfbbf999840166065a8f35455a8",
        "Scope": "local",
        "Driver": "bridge",
        "IPAM": {
            "Driver": "default",
            "Config": [
                {
                    "Subnet": "172.25.0.0/16",
                    "Gateway": "172.25.0.1/16"
                }
            ]
        },
        "Containers": {
            "90e1f3ec71caf82ae776a827e0712a68a110a3f175954e5bd4222fd142ac9428": {
                "Name": "container2",
                "EndpointID": "11cedac1810e864d6b1589d92da12af66203879ab89f4ccd8c8fdaa9b1c48b1d",
                "MacAddress": "02:42:ac:19:00:02",
                "IPv4Address": "172.25.0.2/16",
                "IPv6Address": ""
            }
        },
        "Options": {}
    }
]
</pre>  <p>Notice that <code class="highlighter-rouge">container2</code> is assigned an IP address automatically. Because you specified a <code class="highlighter-rouge">--subnet</code> when creating the network, the IP address was chosen from that subnet.</p> <p>As a reminder, <code class="highlighter-rouge">container1</code> is only connected to the default <code class="highlighter-rouge">bridge</code> network.</p> </li> <li> <p>Start a third container, but this time assign it an IP address using the <code class="highlighter-rouge">--ip</code> flag and connect it to the <code class="highlighter-rouge">isolated_nw</code> network using the <code class="highlighter-rouge">docker run</code> command’s <code class="highlighter-rouge">--network</code> option:</p> <pre class="highlight" data-language="bash">$ docker run --network=isolated_nw --ip=172.25.3.3 -itd --name=container3 busybox

467a7863c3f0277ef8e661b38427737f28099b61fa55622d6c30fb288d88c551
</pre>  <p>As long as the IP address you specify for the container is part of the network’s subnet, you can assign an IPv4 or IPv6 address to a container when connecting it to a network, by using the <code class="highlighter-rouge">--ip</code> or <code class="highlighter-rouge">--ip6</code> flag. when you specify an IP address in this way while using a user-defined network, the configuration is preserved as part of the container’s configuration and will be applied when the container is reloaded. Assigned IP addresses are preserved when using non-user-defined networks, because there is no guarantee that a container’s subnet will not change when the Docker daemon restarts unless you use user-defined networks.</p> </li> <li> <p>Inspect the network resources used by <code class="highlighter-rouge">container3</code>. The output below is truncated for brevity.</p> <pre class="highlight" data-language="bash">$ docker inspect --format=''  container3

{"isolated_nw":
  {"IPAMConfig":
    {
      "IPv4Address":"172.25.3.3"},
      "NetworkID":"1196a4c5af43a21ae38ef34515b6af19236a3fc48122cf585e3f3054d509679b",
      "EndpointID":"dffc7ec2915af58cc827d995e6ebdc897342be0420123277103c40ae35579103",
      "Gateway":"172.25.0.1",
      "IPAddress":"172.25.3.3",
      "IPPrefixLen":16,
      "IPv6Gateway":"",
      "GlobalIPv6Address":"",
      "GlobalIPv6PrefixLen":0,
      "MacAddress":"02:42:ac:19:03:03"}
    }
  }
}
</pre>  <p>Because you connected <code class="highlighter-rouge">container3</code> to the <code class="highlighter-rouge">isolated_nw</code> when you started it, it is not connected to the default <code class="highlighter-rouge">bridge</code> network at all.</p> </li> <li> <p>Inspect the network resources used by <code class="highlighter-rouge">container2</code>. If you have Python installed, you can pretty print the output.</p> <pre class="highlight" data-language="bash">$ docker inspect --format=''  container2 | python -m json.tool

{
    "bridge": {
        "NetworkID":"7ea29fc1412292a2d7bba362f9253545fecdfa8ce9a6e37dd10ba8bee7129812",
        "EndpointID": "0099f9efb5a3727f6a554f176b1e96fca34cae773da68b3b6a26d046c12cb365",
        "Gateway": "172.17.0.1",
        "GlobalIPv6Address": "",
        "GlobalIPv6PrefixLen": 0,
        "IPAMConfig": null,
        "IPAddress": "172.17.0.3",
        "IPPrefixLen": 16,
        "IPv6Gateway": "",
        "MacAddress": "02:42:ac:11:00:03"
    },
    "isolated_nw": {
        "NetworkID":"1196a4c5af43a21ae38ef34515b6af19236a3fc48122cf585e3f3054d509679b",
        "EndpointID": "11cedac1810e864d6b1589d92da12af66203879ab89f4ccd8c8fdaa9b1c48b1d",
        "Gateway": "172.25.0.1",
        "GlobalIPv6Address": "",
        "GlobalIPv6PrefixLen": 0,
        "IPAMConfig": null,
        "IPAddress": "172.25.0.2",
        "IPPrefixLen": 16,
        "IPv6Gateway": "",
        "MacAddress": "02:42:ac:19:00:02"
    }
}
</pre>  <p>Notice that <code class="highlighter-rouge">container2</code> belongs to two networks. It joined the default <code class="highlighter-rouge">bridge</code> network when you launched it and you connected it to the <code class="highlighter-rouge">isolated_nw</code> in step 3.</p> <p><img src="https://docs.docker.com/engine/userguide/networking/images/working.png" alt=""></p> <p>eth0 Link encap:Ethernet HWaddr 02:42:AC:11:00:03</p> <p>eth1 Link encap:Ethernet HWaddr 02:42:AC:15:00:02</p> </li> <li> <p>Use the <code class="highlighter-rouge">docker attach</code> command to connect to the running <code class="highlighter-rouge">container2</code> and examine its networking stack:</p> <pre class="highlight" data-language="bash">$ docker attach container2
</pre>  <p>Use the <code class="highlighter-rouge">ifconfig</code> command to examine the container’s networking stack. you should see two ethernet interfaces, one for the default <code class="highlighter-rouge">bridge</code> network, and the other for the <code class="highlighter-rouge">isolated_nw</code> network.</p> <pre class="highlight" data-language="bash">$ sudo ifconfig -a

eth0      Link encap:Ethernet  HWaddr 02:42:AC:11:00:03
          inet addr:172.17.0.3  Bcast:0.0.0.0  Mask:255.255.0.0
          inet6 addr: fe80::42:acff:fe11:3/64 Scope:Link
          UP BROADCAST RUNNING MULTICAST  MTU:9001  Metric:1
          RX packets:8 errors:0 dropped:0 overruns:0 frame:0
          TX packets:8 errors:0 dropped:0 overruns:0 carrier:0
          collisions:0 txqueuelen:0
          RX bytes:648 (648.0 B)  TX bytes:648 (648.0 B)

eth1      Link encap:Ethernet  HWaddr 02:42:AC:15:00:02
          inet addr:172.25.0.2  Bcast:0.0.0.0  Mask:255.255.0.0
          inet6 addr: fe80::42:acff:fe19:2/64 Scope:Link
          UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1
          RX packets:8 errors:0 dropped:0 overruns:0 frame:0
          TX packets:8 errors:0 dropped:0 overruns:0 carrier:0
          collisions:0 txqueuelen:0
          RX bytes:648 (648.0 B)  TX bytes:648 (648.0 B)

lo        Link encap:Local Loopback
          inet addr:127.0.0.1  Mask:255.0.0.0
          inet6 addr: ::1/128 Scope:Host
          UP LOOPBACK RUNNING  MTU:65536  Metric:1
          RX packets:0 errors:0 dropped:0 overruns:0 frame:0
          TX packets:0 errors:0 dropped:0 overruns:0 carrier:0
          collisions:0 txqueuelen:0
          RX bytes:0 (0.0 B)  TX bytes:0 (0.0 B)
</pre>  </li> <li> <p>The Docker embedded DNS server enables name resolution for containers connected to a given network. This means that any connected container can ping another container on the same network by its container name. From within <code class="highlighter-rouge">container2</code>, you can ping <code class="highlighter-rouge">container3</code> by name.</p> <pre class="highlight" data-language="bash">/ # ping -w 4 container3
PING container3 (172.25.3.3): 56 data bytes
64 bytes from 172.25.3.3: seq=0 ttl=64 time=0.070 ms
64 bytes from 172.25.3.3: seq=1 ttl=64 time=0.080 ms
64 bytes from 172.25.3.3: seq=2 ttl=64 time=0.080 ms
64 bytes from 172.25.3.3: seq=3 ttl=64 time=0.097 ms

--- container3 ping statistics ---
4 packets transmitted, 4 packets received, 0% packet loss
round-trip min/avg/max = 0.070/0.081/0.097 ms
</pre>  <p>This functionality is not available for the default <code class="highlighter-rouge">bridge</code> network. Both <code class="highlighter-rouge">container1</code> and <code class="highlighter-rouge">container2</code> are connected to the <code class="highlighter-rouge">bridge</code> network, but you cannot ping <code class="highlighter-rouge">container1</code> from <code class="highlighter-rouge">container2</code> using the container name.</p> <pre class="highlight" data-language="bash">/ # ping -w 4 container1
ping: bad address 'container1'
</pre>  <p>You can still ping the IP address directly:</p> <pre class="highlight" data-language="bash">/ # ping -w 4 172.17.0.2
PING 172.17.0.2 (172.17.0.2): 56 data bytes
64 bytes from 172.17.0.2: seq=0 ttl=64 time=0.095 ms
64 bytes from 172.17.0.2: seq=1 ttl=64 time=0.075 ms
64 bytes from 172.17.0.2: seq=2 ttl=64 time=0.072 ms
64 bytes from 172.17.0.2: seq=3 ttl=64 time=0.101 ms

--- 172.17.0.2 ping statistics ---
4 packets transmitted, 4 packets received, 0% packet loss
round-trip min/avg/max = 0.072/0.085/0.101 ms
</pre>  <p>Detach from <code class="highlighter-rouge">container2</code> and leave it running using <code class="highlighter-rouge">CTRL-p CTRL-q</code>.</p> </li> <li> <p>Currently, <code class="highlighter-rouge">container2</code> is attached to both <code class="highlighter-rouge">bridge</code> and <code class="highlighter-rouge">isolated_nw</code> networks, so it can communicate with both <code class="highlighter-rouge">container1</code> and <code class="highlighter-rouge">container3</code>. However, <code class="highlighter-rouge">container3</code> and <code class="highlighter-rouge">container1</code> do not have any networks in common, so they cannot communicate. To verify this, attach to <code class="highlighter-rouge">container3</code> and try to ping <code class="highlighter-rouge">container1</code> by IP address.</p> <pre class="highlight" data-language="bash">$ docker attach container3

$ ping 172.17.0.2
PING 172.17.0.2 (172.17.0.2): 56 data bytes
^C

--- 172.17.0.2 ping statistics ---
10 packets transmitted, 0 packets received, 100% packet loss

</pre>  <p>Detach from <code class="highlighter-rouge">container3</code> and leave it running using <code class="highlighter-rouge">CTRL-p CTRL-q</code>.</p> </li> </ol> <blockquote> <p>You can connect a container to a network even if the container is not running. However, <code class="highlighter-rouge">docker network inspect</code> only displays information on running containers.</p> </blockquote> <h3 id="linking-containers-without-using-user-defined-networks">Linking containers without using user-defined networks</h3> <p>After you complete the steps in <a href="#basic-container-networking-examples">Basic container networking examples</a>, <code class="highlighter-rouge">container2</code> can resolve <code class="highlighter-rouge">container3</code>’s name automatically because both containers are connected to the <code class="highlighter-rouge">isolated_nw</code> network. However, containers connected to the default <code class="highlighter-rouge">bridge</code> network cannot resolve each other’s container name. If you need containers to be able to communicate with each other over the <code class="highlighter-rouge">bridge</code> network, you need to use the legacy <a href="../default_network/dockerlinks/">link</a> feature. This is the only use case where using <code class="highlighter-rouge">--link</code> is recommended. You should strongly consider using user-defined networks instead.</p> <p>Using the legacy <code class="highlighter-rouge">link</code> flag adds the following features for communication between communication on the default <code class="highlighter-rouge">bridge</code> network:</p> <ul> <li>the ability to resolve container names to IP addresses</li> <li>the ability to define a network alias as an alternate way to refer to the linked container, using <code class="highlighter-rouge">--link=CONTAINER-NAME:ALIAS</code>
</li> <li>secured container connectivity (in isolation via <code class="highlighter-rouge">--icc=false</code>)</li> <li>environment variable injection</li> </ul> <p>To reiterate, all of these features are provided by default when you use a user-defined network, with no additional configuration required. <strong>Additionally, you get the ability to dynamically attach to and detach from multiple networks.</strong></p> <ul> <li>automatic name resolution using DNS</li> <li>supports the <code class="highlighter-rouge">--link</code> option to provide name alias for the linked container</li> <li>automatic secured isolated environment for the containers in a network</li> <li>environment variable injection</li> </ul> <p>The following example briefly describes how to use <code class="highlighter-rouge">--link</code>.</p> <ol> <li> <p>Continuing with the above example, create a new container, <code class="highlighter-rouge">container4</code>, and connect it to the network <code class="highlighter-rouge">isolated_nw</code>. In addition, link it to container <code class="highlighter-rouge">container5</code> (which does not exist yet!) using the <code class="highlighter-rouge">--link</code> flag.</p> <pre class="highlight" data-language="bash">$ docker run --network=isolated_nw -itd --name=container4 --link container5:c5 busybox

01b5df970834b77a9eadbaff39051f237957bd35c4c56f11193e0594cfd5117c
</pre>  <p>This is a little tricky, because <code class="highlighter-rouge">container5</code> does not exist yet. When <code class="highlighter-rouge">container5</code> is created, <code class="highlighter-rouge">container4</code> will be able to resolve the name <code class="highlighter-rouge">c5</code> to <code class="highlighter-rouge">container5</code>’s IP address.</p> <blockquote> <p><strong>Note:</strong> Any link between containers created with <em>legacy link</em> is static in nature and hard-binds the container with the alias. It does not tolerate linked container restarts. The new <em>link</em> functionality in user defined networks supports dynamic links between containers, and tolerates restarts and IP address changes in the linked container.</p> </blockquote> <p>Since you have not yet created container <code class="highlighter-rouge">container5</code> trying to ping it will result in an error. Attach to <code class="highlighter-rouge">container4</code> and try to ping either <code class="highlighter-rouge">container5</code> or <code class="highlighter-rouge">c5</code>:</p> <pre class="highlight" data-language="bash">$ docker attach container4

$ ping container5

ping: bad address 'container5'

$ ping c5

ping: bad address 'c5'

</pre>  <p>Detach from <code class="highlighter-rouge">container3</code> and leave it running using <code class="highlighter-rouge">CTRL-p CTRL-q</code>.</p> </li> <li> <p>Create another container named <code class="highlighter-rouge">container5</code>, and link it to <code class="highlighter-rouge">container4</code> using the alias <code class="highlighter-rouge">c4</code>.</p> <pre class="highlight" data-language="bash">$ docker run --network=isolated_nw -itd --name=container5 --link container4:c4 busybox

72eccf2208336f31e9e33ba327734125af00d1e1d2657878e2ee8154fbb23c7a
</pre>  <p>Now attach to <code class="highlighter-rouge">container4</code> and try to ping <code class="highlighter-rouge">c5</code> and <code class="highlighter-rouge">container5</code>.</p> <pre class="highlight" data-language="bash">$ docker attach container4

/ # ping -w 4 c5
PING c5 (172.25.0.5): 56 data bytes
64 bytes from 172.25.0.5: seq=0 ttl=64 time=0.070 ms
64 bytes from 172.25.0.5: seq=1 ttl=64 time=0.080 ms
64 bytes from 172.25.0.5: seq=2 ttl=64 time=0.080 ms
64 bytes from 172.25.0.5: seq=3 ttl=64 time=0.097 ms

--- c5 ping statistics ---
4 packets transmitted, 4 packets received, 0% packet loss
round-trip min/avg/max = 0.070/0.081/0.097 ms

/ # ping -w 4 container5
PING container5 (172.25.0.5): 56 data bytes
64 bytes from 172.25.0.5: seq=0 ttl=64 time=0.070 ms
64 bytes from 172.25.0.5: seq=1 ttl=64 time=0.080 ms
64 bytes from 172.25.0.5: seq=2 ttl=64 time=0.080 ms
64 bytes from 172.25.0.5: seq=3 ttl=64 time=0.097 ms

--- container5 ping statistics ---
4 packets transmitted, 4 packets received, 0% packet loss
round-trip min/avg/max = 0.070/0.081/0.097 ms
</pre>  <p>Detach from <code class="highlighter-rouge">container4</code> and leave it running using <code class="highlighter-rouge">CTRL-p CTRL-q</code>.</p> </li> <li> <p>Finally, attach to <code class="highlighter-rouge">container5</code> and verify that you can ping <code class="highlighter-rouge">container4</code>.</p> <pre class="highlight" data-language="bash">$ docker attach container5

/ # ping -w 4 c4
PING c4 (172.25.0.4): 56 data bytes
64 bytes from 172.25.0.4: seq=0 ttl=64 time=0.065 ms
64 bytes from 172.25.0.4: seq=1 ttl=64 time=0.070 ms
64 bytes from 172.25.0.4: seq=2 ttl=64 time=0.067 ms
64 bytes from 172.25.0.4: seq=3 ttl=64 time=0.082 ms

--- c4 ping statistics ---
4 packets transmitted, 4 packets received, 0% packet loss
round-trip min/avg/max = 0.065/0.070/0.082 ms

/ # ping -w 4 container4
PING container4 (172.25.0.4): 56 data bytes
64 bytes from 172.25.0.4: seq=0 ttl=64 time=0.065 ms
64 bytes from 172.25.0.4: seq=1 ttl=64 time=0.070 ms
64 bytes from 172.25.0.4: seq=2 ttl=64 time=0.067 ms
64 bytes from 172.25.0.4: seq=3 ttl=64 time=0.082 ms

--- container4 ping statistics ---
4 packets transmitted, 4 packets received, 0% packet loss
round-trip min/avg/max = 0.065/0.070/0.082 ms
</pre>  <p>Detach from <code class="highlighter-rouge">container5</code> and leave it running using <code class="highlighter-rouge">CTRL-p CTRL-q</code>.</p> </li> </ol> <h3 id="network-alias-scoping-example">Network alias scoping example</h3> <p>When you link containers, whether using the legacy <code class="highlighter-rouge">link</code> method or using user-defined networks, any aliases you specify only have meaning to the container where they are specified, and won’t work on other containers on the default <code class="highlighter-rouge">bridge</code> network.</p> <p>In addition, if a container belongs to multiple networks, a given linked alias is scoped within a given network. Thus, a container can be linked to different aliases in different networks, and the aliases will not work for containers which are not on the same network.</p> <p>The following example illustrates these points.</p> <ol> <li> <p>Create another network named <code class="highlighter-rouge">local_alias</code></p> <pre class="highlight" data-language="bash">$ docker network create -d bridge --subnet 172.26.0.0/24 local_alias
76b7dc932e037589e6553f59f76008e5b76fa069638cd39776b890607f567aaa
</pre>  </li> <li> <p>Next, connect <code class="highlighter-rouge">container4</code> and <code class="highlighter-rouge">container5</code> to the new network <code class="highlighter-rouge">local_alias</code> with the aliases <code class="highlighter-rouge">foo</code> and <code class="highlighter-rouge">bar</code>:</p> <pre class="highlight" data-language="bash">$ docker network connect --link container5:foo local_alias container4
$ docker network connect --link container4:bar local_alias container5
</pre>  </li> <li> <p>Attach to <code class="highlighter-rouge">container3</code> and try to ping <code class="highlighter-rouge">container4</code> using alias <code class="highlighter-rouge">foo</code>, then try pinging container <code class="highlighter-rouge">container5</code> using alias <code class="highlighter-rouge">c5</code>:</p> <p>```bash $ docker attach container4</p> <p>/ # ping -w 4 foo PING foo (172.26.0.3): 56 data bytes 64 bytes from 172.26.0.3: seq=0 ttl=64 time=0.070 ms 64 bytes from 172.26.0.3: seq=1 ttl=64 time=0.080 ms 64 bytes from 172.26.0.3: seq=2 ttl=64 time=0.080 ms 64 bytes from 172.26.0.3: seq=3 ttl=64 time=0.097 ms</p> <p>— foo ping statistics — 4 packets transmitted, 4 packets received, 0% packet loss round-trip min/avg/max = 0.070/0.081/0.097 ms</p> <p>/ # ping -w 4 c5 PING c5 (172.25.0.5): 56 data bytes 64 bytes from 172.25.0.5: seq=0 ttl=64 time=0.070 ms 64 bytes from 172.25.0.5: seq=1 ttl=64 time=0.080 ms 64 bytes from 172.25.0.5: seq=2 ttl=64 time=0.080 ms 64 bytes from 172.25.0.5: seq=3 ttl=64 time=0.097 ms</p> <p>— c5 ping statistics — 4 packets transmitted, 4 packets received, 0% packet loss round-trip min/avg/max = 0.070/0.081/0.097 ms ```</p> <p>Both pings succeed, but the subnets are different, which means that the networks are different.</p> <p>Detach from <code class="highlighter-rouge">container4</code> and leave it running using <code class="highlighter-rouge">CTRL-p CTRL-q</code>.</p> </li> <li> <p>Disconnect <code class="highlighter-rouge">container5</code> from the <code class="highlighter-rouge">isolated_nw</code> network. Attach to <code class="highlighter-rouge">container4</code> and try pinging <code class="highlighter-rouge">c5</code> and <code class="highlighter-rouge">foo</code>.</p> <pre class="highlight" data-language="">$ docker network disconnect isolated_nw container5

$ docker attach container4

/ # ping -w 4 c5
ping: bad address 'c5'

/ # ping -w 4 foo
PING foo (172.26.0.3): 56 data bytes
64 bytes from 172.26.0.3: seq=0 ttl=64 time=0.070 ms
64 bytes from 172.26.0.3: seq=1 ttl=64 time=0.080 ms
64 bytes from 172.26.0.3: seq=2 ttl=64 time=0.080 ms
64 bytes from 172.26.0.3: seq=3 ttl=64 time=0.097 ms

--- foo ping statistics ---
4 packets transmitted, 4 packets received, 0% packet loss
round-trip min/avg/max = 0.070/0.081/0.097 ms

</pre>  <p>You can no longer reach containers on the <code class="highlighter-rouge">isolated_nw</code> network from <code class="highlighter-rouge">container5</code>. However, you can still reach <code class="highlighter-rouge">container4</code> (from <code class="highlighter-rouge">container4</code>) using the alias <code class="highlighter-rouge">foo</code>.</p> <p>Detach from <code class="highlighter-rouge">container4</code> and leave it running using <code class="highlighter-rouge">CTRL-p CTRL-q</code>.</p> </li> </ol> <h3 id="limitations-of-docker-network">Limitations of <code class="highlighter-rouge">docker network</code>
</h3> <p>Although <code class="highlighter-rouge">docker network</code> is the recommended way to control the networks your containers use, it does have some limitations.</p> <h4 id="environment-variable-injection">Environment variable injection</h4> <p>Environment variable injection is static in nature and environment variables cannot be changed after a container is started. The legacy <code class="highlighter-rouge">--link</code> flag shares all environment variables to the linked container, but the <code class="highlighter-rouge">docker network</code> command has no equivalent. When you connect to a network using <code class="highlighter-rouge">docker network</code>, no environment variables can be dynamically among containers.</p> <h4 id="understanding-network-scoped-aliases">Understanding network-scoped aliases</h4> <p>Legacy links provide outgoing name resolution that is isolated within the container in which the alias is configured. Network-scoped aliases do not allow for this one-way isolation, but provide the alias to all members of the network.</p> <p>The following example illustrates this limitation.</p> <ol> <li> <p>Create another container called <code class="highlighter-rouge">container6</code> in the network <code class="highlighter-rouge">isolated_nw</code> and give it the network alias <code class="highlighter-rouge">app</code>.</p> <pre class="highlight" data-language="bash">$ docker run --network=isolated_nw -itd --name=container6 --network-alias app busybox

8ebe6767c1e0361f27433090060b33200aac054a68476c3be87ef4005eb1df17
</pre>  </li> <li> <p>Attach to <code class="highlighter-rouge">container4</code>. Try pinging the container by name (<code class="highlighter-rouge">container6</code>) and by network alias (<code class="highlighter-rouge">app</code>). Notice that the IP address is the same.</p> <pre class="highlight" data-language="bash">$ docker attach container4

/ # ping -w 4 app
PING app (172.25.0.6): 56 data bytes
64 bytes from 172.25.0.6: seq=0 ttl=64 time=0.070 ms
64 bytes from 172.25.0.6: seq=1 ttl=64 time=0.080 ms
64 bytes from 172.25.0.6: seq=2 ttl=64 time=0.080 ms
64 bytes from 172.25.0.6: seq=3 ttl=64 time=0.097 ms

--- app ping statistics ---
4 packets transmitted, 4 packets received, 0% packet loss
round-trip min/avg/max = 0.070/0.081/0.097 ms

/ # ping -w 4 container6
PING container5 (172.25.0.6): 56 data bytes
64 bytes from 172.25.0.6: seq=0 ttl=64 time=0.070 ms
64 bytes from 172.25.0.6: seq=1 ttl=64 time=0.080 ms
64 bytes from 172.25.0.6: seq=2 ttl=64 time=0.080 ms
64 bytes from 172.25.0.6: seq=3 ttl=64 time=0.097 ms

--- container6 ping statistics ---
4 packets transmitted, 4 packets received, 0% packet loss
round-trip min/avg/max = 0.070/0.081/0.097 ms
</pre>  <p>Detach from <code class="highlighter-rouge">container4</code> and leave it running using <code class="highlighter-rouge">CTRL-p CTRL-q</code>.</p> </li> <li> <p>Connect <code class="highlighter-rouge">container6</code> to the <code class="highlighter-rouge">local_alias</code> network with the network-scoped alias <code class="highlighter-rouge">scoped-app</code>.</p> <pre class="highlight" data-language="bash">$ docker network connect --alias scoped-app local_alias container6
</pre>  <p>Now <code class="highlighter-rouge">container6</code> is aliased as <code class="highlighter-rouge">app</code> in network <code class="highlighter-rouge">isolated_nw</code> and as <code class="highlighter-rouge">scoped-app</code> in network <code class="highlighter-rouge">local_alias</code>.</p> </li> <li> <p>Try to reach these aliases from <code class="highlighter-rouge">container4</code> (which is connected to both these networks) and <code class="highlighter-rouge">container5</code> (which is connected only to <code class="highlighter-rouge">isolated_nw</code>).</p> <pre class="highlight" data-language="bash">$ docker attach container4

/ # ping -w 4 scoped-app
PING foo (172.26.0.5): 56 data bytes
64 bytes from 172.26.0.5: seq=0 ttl=64 time=0.070 ms
64 bytes from 172.26.0.5: seq=1 ttl=64 time=0.080 ms
64 bytes from 172.26.0.5: seq=2 ttl=64 time=0.080 ms
64 bytes from 172.26.0.5: seq=3 ttl=64 time=0.097 ms

--- foo ping statistics ---
4 packets transmitted, 4 packets received, 0% packet loss
round-trip min/avg/max = 0.070/0.081/0.097 ms
</pre>  <p>Detach from <code class="highlighter-rouge">container4</code> and leave it running using <code class="highlighter-rouge">CTRL-p CTRL-q</code>.</p> <pre class="highlight" data-language="bash">$ docker attach container5

/ # ping -w 4 scoped-app
ping: bad address 'scoped-app'

</pre>  <p>Detach from <code class="highlighter-rouge">container5</code> and leave it running using <code class="highlighter-rouge">CTRL-p CTRL-q</code>.</p> </li> </ol> <p>This shows that an alias is scoped to the network where it is defined, and only containers connected to that network can access the alias.</p> <h4 id="resolving-multiple-containers-to-a-single-alias">Resolving multiple containers to a single alias</h4> <p>Multiple containers can share the same network-scoped alias within the same network. This example illustrates how this works.</p> <ol> <li> <p>Launch <code class="highlighter-rouge">container7</code> in <code class="highlighter-rouge">isolated_nw</code> with the same alias as <code class="highlighter-rouge">container6</code>, which is <code class="highlighter-rouge">app</code>.</p> <pre class="highlight" data-language="bash">$ docker run --network=isolated_nw -itd --name=container7 --network-alias app busybox

3138c678c123b8799f4c7cc6a0cecc595acbdfa8bf81f621834103cd4f504554
</pre>  <p>When multiple containers share the same alias, one of those containers will resolve to the alias. If that container is unavailable, another container with the alias will be resolved. This provides a sort of high availability within the cluster.</p> <blockquote> <p>When the IP address is resolved, the container chosen to resolve it is random. For that reason, in the exercises below, you may get different results in some steps. If the step assumes the result returned is <code class="highlighter-rouge">container6</code> but you get <code class="highlighter-rouge">container7</code>, this is why.</p> </blockquote> </li> <li> <p>Start a continuous ping from <code class="highlighter-rouge">container4</code> to the <code class="highlighter-rouge">app</code> alias.</p> <pre class="highlight" data-language="bash">$ docker attach container4

$ ping app
PING app (172.25.0.6): 56 data bytes
64 bytes from 172.25.0.6: seq=0 ttl=64 time=0.070 ms
64 bytes from 172.25.0.6: seq=1 ttl=64 time=0.080 ms
64 bytes from 172.25.0.6: seq=2 ttl=64 time=0.080 ms
64 bytes from 172.25.0.6: seq=3 ttl=64 time=0.097 ms
...
</pre>  <p>The IP address that is returned belongs to <code class="highlighter-rouge">container6</code>.</p> </li> <li> <p>In another terminal, stop <code class="highlighter-rouge">container6</code>. <code class="highlighter-rouge">bash $ docker stop container6</code></p> <p>In the terminal attached to <code class="highlighter-rouge">container4</code>, observe the <code class="highlighter-rouge">ping</code> output. It will pause when <code class="highlighter-rouge">container6</code> goes down, because the <code class="highlighter-rouge">ping</code> command looks up the IP when it is first invoked, and that IP is no longer reachable. However, the <code class="highlighter-rouge">ping</code> command has a very long timeout by default, so no error occurs.</p> </li> <li> <p>Exit the <code class="highlighter-rouge">ping</code> command using <code class="highlighter-rouge">CTRL+C</code> and run it again.</p> <pre class="highlight" data-language="bash">$ ping app

PING app (172.25.0.7): 56 data bytes
64 bytes from 172.25.0.7: seq=0 ttl=64 time=0.095 ms
64 bytes from 172.25.0.7: seq=1 ttl=64 time=0.075 ms
64 bytes from 172.25.0.7: seq=2 ttl=64 time=0.072 ms
64 bytes from 172.25.0.7: seq=3 ttl=64 time=0.101 ms
...
</pre>  <p>The <code class="highlighter-rouge">app</code> alias now resolves to the IP address of <code class="highlighter-rouge">container7</code>.</p> </li> <li> <p>For one last test, restart <code class="highlighter-rouge">container6</code>.</p> <pre class="highlight" data-language="bash">$ docker start container6
</pre>  <p>In the terminal attached to <code class="highlighter-rouge">container4</code>, run the <code class="highlighter-rouge">ping</code> command again. It might now resolve to <code class="highlighter-rouge">container6</code> again. If you start and stop the <code class="highlighter-rouge">ping</code> several times, you will see responses from each of the containers.</p> <pre class="highlight" data-language="bash">$ docker attach container4

$ ping app
PING app (172.25.0.6): 56 data bytes
64 bytes from 172.25.0.6: seq=0 ttl=64 time=0.070 ms
64 bytes from 172.25.0.6: seq=1 ttl=64 time=0.080 ms
64 bytes from 172.25.0.6: seq=2 ttl=64 time=0.080 ms
64 bytes from 172.25.0.6: seq=3 ttl=64 time=0.097 ms
...
</pre>  <p>Stop the ping with <code class="highlighter-rouge">CTRL+C</code>. Detach from <code class="highlighter-rouge">container4</code> and leave it running using <code class="highlighter-rouge">CTRL-p CTRL-q</code>.</p> </li> </ol> <h2 id="disconnecting-containers">Disconnecting containers</h2> <p>You can disconnect a container from a network at any time using the <code class="highlighter-rouge">docker network disconnect</code> command.</p> <ol> <li> <p>Disconnect <code class="highlighter-rouge">container2</code> from the <code class="highlighter-rouge">isolated_nw</code> network, then inspect <code class="highlighter-rouge">container2</code> and the <code class="highlighter-rouge">isolated_nw</code> network.</p> <pre class="highlight" data-language="bash">$ docker network disconnect isolated_nw container2

$ docker inspect --format=''  container2 | python -m json.tool

{
    "bridge": {
        "NetworkID":"7ea29fc1412292a2d7bba362f9253545fecdfa8ce9a6e37dd10ba8bee7129812",
        "EndpointID": "9e4575f7f61c0f9d69317b7a4b92eefc133347836dd83ef65deffa16b9985dc0",
        "Gateway": "172.17.0.1",
        "GlobalIPv6Address": "",
        "GlobalIPv6PrefixLen": 0,
        "IPAddress": "172.17.0.3",
        "IPPrefixLen": 16,
        "IPv6Gateway": "",
        "MacAddress": "02:42:ac:11:00:03"
    }
}


$ docker network inspect isolated_nw

[
    {
        "Name": "isolated_nw",
        "Id": "06a62f1c73c4e3107c0f555b7a5f163309827bfbbf999840166065a8f35455a8",
        "Scope": "local",
        "Driver": "bridge",
        "IPAM": {
            "Driver": "default",
            "Config": [
                {
                    "Subnet": "172.21.0.0/16",
                    "Gateway": "172.21.0.1/16"
                }
            ]
        },
        "Containers": {
            "467a7863c3f0277ef8e661b38427737f28099b61fa55622d6c30fb288d88c551": {
                "Name": "container3",
                "EndpointID": "dffc7ec2915af58cc827d995e6ebdc897342be0420123277103c40ae35579103",
                "MacAddress": "02:42:ac:19:03:03",
                "IPv4Address": "172.25.3.3/16",
                "IPv6Address": ""
            }
        },
        "Options": {}
    }
]
</pre>  </li> <li> <p>When a container is disconnected from a network, it can no longer communicate with other containers connected to that network, unless it has other networks in common with them. Verify that <code class="highlighter-rouge">container2</code> can no longer reach <code class="highlighter-rouge">container3</code>, which is on the <code class="highlighter-rouge">isolated_nw</code> network.</p> <pre class="highlight" data-language="bash">$ docker attach container2

/ # ifconfig
eth0      Link encap:Ethernet  HWaddr 02:42:AC:11:00:03  
          inet addr:172.17.0.3  Bcast:0.0.0.0  Mask:255.255.0.0
          inet6 addr: fe80::42:acff:fe11:3/64 Scope:Link
          UP BROADCAST RUNNING MULTICAST  MTU:9001  Metric:1
          RX packets:8 errors:0 dropped:0 overruns:0 frame:0
          TX packets:8 errors:0 dropped:0 overruns:0 carrier:0
          collisions:0 txqueuelen:0
          RX bytes:648 (648.0 B)  TX bytes:648 (648.0 B)

lo        Link encap:Local Loopback  
          inet addr:127.0.0.1  Mask:255.0.0.0
          inet6 addr: ::1/128 Scope:Host
          UP LOOPBACK RUNNING  MTU:65536  Metric:1
          RX packets:0 errors:0 dropped:0 overruns:0 frame:0
          TX packets:0 errors:0 dropped:0 overruns:0 carrier:0
          collisions:0 txqueuelen:0
          RX bytes:0 (0.0 B)  TX bytes:0 (0.0 B)

/ # ping container3
PING container3 (172.25.3.3): 56 data bytes
^C
--- container3 ping statistics ---
2 packets transmitted, 0 packets received, 100% packet loss
</pre>  </li> <li> <p>Verify that <code class="highlighter-rouge">container2</code> still has full connectivity to the default <code class="highlighter-rouge">bridge</code> network.</p> <pre class="highlight" data-language="bash">/ # ping container1
PING container1 (172.17.0.2): 56 data bytes
64 bytes from 172.17.0.2: seq=0 ttl=64 time=0.119 ms
64 bytes from 172.17.0.2: seq=1 ttl=64 time=0.174 ms
^C
--- container1 ping statistics ---
2 packets transmitted, 2 packets received, 0% packet loss
round-trip min/avg/max = 0.119/0.146/0.174 ms
/ #
</pre>  </li> <li> <p>Remove <code class="highlighter-rouge">container4</code>, <code class="highlighter-rouge">container5</code>, <code class="highlighter-rouge">container6</code>, and <code class="highlighter-rouge">container7</code>. ```bash $ docker stop container4 container5 container6 container7</p> <p>$ docker rm container4 container5 container6 container7 ```</p> </li> </ol> <h3 id="handling-stale-network-endpoints">Handling stale network endpoints</h3> <p>In some scenarios, such as ungraceful docker daemon restarts in a multi-host network, the daemon cannot clean up stale connectivity endpoints. Such stale endpoints may cause an error if a new container is connected to that network with the same name as the stale endpoint:</p> <pre data-language="">ERROR: Cannot start container bc0b19c089978f7845633027aa3435624ca3d12dd4f4f764b61eac4c0610f32e: container already connected to network multihost
</pre> <p>To clean up these stale endpoints, remove the container and disconnect it from the network forcibly (<code class="highlighter-rouge">docker network disconnect -f</code>). Now you can successfully connect the container to the network.</p> <pre class="highlight" data-language="bash">$ docker run -d --name redis_db --network multihost redis

ERROR: Cannot start container bc0b19c089978f7845633027aa3435624ca3d12dd4f4f764b61eac4c0610f32e: container already connected to network multihost

$ docker rm -f redis_db

$ docker network disconnect -f multihost redis_db

$ docker run -d --name redis_db --network multihost redis

7d986da974aeea5e9f7aca7e510bdb216d58682faa83a9040c2f2adc0544795a
</pre>  <h2 id="remove-a-network">Remove a network</h2> <p>When all the containers in a network are stopped or disconnected, you can remove a network. If a network has connected endpoints, an error occurs.</p> <ol> <li> <p>Disconnect <code class="highlighter-rouge">container3</code> from <code class="highlighter-rouge">isolated_nw</code>.</p> <p><code class="highlighter-rouge">bash $ docker network disconnect isolated_nw container3</code></p> </li> <li> <p>Inspect <code class="highlighter-rouge">isolated_nw</code> to verify that no other endpoints are connected to it.</p> <pre class="highlight" data-language="bash">$ docker network inspect isolated_nw

[
    {
        "Name": "isolated_nw",
        "Id": "06a62f1c73c4e3107c0f555b7a5f163309827bfbbf999840166065a8f35455a8",
        "Scope": "local",
        "Driver": "bridge",
        "IPAM": {
            "Driver": "default",
            "Config": [
                {
                    "Subnet": "172.21.0.0/16",
                    "Gateway": "172.21.0.1/16"
                }
            ]
        },
        "Containers": {},
        "Options": {}
    }
]
</pre>  </li> <li> <p>Remove the <code class="highlighter-rouge">isolated_nw</code> network. <code class="highlighter-rouge">bash $ docker network rm isolated_nw</code></p> </li> <li> <p>List all your networks to verify that <code class="highlighter-rouge">isolated_nw</code> no longer exists:</p> <pre class="highlight" data-language="bash">$ docker network ls

NETWORK ID          NAME                DRIVER              SCOPE
4bb8c9bf4292        bridge              bridge              local
43575911a2bd        host                host                local
76b7dc932e03        local_alias         bridge              local
b1a086897963        my-network          bridge              local
3eb020e70bfd        none                null                local
69568e6336d8        simple-network      bridge              local
</pre>  </li> </ol> <h2 id="related-information">Related information</h2> <ul> <li><a href="../../../reference/commandline/network_create/">network create</a></li> <li><a href="../../../reference/commandline/network_inspect/">network inspect</a></li> <li><a href="../../../reference/commandline/network_connect/">network connect</a></li> <li><a href="../../../reference/commandline/network_disconnect/">network disconnect</a></li> <li><a href="../../../reference/commandline/network_ls/">network ls</a></li> <li><a href="../../../reference/commandline/network_rm/">network rm</a></li> </ul>
<div class="_attribution">
  <p class="_attribution-p">
    © 2013–2016 Docker, Inc.<br>Licensed under the Apache License, Version 2.0.<br>Docker and the Docker logo are trademarks or registered trademarks of Docker, Inc. in the United States and/or other countries.<br>Docker, Inc. and other parties may also have trademark rights in other terms used herein.<br>
    <a href="https://docs.docker.com/engine/userguide/networking/work-with-networks/" class="_attribution-link" target="_blank">https://docs.docker.com/engine/userguide/networking/work-with-networks/</a>
  </p>
</div>

			</div>
		</div>
	</section>

	</div>
</body>
</html>
