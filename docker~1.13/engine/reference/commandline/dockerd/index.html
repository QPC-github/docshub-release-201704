
<!DOCTYPE HTML>

<html lang="en">

<head>
  <meta charset="utf-8">
  <title>Daemon CLI Reference (Engine) - Docker 1.13 - W3cubDocs</title>
  
  <meta name="description" content=" A self-sufficient runtime for containers. ">
  <meta name="keywords" content="dockerd, daemon, cli, reference, engine, -, docker, docker~1.13">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="http://docs.w3cub.com/docker~1.13/engine/reference/commandline/dockerd/">
  <link href="/favicon.png" rel="icon">
  <link type="text/css" rel="stylesheet" href="/assets/application-50364fff564ce3b6327021805f3f00e2957b441cf27f576a7dd4ff63bbc47047.css">
  <script type="text/javascript" src="/assets/application-db64bfd54ceb42be11af7995804cf4902548419ceb79d509b0b7d62c22d98e6f.js"></script>
  <script src="/json/docker~1.13.js"></script>
  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-71174418-1']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>


</head>

<body>
	<div class="_app">
	<header class="_header">
  
  <form class="_search">
    <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
    <a class="_search-clear"></a>
    <div class="_search-tag"></div>
  </form>
  
  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/docker~1.13/" class="_nav-link" title="" style="margin-left:0;">Docker 1.13</a></span>
  
  <nav class="_nav">
    <a href="/app/" class="_nav-link ">App</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		<div class="_list">
			
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<div class="_page _docker">
				
<h1>dockerd</h1>    <h2 id="description">Description</h2> <p>A self-sufficient runtime for containers.</p> <h2 id="usage">Usage</h2> <pre class="highlight" data-language="shell">dockerd [OPTIONS]
</pre>  <h2 id="options">Options</h2> <table> <thead> <tr> <th>Name, shorthand</th> <th>Default</th> <th>Description</th> </tr> </thead> <tbody> <tr> <td><code class="highlighter-rouge">--add-runtime</code></td> <td> </td> <td>Register an additional OCI compatible runtime</td> </tr> <tr> <td><code class="highlighter-rouge">--api-cors-header</code></td> <td> </td> <td>Set CORS headers in the remote API</td> </tr> <tr> <td><code class="highlighter-rouge">--authorization-plugin</code></td> <td> </td> <td>Authorization plugins to load</td> </tr> <tr> <td><code class="highlighter-rouge">--bridge, -b</code></td> <td> </td> <td>Attach containers to a network bridge</td> </tr> <tr> <td><code class="highlighter-rouge">--bip</code></td> <td> </td> <td>Specify network bridge IP</td> </tr> <tr> <td><code class="highlighter-rouge">--cgroup-parent</code></td> <td> </td> <td>Set parent cgroup for all containers</td> </tr> <tr> <td><code class="highlighter-rouge">--cluster-advertise</code></td> <td> </td> <td>Address or interface name to advertise</td> </tr> <tr> <td><code class="highlighter-rouge">--cluster-store</code></td> <td><code class="highlighter-rouge">map[]</code></td> <td>Set cluster store options</td> </tr> <tr> <td><code class="highlighter-rouge">--config-file</code></td> <td><code class="highlighter-rouge">/etc/docker/daemon.json</code></td> <td>Daemon configuration file</td> </tr> <tr> <td><code class="highlighter-rouge">--containerd</code></td> <td> </td> <td>Path to containerd socket</td> </tr> <tr> <td><code class="highlighter-rouge">--debug, -D</code></td> <td> </td> <td>Enable debug mode</td> </tr> <tr> <td><code class="highlighter-rouge">--default-gateway</code></td> <td> </td> <td>Container default gateway IPv4 address</td> </tr> <tr> <td><code class="highlighter-rouge">--default-gateway-v6</code></td> <td> </td> <td>Container default gateway IPv6 address</td> </tr> <tr> <td><code class="highlighter-rouge">--default-runtime</code></td> <td><code class="highlighter-rouge">runc</code></td> <td>Default OCI runtime for containers</td> </tr> <tr> <td><code class="highlighter-rouge">--default-ulimit</code></td> <td> </td> <td>Default ulimits for containers</td> </tr> <tr> <td><code class="highlighter-rouge">--disable-legacy-registry</code></td> <td> </td> <td>Disable contacting legacy registries</td> </tr> <tr> <td><code class="highlighter-rouge">--dns</code></td> <td> </td> <td>DNS server to use</td> </tr> <tr> <td><code class="highlighter-rouge">--dns-opt</code></td> <td> </td> <td>DNS options to use</td> </tr> <tr> <td><code class="highlighter-rouge">--dns-search</code></td> <td> </td> <td>DNS search domains to use</td> </tr> <tr> <td><code class="highlighter-rouge">--exec-opt</code></td> <td> </td> <td>Runtime execution options</td> </tr> <tr> <td><code class="highlighter-rouge">--exec-root</code></td> <td><code class="highlighter-rouge">/var/run/docker</code></td> <td>Root directory for execution state files</td> </tr> <tr> <td><code class="highlighter-rouge">--fixed-cidr</code></td> <td> </td> <td>IPv4 subnet for fixed IPs</td> </tr> <tr> <td><code class="highlighter-rouge">--fixed-cidr-v6</code></td> <td> </td> <td>IPv6 subnet for fixed IPs</td> </tr> <tr> <td><code class="highlighter-rouge">--group, -G</code></td> <td><code class="highlighter-rouge">docker</code></td> <td>Group for the unix socket</td> </tr> <tr> <td><code class="highlighter-rouge">--graph, -g</code></td> <td><code class="highlighter-rouge">/var/lib/docker</code></td> <td>Root of the Docker runtime</td> </tr> <tr> <td><code class="highlighter-rouge">--host, -H</code></td> <td> </td> <td>Daemon socket(s) to connect to</td> </tr> <tr> <td><code class="highlighter-rouge">--help</code></td> <td> </td> <td>Print usage</td> </tr> <tr> <td><code class="highlighter-rouge">--icc</code></td> <td><code class="highlighter-rouge">true</code></td> <td>Enable inter-container communication</td> </tr> <tr> <td><code class="highlighter-rouge">--insecure-registry</code></td> <td> </td> <td>Enable insecure registry communication</td> </tr> <tr> <td><code class="highlighter-rouge">--ip</code></td> <td><code class="highlighter-rouge">0.0.0.0</code></td> <td>Default IP when binding container ports</td> </tr> <tr> <td><code class="highlighter-rouge">--ip-forward</code></td> <td><code class="highlighter-rouge">true</code></td> <td>Enable net.ipv4.ip_forward</td> </tr> <tr> <td><code class="highlighter-rouge">--ip-masq</code></td> <td><code class="highlighter-rouge">true</code></td> <td>Enable IP masquerading</td> </tr> <tr> <td><code class="highlighter-rouge">--iptables</code></td> <td><code class="highlighter-rouge">true</code></td> <td>Enable addition of iptables rules</td> </tr> <tr> <td><code class="highlighter-rouge">--ipv6</code></td> <td> </td> <td>Enable IPv6 networking</td> </tr> <tr> <td><code class="highlighter-rouge">--log-level, -l</code></td> <td><code class="highlighter-rouge">info</code></td> <td>Set the logging level</td> </tr> <tr> <td><code class="highlighter-rouge">--label</code></td> <td> </td> <td>Set key=value labels to the daemon</td> </tr> <tr> <td><code class="highlighter-rouge">--live-restore</code></td> <td> </td> <td>Enables keeping containers alive during daemon downtime</td> </tr> <tr> <td><code class="highlighter-rouge">--log-driver</code></td> <td><code class="highlighter-rouge">json-file</code></td> <td>Default driver for container logs</td> </tr> <tr> <td><code class="highlighter-rouge">--log-opt</code></td> <td><code class="highlighter-rouge">map[]</code></td> <td>Default log driver options for containers</td> </tr> <tr> <td><code class="highlighter-rouge">--max-concurrent-downloads</code></td> <td><code class="highlighter-rouge">3</code></td> <td>Set the max concurrent downloads for each pull</td> </tr> <tr> <td><code class="highlighter-rouge">--max-concurrent-uploads</code></td> <td><code class="highlighter-rouge">5</code></td> <td>Set the max concurrent uploads for each push</td> </tr> <tr> <td><code class="highlighter-rouge">--mtu</code></td> <td> </td> <td>Set the containers network MTU</td> </tr> <tr> <td><code class="highlighter-rouge">--oom-score-adjust</code></td> <td><code class="highlighter-rouge">-500</code></td> <td>Set the oom_score_adj for the daemon</td> </tr> <tr> <td><code class="highlighter-rouge">--pidfile, -p</code></td> <td><code class="highlighter-rouge">/var/run/docker.pid</code></td> <td>Path to use for daemon PID file</td> </tr> <tr> <td><code class="highlighter-rouge">--raw-logs</code></td> <td> </td> <td>Full timestamps without ANSI coloring</td> </tr> <tr> <td><code class="highlighter-rouge">--registry-mirror</code></td> <td> </td> <td>Preferred Docker registry mirror</td> </tr> <tr> <td><code class="highlighter-rouge">--storage-driver, -s</code></td> <td> </td> <td>Storage driver to use</td> </tr> <tr> <td><code class="highlighter-rouge">--selinux-enabled</code></td> <td> </td> <td>Enable selinux support</td> </tr> <tr> <td><code class="highlighter-rouge">--storage-opt</code></td> <td> </td> <td>Storage driver options</td> </tr> <tr> <td><code class="highlighter-rouge">--swarm-default-advertise-addr</code></td> <td> </td> <td>Set default address or interface for swarm advertised address</td> </tr> <tr> <td><code class="highlighter-rouge">--tls</code></td> <td> </td> <td>Use TLS; implied by –tlsverify</td> </tr> <tr> <td><code class="highlighter-rouge">--tlscacert</code></td> <td><code class="highlighter-rouge">~/.docker/ca.pem</code></td> <td>Trust certs signed only by this CA</td> </tr> <tr> <td><code class="highlighter-rouge">--tlscert</code></td> <td><code class="highlighter-rouge">~/.docker/cert.pem</code></td> <td>Path to TLS certificate file</td> </tr> <tr> <td><code class="highlighter-rouge">--tlskey</code></td> <td><code class="highlighter-rouge">~/.docker/key.pem</code></td> <td>Path to TLS key file</td> </tr> <tr> <td><code class="highlighter-rouge">--tlsverify</code></td> <td> </td> <td>Use TLS and verify the remote</td> </tr> <tr> <td><code class="highlighter-rouge">--userland-proxy</code></td> <td><code class="highlighter-rouge">true</code></td> <td>Use userland proxy for loopback traffic</td> </tr> <tr> <td><code class="highlighter-rouge">--userns-remap</code></td> <td> </td> <td>User/Group setting for user namespaces</td> </tr> <tr> <td><code class="highlighter-rouge">--version, -v</code></td> <td> </td> <td>Print version information and quit</td> </tr> </tbody> </table> <h2 id="extended-description">Extended description</h2> <p>Options with [] may be specified multiple times.</p> <p>dockerd is the persistent process that manages containers. Docker uses different binaries for the daemon and client. To run the daemon you type <code class="highlighter-rouge">dockerd</code>.</p> <p>To run the daemon with debug output, use <code class="highlighter-rouge">dockerd -D</code>.</p> <h2 id="daemon-socket-option">Daemon socket option</h2> <p>The Docker daemon can listen for <a href="../../../api/">Docker Remote API</a> requests via three different types of Socket: <code class="highlighter-rouge">unix</code>, <code class="highlighter-rouge">tcp</code>, and <code class="highlighter-rouge">fd</code>.</p> <p>By default, a <code class="highlighter-rouge">unix</code> domain socket (or IPC socket) is created at <code class="highlighter-rouge">/var/run/docker.sock</code>, requiring either <code class="highlighter-rouge">root</code> permission, or <code class="highlighter-rouge">docker</code> group membership.</p> <p>If you need to access the Docker daemon remotely, you need to enable the <code class="highlighter-rouge">tcp</code> Socket. Beware that the default setup provides un-encrypted and un-authenticated direct access to the Docker daemon - and should be secured either using the <a href="../../../security/https/">built in HTTPS encrypted socket</a>, or by putting a secure web proxy in front of it. You can listen on port <code class="highlighter-rouge">2375</code> on all network interfaces with <code class="highlighter-rouge">-H tcp://0.0.0.0:2375</code>, or on a particular network interface using its IP address: <code class="highlighter-rouge">-H tcp://192.168.59.103:2375</code>. It is conventional to use port <code class="highlighter-rouge">2375</code> for un-encrypted, and port <code class="highlighter-rouge">2376</code> for encrypted communication with the daemon.</p> <blockquote> <p><strong>Note:</strong> If you’re using an HTTPS encrypted socket, keep in mind that only TLS1.0 and greater are supported. Protocols SSLv3 and under are not supported anymore for security reasons.</p> </blockquote> <p>On Systemd based systems, you can communicate with the daemon via <a href="http://0pointer.de/blog/projects/socket-activation.html" target="_blank">Systemd socket activation</a>, use <code class="highlighter-rouge">dockerd -H fd://</code>. Using <code class="highlighter-rouge">fd://</code> will work perfectly for most setups but you can also specify individual sockets: <code class="highlighter-rouge">dockerd -H fd://3</code>. If the specified socket activated files aren’t found, then Docker will exit. You can find examples of using Systemd socket activation with Docker and Systemd in the <a href="https://github.com/docker/docker/tree/master/contrib/init/systemd/" target="_blank">Docker source tree</a>.</p> <p>You can configure the Docker daemon to listen to multiple sockets at the same time using multiple <code class="highlighter-rouge">-H</code> options:</p> <pre class="highlight" data-language="bash"># listen using the default unix socket, and on 2 specific IP addresses on this host.
$ sudo dockerd -H unix:///var/run/docker.sock -H tcp://192.168.59.106 -H tcp://10.10.10.2
</pre>  <p>The Docker client will honor the <code class="highlighter-rouge">DOCKER_HOST</code> environment variable to set the <code class="highlighter-rouge">-H</code> flag for the client.</p> <pre class="highlight" data-language="bash">$ docker -H tcp://0.0.0.0:2375 ps
# or
$ export DOCKER_HOST="tcp://0.0.0.0:2375"
$ docker ps
# both are equal
</pre>  <p>Setting the <code class="highlighter-rouge">DOCKER_TLS_VERIFY</code> environment variable to any value other than the empty string is equivalent to setting the <code class="highlighter-rouge">--tlsverify</code> flag. The following are equivalent:</p> <pre class="highlight" data-language="bash">$ docker --tlsverify ps
# or
$ export DOCKER_TLS_VERIFY=1
$ docker ps
</pre>  <p>The Docker client will honor the <code class="highlighter-rouge">HTTP_PROXY</code>, <code class="highlighter-rouge">HTTPS_PROXY</code>, and <code class="highlighter-rouge">NO_PROXY</code> environment variables (or the lowercase versions thereof). <code class="highlighter-rouge">HTTPS_PROXY</code> takes precedence over <code class="highlighter-rouge">HTTP_PROXY</code>.</p> <h3 id="bind-docker-to-another-hostport-or-a-unix-socket">Bind Docker to another host/port or a Unix socket</h3> <blockquote> <p><strong>Warning</strong>: Changing the default <code class="highlighter-rouge">docker</code> daemon binding to a TCP port or Unix <em>docker</em> user group will increase your security risks by allowing non-root users to gain <em>root</em> access on the host. Make sure you control access to <code class="highlighter-rouge">docker</code>. If you are binding to a TCP port, anyone with access to that port has full Docker access; so it is not advisable on an open network.</p> </blockquote> <p>With <code class="highlighter-rouge">-H</code> it is possible to make the Docker daemon to listen on a specific IP and port. By default, it will listen on <code class="highlighter-rouge">unix:///var/run/docker.sock</code> to allow only local connections by the <em>root</em> user. You <em>could</em> set it to <code class="highlighter-rouge">0.0.0.0:2375</code> or a specific host IP to give access to everybody, but that is <strong>not recommended</strong> because then it is trivial for someone to gain root access to the host where the daemon is running.</p> <p>Similarly, the Docker client can use <code class="highlighter-rouge">-H</code> to connect to a custom port. The Docker client will default to connecting to <code class="highlighter-rouge">unix:///var/run/docker.sock</code> on Linux, and <code class="highlighter-rouge">tcp://127.0.0.1:2376</code> on Windows.</p> <p><code class="highlighter-rouge">-H</code> accepts host and port assignment in the following format:</p> <pre class="highlight" data-language="">tcp://[host]:[port][path] or unix://path
</pre>  <p>For example:</p> <ul> <li>
<code class="highlighter-rouge">tcp://</code> -&gt; TCP connection to <code class="highlighter-rouge">127.0.0.1</code> on either port <code class="highlighter-rouge">2376</code> when TLS encryption is on, or port <code class="highlighter-rouge">2375</code> when communication is in plain text.</li> <li>
<code class="highlighter-rouge">tcp://host:2375</code> -&gt; TCP connection on host:2375</li> <li>
<code class="highlighter-rouge">tcp://host:2375/path</code> -&gt; TCP connection on host:2375 and prepend path to all requests</li> <li>
<code class="highlighter-rouge">unix://path/to/socket</code> -&gt; Unix socket located at <code class="highlighter-rouge">path/to/socket</code>
</li> </ul> <p><code class="highlighter-rouge">-H</code>, when empty, will default to the same value as when no <code class="highlighter-rouge">-H</code> was passed in.</p> <p><code class="highlighter-rouge">-H</code> also accepts short form for TCP bindings: <code class="highlighter-rouge">host:</code> or <code class="highlighter-rouge">host:port</code> or <code class="highlighter-rouge">:port</code></p> <p>Run Docker in daemon mode:</p> <pre class="highlight" data-language="bash">$ sudo &lt;path to&gt;/dockerd -H 0.0.0.0:5555 &amp;
</pre>  <p>Download an <code class="highlighter-rouge">ubuntu</code> image:</p> <pre class="highlight" data-language="bash">$ docker -H :5555 pull ubuntu
</pre>  <p>You can use multiple <code class="highlighter-rouge">-H</code>, for example, if you want to listen on both TCP and a Unix socket</p> <pre class="highlight" data-language="bash"># Run docker in daemon mode
$ sudo &lt;path to&gt;/dockerd -H tcp://127.0.0.1:2375 -H unix:///var/run/docker.sock &amp;
# Download an ubuntu image, use default Unix socket
$ docker pull ubuntu
# OR use the TCP port
$ docker -H tcp://127.0.0.1:2375 pull ubuntu
</pre>  <h3 id="daemon-storage-driver-option">Daemon storage-driver option</h3> <p>The Docker daemon has support for several different image layer storage drivers: <code class="highlighter-rouge">aufs</code>, <code class="highlighter-rouge">devicemapper</code>, <code class="highlighter-rouge">btrfs</code>, <code class="highlighter-rouge">zfs</code>, <code class="highlighter-rouge">overlay</code> and <code class="highlighter-rouge">overlay2</code>.</p> <p>The <code class="highlighter-rouge">aufs</code> driver is the oldest, but is based on a Linux kernel patch-set that is unlikely to be merged into the main kernel. These are also known to cause some serious kernel crashes. However, <code class="highlighter-rouge">aufs</code> allows containers to share executable and shared library memory, so is a useful choice when running thousands of containers with the same program or libraries.</p> <p>The <code class="highlighter-rouge">devicemapper</code> driver uses thin provisioning and Copy on Write (CoW) snapshots. For each devicemapper graph location – typically <code class="highlighter-rouge">/var/lib/docker/devicemapper</code> – a thin pool is created based on two block devices, one for data and one for metadata. By default, these block devices are created automatically by using loopback mounts of automatically created sparse files. Refer to <a href="/#storage-driver-options">Storage driver options</a> below for a way how to customize this setup. <a href="http://jpetazzo.github.io/2014/01/29/docker-device-mapper-resize/" target="_blank">~jpetazzo/Resizing Docker containers with the Device Mapper plugin</a> article explains how to tune your existing setup without the use of options.</p> <p>The <code class="highlighter-rouge">btrfs</code> driver is very fast for <code class="highlighter-rouge">docker build</code> - but like <code class="highlighter-rouge">devicemapper</code> does not share executable memory between devices. Use <code class="highlighter-rouge">dockerd -s btrfs -g /mnt/btrfs_partition</code>.</p> <p>The <code class="highlighter-rouge">zfs</code> driver is probably not as fast as <code class="highlighter-rouge">btrfs</code> but has a longer track record on stability. Thanks to <code class="highlighter-rouge">Single Copy ARC</code> shared blocks between clones will be cached only once. Use <code class="highlighter-rouge">dockerd -s zfs</code>. To select a different zfs filesystem set <code class="highlighter-rouge">zfs.fsname</code> option as described in <a href="/#storage-driver-options">Storage driver options</a>.</p> <p>The <code class="highlighter-rouge">overlay</code> is a very fast union filesystem. It is now merged in the main Linux kernel as of <a href="https://lkml.org/lkml/2014/10/26/137" target="_blank">3.18.0</a>. <code class="highlighter-rouge">overlay</code> also supports page cache sharing, this means multiple containers accessing the same file can share a single page cache entry (or entries), it makes <code class="highlighter-rouge">overlay</code> as efficient with memory as <code class="highlighter-rouge">aufs</code> driver. Call <code class="highlighter-rouge">dockerd -s overlay</code> to use it.</p> <blockquote> <p><strong>Note:</strong> As promising as <code class="highlighter-rouge">overlay</code> is, the feature is still quite young and should not be used in production. Most notably, using <code class="highlighter-rouge">overlay</code> can cause excessive inode consumption (especially as the number of images grows), as well as being incompatible with the use of RPMs.</p> </blockquote> <p>The <code class="highlighter-rouge">overlay2</code> uses the same fast union filesystem but takes advantage of <a href="https://lkml.org/lkml/2015/2/11/106" target="_blank">additional features</a> added in Linux kernel 4.0 to avoid excessive inode consumption. Call <code class="highlighter-rouge">dockerd -s overlay2</code> to use it.</p> <blockquote> <p><strong>Note:</strong> Both <code class="highlighter-rouge">overlay</code> and <code class="highlighter-rouge">overlay2</code> are currently unsupported on <code class="highlighter-rouge">btrfs</code> or any Copy on Write filesystem and should only be used over <code class="highlighter-rouge">ext4</code> partitions.</p> </blockquote> <h3 id="storage-driver-options">Storage driver options</h3> <p>Particular storage-driver can be configured with options specified with <code class="highlighter-rouge">--storage-opt</code> flags. Options for <code class="highlighter-rouge">devicemapper</code> are prefixed with <code class="highlighter-rouge">dm</code>, options for <code class="highlighter-rouge">zfs</code> start with <code class="highlighter-rouge">zfs</code> and options for <code class="highlighter-rouge">btrfs</code> start with <code class="highlighter-rouge">btrfs</code>.</p> <h4 id="devicemapper-options">Devicemapper options</h4> <ul> <li> <p><code class="highlighter-rouge">dm.thinpooldev</code></p> <p>Specifies a custom block storage device to use for the thin pool.</p> <p>If using a block device for device mapper storage, it is best to use <code class="highlighter-rouge">lvm</code> to create and manage the thin-pool volume. This volume is then handed to Docker to exclusively create snapshot volumes needed for images and containers.</p> <p>Managing the thin-pool outside of Engine makes for the most feature-rich method of having Docker utilize device mapper thin provisioning as the backing storage for Docker containers. The highlights of the lvm-based thin-pool management feature include: automatic or interactive thin-pool resize support, dynamically changing thin-pool features, automatic thinp metadata checking when lvm activates the thin-pool, etc.</p> <p>As a fallback if no thin pool is provided, loopback files are created. Loopback is very slow, but can be used without any pre-configuration of storage. It is strongly recommended that you do not use loopback in production. Ensure your Engine daemon has a <code class="highlighter-rouge">--storage-opt dm.thinpooldev</code> argument provided.</p> <p>Example use:</p> <pre class="highlight" data-language="bash">$ sudo dockerd --storage-opt dm.thinpooldev=/dev/mapper/thin-pool
</pre>  </li> <li> <p><code class="highlighter-rouge">dm.basesize</code></p> <p>Specifies the size to use when creating the base device, which limits the size of images and containers. The default value is 10G. Note, thin devices are inherently “sparse”, so a 10G device which is mostly empty doesn’t use 10 GB of space on the pool. However, the filesystem will use more space for the empty case the larger the device is.</p> <p>The base device size can be increased at daemon restart which will allow all future images and containers (based on those new images) to be of the new base device size.</p> <p>Example use:</p> <pre class="highlight" data-language="bash">$ sudo dockerd --storage-opt dm.basesize=50G
</pre>  <p>This will increase the base device size to 50G. The Docker daemon will throw an error if existing base device size is larger than 50G. A user can use this option to expand the base device size however shrinking is not permitted.</p> <p>This value affects the system-wide “base” empty filesystem that may already be initialized and inherited by pulled images. Typically, a change to this value requires additional steps to take effect:</p> <p><code class="highlighter-rouge">bash $ sudo service docker stop $ sudo rm -rf /var/lib/docker $ sudo service docker start</code></p> <p>Example use:</p> <pre class="highlight" data-language="bash">$ sudo dockerd --storage-opt dm.basesize=20G
</pre>  </li> <li> <p><code class="highlighter-rouge">dm.loopdatasize</code></p> <blockquote> <p><strong>Note</strong>: This option configures devicemapper loopback, which should not be used in production.</p> </blockquote> <p>Specifies the size to use when creating the loopback file for the “data” device which is used for the thin pool. The default size is 100G. The file is sparse, so it will not initially take up this much space.</p> <p>Example use:</p> <pre class="highlight" data-language="bash">$ sudo dockerd --storage-opt dm.loopdatasize=200G
</pre>  </li> <li> <p><code class="highlighter-rouge">dm.loopmetadatasize</code></p> <blockquote> <p><strong>Note</strong>: This option configures devicemapper loopback, which should not be used in production.</p> </blockquote> <p>Specifies the size to use when creating the loopback file for the “metadata” device which is used for the thin pool. The default size is 2G. The file is sparse, so it will not initially take up this much space.</p> <p>Example use:</p> <pre class="highlight" data-language="bash">$ sudo dockerd --storage-opt dm.loopmetadatasize=4G
</pre>  </li> <li> <p><code class="highlighter-rouge">dm.fs</code></p> <p>Specifies the filesystem type to use for the base device. The supported options are “ext4” and “xfs”. The default is “xfs”</p> <p>Example use:</p> <pre class="highlight" data-language="bash">$ sudo dockerd --storage-opt dm.fs=ext4
</pre>  </li> <li> <p><code class="highlighter-rouge">dm.mkfsarg</code></p> <p>Specifies extra mkfs arguments to be used when creating the base device.</p> <p>Example use:</p> <pre class="highlight" data-language="bash">$ sudo dockerd --storage-opt "dm.mkfsarg=-O ^has_journal"
</pre>  </li> <li> <p><code class="highlighter-rouge">dm.mountopt</code></p> <p>Specifies extra mount options used when mounting the thin devices.</p> <p>Example use:</p> <pre class="highlight" data-language="bash">$ sudo dockerd --storage-opt dm.mountopt=nodiscard
</pre>  </li> <li> <p><code class="highlighter-rouge">dm.datadev</code></p> <p>(Deprecated, use <code class="highlighter-rouge">dm.thinpooldev</code>)</p> <p>Specifies a custom blockdevice to use for data for the thin pool.</p> <p>If using a block device for device mapper storage, ideally both datadev and metadatadev should be specified to completely avoid using the loopback device.</p> <p>Example use:</p> <pre class="highlight" data-language="bash">$ sudo dockerd \
      --storage-opt dm.datadev=/dev/sdb1 \
      --storage-opt dm.metadatadev=/dev/sdc1
</pre>  </li> <li> <p><code class="highlighter-rouge">dm.metadatadev</code></p> <p>(Deprecated, use <code class="highlighter-rouge">dm.thinpooldev</code>)</p> <p>Specifies a custom blockdevice to use for metadata for the thin pool.</p> <p>For best performance the metadata should be on a different spindle than the data, or even better on an SSD.</p> <p>If setting up a new metadata pool it is required to be valid. This can be achieved by zeroing the first 4k to indicate empty metadata, like this:</p> <pre class="highlight" data-language="bash">$ dd if=/dev/zero of=$metadata_dev bs=4096 count=1
</pre>  <p>Example use:</p> <pre class="highlight" data-language="bash">$ sudo dockerd \
      --storage-opt dm.datadev=/dev/sdb1 \
      --storage-opt dm.metadatadev=/dev/sdc1
</pre>  </li> <li> <p><code class="highlighter-rouge">dm.blocksize</code></p> <p>Specifies a custom blocksize to use for the thin pool. The default blocksize is 64K.</p> <p>Example use:</p> <pre class="highlight" data-language="bash">$ sudo dockerd --storage-opt dm.blocksize=512K
</pre>  </li> <li> <p><code class="highlighter-rouge">dm.blkdiscard</code></p> <p>Enables or disables the use of blkdiscard when removing devicemapper devices. This is enabled by default (only) if using loopback devices and is required to resparsify the loopback file on image/container removal.</p> <p>Disabling this on loopback can lead to <em>much</em> faster container removal times, but will make the space used in <code class="highlighter-rouge">/var/lib/docker</code> directory not be returned to the system for other use when containers are removed.</p> <p>Example use:</p> <pre class="highlight" data-language="bash">$ sudo dockerd --storage-opt dm.blkdiscard=false
</pre>  </li> <li> <p><code class="highlighter-rouge">dm.override_udev_sync_check</code></p> <p>Overrides the <code class="highlighter-rouge">udev</code> synchronization checks between <code class="highlighter-rouge">devicemapper</code> and <code class="highlighter-rouge">udev</code>. <code class="highlighter-rouge">udev</code> is the device manager for the Linux kernel.</p> <p>To view the <code class="highlighter-rouge">udev</code> sync support of a Docker daemon that is using the <code class="highlighter-rouge">devicemapper</code> driver, run:</p> <pre class="highlight" data-language="bash">$ docker info
[...]
Udev Sync Supported: true
[...]
</pre>  <p>When <code class="highlighter-rouge">udev</code> sync support is <code class="highlighter-rouge">true</code>, then <code class="highlighter-rouge">devicemapper</code> and udev can coordinate the activation and deactivation of devices for containers.</p> <p>When <code class="highlighter-rouge">udev</code> sync support is <code class="highlighter-rouge">false</code>, a race condition occurs between the<code class="highlighter-rouge">devicemapper</code> and <code class="highlighter-rouge">udev</code> during create and cleanup. The race condition results in errors and failures. (For information on these failures, see <a href="https://github.com/docker/docker/issues/4036" target="_blank">docker#4036</a>)</p> <p>To allow the <code class="highlighter-rouge">docker</code> daemon to start, regardless of <code class="highlighter-rouge">udev</code> sync not being supported, set <code class="highlighter-rouge">dm.override_udev_sync_check</code> to true:</p> <pre class="highlight" data-language="bash">$ sudo dockerd --storage-opt dm.override_udev_sync_check=true
</pre>  <p>When this value is <code class="highlighter-rouge">true</code>, the <code class="highlighter-rouge">devicemapper</code> continues and simply warns you the errors are happening.</p> <blockquote> <p><strong>Note:</strong> The ideal is to pursue a <code class="highlighter-rouge">docker</code> daemon and environment that does support synchronizing with <code class="highlighter-rouge">udev</code>. For further discussion on this topic, see <a href="https://github.com/docker/docker/issues/4036" target="_blank">docker#4036</a>. Otherwise, set this flag for migrating existing Docker daemons to a daemon with a supported environment.</p> </blockquote> </li> <li> <p><code class="highlighter-rouge">dm.use_deferred_removal</code></p> <p>Enables use of deferred device removal if <code class="highlighter-rouge">libdm</code> and the kernel driver support the mechanism.</p> <p>Deferred device removal means that if device is busy when devices are being removed/deactivated, then a deferred removal is scheduled on device. And devices automatically go away when last user of the device exits.</p> <p>For example, when a container exits, its associated thin device is removed. If that device has leaked into some other mount namespace and can’t be removed, the container exit still succeeds and this option causes the system to schedule the device for deferred removal. It does not wait in a loop trying to remove a busy device.</p> <p>Example use:</p> <pre class="highlight" data-language="bash">$ sudo dockerd --storage-opt dm.use_deferred_removal=true
</pre>  </li> <li> <p><code class="highlighter-rouge">dm.use_deferred_deletion</code></p> <p>Enables use of deferred device deletion for thin pool devices. By default, thin pool device deletion is synchronous. Before a container is deleted, the Docker daemon removes any associated devices. If the storage driver can not remove a device, the container deletion fails and daemon returns.</p> <pre class="highlight" data-language="">Error deleting container: Error response from daemon: Cannot destroy container
</pre>  <p>To avoid this failure, enable both deferred device deletion and deferred device removal on the daemon.</p> <pre class="highlight" data-language="bash">$ sudo dockerd \
      --storage-opt dm.use_deferred_deletion=true \
      --storage-opt dm.use_deferred_removal=true
</pre>  <p>With these two options enabled, if a device is busy when the driver is deleting a container, the driver marks the device as deleted. Later, when the device isn’t in use, the driver deletes it.</p> <p>In general it should be safe to enable this option by default. It will help when unintentional leaking of mount point happens across multiple mount namespaces.</p> </li> <li> <p><code class="highlighter-rouge">dm.min_free_space</code></p> <p>Specifies the min free space percent in a thin pool require for new device creation to succeed. This check applies to both free data space as well as free metadata space. Valid values are from 0% - 99%. Value 0% disables free space checking logic. If user does not specify a value for this option, the Engine uses a default value of 10%.</p> <p>Whenever a new a thin pool device is created (during <code class="highlighter-rouge">docker pull</code> or during container creation), the Engine checks if the minimum free space is available. If sufficient space is unavailable, then device creation fails and any relevant <code class="highlighter-rouge">docker</code> operation fails.</p> <p>To recover from this error, you must create more free space in the thin pool to recover from the error. You can create free space by deleting some images and containers from the thin pool. You can also add more storage to the thin pool.</p> <p>To add more space to a LVM (logical volume management) thin pool, just add more storage to the volume group container thin pool; this should automatically resolve any errors. If your configuration uses loop devices, then stop the Engine daemon, grow the size of loop files and restart the daemon to resolve the issue.</p> <p>Example use:</p> <pre class="highlight" data-language="bash">$ sudo dockerd --storage-opt dm.min_free_space=10%
</pre>  </li> </ul> <h4 id="zfs-options">ZFS options</h4> <ul> <li> <p><code class="highlighter-rouge">zfs.fsname</code></p> <p>Set zfs filesystem under which docker will create its own datasets. By default docker will pick up the zfs filesystem where docker graph (<code class="highlighter-rouge">/var/lib/docker</code>) is located.</p> <p>Example use:</p> <pre class="highlight" data-language="bash">$ sudo dockerd -s zfs --storage-opt zfs.fsname=zroot/docker
</pre>  </li> </ul> <h4 id="btrfs-options">Btrfs options</h4> <ul> <li> <p><code class="highlighter-rouge">btrfs.min_space</code></p> <p>Specifies the minimum size to use when creating the subvolume which is used for containers. If user uses disk quota for btrfs when creating or running a container with <strong>–storage-opt size</strong> option, docker should ensure the <strong>size</strong> cannot be smaller than <strong>btrfs.min_space</strong>.</p> <p>Example use:</p> <pre class="highlight" data-language="bash">$ sudo dockerd -s btrfs --storage-opt btrfs.min_space=10G
</pre>  </li> </ul> <h4 id="overlay2-options">Overlay2 options</h4> <ul> <li> <p><code class="highlighter-rouge">overlay2.override_kernel_check</code></p> <p>Overrides the Linux kernel version check allowing overlay2. Support for specifying multiple lower directories needed by overlay2 was added to the Linux kernel in 4.0.0. However some older kernel versions may be patched to add multiple lower directory support for OverlayFS. This option should only be used after verifying this support exists in the kernel. Applying this option on a kernel without this support will cause failures on mount.</p> </li> </ul> <h2 id="docker-runtime-execution-options">Docker runtime execution options</h2> <p>The Docker daemon relies on a <a href="https://github.com/opencontainers/specs" target="_blank">OCI</a> compliant runtime (invoked via the <code class="highlighter-rouge">containerd</code> daemon) as its interface to the Linux kernel <code class="highlighter-rouge">namespaces</code>, <code class="highlighter-rouge">cgroups</code>, and <code class="highlighter-rouge">SELinux</code>.</p> <p>By default, the Docker daemon automatically starts <code class="highlighter-rouge">containerd</code>. If you want to control <code class="highlighter-rouge">containerd</code> startup, manually start <code class="highlighter-rouge">containerd</code> and pass the path to the <code class="highlighter-rouge">containerd</code> socket using the <code class="highlighter-rouge">--containerd</code> flag. For example:</p> <pre class="highlight" data-language="bash">$ sudo dockerd --containerd /var/run/dev/docker-containerd.sock
</pre>  <p>Runtimes can be registered with the daemon either via the configuration file or using the <code class="highlighter-rouge">--add-runtime</code> command line argument.</p> <p>The following is an example adding 2 runtimes via the configuration:</p> <pre class="highlight" data-language="json">"default-runtime": "runc",
"runtimes": {
	"runc": {
		"path": "runc"
	},
	"custom": {
		"path": "/usr/local/bin/my-runc-replacement",
		"runtimeArgs": [
			"--debug"
		]
	}
}
</pre>  <p>This is the same example via the command line:</p> <pre class="highlight" data-language="bash">$ sudo dockerd --add-runtime runc=runc --add-runtime custom=/usr/local/bin/my-runc-replacement
</pre>  <blockquote> <p><strong>Note</strong>: defining runtime arguments via the command line is not supported.</p> </blockquote> <h2 id="options-for-the-runtime">Options for the runtime</h2> <p>You can configure the runtime using options specified with the <code class="highlighter-rouge">--exec-opt</code> flag. All the flag’s options have the <code class="highlighter-rouge">native</code> prefix. A single <code class="highlighter-rouge">native.cgroupdriver</code> option is available.</p> <p>The <code class="highlighter-rouge">native.cgroupdriver</code> option specifies the management of the container’s cgroups. You can specify only specify <code class="highlighter-rouge">cgroupfs</code> or <code class="highlighter-rouge">systemd</code>. If you specify <code class="highlighter-rouge">systemd</code> and it is not available, the system errors out. If you omit the <code class="highlighter-rouge">native.cgroupdriver</code> option,<code class="highlighter-rouge">cgroupfs</code> is used.</p> <p>This example sets the <code class="highlighter-rouge">cgroupdriver</code> to <code class="highlighter-rouge">systemd</code>:</p> <pre class="highlight" data-language="bash">$ sudo dockerd --exec-opt native.cgroupdriver=systemd
</pre>  <p>Setting this option applies to all containers the daemon launches.</p> <p>Also Windows Container makes use of <code class="highlighter-rouge">--exec-opt</code> for special purpose. Docker user can specify default container isolation technology with this, for example:</p> <pre class="highlight" data-language="bash">$ sudo dockerd --exec-opt isolation=hyperv
</pre>  <p>Will make <code class="highlighter-rouge">hyperv</code> the default isolation technology on Windows. If no isolation value is specified on daemon start, on Windows client, the default is <code class="highlighter-rouge">hyperv</code>, and on Windows server, the default is <code class="highlighter-rouge">process</code>.</p> <h2 id="daemon-dns-options">Daemon DNS options</h2> <p>To set the DNS server for all Docker containers, use:</p> <pre class="highlight" data-language="bash">$ sudo dockerd --dns 8.8.8.8
</pre>  <p>To set the DNS search domain for all Docker containers, use:</p> <pre class="highlight" data-language="bash">$ sudo dockerd --dns-search example.com
</pre>  <h2 id="insecure-registries">Insecure registries</h2> <p>Docker considers a private registry either secure or insecure. In the rest of this section, <em>registry</em> is used for <em>private registry</em>, and <code class="highlighter-rouge">myregistry:5000</code> is a placeholder example for a private registry.</p> <p>A secure registry uses TLS and a copy of its CA certificate is placed on the Docker host at <code class="highlighter-rouge">/etc/docker/certs.d/myregistry:5000/ca.crt</code>. An insecure registry is either not using TLS (i.e., listening on plain text HTTP), or is using TLS with a CA certificate not known by the Docker daemon. The latter can happen when the certificate was not found under <code class="highlighter-rouge">/etc/docker/certs.d/myregistry:5000/</code>, or if the certificate verification failed (i.e., wrong CA).</p> <p>By default, Docker assumes all, but local (see local registries below), registries are secure. Communicating with an insecure registry is not possible if Docker assumes that registry is secure. In order to communicate with an insecure registry, the Docker daemon requires <code class="highlighter-rouge">--insecure-registry</code> in one of the following two forms:</p> <ul> <li>
<code class="highlighter-rouge">--insecure-registry myregistry:5000</code> tells the Docker daemon that myregistry:5000 should be considered insecure.</li> <li>
<code class="highlighter-rouge">--insecure-registry 10.1.0.0/16</code> tells the Docker daemon that all registries whose domain resolve to an IP address is part of the subnet described by the CIDR syntax, should be considered insecure.</li> </ul> <p>The flag can be used multiple times to allow multiple registries to be marked as insecure.</p> <p>If an insecure registry is not marked as insecure, <code class="highlighter-rouge">docker pull</code>, <code class="highlighter-rouge">docker push</code>, and <code class="highlighter-rouge">docker search</code> will result in an error message prompting the user to either secure or pass the <code class="highlighter-rouge">--insecure-registry</code> flag to the Docker daemon as described above.</p> <p>Local registries, whose IP address falls in the 127.0.0.0/8 range, are automatically marked as insecure as of Docker 1.3.2. It is not recommended to rely on this, as it may change in the future.</p> <p>Enabling <code class="highlighter-rouge">--insecure-registry</code>, i.e., allowing un-encrypted and/or untrusted communication, can be useful when running a local registry. However, because its use creates security vulnerabilities it should ONLY be enabled for testing purposes. For increased security, users should add their CA to their system’s list of trusted CAs instead of enabling <code class="highlighter-rouge">--insecure-registry</code>.</p> <h2 id="legacy-registries">Legacy Registries</h2> <p>Enabling <code class="highlighter-rouge">--disable-legacy-registry</code> forces a docker daemon to only interact with registries which support the V2 protocol. Specifically, the daemon will not attempt <code class="highlighter-rouge">push</code>, <code class="highlighter-rouge">pull</code> and <code class="highlighter-rouge">login</code> to v1 registries. The exception to this is <code class="highlighter-rouge">search</code> which can still be performed on v1 registries.</p> <h2 id="running-a-docker-daemon-behind-an-httpsproxy">Running a Docker daemon behind an HTTPS_PROXY</h2> <p>When running inside a LAN that uses an <code class="highlighter-rouge">HTTPS</code> proxy, the Docker Hub certificates will be replaced by the proxy’s certificates. These certificates need to be added to your Docker host’s configuration:</p> <ol> <li>Install the <code class="highlighter-rouge">ca-certificates</code> package for your distribution</li> <li>Ask your network admin for the proxy’s CA certificate and append them to <code class="highlighter-rouge">/etc/pki/tls/certs/ca-bundle.crt</code>
</li> <li>Then start your Docker daemon with <code class="highlighter-rouge">HTTPS_PROXY=http://username:password@proxy:port/ dockerd</code>. The <code class="highlighter-rouge">username:</code> and <code class="highlighter-rouge">password@</code> are optional - and are only needed if your proxy is set up to require authentication.</li> </ol> <p>This will only add the proxy and authentication to the Docker daemon’s requests - your <code class="highlighter-rouge">docker build</code>s and running containers will need extra configuration to use the proxy</p> <h2 id="default-ulimits">Default Ulimits</h2> <p><code class="highlighter-rouge">--default-ulimit</code> allows you to set the default <code class="highlighter-rouge">ulimit</code> options to use for all containers. It takes the same options as <code class="highlighter-rouge">--ulimit</code> for <code class="highlighter-rouge">docker run</code>. If these defaults are not set, <code class="highlighter-rouge">ulimit</code> settings will be inherited, if not set on <code class="highlighter-rouge">docker run</code>, from the Docker daemon. Any <code class="highlighter-rouge">--ulimit</code> options passed to <code class="highlighter-rouge">docker run</code> will overwrite these defaults.</p> <p>Be careful setting <code class="highlighter-rouge">nproc</code> with the <code class="highlighter-rouge">ulimit</code> flag as <code class="highlighter-rouge">nproc</code> is designed by Linux to set the maximum number of processes available to a user, not to a container. For details please check the <a href="../run/">run</a> reference.</p> <h2 id="nodes-discovery">Nodes discovery</h2> <p>The <code class="highlighter-rouge">--cluster-advertise</code> option specifies the <code class="highlighter-rouge">host:port</code> or <code class="highlighter-rouge">interface:port</code> combination that this particular daemon instance should use when advertising itself to the cluster. The daemon is reached by remote hosts through this value. If you specify an interface, make sure it includes the IP address of the actual Docker host. For Engine installation created through <code class="highlighter-rouge">docker-machine</code>, the interface is typically <code class="highlighter-rouge">eth1</code>.</p> <p>The daemon uses <a href="https://github.com/docker/libkv/" target="_blank">libkv</a> to advertise the node within the cluster. Some key-value backends support mutual TLS. To configure the client TLS settings used by the daemon can be configured using the <code class="highlighter-rouge">--cluster-store-opt</code> flag, specifying the paths to PEM encoded files. For example:</p> <pre class="highlight" data-language="bash">$ sudo dockerd \
    --cluster-advertise 192.168.1.2:2376 \
    --cluster-store etcd://192.168.1.2:2379 \
    --cluster-store-opt kv.cacertfile=/path/to/ca.pem \
    --cluster-store-opt kv.certfile=/path/to/cert.pem \
    --cluster-store-opt kv.keyfile=/path/to/key.pem
</pre>  <p>The currently supported cluster store options are:</p> <ul> <li> <p><code class="highlighter-rouge">discovery.heartbeat</code></p> <p>Specifies the heartbeat timer in seconds which is used by the daemon as a keepalive mechanism to make sure discovery module treats the node as alive in the cluster. If not configured, the default value is 20 seconds.</p> </li> <li> <p><code class="highlighter-rouge">discovery.ttl</code></p> <p>Specifies the ttl (time-to-live) in seconds which is used by the discovery module to timeout a node if a valid heartbeat is not received within the configured ttl value. If not configured, the default value is 60 seconds.</p> </li> <li> <p><code class="highlighter-rouge">kv.cacertfile</code></p> <p>Specifies the path to a local file with PEM encoded CA certificates to trust</p> </li> <li> <p><code class="highlighter-rouge">kv.certfile</code></p> <p>Specifies the path to a local file with a PEM encoded certificate. This certificate is used as the client cert for communication with the Key/Value store.</p> </li> <li> <p><code class="highlighter-rouge">kv.keyfile</code></p> <p>Specifies the path to a local file with a PEM encoded private key. This private key is used as the client key for communication with the Key/Value store.</p> </li> <li> <p><code class="highlighter-rouge">kv.path</code></p> <p>Specifies the path in the Key/Value store. If not configured, the default value is ‘docker/nodes’.</p> </li> </ul> <h2 id="access-authorization">Access authorization</h2> <p>Docker’s access authorization can be extended by authorization plugins that your organization can purchase or build themselves. You can install one or more authorization plugins when you start the Docker <code class="highlighter-rouge">daemon</code> using the <code class="highlighter-rouge">--authorization-plugin=PLUGIN_ID</code> option.</p> <pre class="highlight" data-language="bash">$ sudo dockerd --authorization-plugin=plugin1 --authorization-plugin=plugin2,...
</pre>  <p>The <code class="highlighter-rouge">PLUGIN_ID</code> value is either the plugin’s name or a path to its specification file. The plugin’s implementation determines whether you can specify a name or path. Consult with your Docker administrator to get information about the plugins available to you.</p> <p>Once a plugin is installed, requests made to the <code class="highlighter-rouge">daemon</code> through the command line or Docker’s remote API are allowed or denied by the plugin. If you have multiple plugins installed, at least one must allow the request for it to complete.</p> <p>For information about how to create an authorization plugin, see <a href="../../../extend/plugins_authorization/">authorization plugin</a> section in the Docker extend section of this documentation.</p> <h2 id="daemon-user-namespace-options">Daemon user namespace options</h2> <p>The Linux kernel <a href="http://man7.org/linux/man-pages/man7/user_namespaces.7.html" target="_blank">user namespace support</a> provides additional security by enabling a process, and therefore a container, to have a unique range of user and group IDs which are outside the traditional user and group range utilized by the host system. Potentially the most important security improvement is that, by default, container processes running as the <code class="highlighter-rouge">root</code> user will have expected administrative privilege (with some restrictions) inside the container but will effectively be mapped to an unprivileged <code class="highlighter-rouge">uid</code> on the host.</p> <p>When user namespace support is enabled, Docker creates a single daemon-wide mapping for all containers running on the same engine instance. The mappings will utilize the existing subordinate user and group ID feature available on all modern Linux distributions. The <a href="http://man7.org/linux/man-pages/man5/subuid.5.html" target="_blank"><code class="highlighter-rouge">/etc/subuid</code></a> and <a href="http://man7.org/linux/man-pages/man5/subgid.5.html" target="_blank"><code class="highlighter-rouge">/etc/subgid</code></a> files will be read for the user, and optional group, specified to the <code class="highlighter-rouge">--userns-remap</code> parameter. If you do not wish to specify your own user and/or group, you can provide <code class="highlighter-rouge">default</code> as the value to this flag, and a user will be created on your behalf and provided subordinate uid and gid ranges. This default user will be named <code class="highlighter-rouge">dockremap</code>, and entries will be created for it in <code class="highlighter-rouge">/etc/passwd</code> and <code class="highlighter-rouge">/etc/group</code> using your distro’s standard user and group creation tools.</p> <blockquote> <p><strong>Note</strong>: The single mapping per-daemon restriction is in place for now because Docker shares image layers from its local cache across all containers running on the engine instance. Since file ownership must be the same for all containers sharing the same layer content, the decision was made to map the file ownership on <code class="highlighter-rouge">docker pull</code> to the daemon’s user and group mappings so that there is no delay for running containers once the content is downloaded. This design preserves the same performance for <code class="highlighter-rouge">docker pull</code>, <code class="highlighter-rouge">docker push</code>, and container startup as users expect with user namespaces disabled.</p> </blockquote> <h3 id="starting-the-daemon-with-user-namespaces-enabled">Starting the daemon with user namespaces enabled</h3> <p>To enable user namespace support, start the daemon with the <code class="highlighter-rouge">--userns-remap</code> flag, which accepts values in the following formats:</p> <ul> <li>uid</li> <li>uid:gid</li> <li>username</li> <li>username:groupname</li> </ul> <p>If numeric IDs are provided, translation back to valid user or group names will occur so that the subordinate uid and gid information can be read, given these resources are name-based, not id-based. If the numeric ID information provided does not exist as entries in <code class="highlighter-rouge">/etc/passwd</code> or <code class="highlighter-rouge">/etc/group</code>, daemon startup will fail with an error message.</p> <blockquote> <p><strong>Note:</strong> On Fedora 22, you have to <code class="highlighter-rouge">touch</code> the <code class="highlighter-rouge">/etc/subuid</code> and <code class="highlighter-rouge">/etc/subgid</code> files to have ranges assigned when users are created. This must be done <em>before</em> the <code class="highlighter-rouge">--userns-remap</code> option is enabled. Once these files exist, the daemon can be (re)started and range assignment on user creation works properly.</p> </blockquote> <p><strong>Example: starting with default Docker user management:</strong></p> <pre class="highlight" data-language="bash">$ sudo dockerd --userns-remap=default
</pre>  <p>When <code class="highlighter-rouge">default</code> is provided, Docker will create - or find the existing - user and group named <code class="highlighter-rouge">dockremap</code>. If the user is created, and the Linux distribution has appropriate support, the <code class="highlighter-rouge">/etc/subuid</code> and <code class="highlighter-rouge">/etc/subgid</code> files will be populated with a contiguous 65536 length range of subordinate user and group IDs, starting at an offset based on prior entries in those files. For example, Ubuntu will create the following range, based on an existing user named <code class="highlighter-rouge">user1</code> already owning the first 65536 range:</p> <pre class="highlight" data-language="bash">$ cat /etc/subuid
user1:100000:65536
dockremap:165536:65536
</pre>  <p>If you have a preferred/self-managed user with subordinate ID mappings already configured, you can provide that username or uid to the <code class="highlighter-rouge">--userns-remap</code> flag. If you have a group that doesn’t match the username, you may provide the <code class="highlighter-rouge">gid</code> or group name as well; otherwise the username will be used as the group name when querying the system for the subordinate group ID range.</p> <h3 id="detailed-information-on-subuidsubgid-ranges">Detailed information on <code class="highlighter-rouge">subuid</code>/<code class="highlighter-rouge">subgid</code> ranges</h3> <p>Given potential advanced use of the subordinate ID ranges by power users, the following paragraphs define how the Docker daemon currently uses the range entries found within the subordinate range files.</p> <p>The simplest case is that only one contiguous range is defined for the provided user or group. In this case, Docker will use that entire contiguous range for the mapping of host uids and gids to the container process. This means that the first ID in the range will be the remapped root user, and the IDs above that initial ID will map host ID 1 through the end of the range.</p> <p>From the example <code class="highlighter-rouge">/etc/subuid</code> content shown above, the remapped root user would be uid 165536.</p> <p>If the system administrator has set up multiple ranges for a single user or group, the Docker daemon will read all the available ranges and use the following algorithm to create the mapping ranges:</p> <ol> <li>The range segments found for the particular user will be sorted by <em>start ID</em> ascending.</li> <li>Map segments will be created from each range in increasing value with a length matching the length of each segment. Therefore the range segment with the lowest numeric starting value will be equal to the remapped root, and continue up through host uid/gid equal to the range segment length. As an example, if the lowest segment starts at ID 1000 and has a length of 100, then a map of 1000 -&gt; 0 (the remapped root) up through 1100 -&gt; 100 will be created from this segment. If the next segment starts at ID 10000, then the next map will start with mapping 10000 -&gt; 101 up to the length of this second segment. This will continue until no more segments are found in the subordinate files for this user.</li> <li>If more than five range segments exist for a single user, only the first five will be utilized, matching the kernel’s limitation of only five entries in <code class="highlighter-rouge">/proc/self/uid_map</code> and <code class="highlighter-rouge">proc/self/gid_map</code>.</li> </ol> <h3 id="disable-user-namespace-for-a-container">Disable user namespace for a container</h3> <p>If you enable user namespaces on the daemon, all containers are started with user namespaces enabled. In some situations you might want to disable this feature for a container, for example, to start a privileged container (see <a href="/#user-namespace-known-restrictions">user namespace known restrictions</a>). To enable those advanced features for a specific container use <code class="highlighter-rouge">--userns=host</code> in the <code class="highlighter-rouge">run/exec/create</code> command. This option will completely disable user namespace mapping for the container’s user.</p> <h3 id="user-namespace-known-restrictions">User namespace known restrictions</h3> <p>The following standard Docker features are currently incompatible when running a Docker daemon with user namespaces enabled:</p> <ul> <li>sharing PID or NET namespaces with the host (<code class="highlighter-rouge">--pid=host</code> or <code class="highlighter-rouge">--network=host</code>)</li> <li>A <code class="highlighter-rouge">--read-only</code> container filesystem (this is a Linux kernel restriction against remounting with modified flags of a currently mounted filesystem when inside a user namespace)</li> <li>external (volume or graph) drivers which are unaware/incapable of using daemon user mappings</li> <li>Using <code class="highlighter-rouge">--privileged</code> mode flag on <code class="highlighter-rouge">docker run</code> (unless also specifying <code class="highlighter-rouge">--userns=host</code>)</li> </ul> <p>In general, user namespaces are an advanced feature and will require coordination with other capabilities. For example, if volumes are mounted from the host, file ownership will have to be pre-arranged if the user or administrator wishes the containers to have expected access to the volume contents.</p> <p>Finally, while the <code class="highlighter-rouge">root</code> user inside a user namespaced container process has many of the expected admin privileges that go along with being the superuser, the Linux kernel has restrictions based on internal knowledge that this is a user namespaced process. The most notable restriction that we are aware of at this time is the inability to use <code class="highlighter-rouge">mknod</code>. Permission will be denied for device creation even as container <code class="highlighter-rouge">root</code> inside a user namespace.</p> <h2 id="miscellaneous-options">Miscellaneous options</h2> <p>IP masquerading uses address translation to allow containers without a public IP to talk to other machines on the Internet. This may interfere with some network topologies and can be disabled with <code class="highlighter-rouge">--ip-masq=false</code>.</p> <p>Docker supports softlinks for the Docker data directory (<code class="highlighter-rouge">/var/lib/docker</code>) and for <code class="highlighter-rouge">/var/lib/docker/tmp</code>. The <code class="highlighter-rouge">DOCKER_TMPDIR</code> and the data directory can be set like this:</p> <pre class="highlight" data-language="">DOCKER_TMPDIR=/mnt/disk2/tmp /usr/local/bin/dockerd -D -g /var/lib/docker -H unix:// &gt; /var/lib/docker-machine/docker.log 2&gt;&amp;1
# or
export DOCKER_TMPDIR=/mnt/disk2/tmp
/usr/local/bin/dockerd -D -g /var/lib/docker -H unix:// &gt; /var/lib/docker-machine/docker.log 2&gt;&amp;1
</pre>  <h2 id="default-cgroup-parent">Default cgroup parent</h2> <p>The <code class="highlighter-rouge">--cgroup-parent</code> option allows you to set the default cgroup parent to use for containers. If this option is not set, it defaults to <code class="highlighter-rouge">/docker</code> for fs cgroup driver and <code class="highlighter-rouge">system.slice</code> for systemd cgroup driver.</p> <p>If the cgroup has a leading forward slash (<code class="highlighter-rouge">/</code>), the cgroup is created under the root cgroup, otherwise the cgroup is created under the daemon cgroup.</p> <p>Assuming the daemon is running in cgroup <code class="highlighter-rouge">daemoncgroup</code>, <code class="highlighter-rouge">--cgroup-parent=/foobar</code> creates a cgroup in <code class="highlighter-rouge">/sys/fs/cgroup/memory/foobar</code>, whereas using <code class="highlighter-rouge">--cgroup-parent=foobar</code> creates the cgroup in <code class="highlighter-rouge">/sys/fs/cgroup/memory/daemoncgroup/foobar</code></p> <p>The systemd cgroup driver has different rules for <code class="highlighter-rouge">--cgroup-parent</code>. Systemd represents hierarchy by slice and the name of the slice encodes the location in the tree. So <code class="highlighter-rouge">--cgroup-parent</code> for systemd cgroups should be a slice name. A name can consist of a dash-separated series of names, which describes the path to the slice from the root slice. For example, <code class="highlighter-rouge">--cgroup-parent=user-a-b.slice</code> means the memory cgroup for the container is created in <code class="highlighter-rouge">/sys/fs/cgroup/memory/user.slice/user-a.slice/user-a-b.slice/docker-&lt;id&gt;.scope</code>.</p> <p>This setting can also be set per container, using the <code class="highlighter-rouge">--cgroup-parent</code> option on <code class="highlighter-rouge">docker create</code> and <code class="highlighter-rouge">docker run</code>, and takes precedence over the <code class="highlighter-rouge">--cgroup-parent</code> option on the daemon.</p> <h2 id="daemon-configuration-file">Daemon configuration file</h2> <p>The <code class="highlighter-rouge">--config-file</code> option allows you to set any configuration option for the daemon in a JSON format. This file uses the same flag names as keys, except for flags that allow several entries, where it uses the plural of the flag name, e.g., <code class="highlighter-rouge">labels</code> for the <code class="highlighter-rouge">label</code> flag.</p> <p>The options set in the configuration file must not conflict with options set via flags. The docker daemon fails to start if an option is duplicated between the file and the flags, regardless their value. We do this to avoid silently ignore changes introduced in configuration reloads. For example, the daemon fails to start if you set daemon labels in the configuration file and also set daemon labels via the <code class="highlighter-rouge">--label</code> flag. Options that are not present in the file are ignored when the daemon starts.</p> <h3 id="linux-configuration-file">Linux configuration file</h3> <p>The default location of the configuration file on Linux is <code class="highlighter-rouge">/etc/docker/daemon.json</code>. The <code class="highlighter-rouge">--config-file</code> flag can be used to specify a non-default location.</p> <p>This is a full example of the allowed configuration options on Linux:</p> <pre class="highlight" data-language="json">{
    "api-cors-header": "",
    "authorization-plugins": [],
    "bip": "",
    "bridge": "",
    "cgroup-parent": "",
    "cluster-store": "",
    "cluster-store-opts": {},
    "cluster-advertise": "",
    "debug": true,
    "default-gateway": "",
    "default-gateway-v6": "",
    "default-runtime": "runc",
    "default-ulimits": {},
    "disable-legacy-registry": false,
    "dns": [],
    "dns-opts": [],
    "dns-search": [],
    "exec-opts": [],
    "exec-root": "",
    "fixed-cidr": "",
    "fixed-cidr-v6": "",
    "graph": "",
    "group": "",
    "hosts": [],
    "icc": false,
    "insecure-registries": [],
    "ip": "0.0.0.0",
    "iptables": false,
    "ipv6": false,
    "ip-forward": false,
    "ip-masq": false,
    "labels": [],
    "live-restore": true,
    "log-driver": "",
    "log-level": "",
    "log-opts": {},
    "max-concurrent-downloads": 3,
    "max-concurrent-uploads": 5,
    "mtu": 0,
    "oom-score-adjust": -500,
    "pidfile": "",
    "raw-logs": false,
    "registry-mirrors": [],
    "runtimes": {
        "runc": {
            "path": "runc"
        },
        "custom": {
            "path": "/usr/local/bin/my-runc-replacement",
            "runtimeArgs": [
                "--debug"
            ]
        }
    },
    "selinux-enabled": false,
    "storage-driver": "",
    "storage-opts": [],
    "swarm-default-advertise-addr": "",
    "tls": true,
    "tlscacert": "",
    "tlscert": "",
    "tlskey": "",
    "tlsverify": true,
    "userland-proxy": false,
    "userns-remap": ""
}
</pre>  <h3 id="windows-configuration-file">Windows configuration file</h3> <p>The default location of the configuration file on Windows is <code class="highlighter-rouge">%programdata%\docker\config\daemon.json</code>. The <code class="highlighter-rouge">--config-file</code> flag can be used to specify a non-default location.</p> <p>This is a full example of the allowed configuration options on Windows:</p> <pre class="highlight" data-language="json">{
    "authorization-plugins": [],
    "bridge": "",
    "cluster-advertise": "",
    "cluster-store": "",
    "debug": true,
    "default-ulimits": {},
    "disable-legacy-registry": false,
    "dns": [],
    "dns-opts": [],
    "dns-search": [],
    "exec-opts": [],
    "fixed-cidr": "",
    "graph": "",
    "group": "",
    "hosts": [],
    "insecure-registries": [],
    "labels": [],
    "live-restore": true,
    "log-driver": "",
    "log-level": "",
    "mtu": 0,
    "pidfile": "",
    "raw-logs": false,
    "registry-mirrors": [],
    "storage-driver": "",
    "storage-opts": [],
    "swarm-default-advertise-addr": "",
    "tlscacert": "",
    "tlscert": "",
    "tlskey": "",
    "tlsverify": true
}
</pre>  <h3 id="configuration-reloading">Configuration reloading</h3> <p>Some options can be reconfigured when the daemon is running without requiring to restart the process. We use the <code class="highlighter-rouge">SIGHUP</code> signal in Linux to reload, and a global event in Windows with the key <code class="highlighter-rouge">Global\docker-daemon-config-$PID</code>. The options can be modified in the configuration file but still will check for conflicts with the provided flags. The daemon fails to reconfigure itself if there are conflicts, but it won’t stop execution.</p> <p>The list of currently supported options that can be reconfigured is this:</p> <ul> <li>
<code class="highlighter-rouge">debug</code>: it changes the daemon to debug mode when set to true.</li> <li>
<code class="highlighter-rouge">cluster-store</code>: it reloads the discovery store with the new address.</li> <li>
<code class="highlighter-rouge">cluster-store-opts</code>: it uses the new options to reload the discovery store.</li> <li>
<code class="highlighter-rouge">cluster-advertise</code>: it modifies the address advertised after reloading.</li> <li>
<code class="highlighter-rouge">labels</code>: it replaces the daemon labels with a new set of labels.</li> <li>
<code class="highlighter-rouge">live-restore</code>: Enables <a href="../../../admin/live-restore/">keeping containers alive during daemon downtime</a>.</li> <li>
<code class="highlighter-rouge">max-concurrent-downloads</code>: it updates the max concurrent downloads for each pull.</li> <li>
<code class="highlighter-rouge">max-concurrent-uploads</code>: it updates the max concurrent uploads for each push.</li> <li>
<code class="highlighter-rouge">default-runtime</code>: it updates the runtime to be used if not is specified at container creation. It defaults to “default” which is the runtime shipped with the official docker packages.</li> <li>
<code class="highlighter-rouge">runtimes</code>: it updates the list of available OCI runtimes that can be used to run containers</li> </ul> <p>Updating and reloading the cluster configurations such as <code class="highlighter-rouge">--cluster-store</code>, <code class="highlighter-rouge">--cluster-advertise</code> and <code class="highlighter-rouge">--cluster-store-opts</code> will take effect only if these configurations were not previously configured. If <code class="highlighter-rouge">--cluster-store</code> has been provided in flags and <code class="highlighter-rouge">cluster-advertise</code> not, <code class="highlighter-rouge">cluster-advertise</code> can be added in the configuration file without accompanied by <code class="highlighter-rouge">--cluster-store</code> Configuration reload will log a warning message if it detects a change in previously configured cluster configurations.</p> <h2 id="running-multiple-daemons">Running multiple daemons</h2> <blockquote> <p><strong>Note:</strong> Running multiple daemons on a single host is considered as “experimental”. The user should be aware of unsolved problems. This solution may not work properly in some cases. Solutions are currently under development and will be delivered in the near future.</p> </blockquote> <p>This section describes how to run multiple Docker daemons on a single host. To run multiple daemons, you must configure each daemon so that it does not conflict with other daemons on the same host. You can set these options either by providing them as flags, or by using a <a href="/#daemon-configuration-file">daemon configuration file</a>.</p> <p>The following daemon options must be configured for each daemon:</p> <pre class="highlight" data-language="bash">-b, --bridge=                          Attach containers to a network bridge
--exec-root=/var/run/docker            Root of the Docker execdriver
-g, --graph=/var/lib/docker            Root of the Docker runtime
-p, --pidfile=/var/run/docker.pid      Path to use for daemon PID file
-H, --host=[]                          Daemon socket(s) to connect to
--iptables=true                        Enable addition of iptables rules
--config-file=/etc/docker/daemon.json  Daemon configuration file
--tlscacert="~/.docker/ca.pem"         Trust certs signed only by this CA
--tlscert="~/.docker/cert.pem"         Path to TLS certificate file
--tlskey="~/.docker/key.pem"           Path to TLS key file
</pre>  <p>When your daemons use different values for these flags, you can run them on the same host without any problems. It is very important to properly understand the meaning of those options and to use them correctly.</p> <ul> <li>The <code class="highlighter-rouge">-b, --bridge=</code> flag is set to <code class="highlighter-rouge">docker0</code> as default bridge network. It is created automatically when you install Docker. If you are not using the default, you must create and configure the bridge manually or just set it to ‘none’: <code class="highlighter-rouge">--bridge=none</code>
</li> <li>
<code class="highlighter-rouge">--exec-root</code> is the path where the container state is stored. The default value is <code class="highlighter-rouge">/var/run/docker</code>. Specify the path for your running daemon here.</li> <li>
<code class="highlighter-rouge">--graph</code> is the path where images are stored. The default value is <code class="highlighter-rouge">/var/lib/docker</code>. To avoid any conflict with other daemons set this parameter separately for each daemon.</li> <li>
<code class="highlighter-rouge">-p, --pidfile=/var/run/docker.pid</code> is the path where the process ID of the daemon is stored. Specify the path for your pid file here.</li> <li>
<code class="highlighter-rouge">--host=[]</code> specifies where the Docker daemon will listen for client connections. If unspecified, it defaults to <code class="highlighter-rouge">/var/run/docker.sock</code>.</li> <li>
<code class="highlighter-rouge">--iptables=false</code> prevents the Docker daemon from adding iptables rules. If multiple daemons manage iptables rules, they may overwrite rules set by another daemon. Be aware that disabling this option requires you to manually add iptables rules to expose container ports. If you prevent Docker from adding iptables rules, Docker will also not add IP masquerading rules, even if you set <code class="highlighter-rouge">--ip-masq</code> to <code class="highlighter-rouge">true</code>. Without IP masquerading rules, Docker containers will not be able to connect to external hosts or the internet when using network other than default bridge.</li> <li>
<code class="highlighter-rouge">--config-file=/etc/docker/daemon.json</code> is the path where configuration file is stored. You can use it instead of daemon flags. Specify the path for each daemon.</li> <li>
<code class="highlighter-rouge">--tls*</code> Docker daemon supports <code class="highlighter-rouge">--tlsverify</code> mode that enforces encrypted and authenticated remote connections. The <code class="highlighter-rouge">--tls*</code> options enable use of specific certificates for individual daemons.</li> </ul> <p>Example script for a separate “bootstrap” instance of the Docker daemon without network:</p> <pre class="highlight" data-language="bash">$ sudo dockerd \
        -H unix:///var/run/docker-bootstrap.sock \
        -p /var/run/docker-bootstrap.pid \
        --iptables=false \
        --ip-masq=false \
        --bridge=none \
        --graph=/var/lib/docker-bootstrap \
        --exec-root=/var/run/docker-bootstrap
</pre>
<div class="_attribution">
  <p class="_attribution-p">
    © 2013–2016 Docker, Inc.<br>Licensed under the Apache License, Version 2.0.<br>Docker and the Docker logo are trademarks or registered trademarks of Docker, Inc. in the United States and/or other countries.<br>Docker, Inc. and other parties may also have trademark rights in other terms used herein.<br>
    <a href="https://docs.docker.com/engine/reference/commandline/dockerd/" class="_attribution-link" target="_blank">https://docs.docker.com/engine/reference/commandline/dockerd/</a>
  </p>
</div>

			</div>
		</div>
	</section>

	</div>
</body>
</html>
