
<!DOCTYPE HTML>

<html lang="en">

<head>
  <meta charset="utf-8">
  <title>Tasks and Coroutines - Python 3.6 - W3cubDocs</title>
  
  <meta name="description" content="Coroutines used with asyncio may be implemented using the async def statement, or by using generators. The async def type of coroutine was added in &hellip;">
  <meta name="keywords" content="tasks, and, coroutines, -, python, python~3.6">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="http://docs.w3cub.com/python~3.6/library/asyncio-task/">
  <link href="/favicon.png" rel="icon">
  <link type="text/css" rel="stylesheet" href="/assets/application-50364fff564ce3b6327021805f3f00e2957b441cf27f576a7dd4ff63bbc47047.css">
  <script type="text/javascript" src="/assets/application-db64bfd54ceb42be11af7995804cf4902548419ceb79d509b0b7d62c22d98e6f.js"></script>
  <script src="/json/python~3.6.js"></script>
  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-71174418-1']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>


</head>

<body>
	<div class="_app">
	<header class="_header">
  
  <form class="_search">
    <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
    <a class="_search-clear"></a>
    <div class="_search-tag"></div>
  </form>
  
  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/python~3.6/" class="_nav-link" title="" style="margin-left:0;">Python 3.6</a></span>
  
  <nav class="_nav">
    <a href="/app/" class="_nav-link ">App</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		<div class="_list">
			
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<div class="_page _sphinx">
				
<h1 id="tasks-and-coroutines"> Tasks and coroutines</h1>  <h2 id="coroutine">1. Coroutines</h2> <p id="coroutines">Coroutines used with <a class="reference internal" href="../asyncio/#module-asyncio" title="asyncio: Asynchronous I/O, event loop, coroutines and tasks."><code>asyncio</code></a> may be implemented using the <a class="reference internal" href="https://docs.python.org/3.6/reference/compound_stmts.html#async-def" target="_blank"><code>async def</code></a> statement, or by using <a class="reference internal" href="https://docs.python.org/3.6/glossary.html#term-generator" target="_blank"><span class="xref std std-term">generators</span></a>. The <a class="reference internal" href="https://docs.python.org/3.6/reference/compound_stmts.html#async-def" target="_blank"><code>async def</code></a> type of coroutine was added in Python 3.5, and is recommended if there is no need to support older Python versions.</p> <p>Generator-based coroutines should be decorated with <a class="reference internal" href="#asyncio.coroutine" title="asyncio.coroutine"><code>@asyncio.coroutine</code></a>, although this is not strictly enforced. The decorator enables compatibility with <a class="reference internal" href="https://docs.python.org/3.6/reference/compound_stmts.html#async-def" target="_blank"><code>async def</code></a> coroutines, and also serves as documentation. Generator-based coroutines use the <code>yield from</code> syntax introduced in <a class="pep reference external" href="https://www.python.org/dev/peps/pep-0380" id="index-0" target="_blank"><strong>PEP 380</strong></a>, instead of the original <code>yield</code> syntax.</p> <p>The word “coroutine”, like the word “generator”, is used for two different (though related) concepts:</p> <ul class="simple"> <li>The function that defines a coroutine (a function definition using <a class="reference internal" href="https://docs.python.org/3.6/reference/compound_stmts.html#async-def" target="_blank"><code>async def</code></a> or decorated with <code>@asyncio.coroutine</code>). If disambiguation is needed we will call this a <em>coroutine function</em> (<a class="reference internal" href="#asyncio.iscoroutinefunction" title="asyncio.iscoroutinefunction"><code>iscoroutinefunction()</code></a> returns <code>True</code>).</li> <li>The object obtained by calling a coroutine function. This object represents a computation or an I/O operation (usually a combination) that will complete eventually. If disambiguation is needed we will call it a <em>coroutine object</em> (<a class="reference internal" href="#asyncio.iscoroutine" title="asyncio.iscoroutine"><code>iscoroutine()</code></a> returns <code>True</code>).</li> </ul> <p>Things a coroutine can do:</p> <ul class="simple"> <li>
<code>result = await future</code> or <code>result = yield from future</code> – suspends the coroutine until the future is done, then returns the future’s result, or raises an exception, which will be propagated. (If the future is cancelled, it will raise a <code>CancelledError</code> exception.) Note that tasks are futures, and everything said about futures also applies to tasks.</li> <li>
<code>result = await coroutine</code> or <code>result = yield from coroutine</code> – wait for another coroutine to produce a result (or raise an exception, which will be propagated). The <code>coroutine</code> expression must be a <em>call</em> to another coroutine.</li> <li>
<code>return expression</code> – produce a result to the coroutine that is waiting for this one using <a class="reference internal" href="https://docs.python.org/3.6/reference/expressions.html#await" target="_blank"><code>await</code></a> or <code>yield from</code>.</li> <li>
<code>raise exception</code> – raise an exception in the coroutine that is waiting for this one using <a class="reference internal" href="https://docs.python.org/3.6/reference/expressions.html#await" target="_blank"><code>await</code></a> or <code>yield from</code>.</li> </ul> <p>Calling a coroutine does not start its code running – the coroutine object returned by the call doesn’t do anything until you schedule its execution. There are two basic ways to start it running: call <code>await coroutine</code> or <code>yield from coroutine</code> from another coroutine (assuming the other coroutine is already running!), or schedule its execution using the <a class="reference internal" href="#asyncio.ensure_future" title="asyncio.ensure_future"><code>ensure_future()</code></a> function or the <a class="reference internal" href="../asyncio-eventloop/#asyncio.AbstractEventLoop.create_task" title="asyncio.AbstractEventLoop.create_task"><code>AbstractEventLoop.create_task()</code></a> method.</p> <p>Coroutines (and tasks) can only run when the event loop is running.</p> <dl class="function"> <dt id="asyncio.coroutine">
<code>@asyncio.coroutine</code> </dt> <dd>
<p>Decorator to mark generator-based coroutines. This enables the generator use <code>yield from</code> to call <a class="reference internal" href="https://docs.python.org/3.6/reference/compound_stmts.html#async-def" target="_blank"><code>async
def</code></a> coroutines, and also enables the generator to be called by <a class="reference internal" href="https://docs.python.org/3.6/reference/compound_stmts.html#async-def" target="_blank"><code>async def</code></a> coroutines, for instance using an <a class="reference internal" href="https://docs.python.org/3.6/reference/expressions.html#await" target="_blank"><code>await</code></a> expression.</p> <p>There is no need to decorate <a class="reference internal" href="https://docs.python.org/3.6/reference/compound_stmts.html#async-def" target="_blank"><code>async def</code></a> coroutines themselves.</p> <p>If the generator is not yielded from before it is destroyed, an error message is logged. See <a class="reference internal" href="../asyncio-dev/#asyncio-coroutine-not-scheduled"><span>Detect coroutines never scheduled</span></a>.</p> </dd>
</dl> <div class="admonition note"> <p class="first admonition-title">Note</p> <p class="last">In this documentation, some methods are documented as coroutines, even if they are plain Python functions returning a <a class="reference internal" href="#asyncio.Future" title="asyncio.Future"><code>Future</code></a>. This is intentional to have a freedom of tweaking the implementation of these functions in the future. If such a function is needed to be used in a callback-style code, wrap its result with <a class="reference internal" href="#asyncio.ensure_future" title="asyncio.ensure_future"><code>ensure_future()</code></a>.</p> </div>  <h3 id="asyncio-hello-world-coroutine">1.1. Example: Hello World coroutine</h3> <p id="example-hello-world-coroutine">Example of coroutine displaying <code>"Hello World"</code>:</p> <pre data-language="python">import asyncio

async def hello_world():
    print("Hello World!")

loop = asyncio.get_event_loop()
# Blocking call which returns when the hello_world() coroutine is done
loop.run_until_complete(hello_world())
loop.close()
</pre> <div class="admonition seealso"> <p class="first admonition-title">See also</p> <p class="last">The <a class="reference internal" href="../asyncio-eventloop/#asyncio-hello-world-callback"><span>Hello World with call_soon()</span></a> example uses the <a class="reference internal" href="../asyncio-eventloop/#asyncio.AbstractEventLoop.call_soon" title="asyncio.AbstractEventLoop.call_soon"><code>AbstractEventLoop.call_soon()</code></a> method to schedule a callback.</p> </div>   <h3 id="asyncio-date-coroutine">1.2. Example: Coroutine displaying the current date</h3> <p id="example-coroutine-displaying-the-current-date">Example of coroutine displaying the current date every second during 5 seconds using the <a class="reference internal" href="#asyncio.sleep" title="asyncio.sleep"><code>sleep()</code></a> function:</p> <pre data-language="python">import asyncio
import datetime

async def display_date(loop):
    end_time = loop.time() + 5.0
    while True:
        print(datetime.datetime.now())
        if (loop.time() + 1.0) &gt;= end_time:
            break
        await asyncio.sleep(1)

loop = asyncio.get_event_loop()
# Blocking call which returns when the display_date() coroutine is done
loop.run_until_complete(display_date(loop))
loop.close()
</pre> <div class="admonition seealso"> <p class="first admonition-title">See also</p> <p class="last">The <a class="reference internal" href="../asyncio-eventloop/#asyncio-date-callback"><span>display the current date with call_later()</span></a> example uses a callback with the <a class="reference internal" href="../asyncio-eventloop/#asyncio.AbstractEventLoop.call_later" title="asyncio.AbstractEventLoop.call_later"><code>AbstractEventLoop.call_later()</code></a> method.</p> </div>   <h3 id="example-chain-coroutines">1.3. Example: Chain coroutines</h3> <p>Example chaining coroutines:</p> <pre data-language="python">import asyncio

async def compute(x, y):
    print("Compute %s + %s ..." % (x, y))
    await asyncio.sleep(1.0)
    return x + y

async def print_sum(x, y):
    result = await compute(x, y)
    print("%s + %s = %s" % (x, y, result))

loop = asyncio.get_event_loop()
loop.run_until_complete(print_sum(1, 2))
loop.close()
</pre> <p><code>compute()</code> is chained to <code>print_sum()</code>: <code>print_sum()</code> coroutine waits until <code>compute()</code> is completed before returning its result.</p> <p>Sequence diagram of the example:</p> <img alt="../_images/tulip_coro.png" class="align-center" src="https://docs.python.org/3.6/_images/tulip_coro.png"> <p>The “Task” is created by the <a class="reference internal" href="../asyncio-eventloop/#asyncio.AbstractEventLoop.run_until_complete" title="asyncio.AbstractEventLoop.run_until_complete"><code>AbstractEventLoop.run_until_complete()</code></a> method when it gets a coroutine object instead of a task.</p> <p>The diagram shows the control flow, it does not describe exactly how things work internally. For example, the sleep coroutine creates an internal future which uses <a class="reference internal" href="../asyncio-eventloop/#asyncio.AbstractEventLoop.call_later" title="asyncio.AbstractEventLoop.call_later"><code>AbstractEventLoop.call_later()</code></a> to wake up the task in 1 second.</p>    <h2 id="invalidstateerror">2. InvalidStateError</h2> <dl class="exception"> <dt id="asyncio.InvalidStateError">
<code>exception asyncio.InvalidStateError</code> </dt> <dd>
<p>The operation is not allowed in this state.</p> </dd>
</dl>   <h2 id="timeouterror">3. TimeoutError</h2> <dl class="exception"> <dt id="asyncio.TimeoutError">
<code>exception asyncio.TimeoutError</code> </dt> <dd>
<p>The operation exceeded the given deadline.</p> </dd>
</dl> <div class="admonition note"> <p class="first admonition-title">Note</p> <p class="last">This exception is different from the builtin <a class="reference internal" href="../exceptions/#TimeoutError" title="TimeoutError"><code>TimeoutError</code></a> exception!</p> </div>   <h2 id="future">4. Future</h2> <dl class="class"> <dt id="asyncio.Future">
<code>class asyncio.Future(*, loop=None)</code> </dt> <dd>
<p>This class is <em>almost</em> compatible with <a class="reference internal" href="../concurrent.futures/#concurrent.futures.Future" title="concurrent.futures.Future"><code>concurrent.futures.Future</code></a>.</p> <p>Differences:</p> <ul class="simple"> <li>
<a class="reference internal" href="#asyncio.Future.result" title="asyncio.Future.result"><code>result()</code></a> and <a class="reference internal" href="#asyncio.Future.exception" title="asyncio.Future.exception"><code>exception()</code></a> do not take a timeout argument and raise an exception when the future isn’t done yet.</li> <li>Callbacks registered with <a class="reference internal" href="#asyncio.Future.add_done_callback" title="asyncio.Future.add_done_callback"><code>add_done_callback()</code></a> are always called via the event loop’s <a class="reference internal" href="../asyncio-eventloop/#asyncio.AbstractEventLoop.call_soon_threadsafe" title="asyncio.AbstractEventLoop.call_soon_threadsafe"><code>call_soon_threadsafe()</code></a>.</li> <li>This class is not compatible with the <a class="reference internal" href="../concurrent.futures/#concurrent.futures.wait" title="concurrent.futures.wait"><code>wait()</code></a> and <a class="reference internal" href="../concurrent.futures/#concurrent.futures.as_completed" title="concurrent.futures.as_completed"><code>as_completed()</code></a> functions in the <a class="reference internal" href="../concurrent.futures/#module-concurrent.futures" title="concurrent.futures: Execute computations concurrently using threads or processes."><code>concurrent.futures</code></a> package.</li> </ul> <p>This class is <a class="reference internal" href="../asyncio-dev/#asyncio-multithreading"><span>not thread safe</span></a>.</p> <dl class="method"> <dt id="asyncio.Future.cancel">
<code>cancel()</code> </dt> <dd>
<p>Cancel the future and schedule callbacks.</p> <p>If the future is already done or cancelled, return <code>False</code>. Otherwise, change the future’s state to cancelled, schedule the callbacks and return <code>True</code>.</p> </dd>
</dl> <dl class="method"> <dt id="asyncio.Future.cancelled">
<code>cancelled()</code> </dt> <dd>
<p>Return <code>True</code> if the future was cancelled.</p> </dd>
</dl> <dl class="method"> <dt id="asyncio.Future.done">
<code>done()</code> </dt> <dd>
<p>Return <code>True</code> if the future is done.</p> <p>Done means either that a result / exception are available, or that the future was cancelled.</p> </dd>
</dl> <dl class="method"> <dt id="asyncio.Future.result">
<code>result()</code> </dt> <dd>
<p>Return the result this future represents.</p> <p>If the future has been cancelled, raises <code>CancelledError</code>. If the future’s result isn’t yet available, raises <a class="reference internal" href="#asyncio.InvalidStateError" title="asyncio.InvalidStateError"><code>InvalidStateError</code></a>. If the future is done and has an exception set, this exception is raised.</p> </dd>
</dl> <dl class="method"> <dt id="asyncio.Future.exception">
<code>exception()</code> </dt> <dd>
<p>Return the exception that was set on this future.</p> <p>The exception (or <code>None</code> if no exception was set) is returned only if the future is done. If the future has been cancelled, raises <code>CancelledError</code>. If the future isn’t done yet, raises <a class="reference internal" href="#asyncio.InvalidStateError" title="asyncio.InvalidStateError"><code>InvalidStateError</code></a>.</p> </dd>
</dl> <dl class="method"> <dt id="asyncio.Future.add_done_callback">
<code>add_done_callback(fn)</code> </dt> <dd>
<p>Add a callback to be run when the future becomes done.</p> <p>The callback is called with a single argument - the future object. If the future is already done when this is called, the callback is scheduled with <a class="reference internal" href="../asyncio-eventloop/#asyncio.AbstractEventLoop.call_soon" title="asyncio.AbstractEventLoop.call_soon"><code>call_soon()</code></a>.</p> <p><a class="reference internal" href="../asyncio-eventloop/#asyncio-pass-keywords"><span>Use functools.partial to pass parameters to the callback</span></a>. For example, <code>fut.add_done_callback(functools.partial(print, "Future:",
flush=True))</code> will call <code>print("Future:", fut, flush=True)</code>.</p> </dd>
</dl> <dl class="method"> <dt id="asyncio.Future.remove_done_callback">
<code>remove_done_callback(fn)</code> </dt> <dd>
<p>Remove all instances of a callback from the “call when done” list.</p> <p>Returns the number of callbacks removed.</p> </dd>
</dl> <dl class="method"> <dt id="asyncio.Future.set_result">
<code>set_result(result)</code> </dt> <dd>
<p>Mark the future done and set its result.</p> <p>If the future is already done when this method is called, raises <a class="reference internal" href="#asyncio.InvalidStateError" title="asyncio.InvalidStateError"><code>InvalidStateError</code></a>.</p> </dd>
</dl> <dl class="method"> <dt id="asyncio.Future.set_exception">
<code>set_exception(exception)</code> </dt> <dd>
<p>Mark the future done and set an exception.</p> <p>If the future is already done when this method is called, raises <a class="reference internal" href="#asyncio.InvalidStateError" title="asyncio.InvalidStateError"><code>InvalidStateError</code></a>.</p> </dd>
</dl> </dd>
</dl>  <h3 id="example-future-with-run-until-complete">4.1. Example: Future with run_until_complete()</h3> <p>Example combining a <a class="reference internal" href="#asyncio.Future" title="asyncio.Future"><code>Future</code></a> and a <a class="reference internal" href="#coroutine"><span>coroutine function</span></a>:</p> <pre data-language="python">import asyncio

async def slow_operation(future):
    await asyncio.sleep(1)
    future.set_result('Future is done!')

loop = asyncio.get_event_loop()
future = asyncio.Future()
asyncio.ensure_future(slow_operation(future))
loop.run_until_complete(future)
print(future.result())
loop.close()
</pre> <p>The coroutine function is responsible for the computation (which takes 1 second) and it stores the result into the future. The <a class="reference internal" href="../asyncio-eventloop/#asyncio.AbstractEventLoop.run_until_complete" title="asyncio.AbstractEventLoop.run_until_complete"><code>run_until_complete()</code></a> method waits for the completion of the future.</p> <div class="admonition note"> <p class="first admonition-title">Note</p> <p class="last">The <a class="reference internal" href="../asyncio-eventloop/#asyncio.AbstractEventLoop.run_until_complete" title="asyncio.AbstractEventLoop.run_until_complete"><code>run_until_complete()</code></a> method uses internally the <a class="reference internal" href="#asyncio.Future.add_done_callback" title="asyncio.Future.add_done_callback"><code>add_done_callback()</code></a> method to be notified when the future is done.</p> </div>   <h3 id="example-future-with-run-forever">4.2. Example: Future with run_forever()</h3> <p>The previous example can be written differently using the <a class="reference internal" href="#asyncio.Future.add_done_callback" title="asyncio.Future.add_done_callback"><code>Future.add_done_callback()</code></a> method to describe explicitly the control flow:</p> <pre data-language="python">import asyncio

async def slow_operation(future):
    await asyncio.sleep(1)
    future.set_result('Future is done!')

def got_result(future):
    print(future.result())
    loop.stop()

loop = asyncio.get_event_loop()
future = asyncio.Future()
asyncio.ensure_future(slow_operation(future))
future.add_done_callback(got_result)
try:
    loop.run_forever()
finally:
    loop.close()
</pre> <p>In this example, the future is used to link <code>slow_operation()</code> to <code>got_result()</code>: when <code>slow_operation()</code> is done, <code>got_result()</code> is called with the result.</p>    <h2 id="task">5. Task</h2> <dl class="class"> <dt id="asyncio.Task">
<code>class asyncio.Task(coro, *, loop=None)</code> </dt> <dd>
<p>Schedule the execution of a <a class="reference internal" href="#coroutine"><span>coroutine</span></a>: wrap it in a future. A task is a subclass of <a class="reference internal" href="#asyncio.Future" title="asyncio.Future"><code>Future</code></a>.</p> <p>A task is responsible for executing a coroutine object in an event loop. If the wrapped coroutine yields from a future, the task suspends the execution of the wrapped coroutine and waits for the completion of the future. When the future is done, the execution of the wrapped coroutine restarts with the result or the exception of the future.</p> <p>Event loops use cooperative scheduling: an event loop only runs one task at a time. Other tasks may run in parallel if other event loops are running in different threads. While a task waits for the completion of a future, the event loop executes a new task.</p> <p>The cancellation of a task is different from the cancelation of a future. Calling <a class="reference internal" href="#asyncio.Task.cancel" title="asyncio.Task.cancel"><code>cancel()</code></a> will throw a <a class="reference internal" href="../concurrent.futures/#concurrent.futures.CancelledError" title="concurrent.futures.CancelledError"><code>CancelledError</code></a> to the wrapped coroutine. <a class="reference internal" href="#asyncio.Future.cancelled" title="asyncio.Future.cancelled"><code>cancelled()</code></a> only returns <code>True</code> if the wrapped coroutine did not catch the <a class="reference internal" href="../concurrent.futures/#concurrent.futures.CancelledError" title="concurrent.futures.CancelledError"><code>CancelledError</code></a> exception, or raised a <a class="reference internal" href="../concurrent.futures/#concurrent.futures.CancelledError" title="concurrent.futures.CancelledError"><code>CancelledError</code></a> exception.</p> <p>If a pending task is destroyed, the execution of its wrapped <a class="reference internal" href="#coroutine"><span>coroutine</span></a> did not complete. It is probably a bug and a warning is logged: see <a class="reference internal" href="../asyncio-dev/#asyncio-pending-task-destroyed"><span>Pending task destroyed</span></a>.</p> <p>Don’t directly create <a class="reference internal" href="#asyncio.Task" title="asyncio.Task"><code>Task</code></a> instances: use the <a class="reference internal" href="#asyncio.ensure_future" title="asyncio.ensure_future"><code>ensure_future()</code></a> function or the <a class="reference internal" href="../asyncio-eventloop/#asyncio.AbstractEventLoop.create_task" title="asyncio.AbstractEventLoop.create_task"><code>AbstractEventLoop.create_task()</code></a> method.</p> <p>This class is <a class="reference internal" href="../asyncio-dev/#asyncio-multithreading"><span>not thread safe</span></a>.</p> <dl class="classmethod"> <dt id="asyncio.Task.all_tasks">
<code>classmethod all_tasks(loop=None)</code> </dt> <dd>
<p>Return a set of all tasks for an event loop.</p> <p>By default all tasks for the current event loop are returned.</p> </dd>
</dl> <dl class="classmethod"> <dt id="asyncio.Task.current_task">
<code>classmethod current_task(loop=None)</code> </dt> <dd>
<p>Return the currently running task in an event loop or <code>None</code>.</p> <p>By default the current task for the current event loop is returned.</p> <p><code>None</code> is returned when called not in the context of a <a class="reference internal" href="#asyncio.Task" title="asyncio.Task"><code>Task</code></a>.</p> </dd>
</dl> <dl class="method"> <dt id="asyncio.Task.cancel">
<code>cancel()</code> </dt> <dd>
<p>Request that this task cancel itself.</p> <p>This arranges for a <a class="reference internal" href="../concurrent.futures/#concurrent.futures.CancelledError" title="concurrent.futures.CancelledError"><code>CancelledError</code></a> to be thrown into the wrapped coroutine on the next cycle through the event loop. The coroutine then has a chance to clean up or even deny the request using try/except/finally.</p> <p>Unlike <a class="reference internal" href="#asyncio.Future.cancel" title="asyncio.Future.cancel"><code>Future.cancel()</code></a>, this does not guarantee that the task will be cancelled: the exception might be caught and acted upon, delaying cancellation of the task or preventing cancellation completely. The task may also return a value or raise a different exception.</p> <p>Immediately after this method is called, <a class="reference internal" href="#asyncio.Future.cancelled" title="asyncio.Future.cancelled"><code>cancelled()</code></a> will not return <code>True</code> (unless the task was already cancelled). A task will be marked as cancelled when the wrapped coroutine terminates with a <a class="reference internal" href="../concurrent.futures/#concurrent.futures.CancelledError" title="concurrent.futures.CancelledError"><code>CancelledError</code></a> exception (even if <a class="reference internal" href="#asyncio.Task.cancel" title="asyncio.Task.cancel"><code>cancel()</code></a> was not called).</p> </dd>
</dl> <dl class="method"> <dt id="asyncio.Task.get_stack">
<code>get_stack(*, limit=None)</code> </dt> <dd>
<p>Return the list of stack frames for this task’s coroutine.</p> <p>If the coroutine is not done, this returns the stack where it is suspended. If the coroutine has completed successfully or was cancelled, this returns an empty list. If the coroutine was terminated by an exception, this returns the list of traceback frames.</p> <p>The frames are always ordered from oldest to newest.</p> <p>The optional limit gives the maximum number of frames to return; by default all available frames are returned. Its meaning differs depending on whether a stack or a traceback is returned: the newest frames of a stack are returned, but the oldest frames of a traceback are returned. (This matches the behavior of the traceback module.)</p> <p>For reasons beyond our control, only one stack frame is returned for a suspended coroutine.</p> </dd>
</dl> <dl class="method"> <dt id="asyncio.Task.print_stack">
<code>print_stack(*, limit=None, file=None)</code> </dt> <dd>
<p>Print the stack or traceback for this task’s coroutine.</p> <p>This produces output similar to that of the traceback module, for the frames retrieved by get_stack(). The limit argument is passed to get_stack(). The file argument is an I/O stream to which the output is written; by default output is written to sys.stderr.</p> </dd>
</dl> </dd>
</dl>  <h3 id="example-parallel-execution-of-tasks">5.1. Example: Parallel execution of tasks</h3> <p>Example executing 3 tasks (A, B, C) in parallel:</p> <pre data-language="python">import asyncio

async def factorial(name, number):
    f = 1
    for i in range(2, number+1):
        print("Task %s: Compute factorial(%s)..." % (name, i))
        await asyncio.sleep(1)
        f *= i
    print("Task %s: factorial(%s) = %s" % (name, number, f))

loop = asyncio.get_event_loop()
loop.run_until_complete(asyncio.gather(
    factorial("A", 2),
    factorial("B", 3),
    factorial("C", 4),
))
loop.close()
</pre> <p>Output:</p> <pre data-language="python">Task A: Compute factorial(2)...
Task B: Compute factorial(2)...
Task C: Compute factorial(2)...
Task A: factorial(2) = 2
Task B: Compute factorial(3)...
Task C: Compute factorial(3)...
Task B: factorial(3) = 6
Task C: Compute factorial(4)...
Task C: factorial(4) = 24
</pre> <p>A task is automatically scheduled for execution when it is created. The event loop stops when all tasks are done.</p>    <h2 id="task-functions">6. Task functions</h2> <div class="admonition note"> <p class="first admonition-title">Note</p> <p class="last">In the functions below, the optional <em>loop</em> argument allows explicitly setting the event loop object used by the underlying task or coroutine. If it’s not provided, the default event loop is used.</p> </div> <dl class="function"> <dt id="asyncio.as_completed">
<code>asyncio.as_completed(fs, *, loop=None, timeout=None)</code> </dt> <dd>
<p>Return an iterator whose values, when waited for, are <a class="reference internal" href="#asyncio.Future" title="asyncio.Future"><code>Future</code></a> instances.</p> <p>Raises <a class="reference internal" href="#asyncio.TimeoutError" title="asyncio.TimeoutError"><code>asyncio.TimeoutError</code></a> if the timeout occurs before all Futures are done.</p> <p>Example:</p> <pre data-language="python">for f in as_completed(fs):
    result = yield from f  # The 'yield from' may raise
    # Use result
</pre> <div class="admonition note"> <p class="first admonition-title">Note</p> <p class="last">The futures <code>f</code> are not necessarily members of fs.</p> </div> </dd>
</dl> <dl class="function"> <dt id="asyncio.ensure_future">
<code>asyncio.ensure_future(coro_or_future, *, loop=None)</code> </dt> <dd>
<p>Schedule the execution of a <a class="reference internal" href="#coroutine"><span>coroutine object</span></a>: wrap it in a future. Return a <a class="reference internal" href="#asyncio.Task" title="asyncio.Task"><code>Task</code></a> object.</p> <p>If the argument is a <a class="reference internal" href="#asyncio.Future" title="asyncio.Future"><code>Future</code></a>, it is returned directly.</p> <div class="versionadded"> <p><span class="versionmodified">New in version 3.4.4.</span></p> </div> <div class="versionchanged"> <p><span class="versionmodified">Changed in version 3.5.1: </span>The function accepts any <a class="reference internal" href="https://docs.python.org/3.6/glossary.html#term-awaitable" target="_blank"><span class="xref std std-term">awaitable</span></a> object.</p> </div> <div class="admonition seealso"> <p class="first admonition-title">See also</p> <p class="last">The <a class="reference internal" href="../asyncio-eventloop/#asyncio.AbstractEventLoop.create_task" title="asyncio.AbstractEventLoop.create_task"><code>AbstractEventLoop.create_task()</code></a> method.</p> </div> </dd>
</dl> <dl class="function"> <dt id="asyncio.async">
<code>asyncio.async(coro_or_future, *, loop=None)</code> </dt> <dd>
<p>A deprecated alias to <a class="reference internal" href="#asyncio.ensure_future" title="asyncio.ensure_future"><code>ensure_future()</code></a>.</p> <div class="deprecated"> <p><span class="versionmodified">Deprecated since version 3.4.4.</span></p> </div> </dd>
</dl> <dl class="function"> <dt id="asyncio.gather">
<code>asyncio.gather(*coros_or_futures, loop=None, return_exceptions=False)</code> </dt> <dd>
<p>Return a future aggregating results from the given coroutine objects or futures.</p> <p>All futures must share the same event loop. If all the tasks are done successfully, the returned future’s result is the list of results (in the order of the original sequence, not necessarily the order of results arrival). If <em>return_exceptions</em> is true, exceptions in the tasks are treated the same as successful results, and gathered in the result list; otherwise, the first raised exception will be immediately propagated to the returned future.</p> <p>Cancellation: if the outer Future is cancelled, all children (that have not completed yet) are also cancelled. If any child is cancelled, this is treated as if it raised <a class="reference internal" href="../concurrent.futures/#concurrent.futures.CancelledError" title="concurrent.futures.CancelledError"><code>CancelledError</code></a> – the outer Future is <em>not</em> cancelled in this case. (This is to prevent the cancellation of one child to cause other children to be cancelled.)</p> </dd>
</dl> <dl class="function"> <dt id="asyncio.iscoroutine">
<code>asyncio.iscoroutine(obj)</code> </dt> <dd>
<p>Return <code>True</code> if <em>obj</em> is a <a class="reference internal" href="#coroutine"><span>coroutine object</span></a>, which may be based on a generator or an <a class="reference internal" href="https://docs.python.org/3.6/reference/compound_stmts.html#async-def" target="_blank"><code>async def</code></a> coroutine.</p> </dd>
</dl> <dl class="function"> <dt id="asyncio.iscoroutinefunction">
<code>asyncio.iscoroutinefunction(func)</code> </dt> <dd>
<p>Return <code>True</code> if <em>func</em> is determined to be a <a class="reference internal" href="#coroutine"><span>coroutine function</span></a>, which may be a decorated generator function or an <a class="reference internal" href="https://docs.python.org/3.6/reference/compound_stmts.html#async-def" target="_blank"><code>async def</code></a> function.</p> </dd>
</dl> <dl class="function"> <dt id="asyncio.run_coroutine_threadsafe">
<code>asyncio.run_coroutine_threadsafe(coro, loop)</code> </dt> <dd>
<p>Submit a <a class="reference internal" href="#coroutine"><span>coroutine object</span></a> to a given event loop.</p> <p>Return a <a class="reference internal" href="../concurrent.futures/#concurrent.futures.Future" title="concurrent.futures.Future"><code>concurrent.futures.Future</code></a> to access the result.</p> <p>This function is meant to be called from a different thread than the one where the event loop is running. Usage:</p> <pre data-language="python"># Create a coroutine
coro = asyncio.sleep(1, result=3)
# Submit the coroutine to a given loop
future = asyncio.run_coroutine_threadsafe(coro, loop)
# Wait for the result with an optional timeout argument
assert future.result(timeout) == 3
</pre> <p>If an exception is raised in the coroutine, the returned future will be notified. It can also be used to cancel the task in the event loop:</p> <pre data-language="python">try:
    result = future.result(timeout)
except asyncio.TimeoutError:
    print('The coroutine took too long, cancelling the task...')
    future.cancel()
except Exception as exc:
    print('The coroutine raised an exception: {!r}'.format(exc))
else:
    print('The coroutine returned: {!r}'.format(result))
</pre> <p>See the <a class="reference internal" href="../asyncio-dev/#asyncio-multithreading"><span>concurrency and multithreading</span></a> section of the documentation.</p> <div class="admonition note"> <p class="first admonition-title">Note</p> <p class="last">Unlike other functions from the module, <a class="reference internal" href="#asyncio.run_coroutine_threadsafe" title="asyncio.run_coroutine_threadsafe"><code>run_coroutine_threadsafe()</code></a> requires the <em>loop</em> argument to be passed explicitly.</p> </div> <div class="versionadded"> <p><span class="versionmodified">New in version 3.5.1.</span></p> </div> </dd>
</dl> <dl class="function"> <dt id="asyncio.sleep">
<code>coroutine asyncio.sleep(delay, result=None, *, loop=None)</code> </dt> <dd>
<p>Create a <a class="reference internal" href="#coroutine"><span>coroutine</span></a> that completes after a given time (in seconds). If <em>result</em> is provided, it is produced to the caller when the coroutine completes.</p> <p>The resolution of the sleep depends on the <a class="reference internal" href="../asyncio-eventloop/#asyncio-delayed-calls"><span>granularity of the event loop</span></a>.</p> <p>This function is a <a class="reference internal" href="#coroutine"><span>coroutine</span></a>.</p> </dd>
</dl> <dl class="function"> <dt id="asyncio.shield">
<code>asyncio.shield(arg, *, loop=None)</code> </dt> <dd>
<p>Wait for a future, shielding it from cancellation.</p> <p>The statement:</p> <pre data-language="python">res = yield from shield(something())
</pre> <p>is exactly equivalent to the statement:</p> <pre data-language="python">res = yield from something()
</pre> <p><em>except</em> that if the coroutine containing it is cancelled, the task running in <code>something()</code> is not cancelled. From the point of view of <code>something()</code>, the cancellation did not happen. But its caller is still cancelled, so the yield-from expression still raises <a class="reference internal" href="../concurrent.futures/#concurrent.futures.CancelledError" title="concurrent.futures.CancelledError"><code>CancelledError</code></a>. Note: If <code>something()</code> is cancelled by other means this will still cancel <code>shield()</code>.</p> <p>If you want to completely ignore cancellation (not recommended) you can combine <code>shield()</code> with a try/except clause, as follows:</p> <pre data-language="python">try:
    res = yield from shield(something())
except CancelledError:
    res = None
</pre> </dd>
</dl> <dl class="function"> <dt id="asyncio.wait">
<code>coroutine asyncio.wait(futures, *, loop=None, timeout=None, return_when=ALL_COMPLETED)</code> </dt> <dd>
<p>Wait for the Futures and coroutine objects given by the sequence <em>futures</em> to complete. Coroutines will be wrapped in Tasks. Returns two sets of <a class="reference internal" href="#asyncio.Future" title="asyncio.Future"><code>Future</code></a>: (done, pending).</p> <p>The sequence <em>futures</em> must not be empty.</p> <p><em>timeout</em> can be used to control the maximum number of seconds to wait before returning. <em>timeout</em> can be an int or float. If <em>timeout</em> is not specified or <code>None</code>, there is no limit to the wait time.</p> <p><em>return_when</em> indicates when this function should return. It must be one of the following constants of the <a class="reference internal" href="../concurrent.futures/#module-concurrent.futures" title="concurrent.futures: Execute computations concurrently using threads or processes."><code>concurrent.futures</code></a> module:</p> <table class="docutils">  <thead valign="bottom"> <tr class="row-odd">
<th class="head">Constant</th> <th class="head">Description</th> </tr> </thead>  <tr class="row-even">
<td><code>FIRST_COMPLETED</code></td> <td>The function will return when any future finishes or is cancelled.</td> </tr> <tr class="row-odd">
<td><code>FIRST_EXCEPTION</code></td> <td>The function will return when any future finishes by raising an exception. If no future raises an exception then it is equivalent to <code>ALL_COMPLETED</code>.</td> </tr> <tr class="row-even">
<td><code>ALL_COMPLETED</code></td> <td>The function will return when all futures finish or are cancelled.</td> </tr>  </table> <p>This function is a <a class="reference internal" href="#coroutine"><span>coroutine</span></a>.</p> <p>Usage:</p> <pre data-language="python">done, pending = yield from asyncio.wait(fs)
</pre> <div class="admonition note"> <p class="first admonition-title">Note</p> <p class="last">This does not raise <a class="reference internal" href="#asyncio.TimeoutError" title="asyncio.TimeoutError"><code>asyncio.TimeoutError</code></a>! Futures that aren’t done when the timeout occurs are returned in the second set.</p> </div> </dd>
</dl> <dl class="function"> <dt id="asyncio.wait_for">
<code>coroutine asyncio.wait_for(fut, timeout, *, loop=None)</code> </dt> <dd>
<p>Wait for the single <a class="reference internal" href="#asyncio.Future" title="asyncio.Future"><code>Future</code></a> or <a class="reference internal" href="#coroutine"><span>coroutine object</span></a> to complete with timeout. If <em>timeout</em> is <code>None</code>, block until the future completes.</p> <p>Coroutine will be wrapped in <a class="reference internal" href="#asyncio.Task" title="asyncio.Task"><code>Task</code></a>.</p> <p>Returns result of the Future or coroutine. When a timeout occurs, it cancels the task and raises <a class="reference internal" href="#asyncio.TimeoutError" title="asyncio.TimeoutError"><code>asyncio.TimeoutError</code></a>. To avoid the task cancellation, wrap it in <a class="reference internal" href="#asyncio.shield" title="asyncio.shield"><code>shield()</code></a>.</p> <p>If the wait is cancelled, the future <em>fut</em> is also cancelled.</p> <p>This function is a <a class="reference internal" href="#coroutine"><span>coroutine</span></a>, usage:</p> <pre data-language="python">result = yield from asyncio.wait_for(fut, 60.0)
</pre> <div class="versionchanged"> <p><span class="versionmodified">Changed in version 3.4.3: </span>If the wait is cancelled, the future <em>fut</em> is now also cancelled.</p> </div> </dd>
</dl>
<div class="_attribution">
  <p class="_attribution-p">
    © 2001–2017 Python Software Foundation<br>Licensed under the PSF License.<br>
    <a href="https://docs.python.org/3.6/library/asyncio-task.html" class="_attribution-link" target="_blank">https://docs.python.org/3.6/library/asyncio-task.html</a>
  </p>
</div>

			</div>
		</div>
	</section>

	</div>
</body>
</html>
