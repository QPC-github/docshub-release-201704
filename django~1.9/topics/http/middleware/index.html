
<!DOCTYPE HTML>

<html lang="en">

<head>
  <meta charset="utf-8">
  <title>Middleware - Django 1.9 - W3cubDocs</title>
  
  <meta name="description" content="Middleware is a framework of hooks into Django’s request&#47;response processing. It’s a light, low-level “plugin” system for globally altering &hellip;">
  <meta name="keywords" content="middleware, -, django, django~1.9">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="http://docs.w3cub.com/django~1.9/topics/http/middleware/">
  <link href="/favicon.png" rel="icon">
  <link type="text/css" rel="stylesheet" href="/assets/application-50364fff564ce3b6327021805f3f00e2957b441cf27f576a7dd4ff63bbc47047.css">
  <script type="text/javascript" src="/assets/application-db64bfd54ceb42be11af7995804cf4902548419ceb79d509b0b7d62c22d98e6f.js"></script>
  <script src="/json/django~1.9.js"></script>
  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-71174418-1']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>


</head>

<body>
	<div class="_app">
	<header class="_header">
  
  <form class="_search">
    <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
    <a class="_search-clear"></a>
    <div class="_search-tag"></div>
  </form>
  
  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/django~1.9/" class="_nav-link" title="" style="margin-left:0;">Django 1.9</a></span>
  
  <nav class="_nav">
    <a href="/app/" class="_nav-link ">App</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		<div class="_list">
			
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<div class="_page _sphinx">
				
<h1 id="middleware">Middleware</h1> <p>Middleware is a framework of hooks into Django’s request/response processing. It’s a light, low-level “plugin” system for globally altering Django’s input or output.</p> <p>Each middleware component is responsible for doing some specific function. For example, Django includes a middleware component, <a class="reference internal" href="../../../ref/middleware/#django.contrib.auth.middleware.AuthenticationMiddleware" title="django.contrib.auth.middleware.AuthenticationMiddleware"><code>AuthenticationMiddleware</code></a>, that associates users with requests using sessions.</p> <p>This document explains how middleware works, how you activate middleware, and how to write your own middleware. Django ships with some built-in middleware you can use right out of the box. They’re documented in the <a class="reference internal" href="../../../ref/middleware/"><span class="doc">built-in middleware reference</span></a>.</p>  <h2 id="activating-middleware">Activating middleware</h2> <p>To activate a middleware component, add it to the <a class="reference internal" href="../../../ref/settings/#std:setting-MIDDLEWARE_CLASSES"><code>MIDDLEWARE_CLASSES</code></a> list in your Django settings.</p> <p>In <a class="reference internal" href="../../../ref/settings/#std:setting-MIDDLEWARE_CLASSES"><code>MIDDLEWARE_CLASSES</code></a>, each middleware component is represented by a string: the full Python path to the middleware’s class name. For example, here’s the default value created by <a class="reference internal" href="../../../ref/django-admin/#django-admin-startproject"><code>django-admin startproject</code></a>:</p> <pre data-language="python">MIDDLEWARE_CLASSES = [
    'django.middleware.security.SecurityMiddleware',
    'django.contrib.sessions.middleware.SessionMiddleware',
    'django.middleware.common.CommonMiddleware',
    'django.middleware.csrf.CsrfViewMiddleware',
    'django.contrib.auth.middleware.AuthenticationMiddleware',
    'django.contrib.auth.middleware.SessionAuthenticationMiddleware',
    'django.contrib.messages.middleware.MessageMiddleware',
    'django.middleware.clickjacking.XFrameOptionsMiddleware',
]
</pre> <p>A Django installation doesn’t require any middleware — <a class="reference internal" href="../../../ref/settings/#std:setting-MIDDLEWARE_CLASSES"><code>MIDDLEWARE_CLASSES</code></a> can be empty, if you’d like — but it’s strongly suggested that you at least use <a class="reference internal" href="../../../ref/middleware/#django.middleware.common.CommonMiddleware" title="django.middleware.common.CommonMiddleware"><code>CommonMiddleware</code></a>.</p> <p>The order in <a class="reference internal" href="../../../ref/settings/#std:setting-MIDDLEWARE_CLASSES"><code>MIDDLEWARE_CLASSES</code></a> matters because a middleware can depend on other middleware. For instance, <a class="reference internal" href="../../../ref/middleware/#django.contrib.auth.middleware.AuthenticationMiddleware" title="django.contrib.auth.middleware.AuthenticationMiddleware"><code>AuthenticationMiddleware</code></a> stores the authenticated user in the session; therefore, it must run after <a class="reference internal" href="../../../ref/middleware/#django.contrib.sessions.middleware.SessionMiddleware" title="django.contrib.sessions.middleware.SessionMiddleware"><code>SessionMiddleware</code></a>. See <a class="reference internal" href="../../../ref/middleware/#middleware-ordering"><span class="std std-ref">Middleware ordering</span></a> for some common hints about ordering of Django middleware classes.</p>   <h2 id="hooks-and-application-order">Hooks and application order</h2> <p>During the request phase, before calling the view, Django applies middleware in the order it’s defined in <a class="reference internal" href="../../../ref/settings/#std:setting-MIDDLEWARE_CLASSES"><code>MIDDLEWARE_CLASSES</code></a>, top-down. Two hooks are available:</p> <ul class="simple"> <li><a class="reference internal" href="#process_request" title="process_request"><code>process_request()</code></a></li> <li><a class="reference internal" href="#process_view" title="process_view"><code>process_view()</code></a></li> </ul> <p>During the response phase, after calling the view, middleware are applied in reverse order, from the bottom up. Three hooks are available:</p> <ul class="simple"> <li>
<a class="reference internal" href="#process_exception" title="process_exception"><code>process_exception()</code></a> (only if the view raised an exception)</li> <li>
<a class="reference internal" href="#process_template_response" title="process_template_response"><code>process_template_response()</code></a> (only for template responses)</li> <li><a class="reference internal" href="#process_response" title="process_response"><code>process_response()</code></a></li> </ul> <a class="reference internal image-reference" href="https://docs.djangoproject.com/en/1.9/_images/middleware.svg" target="_blank"><img alt="middleware application order" height="409" src="https://docs.djangoproject.com/en/1.9/_images/middleware.svg" width="481"></a> <p>If you prefer, you can also think of it like an onion: each middleware class is a “layer” that wraps the view.</p> <p>The behavior of each hook is described below.</p>   <h2 id="writing-your-own-middleware">Writing your own middleware</h2> <p>Writing your own middleware is easy. Each middleware component is a single Python class that defines one or more of the following methods:</p>  <h3 id="request-middleware"><code>process_request()</code></h3> <dl class="method" id="process-request"> <dt id="process_request">
<code>process_request(request)</code> </dt> 
</dl> <p><code>request</code> is an <a class="reference internal" href="../../../ref/request-response/#django.http.HttpRequest" title="django.http.HttpRequest"><code>HttpRequest</code></a> object.</p> <p><code>process_request()</code> is called on each request, before Django decides which view to execute.</p> <p>It should return either <code>None</code> or an <a class="reference internal" href="../../../ref/request-response/#django.http.HttpResponse" title="django.http.HttpResponse"><code>HttpResponse</code></a> object. If it returns <code>None</code>, Django will continue processing this request, executing any other <code>process_request()</code> middleware, then, <code>process_view()</code> middleware, and finally, the appropriate view. If it returns an <a class="reference internal" href="../../../ref/request-response/#django.http.HttpResponse" title="django.http.HttpResponse"><code>HttpResponse</code></a> object, Django won’t bother calling any other request, view or exception middleware, or the appropriate view; it’ll apply response middleware to that <a class="reference internal" href="../../../ref/request-response/#django.http.HttpResponse" title="django.http.HttpResponse"><code>HttpResponse</code></a>, and return the result.</p>   <h3 id="view-middleware"><code>process_view()</code></h3> <dl class="method" id="process-view"> <dt id="process_view">
<code>process_view(request, view_func, view_args, view_kwargs)</code> </dt> 
</dl> <p><code>request</code> is an <a class="reference internal" href="../../../ref/request-response/#django.http.HttpRequest" title="django.http.HttpRequest"><code>HttpRequest</code></a> object. <code>view_func</code> is the Python function that Django is about to use. (It’s the actual function object, not the name of the function as a string.) <code>view_args</code> is a list of positional arguments that will be passed to the view, and <code>view_kwargs</code> is a dictionary of keyword arguments that will be passed to the view. Neither <code>view_args</code> nor <code>view_kwargs</code> include the first view argument (<code>request</code>).</p> <p><code>process_view()</code> is called just before Django calls the view.</p> <p>It should return either <code>None</code> or an <a class="reference internal" href="../../../ref/request-response/#django.http.HttpResponse" title="django.http.HttpResponse"><code>HttpResponse</code></a> object. If it returns <code>None</code>, Django will continue processing this request, executing any other <code>process_view()</code> middleware and, then, the appropriate view. If it returns an <a class="reference internal" href="../../../ref/request-response/#django.http.HttpResponse" title="django.http.HttpResponse"><code>HttpResponse</code></a> object, Django won’t bother calling any other view or exception middleware, or the appropriate view; it’ll apply response middleware to that <a class="reference internal" href="../../../ref/request-response/#django.http.HttpResponse" title="django.http.HttpResponse"><code>HttpResponse</code></a>, and return the result.</p> <div class="admonition note"> <p class="first admonition-title">Note</p> <p>Accessing <a class="reference internal" href="../../../ref/request-response/#django.http.HttpRequest.POST" title="django.http.HttpRequest.POST"><code>request.POST</code></a> inside middleware from <code>process_request</code> or <code>process_view</code> will prevent any view running after the middleware from being able to <a class="reference internal" href="../file-uploads/#modifying-upload-handlers-on-the-fly"><span class="std std-ref">modify the upload handlers for the request</span></a>, and should normally be avoided.</p> <p class="last">The <a class="reference internal" href="../../../ref/middleware/#django.middleware.csrf.CsrfViewMiddleware" title="django.middleware.csrf.CsrfViewMiddleware"><code>CsrfViewMiddleware</code></a> class can be considered an exception, as it provides the <a class="reference internal" href="../../../ref/csrf/#django.views.decorators.csrf.csrf_exempt" title="django.views.decorators.csrf.csrf_exempt"><code>csrf_exempt()</code></a> and <a class="reference internal" href="../../../ref/csrf/#django.views.decorators.csrf.csrf_protect" title="django.views.decorators.csrf.csrf_protect"><code>csrf_protect()</code></a> decorators which allow views to explicitly control at what point the CSRF validation should occur.</p> </div>   <h3 id="template-response-middleware"><code>process_template_response()</code></h3> <dl class="method" id="process-template-response"> <dt id="process_template_response">
<code>process_template_response(request, response)</code> </dt> 
</dl> <p><code>request</code> is an <a class="reference internal" href="../../../ref/request-response/#django.http.HttpRequest" title="django.http.HttpRequest"><code>HttpRequest</code></a> object. <code>response</code> is the <a class="reference internal" href="../../../ref/template-response/#django.template.response.TemplateResponse" title="django.template.response.TemplateResponse"><code>TemplateResponse</code></a> object (or equivalent) returned by a Django view or by a middleware.</p> <p><code>process_template_response()</code> is called just after the view has finished executing, if the response instance has a <code>render()</code> method, indicating that it is a <a class="reference internal" href="../../../ref/template-response/#django.template.response.TemplateResponse" title="django.template.response.TemplateResponse"><code>TemplateResponse</code></a> or equivalent.</p> <p>It must return a response object that implements a <code>render</code> method. It could alter the given <code>response</code> by changing <code>response.template_name</code> and <code>response.context_data</code>, or it could create and return a brand-new <a class="reference internal" href="../../../ref/template-response/#django.template.response.TemplateResponse" title="django.template.response.TemplateResponse"><code>TemplateResponse</code></a> or equivalent.</p> <p>You don’t need to explicitly render responses – responses will be automatically rendered once all template response middleware has been called.</p> <p>Middleware are run in reverse order during the response phase, which includes <code>process_template_response()</code>.</p>   <h3 id="response-middleware"><code>process_response()</code></h3> <dl class="method" id="process-response"> <dt id="process_response">
<code>process_response(request, response)</code> </dt> 
</dl> <p><code>request</code> is an <a class="reference internal" href="../../../ref/request-response/#django.http.HttpRequest" title="django.http.HttpRequest"><code>HttpRequest</code></a> object. <code>response</code> is the <a class="reference internal" href="../../../ref/request-response/#django.http.HttpResponse" title="django.http.HttpResponse"><code>HttpResponse</code></a> or <a class="reference internal" href="../../../ref/request-response/#django.http.StreamingHttpResponse" title="django.http.StreamingHttpResponse"><code>StreamingHttpResponse</code></a> object returned by a Django view or by a middleware.</p> <p><code>process_response()</code> is called on all responses before they’re returned to the browser.</p> <p>It must return an <a class="reference internal" href="../../../ref/request-response/#django.http.HttpResponse" title="django.http.HttpResponse"><code>HttpResponse</code></a> or <a class="reference internal" href="../../../ref/request-response/#django.http.StreamingHttpResponse" title="django.http.StreamingHttpResponse"><code>StreamingHttpResponse</code></a> object. It could alter the given <code>response</code>, or it could create and return a brand-new <a class="reference internal" href="../../../ref/request-response/#django.http.HttpResponse" title="django.http.HttpResponse"><code>HttpResponse</code></a> or <a class="reference internal" href="../../../ref/request-response/#django.http.StreamingHttpResponse" title="django.http.StreamingHttpResponse"><code>StreamingHttpResponse</code></a>.</p> <p>Unlike the <code>process_request()</code> and <code>process_view()</code> methods, the <code>process_response()</code> method is always called, even if the <code>process_request()</code> and <code>process_view()</code> methods of the same middleware class were skipped (because an earlier middleware method returned an <a class="reference internal" href="../../../ref/request-response/#django.http.HttpResponse" title="django.http.HttpResponse"><code>HttpResponse</code></a>). In particular, this means that your <code>process_response()</code> method cannot rely on setup done in <code>process_request()</code>.</p> <p>Finally, remember that during the response phase, middleware are applied in reverse order, from the bottom up. This means classes defined at the end of <a class="reference internal" href="../../../ref/settings/#std:setting-MIDDLEWARE_CLASSES"><code>MIDDLEWARE_CLASSES</code></a> will be run first.</p>  <h4 id="dealing-with-streaming-responses">Dealing with streaming responses</h4> <p>Unlike <a class="reference internal" href="../../../ref/request-response/#django.http.HttpResponse" title="django.http.HttpResponse"><code>HttpResponse</code></a>, <a class="reference internal" href="../../../ref/request-response/#django.http.StreamingHttpResponse" title="django.http.StreamingHttpResponse"><code>StreamingHttpResponse</code></a> does not have a <code>content</code> attribute. As a result, middleware can no longer assume that all responses will have a <code>content</code> attribute. If they need access to the content, they must test for streaming responses and adjust their behavior accordingly:</p> <pre data-language="python">if response.streaming:
    response.streaming_content = wrap_streaming_content(response.streaming_content)
else:
    response.content = alter_content(response.content)
</pre> <div class="admonition note"> <p class="first admonition-title">Note</p> <p><code>streaming_content</code> should be assumed to be too large to hold in memory. Response middleware may wrap it in a new generator, but must not consume it. Wrapping is typically implemented as follows:</p> <pre data-language="python">def wrap_streaming_content(content):
    for chunk in content:
        yield alter_content(chunk)
</pre> </div>    <h3 id="exception-middleware"><code>process_exception()</code></h3> <dl class="method" id="process-exception"> <dt id="process_exception">
<code>process_exception(request, exception)</code> </dt> 
</dl> <p><code>request</code> is an <a class="reference internal" href="../../../ref/request-response/#django.http.HttpRequest" title="django.http.HttpRequest"><code>HttpRequest</code></a> object. <code>exception</code> is an <code>Exception</code> object raised by the view function.</p> <p>Django calls <code>process_exception()</code> when a view raises an exception. <code>process_exception()</code> should return either <code>None</code> or an <a class="reference internal" href="../../../ref/request-response/#django.http.HttpResponse" title="django.http.HttpResponse"><code>HttpResponse</code></a> object. If it returns an <a class="reference internal" href="../../../ref/request-response/#django.http.HttpResponse" title="django.http.HttpResponse"><code>HttpResponse</code></a> object, the template response and response middleware will be applied, and the resulting response returned to the browser. Otherwise, default exception handling kicks in.</p> <p>Again, middleware are run in reverse order during the response phase, which includes <code>process_exception</code>. If an exception middleware returns a response, the middleware classes above that middleware will not be called at all.</p>   <h3 id="init"><code>__init__()</code></h3> <p>Most middleware classes won’t need an initializer since middleware classes are essentially placeholders for the <code>process_*</code> methods. If you do need some global state you may use <code>__init__</code> to set up. However, keep in mind a couple of caveats:</p> <ul class="simple"> <li>Django initializes your middleware without any arguments, so you can’t define <code>__init__</code> as requiring any arguments.</li> <li>Unlike the <code>process_*</code> methods which get called once per request, <code>__init__</code> gets called only <em>once</em>, when the Web server responds to the first request.</li> </ul>  <h4 id="marking-middleware-as-unused">Marking middleware as unused</h4> <p>It’s sometimes useful to determine at run-time whether a piece of middleware should be used. In these cases, your middleware’s <code>__init__</code> method may raise <a class="reference internal" href="../../../ref/exceptions/#django.core.exceptions.MiddlewareNotUsed" title="django.core.exceptions.MiddlewareNotUsed"><code>django.core.exceptions.MiddlewareNotUsed</code></a>. Django will then remove that piece of middleware from the middleware process and a debug message will be logged to the <code>django.request</code> logger when <a class="reference internal" href="../../../ref/settings/#std:setting-DEBUG"><code>DEBUG</code></a> is set to <code>True</code>.</p> <div class="versionchanged"> <p>Previously, <a class="reference internal" href="../../../ref/exceptions/#django.core.exceptions.MiddlewareNotUsed" title="django.core.exceptions.MiddlewareNotUsed"><code>MiddlewareNotUsed</code></a> exceptions weren’t logged.</p> </div>    <h3 id="guidelines">Guidelines</h3> <ul class="simple"> <li>Middleware classes don’t have to subclass anything.</li> <li>The middleware class can live anywhere on your Python path. All Django cares about is that the <a class="reference internal" href="../../../ref/settings/#std:setting-MIDDLEWARE_CLASSES"><code>MIDDLEWARE_CLASSES</code></a> setting includes the path to it.</li> <li>Feel free to look at <a class="reference internal" href="../../../ref/middleware/"><span class="doc">Django’s available middleware</span></a> for examples.</li> <li>If you write a middleware component that you think would be useful to other people, contribute to the community! <a class="reference internal" href="https://docs.djangoproject.com/en/1.9/internals/contributing/index/" target="_blank"><span class="doc">Let us know</span></a>, and we’ll consider adding it to Django.</li> </ul>
<div class="_attribution">
  <p class="_attribution-p">
    © Django Software Foundation and individual contributors<br>Licensed under the BSD License.<br>
    <a href="https://docs.djangoproject.com/en/1.9/topics/http/middleware/" class="_attribution-link" target="_blank">https://docs.djangoproject.com/en/1.9/topics/http/middleware/</a>
  </p>
</div>

			</div>
		</div>
	</section>

	</div>
</body>
</html>
