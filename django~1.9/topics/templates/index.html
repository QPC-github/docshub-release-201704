
<!DOCTYPE HTML>

<html lang="en">

<head>
  <meta charset="utf-8">
  <title>Templates - Django 1.9 - W3cubDocs</title>
  
  <meta name="description" content="Being a web framework, Django needs a convenient way to generate HTML dynamically. The most common approach relies on templates. A template contains &hellip;">
  <meta name="keywords" content="templates, -, django, django~1.9">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="http://docs.w3cub.com/django~1.9/topics/templates/">
  <link href="/favicon.png" rel="icon">
  <link type="text/css" rel="stylesheet" href="/assets/application-50364fff564ce3b6327021805f3f00e2957b441cf27f576a7dd4ff63bbc47047.css">
  <script type="text/javascript" src="/assets/application-db64bfd54ceb42be11af7995804cf4902548419ceb79d509b0b7d62c22d98e6f.js"></script>
  <script src="/json/django~1.9.js"></script>
  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-71174418-1']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>


</head>

<body>
	<div class="_app">
	<header class="_header">
  
  <form class="_search">
    <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
    <a class="_search-clear"></a>
    <div class="_search-tag"></div>
  </form>
  
  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/django~1.9/" class="_nav-link" title="" style="margin-left:0;">Django 1.9</a></span>
  
  <nav class="_nav">
    <a href="/app/" class="_nav-link ">App</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		<div class="_list">
			
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<div class="_page _sphinx">
				
<h1 id="templates">Templates</h1> <p id="module-django.template">Being a web framework, Django needs a convenient way to generate HTML dynamically. The most common approach relies on templates. A template contains the static parts of the desired HTML output as well as some special syntax describing how dynamic content will be inserted. For a hands-on example of creating HTML pages with templates, see <a class="reference internal" href="../../intro/tutorial03/"><span class="doc">Tutorial 3</span></a>.</p> <p>A Django project can be configured with one or several template engines (or even zero if you don’t use templates). Django ships built-in backends for its own template system, creatively called the Django template language (DTL), and for the popular alternative <a class="reference external" href="http://jinja.pocoo.org/" target="_blank">Jinja2</a>. Backends for other template languages may be available from third-parties.</p> <p>Django defines a standard API for loading and rendering templates regardless of the backend. Loading consists of finding the template for a given identifier and preprocessing it, usually compiling it to an in-memory representation. Rendering means interpolating the template with context data and returning the resulting string.</p> <p>The <a class="reference internal" href="../../ref/templates/language/"><span class="doc">Django template language</span></a> is Django’s own template system. Until Django 1.8 it was the only built-in option available. It’s a good template library even though it’s fairly opinionated and sports a few idiosyncrasies. If you don’t have a pressing reason to choose another backend, you should use the DTL, especially if you’re writing a pluggable application and you intend to distribute templates. Django’s contrib apps that include templates, like <a class="reference internal" href="../../ref/contrib/admin/"><span class="doc">django.contrib.admin</span></a>, use the DTL.</p> <p>For historical reasons, both the generic support for template engines and the implementation of the Django template language live in the <code>django.template</code> namespace.</p>  <h2 id="template-engines">Support for template engines</h2> <div class="versionadded" id="support-for-template-engines"> <p>Support for multiple template engines and the <a class="reference internal" href="../../ref/settings/#std:setting-TEMPLATES"><code>TEMPLATES</code></a> setting were added in Django 1.8.</p> </div>  <h3 id="configuration">Configuration</h3> <p>Templates engines are configured with the <a class="reference internal" href="../../ref/settings/#std:setting-TEMPLATES"><code>TEMPLATES</code></a> setting. It’s a list of configurations, one for each engine. The default value is empty. The <code>settings.py</code> generated by the <a class="reference internal" href="../../ref/django-admin/#django-admin-startproject"><code>startproject</code></a> command defines a more useful value:</p> <pre data-language="python">TEMPLATES = [
    {
        'BACKEND': 'django.template.backends.django.DjangoTemplates',
        'DIRS': [],
        'APP_DIRS': True,
        'OPTIONS': {
            # ... some options here ...
        },
    },
]
</pre> <p><a class="reference internal" href="../../ref/settings/#std:setting-TEMPLATES-BACKEND"><code>BACKEND</code></a> is a dotted Python path to a template engine class implementing Django’s template backend API. The built-in backends are <a class="reference internal" href="#django.template.backends.django.DjangoTemplates" title="django.template.backends.django.DjangoTemplates"><code>django.template.backends.django.DjangoTemplates</code></a> and <a class="reference internal" href="#django.template.backends.jinja2.Jinja2" title="django.template.backends.jinja2.Jinja2"><code>django.template.backends.jinja2.Jinja2</code></a>.</p> <p>Since most engines load templates from files, the top-level configuration for each engine contains two common settings:</p> <ul class="simple"> <li>
<a class="reference internal" href="../../ref/settings/#std:setting-TEMPLATES-DIRS"><code>DIRS</code></a> defines a list of directories where the engine should look for template source files, in search order.</li> <li>
<a class="reference internal" href="../../ref/settings/#std:setting-TEMPLATES-APP_DIRS"><code>APP_DIRS</code></a> tells whether the engine should look for templates inside installed applications. Each backend defines a conventional name for the subdirectory inside applications where its templates should be stored.</li> </ul> <p>While uncommon, it’s possible to configure several instances of the same backend with different options. In that case you should define a unique <a class="reference internal" href="../../ref/settings/#std:setting-TEMPLATES-NAME"><code>NAME</code></a> for each engine.</p> <p><a class="reference internal" href="../../ref/settings/#std:setting-TEMPLATES-OPTIONS"><code>OPTIONS</code></a> contains backend-specific settings.</p>   <h3 id="usage">Usage</h3> <p>The <code>django.template.loader</code> module defines two functions to load templates.</p> <dl class="function"> <dt id="django.template.loader.get_template">
<code>get_template(template_name, dirs=_dirs_undefined, using=None)</code> <a class="reference internal" href="https://docs.djangoproject.com/en/1.9/_modules/django/template/loader/#get_template" target="_blank"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>This function loads the template with the given name and returns a <code>Template</code> object.</p> <p>The exact type of the return value depends on the backend that loaded the template. Each backend has its own <code>Template</code> class.</p> <p><code>get_template()</code> tries each template engine in order until one succeeds. If the template cannot be found, it raises <a class="reference internal" href="#django.template.TemplateDoesNotExist" title="django.template.TemplateDoesNotExist"><code>TemplateDoesNotExist</code></a>. If the template is found but contains invalid syntax, it raises <a class="reference internal" href="#django.template.TemplateSyntaxError" title="django.template.TemplateSyntaxError"><code>TemplateSyntaxError</code></a>.</p> <p>How templates are searched and loaded depends on each engine’s backend and configuration.</p> <p>If you want to restrict the search to a particular template engine, pass the engine’s <a class="reference internal" href="../../ref/settings/#std:setting-TEMPLATES-NAME"><code>NAME</code></a> in the <code>using</code> argument.</p> <div class="deprecated"> <p><span class="versionmodified">Deprecated since version 1.8: </span>The <code>dirs</code> parameter was deprecated.</p> </div> <div class="versionchanged"> <p>The <code>using</code> parameter was added.</p> </div> <div class="versionchanged"> <p><code>get_template()</code> returns a backend-dependent <code>Template</code> instead of a <a class="reference internal" href="../../ref/templates/api/#django.template.Template" title="django.template.Template"><code>django.template.Template</code></a>.</p> </div> </dd>
</dl> <dl class="function"> <dt id="django.template.loader.select_template">
<code>select_template(template_name_list, dirs=_dirs_undefined, using=None)</code> <a class="reference internal" href="https://docs.djangoproject.com/en/1.9/_modules/django/template/loader/#select_template" target="_blank"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p><code>select_template()</code> is just like <code>get_template()</code>, except it takes a list of template names. It tries each name in order and returns the first template that exists.</p> <div class="deprecated"> <p><span class="versionmodified">Deprecated since version 1.8: </span>The <code>dirs</code> parameter was deprecated.</p> </div> <div class="versionchanged"> <p>The <code>using</code> parameter was added.</p> </div> <div class="versionchanged"> <p><code>select_template()</code> returns a backend-dependent <code>Template</code> instead of a <a class="reference internal" href="../../ref/templates/api/#django.template.Template" title="django.template.Template"><code>django.template.Template</code></a>.</p> </div> </dd>
</dl> <p>If loading a template fails, the following two exceptions, defined in <code>django.template</code>, may be raised:</p> <dl class="exception"> <dt id="django.template.TemplateDoesNotExist">
<code>exception TemplateDoesNotExist(msg, tried=None, backend=None, chain=None)</code> <a class="reference internal" href="https://docs.djangoproject.com/en/1.9/_modules/django/template/exceptions/#TemplateDoesNotExist" target="_blank"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>This exception is raised when a template cannot be found. It accepts the following optional arguments for populating the <a class="reference internal" href="#template-postmortem"><span class="std std-ref">template postmortem</span></a> on the debug page:</p> <dl class="docutils"> <dt>
<code>backend</code> </dt> <dd>The template backend instance from which the exception originated.</dd> <dt>
<code>tried</code> </dt> <dd>A list of sources that were tried when finding the template. This is formatted as a list of tuples containing <code>(origin, status)</code>, where <code>origin</code> is an <a class="reference internal" href="#template-origin-api"><span class="std std-ref">origin-like</span></a> object and <code>status</code> is a string with the reason the template wasn’t found.</dd> <dt>
<code>chain</code> </dt> <dd>A list of intermediate <a class="reference internal" href="#django.template.TemplateDoesNotExist" title="django.template.TemplateDoesNotExist"><code>TemplateDoesNotExist</code></a> exceptions raised when trying to load a template. This is used by functions, such as <a class="reference internal" href="#django.template.loader.get_template" title="django.template.loader.get_template"><code>get_template()</code></a>, that try to load a given template from multiple engines.</dd> </dl> <div class="versionadded"> <p>The <code>backend</code>, <code>tried</code>, and <code>chain</code> arguments were added.</p> </div> </dd>
</dl> <dl class="exception"> <dt id="django.template.TemplateSyntaxError">
<code>exception TemplateSyntaxError(msg)</code> <a class="reference internal" href="https://docs.djangoproject.com/en/1.9/_modules/django/template/exceptions/#TemplateSyntaxError" target="_blank"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>This exception is raised when a template was found but contains errors.</p> </dd>
</dl> <p><code>Template</code> objects returned by <code>get_template()</code> and <code>select_template()</code> must provide a <code>render()</code> method with the following signature:</p> <dl class="method"> <dt id="django.template.backends.base.Template.render">
<code>Template.render(context=None, request=None)</code> </dt> <dd>
<p>Renders this template with a given context.</p> <p>If <code>context</code> is provided, it must be a <a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#dict" title="(in Python v3.6)" target="_blank"><code>dict</code></a>. If it isn’t provided, the engine will render the template with an empty context.</p> <p>If <code>request</code> is provided, it must be an <a class="reference internal" href="../../ref/request-response/#django.http.HttpRequest" title="django.http.HttpRequest"><code>HttpRequest</code></a>. Then the engine must make it, as well as the CSRF token, available in the template. How this is achieved is up to each backend.</p> </dd>
</dl> <p>Here’s an example of the search algorithm. For this example the <a class="reference internal" href="../../ref/settings/#std:setting-TEMPLATES"><code>TEMPLATES</code></a> setting is:</p> <pre data-language="python">TEMPLATES = [
    {
        'BACKEND': 'django.template.backends.django.DjangoTemplates',
        'DIRS': [
            '/home/html/example.com',
            '/home/html/default',
        ],
    },
    {
        'BACKEND': 'django.template.backends.jinja2.Jinja2',
        'DIRS': [
            '/home/html/jinja2',
        ],
    },
]
</pre> <p>If you call <code>get_template('story_detail.html')</code>, here are the files Django will look for, in order:</p> <ul class="simple"> <li>
<code>/home/html/example.com/story_detail.html</code> (<code>'django'</code> engine)</li> <li>
<code>/home/html/default/story_detail.html</code> (<code>'django'</code> engine)</li> <li>
<code>/home/html/jinja2/story_detail.html</code> (<code>'jinja2'</code> engine)</li> </ul> <p>If you call <code>select_template(['story_253_detail.html', 'story_detail.html'])</code>, here’s what Django will look for:</p> <ul class="simple"> <li>
<code>/home/html/example.com/story_253_detail.html</code> (<code>'django'</code> engine)</li> <li>
<code>/home/html/default/story_253_detail.html</code> (<code>'django'</code> engine)</li> <li>
<code>/home/html/jinja2/story_253_detail.html</code> (<code>'jinja2'</code> engine)</li> <li>
<code>/home/html/example.com/story_detail.html</code> (<code>'django'</code> engine)</li> <li>
<code>/home/html/default/story_detail.html</code> (<code>'django'</code> engine)</li> <li>
<code>/home/html/jinja2/story_detail.html</code> (<code>'jinja2'</code> engine)</li> </ul> <p>When Django finds a template that exists, it stops looking.</p> <div class="admonition-tip admonition"> <p class="first admonition-title">Tip</p> <p class="last">You can use <a class="reference internal" href="#django.template.loader.select_template" title="django.template.loader.select_template"><code>select_template()</code></a> for flexible template loading. For example, if you’ve written a news story and want some stories to have custom templates, use something like <code>select_template(['story_%s_detail.html' % story.id,
'story_detail.html'])</code>. That’ll allow you to use a custom template for an individual story, with a fallback template for stories that don’t have custom templates.</p> </div> <p>It’s possible – and preferable – to organize templates in subdirectories inside each directory containing templates. The convention is to make a subdirectory for each Django app, with subdirectories within those subdirectories as needed.</p> <p>Do this for your own sanity. Storing all templates in the root level of a single directory gets messy.</p> <p>To load a template that’s within a subdirectory, just use a slash, like so:</p> <pre data-language="python">get_template('news/story_detail.html')
</pre> <p>Using the same <a class="reference internal" href="../../ref/settings/#std:setting-TEMPLATES"><code>TEMPLATES</code></a> option as above, this will attempt to load the following templates:</p> <ul class="simple"> <li>
<code>/home/html/example.com/news/story_detail.html</code> (<code>'django'</code> engine)</li> <li>
<code>/home/html/default/news/story_detail.html</code> (<code>'django'</code> engine)</li> <li>
<code>/home/html/jinja2/news/story_detail.html</code> (<code>'jinja2'</code> engine)</li> </ul> <p>In addition, to cut down on the repetitive nature of loading and rendering templates, Django provides a shortcut function which automates the process.</p> <dl class="function"> <dt id="django.template.loader.render_to_string">
<code>render_to_string(template_name, context=None, context_instance=_context_instance_undefined, request=None, using=None)</code> <a class="reference internal" href="https://docs.djangoproject.com/en/1.9/_modules/django/template/loader/#render_to_string" target="_blank"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p><code>render_to_string()</code> loads a template like <a class="reference internal" href="#django.template.loader.get_template" title="django.template.loader.get_template"><code>get_template()</code></a> and calls its <code>render()</code> method immediately. It takes the following arguments.</p> <dl class="docutils"> <dt>
<code>template_name</code> </dt> <dd>The name of the template to load and render. If it’s a list of template names, Django uses <a class="reference internal" href="#django.template.loader.select_template" title="django.template.loader.select_template"><code>select_template()</code></a> instead of <a class="reference internal" href="#django.template.loader.get_template" title="django.template.loader.get_template"><code>get_template()</code></a> to find the template.</dd> <dt>
<code>context</code> </dt> <dd>
<p class="first">A <a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#dict" title="(in Python v3.6)" target="_blank"><code>dict</code></a> to be used as the template’s context for rendering.</p> <div class="last versionchanged"> <p>The <code>context</code> argument used to be called <code>dictionary</code>. That name is deprecated in Django 1.8 and will be removed in Django 1.10.</p> <p><code>context</code> is now optional. An empty context will be used if it isn’t provided.</p> </div> </dd> <dt>
<code>context_instance</code> </dt> <dd>
<p class="first">An instance of <a class="reference internal" href="../../ref/templates/api/#django.template.Context" title="django.template.Context"><code>Context</code></a> or a subclass (e.g., an instance of <a class="reference internal" href="../../ref/templates/api/#django.template.RequestContext" title="django.template.RequestContext"><code>RequestContext</code></a>) to use as the template’s context.</p> <div class="last deprecated"> <p><span class="versionmodified">Deprecated since version 1.8: </span>The <code>context_instance</code> argument is deprecated. Use <code>context</code> and if needed <code>request</code>.</p> </div> </dd> <dt>
<code>request</code> </dt> <dd>
<p class="first">An optional <a class="reference internal" href="../../ref/request-response/#django.http.HttpRequest" title="django.http.HttpRequest"><code>HttpRequest</code></a> that will be available during the template’s rendering process.</p> <div class="last versionadded"> <p>The <code>request</code> argument was added.</p> </div> </dd> </dl> <p>Usage example:</p> <pre data-language="python">from django.template.loader import render_to_string
rendered = render_to_string('my_template.html', {'foo': 'bar'})
</pre> </dd>
</dl> <p>See also the <a class="reference internal" href="http/shortcuts#django.shortcuts.render" title="django.shortcuts.render" target="_blank"><code>render()</code></a> shortcut which calls <a class="reference internal" href="#django.template.loader.render_to_string" title="django.template.loader.render_to_string"><code>render_to_string()</code></a> and feeds the result into an <a class="reference internal" href="../../ref/request-response/#django.http.HttpResponse" title="django.http.HttpResponse"><code>HttpResponse</code></a> suitable for returning from a view.</p> <p>Finally, you can use configured engines directly:</p> <dl class="data" id="module-django.template.backends"> <dt id="django.template.loader.engines">
<code>engines</code> </dt> <dd>
<p>Template engines are available in <code>django.template.engines</code>:</p> <pre data-language="python">from django.template import engines

django_engine = engines['django']
template = django_engine.from_string("Hello {{ name }}!")
</pre> <p>The lookup key — <code>'django'</code> in this example — is the engine’s <a class="reference internal" href="../../ref/settings/#std:setting-TEMPLATES-NAME"><code>NAME</code></a>.</p> </dd>
</dl>   <h3 id="built-in-backends">Built-in backends</h3> <dl class="class" id="module-django.template.backends.django"> <dt id="django.template.backends.django.DjangoTemplates">
<code>class DjangoTemplates</code> <a class="reference internal" href="https://docs.djangoproject.com/en/1.9/_modules/django/template/backends/django/#DjangoTemplates" target="_blank"><span class="viewcode-link">[source]</span></a>
</dt> 
</dl> <p>Set <a class="reference internal" href="../../ref/settings/#std:setting-TEMPLATES-BACKEND"><code>BACKEND</code></a> to <code>'django.template.backends.django.DjangoTemplates'</code> to configure a Django template engine.</p> <p>When <a class="reference internal" href="../../ref/settings/#std:setting-TEMPLATES-APP_DIRS"><code>APP_DIRS</code></a> is <code>True</code>, <code>DjangoTemplates</code> engines look for templates in the <code>templates</code> subdirectory of installed applications. This generic name was kept for backwards-compatibility.</p> <p><code>DjangoTemplates</code> engines accept the following <a class="reference internal" href="../../ref/settings/#std:setting-TEMPLATES-OPTIONS"><code>OPTIONS</code></a>:</p> <ul> <li>
<p class="first"><code>'allowed_include_roots'</code>: a list of strings representing allowed prefixes for the <code>{% ssi %}</code> template tag. This is a security measure, so that template authors can’t access files that they shouldn’t be accessing.</p> <p>For example, if <code>'allowed_include_roots'</code> is <code>['/home/html',
'/var/www']</code>, then <code>{% ssi /home/html/foo.txt %}</code> would work, but <code>{%
ssi /etc/passwd %}</code> wouldn’t.</p> <p>It defaults to an empty list.</p> <div class="deprecated"> <p><span class="versionmodified">Deprecated since version 1.8: </span><code>allowed_include_roots</code> is deprecated because the {% ssi %} tag is deprecated.</p> </div> </li> <li>
<p class="first"><code>'context_processors'</code>: a list of dotted Python paths to callables that are used to populate the context when a template is rendered with a request. These callables take a request object as their argument and return a <a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#dict" title="(in Python v3.6)" target="_blank"><code>dict</code></a> of items to be merged into the context.</p> <p>It defaults to an empty list.</p> <p>See <a class="reference internal" href="../../ref/templates/api/#django.template.RequestContext" title="django.template.RequestContext"><code>RequestContext</code></a> for more information.</p> </li> <li>
<p class="first"><code>'debug'</code>: a boolean that turns on/off template debug mode. If it is <code>True</code>, the fancy error page will display a detailed report for any exception raised during template rendering. This report contains the relevant snippet of the template with the appropriate line highlighted.</p> <p>It defaults to the value of the <a class="reference internal" href="../../ref/settings/#std:setting-DEBUG"><code>DEBUG</code></a> setting.</p> </li> <li>
<p class="first"><code>'loaders'</code>: a list of dotted Python paths to template loader classes. Each <code>Loader</code> class knows how to import templates from a particular source. Optionally, a tuple can be used instead of a string. The first item in the tuple should be the <code>Loader</code> class name, and subsequent items are passed to the <code>Loader</code> during initialization.</p> <p>The default depends on the values of <a class="reference internal" href="../../ref/settings/#std:setting-TEMPLATES-DIRS"><code>DIRS</code></a> and <a class="reference internal" href="../../ref/settings/#std:setting-TEMPLATES-APP_DIRS"><code>APP_DIRS</code></a>.</p> <p>See <a class="reference internal" href="../../ref/templates/api/#template-loaders"><span class="std std-ref">Loader types</span></a> for details.</p> </li> <li>
<p class="first"><code>'string_if_invalid'</code>: the output, as a string, that the template system should use for invalid (e.g. misspelled) variables.</p> <p>It defaults to an empty string.</p> <p>See <a class="reference internal" href="../../ref/templates/api/#invalid-template-variables"><span class="std std-ref">How invalid variables are handled</span></a> for details.</p> </li> <li>
<p class="first"><code>'file_charset'</code>: the charset used to read template files on disk.</p> <p>It defaults to the value of <a class="reference internal" href="../../ref/settings/#std:setting-FILE_CHARSET"><code>FILE_CHARSET</code></a>.</p> </li> <li>
<p class="first"><code>'libraries'</code>: A dictionary of labels and dotted Python paths of template tag modules to register with the template engine. This can be used to add new libraries or provide alternate labels for existing ones. For example:</p> <pre data-language="python">OPTIONS={
    'libraries': {
        'myapp_tags': 'path.to.myapp.tags',
        'admin.urls': 'django.contrib.admin.templatetags.admin_urls',
    },
}
</pre> <p>Libraries can be loaded by passing the corresponding dictionary key to the <a class="reference internal" href="../../ref/templates/builtins/#std:templatetag-load"><code>{% load %}</code></a> tag.</p> </li> <li>
<p class="first"><code>'builtins'</code>: A list of dotted Python paths of template tag modules to add to <a class="reference internal" href="../../ref/templates/builtins/"><span class="doc">built-ins</span></a>. For example:</p> <pre data-language="python">OPTIONS={
    'builtins': ['myapp.builtins'],
}
</pre> <p>Tags and filters from built-in libraries can be used without first calling the <a class="reference internal" href="../../ref/templates/builtins/#std:templatetag-load"><code>{% load %}</code></a> tag.</p> </li> </ul> <div class="versionadded"> <p>The <code>libraries</code> and <code>builtins</code> arguments were added.</p> </div> <dl class="class" id="module-django.template.backends.jinja2"> <dt id="django.template.backends.jinja2.Jinja2">
<code>class Jinja2</code> <a class="reference internal" href="https://docs.djangoproject.com/en/1.9/_modules/django/template/backends/jinja2/#Jinja2" target="_blank"><span class="viewcode-link">[source]</span></a>
</dt> 
</dl> <p>Requires <a class="reference external" href="http://jinja.pocoo.org/" target="_blank">Jinja2</a> to be installed:</p> <pre data-language="console">$ pip install Jinja2
</pre> <p>Set <a class="reference internal" href="../../ref/settings/#std:setting-TEMPLATES-BACKEND"><code>BACKEND</code></a> to <code>'django.template.backends.jinja2.Jinja2'</code> to configure a <a class="reference external" href="http://jinja.pocoo.org/" target="_blank">Jinja2</a> engine.</p> <p>When <a class="reference internal" href="../../ref/settings/#std:setting-TEMPLATES-APP_DIRS"><code>APP_DIRS</code></a> is <code>True</code>, <code>Jinja2</code> engines look for templates in the <code>jinja2</code> subdirectory of installed applications.</p> <p>The most important entry in <a class="reference internal" href="../../ref/settings/#std:setting-TEMPLATES-OPTIONS"><code>OPTIONS</code></a> is <code>'environment'</code>. It’s a dotted Python path to a callable returning a Jinja2 environment. It defaults to <code>'jinja2.Environment'</code>. Django invokes that callable and passes other options as keyword arguments. Furthermore, Django adds defaults that differ from Jinja2’s for a few options:</p> <ul class="simple"> <li>
<code>'autoescape'</code>: <code>True</code>
</li> <li>
<code>'loader'</code>: a loader configured for <a class="reference internal" href="../../ref/settings/#std:setting-TEMPLATES-DIRS"><code>DIRS</code></a> and <a class="reference internal" href="../../ref/settings/#std:setting-TEMPLATES-APP_DIRS"><code>APP_DIRS</code></a>
</li> <li>
<code>'auto_reload'</code>: <code>settings.DEBUG</code>
</li> <li>
<code>'undefined'</code>: <code>DebugUndefined if settings.DEBUG else Undefined</code>
</li> </ul> <p>The default configuration is purposefully kept to a minimum. If a template is rendered with a request (e.g. when using <a class="reference internal" href="http/shortcuts#django.shortcuts.render" title="django.shortcuts.render" target="_blank"><code>render()</code></a>), the <code>Jinja2</code> backend adds the globals <code>request</code>, <code>csrf_input</code>, and <code>csrf_token</code> to the context. Apart from that, this backend doesn’t create a Django-flavored environment. It doesn’t know about Django context processors, filters, and tags. In order to use Django-specific APIs, you must configure them into the environment.</p> <p>For example, you can create <code>myproject/jinja2.py</code> with this content:</p> <pre data-language="python">from __future__ import absolute_import  # Python 2 only

from django.contrib.staticfiles.storage import staticfiles_storage
from django.core.urlresolvers import reverse

from jinja2 import Environment


def environment(**options):
    env = Environment(**options)
    env.globals.update({
        'static': staticfiles_storage.url,
        'url': reverse,
    })
    return env
</pre> <p>and set the <code>'environment'</code> option to <code>'myproject.jinja2.environment'</code>.</p> <p>Then you could use the following constructs in Jinja2 templates:</p> <pre data-language="html">&lt;img src="{{ static('path/to/company-logo.png') }}" alt="Company Logo"&gt;

&lt;a href="{{ url('admin:index') }}"&gt;Administration&lt;/a&gt;
</pre> <p>The concepts of tags and filters exist both in the Django template language and in Jinja2 but they’re used differently. Since Jinja2 supports passing arguments to callables in templates, many features that require a template tag or filter in Django templates can be achieved simply by calling a function in Jinja2 templates, as shown in the example above. Jinja2’s global namespace removes the need for template context processors. The Django template language doesn’t have an equivalent of Jinja2 tests.</p>   <h3 id="custom-backends">Custom backends</h3> <p>Here’s how to implement a custom template backend in order to use another template system. A template backend is a class that inherits <code>django.template.backends.base.BaseEngine</code>. It must implement <code>get_template()</code> and optionally <code>from_string()</code>. Here’s an example for a fictional <code>foobar</code> template library:</p> <pre data-language="python">from django.template import TemplateDoesNotExist, TemplateSyntaxError
from django.template.backends.base import BaseEngine
from django.template.backends.utils import csrf_input_lazy, csrf_token_lazy

import foobar


class FooBar(BaseEngine):

    # Name of the subdirectory containing the templates for this engine
    # inside an installed application.
    app_dirname = 'foobar'

    def __init__(self, params):
        params = params.copy()
        options = params.pop('OPTIONS').copy()
        super(FooBar, self).__init__(params)

        self.engine = foobar.Engine(**options)

    def from_string(self, template_code):
        try:
          return Template(self.engine.from_string(template_code))
        except foobar.TemplateCompilationFailed as exc:
            raise TemplateSyntaxError(exc.args)

    def get_template(self, template_name):
        try:
            return Template(self.engine.get_template(template_name))
        except foobar.TemplateNotFound as exc:
            raise TemplateDoesNotExist(exc.args, backend=self)
        except foobar.TemplateCompilationFailed as exc:
            raise TemplateSyntaxError(exc.args)


class Template(object):

    def __init__(self, template):
        self.template = template

    def render(self, context=None, request=None):
        if context is None:
            context = {}
        if request is not None:
            context['request'] = request
            context['csrf_input'] = csrf_input_lazy(request)
            context['csrf_token'] = csrf_token_lazy(request)
        return self.template.render(context)
</pre> <p>See <a class="reference external" href="https://github.com/django/deps/blob/master/final/0182-multiple-template-engines.rst" target="_blank">DEP 182</a> for more information.</p>   <h3 id="template-debug-integration">Debug integration for custom engines</h3> <div class="versionadded" id="debug-integration-for-custom-engines"> <p>Debug page integration for non-Django template engines was added.</p> </div> <p>The Django debug page has hooks to provide detailed information when a template error arises. Custom template engines can use these hooks to enhance the traceback information that appears to users. The following hooks are available:</p>  <h4 id="id1">Template postmortem</h4> <p id="template-postmortem">The postmortem appears when <a class="reference internal" href="#django.template.TemplateDoesNotExist" title="django.template.TemplateDoesNotExist"><code>TemplateDoesNotExist</code></a> is raised. It lists the template engines and loaders that were used when trying to find a given template. For example, if two Django engines are configured, the postmortem will appear like:</p> <img alt="../_images/postmortem.png" src="https://docs.djangoproject.com/en/1.9/_images/postmortem.png"> <p>Custom engines can populate the postmortem by passing the <code>backend</code> and <code>tried</code> arguments when raising <a class="reference internal" href="#django.template.TemplateDoesNotExist" title="django.template.TemplateDoesNotExist"><code>TemplateDoesNotExist</code></a>. Backends that use the postmortem <a class="reference internal" href="#template-origin-api"><span class="std std-ref">should specify an origin</span></a> on the template object.</p>   <h4 id="contextual-line-information">Contextual line information</h4> <p>If an error happens during template parsing or rendering, Django can display the line the error happened on. For example:</p> <img alt="../_images/template-lines.png" src="https://docs.djangoproject.com/en/1.9/_images/template-lines.png"> <p>Custom engines can populate this information by setting a <code>template_debug</code> attribute on exceptions raised during parsing and rendering. This attribute is a <a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#dict" title="(in Python v3.6)" target="_blank"><code>dict</code></a> with the following values:</p> <ul class="simple"> <li>
<code>'name'</code>: The name of the template in which the exception occurred.</li> <li>
<code>'message'</code>: The exception message.</li> <li>
<code>'source_lines'</code>: The lines before, after, and including the line the exception occurred on. This is for context, so it shouldn’t contain more than 20 lines or so.</li> <li>
<code>'line'</code>: The line number on which the exception occurred.</li> <li>
<code>'before'</code>: The content on the error line before the token that raised the error.</li> <li>
<code>'during'</code>: The token that raised the error.</li> <li>
<code>'after'</code>: The content on the error line after the token that raised the error.</li> <li>
<code>'total'</code>: The number of lines in <code>source_lines</code>.</li> <li>
<code>'top'</code>: The line number where <code>source_lines</code> starts.</li> <li>
<code>'bottom'</code>: The line number where <code>source_lines</code> ends.</li> </ul> <p>Given the above template error, <code>template_debug</code> would look like:</p> <pre data-language="python">{
    'name': '/path/to/template.html',
    'message': "Invalid block tag: 'syntax'",
    'source_lines': [
        (1, 'some\n'),
        (2, 'lines\n'),
        (3, 'before\n'),
        (4, 'Hello {% syntax error %} {{ world }}\n'),
        (5, 'some\n'),
        (6, 'lines\n'),
        (7, 'after\n'),
        (8, ''),
    ],
    'line': 4,
    'before': 'Hello ',
    'during': '{% syntax error %}',
    'after': ' {{ world }}\n',
    'total': 9,
    'bottom': 9,
    'top': 1,
}
</pre>   <h4 id="template-origin-api">Origin API and 3rd-party integration</h4> <p id="origin-api-and-3rd-party-integration">Django templates have an <a class="reference internal" href="../../ref/templates/api/#django.template.base.Origin" title="django.template.base.Origin"><code>Origin</code></a> object available through the <code>template.origin</code> attribute. This enables debug information to be displayed in the <a class="reference internal" href="#template-postmortem"><span class="std std-ref">template postmortem</span></a>, as well as in 3rd-party libraries, like the <a class="reference external" href="https://github.com/django-debug-toolbar/django-debug-toolbar" target="_blank">Django Debug Toolbar</a>.</p> <p>Custom engines can provide their own <code>template.origin</code> information by creating an object that specifies the following attributes:</p> <ul class="simple"> <li>
<code>'name'</code>: The full path to the template.</li> <li>
<code>'template_name'</code>: The relative path to the template as passed into the the template loading methods.</li> <li>
<code>'loader_name'</code>: An optional string identifying the function or class used to load the template, e.g. <code>django.template.loaders.filesystem.Loader</code>.</li> </ul>     <h2 id="template-language-intro">The Django template language</h2>  <h3 id="the-django-template-language">Syntax</h3> <div class="admonition-about-this-section admonition"> <p class="first admonition-title">About this section</p> <p class="last">This is an overview of the Django template language’s syntax. For details see the <a class="reference internal" href="../../ref/templates/language/"><span class="doc">language syntax reference</span></a>.</p> </div> <p>A Django template is simply a text document or a Python string marked-up using the Django template language. Some constructs are recognized and interpreted by the template engine. The main ones are variables and tags.</p> <p>A template is rendered with a context. Rendering replaces variables with their values, which are looked up in the context, and executes tags. Everything else is output as is.</p> <p>The syntax of the Django template language involves four constructs.</p>  <h4 id="variables">Variables</h4> <p>A variable outputs a value from the context, which is a dict-like object mapping keys to values.</p> <p>Variables are surrounded by <code>{{</code> and <code>}}</code> like this:</p> <pre data-language="html">My first name is {{ first_name }}. My last name is {{ last_name }}.
</pre> <p>With a context of <code>{'first_name': 'John', 'last_name': 'Doe'}</code>, this template renders to:</p> <pre data-language="html">My first name is John. My last name is Doe.
</pre> <p>Dictionary lookup, attribute lookup and list-index lookups are implemented with a dot notation:</p> <pre data-language="html">{{ my_dict.key }}
{{ my_object.attribute }}
{{ my_list.0 }}
</pre> <p>If a variable resolves to a callable, the template system will call it with no arguments and use its result instead of the callable.</p>   <h4 id="tags">Tags</h4> <p>Tags provide arbitrary logic in the rendering process.</p> <p>This definition is deliberately vague. For example, a tag can output content, serve as a control structure e.g. an “if” statement or a “for” loop, grab content from a database, or even enable access to other template tags.</p> <p>Tags are surrounded by <code>{%</code> and <code>%}</code> like this:</p> <pre data-language="html">{% csrf_token %}
</pre> <p>Most tags accept arguments:</p> <pre data-language="html">{% cycle 'odd' 'even' %}
</pre> <p>Some tags require beginning and ending tags:</p> <pre data-language="html">{% if user.is_authenticated %}Hello, {{ user.username }}.{% endif %}
</pre> <p>A <a class="reference internal" href="../../ref/templates/builtins/#ref-templates-builtins-tags"><span class="std std-ref">reference of built-in tags</span></a> is available as well as <a class="reference internal" href="../../howto/custom-template-tags/#howto-writing-custom-template-tags"><span class="std std-ref">instructions for writing custom tags</span></a>.</p>   <h4 id="filters">Filters</h4> <p>Filters transform the values of variables and tag arguments.</p> <p>They look like this:</p> <pre data-language="html">{{ django|title }}
</pre> <p>With a context of <code>{'django': 'the web framework for perfectionists with
deadlines'}</code>, this template renders to:</p> <pre data-language="html">The Web Framework For Perfectionists With Deadlines
</pre> <p>Some filters take an argument:</p> <pre data-language="html">{{ my_date|date:"Y-m-d" }}
</pre> <p>A <a class="reference internal" href="../../ref/templates/builtins/#ref-templates-builtins-filters"><span class="std std-ref">reference of built-in filters</span></a> is available as well as <a class="reference internal" href="../../howto/custom-template-tags/#howto-writing-custom-template-filters"><span class="std std-ref">instructions for writing custom filters</span></a>.</p>   <h4 id="comments">Comments</h4> <p>Comments look like this:</p> <pre data-language="html">{# this won't be rendered #}
</pre> <p>A <a class="reference internal" href="../../ref/templates/builtins/#std:templatetag-comment"><code>{% comment %}</code></a> tag provides multi-line comments.</p>    <h3 id="components">Components</h3> <div class="admonition-about-this-section admonition"> <p class="first admonition-title">About this section</p> <p class="last">This is an overview of the Django template language’s APIs. For details see the <a class="reference internal" href="../../ref/templates/api/"><span class="doc">API reference</span></a>.</p> </div>  <h4 id="engine">Engine</h4> <p><a class="reference internal" href="../../ref/templates/api/#django.template.Engine" title="django.template.Engine"><code>django.template.Engine</code></a> encapsulates an instance of the Django template system. The main reason for instantiating an <a class="reference internal" href="../../ref/templates/api/#django.template.Engine" title="django.template.Engine"><code>Engine</code></a> directly is to use the Django template language outside of a Django project.</p> <p><a class="reference internal" href="#django.template.backends.django.DjangoTemplates" title="django.template.backends.django.DjangoTemplates"><code>django.template.backends.django.DjangoTemplates</code></a> is a thin wrapper adapting <a class="reference internal" href="../../ref/templates/api/#django.template.Engine" title="django.template.Engine"><code>django.template.Engine</code></a> to Django’s template backend API.</p>   <h4 id="template">Template</h4> <p><a class="reference internal" href="../../ref/templates/api/#django.template.Template" title="django.template.Template"><code>django.template.Template</code></a> represents a compiled template. Templates are obtained with <a class="reference internal" href="../../ref/templates/api/#django.template.Engine.get_template" title="django.template.Engine.get_template"><code>Engine.get_template()</code></a> or <a class="reference internal" href="../../ref/templates/api/#django.template.Engine.from_string" title="django.template.Engine.from_string"><code>Engine.from_string()</code></a></p> <p>Likewise <code>django.template.backends.django.Template</code> is a thin wrapper adapting <a class="reference internal" href="../../ref/templates/api/#django.template.Template" title="django.template.Template"><code>django.template.Template</code></a> to the common template API.</p>   <h4 id="context">Context</h4> <p><a class="reference internal" href="../../ref/templates/api/#django.template.Context" title="django.template.Context"><code>django.template.Context</code></a> holds some metadata in addition to the context data. It is passed to <a class="reference internal" href="../../ref/templates/api/#django.template.Template.render" title="django.template.Template.render"><code>Template.render()</code></a> for rendering a template.</p> <p><a class="reference internal" href="../../ref/templates/api/#django.template.RequestContext" title="django.template.RequestContext"><code>django.template.RequestContext</code></a> is a subclass of <a class="reference internal" href="../../ref/templates/api/#django.template.Context" title="django.template.Context"><code>Context</code></a> that stores the current <a class="reference internal" href="../../ref/request-response/#django.http.HttpRequest" title="django.http.HttpRequest"><code>HttpRequest</code></a> and runs template context processors.</p> <p>The common API doesn’t have an equivalent concept. Context data is passed in a plain <a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#dict" title="(in Python v3.6)" target="_blank"><code>dict</code></a> and the current <a class="reference internal" href="../../ref/request-response/#django.http.HttpRequest" title="django.http.HttpRequest"><code>HttpRequest</code></a> is passed separately if needed.</p>   <h4 id="loaders">Loaders</h4> <p>Template loaders are responsible for locating templates, loading them, and returning <a class="reference internal" href="../../ref/templates/api/#django.template.Template" title="django.template.Template"><code>Template</code></a> objects.</p> <p>Django provides several <a class="reference internal" href="../../ref/templates/api/#template-loaders"><span class="std std-ref">built-in template loaders</span></a> and supports <a class="reference internal" href="../../ref/templates/api/#custom-template-loaders"><span class="std std-ref">custom template loaders</span></a>.</p>   <h4 id="context-processors">Context processors</h4> <p>Context processors are functions that receive the current <a class="reference internal" href="../../ref/request-response/#django.http.HttpRequest" title="django.http.HttpRequest"><code>HttpRequest</code></a> as an argument and return a <a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#dict" title="(in Python v3.6)" target="_blank"><code>dict</code></a> of data to be added to the rendering context.</p> <p>Their main use is to add common data shared by all templates to the context without repeating code in every view.</p> <p>Django provides many <a class="reference internal" href="../../ref/templates/api/#context-processors"><span class="std std-ref">built-in context processors</span></a>. Implementing a custom context processor is as simple as defining a function.</p>
<div class="_attribution">
  <p class="_attribution-p">
    © Django Software Foundation and individual contributors<br>Licensed under the BSD License.<br>
    <a href="https://docs.djangoproject.com/en/1.9/topics/templates/" class="_attribution-link" target="_blank">https://docs.djangoproject.com/en/1.9/topics/templates/</a>
  </p>
</div>

			</div>
		</div>
	</section>

	</div>
</body>
</html>
