
<!DOCTYPE HTML>

<html lang="en">

<head>
  <meta charset="utf-8">
  <title>Ecto.Query - Phoenix - W3cubDocs</title>
  
  <meta name="description" content=" Provides the Query DSL. ">
  <meta name="keywords" content="ecto, query, summary, types, functions, macros, -, phoenix">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="http://docs.w3cub.com/phoenix/ecto/ecto.query/">
  <link href="/favicon.png" rel="icon">
  <link type="text/css" rel="stylesheet" href="/assets/application-50364fff564ce3b6327021805f3f00e2957b441cf27f576a7dd4ff63bbc47047.css">
  <script type="text/javascript" src="/assets/application-db64bfd54ceb42be11af7995804cf4902548419ceb79d509b0b7d62c22d98e6f.js"></script>
  <script src="/json/phoenix.js"></script>
  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-71174418-1']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>


</head>

<body>
	<div class="_app">
	<header class="_header">
  
  <form class="_search">
    <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
    <a class="_search-clear"></a>
    <div class="_search-tag"></div>
  </form>
  
  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/phoenix/" class="_nav-link" title="" style="margin-left:0;">Phoenix</a></span>
  
  <nav class="_nav">
    <a href="/app/" class="_nav-link ">App</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		<div class="_list">
			
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<div class="_page _elixir">
				
<h1>  Ecto.Query  </h1>  <p>Provides the Query DSL.</p> <p>Queries are used to retrieve and manipulate data from a repository (see <a href="../ecto.repo.html)/"><code class="inline">Ecto.Repo</code></a>. Ecto queries come in two flavors: keyword-based and macro-based. Most examples will use the keyword-based syntax, the macro one will be explored in later sections.</p> <p>Let’s see a sample query:</p> <pre data-language="elixir"><code class="elixir"># Imports only from/2 of Ecto.Query
import Ecto.Query, only: [from: 2]

# Create a query
query = from u in "users",
          where: u.age &gt; 18,
          select: u.name

# Send the query to the repository
Repo.all(query)</code></pre> <p>In the example above, we are directly querying the “users” table from the database.</p> <h2 id="module-query-expressions" class="section-heading">  Query expressions </h2> <p>Ecto allows a limited set of expressions inside queries. In the query below, for example, we use <code class="inline">u.age</code> to access a field, the <code class="inline">&gt;</code> comparison operator and the literal <code class="inline">0</code>:</p> <pre data-language="elixir"><code class="elixir">query = from u in "users", where: u.age &gt; 0, select: u.name</code></pre> <p>You can find the full list of operations in <a href="../ecto.query.api/"><code class="inline">Ecto.Query.API</code></a>. Besides the operations listed there, the following literals are supported in queries:</p> <ul> <li>Integers: <code class="inline">1</code>, <code class="inline">2</code>, <code class="inline">3</code> </li> <li>Floats: <code class="inline">1.0</code>, <code class="inline">2.0</code>, <code class="inline">3.0</code> </li> <li>Booleans: <code class="inline">true</code>, <code class="inline">false</code> </li> <li>Binaries: <code class="inline">&lt;&lt;1, 2, 3&gt;&gt;</code> </li> <li>Strings: <code class="inline">"foo bar"</code>, <code class="inline">~s(this is a string)</code> </li> <li>Arrays: <code class="inline">[1, 2, 3]</code>, <code class="inline">~w(interpolate words)</code> </li> </ul> <p>All other types and dynamic values must be passed as a parameter using interpolation as explained below.</p> <h2 id="module-interpolation-and-casting" class="section-heading">  Interpolation and casting </h2> <p>External values and Elixir expressions can be injected into a query expression with <code class="inline">^</code>:</p> <pre data-language="elixir"><code class="elixir">def with_minimum(age, height_ft) do
  from u in "users",
    where: u.age &gt; ^age and u.height &gt; ^(height_ft * 3.28),
    select: u.name
end

with_minimum(18, 5.0)</code></pre> <p>When interpolating values, you may want to explicitly tell Ecto what is the expected type of the value being interpolated:</p> <pre data-language="elixir"><code class="elixir">age = "18"
Repo.all(from u in "users",
          where: u.age &gt; type(^age, :integer),
          select: u.name)</code></pre> <p>In the example above, Ecto will cast the age to type integer. When a value cannot be cast, <a href="../ecto.query.casterror/"><code class="inline">Ecto.Query.CastError</code></a> is raised.</p> <p>To avoid the repetition of always specifying the types, you may define an <a href="../ecto.schema/"><code class="inline">Ecto.Schema</code></a>. In such cases, Ecto will analyze your queries and automatically cast the interpolated “age” when compared to the <code class="inline">u.age</code> field, as long as the age field is defined with type <code class="inline">:integer</code> in your schema:</p> <pre data-language="elixir"><code class="elixir">age = "18"
Repo.all(from u in User, where: u.age &gt; ^age, select: u.name)</code></pre> <p>Another advantage of using schemas is that we no longer need to specify the select option in queries, as by default Ecto will retrieve all fields specified in the schema:</p> <pre data-language="elixir"><code class="elixir">age = "18"
Repo.all(from u in User, where: u.age &gt; ^age)</code></pre> <p>For this reason, we will use schemas on the remaining examples but remember Ecto does not require them in order to write queries.</p> <h2 id="module-composition" class="section-heading">  Composition </h2> <p>Ecto queries are composable. For example, the query above can actually be defined in two parts:</p> <pre data-language="elixir"><code class="elixir"># Create a query
query = from u in User, where: u.age &gt; 18

# Extend the query
query = from u in query, select: u.name</code></pre> <p>Composing queries uses the same syntax as creating a query. The difference is that, instead of passing a schema like <code class="inline">Weather</code> on the right side of <code class="inline">in</code>, we passed the query itself.</p> <p>Any value can be used on the right-side of <code class="inline">in</code> as long as it implements the <a href="../ecto.queryable/"><code class="inline">Ecto.Queryable</code></a> protocol. For now, we know such protocols is implemented for both atoms (like <code class="inline">User</code>) and strings (like “users”).</p> <p>In any case, regardless if a schema has been given or not, Ecto queries are always composable thanks to its binding system.</p> <h3>Query bindings</h3> <p>On the left side of <code class="inline">in</code> we specify the query bindings. This is done inside from and join clauses. In the query below <code class="inline">u</code> is a binding and <code class="inline">u.age</code> is a field access using this binding.</p> <pre data-language="elixir"><code class="elixir">query = from u in User, where: u.age &gt; 18</code></pre> <p>Bindings are not exposed from the query. When composing queries you must specify bindings again for each refinement query. For example to further narrow-down above query we again need to tell Ecto what bindings to expect:</p> <pre data-language="elixir"><code class="elixir">query = from u in query, select: u.city</code></pre> <p>Bindings in Ecto are positional, and the names do not have to be consistent between input and refinement queries. For example, the query above could also be written as:</p> <pre data-language="elixir"><code class="elixir">query = from q in query, select: q.city</code></pre> <p>It would make no difference to Ecto. This is important because it allows developers to compose queries without caring about the bindings used in the initial query.</p> <p>When using joins, the bindings should be matched in the order they are specified:</p> <pre data-language="elixir"><code class="elixir"># Create a query
query = from p in Post,
          join: c in Comment, where: c.post_id == p.id

# Extend the query
query = from [p, c] in query,
          select: {p.title, c.body}</code></pre> <p>You are not required to specify all bindings when composing. For example, if we would like to order the results above by post insertion date, we could further extend it as:</p> <pre data-language="elixir"><code class="elixir">query = from q in query, order_by: q.inserted_at</code></pre> <p>The example above will work if the input query has 1 or 10 bindings. In the example above, we will always sort by the <code class="inline">inserted_at</code> column from the <code class="inline">from</code> source.</p> <h3>Bindingless operations</h3> <p>Although bindings are extremely useful when working with joins, they are not necessary when the query has only the <code class="inline">from</code> clause. For such cases, Ecto supports a way for building queries without specifying the binding:</p> <pre data-language="elixir"><code class="elixir">from Post,
  where: [category: "fresh and new"],
  order_by: [desc: :published_at],
  select: [:id, :title, :body]</code></pre> <p>The query above will select all posts with category “fresh and new”, order by the most recently published, and return Post structs with only the id, title and body fields set. It is equivalent to:</p> <pre data-language="elixir"><code class="elixir">from p in Post,
  where: p.category == "fresh and new",
  order_by: [desc: p.published_at],
  select: struct(p, [:id, :title, :body])</code></pre> <p>One advantage of bindingless queries is that they are data-driven and therefore useful for dynamically building queries. For example, the query above could also be written as:</p> <pre data-language="elixir"><code class="elixir">where = [category: "fresh and new"]
order_by = [desc: :published_at]
select = [:id, :title, :body]
from Post, where: ^where, order_by: ^order_by, select: ^select</code></pre> <p>This feature is very useful when queries need to be built based on some user input, like web search forms, CLIs and so on.</p> <h2 id="module-fragments" class="section-heading">  Fragments </h2> <p>If you need an escape hatch, Ecto provides fragments (see <a href="../ecto.query.api/#fragment/1)"><code class="inline">Ecto.Query.API.fragment/1</code></a> to inject SQL (and non-SQL) fragments into queries.</p> <p>For example, to get all posts while running the “lower(?)” function in the database where <code class="inline">p.title</code> is interpolated in place of <code class="inline">?</code>, one can write:</p> <pre data-language="elixir"><code class="elixir">from p in Post,
  where: is_nil(p.published_at) and
         fragment("lower(?)", p.title) == ^title</code></pre> <p>Also, most adapters provide direct APIs for queries, like <a href="../ecto.adapters.sql/#query/4"><code class="inline">Ecto.Adapters.SQL.query/4</code></a>, allowing developers to completely bypass Ecto queries.</p> <h2 id="module-macro-api" class="section-heading">  Macro API </h2> <p>In all examples so far we have used the <strong>keywords query syntax</strong> to create a query:</p> <pre data-language="elixir"><code class="elixir">import Ecto.Query
from u in "users", where: u.age &gt; 18, select: u.name</code></pre> <p>Due to the prevalence of the pipe operator in Elixir, Ecto also supports a pipe-based syntax:</p> <pre data-language="elixir"><code class="elixir">"users"
|&gt; where([u], u.age &gt; 18)
|&gt; select([u], u.name)</code></pre> <p>The keyword-based and pipe-based examples are equivalent. The downside of using macros is that the binding must be specified for every operation. However, since keyword-based and pipe-based examples are equivalent, the bindingless syntax also works for macros:</p> <pre data-language="elixir"><code class="elixir">"users"
|&gt; where([u], u.age &gt; 18)
|&gt; select([:name])</code></pre> <p>Such allows developers to write queries using bindings only in more complex query expressions.</p> <p>This module documents each of those macros, providing examples in both the keywords query and pipe expression formats.</p> <h2 id="module-query-prefix" class="section-heading">  Query Prefix </h2> <p>It is possible to set a prefix for the queries. For Postgres users, this will specify the schema where the table is located, while for MySQL users this will specify the database where the table is located. When no prefix is set, Postgres queries are assumed to be in the public schema, while MySQL queries are assumed to be in the database set in the config for the repo.</p> <p>To set the prefix on a query:</p> <pre data-language="elixir"><code class="elixir">results =
  query # May be User or an Ecto.Query itself
  |&gt; Ecto.Queryable.to_query
  |&gt; Map.put(:prefix, "foo")
  |&gt; Repo.all</code></pre> <p>When a prefix is set in a query, all loaded structs will belong to that prefix, so operations like update and delete will be applied to the proper prefix. In case you want to manually set the prefix for new data, specially on insert, use <a href="../ecto/#put_meta/2"><code class="inline">Ecto.put_meta/2</code></a>.</p>   <h1 class="section-heading" id="summary">  Summary </h1> <h2> Types </h2>
<dl class="summary-types summary">   <dt class="summary-signature"> <a href="#t/0">t()</a> </dt>  </dl> <h2> Functions </h2>
<dl class="summary-functions summary">   <dt class="summary-signature"> <a href="#exclude/2">exclude(query, field)</a> </dt> <dd class="summary-synopsis">
<p>Resets a previously set field on a query</p> </dd>   <dt class="summary-signature"> <a href="#first/2">first(queryable, order_by \\ nil)</a> </dt> <dd class="summary-synopsis">
<p>Restricts the query to return the first result ordered by primary key</p> </dd>   <dt class="summary-signature"> <a href="#last/2">last(queryable, order_by \\ nil)</a> </dt> <dd class="summary-synopsis">
<p>Restricts the query to return the last result ordered by primary key</p> </dd>   <dt class="summary-signature"> <a href="#subquery/1">subquery(subquery)</a> </dt> <dd class="summary-synopsis">
<p>Converts a query into a subquery</p> </dd>  </dl> <h2> Macros </h2>
<dl class="summary-macros summary">   <dt class="summary-signature"> <a href="#distinct/3">distinct(query, binding \\ [], expr)</a> </dt> <dd class="summary-synopsis">
<p>A distinct query expression</p> </dd>   <dt class="summary-signature"> <a href="#from/2">from(expr, kw \\ [])</a> </dt> <dd class="summary-synopsis">
<p>Creates a query</p> </dd>   <dt class="summary-signature"> <a href="#group_by/3">group_by(query, binding \\ [], expr)</a> </dt> <dd class="summary-synopsis">
<p>A group by query expression</p> </dd>   <dt class="summary-signature"> <a href="#having/3">having(query, binding \\ [], expr)</a> </dt> <dd class="summary-synopsis">
<p>A having query expression</p> </dd>   <dt class="summary-signature"> <a href="#join/5">join(query, qual, binding \\ [], expr, on \\ nil)</a> </dt> <dd class="summary-synopsis">
<p>A join query expression</p> </dd>   <dt class="summary-signature"> <a href="#limit/3">limit(query, binding \\ [], expr)</a> </dt> <dd class="summary-synopsis">
<p>A limit query expression</p> </dd>   <dt class="summary-signature"> <a href="#lock/2">lock(query, expr)</a> </dt> <dd class="summary-synopsis">
<p>A lock query expression</p> </dd>   <dt class="summary-signature"> <a href="#offset/3">offset(query, binding \\ [], expr)</a> </dt> <dd class="summary-synopsis">
<p>An offset query expression</p> </dd>   <dt class="summary-signature"> <a href="#order_by/3">order_by(query, binding \\ [], expr)</a> </dt> <dd class="summary-synopsis">
<p>An order by query expression</p> </dd>   <dt class="summary-signature"> <a href="#preload/3">preload(query, bindings \\ [], expr)</a> </dt> <dd class="summary-synopsis">
<p>Preloads the associations into the given struct</p> </dd>   <dt class="summary-signature"> <a href="#select/3">select(query, binding \\ [], expr)</a> </dt> <dd class="summary-synopsis">
<p>A select query expression</p> </dd>   <dt class="summary-signature"> <a href="#update/3">update(query, binding \\ [], expr)</a> </dt> <dd class="summary-synopsis">
<p>An update query expression</p> </dd>   <dt class="summary-signature"> <a href="#where/3">where(query, binding \\ [], expr)</a> </dt> <dd class="summary-synopsis">
<p>A where query expression</p> </dd>  </dl>   <h1 class="section-heading" id="types">  Types </h1>  <div id="t/0" class="type-detail"> <pre data-language="elixir"><code class="elixir"><a href="#t:t/0">t</a></code></pre> </div>    <h1 class="section-heading" id="functions">  Functions </h1>  <h3 class="detail-header function" id="exclude/2">  <span class="signature">exclude(query, field)</span>  </h3>  <p>Resets a previously set field on a query.</p> <p>It can reset any query field except the query source (<code class="inline">from</code>).</p> <h4>Example</h4> <pre data-language="elixir"><code class="elixir">query |&gt; Ecto.Query.exclude(:select)</code></pre>    <h3 class="detail-header function" id="first/2">  <span class="signature">first(queryable, order_by \\ nil)</span>  </h3>  <p>Restricts the query to return the first result ordered by primary key.</p> <p>The query will be automatically ordered by the primary key unless <code class="inline">order_by</code> is given or <code class="inline">order_by</code> is set in the query. Limit is always set to 1.</p> <h4>Examples</h4> <pre data-language="elixir"><code class="elixir">Post |&gt; first |&gt; Repo.one
query |&gt; first(:inserted_at) |&gt; Repo.one</code></pre>    <h3 class="detail-header function" id="last/2">  <span class="signature">last(queryable, order_by \\ nil)</span>  </h3>  <p>Restricts the query to return the last result ordered by primary key.</p> <p>The query ordering will be automatically reversed, with ASC columns becoming DESC columns (and vice-versa) and limit is set to 1. If there is no ordering, the query will be automatically ordered decreasingly by primary key.</p> <h4>Examples</h4> <pre data-language="elixir"><code class="elixir">Post |&gt; last |&gt; Repo.one
query |&gt; last(:inserted_at) |&gt; Repo.one</code></pre>    <h3 class="detail-header function" id="subquery/1">  <span class="signature">subquery(subquery)</span>  </h3>  <p>Converts a query into a subquery.</p> <p>If a subquery is given, returns the subquery itself. If any other value is given, it is converted to a query via <a href="../ecto.queryable/"><code class="inline">Ecto.Queryable</code></a> and wrapped in the <a href="../ecto.subquery/"><code class="inline">Ecto.SubQuery</code></a> struct.</p> <p>Subqueries are currently only supported in the <code class="inline">from</code> and <code class="inline">join</code> fields.</p> <h4>Examples</h4> <pre data-language="elixir"><code class="elixir"># Get the average salary of the top 10 highest salaries
query = from Employee, order_by: [desc: :salary], limit: 10
from e in subquery(query), select: avg(e.salary)</code></pre>     <h1 class="section-heading" id="macros">  Macros </h1>  <h3 class="detail-header macro" id="distinct/3">  <span class="signature">distinct(query, binding \\ [], expr)</span>  </h3>  <p>A distinct query expression.</p> <p>When true, only keeps distinct values from the resulting select expression.</p> <p>If supported by your database, you can also pass query expressions to distinct and it will generate a query with DISTINCT ON. In such cases, the row that is being kept depends on the ordering of the rows. When an <code class="inline">order_by</code> expression is also added to the query, all fields in the <code class="inline">distinct</code> expression are automatically referenced <code class="inline">order_by</code> too.</p> <p><code class="inline">distinct</code> also accepts a list of atoms where each atom refers to a field in source.</p> <h4>Keywords examples</h4> <pre data-language="elixir"><code class="elixir"># Returns the list of different categories in the Post schema
from(p in Post, distinct: true, select: p.category)

# If your database supports DISTINCT ON(),
# you can pass expressions to distinct too
from(p in Post,
   distinct: p.category,
   order_by: [p.date])

# Using atoms
from(p in Post, distinct: :category, order_by: :date)</code></pre> <h4>Expressions example</h4> <pre data-language="elixir"><code class="elixir">Post
|&gt; distinct(true)
|&gt; order_by([p], [p.category, p.author])</code></pre>    <h3 class="detail-header macro" id="from/2">  <span class="signature">from(expr, kw \\ [])</span>  </h3>  <p>Creates a query.</p> <p>It can either be a keyword query or a query expression.</p> <p>If it is a keyword query the first argument must be either an <code class="inline">in</code> expression, or a value that implements the <a href="../ecto.queryable/"><code class="inline">Ecto.Queryable</code></a> protocol. If the query needs a reference to the data source in any other part of the expression, then an <code class="inline">in</code> must be used to create a reference variable. The second argument should be a keyword query where the keys are expression types and the values are expressions.</p> <p>If it is a query expression the first argument must be a value that implements the <a href="../ecto.queryable/"><code class="inline">Ecto.Queryable</code></a> protocol and the second argument the expression.</p> <h4>Keywords example</h4> <pre data-language="elixir"><code class="elixir">from(c in City, select: c)</code></pre> <h4>Expressions example</h4> <pre data-language="elixir"><code class="elixir">City |&gt; select([c], c)</code></pre> <h4>Examples</h4> <pre data-language="elixir"><code class="elixir">def paginate(query, page, size) do
  from query,
    limit: ^size,
    offset: ^((page-1) * size)
end</code></pre> <p>The example above does not use <code class="inline">in</code> because <code class="inline">limit</code> and <code class="inline">offset</code> do not require a reference to the data source. However, extending the query with a where expression would require the use of <code class="inline">in</code>:</p> <pre data-language="elixir"><code class="elixir">def published(query) do
  from p in query, where: not(is_nil(p.published_at))
end</code></pre> <p>Notice we have created a <code class="inline">p</code> variable to reference the query’s original data source. This assumes that the original query only had one source. When the given query has more than one source, a variable must be given for each in the order they were bound:</p> <pre data-language="elixir"><code class="elixir">def published_multi(query) do
  from [p,o] in query,
  where: not(is_nil(p.published_at)) and not(is_nil(o.published_at))
end</code></pre> <p>Note the variables <code class="inline">p</code> and <code class="inline">o</code> can be named whatever you like as they have no importance in the query sent to the database.</p>    <h3 class="detail-header macro" id="group_by/3">  <span class="signature">group_by(query, binding \\ [], expr)</span>  </h3>  <p>A group by query expression.</p> <p>Groups together rows from the schema that have the same values in the given fields. Using <code class="inline">group_by</code> “groups” the query giving it different semantics in the <code class="inline">select</code> expression. If a query is grouped, only fields that were referenced in the <code class="inline">group_by</code> can be used in the <code class="inline">select</code> or if the field is given as an argument to an aggregate function.</p> <p><code class="inline">group_by</code> also accepts a list of atoms where each atom refers to a field in source.</p> <h4>Keywords examples</h4> <pre data-language="elixir"><code class="elixir"># Returns the number of posts in each category
from(p in Post,
  group_by: p.category,
  select: {p.category, count(p.id)})

# Group on all fields on the Post schema
from(p in Post, group_by: p, select: p)

# Using atoms
from(p in Post, group_by: :category, select: {p.category, count(p.id)})</code></pre> <h4>Expressions example</h4> <pre data-language="elixir"><code class="elixir">Post |&gt; group_by([p], p.category) |&gt; select([p], count(p.id))</code></pre>    <h3 class="detail-header macro" id="having/3">  <span class="signature">having(query, binding \\ [], expr)</span>  </h3>  <p>A having query expression.</p> <p>Like <code class="inline">where</code>, <code class="inline">having</code> filters rows from the schema, but after the grouping is performed giving it the same semantics as <code class="inline">select</code> for a grouped query (see <a href="#group_by/3)"><code class="inline">group_by/3</code></a>. <code class="inline">having</code> groups the query even if the query has no <code class="inline">group_by</code> expression.</p> <h4>Keywords example</h4> <pre data-language="elixir"><code class="elixir"># Returns the number of posts in each category where the
# average number of comments is above ten
from(p in Post,
  group_by: p.category,
  having: avg(p.num_comments) &gt; 10,
  select: {p.category, count(p.id)})</code></pre> <h4>Expressions example</h4> <pre data-language="elixir"><code class="elixir">Post
|&gt; group_by([p], p.category)
|&gt; having([p], avg(p.num_comments) &gt; 10)
|&gt; select([p], count(p.id))</code></pre>    <h3 class="detail-header macro" id="join/5">  <span class="signature">join(query, qual, binding \\ [], expr, on \\ nil)</span>  </h3>  <p>A join query expression.</p> <p>Receives a source that is to be joined to the query and a condition for the join. The join condition can be any expression that evaluates to a boolean value. The join is by default an inner join, the qualifier can be changed by giving the atoms: <code class="inline">:inner</code>, <code class="inline">:left</code>, <code class="inline">:right</code> or <code class="inline">:full</code>. For a keyword query the <code class="inline">:join</code> keyword can be changed to: <code class="inline">:inner_join</code>, <code class="inline">:left_join</code>, <code class="inline">:right_join</code> or <code class="inline">:full_join</code>.</p> <p>It is also possible to use the atoms <code class="inline">:inner_lateral</code> and <code class="inline">:left_lateral</code> using the Postgres adapter. See “Joining with fragments” below.</p> <p>Currently it is possible to join on an Ecto.Schema (a module), an existing source (a binary representing a table), an association or a fragment. For a lateral join it is only possible to join on a fragment since the join query must be able to access columns from the left side of the join. See the examples below:</p> <h4>Keywords examples</h4> <pre data-language="elixir"><code class="elixir">from c in Comment,
  join: p in Post, on: c.post_id == p.id,
  select: {p.title, c.text}

from p in Post,
  left_join: c in assoc(p, :comments),
  select: {p, c}</code></pre> <h4>Expressions examples</h4> <pre data-language="elixir"><code class="elixir">Comment
|&gt; join(:inner, [c], p in Post, c.post_id == p.id)
|&gt; select([c, p], {p.title, c.text})

Post
|&gt; join(:left, [p], c in assoc(p, :comments))
|&gt; select([p, c], {p, c})

Post
|&gt; join(:left, [p], c in Comment, c.post_id == p.id and c.is_visible == true)
|&gt; select([p, c], {p, c})</code></pre> <h4>Joining with fragments</h4> <p>When you need to join on a complex expression that cannot be expressed via Ecto associations, Ecto supports fragments in joins:</p> <pre data-language="elixir"><code class="elixir">Comment
|&gt; join(:inner, [c], p in fragment("SOME COMPLEX QUERY", c.id, ^some_param))</code></pre> <p>Although using fragments in joins is discouraged in favor of Ecto Query syntax, they are necessary when writing lateral joins as lateral joins require a subquery that refer to previous bindings:</p> <pre data-language="elixir"><code class="elixir">Game
|&gt; join(:inner_lateral, [g], gs in fragment("SELECT * FROM games_sold AS gs WHERE gs.game_id = ? ORDER BY gs.sold_on LIMIT 2", g.id))
|&gt; select([g, gs], {g.name, gs.sold_on})</code></pre>    <h3 class="detail-header macro" id="limit/3">  <span class="signature">limit(query, binding \\ [], expr)</span>  </h3>  <p>A limit query expression.</p> <p>Limits the number of rows returned from the result. Can be any expression but has to evaluate to an integer value and it can’t include any field.</p> <p>If <code class="inline">limit</code> is given twice, it overrides the previous value.</p> <h4>Keywords example</h4> <pre data-language="elixir"><code class="elixir">from(u in User, where: u.id == ^current_user, limit: 1)</code></pre> <h4>Expressions example</h4> <pre data-language="elixir"><code class="elixir">User |&gt; where([u], u.id == ^current_user) |&gt; limit(1)</code></pre>    <h3 class="detail-header macro" id="lock/2">  <span class="signature">lock(query, expr)</span>  </h3>  <p>A lock query expression.</p> <p>Provides support for row-level pessimistic locking using <code class="inline">SELECT ... FOR UPDATE</code> or other, database-specific, locking clauses. <code class="inline">expr</code> can be any expression but has to evaluate to a boolean value or to a string and it can’t include any fields.</p> <p>If <code class="inline">lock</code> is used more than once, the last one used takes precedence.</p> <p>Ecto also supports <a href="http://en.wikipedia.org/wiki/Optimistic_concurrency_control" target="_blank">optimistic locking</a> but not through queries. For more information on optimistic locking, have a look at the <a href="../ecto.changeset/#optimistic_lock/3"><code class="inline">Ecto.Changeset.optimistic_lock/3</code></a> function</p> <h4>Keywords example</h4> <pre data-language="elixir"><code class="elixir">from(u in User, where: u.id == ^current_user, lock: "FOR SHARE NOWAIT")</code></pre> <h4>Expressions example</h4> <pre data-language="elixir"><code class="elixir">User |&gt; where(u.id == ^current_user) |&gt; lock("FOR SHARE NOWAIT")</code></pre>    <h3 class="detail-header macro" id="offset/3">  <span class="signature">offset(query, binding \\ [], expr)</span>  </h3>  <p>An offset query expression.</p> <p>Offsets the number of rows selected from the result. Can be any expression but it must evaluate to an integer value and it can’t include any field.</p> <p>If <code class="inline">offset</code> is given twice, it overrides the previous value.</p> <h4>Keywords example</h4> <pre data-language="elixir"><code class="elixir"># Get all posts on page 4
from(p in Post, limit: 10, offset: 30)</code></pre> <h4>Expressions example</h4> <pre data-language="elixir"><code class="elixir">Post |&gt; limit(10) |&gt; offset(30)</code></pre>    <h3 class="detail-header macro" id="order_by/3">  <span class="signature">order_by(query, binding \\ [], expr)</span>  </h3>  <p>An order by query expression.</p> <p>Orders the fields based on one or more fields. It accepts a single field or a list of fields. The default direction is ascending (<code class="inline">:asc</code>) and can be customized in a keyword list as shown in the examples. There can be several order by expressions in a query.</p> <p><code class="inline">order_by</code> also accepts a list of atoms where each atom refers to a field in source or a keyword list where the direction is given as key and the field to order as value.</p> <h4>Keywords examples</h4> <pre data-language="elixir"><code class="elixir">from(c in City, order_by: c.name, order_by: c.population)
from(c in City, order_by: [c.name, c.population])
from(c in City, order_by: [asc: c.name, desc: c.population])

from(c in City, order_by: [:name, :population])
from(c in City, order_by: [asc: :name, desc: :population])</code></pre> <p>A keyword list can also be interpolated:</p> <pre data-language="elixir"><code class="elixir">values = [asc: :name, desc: :population]
from(c in City, order_by: ^values)</code></pre> <h4>Expressions example</h4> <pre data-language="elixir"><code class="elixir">City |&gt; order_by([c], asc: c.name, desc: c.population)
City |&gt; order_by(asc: :name) # Sorts by the cities name</code></pre>    <h3 class="detail-header macro" id="preload/3">  <span class="signature">preload(query, bindings \\ [], expr)</span>  </h3>  <p>Preloads the associations into the given struct.</p> <p>Preloading allows developers to specify associations that are preloaded into the struct. Consider this example:</p> <pre data-language="elixir"><code class="elixir">Repo.all from p in Post, preload: [:comments]</code></pre> <p>The example above will fetch all posts from the database and then do a separate query returning all comments associated to the given posts.</p> <p>However, often times, you want posts and comments to be selected and filtered in the same query. For such cases, you can explicitly tell the association to be preloaded into the struct:</p> <pre data-language="elixir"><code class="elixir">Repo.all from p in Post,
           join: c in assoc(p, :comments),
           where: c.published_at &gt; p.updated_at,
           preload: [comments: c]</code></pre> <p>In the example above, instead of issuing a separate query to fetch comments, Ecto will fetch posts and comments in a single query.</p> <p>Nested associations can also be preloaded in both formats:</p> <pre data-language="elixir"><code class="elixir">Repo.all from p in Post,
           preload: [comments: :likes]

Repo.all from p in Post,
           join: c in assoc(p, :comments),
           join: l in assoc(c, :likes),
           where: l.inserted_at &gt; c.updated_at,
           preload: [comments: {c, likes: l}]</code></pre> <p>Keep in mind neither format can be nested arbitrarily. For example, the query below is invalid because we cannot preload likes with the join association <code class="inline">c</code>.</p> <pre data-language="elixir"><code class="elixir">Repo.all from p in Post,
           join: c in assoc(p, :comments),
           preload: [comments: {c, :likes}]</code></pre> <h4>Preload queries</h4> <p>Preload also allows queries to be given, allowing you to filter or customize how the preloads are fetched:</p> <pre data-language="elixir"><code class="elixir">comments_query = from c in Comment, order_by: c.published_at
Repo.all from p in Post, preload: [comments: ^comments_query]</code></pre> <p>The example above will issue two queries, one for loading posts and then another for loading the comments associated with the posts. Comments will be ordered by <code class="inline">published_at</code>.</p> <p>Note: keep in mind operations like limit and offset in the preload query will affect the whole result set and not each association. For example, the query below:</p> <pre data-language="elixir"><code class="elixir">comments_query = from c in Comment, order_by: c.popularity, limit: 5
Repo.all from p in Post, preload: [comments: ^comments_query]</code></pre> <p>won’t bring the top of comments per post. Rather, it will only bring the 5 top comments across all posts.</p> <h4>Preload functions</h4> <p>Preload also allows functions to be given. In such cases, the function receives the IDs to be fetched and it must return the associated data. This data will then be mapped and sorted:</p> <pre data-language="elixir"><code class="elixir">Repo.all from p in Post, preload: [comments: fn _ -&gt; previously_loaded_comments end]</code></pre> <p>This is useful when the whole dataset was already loaded or must be explicitly fetched from elsewhere.</p> <h4>Keywords example</h4> <pre data-language="elixir"><code class="elixir"># Returns all posts, their associated comments, and the associated
# likes for those comments.
from(p in Post,
  preload: [:comments, comments: :likes],
  select: p)</code></pre> <h4>Expressions examples</h4> <pre data-language="elixir"><code class="elixir">Post |&gt; preload(:comments) |&gt; select([p], p)
Post |&gt; join(:left, [p], c in assoc(p, :comments)) |&gt; preload([p, c], [:user, comments: c]) |&gt; select([p], p)</code></pre>    <h3 class="detail-header macro" id="select/3">  <span class="signature">select(query, binding \\ [], expr)</span>  </h3>  <p>A select query expression.</p> <p>Selects which fields will be selected from the schema and any transformations that should be performed on the fields. Any expression that is accepted in a query can be a select field.</p> <p>The sub-expressions in the query can be wrapped in lists, tuples or maps as shown in the examples. A full schema can also be selected.</p> <p>There can only be one select expression in a query, if the select expression is omitted, the query will by default select the full schema.</p> <p><code class="inline">select</code> also accepts a list of atoms where each atom refers to a field in the source to be selected.</p> <h4>Keywords examples</h4> <pre data-language="elixir"><code class="elixir">from(c in City, select: c) # returns the schema as a struct
from(c in City, select: {c.name, c.population})
from(c in City, select: [c.name, c.county])
from(c in City, select: {c.name, ^to_string(40 + 2), 43})
from(c in City, select: %{n: c.name, answer: 42})</code></pre> <p>It is also possible to select a struct and limit the returned fields at the same time:</p> <pre data-language="elixir"><code class="elixir">from(City, select: [:name])</code></pre> <p>The syntax above is equivalent to:</p> <pre data-language="elixir"><code class="elixir">from(city in City, select: struct(city, [:name]))</code></pre> <p>You can also write:</p> <pre data-language="elixir"><code class="elixir">from(city in City, select: map(city, [:name]))</code></pre> <p>If you want a map with only the selected fields to be returned. For more information, read the docs for <a href="../ecto.query.api/#struct/2"><code class="inline">Ecto.Query.API.struct/2</code></a> and <a href="../ecto.query.api/#map/2"><code class="inline">Ecto.Query.API.map/2</code></a>.</p> <h4>Expressions examples</h4> <pre data-language="elixir"><code class="elixir">City |&gt; select([c], c)
City |&gt; select([c], {c.name, c.country})
City |&gt; select([c], %{"name" =&gt; c.name})
City |&gt; select([:name])
City |&gt; select([c], struct(c, [:name]))
City |&gt; select([c], map(c, [:name]))</code></pre>    <h3 class="detail-header macro" id="update/3">  <span class="signature">update(query, binding \\ [], expr)</span>  </h3>  <p>An update query expression.</p> <p>Updates are used to update the filtered entries. In order for updates to be applied, <code class="inline">Ecto.Repo.update_all/3</code> must be invoked.</p> <h4>Keywords example</h4> <pre data-language="elixir"><code class="elixir">from(u in User, update: [set: [name: "new name"]])</code></pre> <h4>Expressions example</h4> <pre data-language="elixir"><code class="elixir">User |&gt; update([u], set: [name: "new name"])
User |&gt; update(set: [name: "new name"])</code></pre> <h4>Operators</h4> <p>The update expression in Ecto supports the following operators:</p> <ul> <li>
<p><code class="inline">set</code> - sets the given field in the table to the given value</p> <pre data-language="elixir"><code class="elixir">from(u in User, update: [set: [name: "new name"]])</code></pre> </li> <li>
<p><code class="inline">inc</code> - increments (or decrements if the value is negative) the given field in the table by the given value</p> <pre data-language="elixir"><code class="elixir">from(u in User, update: [inc: [accesses: 1]])</code></pre> </li> <li>
<p><code class="inline">push</code> - pushes (appends) the given value to the end of the array field</p> <pre data-language="elixir"><code class="elixir">from(u in User, update: [push: [tags: "cool"]])</code></pre> </li> <li>
<p><code class="inline">pull</code> - pulls (removes) the given value from the array field</p> <pre data-language="elixir"><code class="elixir">from(u in User, update: [pull: [tags: "not cool"]])</code></pre> </li> </ul>    <h3 class="detail-header macro" id="where/3">  <span class="signature">where(query, binding \\ [], expr)</span>  </h3>  <p>A where query expression.</p> <p><code class="inline">where</code> expressions are used to filter the result set. If there is more than one where expression, they are combined with an <code class="inline">and</code> operator. All where expressions have to evaluate to a boolean value.</p> <p><code class="inline">where</code> also accepts a keyword list where the field given as key is going to be compared with the given value. The fields will always refer to the source given in <code class="inline">from</code>.</p> <h4>Keywords example</h4> <pre data-language="elixir"><code class="elixir">from(c in City, where: c.state == "Sweden")
from(c in City, where: [state: "Sweden"])</code></pre> <p>It is also possible to interpolate the whole keyword list, allowing you to dynamically filter the source:</p> <pre data-language="elixir"><code class="elixir">filters = [state: "Sweden"]
from(c in City, where: ^filters)</code></pre> <h4>Expressions example</h4> <pre data-language="elixir"><code class="elixir">City |&gt; where([c], c.state == "Sweden")
City |&gt; where(state: "Sweden")</code></pre>
<div class="_attribution">
  <p class="_attribution-p">
    © 2012 Plataformatec<br>Licensed under the Apache License, Version 2.0.<br>
    <a href="https://hexdocs.pm/ecto/Ecto.Query.html" class="_attribution-link" target="_blank">https://hexdocs.pm/ecto/Ecto.Query.html</a>
  </p>
</div>

			</div>
		</div>
	</section>

	</div>
</body>
</html>
