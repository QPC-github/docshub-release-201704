
<!DOCTYPE HTML>

<html lang="en">

<head>
  <meta charset="utf-8">
  <title>Ecto.Query.API - Phoenix - W3cubDocs</title>
  
  <meta name="description" content=" This module lists all functions allowed in the query API. ">
  <meta name="keywords" content="ecto, query, api, summary, functions, -, phoenix">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="http://docs.w3cub.com/phoenix/ecto/ecto.query.api/">
  <link href="/favicon.png" rel="icon">
  <link type="text/css" rel="stylesheet" href="/assets/application-50364fff564ce3b6327021805f3f00e2957b441cf27f576a7dd4ff63bbc47047.css">
  <script type="text/javascript" src="/assets/application-db64bfd54ceb42be11af7995804cf4902548419ceb79d509b0b7d62c22d98e6f.js"></script>
  <script src="/json/phoenix.js"></script>
  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-71174418-1']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>


</head>

<body>
	<div class="_app">
	<header class="_header">
  
  <form class="_search">
    <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
    <a class="_search-clear"></a>
    <div class="_search-tag"></div>
  </form>
  
  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/phoenix/" class="_nav-link" title="" style="margin-left:0;">Phoenix</a></span>
  
  <nav class="_nav">
    <a href="/app/" class="_nav-link ">App</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		<div class="_list">
			
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<div class="_page _elixir">
				
<h1>  Ecto.Query.API  </h1>  <p>This module lists all functions allowed in the query API.</p> <ul> <li>Comparison operators: <code class="inline">==</code>, <code class="inline">!=</code>, <code class="inline">&lt;=</code>, <code class="inline">&gt;=</code>, <code class="inline">&lt;</code>, <code class="inline">&gt;</code> </li> <li>Boolean operators: <code class="inline">and</code>, <code class="inline">or</code>, <code class="inline">not</code> </li> <li>Inclusion operator: <a href="#in/2"><code class="inline">in/2</code></a> </li> <li>Search functions: <a href="#like/2"><code class="inline">like/2</code></a> and <a href="#ilike/2"><code class="inline">ilike/2</code></a> </li> <li>Null check functions: <a href="#is_nil/1"><code class="inline">is_nil/1</code></a> </li> <li>Aggregates: <a href="#count/1"><code class="inline">count/1</code></a>, <a href="#avg/1"><code class="inline">avg/1</code></a>, <a href="#sum/1"><code class="inline">sum/1</code></a>, <a href="#min/1"><code class="inline">min/1</code></a>, <a href="#max/1"><code class="inline">max/1</code></a> </li> <li>Date/time intervals: <a href="#datetime_add/3"><code class="inline">datetime_add/3</code></a>, <a href="#date_add/3"><code class="inline">date_add/3</code></a>, <a href="#from_now/2"><code class="inline">from_now/2</code></a>, <a href="#ago/2"><code class="inline">ago/2</code></a> </li> <li>Inside select: <a href="#struct/2"><code class="inline">struct/2</code></a>, <a href="#map/2"><code class="inline">map/2</code></a> and literals (map, tuples, lists, etc) </li> <li>General: <a href="#fragment/1"><code class="inline">fragment/1</code></a>, <a href="#field/2"><code class="inline">field/2</code></a> and <a href="#type/2"><code class="inline">type/2</code></a> </li> </ul> <p>Note the functions in this module exist for documentation purposes and one should never need to invoke them directly. Furthermore, it is possible to define your own macros and use them in Ecto queries (see docs for <a href="#fragment/1)"><code class="inline">fragment/1</code></a>.</p>   <h1 class="section-heading" id="summary">  Summary </h1> <h2> Functions </h2>
<dl class="summary-functions summary">   <dt class="summary-signature"> <a href="#!=/2">left != right</a> </dt> <dd class="summary-synopsis">
<p>Binary <code class="inline">!=</code> operation</p> </dd>   <dt class="summary-signature"> <a href="#%3C/2">left &lt; right</a> </dt> <dd class="summary-synopsis">
<p>Binary <code class="inline">&lt;</code> operation</p> </dd>   <dt class="summary-signature"> <a href="#%3C=/2">left &lt;= right</a> </dt> <dd class="summary-synopsis">
<p>Binary <code class="inline">&lt;=</code> operation</p> </dd>   <dt class="summary-signature"> <a href="#==/2">left == right</a> </dt> <dd class="summary-synopsis">
<p>Binary <code class="inline">==</code> operation</p> </dd>   <dt class="summary-signature"> <a href="#%3E/2">left &gt; right</a> </dt> <dd class="summary-synopsis">
<p>Binary <code class="inline">&gt;</code> operation</p> </dd>   <dt class="summary-signature"> <a href="#%3E=/2">left &gt;= right</a> </dt> <dd class="summary-synopsis">
<p>Binary <code class="inline">&gt;=</code> operation</p> </dd>   <dt class="summary-signature"> <a href="#ago/2">ago(count, interval)</a> </dt> <dd class="summary-synopsis">
<p>Substracts the given interval from the current time in UTC</p> </dd>   <dt class="summary-signature"> <a href="#and/2">left and right</a> </dt> <dd class="summary-synopsis">
<p>Binary <code class="inline">and</code> operation</p> </dd>   <dt class="summary-signature"> <a href="#avg/1">avg(value)</a> </dt> <dd class="summary-synopsis">
<p>Calculates the average for the given entry</p> </dd>   <dt class="summary-signature"> <a href="#count/1">count(value)</a> </dt> <dd class="summary-synopsis">
<p>Counts the given entry</p> </dd>   <dt class="summary-signature"> <a href="#count/2">count(value, atom)</a> </dt> <dd class="summary-synopsis">
<p>Counts the distinct values in given entry</p> </dd>   <dt class="summary-signature"> <a href="#date_add/3">date_add(date, count, interval)</a> </dt> <dd class="summary-synopsis">
<p>Adds a given interval to a date</p> </dd>   <dt class="summary-signature"> <a href="#datetime_add/3">datetime_add(datetime, count, interval)</a> </dt> <dd class="summary-synopsis">
<p>Adds a given interval to a datetime</p> </dd>   <dt class="summary-signature"> <a href="#field/2">field(source, field)</a> </dt> <dd class="summary-synopsis">
<p>Allows a field to be dynamically accessed</p> </dd>   <dt class="summary-signature"> <a href="#fragment/1">fragment(fragments)</a> </dt> <dd class="summary-synopsis">
<p>Send fragments directly to the database</p> </dd>   <dt class="summary-signature"> <a href="#from_now/2">from_now(count, interval)</a> </dt> <dd class="summary-synopsis">
<p>Adds the given interval to the current time in UTC</p> </dd>   <dt class="summary-signature"> <a href="#ilike/2">ilike(string, search)</a> </dt> <dd class="summary-synopsis">
<p>Searches for <code class="inline">search</code> in <code class="inline">string</code> in a case insensitive fashion</p> </dd>   <dt class="summary-signature"> <a href="#in/2">left in right</a> </dt> <dd class="summary-synopsis">
<p>Checks if the left-value is included in the right one</p> </dd>   <dt class="summary-signature"> <a href="#is_nil/1">is_nil(value)</a> </dt> <dd class="summary-synopsis">
<p>Checks if the given value is nil</p> </dd>   <dt class="summary-signature"> <a href="#like/2">like(string, search)</a> </dt> <dd class="summary-synopsis">
<p>Searches for <code class="inline">search</code> in <code class="inline">string</code></p> </dd>   <dt class="summary-signature"> <a href="#map/2">map(source, fields)</a> </dt> <dd class="summary-synopsis">
<p>Used in <code class="inline">select</code> to specify which fields should be returned as a map</p> </dd>   <dt class="summary-signature"> <a href="#max/1">max(value)</a> </dt> <dd class="summary-synopsis">
<p>Calculates the maximum for the given entry</p> </dd>   <dt class="summary-signature"> <a href="#min/1">min(value)</a> </dt> <dd class="summary-synopsis">
<p>Calculates the minimum for the given entry</p> </dd>   <dt class="summary-signature"> <a href="#not/1">not value</a> </dt> <dd class="summary-synopsis">
<p>Unary <code class="inline">not</code> operation</p> </dd>   <dt class="summary-signature"> <a href="#or/2">left or right</a> </dt> <dd class="summary-synopsis">
<p>Binary <code class="inline">or</code> operation</p> </dd>   <dt class="summary-signature"> <a href="#struct/2">struct(source, fields)</a> </dt> <dd class="summary-synopsis">
<p>Used in <code class="inline">select</code> to specify which struct fields should be returned</p> </dd>   <dt class="summary-signature"> <a href="#sum/1">sum(value)</a> </dt> <dd class="summary-synopsis">
<p>Calculates the sum for the given entry</p> </dd>   <dt class="summary-signature"> <a href="#type/2">type(interpolated_value, type)</a> </dt> <dd class="summary-synopsis">
<p>Casts the given value to the given type</p> </dd>  </dl>   <h1 class="section-heading" id="functions">  Functions </h1>  <h3 class="detail-header function" id="!=/2">  <span class="signature">left != right</span>  </h3>  <p>Binary <code class="inline">!=</code> operation.</p>    <h3 class="detail-header function" id="%3C/2">  <span class="signature">left &lt; right</span>  </h3>  <p>Binary <code class="inline">&lt;</code> operation.</p>    <h3 class="detail-header function" id="%3C=/2">  <span class="signature">left &lt;= right</span>  </h3>  <p>Binary <code class="inline">&lt;=</code> operation.</p>    <h3 class="detail-header function" id="==/2">  <span class="signature">left == right</span>  </h3>  <p>Binary <code class="inline">==</code> operation.</p>    <h3 class="detail-header function" id="%3E/2">  <span class="signature">left &gt; right</span>  </h3>  <p>Binary <code class="inline">&gt;</code> operation.</p>    <h3 class="detail-header function" id="%3E=/2">  <span class="signature">left &gt;= right</span>  </h3>  <p>Binary <code class="inline">&gt;=</code> operation.</p>    <h3 class="detail-header function" id="ago/2">  <span class="signature">ago(count, interval)</span>  </h3>  <p>Substracts the given interval from the current time in UTC.</p> <p>The current time in UTC is retrieved from Elixir and not from the database.</p> <h4>Examples</h4> <pre data-language="elixir"><code class="elixir">from p in Post, where: p.published_at &gt; ago(3, "month")</code></pre>    <h3 class="detail-header function" id="and/2">  <span class="signature">left and right</span>  </h3>  <p>Binary <code class="inline">and</code> operation.</p>    <h3 class="detail-header function" id="avg/1">  <span class="signature">avg(value)</span>  </h3>  <p>Calculates the average for the given entry.</p> <pre data-language="elixir"><code class="elixir">from p in Payment, select: avg(p.value)</code></pre>    <h3 class="detail-header function" id="count/1">  <span class="signature">count(value)</span>  </h3>  <p>Counts the given entry.</p> <pre data-language="elixir"><code class="elixir">from p in Post, select: count(p.id)</code></pre>    <h3 class="detail-header function" id="count/2">  <span class="signature">count(value, atom)</span>  </h3>  <p>Counts the distinct values in given entry.</p> <pre data-language="elixir"><code class="elixir">from p in Post, select: count(p.id, :distinct)</code></pre>    <h3 class="detail-header function" id="date_add/3">  <span class="signature">date_add(date, count, interval)</span>  </h3>  <p>Adds a given interval to a date.</p> <p>See <a href="#datetime_add/3"><code class="inline">datetime_add/3</code></a> for more information.</p>    <h3 class="detail-header function" id="datetime_add/3">  <span class="signature">datetime_add(datetime, count, interval)</span>  </h3>  <p>Adds a given interval to a datetime.</p> <p>The first argument is a <code class="inline">datetime</code>, the second one is the count for the interval, which may be either positive or negative and the interval value:</p> <pre data-language="elixir"><code class="elixir"># Get all items published since the last month
from p in Post, where: p.published_at &gt;
                       datetime_add(^Ecto.DateTime.utc, -1, "month")</code></pre> <p>In the example above, we used <a href="#datetime_add/3"><code class="inline">datetime_add/3</code></a> to subtract one month from the current datetime and compared it with the <code class="inline">p.published_at</code>. If you want to perform operations on date, <a href="#date_add/3"><code class="inline">date_add/3</code></a> could be used.</p> <p>The following intervals are supported: year, month, week, day, hour, minute, second, millisecond and microsecond.</p>    <h3 class="detail-header function" id="field/2">  <span class="signature">field(source, field)</span>  </h3>  <p>Allows a field to be dynamically accessed.</p> <pre data-language="elixir"><code class="elixir">def at_least_four(doors_or_tires) do
    from c in Car,
  where: field(c, ^doors_or_tires) &gt;= 4
end</code></pre> <p>In the example above, both <code class="inline">at_least_four(:doors)</code> and <code class="inline">at_least_four(:tires)</code> would be valid calls as the field is dynamically generated.</p>    <h3 class="detail-header function" id="fragment/1">  <span class="signature">fragment(fragments)</span>  </h3>  <p>Send fragments directly to the database.</p> <p>It is not possible to represent all possible database queries using Ecto’s query syntax. When such is required, it is possible to use fragments to send any expression to the database:</p> <pre data-language="elixir"><code class="elixir">def unpublished_by_title(title) do
  from p in Post,
    where: is_nil(p.published_at) and
           fragment("lower(?)", p.title) == ^title
end</code></pre> <p>In the example above, we are using the lower procedure in the database to downcase the title column.</p> <p>It is very important to keep in mind that Ecto is unable to do any type casting described above when fragments are used. You can however use the <a href="#type/2"><code class="inline">type/2</code></a> function to give Ecto some hints:</p> <pre data-language="elixir"><code class="elixir">fragment("lower(?)", p.title) == type(^title, :string)</code></pre> <p>Or even say the right side is of the same type as <code class="inline">p.title</code>:</p> <pre data-language="elixir"><code class="elixir">fragment("lower(?)", p.title) == type(^title, p.title)</code></pre> <p>It is possible to make use of PostgreSQL’s JSON/JSONB data type with fragments, as well:</p> <pre data-language="elixir"><code class="elixir">fragment("?-&gt;&gt;? ILIKE ?", p.map, "key_name", ^some_value)</code></pre> <h4>Keyword fragments</h4> <p>In order to support databases that do not have string-based queries, like MongoDB, fragments also allow keywords to be given:</p> <pre data-language="elixir"><code class="elixir">from p in Post,
    where: fragment(title: ["$eq": ^some_value])</code></pre> <h4>Defining custom functions using macros and fragment</h4> <p>You can add a custom Ecto query function using macros. For example to expose SQL’s coalesce function you can define this macro:</p> <pre data-language="elixir"><code class="elixir">defmodule CustomFunctions do
  defmacro coalesce(left, right) do
    quote do
      fragment("coalesce(?, ?)", unquote(left), unquote(right))
    end
  end
end</code></pre> <p>To have coalesce/2 available, just import the module that defines it.</p> <pre data-language="elixir"><code class="elixir">import CustomFunctions</code></pre> <p>The only downside is that it will show up as a fragment when inspecting the Elixir query. Other than that, it should be equivalent to a built-in Ecto query function.</p>    <h3 class="detail-header function" id="from_now/2">  <span class="signature">from_now(count, interval)</span>  </h3>  <p>Adds the given interval to the current time in UTC.</p> <p>The current time in UTC is retrieved from Elixir and not from the database.</p> <h4>Examples</h4> <pre data-language="elixir"><code class="elixir">from a in Account, where: a.expires_at &lt; from_now(3, "month")</code></pre>    <h3 class="detail-header function" id="ilike/2">  <span class="signature">ilike(string, search)</span>  </h3>  <p>Searches for <code class="inline">search</code> in <code class="inline">string</code> in a case insensitive fashion.</p> <pre data-language="elixir"><code class="elixir">from p in Post, where: ilike(p.body, "Chapter%")</code></pre> <p>Translates to the underlying SQL ILIKE query. This operation is only available on PostgreSQL.</p>    <h3 class="detail-header function" id="in/2">  <span class="signature">left in right</span>  </h3>  <p>Checks if the left-value is included in the right one.</p> <pre data-language="elixir"><code class="elixir">from p in Post, where: p.id in [1, 2, 3]</code></pre> <p>The right side may either be a list, a literal list or even a column in the database with array type:</p> <pre data-language="elixir"><code class="elixir">from p in Post, where: "elixir" in p.tags</code></pre>    <h3 class="detail-header function" id="is_nil/1">  <span class="signature">is_nil(value)</span>  </h3>  <p>Checks if the given value is nil.</p> <pre data-language="elixir"><code class="elixir">from p in Post, where: is_nil(p.published_at)</code></pre>    <h3 class="detail-header function" id="like/2">  <span class="signature">like(string, search)</span>  </h3>  <p>Searches for <code class="inline">search</code> in <code class="inline">string</code>.</p> <pre data-language="elixir"><code class="elixir">from p in Post, where: like(p.body, "Chapter%")</code></pre> <p>Translates to the underlying SQL LIKE query, therefore its behaviour is dependent on the database. In particular, PostgreSQL will do a case-sensitive operation, while the majority of other databases will be case-insensitive. For performing a case-insensitive <code class="inline">like</code> in PostgreSQL, see <a href="#ilike/2"><code class="inline">ilike/2</code></a>.</p>    <h3 class="detail-header function" id="map/2">  <span class="signature">map(source, fields)</span>  </h3>  <p>Used in <code class="inline">select</code> to specify which fields should be returned as a map.</p> <p>For example, if you don’t need all fields to be returned or neither need a struct, you can use <a href="#map/2"><code class="inline">map/2</code></a> to achieve both:</p> <pre data-language="elixir"><code class="elixir">from p in Post,
  select: map(p, [:title, :body])</code></pre> <p><a href="#map/2"><code class="inline">map/2</code></a> can also be used to dynamically select fields:</p> <pre data-language="elixir"><code class="elixir">fields = [:title, :body]
from p in Post, select: map(p, ^fields)</code></pre> <p><a href="#map/2"><code class="inline">map/2</code></a> is also useful when you want to limit the fields of different structs:</p> <pre data-language="elixir"><code class="elixir">from(city in City, join: country in assoc(city, :country),
     select: {map(city, [:country_id, :name]), map(country, [:id, :population])}</code></pre> <p>For preloads, the selected fields may be specified from the parent:</p> <pre data-language="elixir"><code class="elixir">from(city in City, preload: :country,
     select: map(city, [:country_id, :name, country: [:id, :population]]))</code></pre> <p><strong>IMPORTANT</strong>: When filtering fields for associations, you MUST include the foreign keys used in the relationship, otherwise Ecto will be unable to find associated records.</p>    <h3 class="detail-header function" id="max/1">  <span class="signature">max(value)</span>  </h3>  <p>Calculates the maximum for the given entry.</p> <pre data-language="elixir"><code class="elixir">from p in Payment, select: max(p.value)</code></pre>    <h3 class="detail-header function" id="min/1">  <span class="signature">min(value)</span>  </h3>  <p>Calculates the minimum for the given entry.</p> <pre data-language="elixir"><code class="elixir">from p in Payment, select: min(p.value)</code></pre>    <h3 class="detail-header function" id="not/1">  <span class="signature">not value</span>  </h3>  <p>Unary <code class="inline">not</code> operation.</p>    <h3 class="detail-header function" id="or/2">  <span class="signature">left or right</span>  </h3>  <p>Binary <code class="inline">or</code> operation.</p>    <h3 class="detail-header function" id="struct/2">  <span class="signature">struct(source, fields)</span>  </h3>  <p>Used in <code class="inline">select</code> to specify which struct fields should be returned.</p> <p>For example, if you don’t need all fields to be returned as part of a struct, you can filter it to include only certain fields by using <a href="#struct/2"><code class="inline">struct/2</code></a>:</p> <pre data-language="elixir"><code class="elixir">from p in Post,
  select: struct(p, [:title, :body])</code></pre> <p><a href="#struct/2"><code class="inline">struct/2</code></a> can also be used to dynamically select fields:</p> <pre data-language="elixir"><code class="elixir">fields = [:title, :body]
from p in Post, select: struct(p, ^fields)</code></pre> <p>As a convenience, <code class="inline">select</code> allows developers to take fields without an explicit call to <a href="#struct/2"><code class="inline">struct/2</code></a>:</p> <pre data-language="elixir"><code class="elixir">from p in Post, select: [:title, :body]</code></pre> <p>Or even dynamically:</p> <pre data-language="elixir"><code class="elixir">fields = [:title, :body]
from p in Post, select: ^fields</code></pre> <p>However, <a href="#struct/2"><code class="inline">struct/2</code></a> is still useful when you want to limit the fields of different structs:</p> <pre data-language="elixir"><code class="elixir">from(city in City, join: country in assoc(city, :country),
     select: {struct(city, [:country_id, :name]), struct(country, [:id, :population])}</code></pre> <p>For preloads, the selected fields may be specified from the parent:</p> <pre data-language="elixir"><code class="elixir">from(city in City, preload: :country,
     select: struct(city, [:country_id, :name, country: [:id, :population]]))</code></pre> <p><strong>IMPORTANT</strong>: When filtering fields for associations, you MUST include the foreign keys used in the relationship, otherwise Ecto will be unable to find associated records.</p>    <h3 class="detail-header function" id="sum/1">  <span class="signature">sum(value)</span>  </h3>  <p>Calculates the sum for the given entry.</p> <pre data-language="elixir"><code class="elixir">from p in Payment, select: sum(p.value)</code></pre>    <h3 class="detail-header function" id="type/2">  <span class="signature">type(interpolated_value, type)</span>  </h3>  <p>Casts the given value to the given type.</p> <p>Most of the times, Ecto is able to proper cast interpolated values due to its type checking mechanism. In some situations though, in particular when using fragments with <a href="#fragment/1"><code class="inline">fragment/1</code></a>, you may want to tell Ecto you are expecting a particular type:</p> <pre data-language="elixir"><code class="elixir">fragment("lower(?)", p.title) == type(^title, :string)</code></pre> <p>It is also possible to say the type must match the same of a column:</p> <pre data-language="elixir"><code class="elixir">fragment("lower(?)", p.title) == type(^title, p.title)</code></pre>
<div class="_attribution">
  <p class="_attribution-p">
    © 2012 Plataformatec<br>Licensed under the Apache License, Version 2.0.<br>
    <a href="https://hexdocs.pm/ecto/Ecto.Query.API.html" class="_attribution-link" target="_blank">https://hexdocs.pm/ecto/Ecto.Query.API.html</a>
  </p>
</div>

			</div>
		</div>
	</section>

	</div>
</body>
</html>
