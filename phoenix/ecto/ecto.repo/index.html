
<!DOCTYPE HTML>

<html lang="en">

<head>
  <meta charset="utf-8">
  <title>Ecto.Repo - Phoenix - W3cubDocs</title>
  
  <meta name="description" content=" Defines a repository. ">
  <meta name="keywords" content="ecto, repo, summary, types, callbacks, -, phoenix">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="http://docs.w3cub.com/phoenix/ecto/ecto.repo/">
  <link href="/favicon.png" rel="icon">
  <link type="text/css" rel="stylesheet" href="/assets/application-50364fff564ce3b6327021805f3f00e2957b441cf27f576a7dd4ff63bbc47047.css">
  <script type="text/javascript" src="/assets/application-db64bfd54ceb42be11af7995804cf4902548419ceb79d509b0b7d62c22d98e6f.js"></script>
  <script src="/json/phoenix.js"></script>
  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-71174418-1']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>


</head>

<body>
	<div class="_app">
	<header class="_header">
  
  <form class="_search">
    <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
    <a class="_search-clear"></a>
    <div class="_search-tag"></div>
  </form>
  
  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/phoenix/" class="_nav-link" title="" style="margin-left:0;">Phoenix</a></span>
  
  <nav class="_nav">
    <a href="/app/" class="_nav-link ">App</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		<div class="_list">
			
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<div class="_page _elixir">
				
<h1>  Ecto.Repo <small>behaviour</small>  </h1>  <p>Defines a repository.</p> <p>A repository maps to an underlying data store, controlled by the adapter. For example, Ecto ships with a Postgres adapter that stores data into a PostgreSQL database.</p> <p>When used, the repository expects the <code class="inline">:otp_app</code> as option. The <code class="inline">:otp_app</code> should point to an OTP application that has the repository configuration. For example, the repository:</p> <pre data-language="elixir"><code class="elixir">defmodule Repo do
  use Ecto.Repo, otp_app: :my_app
end</code></pre> <p>Could be configured with:</p> <pre data-language="elixir"><code class="elixir">config :my_app, Repo,
  adapter: Ecto.Adapters.Postgres,
  database: "ecto_simple",
  username: "postgres",
  password: "postgres",
  hostname: "localhost"</code></pre> <p>Most of the configuration that goes into the <code class="inline">config</code> is specific to the adapter, so check <a href="../ecto.adapters.postgres/"><code class="inline">Ecto.Adapters.Postgres</code></a> documentation for more information. However, some configuration is shared across all adapters, they are:</p> <ul> <li>
<p><code class="inline">:priv</code> - the directory where to keep repository data, like migrations, schema and more. Defaults to “priv/YOUR_REPO”. It must always point to a subdirectory inside the priv directory.</p> </li> <li>
<p><code class="inline">:url</code> - an URL that specifies storage information. Read below for more information</p> </li> <li>
<code class="inline">:loggers</code> - a list of <code class="inline">{mod, fun, args}</code> tuples that are invoked by adapters for logging queries and other events. The given module and function will be called with a log entry (see <a href="../ecto.logentry.html)/"><code class="inline">Ecto.LogEntry</code></a> and the given arguments. The invoked function must return the <a href="../ecto.logentry/"><code class="inline">Ecto.LogEntry</code></a> as result. The default value is: <code class="inline">[{Ecto.LogEntry, :log, []}]</code>, which will call <a href="../ecto.logentry/#log/1"><code class="inline">Ecto.LogEntry.log/1</code></a> that will use Elixir’s <code class="inline">Logger</code> in <code class="inline">:debug</code> mode. You may pass any desired mod-fun-args triplet or <code class="inline">[{Ecto.LogEntry, :log, [:info]}]</code> if you want to keep the current behaviour but use another log level. </li> </ul> <h2 id="module-urls" class="section-heading">  URLs </h2> <p>Repositories by default support URLs. For example, the configuration above could be rewritten to:</p> <pre data-language="elixir"><code class="elixir">config :my_app, Repo,
  url: "ecto://postgres:postgres@localhost/ecto_simple"</code></pre> <p>The schema can be of any value. The path represents the database name while options are simply merged in.</p> <p>URLs also support <code class="inline">{:system, "KEY"}</code> to be given, telling Ecto to load the configuration from the system environment instead:</p> <pre data-language="elixir"><code class="elixir">config :my_app, Repo,
  url: {:system, "DATABASE_URL"}</code></pre> <h2 id="module-shared-options" class="section-heading">  Shared options </h2> <p>Almost all of the repository operations below accept the following options:</p> <ul> <li>
<code class="inline">:timeout</code> - The time in milliseconds to wait for the query call to finish, <code class="inline">:infinity</code> will wait indefinitely (default: 15000); </li> <li>
<code class="inline">:pool_timeout</code> - The time in milliseconds to wait for calls to the pool to finish, <code class="inline">:infinity</code> will wait indefinitely (default: 5000); </li> <li>
<code class="inline">:log</code> - When false, does not log the query </li> </ul> <p>Such cases will be explicitly documented as well as any extra option.</p>   <h1 class="section-heading" id="summary">  Summary </h1> <h2> Types </h2>
<dl class="summary-types summary">   <dt class="summary-signature"> <a href="#t:t/0">t()</a> </dt>  </dl> <h2> Callbacks </h2>
<dl class="summary-callbacks summary">   <dt class="summary-signature"> <a href="#c:__adapter__/0">__adapter__()</a> </dt> <dd class="summary-synopsis">
<p>Returns the adapter tied to the repository</p> </dd>   <dt class="summary-signature"> <a href="#c:__log__/1">__log__(entry)</a> </dt> <dd class="summary-synopsis">
<p>A callback invoked by adapters that logs the given action</p> </dd>   <dt class="summary-signature"> <a href="#c:aggregate/4">aggregate(queryable, aggregate, field, opts)</a> </dt> <dd class="summary-synopsis">
<p>Calculate the given <code class="inline">aggregate</code> over the given <code class="inline">field</code></p> </dd>   <dt class="summary-signature"> <a href="#c:all/2">all(queryable, opts)</a> </dt> <dd class="summary-synopsis">
<p>Fetches all entries from the data store matching the given query</p> </dd>   <dt class="summary-signature"> <a href="#c:config/0">config()</a> </dt> <dd class="summary-synopsis">
<p>Returns the adapter configuration stored in the <code class="inline">:otp_app</code> environment</p> </dd>   <dt class="summary-signature"> <a href="#c:delete/2">delete(struct_or_changeset, opts)</a> </dt> <dd class="summary-synopsis">
<p>Deletes a struct using its primary key</p> </dd>   <dt class="summary-signature"> <a href="#c:delete!/2">delete!(struct_or_changeset, opts)</a> </dt> <dd class="summary-synopsis">
<p>Same as <code class="inline">delete/2</code> but returns the struct or raises if the changeset is invalid</p> </dd>   <dt class="summary-signature"> <a href="#c:delete_all/2">delete_all(queryable, opts)</a> </dt> <dd class="summary-synopsis">
<p>Deletes all entries matching the given query</p> </dd>   <dt class="summary-signature"> <a href="#c:get/3">get(queryable, id, opts)</a> </dt> <dd class="summary-synopsis">
<p>Fetches a single struct from the data store where the primary key matches the given id</p> </dd>   <dt class="summary-signature"> <a href="#c:get!/3">get!(queryable, id, opts)</a> </dt> <dd class="summary-synopsis">
<p>Similar to <code class="inline">get/3</code> but raises <a href="../ecto.noresultserror/"><code class="inline">Ecto.NoResultsError</code></a> if no record was found</p> </dd>   <dt class="summary-signature"> <a href="#c:get_by/3">get_by(queryable, clauses, opts)</a> </dt> <dd class="summary-synopsis">
<p>Fetches a single result from the query</p> </dd>   <dt class="summary-signature"> <a href="#c:get_by!/3">get_by!(queryable, clauses, opts)</a> </dt> <dd class="summary-synopsis">
<p>Similar to <code class="inline">get_by/3</code> but raises <a href="../ecto.noresultserror/"><code class="inline">Ecto.NoResultsError</code></a> if no record was found</p> </dd>   <dt class="summary-signature"> <a href="#c:in_transaction?/0">in_transaction?()</a> </dt> <dd class="summary-synopsis">
<p>Returns true if the current process is inside a transaction</p> </dd>   <dt class="summary-signature"> <a href="#c:insert/2">insert(struct_or_changeset, opts)</a> </dt> <dd class="summary-synopsis">
<p>Inserts a struct or a changeset</p> </dd>   <dt class="summary-signature"> <a href="#c:insert!/2">insert!(struct_or_changeset, opts)</a> </dt> <dd class="summary-synopsis">
<p>Same as <code class="inline">insert/2</code> but returns the struct or raises if the changeset is invalid</p> </dd>   <dt class="summary-signature"> <a href="#c:insert_all/3">insert_all(schema_or_source, entries, opts)</a> </dt> <dd class="summary-synopsis">
<p>Inserts all entries into the repository</p> </dd>   <dt class="summary-signature"> <a href="#c:insert_or_update/2">insert_or_update(changeset, opts)</a> </dt> <dd class="summary-synopsis">
<p>Inserts or updates a changeset depending on whether the struct is persisted or not</p> </dd>   <dt class="summary-signature"> <a href="#c:insert_or_update!/2">insert_or_update!(changeset, opts)</a> </dt> <dd class="summary-synopsis">
<p>Same as <code class="inline">insert_or_update/2</code> but returns the struct or raises if the changeset is invalid</p> </dd>   <dt class="summary-signature"> <a href="#c:one/2">one(queryable, opts)</a> </dt> <dd class="summary-synopsis">
<p>Fetches a single result from the query</p> </dd>   <dt class="summary-signature"> <a href="#c:one!/2">one!(queryable, opts)</a> </dt> <dd class="summary-synopsis">
<p>Similar to <code class="inline">one/2</code> but raises <a href="../ecto.noresultserror/"><code class="inline">Ecto.NoResultsError</code></a> if no record was found</p> </dd>   <dt class="summary-signature"> <a href="#c:preload/3">preload(struct_or_structs, preloads, opts)</a> </dt> <dd class="summary-synopsis">
<p>Preloads all associations on the given struct or structs</p> </dd>   <dt class="summary-signature"> <a href="#c:rollback/1">rollback(value)</a> </dt> <dd class="summary-synopsis">
<p>Rolls back the current transaction</p> </dd>   <dt class="summary-signature"> <a href="#c:start_link/1">start_link(opts)</a> </dt> <dd class="summary-synopsis">
<p>Starts any connection pooling or supervision and return <code class="inline">{:ok, pid}</code> or just <code class="inline">:ok</code> if nothing needs to be done</p> </dd>   <dt class="summary-signature"> <a href="#c:stop/2">stop(pid, timeout)</a> </dt> <dd class="summary-synopsis">
<p>Shuts down the repository represented by the given pid</p> </dd>   <dt class="summary-signature"> <a href="#c:transaction/2">transaction(fun_or_multi, opts)</a> </dt> <dd class="summary-synopsis">
<p>Runs the given function or <a href="../ecto.multi/"><code class="inline">Ecto.Multi</code></a> inside a transaction</p> </dd>   <dt class="summary-signature"> <a href="#c:update/2">update(changeset, opts)</a> </dt> <dd class="summary-synopsis">
<p>Updates a changeset using its primary key</p> </dd>   <dt class="summary-signature"> <a href="#c:update!/2">update!(changeset, opts)</a> </dt> <dd class="summary-synopsis">
<p>Same as <code class="inline">update/2</code> but returns the struct or raises if the changeset is invalid</p> </dd>   <dt class="summary-signature"> <a href="#c:update_all/3">update_all(queryable, updates, opts)</a> </dt> <dd class="summary-synopsis">
<p>Updates all entries matching the given query with the given values</p> </dd>  </dl>   <h1 class="section-heading" id="types">  Types </h1>  <div id="t:t/0" class="type-detail"> <pre data-language="elixir"><code class="elixir"><a href="#t:t/0">t</a> :: module</code></pre> </div>    <h1 class="section-heading" id="callbacks">  Callbacks </h1>  <h3 class="detail-header callback" id="c:__adapter__/0">  <span class="signature">__adapter__()</span>  </h3>  <h4 class="specs-title">Specs</h4>  <pre data-language="elixir"><code class="elixir">__adapter__ :: <a href="../ecto.adapter/#t:t/0">Ecto.Adapter.t</a></code></pre>    <p>Returns the adapter tied to the repository.</p>    <h3 class="detail-header callback" id="c:__log__/1">  <span class="signature">__log__(entry)</span>  </h3>  <h4 class="specs-title">Specs</h4>  <pre data-language="elixir"><code class="elixir">__log__(entry :: <a href="../ecto.logentry/#t:t/0">Ecto.LogEntry.t</a>) :: <a href="../ecto.logentry/#t:t/0">Ecto.LogEntry.t</a></code></pre>    <p>A callback invoked by adapters that logs the given action.</p> <p>See <a href="../ecto.logentry/"><code class="inline">Ecto.LogEntry</code></a> for more information and <a href="../ecto.repo/#content"><code class="inline">Ecto.Repo</code></a> module documentation on setting up your own loggers.</p>    <h3 class="detail-header callback" id="c:aggregate/4">  <span class="signature">aggregate(queryable, aggregate, field, opts)</span>  </h3>  <h4 class="specs-title">Specs</h4>  <pre data-language="elixir"><code class="elixir">aggregate(queryable :: <a href="../ecto.queryable/#t:t/0">Ecto.Queryable.t</a>, aggregate :: :avg | :count | :max | :min | :sum, field :: atom, opts :: <a href="http://elixir-lang.org/docs/stable/elixir/Keyword.html#t:t/0" target="_blank">Keyword.t</a>) ::
  term |
  nil</code></pre>    <p>Calculate the given <code class="inline">aggregate</code> over the given <code class="inline">field</code>.</p> <p>If the query has a limit, offset or distinct set, it will be automatically wrapped in a subquery in order to return the proper result.</p> <p>Any preload or select in the query will be ignored in favor of the column being aggregated.</p> <p>The aggregation will fail if any <code class="inline">group_by</code> field is set.</p> <h4>Options</h4> <p>See the “Shared options” section at the module documentation.</p> <h4>Examples</h4> <pre data-language="elixir"><code class="elixir"># Returns the number of visits per blog post
Repo.aggregate(Post, :count, :visits)

# Returns the average number of visits for the top 10
query = from Post, limit: 10
Repo.aggregate(query, :avg, :visits)</code></pre>    <h3 class="detail-header callback" id="c:all/2">  <span class="signature">all(queryable, opts)</span>  </h3>  <h4 class="specs-title">Specs</h4>  <pre data-language="elixir"><code class="elixir">all(queryable :: <a href="../ecto.query/#t:t/0">Ecto.Query.t</a>, opts :: <a href="http://elixir-lang.org/docs/stable/elixir/Keyword.html#t:t/0" target="_blank">Keyword.t</a>) ::
  [<a href="../ecto.schema/#t:t/0">Ecto.Schema.t</a>] |
  no_return</code></pre>    <p>Fetches all entries from the data store matching the given query.</p> <p>May raise <a href="../ecto.queryerror/"><code class="inline">Ecto.QueryError</code></a> if query validation fails.</p> <h4>Options</h4> <p>See the “Shared options” section at the module documentation.</p> <h4>Example</h4> <pre data-language="elixir"><code class="elixir"># Fetch all post titles
query = from p in Post,
     select: p.title
MyRepo.all(query)</code></pre>    <h3 class="detail-header callback" id="c:config/0">  <span class="signature">config()</span>  </h3>  <h4 class="specs-title">Specs</h4>  <pre data-language="elixir"><code class="elixir">config :: <a href="http://elixir-lang.org/docs/stable/elixir/Keyword.html#t:t/0" target="_blank">Keyword.t</a></code></pre>    <p>Returns the adapter configuration stored in the <code class="inline">:otp_app</code> environment.</p>    <h3 class="detail-header callback" id="c:delete/2">  <span class="signature">delete(struct_or_changeset, opts)</span>  </h3>  <h4 class="specs-title">Specs</h4>  <pre data-language="elixir"><code class="elixir">delete(struct_or_changeset :: <a href="../ecto.schema/#t:t/0">Ecto.Schema.t</a> | <a href="../ecto.changeset/#t:t/0">Ecto.Changeset.t</a>, opts :: <a href="http://elixir-lang.org/docs/stable/elixir/Keyword.html#t:t/0" target="_blank">Keyword.t</a>) ::
  {:ok, <a href="../ecto.schema/#t:t/0">Ecto.Schema.t</a>} |
  {:error, <a href="../ecto.changeset/#t:t/0">Ecto.Changeset.t</a>}</code></pre>    <p>Deletes a struct using its primary key.</p> <p>If the struct has no primary key, <a href="../ecto.noprimarykeyfielderror/"><code class="inline">Ecto.NoPrimaryKeyFieldError</code></a> will be raised.</p> <p>It returns <code class="inline">{:ok, struct}</code> if the struct has been successfully deleted or <code class="inline">{:error, changeset}</code> if there was a validation or a known constraint error.</p> <h4>Options</h4> <p>See the “Shared options” section at the module documentation.</p> <h4>Example</h4> <pre data-language="elixir"><code class="elixir">post = MyRepo.get!(Post, 42)
case MyRepo.delete post do
  {:ok, struct}       -&gt; # Deleted with success
  {:error, changeset} -&gt; # Something went wrong
end</code></pre>    <h3 class="detail-header callback" id="c:delete!/2">  <span class="signature">delete!(struct_or_changeset, opts)</span>  </h3>  <h4 class="specs-title">Specs</h4>  <pre data-language="elixir"><code class="elixir">delete!(struct_or_changeset :: <a href="../ecto.schema/#t:t/0">Ecto.Schema.t</a> | <a href="../ecto.changeset/#t:t/0">Ecto.Changeset.t</a>, opts :: <a href="http://elixir-lang.org/docs/stable/elixir/Keyword.html#t:t/0" target="_blank">Keyword.t</a>) ::
  <a href="../ecto.schema/#t:t/0">Ecto.Schema.t</a> |
  no_return</code></pre>    <p>Same as <code class="inline">delete/2</code> but returns the struct or raises if the changeset is invalid.</p>    <h3 class="detail-header callback" id="c:delete_all/2">  <span class="signature">delete_all(queryable, opts)</span>  </h3>  <h4 class="specs-title">Specs</h4>  <pre data-language="elixir"><code class="elixir">delete_all(queryable :: <a href="../ecto.queryable/#t:t/0">Ecto.Queryable.t</a>, opts :: <a href="http://elixir-lang.org/docs/stable/elixir/Keyword.html#t:t/0" target="_blank">Keyword.t</a>) ::
  {integer, nil | [term]} |
  no_return</code></pre>    <p>Deletes all entries matching the given query.</p> <p>It returns a tuple containing the number of entries and any returned result as second element. If the database does not support RETURNING in DELETE statements or no return result was selected, the second element will be <code class="inline">nil</code>.</p> <h4>Options</h4> <ul> <li>
<code class="inline">:returning</code> - selects which fields to return. When <code class="inline">true</code>, returns all fields in the given struct. May be a list of fields, where a struct is still returned but only with the given fields. Or <code class="inline">false</code>, where nothing is returned (the default). This option is not supported by all databases. </li> </ul> <p>See the “Shared options” section at the module documentation for remaining options.</p> <h4>Examples</h4> <pre data-language="elixir"><code class="elixir">MyRepo.delete_all(Post)

from(p in Post, where: p.id &lt; 10) |&gt; MyRepo.delete_all</code></pre>    <h3 class="detail-header callback" id="c:get/3">  <span class="signature">get(queryable, id, opts)</span>  </h3>  <h4 class="specs-title">Specs</h4>  <pre data-language="elixir"><code class="elixir">get(queryable :: <a href="../ecto.queryable/#t:t/0">Ecto.Queryable.t</a>, id :: term, opts :: <a href="http://elixir-lang.org/docs/stable/elixir/Keyword.html#t:t/0" target="_blank">Keyword.t</a>) ::
  <a href="../ecto.schema/#t:t/0">Ecto.Schema.t</a> |
  nil |
  no_return</code></pre>    <p>Fetches a single struct from the data store where the primary key matches the given id.</p> <p>Returns <code class="inline">nil</code> if no result was found. If the struct in the queryable has no or more than one primary key, it will raise an argument error.</p> <h4>Options</h4> <p>See the “Shared options” section at the module documentation.</p> <h4>Example</h4> <pre data-language="elixir"><code class="elixir">MyRepo.get(Post, 42)</code></pre>    <h3 class="detail-header callback" id="c:get!/3">  <span class="signature">get!(queryable, id, opts)</span>  </h3>  <h4 class="specs-title">Specs</h4>  <pre data-language="elixir"><code class="elixir">get!(queryable :: <a href="../ecto.queryable/#t:t/0">Ecto.Queryable.t</a>, id :: term, opts :: <a href="http://elixir-lang.org/docs/stable/elixir/Keyword.html#t:t/0" target="_blank">Keyword.t</a>) ::
  <a href="../ecto.schema/#t:t/0">Ecto.Schema.t</a> |
  nil |
  no_return</code></pre>    <p>Similar to <code class="inline">get/3</code> but raises <a href="../ecto.noresultserror/"><code class="inline">Ecto.NoResultsError</code></a> if no record was found.</p> <h4>Options</h4> <p>See the “Shared options” section at the module documentation.</p> <h4>Example</h4> <pre data-language="elixir"><code class="elixir">MyRepo.get!(Post, 42)</code></pre>    <h3 class="detail-header callback" id="c:get_by/3">  <span class="signature">get_by(queryable, clauses, opts)</span>  </h3>  <h4 class="specs-title">Specs</h4>  <pre data-language="elixir"><code class="elixir">get_by(queryable :: <a href="../ecto.queryable/#t:t/0">Ecto.Queryable.t</a>, clauses :: <a href="http://elixir-lang.org/docs/stable/elixir/Keyword.html#t:t/0" target="_blank">Keyword.t</a> | map, opts :: <a href="http://elixir-lang.org/docs/stable/elixir/Keyword.html#t:t/0" target="_blank">Keyword.t</a>) ::
  <a href="../ecto.schema/#t:t/0">Ecto.Schema.t</a> |
  nil |
  no_return</code></pre>    <p>Fetches a single result from the query.</p> <p>Returns <code class="inline">nil</code> if no result was found.</p> <h4>Options</h4> <p>See the “Shared options” section at the module documentation.</p> <h4>Example</h4> <pre data-language="elixir"><code class="elixir">MyRepo.get_by(Post, title: "My post")</code></pre>    <h3 class="detail-header callback" id="c:get_by!/3">  <span class="signature">get_by!(queryable, clauses, opts)</span>  </h3>  <h4 class="specs-title">Specs</h4>  <pre data-language="elixir"><code class="elixir">get_by!(queryable :: <a href="../ecto.queryable/#t:t/0">Ecto.Queryable.t</a>, clauses :: <a href="http://elixir-lang.org/docs/stable/elixir/Keyword.html#t:t/0" target="_blank">Keyword.t</a> | map, opts :: <a href="http://elixir-lang.org/docs/stable/elixir/Keyword.html#t:t/0" target="_blank">Keyword.t</a>) ::
  <a href="../ecto.schema/#t:t/0">Ecto.Schema.t</a> |
  nil |
  no_return</code></pre>    <p>Similar to <code class="inline">get_by/3</code> but raises <a href="../ecto.noresultserror/"><code class="inline">Ecto.NoResultsError</code></a> if no record was found.</p> <h4>Options</h4> <p>See the “Shared options” section at the module documentation.</p> <h4>Example</h4> <pre data-language="elixir"><code class="elixir">MyRepo.get_by!(Post, title: "My post")</code></pre>    <h3 class="detail-header callback" id="c:in_transaction?/0">  <span class="signature">in_transaction?()</span>  </h3>  <h4 class="specs-title">Specs</h4>  <pre data-language="elixir"><code class="elixir">in_transaction? :: boolean</code></pre>    <p>Returns true if the current process is inside a transaction.</p> <h4>Examples</h4> <pre data-language="elixir"><code class="elixir">MyRepo.in_transaction?
#=&gt; false

MyRepo.transaction(fn -&gt;
  MyRepo.in_transaction? #=&gt; true
end)</code></pre>    <h3 class="detail-header callback" id="c:insert/2">  <span class="signature">insert(struct_or_changeset, opts)</span>  </h3>  <h4 class="specs-title">Specs</h4>  <pre data-language="elixir"><code class="elixir">insert(struct_or_changeset :: <a href="../ecto.schema/#t:t/0">Ecto.Schema.t</a> | <a href="../ecto.changeset/#t:t/0">Ecto.Changeset.t</a>, opts :: <a href="http://elixir-lang.org/docs/stable/elixir/Keyword.html#t:t/0" target="_blank">Keyword.t</a>) ::
  {:ok, <a href="../ecto.schema/#t:t/0">Ecto.Schema.t</a>} |
  {:error, <a href="../ecto.changeset/#t:t/0">Ecto.Changeset.t</a>}</code></pre>    <p>Inserts a struct or a changeset.</p> <p>In case a struct is given, the struct is converted into a changeset with all non-nil fields as part of the changeset.</p> <p>In case a changeset is given, the changes in the changeset are merged with the struct fields, and all of them are sent to the database.</p> <p>It returns <code class="inline">{:ok, struct}</code> if the struct has been successfully inserted or <code class="inline">{:error, changeset}</code> if there was a validation or a known constraint error.</p> <h4>Options</h4> <p>See the “Shared options” section at the module documentation.</p> <h4>Example</h4> <pre data-language="elixir"><code class="elixir">case MyRepo.insert %Post{title: "Ecto is great"} do
  {:ok, struct}       -&gt; # Inserted with success
  {:error, changeset} -&gt; # Something went wrong
end</code></pre>    <h3 class="detail-header callback" id="c:insert!/2">  <span class="signature">insert!(struct_or_changeset, opts)</span>  </h3>  <h4 class="specs-title">Specs</h4>  <pre data-language="elixir"><code class="elixir">insert!(struct_or_changeset :: <a href="../ecto.schema/#t:t/0">Ecto.Schema.t</a> | <a href="../ecto.changeset/#t:t/0">Ecto.Changeset.t</a>, opts :: <a href="http://elixir-lang.org/docs/stable/elixir/Keyword.html#t:t/0" target="_blank">Keyword.t</a>) ::
  <a href="../ecto.schema/#t:t/0">Ecto.Schema.t</a> |
  no_return</code></pre>    <p>Same as <code class="inline">insert/2</code> but returns the struct or raises if the changeset is invalid.</p>    <h3 class="detail-header callback" id="c:insert_all/3">  <span class="signature">insert_all(schema_or_source, entries, opts)</span>  </h3>  <h4 class="specs-title">Specs</h4>  <pre data-language="elixir"><code class="elixir">insert_all(schema_or_source :: binary | {binary, <a href="../ecto.schema/#t:t/0">Ecto.Schema.t</a>} | <a href="../ecto.schema/#t:t/0">Ecto.Schema.t</a>, entries :: [map | <a href="http://elixir-lang.org/docs/stable/elixir/Keyword.html#t:t/0" target="_blank">Keyword.t</a>], opts :: <a href="http://elixir-lang.org/docs/stable/elixir/Keyword.html#t:t/0" target="_blank">Keyword.t</a>) ::
  {integer, nil | [term]} |
  no_return</code></pre>    <p>Inserts all entries into the repository.</p> <p>It expects a schema (<code class="inline">MyApp.User</code>) or a source (<code class="inline">"users"</code>) or both (<code class="inline">{"users", MyApp.User}</code>) as the first argument. The second argument is a list of entries to be inserted, either as keyword lists or as maps.</p> <p>It returns a tuple containing the number of entries and any returned result as second element. If the database does not support RETURNING in UPDATE statements or no return result was selected, the second element will be <code class="inline">nil</code>.</p> <p>When a schema is given, the values given will be properly dumped before being sent to the database. If the schema contains an autogenerated ID field, it will be handled either at the adapter or the storage layer. However any other autogenerated value, like timestamps, won’t be autogenerated when using <code class="inline">c:insert_all/3</code>. This is by design as this function aims to be a more direct way to insert data into the database without the conveniences of <code class="inline">c:insert/2</code>. This is also consistent with <code class="inline">c:update_all/3</code> that does not handle timestamps as well.</p> <p>If a source is given, without a schema, the given fields are passed as is to the adapter.</p> <h4>Options</h4> <ul> <li>
<code class="inline">:returning</code> - selects which fields to return. When <code class="inline">true</code>, returns all fields in the given struct. May be a list of fields, where a struct is still returned but only with the given fields. Or <code class="inline">false</code>, where nothing is returned (the default). This option is not supported by all databases. </li> </ul> <p>See the “Shared options” section at the module documentation for remaining options.</p>    <h3 class="detail-header callback" id="c:insert_or_update/2">  <span class="signature">insert_or_update(changeset, opts)</span>  </h3>  <h4 class="specs-title">Specs</h4>  <pre data-language="elixir"><code class="elixir">insert_or_update(changeset :: <a href="../ecto.changeset/#t:t/0">Ecto.Changeset.t</a>, opts :: <a href="http://elixir-lang.org/docs/stable/elixir/Keyword.html#t:t/0" target="_blank">Keyword.t</a>) ::
  {:ok, <a href="../ecto.schema/#t:t/0">Ecto.Schema.t</a>} |
  {:error, <a href="../ecto.changeset/#t:t/0">Ecto.Changeset.t</a>}</code></pre>    <p>Inserts or updates a changeset depending on whether the struct is persisted or not.</p> <p>The distinction whether to insert or update will be made on the <a href="../ecto.schema.metadata/"><code class="inline">Ecto.Schema.Metadata</code></a> field <code class="inline">:state</code>. The <code class="inline">:state</code> is automatically set by Ecto when loading or building a schema.</p> <p>Please note that for this to work, you will have to load existing structs from the database. So even if the struct exists, this won’t work:</p> <pre data-language="elixir"><code class="elixir">struct = %Post{id: 'existing_id', ...}
MyRepo.insert_or_update changeset
# =&gt; {:error, "id already exists"}</code></pre> <h4>Options</h4> <p>See the “Shared options” section at the module documentation.</p> <h4>Example</h4> <pre data-language="elixir"><code class="elixir">result =
  case MyRepo.get(Post, id) do
    nil  -&gt; %Post{id: id} # Post not found, we build one
    post -&gt; post          # Post exists, let's use it
  end
  |&gt; Post.changeset(changes)
  |&gt; MyRepo.insert_or_update

case result do
  {:ok, struct}       -&gt; # Inserted or updated with success
  {:error, changeset} -&gt; # Something went wrong
end</code></pre>    <h3 class="detail-header callback" id="c:insert_or_update!/2">  <span class="signature">insert_or_update!(changeset, opts)</span>  </h3>  <h4 class="specs-title">Specs</h4>  <pre data-language="elixir"><code class="elixir">insert_or_update!(changeset :: <a href="../ecto.changeset/#t:t/0">Ecto.Changeset.t</a>, opts :: <a href="http://elixir-lang.org/docs/stable/elixir/Keyword.html#t:t/0" target="_blank">Keyword.t</a>) ::
  <a href="../ecto.schema/#t:t/0">Ecto.Schema.t</a> |
  no_return</code></pre>    <p>Same as <code class="inline">insert_or_update/2</code> but returns the struct or raises if the changeset is invalid.</p>    <h3 class="detail-header callback" id="c:one/2">  <span class="signature">one(queryable, opts)</span>  </h3>  <h4 class="specs-title">Specs</h4>  <pre data-language="elixir"><code class="elixir">one(queryable :: <a href="../ecto.queryable/#t:t/0">Ecto.Queryable.t</a>, opts :: <a href="http://elixir-lang.org/docs/stable/elixir/Keyword.html#t:t/0" target="_blank">Keyword.t</a>) ::
  <a href="../ecto.schema/#t:t/0">Ecto.Schema.t</a> |
  nil |
  no_return</code></pre>    <p>Fetches a single result from the query.</p> <p>Returns <code class="inline">nil</code> if no result was found. Raises if more than one entry.</p> <h4>Options</h4> <p>See the “Shared options” section at the module documentation.</p>    <h3 class="detail-header callback" id="c:one!/2">  <span class="signature">one!(queryable, opts)</span>  </h3>  <h4 class="specs-title">Specs</h4>  <pre data-language="elixir"><code class="elixir">one!(queryable :: <a href="../ecto.queryable/#t:t/0">Ecto.Queryable.t</a>, opts :: <a href="http://elixir-lang.org/docs/stable/elixir/Keyword.html#t:t/0" target="_blank">Keyword.t</a>) ::
  <a href="../ecto.schema/#t:t/0">Ecto.Schema.t</a> |
  no_return</code></pre>    <p>Similar to <code class="inline">one/2</code> but raises <a href="../ecto.noresultserror/"><code class="inline">Ecto.NoResultsError</code></a> if no record was found.</p> <p>Raises if more than one entry.</p> <h4>Options</h4> <p>See the “Shared options” section at the module documentation.</p>    <h3 class="detail-header callback" id="c:preload/3">  <span class="signature">preload(struct_or_structs, preloads, opts)</span>  </h3>  <h4 class="specs-title">Specs</h4>  <pre data-language="elixir"><code class="elixir">preload(struct_or_structs, preloads :: term, opts :: <a href="http://elixir-lang.org/docs/stable/elixir/Keyword.html#t:t/0" target="_blank">Keyword.t</a>) :: struct_or_structs when struct_or_structs: [<a href="../ecto.schema/#t:t/0">Ecto.Schema.t</a>] | <a href="../ecto.schema/#t:t/0">Ecto.Schema.t</a></code></pre>    <p>Preloads all associations on the given struct or structs.</p> <p>This is similar to <a href="../ecto.query/#preload/3"><code class="inline">Ecto.Query.preload/3</code></a> except it allows you to preload structs after they have been fetched from the database.</p> <p>In case the association was already loaded, preload won’t attempt to reload it.</p> <h4>Options</h4> <p>Besides the “Shared options” section at the module documentation, it accepts:</p> <ul> <li>
<code class="inline">:force</code> - By default, Ecto won’t preload associations that are already loaded. By setting this option to true, any existing association will be discarded and reloaded. </li> <li>
<code class="inline">:in_parallel</code> - If the preloads must be done in parallel. It can only be performed when we have more than one preload and the repository is not in a transaction. Defaults to <code class="inline">true</code>. </li> <li>
<code class="inline">:prefix</code> - the prefix to fetch preloads from. By default, queries will use the same prefix as the one in the given collection. This option allows the prefix to be changed. </li> </ul> <h4>Examples</h4> <pre data-language="elixir"><code class="elixir">posts = Repo.preload posts, :comments
posts = Repo.preload posts, comments: :permalinks
posts = Repo.preload posts, comments: from(c in Comment, order_by: c.published_at)</code></pre>    <h3 class="detail-header callback" id="c:rollback/1">  <span class="signature">rollback(value)</span>  </h3>  <h4 class="specs-title">Specs</h4>  <pre data-language="elixir"><code class="elixir">rollback(value :: any) :: no_return</code></pre>    <p>Rolls back the current transaction.</p> <p>The transaction will return the value given as <code class="inline">{:error, value}</code>.</p>    <h3 class="detail-header callback" id="c:start_link/1">  <span class="signature">start_link(opts)</span>  </h3>  <h4 class="specs-title">Specs</h4>  <pre data-language="elixir"><code class="elixir">start_link(opts :: <a href="http://elixir-lang.org/docs/stable/elixir/Keyword.html#t:t/0" target="_blank">Keyword.t</a>) ::
  {:ok, pid} |
  {:error, {:already_started, pid}} |
  {:error, term}</code></pre>    <p>Starts any connection pooling or supervision and return <code class="inline">{:ok, pid}</code> or just <code class="inline">:ok</code> if nothing needs to be done. </p> <p>Returns <code class="inline">{:error, {:already_started, pid}}</code> if the repo is already started or <code class="inline">{:error, term}</code> in case anything else goes wrong.</p> <h4>Options</h4> <p>See the configuration in the moduledoc for options shared between adapters, for adapter-specific configuration see the adapter’s documentation.</p>    <h3 class="detail-header callback" id="c:stop/2">  <span class="signature">stop(pid, timeout)</span>  </h3>  <h4 class="specs-title">Specs</h4>  <pre data-language="elixir"><code class="elixir">stop(pid, timeout) :: :ok</code></pre>    <p>Shuts down the repository represented by the given pid.</p>    <h3 class="detail-header callback" id="c:transaction/2">  <span class="signature">transaction(fun_or_multi, opts)</span>  </h3>  <h4 class="specs-title">Specs</h4>  <pre data-language="elixir"><code class="elixir">transaction(fun_or_multi :: (... -&gt; any) | <a href="../ecto.multi/#t:t/0">Ecto.Multi.t</a>, opts :: <a href="http://elixir-lang.org/docs/stable/elixir/Keyword.html#t:t/0" target="_blank">Keyword.t</a>) ::
  {:ok, any} |
  {:error, any} |
  {:error, atom, any, %{optional(atom) =&gt; any}}</code></pre>    <p>Runs the given function or <a href="../ecto.multi/"><code class="inline">Ecto.Multi</code></a> inside a transaction.</p> <h4>Use with function</h4> <p>If an unhandled error occurs the transaction will be rolled back and the error will bubble up from the transaction function. If no error occurred the transaction will be committed when the function returns. A transaction can be explicitly rolled back by calling <code class="inline">rollback/1</code>, this will immediately leave the function and return the value given to <code class="inline">rollback</code> as <code class="inline">{:error, value}</code>.</p> <p>A successful transaction returns the value returned by the function wrapped in a tuple as <code class="inline">{:ok, value}</code>.</p> <p>If <code class="inline">transaction/2</code> is called inside another transaction, the function is simply executed, without wrapping the new transaction call in any way. If there is an error in the inner transaction and the error is rescued, or the inner transaction is rolled back, the whole outer transaction is marked as tainted, guaranteeing nothing will be committed.</p> <h4>Use with Ecto.Multi</h4> <p>Besides functions transaction can be used with an Ecto.Multi struct. Transaction will be started, all operations applied and in case of success committed returning <code class="inline">{:ok, changes}</code>. In case of any errors the transaction will be rolled back and <code class="inline">{:error, failed_operation, failed_value, changes_so_far}</code> will be returned.</p> <p>You can read more about using transactions with <a href="../ecto.multi/"><code class="inline">Ecto.Multi</code></a> as well as see some examples in the <a href="../ecto.multi/"><code class="inline">Ecto.Multi</code></a> documentation.</p> <h4>Options</h4> <p>See the “Shared options” section at the module documentation.</p> <h4>Examples</h4> <pre data-language="elixir"><code class="elixir">MyRepo.transaction(fn -&gt;
  MyRepo.update!(%{alice | balance: alice.balance - 10})
  MyRepo.update!(%{bob | balance: bob.balance + 10})
end)

# Roll back a transaction explicitly
MyRepo.transaction(fn -&gt;
  p = MyRepo.insert!(%Post{})
  if not Editor.post_allowed?(p) do
    MyRepo.rollback(:posting_not_allowed)
  end
end)

# With Ecto.Multi
Ecto.Multi.new
|&gt; Ecto.Multi.insert(:post, %Post{})
|&gt; MyRepo.transaction</code></pre>    <h3 class="detail-header callback" id="c:update/2">  <span class="signature">update(changeset, opts)</span>  </h3>  <h4 class="specs-title">Specs</h4>  <pre data-language="elixir"><code class="elixir">update(changeset :: <a href="../ecto.changeset/#t:t/0">Ecto.Changeset.t</a>, opts :: <a href="http://elixir-lang.org/docs/stable/elixir/Keyword.html#t:t/0" target="_blank">Keyword.t</a>) ::
  {:ok, <a href="../ecto.schema/#t:t/0">Ecto.Schema.t</a>} |
  {:error, <a href="../ecto.changeset/#t:t/0">Ecto.Changeset.t</a>}</code></pre>    <p>Updates a changeset using its primary key.</p> <p>A changeset is required as it is the only mechanism for tracking dirty changes.</p> <p>If the struct has no primary key, <a href="../ecto.noprimarykeyfielderror/"><code class="inline">Ecto.NoPrimaryKeyFieldError</code></a> will be raised.</p> <p>It returns <code class="inline">{:ok, struct}</code> if the struct has been successfully updated or <code class="inline">{:error, changeset}</code> if there was a validation or a known constraint error.</p> <h4>Options</h4> <p>Besides the “Shared options” section at the module documentation, it accepts:</p> <ul> <li>
<code class="inline">:force</code> - By default, if there are no changes in the changeset, <code class="inline">update!/2</code> is a no-op. By setting this option to true, update callbacks will always be executed, even if there are no changes (including timestamps). </li> </ul> <h4>Example</h4> <pre data-language="elixir"><code class="elixir">post = MyRepo.get!(Post, 42)
post = Ecto.Changeset.change post, title: "New title"
case MyRepo.update post do
  {:ok, struct}       -&gt; # Updated with success
  {:error, changeset} -&gt; # Something went wrong
end</code></pre>    <h3 class="detail-header callback" id="c:update!/2">  <span class="signature">update!(changeset, opts)</span>  </h3>  <h4 class="specs-title">Specs</h4>  <pre data-language="elixir"><code class="elixir">update!(changeset :: <a href="../ecto.changeset/#t:t/0">Ecto.Changeset.t</a>, opts :: <a href="http://elixir-lang.org/docs/stable/elixir/Keyword.html#t:t/0" target="_blank">Keyword.t</a>) ::
  <a href="../ecto.schema/#t:t/0">Ecto.Schema.t</a> |
  no_return</code></pre>    <p>Same as <code class="inline">update/2</code> but returns the struct or raises if the changeset is invalid.</p>    <h3 class="detail-header callback" id="c:update_all/3">  <span class="signature">update_all(queryable, updates, opts)</span>  </h3>  <h4 class="specs-title">Specs</h4>  <pre data-language="elixir"><code class="elixir">update_all(queryable :: <a href="../ecto.queryable/#t:t/0">Ecto.Queryable.t</a>, updates :: <a href="http://elixir-lang.org/docs/stable/elixir/Keyword.html#t:t/0" target="_blank">Keyword.t</a>, opts :: <a href="http://elixir-lang.org/docs/stable/elixir/Keyword.html#t:t/0" target="_blank">Keyword.t</a>) ::
  {integer, nil | [term]} |
  no_return</code></pre>    <p>Updates all entries matching the given query with the given values.</p> <p>It returns a tuple containing the number of entries and any returned result as second element. If the database does not support RETURNING in UPDATE statements or no return result was selected, the second element will be <code class="inline">nil</code>.</p> <p>Keep in mind this <code class="inline">update_all</code> will not update autogenerated fields like the <code class="inline">updated_at</code> columns.</p> <p>See <a href="../ecto.query/#update/3"><code class="inline">Ecto.Query.update/3</code></a> for update operations that can be performed on fields.</p> <h4>Options</h4> <ul> <li>
<code class="inline">:returning</code> - selects which fields to return. When <code class="inline">true</code>, returns all fields in the given struct. May be a list of fields, where a struct is still returned but only with the given fields. Or <code class="inline">false</code>, where nothing is returned (the default). This option is not supported by all databases. </li> </ul> <p>See the “Shared options” section at the module documentation for remaining options.</p> <h4>Examples</h4> <pre data-language="elixir"><code class="elixir">MyRepo.update_all(Post, set: [title: "New title"])

MyRepo.update_all(Post, inc: [visits: 1])

from(p in Post, where: p.id &lt; 10)
|&gt; MyRepo.update_all(set: [title: "New title"])

from(p in Post, where: p.id &lt; 10, update: [set: [title: "New title"]])
|&gt; MyRepo.update_all([])

from(p in Post, where: p.id &lt; 10, update: [set: [title: fragment("?", new_title)]])
|&gt; MyRepo.update_all([])</code></pre>
<div class="_attribution">
  <p class="_attribution-p">
    © 2012 Plataformatec<br>Licensed under the Apache License, Version 2.0.<br>
    <a href="https://hexdocs.pm/ecto/Ecto.Repo.html" class="_attribution-link" target="_blank">https://hexdocs.pm/ecto/Ecto.Repo.html</a>
  </p>
</div>

			</div>
		</div>
	</section>

	</div>
</body>
</html>
