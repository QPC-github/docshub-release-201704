
<!DOCTYPE HTML>

<html lang="en">

<head>
  <meta charset="utf-8">
  <title>Ecto.Adapter - Phoenix - W3cubDocs</title>
  
  <meta name="description" content=" This module specifies the adapter API that an adapter is required to implement. ">
  <meta name="keywords" content="ecto, adapter, summary, types, callbacks, -, phoenix">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="http://docs.w3cub.com/phoenix/ecto/ecto.adapter/">
  <link href="/favicon.png" rel="icon">
  <link type="text/css" rel="stylesheet" href="/assets/application-50364fff564ce3b6327021805f3f00e2957b441cf27f576a7dd4ff63bbc47047.css">
  <script type="text/javascript" src="/assets/application-db64bfd54ceb42be11af7995804cf4902548419ceb79d509b0b7d62c22d98e6f.js"></script>
  <script src="/json/phoenix.js"></script>
  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-71174418-1']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>


</head>

<body>
	<div class="_app">
	<header class="_header">
  
  <form class="_search">
    <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
    <a class="_search-clear"></a>
    <div class="_search-tag"></div>
  </form>
  
  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/phoenix/" class="_nav-link" title="" style="margin-left:0;">Phoenix</a></span>
  
  <nav class="_nav">
    <a href="/app/" class="_nav-link ">App</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		<div class="_list">
			
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<div class="_page _elixir">
				
<h1>  Ecto.Adapter <small>behaviour</small>  </h1>  <p>This module specifies the adapter API that an adapter is required to implement.</p>   <h1 class="section-heading" id="summary">  Summary </h1> <h2> Types </h2>
<dl class="summary-types summary">   <dt class="summary-signature"> <a href="#t:autogenerate_id/0">autogenerate_id()</a> </dt>   <dt class="summary-signature"> <a href="#t:cached/0">cached()</a> </dt>   <dt class="summary-signature"> <a href="#t:constraints/0">constraints()</a> </dt>   <dt class="summary-signature"> <a href="#t:fields/0">fields()</a> </dt>   <dt class="summary-signature"> <a href="#t:filters/0">filters()</a> </dt>   <dt class="summary-signature"> <a href="#t:prepared/0">prepared()</a> </dt>   <dt class="summary-signature"> <a href="#t:process/0">process()</a> </dt>   <dt class="summary-signature"> <a href="#t:query_meta/0">query_meta()</a> </dt> <dd class="summary-synopsis">
<p>Ecto.Query metadata fields (stored in cache)</p> </dd>   <dt class="summary-signature"> <a href="#t:returning/0">returning()</a> </dt>   <dt class="summary-signature"> <a href="#t:schema_meta/0">schema_meta()</a> </dt> <dd class="summary-synopsis">
<p>Ecto.Schema metadata fields</p> </dd>   <dt class="summary-signature"> <a href="#t:source/0">source()</a> </dt>   <dt class="summary-signature"> <a href="#t:t/0">t()</a> </dt>  </dl> <h2> Callbacks </h2>
<dl class="summary-callbacks summary">   <dt class="summary-signature"> <a href="#c:__before_compile__/1">__before_compile__(env)</a> </dt> <dd class="summary-synopsis">
<p>The callback invoked in case the adapter needs to inject code</p> </dd>   <dt class="summary-signature"> <a href="#c:autogenerate/1">autogenerate(field_type)</a> </dt> <dd class="summary-synopsis">
<p>Called to autogenerate a value for id/embed_id/binary_id</p> </dd>   <dt class="summary-signature"> <a href="#c:child_spec/2">child_spec(repo, options)</a> </dt> <dd class="summary-synopsis">
<p>Returns the childspec that starts the adapter process</p> </dd>   <dt class="summary-signature"> <a href="#c:delete/4">delete(repo, schema_meta, filters, options)</a> </dt> <dd class="summary-synopsis">
<p>Deletes a single struct with the given filters</p> </dd>   <dt class="summary-signature"> <a href="#c:dumpers/2">dumpers(primitive_type, ecto_type)</a> </dt> <dd class="summary-synopsis">
<p>Returns the dumpers for a given type</p> </dd>   <dt class="summary-signature"> <a href="#c:ensure_all_started/2">ensure_all_started(repo, type)</a> </dt> <dd class="summary-synopsis">
<p>Ensure all applications necessary to run the adapter are started</p> </dd>   <dt class="summary-signature"> <a href="#c:execute/6">execute(repo, query_meta, query, params, arg4, options)</a> </dt> <dd class="summary-synopsis">
<p>Executes a previously prepared query</p> </dd>   <dt class="summary-signature"> <a href="#c:insert/5">insert(repo, schema_meta, fields, returning, options)</a> </dt> <dd class="summary-synopsis">
<p>Inserts a single new struct in the data store</p> </dd>   <dt class="summary-signature"> <a href="#c:insert_all/6">insert_all(repo, schema_meta, header, list, returning, options)</a> </dt> <dd class="summary-synopsis">
<p>Inserts multiple entries into the data store</p> </dd>   <dt class="summary-signature"> <a href="#c:loaders/2">loaders(primitive_type, ecto_type)</a> </dt> <dd class="summary-synopsis">
<p>Returns the loaders for a given type</p> </dd>   <dt class="summary-signature"> <a href="#c:prepare/2">prepare(atom, query)</a> </dt> <dd class="summary-synopsis">
<p>Commands invoked to prepare a query for <code class="inline">all</code>, <code class="inline">update_all</code> and <code class="inline">delete_all</code></p> </dd>   <dt class="summary-signature"> <a href="#c:update/6">update(repo, schema_meta, fields, filters, returning, options)</a> </dt> <dd class="summary-synopsis">
<p>Updates a single struct with the given filters</p> </dd>  </dl>   <h1 class="section-heading" id="types">  Types </h1>  <div id="t:autogenerate_id/0" class="type-detail"> <pre data-language="elixir"><code class="elixir"><a href="#t:autogenerate_id/0">autogenerate_id</a> ::
  {field :: atom, type :: :id | :binary_id, value :: term} |
  nil</code></pre> </div> <div id="t:cached/0" class="type-detail"> <pre data-language="elixir"><code class="elixir"><a href="#t:cached/0">cached</a> :: term</code></pre> </div> <div id="t:constraints/0" class="type-detail"> <pre data-language="elixir"><code class="elixir"><a href="#t:constraints/0">constraints</a> :: <a href="http://elixir-lang.org/docs/stable/elixir/Keyword.html#t:t/0" target="_blank">Keyword.t</a></code></pre> </div> <div id="t:fields/0" class="type-detail"> <pre data-language="elixir"><code class="elixir"><a href="#t:fields/0">fields</a> :: <a href="http://elixir-lang.org/docs/stable/elixir/Keyword.html#t:t/0" target="_blank">Keyword.t</a></code></pre> </div> <div id="t:filters/0" class="type-detail"> <pre data-language="elixir"><code class="elixir"><a href="#t:filters/0">filters</a> :: <a href="http://elixir-lang.org/docs/stable/elixir/Keyword.html#t:t/0" target="_blank">Keyword.t</a></code></pre> </div> <div id="t:prepared/0" class="type-detail"> <pre data-language="elixir"><code class="elixir"><a href="#t:prepared/0">prepared</a> :: term</code></pre> </div> <div id="t:process/0" class="type-detail"> <pre data-language="elixir"><code class="elixir"><a href="#t:process/0">process</a> :: (field :: <a href="http://elixir-lang.org/docs/stable/elixir/Macro.html#t:t/0" target="_blank">Macro.t</a>, value :: term, context :: term -&gt; term)</code></pre> </div> <div id="t:query_meta/0" class="type-detail"> <pre data-language="elixir"><code class="elixir"><a href="#t:query_meta/0">query_meta</a> :: %{prefix: binary | nil, sources: tuple, assocs: term, preloads: term, select: term, fields: [term]}</code></pre> <p>Ecto.Query metadata fields (stored in cache)</p>  </div> <div id="t:returning/0" class="type-detail"> <pre data-language="elixir"><code class="elixir"><a href="#t:returning/0">returning</a> :: [atom]</code></pre> </div> <div id="t:schema_meta/0" class="type-detail"> <pre data-language="elixir"><code class="elixir"><a href="#t:schema_meta/0">schema_meta</a> :: %{source: <a href="#t:source/0">source</a>, schema: atom, context: term, autogenerate_id: {atom, :id | :binary_id}}</code></pre> <p>Ecto.Schema metadata fields</p>  </div> <div id="t:source/0" class="type-detail"> <pre data-language="elixir"><code class="elixir"><a href="#t:source/0">source</a> :: {prefix :: binary | nil, table :: binary}</code></pre> </div> <div id="t:t/0" class="type-detail"> <pre data-language="elixir"><code class="elixir"><a href="#t:t/0">t</a> :: module</code></pre> </div>    <h1 class="section-heading" id="callbacks">  Callbacks </h1>  <h3 class="detail-header callback" id="c:__before_compile__/1">  <span class="signature">__before_compile__(env)</span>  </h3>  <h4 class="specs-title">Specs</h4>  <pre data-language="elixir"><code class="elixir">__before_compile__({line :: <a href="http://elixir-lang.org/docs/stable/elixir/Macro.Env.html#t:line/0" target="_blank">Macro.Env.line</a>, env :: <a href="http://elixir-lang.org/docs/stable/elixir/Macro.Env.html#t:t/0" target="_blank">Macro.Env.t</a>}, env :: <a href="http://elixir-lang.org/docs/stable/elixir/Macro.Env.html#t:t/0" target="_blank">Macro.Env.t</a>) :: <a href="http://elixir-lang.org/docs/stable/elixir/Macro.html#t:t/0" target="_blank">Macro.t</a></code></pre>    <p>The callback invoked in case the adapter needs to inject code.</p>    <h3 class="detail-header callback" id="c:autogenerate/1">  <span class="signature">autogenerate(field_type)</span>  </h3>  <h4 class="specs-title">Specs</h4>  <pre data-language="elixir"><code class="elixir">autogenerate(field_type :: :id | :binary_id | :embed_id) ::
  term |
  nil |
  no_return</code></pre>    <p>Called to autogenerate a value for id/embed_id/binary_id.</p> <p>Returns the autogenerated value, or nil if it must be autogenerated inside the storage or raise if not supported.</p>    <h3 class="detail-header callback" id="c:child_spec/2">  <span class="signature">child_spec(repo, options)</span>  </h3>  <h4 class="specs-title">Specs</h4>  <pre data-language="elixir"><code class="elixir">child_spec(repo, options) :: <a href="http://elixir-lang.org/docs/stable/elixir/Supervisor.Spec.html#t:spec/0" target="_blank">Supervisor.Spec.spec</a></code></pre>    <p>Returns the childspec that starts the adapter process.</p>    <h3 class="detail-header callback" id="c:delete/4">  <span class="signature">delete(repo, schema_meta, filters, options)</span>  </h3>  <h4 class="specs-title">Specs</h4>  <pre data-language="elixir"><code class="elixir">delete(repo, <a href="#t:schema_meta/0">schema_meta</a>, <a href="#t:filters/0">filters</a>, options) ::
  {:ok, <a href="#t:fields/0">fields</a>} |
  {:invalid, <a href="#t:constraints/0">constraints</a>} |
  {:error, :stale} |
  no_return</code></pre>    <p>Deletes a single struct with the given filters.</p> <p>While <code class="inline">filters</code> can be any record column, it is expected that at least the primary key (or any other key that uniquely identifies an existing record) be given as a filter. Therefore, in case there is no record matching the given filters, <code class="inline">{:error, :stale}</code> is returned.</p>    <h3 class="detail-header callback" id="c:dumpers/2">  <span class="signature">dumpers(primitive_type, ecto_type)</span>  </h3>  <h4 class="specs-title">Specs</h4>  <pre data-language="elixir"><code class="elixir">dumpers(primitive_type :: <a href="../ecto.type/#t:primitive/0">Ecto.Type.primitive</a>, ecto_type :: <a href="../ecto.type/#t:t/0">Ecto.Type.t</a>) :: [(term -&gt; {:ok, term} | :error) | <a href="../ecto.type/#t:t/0">Ecto.Type.t</a>]</code></pre>    <p>Returns the dumpers for a given type.</p> <p>It receives the primitive type and the Ecto type (which may be primitive as well). It returns a list of dumpers with the given type usually at the beginning.</p> <p>This allows developers to properly translate values coming from the Ecto into adapter ones. For example, if the database does not support booleans but instead returns 0 and 1 for them, you could add:</p> <pre data-language="elixir"><code class="elixir">def dumpers(:boolean, type), do: [type, &amp;bool_encode/1]
def dumpers(_primitive, type), do: [type]

defp bool_encode(false), do: {:ok, 0}
defp bool_encode(true), do: {:ok, 1}</code></pre> <p>All adapters are required to implement a clause or :binary_id types, since they are adapter specific. If your adapter does not provide binary ids, you may simply use Ecto.UUID:</p> <pre data-language="elixir"><code class="elixir">def dumpers(:binary_id, type), do: [type, Ecto.UUID]
def dumpers(_primitive, type), do: [type]</code></pre>    <h3 class="detail-header callback" id="c:ensure_all_started/2">  <span class="signature">ensure_all_started(repo, type)</span>  </h3>  <h4 class="specs-title">Specs</h4>  <pre data-language="elixir"><code class="elixir">ensure_all_started(repo, type :: :application.restart_type) ::
  {:ok, [atom]} |
  {:error, atom}</code></pre>    <p>Ensure all applications necessary to run the adapter are started.</p>    <h3 class="detail-header callback" id="c:execute/6">  <span class="signature">execute(repo, query_meta, query, params, arg4, options)</span>  </h3>  <h4 class="specs-title">Specs</h4>  <pre data-language="elixir"><code class="elixir">execute(repo, <a href="#t:query_meta/0">query_meta</a>, query, params :: list, <a href="#t:process/0">process</a> | nil, options) :: result when result: {integer, [[term]] | nil} | no_return, query: {:nocache, <a href="#t:prepared/0">prepared</a>} | {:cached, (<a href="#t:prepared/0">prepared</a> -&gt; :ok), <a href="#t:cached/0">cached</a>} | {:cache, (<a href="#t:cached/0">cached</a> -&gt; :ok), <a href="#t:prepared/0">prepared</a>}</code></pre>    <p>Executes a previously prepared query.</p> <p>It must return a tuple containing the number of entries and the result set as a list of lists. The result set may also be <code class="inline">nil</code> if a particular operation does not support them.</p> <p>The <code class="inline">meta</code> field is a map containing some of the fields found in the <a href="../ecto.query/"><code class="inline">Ecto.Query</code></a> struct.</p> <p>It receives a process function that should be invoked for each selected field in the query result in order to convert them to the expected Ecto type. The <code class="inline">process</code> function will be nil if no result set is expected from the query.</p>    <h3 class="detail-header callback" id="c:insert/5">  <span class="signature">insert(repo, schema_meta, fields, returning, options)</span>  </h3>  <h4 class="specs-title">Specs</h4>  <pre data-language="elixir"><code class="elixir">insert(repo, <a href="#t:schema_meta/0">schema_meta</a>, <a href="#t:fields/0">fields</a>, <a href="#t:returning/0">returning</a>, options) ::
  {:ok, <a href="#t:fields/0">fields</a>} |
  {:invalid, <a href="#t:constraints/0">constraints</a>} |
  no_return</code></pre>    <p>Inserts a single new struct in the data store.</p> <h4>Autogenerate</h4> <p>The primary key will be automatically included in <code class="inline">returning</code> if the field has type <code class="inline">:id</code> or <code class="inline">:binary_id</code> and no value was set by the developer or none was autogenerated by the adapter.</p>    <h3 class="detail-header callback" id="c:insert_all/6">  <span class="signature">insert_all(repo, schema_meta, header, list, returning, options)</span>  </h3>  <h4 class="specs-title">Specs</h4>  <pre data-language="elixir"><code class="elixir">insert_all(repo, <a href="#t:schema_meta/0">schema_meta</a>, header :: [atom], [<a href="#t:fields/0">fields</a>], <a href="#t:returning/0">returning</a>, options) ::
  {integer, [[term]] | nil} |
  no_return</code></pre>    <p>Inserts multiple entries into the data store.</p>    <h3 class="detail-header callback" id="c:loaders/2">  <span class="signature">loaders(primitive_type, ecto_type)</span>  </h3>  <h4 class="specs-title">Specs</h4>  <pre data-language="elixir"><code class="elixir">loaders(primitive_type :: <a href="../ecto.type/#t:primitive/0">Ecto.Type.primitive</a>, ecto_type :: <a href="../ecto.type/#t:t/0">Ecto.Type.t</a>) :: [(term -&gt; {:ok, term} | :error) | <a href="../ecto.type/#t:t/0">Ecto.Type.t</a>]</code></pre>    <p>Returns the loaders for a given type.</p> <p>It receives the primitive type and the Ecto type (which may be primitive as well). It returns a list of loaders with the given type usually at the end.</p> <p>This allows developers to properly translate values coming from the adapters into Ecto ones. For example, if the database does not support booleans but instead returns 0 and 1 for them, you could add:</p> <pre data-language="elixir"><code class="elixir">def loaders(:boolean, type), do: [&amp;bool_decode/1, type]
def loaders(_primitive, type), do: [type]

defp bool_decode(0), do: {:ok, false}
defp bool_decode(1), do: {:ok, true}</code></pre> <p>All adapters are required to implement a clause for <code class="inline">:binary_id</code> types, since they are adapter specific. If your adapter does not provide binary ids, you may simply use Ecto.UUID:</p> <pre data-language="elixir"><code class="elixir">def loaders(:binary_id, type), do: [Ecto.UUID, type]
def loaders(_primitive, type), do: [type]</code></pre>    <h3 class="detail-header callback" id="c:prepare/2">  <span class="signature">prepare(atom, query)</span>  </h3>  <h4 class="specs-title">Specs</h4>  <pre data-language="elixir"><code class="elixir">prepare(atom :: :all | :update_all | :delete_all, query :: <a href="../ecto.query/#t:t/0">Ecto.Query.t</a>) ::
  {:cache, <a href="#t:prepared/0">prepared</a>} |
  {:nocache, <a href="#t:prepared/0">prepared</a>}</code></pre>    <p>Commands invoked to prepare a query for <code class="inline">all</code>, <code class="inline">update_all</code> and <code class="inline">delete_all</code>.</p> <p>The returned result is given to <code class="inline">execute/6</code>.</p>    <h3 class="detail-header callback" id="c:update/6">  <span class="signature">update(repo, schema_meta, fields, filters, returning, options)</span>  </h3>  <h4 class="specs-title">Specs</h4>  <pre data-language="elixir"><code class="elixir">update(repo, <a href="#t:schema_meta/0">schema_meta</a>, <a href="#t:fields/0">fields</a>, <a href="#t:filters/0">filters</a>, <a href="#t:returning/0">returning</a>, options) ::
  {:ok, <a href="#t:fields/0">fields</a>} |
  {:invalid, <a href="#t:constraints/0">constraints</a>} |
  {:error, :stale} |
  no_return</code></pre>    <p>Updates a single struct with the given filters.</p> <p>While <code class="inline">filters</code> can be any record column, it is expected that at least the primary key (or any other key that uniquely identifies an existing record) be given as a filter. Therefore, in case there is no record matching the given filters, <code class="inline">{:error, :stale}</code> is returned.</p>
<div class="_attribution">
  <p class="_attribution-p">
    © 2012 Plataformatec<br>Licensed under the Apache License, Version 2.0.<br>
    <a href="https://hexdocs.pm/ecto/Ecto.Adapter.html" class="_attribution-link" target="_blank">https://hexdocs.pm/ecto/Ecto.Adapter.html</a>
  </p>
</div>

			</div>
		</div>
	</section>

	</div>
</body>
</html>
