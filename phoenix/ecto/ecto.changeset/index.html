
<!DOCTYPE HTML>

<html lang="en">

<head>
  <meta charset="utf-8">
  <title>Ecto.Changeset - Phoenix - W3cubDocs</title>
  
  <meta name="description" content=" Changesets allow filtering, casting, validation and definition of constraints when manipulating structs. ">
  <meta name="keywords" content="ecto, changeset, summary, types, functions, -, phoenix">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="http://docs.w3cub.com/phoenix/ecto/ecto.changeset/">
  <link href="/favicon.png" rel="icon">
  <link type="text/css" rel="stylesheet" href="/assets/application-50364fff564ce3b6327021805f3f00e2957b441cf27f576a7dd4ff63bbc47047.css">
  <script type="text/javascript" src="/assets/application-db64bfd54ceb42be11af7995804cf4902548419ceb79d509b0b7d62c22d98e6f.js"></script>
  <script src="/json/phoenix.js"></script>
  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-71174418-1']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>


</head>

<body>
	<div class="_app">
	<header class="_header">
  
  <form class="_search">
    <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
    <a class="_search-clear"></a>
    <div class="_search-tag"></div>
  </form>
  
  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/phoenix/" class="_nav-link" title="" style="margin-left:0;">Phoenix</a></span>
  
  <nav class="_nav">
    <a href="/app/" class="_nav-link ">App</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		<div class="_list">
			
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<div class="_page _elixir">
				
<h1>  Ecto.Changeset  </h1>  <p>Changesets allow filtering, casting, validation and definition of constraints when manipulating structs.</p> <p>There is an example of working with changesets in the introductory documentation in the <a href="../ecto/"><code class="inline">Ecto</code></a> module. The functions <a href="#change/2"><code class="inline">change/2</code></a> and <a href="#cast/3"><code class="inline">cast/3</code></a> are the usual entry points for creating changesets, while the remaining functions are useful for manipulating them.</p> <h2 id="module-validations-and-constraints" class="section-heading">  Validations and constraints </h2> <p>Ecto changesets provide both validations and constraints which are ultimately turned into errors in case something goes wrong.</p> <p>The difference between them is that validations can be executed without a need to interact with the database and, therefore, are always executed before attempting to insert or update the entry in the database.</p> <p>However, constraints can only be checked in a safe way when performing the operation in the database. As a consequence, validations are always checked before constraints. Constraints won’t even be checked in case validations failed.</p> <p>Let’s see an example:</p> <pre data-language="elixir"><code class="elixir">defmodule User do
  use Ecto.Schema
  import Ecto.Changeset

  schema "users" do
    field :name
    field :email
    field :age, :integer
  end

  def changeset(user, params \\ %{}) do
    user
    |&gt; cast(params, [:name, :email, :age])
    |&gt; validate_required([:name, :email])
    |&gt; validate_format(:email, ~r/@/)
    |&gt; validate_inclusion(:age, 18..100)
    |&gt; unique_constraint(:email)
  end
end</code></pre> <p>In the <code class="inline">changeset/2</code> function above, we define three validations - one after another they check that <code class="inline">name</code> and <code class="inline">email</code> fields are present in the changeset, the e-mail is of the specified format, and the age is between 18 and 100 - as well as a unique constraint in the email field.</p> <p>Let’s suppose the e-mail is given but the age is invalid. The changeset would have the following errors:</p> <pre data-language="elixir"><code class="elixir">changeset = User.changeset(%User{}, %{age: 0, email: "mary@example.com"})
{:error, changeset} = Repo.insert(changeset)
changeset.errors #=&gt; [age: {"is invalid", []}, name: {"can't be blank", []}]</code></pre> <p>In this case, we haven’t checked the unique constraint in the e-mail field because the data did not validate. Let’s fix the age and assume, however, that the e-mail already exists in the database:</p> <pre data-language="elixir"><code class="elixir">changeset = User.changeset(%User{}, %{age: 42, email: "mary@example.com"})
{:error, changeset} = Repo.insert(changeset)
changeset.errors #=&gt; [email: {"has already been taken", []}]</code></pre> <p>Validations and constraints define an explicit boundary when the check happens. By moving constraints to the database, we also provide a safe, correct and data-race free means of checking the user input.</p> <h2 id="module-empty-values" class="section-heading">  Empty values </h2> <p>Many times, the data given on cast needs to be further pruned, specially regarding empty values. For example, if you are gathering data to be cast from the command line or through an HTML form or any other text-based format, it is likely those means cannot express nil values. For those reasons, changesets include the concept of empty values, which are values that will be automatically converted to nil on <a href="#cast/3"><code class="inline">cast/3</code></a>. Those values are stored in the changeset <code class="inline">empty_values</code> field and default to <code class="inline">[""]</code>.</p> <h2 id="module-the-ecto-changeset-struct" class="section-heading">  The Ecto.Changeset struct </h2> <p>The fields are:</p> <ul> <li>
<code class="inline">valid?</code> - Stores if the changeset is valid </li> <li>
<code class="inline">data</code> - The changeset source data, for example, a struct </li> <li>
<code class="inline">params</code> - The parameters as given on changeset creation </li> <li>
<code class="inline">changes</code> - The <code class="inline">changes</code> from parameters that were approved in casting </li> <li>
<code class="inline">errors</code> - All errors from validations </li> <li>
<code class="inline">validations</code> - All validations performed in the changeset </li> <li>
<code class="inline">constraints</code> - All constraints defined in the changeset </li> <li>
<code class="inline">required</code> - All required fields as a list of atoms </li> <li>
<code class="inline">filters</code> - Filters (as a map <code class="inline">%{field =&gt; value}</code>) to narrow the scope of update/delete queries </li> <li>
<code class="inline">action</code> - The action to be performed with the changeset </li> <li>
<code class="inline">types</code> - Cache of the data’s field types </li> <li>
<code class="inline">repo</code> - The repository applying the changeset (only set after a Repo function is called) </li> <li>
<code class="inline">opts</code> - The options given to the repository </li> <li>
<code class="inline">empty_values</code> - A list of values to be considered empty </li> </ul> <h2 id="module-on-replace" class="section-heading">  On replace </h2> <p>Using changesets you can work with associations as well as with embedded structs. Sometimes related data may be replaced by incoming data and by default Ecto won’t allow such. Such behaviour can be changed when defining the relation by setting <code class="inline">:on_replace</code> option according to the values below:</p> <ul> <li>
<code class="inline">:raise</code> (default) - do not allow removing association or embedded data via parent changesets, </li> <li>
<code class="inline">:mark_as_invalid</code> - if attempting to remove the association or embedded data via parent changeset - an error will be added to the parent changeset, and it will be marked as invalid, </li> <li>
<code class="inline">:nilify</code> - sets owner reference column to <code class="inline">nil</code> (available only for associations), </li> <li>
<code class="inline">:update</code> - updates the association, available only for has_one and belongs_to. This option will update all the fields given to the changeset including the id for the association. </li> <li>
<p><code class="inline">:delete</code> - removes the association or related data from the database. This option has to be used carefully. You should consider adding a separate boolean virtual field to the changeset function that will allow you to manually mark it for deletion, as in the example below:</p> <pre data-language="elixir"><code class="elixir">defmodule Comment do
  use Ecto.Schema
  import Ecto.Changeset

  schema "comments" do
    field :body, :string
    field :delete, :boolean, virtual: true
  end

  def changeset(comment, params) do
    cast(comment, params, [:body, :delete])
    |&gt; maybe_mark_for_deletion
  end

  defp maybe_mark_for_deletion(changeset) do
    if get_change(changeset, :delete) do
      %{changeset | action: :delete}
    else
      changeset
    end
  end
end</code></pre> </li> </ul>   <h1 class="section-heading" id="summary">  Summary </h1> <h2> Types </h2>
<dl class="summary-types summary">   <dt class="summary-signature"> <a href="#t:action/0">action()</a> </dt>   <dt class="summary-signature"> <a href="#t:constraint/0">constraint()</a> </dt>   <dt class="summary-signature"> <a href="#t:data/0">data()</a> </dt>   <dt class="summary-signature"> <a href="#t:error/0">error()</a> </dt>   <dt class="summary-signature"> <a href="#t:t/0">t()</a> </dt>   <dt class="summary-signature"> <a href="#t:types/0">types()</a> </dt>  </dl> <h2> Functions </h2>
<dl class="summary-functions summary">   <dt class="summary-signature"> <a href="#add_error/4">add_error(changeset, key, message, keys \\ [])</a> </dt> <dd class="summary-synopsis">
<p>Adds an error to the changeset</p> </dd>   <dt class="summary-signature"> <a href="#apply_changes/1">apply_changes(changeset)</a> </dt> <dd class="summary-synopsis">
<p>Applies the changeset changes to the changeset data</p> </dd>   <dt class="summary-signature"> <a href="#assoc_constraint/3">assoc_constraint(changeset, assoc, opts \\ [])</a> </dt> <dd class="summary-synopsis">
<p>Checks the associated field exists</p> </dd>   <dt class="summary-signature"> <a href="#cast/3">cast(data, params, allowed)</a> </dt> <dd class="summary-synopsis">
<p>Applies the given <code class="inline">params</code> as changes for the given <code class="inline">data</code> according to the given set of keys. Returns a changeset</p> </dd>   <dt class="summary-signature"> <a href="#cast/4">cast(data, params, required, optional)</a> </dt> <dd class="summary-synopsis">
<p>WARNING: This function is deprecated in favor of <a href="#cast/3"><code class="inline">cast/3</code></a> + <a href="#validate_required/3"><code class="inline">validate_required/3</code></a></p> </dd>   <dt class="summary-signature"> <a href="#cast_assoc/3">cast_assoc(changeset, name, opts \\ [])</a> </dt> <dd class="summary-synopsis">
<p>Casts the given association</p> </dd>   <dt class="summary-signature"> <a href="#cast_embed/3">cast_embed(changeset, name, opts \\ [])</a> </dt> <dd class="summary-synopsis">
<p>Casts the given embed</p> </dd>   <dt class="summary-signature"> <a href="#change/2">change(data, changes \\ %{})</a> </dt> <dd class="summary-synopsis">
<p>Wraps the given data in a changeset or adds changes to a changeset</p> </dd>   <dt class="summary-signature"> <a href="#check_constraint/3">check_constraint(changeset, field, opts \\ [])</a> </dt> <dd class="summary-synopsis">
<p>Checks for a check constraint in the given field</p> </dd>   <dt class="summary-signature"> <a href="#delete_change/2">delete_change(changeset, key)</a> </dt> <dd class="summary-synopsis">
<p>Deletes a change with the given key</p> </dd>   <dt class="summary-signature"> <a href="#exclusion_constraint/3">exclusion_constraint(changeset, field, opts \\ [])</a> </dt> <dd class="summary-synopsis">
<p>Checks for an exclusion constraint in the given field</p> </dd>   <dt class="summary-signature"> <a href="#fetch_change/2">fetch_change(changeset, key)</a> </dt> <dd class="summary-synopsis">
<p>Fetches a change from the given changeset</p> </dd>   <dt class="summary-signature"> <a href="#fetch_field/2">fetch_field(changeset, key)</a> </dt> <dd class="summary-synopsis">
<p>Fetches the given field from changes or from the data</p> </dd>   <dt class="summary-signature"> <a href="#force_change/3">force_change(changeset, key, value)</a> </dt> <dd class="summary-synopsis">
<p>Forces a change on the given <code class="inline">key</code> with <code class="inline">value</code></p> </dd>   <dt class="summary-signature"> <a href="#foreign_key_constraint/3">foreign_key_constraint(changeset, field, opts \\ [])</a> </dt> <dd class="summary-synopsis">
<p>Checks for foreign key constraint in the given field</p> </dd>   <dt class="summary-signature"> <a href="#get_change/3">get_change(changeset, key, default \\ nil)</a> </dt> <dd class="summary-synopsis">
<p>Gets a change or returns a default value</p> </dd>   <dt class="summary-signature"> <a href="#get_field/3">get_field(changeset, key, default \\ nil)</a> </dt> <dd class="summary-synopsis">
<p>Gets a field from changes or from the data</p> </dd>   <dt class="summary-signature"> <a href="#merge/2">merge(changeset1, changeset2)</a> </dt> <dd class="summary-synopsis">
<p>Merges two changesets</p> </dd>   <dt class="summary-signature"> <a href="#no_assoc_constraint/3">no_assoc_constraint(changeset, assoc, opts \\ [])</a> </dt> <dd class="summary-synopsis">
<p>Checks the associated field does not exist</p> </dd>   <dt class="summary-signature"> <a href="#optimistic_lock/3">optimistic_lock(data_or_changeset, field, incrementer \\ &amp;(&amp;1 + 1))</a> </dt> <dd class="summary-synopsis">
<p>Applies optimistic locking to the changeset</p> </dd>   <dt class="summary-signature"> <a href="#prepare_changes/2">prepare_changes(changeset, function)</a> </dt> <dd class="summary-synopsis">
<p>Provides a function to run before emitting changes to the repository</p> </dd>   <dt class="summary-signature"> <a href="#put_assoc/4">put_assoc(changeset, name, value, opts \\ [])</a> </dt> <dd class="summary-synopsis">
<p>Puts the given association as a change in the changeset</p> </dd>   <dt class="summary-signature"> <a href="#put_change/3">put_change(changeset, key, value)</a> </dt> <dd class="summary-synopsis">
<p>Puts a change on the given <code class="inline">key</code> with <code class="inline">value</code></p> </dd>   <dt class="summary-signature"> <a href="#put_embed/4">put_embed(changeset, name, value, opts \\ [])</a> </dt> <dd class="summary-synopsis">
<p>Puts the given embed as a change in the changeset</p> </dd>   <dt class="summary-signature"> <a href="#traverse_errors/2">traverse_errors(changeset, msg_func)</a> </dt> <dd class="summary-synopsis">
<p>Traverses changeset errors and applies the given function to error messages</p> </dd>   <dt class="summary-signature"> <a href="#unique_constraint/3">unique_constraint(changeset, field, opts \\ [])</a> </dt> <dd class="summary-synopsis">
<p>Checks for a unique constraint in the given field</p> </dd>   <dt class="summary-signature"> <a href="#update_change/3">update_change(changeset, key, function)</a> </dt> <dd class="summary-synopsis">
<p>Updates a change</p> </dd>   <dt class="summary-signature"> <a href="#validate_acceptance/3">validate_acceptance(changeset, field, opts \\ [])</a> </dt> <dd class="summary-synopsis">
<p>Validates the given parameter was given as true</p> </dd>   <dt class="summary-signature"> <a href="#validate_change/3">validate_change(changeset, field, validator)</a> </dt> <dd class="summary-synopsis">
<p>Validates the given <code class="inline">field</code> change</p> </dd>   <dt class="summary-signature"> <a href="#validate_change/4">validate_change(changeset, field, metadata, validator)</a> </dt> <dd class="summary-synopsis">
<p>Stores the validation <code class="inline">metadata</code> and validates the given <code class="inline">field</code> change</p> </dd>   <dt class="summary-signature"> <a href="#validate_confirmation/3">validate_confirmation(changeset, field, opts \\ [])</a> </dt> <dd class="summary-synopsis">
<p>Validates that the given field matches the confirmation parameter of that field</p> </dd>   <dt class="summary-signature"> <a href="#validate_exclusion/4">validate_exclusion(changeset, field, data, opts \\ [])</a> </dt> <dd class="summary-synopsis">
<p>Validates a change is not included in the given enumerable</p> </dd>   <dt class="summary-signature"> <a href="#validate_format/4">validate_format(changeset, field, format, opts \\ [])</a> </dt> <dd class="summary-synopsis">
<p>Validates a change has the given format</p> </dd>   <dt class="summary-signature"> <a href="#validate_inclusion/4">validate_inclusion(changeset, field, data, opts \\ [])</a> </dt> <dd class="summary-synopsis">
<p>Validates a change is included in the given enumerable</p> </dd>   <dt class="summary-signature"> <a href="#validate_length/3">validate_length(changeset, field, opts)</a> </dt> <dd class="summary-synopsis">
<p>Validates a change is a string or list of the given length</p> </dd>   <dt class="summary-signature"> <a href="#validate_number/3">validate_number(changeset, field, opts)</a> </dt> <dd class="summary-synopsis">
<p>Validates the properties of a number</p> </dd>   <dt class="summary-signature"> <a href="#validate_required/3">validate_required(changeset, fields, opts \\ [])</a> </dt> <dd class="summary-synopsis">
<p>Validates that one or more fields are present in the changeset</p> </dd>   <dt class="summary-signature"> <a href="#validate_subset/4">validate_subset(changeset, field, data, opts \\ [])</a> </dt> <dd class="summary-synopsis">
<p>Validates a change, of type enum, is a subset of the given enumerable. Like validate_inclusion/4 for lists</p> </dd>  </dl>   <h1 class="section-heading" id="types">  Types </h1>  <div id="t:action/0" class="type-detail"> <pre data-language="elixir"><code class="elixir"><a href="#t:action/0">action</a> :: nil | :insert | :update | :delete | :replace</code></pre> </div> <div id="t:constraint/0" class="type-detail"> <pre data-language="elixir"><code class="elixir"><a href="#t:constraint/0">constraint</a> :: %{type: :unique, constraint: <a href="http://elixir-lang.org/docs/stable/elixir/String.html#t:t/0" target="_blank">String.t</a>, match: :exact | :suffix, field: atom, message: <a href="#t:error/0">error</a>}</code></pre> </div> <div id="t:data/0" class="type-detail"> <pre data-language="elixir"><code class="elixir"><a href="#t:data/0">data</a> :: map</code></pre> </div> <div id="t:error/0" class="type-detail"> <pre data-language="elixir"><code class="elixir"><a href="#t:error/0">error</a> :: {<a href="http://elixir-lang.org/docs/stable/elixir/String.html#t:t/0" target="_blank">String.t</a>, <a href="http://elixir-lang.org/docs/stable/elixir/Keyword.html#t:t/0" target="_blank">Keyword.t</a>}</code></pre> </div> <div id="t:t/0" class="type-detail"> <pre data-language="elixir"><code class="elixir"><a href="#t:t/0">t</a> :: %Ecto.Changeset{action: <a href="#t:action/0">action</a>, changes: %{optional(atom) =&gt; term}, constraints: [<a href="#t:constraint/0">constraint</a>], data: <a href="../ecto.schema/#t:t/0">Ecto.Schema.t</a> | nil, empty_values: term, errors: [{atom, <a href="#t:error/0">error</a>}], filters: %{optional(atom) =&gt; term}, params: %{optional(<a href="http://elixir-lang.org/docs/stable/elixir/String.html#t:t/0" target="_blank">String.t</a>) =&gt; term} | nil, prepare: [(<a href="#t:t/0">t</a> -&gt; <a href="#t:t/0">t</a>)], repo: atom | nil, required: [atom], types: nil | %{optional(atom) =&gt; <a href="../ecto.type/#t:t/0">Ecto.Type.t</a>}, valid?: boolean, validations: <a href="http://elixir-lang.org/docs/stable/elixir/Keyword.html#t:t/0" target="_blank">Keyword.t</a>}</code></pre> </div> <div id="t:types/0" class="type-detail"> <pre data-language="elixir"><code class="elixir"><a href="#t:types/0">types</a> :: <a href="http://elixir-lang.org/docs/stable/elixir/Keyword.html#t:t/0" target="_blank">Keyword.t</a> | map</code></pre> </div>    <h1 class="section-heading" id="functions">  Functions </h1>  <h3 class="detail-header function" id="add_error/4">  <span class="signature">add_error(changeset, key, message, keys \\ [])</span>  </h3>  <h4 class="specs-title">Specs</h4>  <pre data-language="elixir"><code class="elixir">add_error(<a href="#t:t/0">t</a>, atom, <a href="http://elixir-lang.org/docs/stable/elixir/String.html#t:t/0" target="_blank">String.t</a>, <a href="http://elixir-lang.org/docs/stable/elixir/Keyword.html#t:t/0" target="_blank">Keyword.t</a>) :: <a href="#t:t/0">t</a></code></pre>    <p>Adds an error to the changeset.</p> <p>An additional keyword list <code class="inline">keys</code> can be passed to provide additional contextual information for the error. This is useful when using <code class="inline">traverse_errors</code></p> <h4>Examples</h4> <pre data-language="elixir"><code class="iex elixir">iex&gt; changeset = change(%Post{}, %{title: ""})
iex&gt; changeset = add_error(changeset, :title, "empty")
iex&gt; changeset.errors
[title: {"empty", []}]
iex&gt; changeset.valid?
false

iex&gt; changeset = change(%Post{}, %{title: ""})
iex&gt; changeset = add_error(changeset, :title, "empty", additional: "info")
iex&gt; changeset.errors
[title: {"empty", [additional: "info"]}]
iex&gt; changeset.valid?
false</code></pre>    <h3 class="detail-header function" id="apply_changes/1">  <span class="signature">apply_changes(changeset)</span>  </h3>  <h4 class="specs-title">Specs</h4>  <pre data-language="elixir"><code class="elixir">apply_changes(<a href="#t:t/0">t</a>) :: <a href="../ecto.schema/#t:t/0">Ecto.Schema.t</a></code></pre>    <p>Applies the changeset changes to the changeset data.</p> <p>This operation will return the underlying data with changes regardless if the changeset is valid or not.</p> <h4>Examples</h4> <pre data-language="elixir"><code class="elixir">apply_changes(changeset)</code></pre>    <h3 class="detail-header function" id="assoc_constraint/3">  <span class="signature">assoc_constraint(changeset, assoc, opts \\ [])</span>  </h3>  <h4 class="specs-title">Specs</h4>  <pre data-language="elixir"><code class="elixir">assoc_constraint(<a href="#t:t/0">t</a>, atom, <a href="http://elixir-lang.org/docs/stable/elixir/Keyword.html#t:t/0" target="_blank">Keyword.t</a>) ::
  <a href="#t:t/0">t</a> |
  no_return</code></pre>    <p>Checks the associated field exists.</p> <p>This is similar to <a href="#foreign_key_constraint/3"><code class="inline">foreign_key_constraint/3</code></a> except that the field is inferred from the association definition. This is useful to guarantee that a child will only be created if the parent exists in the database too. Therefore, it only applies to <code class="inline">belongs_to</code> associations.</p> <p>As the name says, a constraint is required in the database for this function to work. Such constraint is often added as a reference to the child table:</p> <pre data-language="elixir"><code class="elixir">create table(:comments) do
  add :post_id, references(:posts)
end</code></pre> <p>Now, when inserting a comment, it is possible to forbid any comment to be added if the associated post does not exist:</p> <pre data-language="elixir"><code class="elixir">comment
|&gt; Ecto.Changeset.cast(params, [:post_id])
|&gt; Ecto.Changeset.assoc_constraint(:post)
|&gt; Repo.insert</code></pre> <h4>Options</h4> <ul> <li>
<code class="inline">:message</code> - the message in case the constraint check fails, defaults to “does not exist” </li> <li>
<code class="inline">:name</code> - the constraint name. By default, the constraint name is inferred from the table + association field. May be required explicitly for complex cases </li> </ul>    <h3 class="detail-header function" id="cast/3">  <span class="signature">cast(data, params, allowed)</span>  </h3>  <h4 class="specs-title">Specs</h4>  <pre data-language="elixir"><code class="elixir">cast(<a href="../ecto.schema/#t:t/0">Ecto.Schema.t</a> | <a href="#t:t/0">t</a> | {<a href="#t:data/0">data</a>, <a href="#t:types/0">types</a>}, %{optional(binary) =&gt; term} | %{optional(atom) =&gt; term} | :invalid, [<a href="http://elixir-lang.org/docs/stable/elixir/String.html#t:t/0" target="_blank">String.t</a> | atom]) ::
  <a href="#t:t/0">t</a> |
  no_return</code></pre>    <p>Applies the given <code class="inline">params</code> as changes for the given <code class="inline">data</code> according to the given set of keys. Returns a changeset.</p> <p>The given <code class="inline">data</code> may be either a changeset, a struct or a <code class="inline">{data, types}</code> tuple. The second argument is a map of <code class="inline">params</code> that are cast according to the type information from <code class="inline">data</code>. <code class="inline">params</code> is a map with string keys or a map with atom keys containing potentially unsafe data.</p> <p>During casting, all <code class="inline">allowed</code> parameters will have their key name converted to an atom and stored as a change in the <code class="inline">:changes</code> field of the changeset. All parameters that are not explicitly allowed are ignored.</p> <p>If casting of all fields is successful, the changeset is returned as valid.</p> <h4>Examples</h4> <pre data-language="elixir"><code class="iex elixir">iex&gt; changeset = cast(post, params, [:title])
iex&gt; if changeset.valid? do
...&gt;   Repo.update!(changeset)
...&gt; end</code></pre> <p>Passing a changeset as the first argument:</p> <pre data-language="elixir"><code class="iex elixir">iex&gt; changeset = cast(post, %{title: "Hello"}, [:title])
iex&gt; new_changeset = cast(changeset, %{title: "Foo", body: "Bar"}, [:body])
iex&gt; new_changeset.params
%{"title" =&gt; "Foo", "body" =&gt; "Bar"}</code></pre> <p>Or creating a changeset from a simple map with types:</p> <pre data-language="elixir"><code class="iex elixir">iex&gt; data = %{title: "hello"}
iex&gt; types = %{title: :string}
iex&gt; changeset = cast({data, types}, %{title: "world"}, [:title])
iex&gt; apply_changes(changeset)
%{title: "world"}</code></pre> <h4>Composing casts</h4> <p><a href="#cast/3"><code class="inline">cast/3</code></a> also accepts a changeset as its first argument. In such cases, all the effects caused by the call to <a href="#cast/3"><code class="inline">cast/3</code></a> (additional errors and changes) are simply added to the ones already present in the argument changeset. Parameters are merged (<strong>not deep-merged</strong>) and the ones passed to <a href="#cast/3"><code class="inline">cast/3</code></a> take precedence over the ones already in the changeset.</p>    <h3 class="detail-header function" id="cast/4">  <span class="signature">cast(data, params, required, optional)</span>  </h3>  <p>WARNING: This function is deprecated in favor of <a href="#cast/3"><code class="inline">cast/3</code></a> + <a href="#validate_required/3"><code class="inline">validate_required/3</code></a>.</p> <p>Converts the given <code class="inline">params</code> into a changeset for <code class="inline">data</code> keeping only the set of <code class="inline">required</code> and <code class="inline">optional</code> keys.</p>    <h3 class="detail-header function" id="cast_assoc/3">  <span class="signature">cast_assoc(changeset, name, opts \\ [])</span>  </h3>  <p>Casts the given association.</p> <p>The parameters for the given association will be retrieved from <code class="inline">changeset.params</code> and the changeset function in the association module will be invoked. The function to be invoked may also be configured by using the <code class="inline">:with</code> option.</p> <p>The changeset must have been previously <code class="inline">cast</code> using <a href="#cast/3"><code class="inline">cast/3</code></a> before this function is invoked.</p> <h4>Options</h4> <ul> <li>
<code class="inline">:with</code> - the function to build the changeset from params. Defaults to the changeset/2 function in the association module </li> <li>
<code class="inline">:required</code> - if the association is a required field </li> <li>
<code class="inline">:required_message</code> - the message on failure, defaults to “can’t be blank” </li> <li>
<code class="inline">:invalid_message</code> - the message on failure, defaults to “is invalid” </li> </ul>    <h3 class="detail-header function" id="cast_embed/3">  <span class="signature">cast_embed(changeset, name, opts \\ [])</span>  </h3>  <p>Casts the given embed.</p> <p>The parameters for the given embed will be retrieved from <code class="inline">changeset.params</code> and the changeset function in the embed module will be invoked. The function to be invoked may also be configured by using the <code class="inline">:with</code> option.</p> <p>The changeset must have been previously <code class="inline">cast</code> using <a href="#cast/3"><code class="inline">cast/3</code></a> before this function is invoked.</p> <h4>Options</h4> <ul> <li>
<code class="inline">:with</code> - the function to build the changeset from params. Defaults to the changeset/2 function in the embed module </li> <li>
<code class="inline">:required</code> - if the embed is a required field </li> <li>
<code class="inline">:required_message</code> - the message on failure, defaults to “can’t be blank” </li> <li>
<code class="inline">:invalid_message</code> - the message on failure, defaults to “is invalid” </li> </ul>    <h3 class="detail-header function" id="change/2">  <span class="signature">change(data, changes \\ %{})</span>  </h3>  <h4 class="specs-title">Specs</h4>  <pre data-language="elixir"><code class="elixir">change(<a href="../ecto.schema/#t:t/0">Ecto.Schema.t</a> | <a href="#t:t/0">t</a> | {<a href="#t:data/0">data</a>, <a href="#t:types/0">types</a>}, %{optional(atom) =&gt; term} | <a href="http://elixir-lang.org/docs/stable/elixir/Keyword.html#t:t/0" target="_blank">Keyword.t</a>) ::
  <a href="#t:t/0">t</a> |
  no_return</code></pre>    <p>Wraps the given data in a changeset or adds changes to a changeset.</p> <p>Changed attributes will only be added if the change does not have the same value as the field in the data.</p> <p>This function is useful for:</p> <ul> <li>wrapping a struct inside a changeset </li> <li>directly changing a struct without performing castings nor validations </li> <li>directly bulk-adding changes to a changeset </li> </ul> <p>Since neither validation nor casting is performed, <a href="#change/2"><code class="inline">change/2</code></a> expects the keys in <code class="inline">changes</code> to be atoms. <code class="inline">changes</code> can be a map as well as a keyword list.</p> <p>When a changeset is passed as the first argument, the changes passed as the second argument are merged over the changes already in the changeset if they differ from the values in the struct. If <code class="inline">changes</code> is an empty map, this function is a no-op.</p> <p>When a <code class="inline">{data, types}</code> is passed as the first argument, a changeset is created with the given data and types and marked as valid.</p> <p>See <a href="#cast/3"><code class="inline">cast/3</code></a> if you’d prefer to cast and validate external parameters.</p> <h4>Examples</h4> <pre data-language="elixir"><code class="iex elixir">iex&gt; changeset = change(%Post{})
%Ecto.Changeset{...}
iex&gt; changeset.valid?
true
iex&gt; changeset.changes
%{}

iex&gt; changeset = change(%Post{author: "bar"}, title: "title")
iex&gt; changeset.changes
%{title: "title"}

iex&gt; changeset = change(%Post{title: "title"}, title: "title")
iex&gt; changeset.changes
%{}

iex&gt; changeset = change(changeset, %{title: "new title", body: "body"})
iex&gt; changeset.changes.title
"new title"
iex&gt; changeset.changes.body
"body"</code></pre>    <h3 class="detail-header function" id="check_constraint/3">  <span class="signature">check_constraint(changeset, field, opts \\ [])</span>  </h3>  <p>Checks for a check constraint in the given field.</p> <p>The check constraint works by relying on the database to check if the check constraint has been violated or not and, if so, Ecto converts it into a changeset error.</p> <h4>Options</h4> <ul> <li>
<code class="inline">:message</code> - the message in case the constraint check fails. Defaults to “is invalid” </li> <li>
<code class="inline">:name</code> - the name of the constraint. Required. </li> <li>
<code class="inline">:match</code> - how the changeset constraint name it matched against the repo constraint, may be <code class="inline">:exact</code> or <code class="inline">:suffix</code>. Defaults to <code class="inline">:exact</code>. <code class="inline">:suffix</code> matches any repo constraint which <code class="inline">ends_with?</code> <code class="inline">:name</code> to this changeset constraint. </li> </ul>    <h3 class="detail-header function" id="delete_change/2">  <span class="signature">delete_change(changeset, key)</span>  </h3>  <h4 class="specs-title">Specs</h4>  <pre data-language="elixir"><code class="elixir">delete_change(<a href="#t:t/0">t</a>, atom) :: <a href="#t:t/0">t</a></code></pre>    <p>Deletes a change with the given key.</p> <h4>Examples</h4> <pre data-language="elixir"><code class="iex elixir">iex&gt; changeset = change(%Post{}, %{title: "foo"})
iex&gt; changeset = delete_change(changeset, :title)
iex&gt; get_change(changeset, :title)
nil</code></pre>    <h3 class="detail-header function" id="exclusion_constraint/3">  <span class="signature">exclusion_constraint(changeset, field, opts \\ [])</span>  </h3>  <p>Checks for an exclusion constraint in the given field.</p> <p>The exclusion constraint works by relying on the database to check if the exclusion constraint has been violated or not and, if so, Ecto converts it into a changeset error.</p> <h4>Options</h4> <ul> <li>
<code class="inline">:message</code> - the message in case the constraint check fails, defaults to “violates an exclusion constraint” </li> <li>
<code class="inline">:name</code> - the constraint name. By default, the constraint name is inferred from the table + field. May be required explicitly for complex cases </li> <li>
<code class="inline">:match</code> - how the changeset constraint name it matched against the repo constraint, may be <code class="inline">:exact</code> or <code class="inline">:suffix</code>. Defaults to <code class="inline">:exact</code>. <code class="inline">:suffix</code> matches any repo constraint which <code class="inline">ends_with?</code> <code class="inline">:name</code> to this changeset constraint. </li> </ul>    <h3 class="detail-header function" id="fetch_change/2">  <span class="signature">fetch_change(changeset, key)</span>  </h3>  <h4 class="specs-title">Specs</h4>  <pre data-language="elixir"><code class="elixir">fetch_change(<a href="#t:t/0">t</a>, atom) :: {:ok, term} | :error</code></pre>    <p>Fetches a change from the given changeset.</p> <p>This function only looks at the <code class="inline">:changes</code> field of the given <code class="inline">changeset</code> and returns <code class="inline">{:ok, value}</code> if the change is present or <code class="inline">:error</code> if it’s not.</p> <h4>Examples</h4> <pre data-language="elixir"><code class="iex elixir">iex&gt; changeset = change(%Post{body: "foo"}, %{title: "bar"})
iex&gt; fetch_change(changeset, :title)
{:ok, "bar"}
iex&gt; fetch_change(changeset, :body)
:error</code></pre>    <h3 class="detail-header function" id="fetch_field/2">  <span class="signature">fetch_field(changeset, key)</span>  </h3>  <h4 class="specs-title">Specs</h4>  <pre data-language="elixir"><code class="elixir">fetch_field(<a href="#t:t/0">t</a>, atom) ::
  {:changes, term} |
  {:data, term} |
  :error</code></pre>    <p>Fetches the given field from changes or from the data.</p> <p>While <a href="#fetch_change/2"><code class="inline">fetch_change/2</code></a> only looks at the current <code class="inline">changes</code> to retrieve a value, this function looks at the changes and then falls back on the data, finally returning <code class="inline">:error</code> if no value is available.</p> <p>For relations, these functions will return the changeset original data with changes applied. To retrieve raw changesets, please use <a href="#fetch_change/2"><code class="inline">fetch_change/2</code></a>.</p> <h4>Examples</h4> <pre data-language="elixir"><code class="iex elixir">iex&gt; post = %Post{title: "Foo", body: "Bar baz bong"}
iex&gt; changeset = change(post, %{title: "New title"})
iex&gt; fetch_field(changeset, :title)
{:changes, "New title"}
iex&gt; fetch_field(changeset, :body)
{:data, "Bar baz bong"}
iex&gt; fetch_field(changeset, :not_a_field)
:error</code></pre>    <h3 class="detail-header function" id="force_change/3">  <span class="signature">force_change(changeset, key, value)</span>  </h3>  <h4 class="specs-title">Specs</h4>  <pre data-language="elixir"><code class="elixir">force_change(<a href="#t:t/0">t</a>, atom, term) :: <a href="#t:t/0">t</a> | no_return</code></pre>    <p>Forces a change on the given <code class="inline">key</code> with <code class="inline">value</code>.</p> <p>If the change is already present, it is overridden with the new value.</p> <h4>Examples</h4> <pre data-language="elixir"><code class="iex elixir">iex&gt; changeset = change(%Post{author: "bar"}, %{title: "foo"})
iex&gt; changeset = force_change(changeset, :title, "bar")
iex&gt; changeset.changes
%{title: "bar"}

iex&gt; changeset = force_change(changeset, :author, "bar")
iex&gt; changeset.changes
%{title: "bar", author: "bar"}</code></pre>    <h3 class="detail-header function" id="foreign_key_constraint/3">  <span class="signature">foreign_key_constraint(changeset, field, opts \\ [])</span>  </h3>  <h4 class="specs-title">Specs</h4>  <pre data-language="elixir"><code class="elixir">foreign_key_constraint(<a href="#t:t/0">t</a>, atom, <a href="http://elixir-lang.org/docs/stable/elixir/Keyword.html#t:t/0" target="_blank">Keyword.t</a>) :: <a href="#t:t/0">t</a></code></pre>    <p>Checks for foreign key constraint in the given field.</p> <p>The foreign key constraint works by relying on the database to check if the associated data exists or not. This is useful to guarantee that a child will only be created if the parent exists in the database too.</p> <p>In order to use the foreign key constraint the first step is to define the foreign key in a migration. This is often done with references. For example, imagine you are creating a comments table that belongs to posts. One would have:</p> <pre data-language="elixir"><code class="elixir">create table(:comments) do
  add :post_id, references(:posts)
end</code></pre> <p>By default, Ecto will generate a foreign key constraint with name “comments_post_id_fkey” (the name is configurable).</p> <p>Now that a constraint exists, when creating comments, we could annotate the changeset with foreign key constraint so Ecto knows how to convert it into an error message:</p> <pre data-language="elixir"><code class="elixir">cast(comment, params, [:post_id])
|&gt; foreign_key_constraint(:post_id)</code></pre> <p>Now, when invoking <code class="inline">Repo.insert/2</code> or <code class="inline">Repo.update/2</code>, if the associated post does not exist, it will be converted into an error and <code class="inline">{:error, changeset}</code> returned by the repository.</p> <h4>Options</h4> <ul> <li>
<code class="inline">:message</code> - the message in case the constraint check fails, defaults to “does not exist” </li> <li>
<code class="inline">:name</code> - the constraint name. By default, the constraint name is inferred from the table + field. May be required explicitly for complex cases </li> </ul>    <h3 class="detail-header function" id="get_change/3">  <span class="signature">get_change(changeset, key, default \\ nil)</span>  </h3>  <h4 class="specs-title">Specs</h4>  <pre data-language="elixir"><code class="elixir">get_change(<a href="#t:t/0">t</a>, atom, term) :: term</code></pre>    <p>Gets a change or returns a default value.</p> <h4>Examples</h4> <pre data-language="elixir"><code class="iex elixir">iex&gt; changeset = change(%Post{body: "foo"}, %{title: "bar"})
iex&gt; get_change(changeset, :title)
"bar"
iex&gt; get_change(changeset, :body)
nil</code></pre>    <h3 class="detail-header function" id="get_field/3">  <span class="signature">get_field(changeset, key, default \\ nil)</span>  </h3>  <h4 class="specs-title">Specs</h4>  <pre data-language="elixir"><code class="elixir">get_field(<a href="#t:t/0">t</a>, atom, term) :: term</code></pre>    <p>Gets a field from changes or from the data.</p> <p>While <a href="#get_change/3"><code class="inline">get_change/3</code></a> only looks at the current <code class="inline">changes</code> to retrieve a value, this function looks at the changes and then falls back on the data, finally returning <code class="inline">default</code> if no value is available.</p> <p>For relations, these functions will return the changeset data with changes applied. To retrieve raw changesets, please use <a href="#get_change/3"><code class="inline">get_change/3</code></a>.</p> <pre data-language="elixir"><code class="iex elixir">iex&gt; post = %Post{title: "A title", body: "My body is a cage"}
iex&gt; changeset = change(post, %{title: "A new title"})
iex&gt; get_field(changeset, :title)
"A new title"
iex&gt; get_field(changeset, :not_a_field, "Told you, not a field!")
"Told you, not a field!"</code></pre>    <h3 class="detail-header function" id="merge/2">  <span class="signature">merge(changeset1, changeset2)</span>  </h3>  <h4 class="specs-title">Specs</h4>  <pre data-language="elixir"><code class="elixir">merge(<a href="#t:t/0">t</a>, <a href="#t:t/0">t</a>) :: <a href="#t:t/0">t</a> | no_return</code></pre>    <p>Merges two changesets.</p> <p>This function merges two changesets provided they have been applied to the same data (their <code class="inline">:data</code> field is equal); if the data differs, an <code class="inline">ArgumentError</code> exception is raised. If one of the changesets has a <code class="inline">:repo</code> field which is not <code class="inline">nil</code>, then the value of that field is used as the <code class="inline">:repo</code> field of the resulting changeset; if both changesets have a non-<code class="inline">nil</code> and different <code class="inline">:repo</code> field, an <code class="inline">ArgumentError</code> exception is raised.</p> <p>The other fields are merged with the following criteria:</p> <ul> <li>
<code class="inline">params</code> - params are merged (not deep-merged) giving precedence to the params of <code class="inline">changeset2</code> in case of a conflict. If both changesets have their <code class="inline">:params</code> fields set to <code class="inline">nil</code>, the resulting changeset will have its params set to <code class="inline">nil</code> too. </li> <li>
<code class="inline">changes</code> - changes are merged giving precedence to the <code class="inline">changeset2</code> changes. </li> <li>
<code class="inline">errors</code> and <code class="inline">validations</code> - they are simply concatenated. </li> <li>
<code class="inline">required</code> - required fields are merged; all the fields that appear in the required list of both changesets are moved to the required list of the resulting changeset. </li> </ul> <h4>Examples</h4> <pre data-language="elixir"><code class="iex elixir">iex&gt; changeset1 = cast(%Post{}, %{title: "Title"}, [:title])
iex&gt; changeset2 = cast(%Post{}, %{title: "New title", body: "Body"}, [:title, :body])
iex&gt; changeset = merge(changeset1, changeset2)
iex&gt; changeset.changes
%{body: "Body", title: "New title"}

iex&gt; changeset1 = cast(%Post{body: "Body"}, %{title: "Title"}, [:title])
iex&gt; changeset2 = cast(%Post{}, %{title: "New title"}, [:title])
iex&gt; merge(changeset1, changeset2)
** (ArgumentError) different :data when merging changesets</code></pre>    <h3 class="detail-header function" id="no_assoc_constraint/3">  <span class="signature">no_assoc_constraint(changeset, assoc, opts \\ [])</span>  </h3>  <h4 class="specs-title">Specs</h4>  <pre data-language="elixir"><code class="elixir">no_assoc_constraint(<a href="#t:t/0">t</a>, atom, <a href="http://elixir-lang.org/docs/stable/elixir/Keyword.html#t:t/0" target="_blank">Keyword.t</a>) ::
  <a href="#t:t/0">t</a> |
  no_return</code></pre>    <p>Checks the associated field does not exist.</p> <p>This is similar to <a href="#foreign_key_constraint/3"><code class="inline">foreign_key_constraint/3</code></a> except that the field is inferred from the association definition. This is useful to guarantee that parent can only be deleted (or have its primary key changed) if no child exists in the database. Therefore, it only applies to <code class="inline">has_*</code> associations.</p> <p>As the name says, a constraint is required in the database for this function to work. Such constraint is often added as a reference to the child table:</p> <pre data-language="elixir"><code class="elixir">create table(:comments) do
  add :post_id, references(:posts)
end</code></pre> <p>Now, when deleting the post, it is possible to forbid any post to be deleted if they still have comments attached to it:</p> <pre data-language="elixir"><code class="elixir">post
|&gt; Ecto.Changeset.change
|&gt; Ecto.Changeset.no_assoc_constraint(:comments)
|&gt; Repo.delete</code></pre> <h4>Options</h4> <ul> <li>
<code class="inline">:message</code> - the message in case the constraint check fails, defaults to “is still associated to this entry” (for has_one) and “are still associated to this entry” (for has_many) </li> <li>
<code class="inline">:name</code> - the constraint name. By default, the constraint name is inferred from the association table + association field. May be required explicitly for complex cases </li> </ul>    <h3 class="detail-header function" id="optimistic_lock/3">  <span class="signature">optimistic_lock(data_or_changeset, field, incrementer \\ &amp;(&amp;1 + 1))</span>  </h3>  <h4 class="specs-title">Specs</h4>  <pre data-language="elixir"><code class="elixir">optimistic_lock(<a href="../ecto.schema/#t:t/0">Ecto.Schema.t</a> | <a href="#t:t/0">t</a>, atom, (integer -&gt; integer)) ::
  <a href="#t:t/0">t</a> |
  no_return</code></pre>    <p>Applies optimistic locking to the changeset.</p> <p><a href="http://en.wikipedia.org/wiki/Optimistic_concurrency_control" target="_blank">Optimistic locking</a> (or <em>optimistic concurrency control</em>) is a technique that allows concurrent edits on a single record. While pessimistic locking works by locking a resource for an entire transaction, optimistic locking only checks if the resource changed before updating it.</p> <p>This is done by regularly fetching the record from the database, then checking whether another user has made changes to the record <em>only when updating the record</em>. This behaviour is ideal in situations where the chances of concurrent updates to the same record are low; if they’re not, pessimistic locking or other concurrency patterns may be more suited.</p> <h4>Usage</h4> <p>Optimistic locking works by keeping a “version” counter for each record; this counter gets incremented each time a modification is made to a record. Hence, in order to use optimistic locking, a field must exist in your schema for versioning purpose. Such field is usually an integer but other types are supported.</p> <h4>Examples</h4> <p>Assuming we have a <code class="inline">Post</code> schema (stored in the <code class="inline">posts</code> table), the first step is to add a version column to the <code class="inline">posts</code> table:</p> <pre data-language="elixir"><code class="elixir">alter table(:posts) do
  add :lock_version, :integer, default: 1
end</code></pre> <p>The column name is arbitrary and doesn’t need to be <code class="inline">:lock_version</code>. Now add a field to the schema too:</p> <pre data-language="elixir"><code class="elixir">defmodule Post do
  use Ecto.Schema

  schema "posts" do
    field :title, :string
    field :lock_version, :integer, default: 1
  end

  def changeset(:update, struct, params \\ %{}) do
    struct
    |&gt; Ecto.Changeset.cast(params, [:title])
    |&gt; Ecto.Changeset.optimistic_lock(:lock_version)
  end
end</code></pre> <p>Now let’s take optimistic locking for a spin:</p> <pre data-language="elixir"><code class="iex elixir">iex&gt; post = Repo.insert!(%Post{title: "foo"})
%Post{id: 1, title: "foo", lock_version: 1}
iex&gt; valid_change = Post.changeset(:update, post, %{title: "bar"})
iex&gt; stale_change = Post.changeset(:update, post, %{title: "baz"})
iex&gt; Repo.update!(valid_change)
%Post{id: 1, title: "bar", lock_version: 2}
iex&gt; Repo.update!(stale_change)
** (Ecto.StaleEntryError) attempted to update a stale entry:

%Post{id: 1, title: "baz", lock_version: 1}</code></pre> <p>When a conflict happens (a record which has been previously fetched is being updated, but that same record has been modified since it was fetched), an <a href="../ecto.staleentryerror/"><code class="inline">Ecto.StaleEntryError</code></a> exception is raised.</p> <p>Optimistic locking also works with delete operations. Just call the <code class="inline">optimistic_lock</code> function with the data before delete:</p> <pre data-language="elixir"><code class="iex elixir">iex&gt; changeset = Ecto.Changeset.optimistic_lock(post, :lock_version)
iex&gt; Repo.delete(changeset)</code></pre> <p><a href="#optimistic_lock/3"><code class="inline">optimistic_lock/3</code></a> by default assumes the field being used as a lock is an integer. If you want to use another type, you need to pass the third argument customizing how the next value is generated:</p> <pre data-language="elixir"><code class="iex elixir">iex&gt; Ecto.Changeset.optimistic_lock(post, :lock_uuid, fn _ -&gt; Ecto.UUID.generate end)</code></pre>    <h3 class="detail-header function" id="prepare_changes/2">  <span class="signature">prepare_changes(changeset, function)</span>  </h3>  <h4 class="specs-title">Specs</h4>  <pre data-language="elixir"><code class="elixir">prepare_changes(<a href="#t:t/0">t</a>, (<a href="#t:t/0">t</a> -&gt; <a href="#t:t/0">t</a>)) :: <a href="#t:t/0">t</a></code></pre>    <p>Provides a function to run before emitting changes to the repository.</p> <p>Such function receives the changeset and must return a changeset, allowing developers to do final adjustments to the changeset or to issue data consistency commands.</p> <p>The given function is guaranteed to run inside the same transaction as the changeset operation for databases that do support transactions.</p> <h4>Example</h4> <p>A common use case is updating a counter cache, in this case updating a post’s comment count when a comment is created:</p> <pre data-language="elixir"><code class="elixir">def create_comment(comment, params) do
  comment
  |&gt; cast(params, [:body, :post_id])
  |&gt; prepare_changes(fn changeset -&gt;
    assoc(changeset.data, :post)
    |&gt; changeset.repo.update_all(inc: [comment_count: 1])
    changeset
  end)
end</code></pre> <p>We retrieve the repo and from the comment changeset itself, and use update_all to update the counter cache in one query. Finally, the original changeset must be returned.</p>    <h3 class="detail-header function" id="put_assoc/4">  <span class="signature">put_assoc(changeset, name, value, opts \\ [])</span>  </h3>  <p>Puts the given association as a change in the changeset.</p> <p>The given value may either be the association struct, a changeset for the given association or a map or keyword list of changes to be applied to the current association. If a map or keyword list are given and there is no association, one will be created.</p> <p>If the association has no changes, it will be skipped. If the association is invalid, the changeset will be marked as invalid. If the given value is not an association, it will raise.</p>    <h3 class="detail-header function" id="put_change/3">  <span class="signature">put_change(changeset, key, value)</span>  </h3>  <h4 class="specs-title">Specs</h4>  <pre data-language="elixir"><code class="elixir">put_change(<a href="#t:t/0">t</a>, atom, term) :: <a href="#t:t/0">t</a> | no_return</code></pre>    <p>Puts a change on the given <code class="inline">key</code> with <code class="inline">value</code>.</p> <p>If the change is already present, it is overridden with the new value, also, if the change has the same value as in the changeset data, it is not added to the list of changes.</p> <h4>Examples</h4> <pre data-language="elixir"><code class="iex elixir">iex&gt; changeset = change(%Post{author: "bar"}, %{title: "foo"})
iex&gt; changeset = put_change(changeset, :title, "bar")
iex&gt; changeset.changes
%{title: "bar"}

iex&gt; changeset = put_change(changeset, :author, "bar")
iex&gt; changeset.changes
%{title: "bar"}</code></pre>    <h3 class="detail-header function" id="put_embed/4">  <span class="signature">put_embed(changeset, name, value, opts \\ [])</span>  </h3>  <p>Puts the given embed as a change in the changeset.</p> <p>The given value may either be the embed struct, a changeset for the given embed or a map or keyword list of changes to be applied to the current embed. If a map or keyword list are given and there is no embed, one will be created.</p> <p>If the embed has no changes, it will be skipped. If the embed is invalid, the changeset will be marked as invalid. If the given value is not an embed, it will raise.</p>    <h3 class="detail-header function" id="traverse_errors/2">  <span class="signature">traverse_errors(changeset, msg_func)</span>  </h3>  <h4 class="specs-title">Specs</h4>  <pre data-language="elixir"><code class="elixir">traverse_errors(<a href="#t:t/0">t</a>, (<a href="#t:error/0">error</a> -&gt; <a href="http://elixir-lang.org/docs/stable/elixir/String.html#t:t/0" target="_blank">String.t</a>)) :: %{optional(atom) =&gt; [<a href="http://elixir-lang.org/docs/stable/elixir/String.html#t:t/0" target="_blank">String.t</a>]}</code></pre>    <p>Traverses changeset errors and applies the given function to error messages.</p> <p>This function is particularly useful when associations and embeds are cast in the changeset as it will traverse all associations and embeds and place all errors in a series of nested maps.</p> <p>A changeset is supplied along with a function to apply to each error message as the changeset is traversed. The error message function receives an error tuple <code class="inline">{msg, opts}</code>, for example:</p> <pre data-language="elixir"><code class="elixir">{"should be at least %{count} characters", [count: 3]}</code></pre> <h4>Examples</h4> <pre data-language="elixir"><code class="iex elixir">iex&gt; traverse_errors(changeset, fn {msg, opts} -&gt;
...&gt;   Enum.reduce(opts, msg, fn {key, value}, acc -&gt;
...&gt;     String.replace(msg, "%{#{key}}", to_string(value))
...&gt;   end)
...&gt; end)
%{title: ["should be at least 3 characters"]}</code></pre>    <h3 class="detail-header function" id="unique_constraint/3">  <span class="signature">unique_constraint(changeset, field, opts \\ [])</span>  </h3>  <h4 class="specs-title">Specs</h4>  <pre data-language="elixir"><code class="elixir">unique_constraint(<a href="#t:t/0">t</a>, atom, <a href="http://elixir-lang.org/docs/stable/elixir/Keyword.html#t:t/0" target="_blank">Keyword.t</a>) :: <a href="#t:t/0">t</a></code></pre>    <p>Checks for a unique constraint in the given field.</p> <p>The unique constraint works by relying on the database to check if the unique constraint has been violated or not and, if so, Ecto converts it into a changeset error.</p> <p>In order to use the uniqueness constraint, the first step is to define the unique index in a migration:</p> <pre data-language="elixir"><code class="elixir">create unique_index(:users, [:email])</code></pre> <p>Now that a constraint exists, when modifying users, we could annotate the changeset with unique constraint so Ecto knows how to convert it into an error message:</p> <pre data-language="elixir"><code class="elixir">cast(user, params, [:email])
|&gt; unique_constraint(:email)</code></pre> <p>Now, when invoking <code class="inline">Repo.insert/2</code> or <code class="inline">Repo.update/2</code>, if the email already exists, it will be converted into an error and <code class="inline">{:error, changeset}</code> returned by the repository. Note that the error will occur only after hitting the database so it will not be visible until all other validations pass.</p> <h4>Options</h4> <ul> <li>
<code class="inline">:message</code> - the message in case the constraint check fails, defaults to “has already been taken” </li> <li>
<code class="inline">:name</code> - the constraint name. By default, the constraint name is inferred from the table + field. May be required explicitly for complex cases </li> <li>
<code class="inline">:match</code> - how the changeset constraint name it matched against the repo constraint, may be <code class="inline">:exact</code> or <code class="inline">:suffix</code>. Defaults to <code class="inline">:exact</code>. <code class="inline">:suffix</code> matches any repo constraint which <code class="inline">ends_with?</code> <code class="inline">:name</code> to this changeset constraint. </li> </ul> <h4>Complex constraints</h4> <p>Because the constraint logic is in the database, we can leverage all the database functionality when defining them. For example, let’s suppose the e-mails are scoped by company id. We would write in a migration:</p> <pre data-language="elixir"><code class="elixir">create unique_index(:users, [:email, :company_id])</code></pre> <p>Because such indexes have usually more complex names, we need to explicitly tell the changeset which constraint name to use:</p> <pre data-language="elixir"><code class="elixir">cast(user, params, [:email])
|&gt; unique_constraint(:email, name: :posts_special_email_index)</code></pre> <p>Alternatively, you can give both <code class="inline">unique_index</code> and <code class="inline">unique_constraint</code> the same name:</p> <pre data-language="elixir"><code class="elixir"># In the migration
create unique_index(:users, [:email, :company_id], name: :posts_email_company_id_index)

# In the changeset function
cast(user, params, [:email])
|&gt; unique_constraint(:email, name: :posts_email_company_id_index)</code></pre> <h4>Case sensitivity</h4> <p>Unfortunately, different databases provide different guarantees when it comes to case-sensitiveness. For example, in MySQL, comparisons are case-insensitive by default. In Postgres, users can define case insensitive column by using the <code class="inline">:citext</code> type/extension.</p> <p>If for some reason your database does not support case insensitive columns, you can explicitly downcase values before inserting/updating them:</p> <pre data-language="elixir"><code class="elixir">cast(data, params, [:email])
|&gt; update_change(:email, &amp;String.downcase/1)
|&gt; unique_constraint(:email)</code></pre>    <h3 class="detail-header function" id="update_change/3">  <span class="signature">update_change(changeset, key, function)</span>  </h3>  <h4 class="specs-title">Specs</h4>  <pre data-language="elixir"><code class="elixir">update_change(<a href="#t:t/0">t</a>, atom, (term -&gt; term)) :: <a href="#t:t/0">t</a></code></pre>    <p>Updates a change.</p> <p>The given <code class="inline">function</code> is invoked with the change value only if there is a change for the given <code class="inline">key</code>. Note that the value of the change can still be <code class="inline">nil</code> (unless the field was marked as required on <a href="#cast/3)"><code class="inline">cast/3</code></a>.</p> <h4>Examples</h4> <pre data-language="elixir"><code class="iex elixir">iex&gt; changeset = change(%Post{}, %{impressions: 1})
iex&gt; changeset = update_change(changeset, :impressions, &amp;(&amp;1 + 1))
iex&gt; changeset.changes.impressions
2</code></pre>    <h3 class="detail-header function" id="validate_acceptance/3">  <span class="signature">validate_acceptance(changeset, field, opts \\ [])</span>  </h3>  <h4 class="specs-title">Specs</h4>  <pre data-language="elixir"><code class="elixir">validate_acceptance(<a href="#t:t/0">t</a>, atom, <a href="http://elixir-lang.org/docs/stable/elixir/Keyword.html#t:t/0" target="_blank">Keyword.t</a>) :: <a href="#t:t/0">t</a></code></pre>    <p>Validates the given parameter was given as true.</p> <p>This validation is used to check for one specific parameter being true and as such does not require the field to effectively exist in the schema or the data being validated.</p> <h4>Options</h4> <ul> <li>
<code class="inline">:message</code> - the message on failure, defaults to “must be accepted” </li> </ul> <h4>Examples</h4> <pre data-language="elixir"><code class="elixir">validate_acceptance(changeset, :terms_of_service)
validate_acceptance(changeset, :rules, message: "please accept rules")</code></pre>    <h3 class="detail-header function" id="validate_change/3">  <span class="signature">validate_change(changeset, field, validator)</span>  </h3>  <h4 class="specs-title">Specs</h4>  <pre data-language="elixir"><code class="elixir">validate_change(<a href="#t:t/0">t</a>, atom, (atom, term -&gt; [<a href="#t:error/0">error</a>])) :: <a href="#t:t/0">t</a></code></pre>    <p>Validates the given <code class="inline">field</code> change.</p> <p>It invokes the <code class="inline">validator</code> function to perform the validation only if a change for the given <code class="inline">field</code> exists and the change value is not <code class="inline">nil</code>. The function must return a list of errors (with an empty list meaning no errors).</p> <p>In case there’s at least one error, the list of errors will be appended to the <code class="inline">:errors</code> field of the changeset and the <code class="inline">:valid?</code> flag will be set to <code class="inline">false</code>.</p> <h4>Examples</h4> <pre data-language="elixir"><code class="iex elixir">iex&gt; changeset = change(%Post{}, %{title: "foo"})
iex&gt; changeset = validate_change changeset, :title, fn :title, title  -&gt;
...&gt;   # Value must not be "foo"!
...&gt;   if title == "foo" do
...&gt;     [title: "cannot be foo"]
...&gt;   else
...&gt;     []
...&gt;   end
...&gt; end
iex&gt; changeset.errors
[title: {"cannot be foo", []}]</code></pre>    <h3 class="detail-header function" id="validate_change/4">  <span class="signature">validate_change(changeset, field, metadata, validator)</span>  </h3>  <h4 class="specs-title">Specs</h4>  <pre data-language="elixir"><code class="elixir">validate_change(<a href="#t:t/0">t</a>, atom, term, (atom, term -&gt; [<a href="#t:error/0">error</a>])) :: <a href="#t:t/0">t</a></code></pre>    <p>Stores the validation <code class="inline">metadata</code> and validates the given <code class="inline">field</code> change.</p> <p>Similar to <a href="#validate_change/3"><code class="inline">validate_change/3</code></a> but stores the validation metadata into the changeset validators. The validator metadata is often used as a reflection mechanism, to automatically generate code based on the available validations.</p> <h4>Examples</h4> <pre data-language="elixir"><code class="iex elixir">iex&gt; changeset = change(%Post{}, %{title: "foo"})
iex&gt; changeset = validate_change changeset, :title, :useless_validator, fn
...&gt;   _, _ -&gt; []
...&gt; end
iex&gt; changeset.validations
[title: :useless_validator]</code></pre>    <h3 class="detail-header function" id="validate_confirmation/3">  <span class="signature">validate_confirmation(changeset, field, opts \\ [])</span>  </h3>  <h4 class="specs-title">Specs</h4>  <pre data-language="elixir"><code class="elixir">validate_confirmation(<a href="#t:t/0">t</a>, atom, <a href="http://elixir-lang.org/docs/stable/elixir/Keyword.html#t:t/0" target="_blank">Keyword.t</a>) :: <a href="#t:t/0">t</a></code></pre>    <p>Validates that the given field matches the confirmation parameter of that field.</p> <p>By calling <code class="inline">validate_confirmation(changeset, :email)</code>, this validation will check if both “email” and “email_confirmation” in the parameter map matches.</p> <p>Note that if the confirmation field is nil or missing, by default this does not add a validation error. You can specify that the confirmation field is required in the options (see below). Note “email_confirmation” does not need to be added as a virtual field in your schema.</p> <h4>Options</h4> <ul> <li>
<code class="inline">:message</code> - the message on failure, defaults to “does not match” </li> <li>
<code class="inline">:required</code> - boolean, sets whether existence of confirmation parameter is required for addition of error. Defaults to false </li> </ul> <h4>Examples</h4> <pre data-language="elixir"><code class="elixir">validate_confirmation(changeset, :email)
validate_confirmation(changeset, :password, message: "does not match password")

cast(data, params, [:password])
|&gt; validate_confirmation(:password, message: "does not match password")</code></pre>    <h3 class="detail-header function" id="validate_exclusion/4">  <span class="signature">validate_exclusion(changeset, field, data, opts \\ [])</span>  </h3>  <h4 class="specs-title">Specs</h4>  <pre data-language="elixir"><code class="elixir">validate_exclusion(<a href="#t:t/0">t</a>, atom, <a href="http://elixir-lang.org/docs/stable/elixir/Enum.html#t:t/0" target="_blank">Enum.t</a>, <a href="http://elixir-lang.org/docs/stable/elixir/Keyword.html#t:t/0" target="_blank">Keyword.t</a>) :: <a href="#t:t/0">t</a></code></pre>    <p>Validates a change is not included in the given enumerable.</p> <h4>Options</h4> <ul> <li>
<code class="inline">:message</code> - the message on failure, defaults to “is reserved” </li> </ul> <h4>Examples</h4> <pre data-language="elixir"><code class="elixir">validate_exclusion(changeset, :name, ~w(admin superadmin))</code></pre>    <h3 class="detail-header function" id="validate_format/4">  <span class="signature">validate_format(changeset, field, format, opts \\ [])</span>  </h3>  <h4 class="specs-title">Specs</h4>  <pre data-language="elixir"><code class="elixir">validate_format(<a href="#t:t/0">t</a>, atom, <a href="http://elixir-lang.org/docs/stable/elixir/Regex.html#t:t/0" target="_blank">Regex.t</a>, <a href="http://elixir-lang.org/docs/stable/elixir/Keyword.html#t:t/0" target="_blank">Keyword.t</a>) :: <a href="#t:t/0">t</a></code></pre>    <p>Validates a change has the given format.</p> <p>The format has to be expressed as a regular expression.</p> <h4>Options</h4> <ul> <li>
<code class="inline">:message</code> - the message on failure, defaults to “has invalid format” </li> </ul> <h4>Examples</h4> <pre data-language="elixir"><code class="elixir">validate_format(changeset, :email, ~r/@/)</code></pre>    <h3 class="detail-header function" id="validate_inclusion/4">  <span class="signature">validate_inclusion(changeset, field, data, opts \\ [])</span>  </h3>  <h4 class="specs-title">Specs</h4>  <pre data-language="elixir"><code class="elixir">validate_inclusion(<a href="#t:t/0">t</a>, atom, <a href="http://elixir-lang.org/docs/stable/elixir/Enum.html#t:t/0" target="_blank">Enum.t</a>, <a href="http://elixir-lang.org/docs/stable/elixir/Keyword.html#t:t/0" target="_blank">Keyword.t</a>) :: <a href="#t:t/0">t</a></code></pre>    <p>Validates a change is included in the given enumerable.</p> <h4>Options</h4> <ul> <li>
<code class="inline">:message</code> - the message on failure, defaults to “is invalid” </li> </ul> <h4>Examples</h4> <pre data-language="elixir"><code class="elixir">validate_inclusion(changeset, :gender, ["man", "woman", "other", "prefer not to say"])
validate_inclusion(changeset, :age, 0..99)</code></pre>    <h3 class="detail-header function" id="validate_length/3">  <span class="signature">validate_length(changeset, field, opts)</span>  </h3>  <h4 class="specs-title">Specs</h4>  <pre data-language="elixir"><code class="elixir">validate_length(<a href="#t:t/0">t</a>, atom, <a href="http://elixir-lang.org/docs/stable/elixir/Keyword.html#t:t/0" target="_blank">Keyword.t</a>) :: <a href="#t:t/0">t</a></code></pre>    <p>Validates a change is a string or list of the given length.</p> <h4>Options</h4> <ul> <li>
<code class="inline">:is</code> - the length must be exactly this value </li> <li>
<code class="inline">:min</code> - the length must be greater than or equal to this value </li> <li>
<code class="inline">:max</code> - the length must be less than or equal to this value </li> <li>
<p><code class="inline">:message</code> - the message on failure, depending on the validation, is one of:</p> <ul> <li>for strings: </li> <li>“should be %{count} character(s)” </li> <li>“should be at least %{count} character(s)” </li> <li>“should be at most %{count} character(s)” </li> <li>for lists: </li> <li>“should have %{count} item(s)” </li> <li>“should have at least %{count} item(s)” </li> <li>“should have at most %{count} item(s)” </li> </ul> </li> </ul> <h4>Examples</h4> <pre data-language="elixir"><code class="elixir">validate_length(changeset, :title, min: 3)
validate_length(changeset, :title, max: 100)
validate_length(changeset, :title, min: 3, max: 100)
validate_length(changeset, :code, is: 9)
validate_length(changeset, :topics, is: 2)</code></pre>    <h3 class="detail-header function" id="validate_number/3">  <span class="signature">validate_number(changeset, field, opts)</span>  </h3>  <h4 class="specs-title">Specs</h4>  <pre data-language="elixir"><code class="elixir">validate_number(<a href="#t:t/0">t</a>, atom, <a href="http://elixir-lang.org/docs/stable/elixir/Keyword.html#t:t/0" target="_blank">Keyword.t</a>) ::
  <a href="#t:t/0">t</a> |
  no_return</code></pre>    <p>Validates the properties of a number.</p> <h4>Options</h4> <ul> <li>
<code class="inline">:less_than</code> </li> <li>
<code class="inline">:greater_than</code> </li> <li>
<code class="inline">:less_than_or_equal_to</code> </li> <li>
<code class="inline">:greater_than_or_equal_to</code> </li> <li>
<code class="inline">:equal_to</code> </li> <li>
<p><code class="inline">:message</code> - the message on failure, defaults to one of:</p> <ul> <li>“must be less than %{count}” </li> <li>“must be greater than %{count}” </li> <li>“must be less than or equal to %{count}” </li> <li>“must be greater than or equal to %{count}” </li> <li>“must be equal to %{count}” </li> </ul> </li> </ul> <h4>Examples</h4> <pre data-language="elixir"><code class="elixir">validate_number(changeset, :count, less_than: 3)
validate_number(changeset, :pi, greater_than: 3, less_than: 4)
validate_number(changeset, :the_answer_to_life_the_universe_and_everything, equal_to: 42)</code></pre>    <h3 class="detail-header function" id="validate_required/3">  <span class="signature">validate_required(changeset, fields, opts \\ [])</span>  </h3>  <h4 class="specs-title">Specs</h4>  <pre data-language="elixir"><code class="elixir">validate_required(<a href="#t:t/0">t</a>, list | atom, <a href="http://elixir-lang.org/docs/stable/elixir/Keyword.html#t:t/0" target="_blank">Keyword.t</a>) :: <a href="#t:t/0">t</a></code></pre>    <p>Validates that one or more fields are present in the changeset.</p> <p>If the value of a field is <code class="inline">nil</code> or a string made only of whitespace, the changeset is marked as invalid and an error is added. Note the error won’t be added though if the field already has an error.</p> <p>You can pass a single field name or a list of field names that are required.</p> <p>Do not use this function to validate associations are required, instead pass the <code class="inline">:required</code> option to <a href="#cast_assoc/3"><code class="inline">cast_assoc/3</code></a>.</p> <h4>Options</h4> <ul> <li>
<code class="inline">:message</code> - the message on failure, defaults to “can’t be blank” </li> </ul> <h4>Examples</h4> <pre data-language="elixir"><code class="elixir">validate_required(changeset, :title)
validate_required(changeset, [:title, :body])</code></pre>    <h3 class="detail-header function" id="validate_subset/4">  <span class="signature">validate_subset(changeset, field, data, opts \\ [])</span>  </h3>  <h4 class="specs-title">Specs</h4>  <pre data-language="elixir"><code class="elixir">validate_subset(<a href="#t:t/0">t</a>, atom, <a href="http://elixir-lang.org/docs/stable/elixir/Enum.html#t:t/0" target="_blank">Enum.t</a>, <a href="http://elixir-lang.org/docs/stable/elixir/Keyword.html#t:t/0" target="_blank">Keyword.t</a>) :: <a href="#t:t/0">t</a></code></pre>    <p>Validates a change, of type enum, is a subset of the given enumerable. Like validate_inclusion/4 for lists.</p> <h4>Options</h4> <ul> <li>
<code class="inline">:message</code> - the message on failure, defaults to “has an invalid entry” </li> </ul> <h4>Examples</h4> <pre data-language="elixir"><code class="elixir">validate_subset(changeset, :pets, ["cat", "dog", "parrot"])
validate_subset(changeset, :lottery_numbers, 0..99)</code></pre>
<div class="_attribution">
  <p class="_attribution-p">
    © 2012 Plataformatec<br>Licensed under the Apache License, Version 2.0.<br>
    <a href="https://hexdocs.pm/ecto/Ecto.Changeset.html" class="_attribution-link" target="_blank">https://hexdocs.pm/ecto/Ecto.Changeset.html</a>
  </p>
</div>

			</div>
		</div>
	</section>

	</div>
</body>
</html>
