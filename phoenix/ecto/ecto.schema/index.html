
<!DOCTYPE HTML>

<html lang="en">

<head>
  <meta charset="utf-8">
  <title>Ecto.Schema - Phoenix - W3cubDocs</title>
  
  <meta name="description" content=" Defines a schema. ">
  <meta name="keywords" content="ecto, schema, summary, types, macros, -, phoenix">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="http://docs.w3cub.com/phoenix/ecto/ecto.schema/">
  <link href="/favicon.png" rel="icon">
  <link type="text/css" rel="stylesheet" href="/assets/application-50364fff564ce3b6327021805f3f00e2957b441cf27f576a7dd4ff63bbc47047.css">
  <script type="text/javascript" src="/assets/application-db64bfd54ceb42be11af7995804cf4902548419ceb79d509b0b7d62c22d98e6f.js"></script>
  <script src="/json/phoenix.js"></script>
  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-71174418-1']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>


</head>

<body>
	<div class="_app">
	<header class="_header">
  
  <form class="_search">
    <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
    <a class="_search-clear"></a>
    <div class="_search-tag"></div>
  </form>
  
  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/phoenix/" class="_nav-link" title="" style="margin-left:0;">Phoenix</a></span>
  
  <nav class="_nav">
    <a href="/app/" class="_nav-link ">App</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		<div class="_list">
			
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<div class="_page _elixir">
				
<h1>  Ecto.Schema  </h1>  <p>Defines a schema.</p> <p>An Ecto schema is used to map any data source into an Elixir struct. One of such use cases is to map data coming from a repository, usually a table, into Elixir structs.</p> <h2 id="module-example" class="section-heading">  Example </h2> <pre data-language="elixir"><code class="elixir">defmodule User do
  use Ecto.Schema

  schema "users" do
    field :name, :string
    field :age, :integer, default: 0
    has_many :posts, Post
  end
end</code></pre> <p>By default, a schema will generate a primary key, named <code class="inline">id</code> and of type <code class="inline">:integer</code>, and <code class="inline">belongs_to</code> associations in the schema will generate foreign keys of type <code class="inline">:integer</code>. These settings can be seen below.</p> <h2 id="module-schema-attributes" class="section-heading">  Schema attributes </h2> <p>Supported attributes, to be set beforehand, for configuring the defined schema.</p> <p>These attributes are:</p> <ul> <li>
<p><code class="inline">@primary_key</code> - configures the schema primary key. It expects a tuple <code class="inline">{field_name, type, options}</code> with the primary key field name, type (typically <code class="inline">:id</code> or <code class="inline">:binary_id</code>, but can be any type) and options. Defaults to <code class="inline">{:id, :id, autogenerate: true}</code>. When set to <code class="inline">false</code>, does not define a primary key in the schema;</p> </li> <li>
<p><code class="inline">@schema_prefix</code> - configures the schema prefix. Defaults to <code class="inline">nil</code>, which generates structs and queries without prefix. When set, the prefix will be used by every built struct as well as queries where the <code class="inline">from</code> is the current schema. In PostgreSQL, the prefix is called “SCHEMA” (typically set with schema search_path). In MySQL the prefix points to databases.</p> </li> <li>
<p><code class="inline">@foreign_key_type</code> - configures the default foreign key type used by <code class="inline">belongs_to</code> associations. Defaults to <code class="inline">:integer</code>;</p> </li> <li>
<p><code class="inline">@timestamps_opts</code> - configures the default timestamps type used by <code class="inline">timestamps</code>. Defaults to <code class="inline">[type: Ecto.DateTime, usec: false]</code>;</p> </li> <li>
<code class="inline">@derive</code> - the same as <code class="inline">@derive</code> available in <code class="inline">Kernel.defstruct/1</code> as the schema defines a struct behind the scenes; </li> </ul> <p>The advantage of configuring the schema via those attributes is that they can be set with a macro to configure application wide defaults.</p> <p>For example, if your database does not support autoincrementing primary keys and requires something like UUID or a RecordID, you can configure and use<code class="inline">:binary_id</code> as your primary key type as follows:</p> <pre data-language="elixir"><code class="elixir"># Define a module to be used as base
defmodule MyApp.Schema do
  defmacro __using__(_) do
    quote do
      use Ecto.Schema
      @primary_key {:id, :binary_id, autogenerate: true}
      @foreign_key_type :binary_id
    end
  end
end

# Now use MyApp.Schema to define new schemas
defmodule MyApp.Comment do
  use MyApp.Schema

  schema "comments" do
    belongs_to :post, MyApp.Post
  end
end</code></pre> <p>Any schemas using <code class="inline">MyApp.Schema</code> will get the <code class="inline">:id</code> field with type <code class="inline">:binary_id</code> as the primary key. We explain what the <code class="inline">:binary_id</code> type entails in the next section.</p> <p>The <code class="inline">belongs_to</code> association on <code class="inline">MyApp.Comment</code> will also define a <code class="inline">:post_id</code> field with <code class="inline">:binary_id</code> type that references the <code class="inline">:id</code> field of the <code class="inline">MyApp.Post</code> schema.</p> <h2 id="module-primary-keys" class="section-heading">  Primary keys </h2> <p>Ecto supports two ID types, called <code class="inline">:id</code> and <code class="inline">:binary_id</code>, which are often used as the type for primary keys and associations.</p> <p>The <code class="inline">:id</code> type is used when the primary key is an integer while the <code class="inline">:binary_id</code> is used for primary keys in particular binary formats, which may be <a href="../ecto.uuid/"><code class="inline">Ecto.UUID</code></a> for databases like PostgreSQL and MySQL, or some specific ObjectID or RecordID often imposed by NoSQL databases.</p> <p>In both cases, both types have their semantics specified by the underlying adapter/database. If you use the <code class="inline">:id</code> type with <code class="inline">:autogenerate</code>, it means the database will be responsible for auto-generation of the id. This is often the case for primary keys in relational databases which are auto-incremented.</p> <p>Similarly, the <code class="inline">:binary_id</code> type may be generated in the adapter for cases like UUID but it may also be handled by the database if required. In any case, both scenarios are handled transparently by Ecto.</p> <p>Besides <code class="inline">:id</code> and <code class="inline">:binary_id</code>, which are often used by primary and foreign keys, Ecto provides a huge variety of types to be used by any column.</p> <h2 id="module-types-and-casting" class="section-heading">  Types and casting </h2> <p>When defining the schema, types need to be given. Types are split into two categories, primitive types and custom types.</p> <h3>Primitive types</h3> <p>The primitive types are:</p> <table> <colgroup> <col> <col> <col> </colgroup> <thead> <tr> <th style="text-align: left">Ecto type</th>
<th style="text-align: left">Elixir type</th>
<th style="text-align: left">Literal syntax in query</th> </tr> </thead> <tr> <td style="text-align: left"><code class="inline">:id</code></td>
<td style="text-align: left"><code class="inline">integer</code></td>
<td style="text-align: left">1, 2, 3</td> </tr> <tr> <td style="text-align: left"><code class="inline">:binary_id</code></td>
<td style="text-align: left"><code class="inline">binary</code></td>
<td style="text-align: left"><code class="inline">&lt;&lt;int, int, int, ...&gt;&gt;</code></td> </tr> <tr> <td style="text-align: left"><code class="inline">:integer</code></td>
<td style="text-align: left"><code class="inline">integer</code></td>
<td style="text-align: left">1, 2, 3</td> </tr> <tr> <td style="text-align: left"><code class="inline">:float</code></td>
<td style="text-align: left"><code class="inline">float</code></td>
<td style="text-align: left">1.0, 2.0, 3.0</td> </tr> <tr> <td style="text-align: left"><code class="inline">:boolean</code></td>
<td style="text-align: left"><code class="inline">boolean</code></td>
<td style="text-align: left">true, false</td> </tr> <tr> <td style="text-align: left"><code class="inline">:string</code></td>
<td style="text-align: left">UTF-8 encoded <code class="inline">string</code>
</td>
<td style="text-align: left">“hello”</td> </tr> <tr> <td style="text-align: left"><code class="inline">:binary</code></td>
<td style="text-align: left"><code class="inline">binary</code></td>
<td style="text-align: left"><code class="inline">&lt;&lt;int, int, int, ...&gt;&gt;</code></td> </tr> <tr> <td style="text-align: left"><code class="inline">{:array, inner_type}</code></td>
<td style="text-align: left"><code class="inline">list</code></td>
<td style="text-align: left"><code class="inline">[value, value, value, ...]</code></td> </tr> <tr> <td style="text-align: left"><code class="inline">:decimal</code></td>
<td style="text-align: left"><a href="https://github.com/ericmj/decimal" target="_blank"><code class="inline">Decimal</code></a></td>
<td style="text-align: left"></td> </tr> <tr> <td style="text-align: left"><code class="inline">:map</code></td>
<td style="text-align: left"><code class="inline">map</code></td>
<td style="text-align: left"></td> </tr> <tr> <td style="text-align: left"><code class="inline">{:map, inner_type}</code></td>
<td style="text-align: left"><code class="inline">map</code></td>
<td style="text-align: left"></td> </tr> </table> <p><strong>Note:</strong> For the <code class="inline">{:array, inner_type}</code> and <code class="inline">{:map, inner_type}</code> type, replace <code class="inline">inner_type</code> with one of the valid types, such as <code class="inline">:string</code>.</p> <h3>Custom types</h3> <p>Besides providing primitive types, Ecto allows custom types to be implemented by developers, allowing Ecto behaviour to be extended.</p> <p>A custom type is a module that implements the <a href="../ecto.type/"><code class="inline">Ecto.Type</code></a> behaviour. By default, Ecto provides the following custom types:</p> <table> <colgroup> <col> <col> <col> </colgroup> <thead> <tr> <th style="text-align: left">Custom type</th>
<th style="text-align: left">Database type</th>
<th style="text-align: left">Elixir type</th> </tr> </thead> <tr> <td style="text-align: left"><a href="../ecto.datetime/"><code class="inline">Ecto.DateTime</code></a></td>
<td style="text-align: left"><code class="inline">:datetime</code></td>
<td style="text-align: left"><code class="inline">%Ecto.DateTime{}</code></td> </tr> <tr> <td style="text-align: left"><a href="../ecto.date/"><code class="inline">Ecto.Date</code></a></td>
<td style="text-align: left"><code class="inline">:date</code></td>
<td style="text-align: left"><code class="inline">%Ecto.Date{}</code></td> </tr> <tr> <td style="text-align: left"><a href="../ecto.time/"><code class="inline">Ecto.Time</code></a></td>
<td style="text-align: left"><code class="inline">:time</code></td>
<td style="text-align: left"><code class="inline">%Ecto.Time{}</code></td> </tr> <tr> <td style="text-align: left"><a href="../ecto.uuid/"><code class="inline">Ecto.UUID</code></a></td>
<td style="text-align: left"><code class="inline">:uuid</code></td>
<td style="text-align: left"><code class="inline">uuid-string</code></td> </tr> </table> <p>Read the <a href="../ecto.type/"><code class="inline">Ecto.Type</code></a> documentation for more information on implementing your own types.</p> <p>Finally, schemas can also have virtual fields by passing the <code class="inline">virtual: true</code> option. These fields are not persisted to the database and can optionally not be type checked by declaring type <code class="inline">:any</code>.</p> <h3>The map type</h3> <p>The map type allows developers to store an Elixir map directly in the database:</p> <pre data-language="elixir"><code class="elixir"># In your migration
create table(:users) do
  add :data, :map
end

# In your schema
field :data, :map

# Now in your code
user = Repo.insert! %User{data: %{"foo" =&gt; "bar"}}</code></pre> <p>Keep in mind that we advise the map keys to be strings or integers instead of atoms. Atoms may be accepted depending on how maps are serialized but the database will always return atom keys as strings due to security reasons.</p> <p>In order to support maps, different databases may employ different techniques. For example, PostgreSQL will store those values in jsonb fields, allowing you to just query parts of it. MySQL and MSSQL, on the other hand, do not yet provide a JSON type, so the value will be stored in a text field.</p> <p>For maps to work in such databases, Ecto will need a JSON library. By default Ecto will use <a href="http://github.com/devinus/poison" target="_blank">Poison</a> which needs to be added your deps in <code class="inline">mix.exs</code>:</p> <pre data-language="elixir"><code class="elixir">{:poison, "~&gt; 1.0"}</code></pre> <p>You can however tell Ecto to use any other library by configuring it:</p> <pre data-language="elixir"><code class="elixir">config :ecto, :json_library, YourLibraryOfChoice</code></pre> <h3>Casting</h3> <p>When directly manipulating the struct, it is the responsibility of the developer to ensure the field values have the proper type. For example, you can create a user struct with an invalid value for <code class="inline">age</code>:</p> <pre data-language="elixir"><code class="iex elixir">iex&gt; user = %User{age: "0"}
iex&gt; user.age
"0"</code></pre> <p>However, if you attempt to persist the struct above, an error will be raised since Ecto validates the types when sending them to the adapter/database.</p> <p>Therefore, when working with and manipulating external data, it is recommended to use <a href="../ecto.changeset/"><code class="inline">Ecto.Changeset</code></a>’s that are able to filter and properly cast external data:</p> <pre data-language="elixir"><code class="elixir">changeset = Ecto.Changeset.cast(%User{}, %{"age" =&gt; "0"}, [:age])
user = Repo.insert!(changeset)</code></pre> <p><strong>You can use Ecto schemas and changesets to cast and validate any kind of data, regardless if the data will be persisted to an Ecto repository or not</strong>.</p> <h2 id="module-reflection" class="section-heading">  Reflection </h2> <p>Any schema module will generate the <code class="inline">__schema__</code> function that can be used for runtime introspection of the schema:</p> <ul> <li>
<code class="inline">__schema__(:source)</code> - Returns the source as given to <a href="#schema/2"><code class="inline">schema/2</code></a>; </li> <li>
<code class="inline">__schema__(:prefix)</code> - Returns optional prefix for source provided by <code class="inline">@schema_prefix</code> schema attribute; </li> <li>
<p><code class="inline">__schema__(:primary_key)</code> - Returns a list of primary key fields (empty if there is none);</p> </li> <li>
<code class="inline">__schema__(:fields)</code> - Returns a list of all non-virtual field names; </li> <li>
<code class="inline">__schema__(:type, field)</code> - Returns the type of the given non-virtual field; </li> <li>
<p><code class="inline">__schema__(:types)</code> - Returns a map of all non-virtual field names and their type;</p> </li> <li>
<code class="inline">__schema__(:associations)</code> - Returns a list of all association field names; </li> <li>
<p><code class="inline">__schema__(:association, assoc)</code> - Returns the association reflection of the given assoc;</p> </li> <li>
<code class="inline">__schema__(:embeds)</code> - Returns a list of all embedded field names; </li> <li>
<p><code class="inline">__schema__(:embed, embed)</code> - Returns the embedding reflection of the given embed;</p> </li> <li>
<p><code class="inline">__schema__(:read_after_writes)</code> - Non-virtual fields that must be read back from the database after every write (insert or update);</p> </li> <li>
<code class="inline">__schema__(:autogenerate_id)</code> - Primary key that is auto generated on insert; </li> </ul> <p>Furthermore, both <code class="inline">__struct__</code> and <code class="inline">__changeset__</code> functions are defined so structs and changeset functionalities are available.</p>   <h1 class="section-heading" id="summary">  Summary </h1> <h2> Types </h2>
<dl class="summary-types summary">   <dt class="summary-signature"> <a href="#t:t/0">t()</a> </dt>  </dl> <h2> Macros </h2>
<dl class="summary-macros summary">   <dt class="summary-signature"> <a href="#belongs_to/3">belongs_to(name, queryable, opts \\ [])</a> </dt> <dd class="summary-synopsis">
<p>Indicates a one-to-one or many-to-one association with another schema</p> </dd>   <dt class="summary-signature"> <a href="#embedded_schema/1">embedded_schema(list)</a> </dt> <dd class="summary-synopsis">
<p>Defines an embedded schema</p> </dd>   <dt class="summary-signature"> <a href="#embeds_many/3">embeds_many(name, schema, opts \\ [])</a> </dt> <dd class="summary-synopsis">
<p>Indicates an embedding of many schemas</p> </dd>   <dt class="summary-signature"> <a href="#embeds_one/3">embeds_one(name, schema, opts \\ [])</a> </dt> <dd class="summary-synopsis">
<p>Indicates an embedding of a schema</p> </dd>   <dt class="summary-signature"> <a href="#field/3">field(name, type \\ :string, opts \\ [])</a> </dt> <dd class="summary-synopsis">
<p>Defines a field on the schema with given name and type</p> </dd>   <dt class="summary-signature"> <a href="#has_many/3">has_many(name, queryable, opts \\ [])</a> </dt> <dd class="summary-synopsis">
<p>Indicates a one-to-many association with another schema</p> </dd>   <dt class="summary-signature"> <a href="#has_one/3">has_one(name, queryable, opts \\ [])</a> </dt> <dd class="summary-synopsis">
<p>Indicates a one-to-one association with another schema</p> </dd>   <dt class="summary-signature"> <a href="#many_to_many/3">many_to_many(name, queryable, opts \\ [])</a> </dt> <dd class="summary-synopsis">
<p>Indicates a many-to-many association with another schema</p> </dd>   <dt class="summary-signature"> <a href="#schema/2">schema(source, list)</a> </dt> <dd class="summary-synopsis">
<p>Defines a schema with a source name and field definitions</p> </dd>   <dt class="summary-signature"> <a href="#timestamps/1">timestamps(opts \\ [])</a> </dt> <dd class="summary-synopsis">
<p>Generates <code class="inline">:inserted_at</code> and <code class="inline">:updated_at</code> timestamp fields</p> </dd>  </dl>   <h1 class="section-heading" id="types">  Types </h1>  <div id="t:t/0" class="type-detail"> <pre data-language="elixir"><code class="elixir"><a href="#t:t/0">t</a> :: %atom{}</code></pre> </div>    <h1 class="section-heading" id="macros">  Macros </h1>  <h3 class="detail-header macro" id="belongs_to/3">  <span class="signature">belongs_to(name, queryable, opts \\ [])</span>  </h3>  <p>Indicates a one-to-one or many-to-one association with another schema.</p> <p>The current schema belongs to zero or one records of the other schema. The other schema often has a <code class="inline">has_one</code> or a <code class="inline">has_many</code> field with the reverse association.</p> <p>You should use <code class="inline">belongs_to</code> in the table that contains the foreign key. Imagine a company &lt;-&gt; manager relationship. If the company contains the <code class="inline">manager_id</code> in the underlying database table, we say the company belongs to manager.</p> <p>In fact, when you invoke this macro, a field with the name of foreign key is automatically defined in the schema for you.</p> <h4>Options</h4> <ul> <li>
<p><code class="inline">:foreign_key</code> - Sets the foreign key field name, defaults to the name of the association suffixed by <code class="inline">_id</code>. For example, <code class="inline">belongs_to :company</code> will define foreign key of <code class="inline">:company_id</code></p> </li> <li>
<p><code class="inline">:references</code> - Sets the key on the other schema to be used for the association, defaults to: <code class="inline">:id</code></p> </li> <li>
<p><code class="inline">:define_field</code> - When false, does not automatically define a <code class="inline">:foreign_key</code> field, implying the user is defining the field manually elsewhere</p> </li> <li>
<p><code class="inline">:type</code> - Sets the type of automatically defined <code class="inline">:foreign_key</code>. Defaults to: <code class="inline">:id</code> and can be set per schema via <code class="inline">@foreign_key_type</code></p> </li> <li>
<p><code class="inline">:on_replace</code> - The action taken on associations when the record is replaced when casting or manipulating parent changeset. May be <code class="inline">:raise</code> (default), <code class="inline">:mark_as_invalid</code>, <code class="inline">:nilify</code>, or <code class="inline">:delete</code>. See <a href="../ecto.changeset/"><code class="inline">Ecto.Changeset</code></a>’s section on related data for more info.</p> </li> <li>
<code class="inline">:defaults</code> - Default values to use when building the association </li> </ul> <p>All other options are forwarded to the underlying foreign key definition and therefore accept the same options as <a href="#field/3"><code class="inline">field/3</code></a>.</p> <h4>Examples</h4> <pre data-language="elixir"><code class="elixir">defmodule Comment do
  use Ecto.Schema

  schema "comments" do
    belongs_to :post, Post
  end
end

# The post can come preloaded on the comment record
[comment] = Repo.all(from(c in Comment, where: c.id == 42, preload: :post))
comment.post #=&gt; %Post{...}</code></pre> <h4>Polymorphic associations</h4> <p>One common use case for belongs to associations is to handle polymorphism. For example, imagine you have defined a Comment schema and you wish to use it for commenting on both tasks and posts.</p> <p>Some abstractions would force you to define some sort of polymorphic association with two fields in your database:</p> <pre data-language="elixir"><code class="elixir">* commentable_type
* commentable_id</code></pre> <p>The problem with this approach is that it breaks references in the database. You can’t use foreign keys and it is very inefficient, both in terms of query time and storage.</p> <p>In Ecto, we have three ways to solve this issue. The simplest is to define multiple fields in the Comment schema, one for each association:</p> <pre data-language="elixir"><code class="elixir">* task_id
* post_id</code></pre> <p>Unless you have dozens of columns, this is simpler for the developer, more DB friendly and more efficient in all aspects.</p> <p>Alternatively, because Ecto does not tie a schema to a given table, we can use separate tables for each association. Let’s start over and define a new Comment schema:</p> <pre data-language="elixir"><code class="elixir">defmodule Comment do
  use Ecto.Schema

  schema "abstract table: comments" do
    # This will be used by associations on each "concrete" table
    field :assoc_id, :integer
  end
end</code></pre> <p>Notice we have changed the table name to “abstract table: comments”. You can choose whatever name you want, the point here is that this particular table will never exist.</p> <p>Now in your Post and Task schemas:</p> <pre data-language="elixir"><code class="elixir">defmodule Post do
  use Ecto.Schema

  schema "posts" do
    has_many :comments, {"posts_comments", Comment}, foreign_key: :assoc_id
  end
end

defmodule Task do
  use Ecto.Schema

  schema "tasks" do
    has_many :comments, {"tasks_comments", Comment}, foreign_key: :assoc_id
  end
end</code></pre> <p>Now each association uses its own specific table, “posts_comments” and “tasks_comments”, which must be created on migrations. The advantage of this approach is that we never store unrelated data together, also ensuring we keep database references fast and correct.</p> <p>When using this technique, the only limitation is that you cannot build comments directly. For example, the command below</p> <pre data-language="elixir"><code class="elixir">Repo.insert!(%Comment{})</code></pre> <p>will attempt to use the abstract table. Instead, one should use</p> <pre data-language="elixir"><code class="elixir">Repo.insert!(build_assoc(post, :comments))</code></pre> <p>where <code class="inline">build_assoc/3</code> is defined in <a href="../ecto/"><code class="inline">Ecto</code></a>. You can also use <code class="inline">assoc/2</code> in both <a href="../ecto/"><code class="inline">Ecto</code></a> and in the query syntax to easily retrieve associated comments to a given post or task:</p> <pre data-language="elixir"><code class="elixir"># Fetch all comments associated to the given task
Repo.all(assoc(task, :comments))</code></pre> <p>Or all comments in a given table:</p> <pre data-language="elixir"><code class="elixir">Repo.all from(c in {"posts_comments", Comment}), ...)</code></pre> <p>The third and final option is to use <a href="#many_to_many/3"><code class="inline">many_to_many/3</code></a> to define the relationships between the resources. In this case, the comments table won’t have the foreign key, instead there is a intermediary table responsible for associating the entries:</p> <pre data-language="elixir"><code class="elixir">defmodule Comment do
  use Ecto.Schema
  schema "comments" do
    # ...
  end
end</code></pre> <p>In your posts and tasks:</p> <pre data-language="elixir"><code class="elixir">defmodule Post do
  use Ecto.Schema

  schema "posts" do
    many_to_many :comments, Comment, join_through: "posts_comments"
  end
end

defmodule Task do
  use Ecto.Schema

  schema "tasks" do
    many_to_many :comments, Comment, join_through: "tasks_comments"
  end
end</code></pre> <p>See <a href="#many_to_many/3"><code class="inline">many_to_many/3</code></a> for more information on this particular approach.</p>    <h3 class="detail-header macro" id="embedded_schema/1">  <span class="signature">embedded_schema(list)</span>  </h3>  <p>Defines an embedded schema.</p> <p>An embedded schema does not require a source name and it does not include a metadata field.</p> <p>Embedded schemas by default set the primary key type to <code class="inline">:binary_id</code> but such can be configured with the <code class="inline">@primary_key</code> attribute.</p>    <h3 class="detail-header macro" id="embeds_many/3">  <span class="signature">embeds_many(name, schema, opts \\ [])</span>  </h3>  <p>Indicates an embedding of many schemas.</p> <p>The current schema has zero or more records of the other schema embedded inside of it. Embeds have all the things regular schemas have.</p> <p>It is recommended to declare your <a href="#embeds_many/3"><code class="inline">embeds_many/3</code></a> field with type <code class="inline">{:array, :map}</code> and default value of <code class="inline">[]</code> at the database level. In fact, Ecto will automatically translate <code class="inline">nil</code> values from the database into empty lists for embeds many (this behaviour is specific to <a href="#embeds_many/3"><code class="inline">embeds_many/3</code></a> fields in order to mimic <a href="#has_many/3)"><code class="inline">has_many/3</code></a>.</p> <p>For encoding and decoding of embeds, please read the docs for <a href="#embeds_one/3"><code class="inline">embeds_one/3</code></a>.</p> <h4>Options</h4> <ul> <li>
<code class="inline">:on_replace</code> - The action taken on associations when the embed is replaced when casting or manipulating parent changeset. May be <code class="inline">:raise</code> (default), <code class="inline">:mark_as_invalid</code>, or <code class="inline">:delete</code>. See <a href="../ecto.changeset/"><code class="inline">Ecto.Changeset</code></a>’s section on related data for more info. </li> </ul> <h4>Examples</h4> <pre data-language="elixir"><code class="elixir">defmodule Order do
  use Ecto.Schema

  schema "orders" do
    embeds_many :items, Item
  end
end

defmodule Item do
  use Ecto.Schema

  embedded_schema do
    field :name
  end
end

# The items are loaded with the order
order = Repo.get!(Order, 42)
order.items #=&gt; [%Item{...}, ...]</code></pre> <p>Adding and removal of embeds can only be done via the <a href="../ecto.changeset/"><code class="inline">Ecto.Changeset</code></a> API so Ecto can properly track the embed life-cycle:</p> <pre data-language="elixir"><code class="elixir">order = Repo.get!(Order, 42)

# Generate a changeset
changeset = Ecto.Changeset.change(order)

# Change, put a new one or remove all items
changeset = Ecto.Changeset.put_change(changeset, :items, [])

# Update the order
changeset = Repo.update!(changeset)</code></pre>    <h3 class="detail-header macro" id="embeds_one/3">  <span class="signature">embeds_one(name, schema, opts \\ [])</span>  </h3>  <p>Indicates an embedding of a schema.</p> <p>The current schema has zero or one records of the other schema embedded inside of it. It uses a field similar to the <code class="inline">:map</code> type for storage, but allows embeds to have all the things regular schema can.</p> <p>You must declare your <a href="#embeds_one/3"><code class="inline">embeds_one/3</code></a> field with type <code class="inline">:map</code> at the database level.</p> <h4>Options</h4> <ul> <li>
<code class="inline">:on_replace</code> - The action taken on associations when the embed is replaced when casting or manipulating parent changeset. May be <code class="inline">:raise</code> (default), <code class="inline">:mark_as_invalid</code>, or <code class="inline">:delete</code>. See <a href="../ecto.changeset/"><code class="inline">Ecto.Changeset</code></a>’s section on related data for more info. </li> </ul> <h4>Examples</h4> <pre data-language="elixir"><code class="elixir">defmodule Order do
  use Ecto.Schema

  schema "orders" do
    embeds_one :item, Item
  end
end

defmodule Item do
  use Ecto.Schema

  # A required field for all embedded documents
  @primary_key {:id, :binary_id, autogenerate: true}
  schema "" do
    field :name
  end
end

# The item is loaded with the order
order = Repo.get!(Order, 42)
order.item #=&gt; %Item{...}</code></pre> <p>Adding and removal of embeds can only be done via the <a href="../ecto.changeset/"><code class="inline">Ecto.Changeset</code></a> API so Ecto can properly track the embed life-cycle:</p> <pre data-language="elixir"><code class="elixir">order = Repo.get!(Order, 42)

# Generate a changeset
changeset = Ecto.Changeset.change(order)

# Change, put a new one or remove an item
changeset = Ecto.Changeset.put_change(changeset, :item, nil)

# Update the order
changeset = Repo.update!(changeset)</code></pre> <h4>Encoding and decoding</h4> <p>Because many databases do not support direct encoding and decoding of embeds, it is often emulated by Ecto by using specific encoding and decoding rules.</p> <p>For example, PostgreSQL will store embeds on top of JSONB columns, which means types in embedded schemas won’t go through the usual dump-&gt;DB-&gt;load cycle but rather encode-&gt;DB-&gt;decode-&gt;cast. This means that, when using embedded schemas with databases like PG or MySQL, make sure all of your types can be JSON encoded/decoded correctly. Ecto provides this guarantee for all built-in types.</p>    <h3 class="detail-header macro" id="field/3">  <span class="signature">field(name, type \\ :string, opts \\ [])</span>  </h3>  <p>Defines a field on the schema with given name and type.</p> <h4>Options</h4> <ul> <li>
<p><code class="inline">:default</code> - Sets the default value on the schema and the struct. The default value is calculated at compilation time, so don’t use expressions like <code class="inline">Ecto.DateTime.utc</code> or <code class="inline">Ecto.UUID.generate</code> as they would then be the same for all records</p> </li> <li>
<p><code class="inline">:autogenerate</code> - Annotates the field to be autogenerated before insertion if value is not set. It will call the <code class="inline">autogenerate/0</code> function in the field’s type.</p> </li> <li>
<p><code class="inline">:read_after_writes</code> - When true, the field is always read back from the database after insert and updates.</p> <p>For relational databases, this means the RETURNING option of those statements is used. For this reason, MySQL does not support this option and will raise an error if a schema is inserted/updated with read after writes fields.</p> </li> <li>
<code class="inline">:virtual</code> - When true, the field is not persisted to the database. Notice virtual fields do not support <code class="inline">:autogenerate</code> nor <code class="inline">:read_after_writes</code>. </li> </ul>    <h3 class="detail-header macro" id="has_many/3">  <span class="signature">has_many(name, queryable, opts \\ [])</span>  </h3>  <p>Indicates a one-to-many association with another schema.</p> <p>The current schema has zero or more records of the other schema. The other schema often has a <code class="inline">belongs_to</code> field with the reverse association.</p> <h4>Options</h4> <ul> <li>
<p><code class="inline">:foreign_key</code> - Sets the foreign key, this should map to a field on the other schema, defaults to the underscored name of the current schema suffixed by <code class="inline">_id</code></p> </li> <li>
<p><code class="inline">:references</code> - Sets the key on the current schema to be used for the association, defaults to the primary key on the schema</p> </li> <li>
<p><code class="inline">:through</code> - If this association must be defined in terms of existing associations. Read below for more information</p> </li> <li>
<p><code class="inline">:on_delete</code> - The action taken on associations when parent record is deleted. May be <code class="inline">:nothing</code> (default), <code class="inline">:nilify_all</code> and <code class="inline">:delete_all</code>. Notice <code class="inline">:on_delete</code> may also be set in migrations when creating a reference. If supported, relying on the database via migrations is preferred. <code class="inline">:nilify_all</code> and <code class="inline">:delete_all</code> will not cascade to child records unless set via database migrations.</p> </li> <li>
<p><code class="inline">:on_replace</code> - The action taken on associations when the record is replaced when casting or manipulating parent changeset. May be <code class="inline">:raise</code> (default), <code class="inline">:mark_as_invalid</code>, <code class="inline">:nilify</code>, or <code class="inline">:delete</code>. See <a href="../ecto.changeset/"><code class="inline">Ecto.Changeset</code></a>’s section on related data for more info.</p> </li> <li>
<code class="inline">:defaults</code> - Default values to use when building the association </li> </ul> <h4>Examples</h4> <pre data-language="elixir"><code class="elixir">defmodule Post do
  use Ecto.Schema
  schema "posts" do
    has_many :comments, Comment
  end
end

# Get all comments for a given post
post = Repo.get(Post, 42)
comments = Repo.all assoc(post, :comments)

# The comments can come preloaded on the post struct
[post] = Repo.all(from(p in Post, where: p.id == 42, preload: :comments))
post.comments #=&gt; [%Comment{...}, ...]</code></pre> <h4>has_many/has_one :through</h4> <p>Ecto also supports defining associations in terms of other associations via the <code class="inline">:through</code> option. Let’s see an example:</p> <pre data-language="elixir"><code class="elixir">defmodule Post do
  use Ecto.Schema

  schema "posts" do
    has_many :comments, Comment
    has_one :permalink, Permalink

    # In the has_many :through example below, the `:comments`
    # in the list [:comments, :author] refers to the
    # `has_many :comments` in the Post own schema and the
    # `:author` refers to the `belongs_to :author` of the
    # Comment's schema (the module below).
    # (see the description below for more details)
    has_many :comments_authors, through: [:comments, :author]

    # Specify the association with custom source
    has_many :tags, {"posts_tags", Tag}
  end
end

defmodule Comment do
  use Ecto.Schema

  schema "comments" do
    belongs_to :author, Author
    belongs_to :post, Post
    has_one :post_permalink, through: [:post, :permalink]
  end
end</code></pre> <p>In the example above, we have defined a <code class="inline">has_many :through</code> association named <code class="inline">:comments_authors</code>. A <code class="inline">:through</code> association always expects a list and the first element of the list must be a previously defined association in the current module. For example, <code class="inline">:comments_authors</code> first points to <code class="inline">:comments</code> in the same module (Post), which then points to <code class="inline">:author</code> in the next schema, <code class="inline">Comment</code>.</p> <p>This <code class="inline">:through</code> association will return all authors for all comments that belongs to that post:</p> <pre data-language="elixir"><code class="elixir"># Get all comments for a given post
post = Repo.get(Post, 42)
authors = Repo.all assoc(post, :comments_authors)</code></pre> <p><code class="inline">:through</code> associations are read-only as they are useful for avoiding repetition, allowing the developer to easily retrieve data that is often seen together but stored across different tables.</p> <p><code class="inline">:through</code> associations can also be preloaded. In such cases, not only the <code class="inline">:through</code> association is preloaded but all intermediate steps are preloaded too:</p> <pre data-language="elixir"><code class="elixir">[post] = Repo.all(from(p in Post, where: p.id == 42, preload: :comments_authors))
post.comments_authors #=&gt; [%Author{...}, ...]

# The comments for each post will be preloaded too
post.comments #=&gt; [%Comment{...}, ...]

# And the author for each comment too
hd(post.comments).author #=&gt; %Author{...}</code></pre> <p>Finally, <code class="inline">:through</code> can be used with multiple associations (not only 2) and with associations of any kind, including <code class="inline">belongs_to</code> and other <code class="inline">:through</code> associations. When the <code class="inline">:through</code> association is expected to return one or zero items, <code class="inline">has_one :through</code> should be used instead, as in the example at the beginning of this section:</p> <pre data-language="elixir"><code class="elixir"># How we defined the association above
has_one :post_permalink, through: [:post, :permalink]

# Get a preloaded comment
[comment] = Repo.all(Comment) |&gt; Repo.preload(:post_permalink)
comment.post_permalink #=&gt; %Permalink{...}</code></pre>    <h3 class="detail-header macro" id="has_one/3">  <span class="signature">has_one(name, queryable, opts \\ [])</span>  </h3>  <p>Indicates a one-to-one association with another schema.</p> <p>The current schema has zero or one records of the other schema. The other schema often has a <code class="inline">belongs_to</code> field with the reverse association.</p> <h4>Options</h4> <ul> <li>
<p><code class="inline">:foreign_key</code> - Sets the foreign key, this should map to a field on the other schema, defaults to the underscored name of the current schema suffixed by <code class="inline">_id</code></p> </li> <li>
<p><code class="inline">:references</code> - Sets the key on the current schema to be used for the association, defaults to the primary key on the schema</p> </li> <li>
<p><code class="inline">:through</code> - If this association must be defined in terms of existing associations. Read the section in <a href="#has_many/3"><code class="inline">has_many/3</code></a> for more information</p> </li> <li>
<p><code class="inline">:on_delete</code> - The action taken on associations when parent record is deleted. May be <code class="inline">:nothing</code> (default), <code class="inline">:nilify_all</code> and <code class="inline">:delete_all</code>. Notice <code class="inline">:on_delete</code> may also be set in migrations when creating a reference. If supported, relying on the database via migrations is preferred. <code class="inline">:nilify_all</code> and <code class="inline">:delete_all</code> will not cascade to child records unless set via database migrations.</p> </li> <li>
<p><code class="inline">:on_replace</code> - The action taken on associations when the record is replaced when casting or manipulating parent changeset. May be <code class="inline">:raise</code> (default), <code class="inline">:mark_as_invalid</code>, <code class="inline">:nilify</code>, or <code class="inline">:delete</code>. See <a href="../ecto.changeset/"><code class="inline">Ecto.Changeset</code></a>’s section on related data for more info.</p> </li> <li>
<code class="inline">:defaults</code> - Default values to use when building the association </li> </ul> <h4>Examples</h4> <pre data-language="elixir"><code class="elixir">defmodule Post do
  use Ecto.Schema

  schema "posts" do
    has_one :permalink, Permalink

    # Specify the association with custom source
    has_one :category, {"posts_categories", Category}
  end
end

# The permalink can come preloaded on the post struct
[post] = Repo.all(from(p in Post, where: p.id == 42, preload: :permalink))
post.permalink #=&gt; %Permalink{...}</code></pre>    <h3 class="detail-header macro" id="many_to_many/3">  <span class="signature">many_to_many(name, queryable, opts \\ [])</span>  </h3>  <p>Indicates a many-to-many association with another schema.</p> <p>The association happens through a join schema or source, containing foreign keys to the associated schemas. For example, the association below:</p> <pre data-language="elixir"><code class="elixir"># from MyApp.Post
many_to_many :tags, MyApp.Tag, join_through: "posts_tags"</code></pre> <p>is backed by relational databases through a join table as follows:</p> <pre data-language="elixir"><code class="elixir">[Post] &lt;-&gt; [posts_tags] &lt;-&gt; [Tag]
  id   &lt;--   post_id
              tag_id    --&gt;  id</code></pre> <p>More information on the migration for creating such a schema is shown below.</p> <h4>Options</h4> <ul> <li>
<p><code class="inline">:join_through</code> - specifies the source of the associated data. It may be a string, like “posts_tags”, representing the underlying storage table or an atom, like <code class="inline">MyApp.PostTag</code>, representing a schema. This option is required.</p> </li> <li>
<p><code class="inline">:join_keys</code> - specifies how the schemas are associated. It expects a keyword list with two entries, the first being how the join table should reach the current schema and the second how the join table should reach the associated schema. In the example above, it defaults to: <code class="inline">[post_id: :id, tag_id: :id]</code>. The keys are inflected from the schema names.</p> </li> <li>
<p><code class="inline">:on_delete</code> - The action taken on associations when the parent record is deleted. May be <code class="inline">:nothing</code> (default) or <code class="inline">:delete_all</code>. <code class="inline">:delete_all</code> will only remove data from the join source, never the associated records. Notice <code class="inline">:on_delete</code> may also be set in migrations when creating a reference. If supported, relying on the database via migrations is preferred. <code class="inline">:nilify_all</code> and <code class="inline">:delete_all</code> will not cascade to child records unless set via database migrations.</p> </li> <li>
<p><code class="inline">:on_replace</code> - The action taken on associations when the record is replaced when casting or manipulating parent changeset. May be <code class="inline">:raise</code> (default), <code class="inline">:mark_as_invalid</code>, or <code class="inline">:delete</code>. <code class="inline">:delete</code> will only remove data from the join source, never the associated records. See <a href="../ecto.changeset/"><code class="inline">Ecto.Changeset</code></a>’s section on related data for more info.</p> </li> <li>
<code class="inline">:defaults</code> - Default values to use when building the association </li> </ul> <h4>Removing data</h4> <p>If you attempt to remove associated <code class="inline">many_to_many</code> data, <strong>Ecto will always remove data from the join schema and never from the target associations</strong> be it by setting <code class="inline">:on_replace</code> to <code class="inline">:delete</code>, <code class="inline">:on_delete</code> to <code class="inline">:delete_all</code> or by using changeset functions such as <code class="inline">Ecto.Changeset.put_assoc/3</code>. For example, if a <code class="inline">Post</code> has a many to many relationship with <code class="inline">Tag</code>, setting <code class="inline">:on_delete</code> to <code class="inline">:delete_all</code> will only delete entries from the “posts_tags” table in case <code class="inline">Post</code> is deleted.</p> <h4>Migration</h4> <p>How your migration should be structured depends on the value you pass in <code class="inline">:join_through</code>. If <code class="inline">:join_through</code> is simply a string, representing a table, you may define a table without primary keys and you must not include any further columns, as those values won’t be set by Ecto:</p> <pre data-language="elixir"><code class="elixir">create table(:posts_tags, primary_key: false) do
  add :post_id, references(:posts)
  add :tag_id, references(:tags)
end</code></pre> <p>However, if your <code class="inline">:join_through</code> is a schema, like <code class="inline">MyApp.PostTag</code>, your join table may be structured as any other table in your codebase, including timestamps:</p> <pre data-language="elixir"><code class="elixir">create table(:posts_tags) do
  add :post_id, references(:posts)
  add :tag_id, references(:tags)
  timestamps
end</code></pre> <p>Because <code class="inline">:join_through</code> contains a schema, in such cases, autogenerated values and primary keys will be automatically handled by Ecto.</p> <h4>Examples</h4> <pre data-language="elixir"><code class="elixir">defmodule Post do
  use Ecto.Schema
  schema "posts" do
    many_to_many :tags, Tag, join_through: "posts_tags"
  end
end

# Let's create a post and a tag
post = Repo.insert!(%Post{})
tag = Repo.insert!(%Tag{name: "introduction"})

# We can associate at any time post and tags together using changesets
post
|&gt; Repo.preload(:tags) # Load existing data
|&gt; Ecto.Changeset.change() # Build the changeset
|&gt; Ecto.Changeset.put_assoc(:tags, [tag]) # Set the association
|&gt; Repo.update!

# In a later moment, we may get all tags for a given post
post = Repo.get(Post, 42)
tags = Repo.all(assoc(post, :tags))

# The tags may also be preloaded on the post struct for reading
[post] = Repo.all(from(p in Post, where: p.id == 42, preload: :tags))
post.tags #=&gt; [%Tag{...}, ...]</code></pre> <h4>Join Schema Example</h4> <p>You may prefer to use a join schema to handle many_to_many associations. The decoupled nature of Ecto allows us to create a “join” struct which <code class="inline">belongs_to</code> both sides of the many to many association.</p> <p>In our example, a User has and belongs to many Organizations</p> <pre data-language="elixir"><code class="elixir">defmodule UserOrganization do
  use Ecto.Schema

  @primary_key false
  schema "user_organisation" do
    belongs_to :user, User
    belongs_to :organization, Organization
    timestamps # Added bonus, a join schema will also allow you to set timestamps
  end

  def changeset(struct, params \\ %{}) do
    struct
    |&gt; cast(params, [:user_id, :organization_id])
    |&gt; validate_required([:user_id, :organization_id])
    # Maybe do some counter caching here!
  end
end

defmodule User do
  use Ecto.Schema

  schema "users" do
    many_to_many :organizations, join_through: UserOrganization
  end
end

defmodule Organization do
  use Ecto.Schema

  schema "organizations" do
    many_to_many :users, join_through: UserOrganization
  end
end

# Then to create the association, pass in the ID's of an existing
# User and Organization to UserOrganization.changeset
changeset = UserOrganization.changeset(%UserOrganization{}, %{user_id: id, organization_id: id})

case Repo.insert(changeset) do
  {:ok, assoc} -&gt; # Assoc was created!
  {:error, changeset} -&gt; # Handle the error
end</code></pre>    <h3 class="detail-header macro" id="schema/2">  <span class="signature">schema(source, list)</span>  </h3>  <p>Defines a schema with a source name and field definitions.</p>    <h3 class="detail-header macro" id="timestamps/1">  <span class="signature">timestamps(opts \\ [])</span>  </h3>  <p>Generates <code class="inline">:inserted_at</code> and <code class="inline">:updated_at</code> timestamp fields.</p> <p>The fields generated by this macro will automatically be set to the current time when inserting and updating values in a repository.</p> <h4>Options</h4> <ul> <li>
<code class="inline">:type</code> - the timestamps type, defaults to <a href="../ecto.datetime/"><code class="inline">Ecto.DateTime</code></a>. </li> <li>
<code class="inline">:usec</code> - boolean, sets whether microseconds are used in timestamps. Microseconds will be 0 if false. Defaults to false. </li> <li>
<code class="inline">:inserted_at</code> - the name of the column for insertion times or <code class="inline">false</code> </li> <li>
<code class="inline">:updated_at</code> - the name of the column for update times or <code class="inline">false</code> </li> <li>
<code class="inline">:autogenerate</code> - a module-function-args tuple used for generating both <code class="inline">inserted_at</code> and <code class="inline">updated_at</code> timestamps </li> </ul> <p>All options can be pre-configured by setting <code class="inline">@timestamps_opts</code>.</p>
<div class="_attribution">
  <p class="_attribution-p">
    © 2012 Plataformatec<br>Licensed under the Apache License, Version 2.0.<br>
    <a href="https://hexdocs.pm/ecto/Ecto.Schema.html" class="_attribution-link" target="_blank">https://hexdocs.pm/ecto/Ecto.Schema.html</a>
  </p>
</div>

			</div>
		</div>
	</section>

	</div>
</body>
</html>
